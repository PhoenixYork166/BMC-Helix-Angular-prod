{"version":3,"file":"default-expression-evaluator.service.js","sourceRoot":"","sources":["../../../../../../../libs/platform/view/api/expressions/default-expression-evaluator.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { BinaryExpression, CallExpression, Expression, Identifier, Literal, UnaryExpression } from 'jsep';\nimport { every, find, forEach, includes, isNaN, isNil, isString, isUndefined, result, trim } from 'lodash';\nimport { RxExpressionHelperService } from './expression-helper.service';\nimport { RxExpressionSyntaxTreeBuilderService } from './expression-syntax-tree-builder.service';\nimport { IExpressionEvaluator } from './expression-evaluator.types';\nimport { Injectable } from '@angular/core';\nimport { RxStringService } from '@helix/platform/utils';\nimport BigNumber from 'bignumber.js';\nimport { ExpressionOperator } from '@helix/platform/shared/api';\nimport { RX_EXPRESSION_FUNCTIONS, RX_SUPPORTED_FUNCTION } from './expression-functions.constant';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RxDefaultExpressionEvaluatorService implements IExpressionEvaluator {\n  private parsedExpressionCache = {};\n\n  private operators = {\n    [ExpressionOperator.Equal]: (a, b) => {\n      if (BigNumber.isBigNumber(a)) {\n        return a.isEqualTo(b);\n      } else if (BigNumber.isBigNumber(b)) {\n        return b.isEqualTo(a);\n      } else {\n        // tslint:disable-next-line:triple-equals\n        return a == b;\n      }\n    },\n    [ExpressionOperator.Add]: (a, b) => {\n      if ((isNil(a) || isNaN(a)) && (isNil(b) || isNaN(b))) {\n        return null;\n      } else if ((isNil(a) || isNaN(a)) && !(isNil(b) || isNaN(b))) {\n        return BigNumber.isBigNumber(b) ? Number(b) : b;\n      } else if ((isNil(b) || isNaN(b)) && !(isNil(a) || isNaN(a))) {\n        return BigNumber.isBigNumber(a) ? Number(a) : a;\n      }\n\n      // Have to convert BigNumber values to Number in order to use mathimatical addition as opposed to\n      // string concatenation, which will otherwise happen due to BigNumber.valueOf() returning a string.\n      a = BigNumber.isBigNumber(a) ? Number(a) : a;\n      b = BigNumber.isBigNumber(b) ? Number(b) : b;\n\n      return a + b;\n    },\n    [ExpressionOperator.Subtract]: (a, b) => {\n      if (isUndefined(a) || isNaN(a)) {\n        a = 0;\n      }\n\n      if (isUndefined(b) || isNaN(b)) {\n        b = 0;\n      }\n\n      return a - b;\n    },\n    [ExpressionOperator.Multiply]: (a, b) => {\n      if (isUndefined(a) || isNaN(a)) {\n        a = 0;\n      }\n\n      if (isUndefined(b) || isNaN(b)) {\n        b = 0;\n      }\n\n      return a * b;\n    },\n    [ExpressionOperator.Divide]: (a, b) => {\n      if (isUndefined(a) || isUndefined(b) || isNaN(a) || isNaN(b)) {\n        return 0;\n      }\n\n      return a / b;\n    },\n    [ExpressionOperator.LessThan]: (a, b) => {\n      if (BigNumber.isBigNumber(a)) {\n        return a.lt(b);\n      } else if (BigNumber.isBigNumber(b)) {\n        return b.gt(a);\n      } else {\n        return a < b;\n      }\n    },\n    [ExpressionOperator.GreaterThan]: (a, b) => {\n      if (BigNumber.isBigNumber(a)) {\n        return a.gt(b);\n      } else if (BigNumber.isBigNumber(b)) {\n        return b.lt(a);\n      } else {\n        return a > b;\n      }\n    },\n    [ExpressionOperator.GreaterThanOrEqual]: (a, b) => {\n      if (BigNumber.isBigNumber(a)) {\n        return a.gte(b);\n      } else if (BigNumber.isBigNumber(b)) {\n        return b.lte(a);\n      } else {\n        return a >= b;\n      }\n    },\n    [ExpressionOperator.LessThanOrEqual]: (a, b) => {\n      if (BigNumber.isBigNumber(a)) {\n        return a.lte(b);\n      } else if (BigNumber.isBigNumber(b)) {\n        return b.gte(a);\n      } else {\n        return a <= b;\n      }\n    },\n    [ExpressionOperator.NotEqual]: (a, b) => {\n      if (BigNumber.isBigNumber(a)) {\n        return !a.isEqualTo(b);\n      } else if (BigNumber.isBigNumber(b)) {\n        return !b.isEqualTo(a);\n      } else {\n        // tslint:disable-next-line:triple-equals\n        return a != b;\n      }\n    },\n    [ExpressionOperator.Remainder]: (a, b) => {\n      if (isUndefined(a) || isUndefined(b) || isNaN(a) || isNaN(b)) {\n        return 0;\n      }\n\n      return a % b;\n    },\n    [ExpressionOperator.And]: this.andHandler,\n    [ExpressionOperator.And.toLowerCase()]: this.andHandler,\n    [ExpressionOperator.Or]: this.orHandler,\n    [ExpressionOperator.Or.toLowerCase()]: this.orHandler,\n    [ExpressionOperator.Like]: this.likeHandler,\n    [ExpressionOperator.Like.toLowerCase()]: this.likeHandler,\n    [ExpressionOperator.Contains]: this.likeHandler,\n    [ExpressionOperator.Contains.toLowerCase()]: this.likeHandler\n  };\n\n  private unaryOperators = {\n    '-': (value) => {\n      if (isUndefined(value) || isNaN(value)) {\n        return 0;\n      } else {\n        return -Number(value);\n      }\n    },\n    '!': (value) => !Boolean(value)\n  };\n\n  constructor(\n    private rxExpressionHelperService: RxExpressionHelperService,\n    private rxStringService: RxStringService,\n    private rxExpressionSyntaxTreeBuilderService: RxExpressionSyntaxTreeBuilderService\n  ) {}\n\n  parseExpression(expression: string): Expression {\n    if (!this.parsedExpressionCache[expression]) {\n      const parsedExpression = this.rxExpressionSyntaxTreeBuilderService.buildTree(expression);\n\n      if (this.validateChildNodeTypes(parsedExpression)) {\n        this.parsedExpressionCache[expression] = parsedExpression;\n      } else {\n        throw new Error('Invalid syntax');\n      }\n    }\n\n    return this.parsedExpressionCache[expression];\n  }\n\n  evaluate(expression: string, data: object) {\n    let evaluatedExpression = expression;\n\n    expression = trim(expression);\n\n    if (this.rxStringService.isNonEmptyString(expression)) {\n      const preparedExpression = this.rxExpressionHelperService.prepare(expression);\n      let parsedExpression;\n\n      try {\n        parsedExpression = this.parseExpression(preparedExpression);\n      } catch (e) {\n        throw new Error(`Cannot parse expression \"${expression}\": ${e.message}.`);\n      }\n\n      try {\n        evaluatedExpression = this.evaluateNode(parsedExpression, data || {});\n      } catch (e) {\n        throw new Error(`Cannot evaluate expression \"${expression}\": ${e.message}.`);\n      }\n    } else {\n      evaluatedExpression = null;\n    }\n\n    return evaluatedExpression;\n  }\n\n  private andHandler(a, b): boolean {\n    return Boolean(a) && Boolean(b);\n  }\n\n  private orHandler(a, b): boolean {\n    return Boolean(a) || Boolean(b);\n  }\n\n  private likeHandler(a, b): boolean {\n    return includes(a, b);\n  }\n\n  private validateChildNodeTypes(node: Expression): boolean {\n    let isValid = false;\n\n    switch (node.type) {\n      case 'BinaryExpression':\n        isValid =\n          this.validateChildNodeTypes((node as BinaryExpression).left) &&\n          this.validateChildNodeTypes((node as BinaryExpression).right);\n        break;\n\n      case 'UnaryExpression':\n        isValid = this.validateChildNodeTypes((node as UnaryExpression).argument);\n        break;\n\n      case 'CallExpression':\n        isValid = false;\n\n        const functionNode = node as CallExpression;\n        const functionDescriptor = find(RX_EXPRESSION_FUNCTIONS, { name: functionNode.callee['name'] });\n\n        if (functionDescriptor && functionNode.arguments.length === functionDescriptor.parameters.length) {\n          isValid = every(functionNode.arguments, (argument) => this.validateChildNodeTypes(argument));\n        }\n\n        break;\n\n      case 'Literal':\n        isValid = true;\n        break;\n\n      case 'Identifier':\n        isValid = /^\\$[A-Za-z]+\\$$/.test((node as Identifier).name);\n        break;\n    }\n\n    return isValid;\n  }\n\n  private evaluateNode(node: Expression, data: object) {\n    switch (node.type) {\n      case 'BinaryExpression':\n        const left = this.evaluateNode((node as BinaryExpression).left, data);\n        const right = this.evaluateNode((node as BinaryExpression).right, data);\n\n        if (this.operators[(node as BinaryExpression).operator]) {\n          const binaryResult = this.operators[(node as BinaryExpression).operator](left, right);\n\n          if (isNaN(binaryResult)) {\n            throw new Error(\n              `Operator: ${(node as BinaryExpression).operator} has invalid arguments: ${left}, ${right}`\n            );\n          } else {\n            return binaryResult;\n          }\n        } else {\n          throw new Error(`Unknown binary operator: ${(node as BinaryExpression).operator}`);\n        }\n\n      case 'CallExpression':\n        let evaluatedArguments = [];\n        const functionName = (node as CallExpression).callee['name'];\n\n        evaluatedArguments = (node as CallExpression).arguments.map((argument) => this.evaluateNode(argument, data));\n\n        if (RX_SUPPORTED_FUNCTION[functionName]) {\n          return RX_SUPPORTED_FUNCTION[functionName](...evaluatedArguments);\n        } else {\n          throw new Error(`Unknown function: ${functionName}`);\n        }\n\n      case 'Literal':\n        let nodeValue = (node as Literal).value;\n\n        if (isString(nodeValue as string)) {\n          if (/^rx-\\${[^{}$]+}$/.test(nodeValue as string)) {\n            nodeValue = result(data, (nodeValue as string).slice(5, -1));\n          } else {\n            const expressions = (nodeValue as string).match(/(rx-\\${[^{}$]+})/g);\n\n            forEach(expressions, (expression) => {\n              const value = result<any>(data, expression.slice(5, -1));\n\n              nodeValue = (nodeValue as string).replace(expression, isNil(value) ? '' : value);\n            });\n          }\n        }\n\n        return nodeValue;\n\n      case 'UnaryExpression':\n        if (this.unaryOperators[(node as UnaryExpression).operator]) {\n          const evaluatedResult = this.evaluateNode((node as UnaryExpression).argument, data);\n          const unaryResult = this.unaryOperators[(node as UnaryExpression).operator](evaluatedResult);\n\n          if (isNaN(unaryResult)) {\n            throw new Error(`Operator: ${(node as UnaryExpression).operator} has invalid argument: ${evaluatedResult}`);\n          } else {\n            return unaryResult;\n          }\n        } else {\n          throw new Error(`Unknown unary operator: ${(node as UnaryExpression).operator}`);\n        }\n\n      default:\n        throw new Error('Invalid syntax');\n    }\n  }\n}\n"]}