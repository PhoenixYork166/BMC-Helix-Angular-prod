{"version":3,"file":"view-expression-configurator.class.js","sourceRoot":"","sources":["../../../../../../../libs/platform/view/designer/expression-configurator/view-expression-configurator.class.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,6BAA6B,EAC7B,uBAAuB,EAEvB,wBAAwB,EACzB,MAAM,4BAA4B,CAAC;AACpC,OAAO,EAAE,EAAE,EAAE,MAAM,MAAM,CAAC;AAE1B,OAAO,EAAwB,yBAAyB,EAAE,MAAM,0BAA0B,CAAC;AAE3F,MAAM,OAAgB,4BAA6B,SAAQ,wBAAwB;IAKjF,YAAsB,QAAkB;QACtC,KAAK,EAAE,CAAC;QADY,aAAQ,GAAR,QAAQ,CAAU;QAJhC,8BAAyB,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAA4B,yBAAyB,CAAC,CAAC;IAM5G,CAAC;IAED,gBAAgB;QACd,uCACK,KAAK,CAAC,gBAAgB,EAAE,KAC3B,eAAe,EAAE,IAAI,CAAC,qBAAqB,EAC3C,SAAS,EAAE,6BAA6B,CAAC,GAAG,CAAC,uBAAuB,CAAC,SAAS,CAAC,EAE/E,kBAAkB,EAAE,CAAC,YAAY,EAAE,UAAU,EAAE,EAAE;gBAC/C,IAAI,OAAO,GAAG,IAAI,CAAC;gBAEnB,MAAM,mBAAmB,GAAG,IAAI,CAAC,sBAAsB,CAAC,YAAY,CAAC,CAAC;gBAEtE,IAAI;oBACF,mBAAmB,CAAC,eAAe,CAAC,IAAI,CAAC,yBAAyB,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;iBACzF;gBAAC,OAAO,CAAC,EAAE;oBACV,OAAO,GAAG,KAAK,CAAC;iBACjB;gBAED,OAAO,EAAE,CAAC,OAAO,CAAC,CAAC;YACrB,CAAC,IACD;IACJ,CAAC;CACF","sourcesContent":["import {\n  ExpressionOperatorRowsByGroup,\n  ExpressionOperatorGroup,\n  IExpressionConfiguratorDefaultPropertyConfig,\n  RxExpressionConfigurator\n} from '@helix/platform/shared/api';\nimport { of } from 'rxjs';\nimport { Injector } from '@angular/core';\nimport { IExpressionEvaluator, RxExpressionHelperService } from '@helix/platform/view/api';\n\nexport abstract class RxViewExpressionConfigurator extends RxExpressionConfigurator {\n  private rxExpressionHelperService = this.injector.get<RxExpressionHelperService>(RxExpressionHelperService);\n\n  abstract getExpressionEvaluator(propertyName: string): IExpressionEvaluator;\n\n  constructor(protected injector: Injector) {\n    super();\n  }\n\n  getDefaultConfig(): IExpressionConfiguratorDefaultPropertyConfig {\n    return {\n      ...super.getDefaultConfig(),\n      dataDictionary$: this.commonDataDictionary$,\n      operators: ExpressionOperatorRowsByGroup.get(ExpressionOperatorGroup.AllClient),\n\n      validateExpression: (propertyName, expression) => {\n        let isValid = true;\n\n        const expressionEvaluator = this.getExpressionEvaluator(propertyName);\n\n        try {\n          expressionEvaluator.parseExpression(this.rxExpressionHelperService.prepare(expression));\n        } catch (e) {\n          isValid = false;\n        }\n\n        return of(isValid);\n      }\n    };\n  }\n}\n"]}