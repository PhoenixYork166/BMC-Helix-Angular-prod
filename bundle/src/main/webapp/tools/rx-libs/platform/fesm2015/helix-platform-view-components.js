import * as i0 from '@angular/core';
import { Injectable, Component, ChangeDetectionStrategy, Input, NgModule, HostBinding, ElementRef, ViewChildren, ViewChild, EventEmitter, Inject, Output, HostListener, ViewEncapsulation, Optional, Directive, Host } from '@angular/core';
import { of, combineLatest, EMPTY, throwError, Subject, merge, ReplaySubject, from, forkJoin, BehaviorSubject, defer, asyncScheduler, asapScheduler, AsyncSubject, Subscription, zip, iif } from 'rxjs';
import { switchMap, takeUntil, map, catchError, take, withLatestFrom, pairwise, skip, concatMap, shareReplay, distinctUntilChanged, mergeMap, first, filter, tap, share, takeWhile, pluck, switchMapTo, finalize, observeOn, startWith, delay, concatMapTo, mapTo, debounceTime, defaultIfEmpty, skipWhile } from 'rxjs/operators';
import * as i1$5 from '@helix/platform/record/api';
import { RxRecordDefinitionCacheService, RX_RECORD_DEFINITION, RecordFieldOption, RxFieldDefinitionService, RxRecordInstanceUtilsService, RxRecordInstanceService, UploaderService } from '@helix/platform/record/api';
import * as i1$1 from '@helix/platform/shared/api';
import { Tooltip, RxDefinitionNameService, RX_APPLICATION, RxSystemConfigurationService, RX_ADMINISTRATION, ExpressionOperatorRowsByGroup, ExpressionOperatorGroup, RxExpressionConfigurator, RxDefinitionModule, RxBooleanPipe, ExpressionParserToken, RX_DATA_PAGE, RxFeatureService } from '@helix/platform/shared/api';
import * as i2$5 from '@helix/platform/shared/components';
import { RxDefinitionPickerComponent, RxDefinitionPickerType, SelectFormControlComponent, ExpressionInspectorControlComponent, TextFormControlComponent, IconPickerFormControlComponent, IconPickerFormControlModule, InspectorWidgetBase, GroupButtonFormControlComponent, SwitchFormControlComponent, OptionalExpressionInspectorControlComponent, RxDefinitionPickerModule, FormControlsModule, RxSelectWithPaginationComponent, RxSelectWithPaginationModule, ValueAccessor, ValidationFormControlComponent, RxBooleanModule, RX_DEFINITION_PICKER, ExpressionFormControlComponent, LocalizedCharacterFieldValueModalComponent, OptionalSelectFormControlComponent, StepperWithUnitsFormControlModule, SelectFormControlModule, GroupButtonFormControlModule, ExpressionEditorModule, ExpressionFormControlModule, StepperWithUnitsFormControlComponent, RX_GAINSIGHT } from '@helix/platform/shared/components';
import * as i1$4 from '@helix/platform/view/api';
import { RX_DISABLED_PROP_DEFAULT_VALUE, RX_STANDARD_PROPS_DEFAULT_VALUES, RX_AVAILABLE_ON_DEVICES_PROP_NAME, RX_LEGACY_ICONS, RxViewComponentType, RX_VIEW_DEFINITION, RxViewComponentRegistryService, RX_AVAILABLE_ON_DEVICES_DEFAULT_VALUE, ViewComponentPropertyType, RX_AVAILABLE_ON_DEVICES_PROP_DESC, ViewDefinitionType, RX_STANDARD_PROPS_DESC, RX_EXPRESSION_EVALUATOR, OpenViewActionModalSize, RecordGridFilterOperator, RecordGridFilterDataLogic, RecordGridNamedFilterOptionKey, RxViewLayout, RX_VIEW_ACTION, OpenViewActionLaunchBehavior, OpenViewActionType, RowDataItemIdFieldName, ApplyGridFilterMode, RX_LAUNCH_BEHAVIOR, RxRecordQueryExpressionEvaluatorService, RX_RICH_TEXT, RX_DISABLED_PROP_DESC } from '@helix/platform/view/api';
import * as i1$3 from '@helix/platform/view/designer';
import { ViewDesignerComponentModel, RxViewActionValidatorService, validateCssClassNames, validateAvailableOnDevicesProp, getDisabledFieldInspectorConfig, getStandardPropsInspectorConfigs, ActionListWidgetComponent, ViewDesignerCanvasModule, ActionListWidgetModule, validateStandardProps, CanvasItemContainerComponent, ViewDesignerCanvasItemApiToken, getHiddenFieldInspectorConfig, getAvailableOnDevicesInspectorConfig, getStylesFieldInspectorConfig, CanvasOutletComponent, RxViewComponentExpressionConfigurator, NamedListFilterExpressionConfigurator, RxViewExpressionConfigurator, ActionListControlComponent, ActionListControlModule, RX_VIEW_DESIGNER } from '@helix/platform/view/designer';
import * as i2 from '@ngx-translate/core';
import { TranslateService, TranslateModule } from '@ngx-translate/core';
import { flatten, map as map$1, includes, get, find, throttle, isEmpty, isUndefined, last, values, times, xor, groupBy, reduce, inRange, flow, omit, omitBy, isNil, isFinite, isEqual, uniq, reject, assign, forEach, remove, filter as filter$1, clone, flattenDeep, transform, isObject, forOwn, compact, set, isFunction, head, castArray, isString, every, sortBy, pull, noop, defaults, isNull, toString, has, first as first$1, findIndex, pick, uniqBy, cloneDeep, constant, some, isBoolean, without, isArray, keys, intersection, findKey, chain, toNumber, endsWith, differenceBy, round, intersectionBy, min, max, isNumber, findLast, escape, trim } from 'lodash';
import * as i1 from '@bmc-ux/adapt-angular';
import { AdaptButtonModule, AdaptIconModule, AdaptDropdownModule, AdaptRxTextfieldModule, AdaptEmptyStateModule, AdaptAlertModule, AdaptRxFormControlModule, TreeWrap, DismissReasons, AdaptRxSearchModule, AdaptAccordionModule, AdaptTreeModule, AdaptRxSelectModule, AdaptRxUploaderModule, UploaderMode, UploaderSelectionMode, AdaptDownloadModule, AdaptRxSwitchModule, AdaptRxCheckboxModule, AdaptRxDatetimeModule, AdaptRxDatetimeAdapter, RxDatetimePickerMode, AdaptRxCounterModule, AdaptRxValidatorsModule, AdaptRxRadiobuttonModule, AdaptRxLabelModule, AdaptRxTextareaModule, AdaptTooltipModule, AdaptBusyModule, AdaptAccordionTabComponent, AdvancedFilterDataTypesConfigsService, AdvancedFilterOptionDataType, formatAdvancedFilterTagText, isEmptyOrWhitespace, booleanDataTypeBlankValue, getTagText, AdaptTagModule, AdaptMetatagModule, AdaptAdvancedFilteringModule, AdaptPopoverModule, getValueOrFunc, AdaptSubnavModule, AdaptTabsModule, AdaptRxListBuilderComponent, AdaptRxListBuilderModule, AdaptAgreementModule } from '@bmc-ux/adapt-angular';
import * as i3 from '@angular/common';
import { CommonModule, DatePipe, DecimalPipe, DOCUMENT } from '@angular/common';
import * as i1$2 from '@helix/platform/view/runtime';
import { BaseViewComponent, RuntimeViewCanvasModule, VIEW_COMPONENT_DEFAULT_EVENT_NAME } from '@helix/platform/view/runtime';
import { ResizeSensor } from 'css-element-queries';
import * as i2$1 from '@helix/platform/utils';
import { RxJsonParserService, RxGuidService, RxUniqueValidatorModule, RxNoWhitespaceValidatorModule, RxError } from '@helix/platform/utils';
import * as i2$2 from 'angular-split';
import { SplitComponent, AngularSplitModule } from 'angular-split';
import * as i8 from '@angular/cdk/drag-drop';
import { DragDropModule, moveItemInArray, CdkDropList, CdkDrag } from '@angular/cdk/drag-drop';
import * as i2$3 from '@angular/forms';
import { FormsModule, FormControl, FormGroup, ReactiveFormsModule, NG_VALUE_ACCESSOR, NgModel, Validators, NgForm } from '@angular/forms';
import * as i2$4 from '@helix/platform/association/api';
import { RX_ASSOCIATION_DEFINITION, RX_ASSOCIATED_RECORD_NODE_SIDES, RxAssociationInstanceDataPageService, RxAssociationDefinitionCacheService, RxAssociatedRecordNodeSide } from '@helix/platform/association/api';
import * as i1$6 from '@helix/platform/ui-kit';
import { RX_MODAL, RxModalModule, ReadOnlyFieldModule, RxModalClass, RxBusyIndicatorModule, RxDirectivesModule, RxModalService } from '@helix/platform/ui-kit';
import { __decorate, __param, __metadata } from 'tslib';
import moment from 'moment-es6';
import BigNumber from 'bignumber.js';
import { AdaptTextFieldFormBuilderModule, AdaptTextFieldModule, AdaptSelectModule } from '@bmc-ux/obsolete';
import * as i2$6 from '@helix/platform/named-list/api';
import * as i2$7 from 'ckeditor4-angular';
import { CKEditorModule, CKEditorComponent } from 'ckeditor4-angular';
import * as i1$7 from '@bmc-ux/adapt-table';
import { SortOrder, AdaptTableModule, ResizeMode, ExportType, AdaptTableHeaderSelectionMode, AdaptTableEventSource, ToolbarItemsByPriority } from '@bmc-ux/adapt-table';
import { saveAs } from 'file-saver';
import * as i28 from '@angular/router';
import { RouterModule } from '@angular/router';
import * as i1$8 from '@angular/platform-browser';
import * as i1$9 from '@angular/common/http';

var ActionButtonStyle;
(function (ActionButtonStyle) {
    ActionButtonStyle["Primary"] = "primary";
    ActionButtonStyle["Secondary"] = "secondary";
    ActionButtonStyle["Tertiary"] = "tertiary";
})(ActionButtonStyle || (ActionButtonStyle = {}));
var DeprecatedActionButtonStyle;
(function (DeprecatedActionButtonStyle) {
    DeprecatedActionButtonStyle["Link"] = "link";
    DeprecatedActionButtonStyle["Clear"] = "clear";
})(DeprecatedActionButtonStyle || (DeprecatedActionButtonStyle = {}));
var ActionButtonSize;
(function (ActionButtonSize) {
    ActionButtonSize["Small"] = "small";
    ActionButtonSize["Default"] = "default";
    ActionButtonSize["Large"] = "large";
})(ActionButtonSize || (ActionButtonSize = {}));
var ActionButtonIconAlignment;
(function (ActionButtonIconAlignment) {
    ActionButtonIconAlignment["Left"] = "left";
    ActionButtonIconAlignment["Right"] = "right";
})(ActionButtonIconAlignment || (ActionButtonIconAlignment = {}));

class RxActionButtonService {
    getButtonType(style) {
        let result;
        switch (style) {
            case ActionButtonStyle.Secondary:
                result = 'secondary';
                break;
            case ActionButtonStyle.Tertiary:
                result = 'tertiary';
                break;
            default:
                result = 'primary';
                break;
        }
        return result;
    }
    getIconCssClass(iconClass, iconAlignment = ActionButtonIconAlignment.Left) {
        return iconClass ? `d-icon-${iconAlignment}-${iconClass}` : '';
    }
}
RxActionButtonService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxActionButtonService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
RxActionButtonService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxActionButtonService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxActionButtonService, decorators: [{
            type: Injectable
        }] });

const ACTIONS_KEY = 'actions';
class ActionButtonDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.componentProperties$ = this.sandbox.componentProperties$;
        this.rxRecordDefinitionCacheService = this.injector.get(RxRecordDefinitionCacheService);
        this.viewActionValidatorService = this.injector.get(RxViewActionValidatorService);
        this.translateService = this.injector.get(TranslateService);
        this.label$ = this.sandbox.getComponentPropertyValue('labelKey').pipe(switchMap((labelKey) => labelKey ? of(this.translateService.instant(labelKey)) : this.sandbox.getComponentPropertyValue('label')), takeUntil(this.sandbox.destroyed$));
        this.style$ = this.sandbox.getComponentPropertyValue('style');
        this.size$ = this.sandbox.getComponentPropertyValue('size');
        this.icon$ = this.sandbox.getComponentPropertyValue('icon');
        this.iconAlignment$ = this.sandbox.getComponentPropertyValue('iconAlignment');
        this.fieldDefinitions$ = this.sandbox.getComponentPropertyValue('recordDefinitionName').pipe(switchMap((recordDefinitionName) => recordDefinitionName
            ? this.rxRecordDefinitionCacheService.getRecordDefinition(recordDefinitionName).pipe(map((recordDefinition) => recordDefinition.fieldDefinitions), catchError(() => of([])))
            : of([])));
    }
    static getInitialProperties(props) {
        return Object.assign(Object.assign(Object.assign({ iconAlignment: ActionButtonIconAlignment.Left, label: 'New button', size: ActionButtonSize.Default, icon: null, style: ActionButtonStyle.Primary, recordDefinitionName: null, fieldId: null, recordInstance: null }, RX_DISABLED_PROP_DEFAULT_VALUE), RX_STANDARD_PROPS_DEFAULT_VALUES), props);
    }
    rxInit() {
        // Set initial inspector config.
        combineLatest([this.sandbox.componentProperties$, this.fieldDefinitions$])
            .pipe(map(([componentProperties, fieldDefinitions]) => this.getInspectorConfig(componentProperties, fieldDefinitions)), take(1), takeUntil(this.sandbox.destroyed$))
            .subscribe((inspectorConfig) => {
            this.sandbox.updateInspectorConfig(inspectorConfig);
        });
        const actions$ = this.sandbox.getChildComponents();
        combineLatest([
            actions$.pipe(switchMap((actions) => this.viewActionValidatorService.validate(actions, ACTIONS_KEY))),
            this.sandbox.getComponentPropertyValue('styles').pipe(map(validateCssClassNames)),
            this.sandbox
                .getComponentPropertyValue(RX_AVAILABLE_ON_DEVICES_PROP_NAME)
                .pipe(map(validateAvailableOnDevicesProp))
        ])
            .pipe(map(flatten), takeUntil(this.sandbox.destroyed$))
            .subscribe((validationIssues) => {
            this.setValidationIssues(validationIssues);
        });
        // update field names when Record Definition Name changed
        this.fieldDefinitions$
            .pipe(withLatestFrom(this.componentProperties$), map(([fieldDefinitions, properties]) => this.getInspectorConfig(properties, fieldDefinitions)))
            .subscribe((inspector) => this.sandbox.updateInspectorConfig(inspector));
        // clear fieldId and recordInstance if recordDefinitionName changed
        this.sandbox
            .getComponentPropertyValue('recordDefinitionName')
            .pipe(pairwise())
            .subscribe(([oldName, newName]) => {
            if (oldName && oldName !== newName) {
                this.sandbox.updateComponentProperties({
                    fieldId: null,
                    recordInstance: null
                });
            }
        });
        this.label$.subscribe((label) => {
            this.sandbox.setBreadcrumbs(label);
        });
        this.sandbox
            .getComponentPropertyValue('action')
            .pipe(switchMap((action) => (action ? EMPTY : this.label$)), takeUntil(this.sandbox.destroyed$))
            .subscribe((label) => {
            // Don't build settable properties if 'action' property is not empty.
            // In this case button threads as a child of association component only.
            this.sandbox.setSettablePropertiesDataDictionary(label, [
                {
                    label: 'Disabled',
                    expression: this.getExpressionForProperty('disabled')
                },
                {
                    label: 'Hidden',
                    expression: this.getExpressionForProperty('hidden')
                }
            ]);
        });
    }
    setValidationIssues(issues) {
        this.sandbox.setValidationIssues(issues);
    }
    getInspectorConfig(props, fieldDefinitions) {
        const securitySectionControls = [
            {
                name: 'recordDefinitionName',
                component: RxDefinitionPickerComponent,
                options: {
                    label: 'Record definition name',
                    tooltip: new Tooltip('The view component will be hidden if the user has no access to the specified record definition.'),
                    definitionType: RxDefinitionPickerType.StandardDataRecord
                }
            }
        ];
        if (props.recordDefinitionName) {
            securitySectionControls.push({
                name: 'fieldId',
                component: SelectFormControlComponent,
                options: {
                    label: 'Field name',
                    tooltip: new Tooltip('The view component will be hidden if the user has no access to the specified field, or disabled if the user only has View permission ' +
                        'for the specified field. <br><br> Record definition name, Field name, and Record instance must all be ' +
                        'specified in order to control the disabled/hidden state of the view component using field permissions.'),
                    options: fieldDefinitions.map((definition) => ({ name: definition.name, id: String(definition.id) })),
                    emptyOption: true
                }
            }, {
                name: 'recordInstance',
                component: ExpressionInspectorControlComponent,
                options: {
                    label: 'Record instance',
                    tooltip: new Tooltip('Expression pointing to a record instance that provides the field permission details.')
                }
            });
        }
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'label',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Label'
                            }
                        },
                        {
                            name: 'style',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Style',
                                required: true,
                                options: map$1(ActionButtonStyle, (value, name) => ({
                                    id: value,
                                    name
                                }))
                            }
                        },
                        {
                            name: 'size',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Size',
                                options: map$1(ActionButtonSize, (value, name) => ({
                                    id: value,
                                    name
                                })),
                                sortAlphabetically: false
                            }
                        },
                        {
                            name: 'icon',
                            component: IconPickerFormControlComponent,
                            options: {
                                label: 'Icon'
                            }
                        },
                        {
                            name: 'iconAlignment',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Icon alignment',
                                options: map$1(ActionButtonIconAlignment, (value, name) => ({
                                    id: value,
                                    name
                                }))
                            }
                        },
                        getDisabledFieldInspectorConfig(),
                        ...getStandardPropsInspectorConfigs()
                    ]
                },
                {
                    label: 'Actions',
                    controls: [
                        {
                            widgetName: ACTIONS_KEY,
                            component: ActionListWidgetComponent
                        }
                    ]
                },
                {
                    label: 'Security',
                    controls: securitySectionControls
                }
            ]
        };
    }
}

class ActionButtonDesignComponent {
    constructor(rxActionButtonService) {
        this.rxActionButtonService = rxActionButtonService;
    }
    ngOnInit() {
        this.iconCssClass$ = combineLatest([this.model.icon$, this.model.iconAlignment$]).pipe(map(([iconCssName, iconAlignment]) => this.rxActionButtonService.getIconCssClass(iconCssName, iconAlignment)));
        this.buttonType$ = this.model.style$.pipe(map((style) => this.rxActionButtonService.getButtonType(style)));
        this.size$ = this.model.size$.pipe(map((size) => size || ActionButtonSize.Default));
    }
}
ActionButtonDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonDesignComponent, deps: [{ token: RxActionButtonService }], target: i0.ɵɵFactoryTarget.Component });
ActionButtonDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ActionButtonDesignComponent, selector: "rx-action-button-design", inputs: { model: "model" }, ngImport: i0, template: "<button adapt-button [btn-type]=\"buttonType$ | async\" [size]=\"size$ | async\" [ngClass]=\"iconCssClass$ | async\">\n  {{ model.label$ | async }}\n</button>\n", components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-action-button-design',
                    templateUrl: './action-button-design.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: RxActionButtonService }]; }, propDecorators: { model: [{
                type: Input
            }] } });

class ActionButtonAdapterService {
    constructor() {
        this.deprecatedButtonStyles = [DeprecatedActionButtonStyle.Link, DeprecatedActionButtonStyle.Clear];
    }
    adaptDefinition(componentDefinition) {
        if (includes(this.deprecatedButtonStyles, componentDefinition.propertiesByName.style)) {
            componentDefinition.propertiesByName.style = ActionButtonStyle.Tertiary;
        }
        if (!componentDefinition.propertiesByName.size) {
            componentDefinition.propertiesByName.size = ActionButtonSize.Small;
        }
        if (componentDefinition.propertiesByName.icon) {
            componentDefinition.propertiesByName.icon = get(RX_LEGACY_ICONS, componentDefinition.propertiesByName.icon, componentDefinition.propertiesByName.icon);
        }
    }
}
ActionButtonAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonAdapterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ActionButtonAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonAdapterService, decorators: [{
            type: Injectable
        }] });

class ActionButtonDesignModule {
    constructor(rxDefinitionAdapterRegistryService, actionButtonAdapterService) {
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.actionButtonAdapterService = actionButtonAdapterService;
        this.rxDefinitionAdapterRegistryService.registerDesignAdapter(RxViewComponentType.ActionButton, this.actionButtonAdapterService);
    }
}
ActionButtonDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonDesignModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: ActionButtonAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
ActionButtonDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonDesignModule, declarations: [ActionButtonDesignComponent], imports: [CommonModule,
        AdaptButtonModule,
        ViewDesignerCanvasModule,
        ActionListWidgetModule,
        IconPickerFormControlModule] });
ActionButtonDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonDesignModule, providers: [RxActionButtonService, ActionButtonAdapterService], imports: [[
            CommonModule,
            AdaptButtonModule,
            ViewDesignerCanvasModule,
            ActionListWidgetModule,
            IconPickerFormControlModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        AdaptButtonModule,
                        ViewDesignerCanvasModule,
                        ActionListWidgetModule,
                        IconPickerFormControlModule
                    ],
                    declarations: [ActionButtonDesignComponent],
                    entryComponents: [ActionButtonDesignComponent],
                    providers: [RxActionButtonService, ActionButtonAdapterService]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: ActionButtonAdapterService }]; } });

class ActionButtonComponent extends BaseViewComponent {
    constructor(rxLogService, translateService, rxNotificationService, rxActionButtonService) {
        super();
        this.rxLogService = rxLogService;
        this.translateService = translateService;
        this.rxNotificationService = rxNotificationService;
        this.rxActionButtonService = rxActionButtonService;
        this.api = {
            click: this.click.bind(this),
            setProperty: this.setProperty.bind(this)
        };
        this.state = {};
        this.isActionInProgress = false;
        this.isDisabled = false;
        this.buttonType = '';
    }
    get hostClass() {
        const state = this.state;
        const className = `${RxViewComponentType.ActionButton}_${state.style}`;
        return state.styles ? `${className} ${state.styles}` : className;
    }
    ngOnInit() {
        this.notifyPropertyChanged('api', this.api);
        this.config.pipe(takeUntil(this.destroyed$)).subscribe((config) => {
            Object.assign(this.state, config);
            if (config.labelKey) {
                this.state.buttonLabel = this.translateService.instant(config.labelKey);
            }
            else {
                this.state.buttonLabel = config.label;
            }
            this.state.icon = '';
            this.state.cls = config.cls || '';
            if (config.iconCls || config.icon) {
                const icon = config.iconCls || config.icon;
                const iconAlignment = ((config.label || config.labelKey) && config.iconAlignment) || 'left';
                this.state.icon = this.rxActionButtonService.getIconCssClass(icon, iconAlignment);
            }
            if (config.iconCls && config.icon) {
                this.rxLogService.warning('iconCls option is specified, icon will be ignored.');
            }
            if (!config.cls) {
                this.buttonType = this.rxActionButtonService.getButtonType(this.state.style);
            }
            if (config.cls && config.style) {
                this.rxLogService.warning('cls option is specified, style will be ignored.');
            }
            this.validateRecordDefinitionName();
            this.isHidden = this.isHiddenFunc();
            this.isDisabled = this.isDisabledFunc();
        });
    }
    // api
    click() {
        if (!this.isDisabled) {
            this.isActionInProgress = true;
            this.isDisabled = true;
            return this
                .triggerViewActions()
                .then((res) => {
                this.isActionInProgress = false;
                this.isDisabled = this.isDisabledFunc();
            })
                .catch((err) => {
                this.isActionInProgress = false;
                this.isDisabled = this.isDisabledFunc();
            });
        }
    }
    isDisabledFunc() {
        return (Boolean(this.state.disabled) ||
            this.isActionInProgress ||
            (this.state.recordInstance &&
                this.state.fieldId &&
                this.state.recordInstance.recordDefinitionName === this.state.recordDefinitionName &&
                find(this.state.recordInstance.fieldInstances, { id: Number(this.state.fieldId) }) &&
                find(this.state.recordInstance.fieldInstances, { id: Number(this.state.fieldId) }).permissionType ===
                    RX_RECORD_DEFINITION.fieldPermissionTypes.view));
    }
    isHiddenFunc() {
        return (this.isHidden =
            Boolean(this.state.hidden) ||
                (this.state.recordInstance &&
                    (this.state.recordInstance.recordDefinitionName !== this.state.recordDefinitionName ||
                        (this.state.fieldId &&
                            !find(this.state.recordInstance.fieldInstances, { id: Number(this.state.fieldId) })))));
    }
    setProperty(propertyPath, value) {
        if (includes(['hidden', 'disabled'], propertyPath)) {
            this.state[propertyPath] = value;
            this.notifyPropertyChanged(propertyPath, this.state[propertyPath]);
        }
        else {
            return throwError(`Action Button: property ${propertyPath} is not settable.`);
        }
    }
    validateRecordDefinitionName() {
        if (this.state.recordInstance &&
            this.state.recordInstance.recordDefinitionName !== this.state.recordDefinitionName) {
            const buttonName = this.translateService.instant('com.bmc.arsys.rx.client.view-components.action-button.component-name.label', {
                label: this.state.label
            });
            const errorMessage = this.translateService.instant('com.bmc.arsys.rx.client.view-components.action-button.configuration-error.message', {
                componentName: buttonName
            });
            this.rxNotificationService.addErrorMessage(errorMessage);
        }
    }
}
ActionButtonComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonComponent, deps: [{ token: i1$1.RxLogService }, { token: i2.TranslateService }, { token: i1$1.RxNotificationService }, { token: RxActionButtonService }], target: i0.ɵɵFactoryTarget.Component });
ActionButtonComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ActionButtonComponent, selector: "rx-action-button", inputs: { guid: "guid", config: "config", runtimeViewModelApi: "runtimeViewModelApi" }, host: { properties: { "class": "this.hostClass" } }, usesInheritance: true, ngImport: i0, template: "<button\n  adapt-button\n  type=\"button\"\n  class=\"mw-100 rx-ellipsis\"\n  *ngIf=\"!isHidden\"\n  [btn-type]=\"buttonType\"\n  [ngClass]=\"[state.icon, state.cls]\"\n  [disabled]=\"isDisabled\"\n  [size]=\"state.size\"\n  (click)=\"api.click($event)\"\n>\n  <span>{{ state.buttonLabel }}</span>\n</button>\n", styles: [":host{display:block}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-action-button',
                    templateUrl: './action-button.component.html',
                    styleUrls: ['./action-button.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxLogService }, { type: i2.TranslateService }, { type: i1$1.RxNotificationService }, { type: RxActionButtonService }]; }, propDecorators: { guid: [{
                type: Input
            }], config: [{
                type: Input
            }], runtimeViewModelApi: [{
                type: Input
            }], hostClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

class ActionButtonModule {
    constructor(rxDefinitionAdapterRegistryService, actionButtonAdapterService) {
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.actionButtonAdapterService = actionButtonAdapterService;
        this.rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.ActionButton, this.actionButtonAdapterService);
    }
}
ActionButtonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: ActionButtonAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
ActionButtonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonModule, declarations: [ActionButtonComponent], imports: [AdaptButtonModule, CommonModule, TranslateModule, AdaptIconModule], exports: [ActionButtonComponent] });
ActionButtonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonModule, providers: [RxActionButtonService, ActionButtonAdapterService], imports: [[AdaptButtonModule, CommonModule, TranslateModule, AdaptIconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [AdaptButtonModule, CommonModule, TranslateModule, AdaptIconModule],
                    exports: [ActionButtonComponent],
                    declarations: [ActionButtonComponent],
                    entryComponents: [ActionButtonComponent],
                    providers: [RxActionButtonService, ActionButtonAdapterService]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: ActionButtonAdapterService }]; } });

var RxButtonBarAlignment;
(function (RxButtonBarAlignment) {
    RxButtonBarAlignment["Left"] = "left";
    RxButtonBarAlignment["Right"] = "right";
    RxButtonBarAlignment["Center"] = "center";
})(RxButtonBarAlignment || (RxButtonBarAlignment = {}));
const RX_BUTTON_BAR = {
    alignmentOptions: {
        left: {
            id: RxButtonBarAlignment.Left,
            name: 'Left',
            cls: 'align-left'
        },
        center: {
            id: RxButtonBarAlignment.Center,
            name: 'Center',
            cls: 'align-center'
        },
        right: {
            id: RxButtonBarAlignment.Right,
            name: 'Right',
            cls: 'align-right'
        }
    }
};

class RxButtonBarService {
    getAlignClass(alignment) {
        return get(RX_BUTTON_BAR.alignmentOptions, [alignment, 'cls'], '');
    }
}
RxButtonBarService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxButtonBarService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
RxButtonBarService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxButtonBarService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxButtonBarService, decorators: [{
            type: Injectable
        }] });

class ButtonBarDropdownItemComponent extends ActionButtonComponent {
}
ButtonBarDropdownItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarDropdownItemComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
ButtonBarDropdownItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ButtonBarDropdownItemComponent, selector: "rx-button-bar-dropdown-item-component", inputs: { guid: "guid", config: "config", runtimeViewModelApi: "runtimeViewModelApi" }, usesInheritance: true, ngImport: i0, template: "<button type=\"button\" class=\"dropdown-item\" *ngIf=\"!isHidden\" [disabled]=\"isDisabled\" (click)=\"api.click($event)\">\n  {{ state.label }}\n</button>\n", directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarDropdownItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-button-bar-dropdown-item-component',
                    templateUrl: './button-bar-dropdown-item.component.html'
                }]
        }], propDecorators: { guid: [{
                type: Input
            }], config: [{
                type: Input
            }], runtimeViewModelApi: [{
                type: Input
            }] } });

class ButtonBarComponent extends BaseViewComponent {
    constructor(elementRef, runtimeCanvasItemComponent, changeDetector, ngZone, rxButtonBarService, renderer) {
        super();
        this.elementRef = elementRef;
        this.runtimeCanvasItemComponent = runtimeCanvasItemComponent;
        this.changeDetector = changeDetector;
        this.ngZone = ngZone;
        this.rxButtonBarService = rxButtonBarService;
        this.renderer = renderer;
        this.api = {
            setProperty: this.setProperty.bind(this)
        };
        this.childLayouts = null;
        this.isDropdownVisible = false;
        this.resize$ = new Subject();
        this.onResizeThrottled = throttle(this.onResize.bind(this), 100);
    }
    ngOnInit() {
        super.ngOnInit();
        this.notifyPropertyChanged('api', this.api);
        this.config.pipe(takeUntil(this.destroyed$)).subscribe((config) => {
            this.isHidden = Boolean(config.hidden);
            this.alignClass = this.rxButtonBarService.getAlignClass(config.alignment);
        });
        this.childLayouts = get(this.runtimeCanvasItemComponent.getChildren(RX_VIEW_DEFINITION.defaultOutletName), '[0].children');
    }
    ngAfterViewInit() {
        const el = this.renderer.selectRootElement(this.elementRef.nativeElement, true);
        if (!isEmpty(this.childLayouts)) {
            const buttonConfigs = this.childLayouts.map((layout) => layout.config);
            this.ngZone.runOutsideAngular(() => {
                this.resizeSensor = new ResizeSensor(el, (size) => {
                    this.ngZone.run(() => this.resize$.next(size));
                });
            });
            merge(...buttonConfigs, this.resize$)
                .pipe(map((size) => size.width || el.offsetWidth), takeUntil(this.destroyed$))
                .subscribe((width) => this.onResizeThrottled(width));
        }
        this.onResize(el.offsetWidth);
        this.changeDetector.detectChanges();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.resizeSensor) {
            this.resizeSensor.detach();
        }
    }
    onResize(containerWidth) {
        let totalButtonsWidth = 0;
        const toggleButtonOffsetWidth = this.dropdownToggleButton
            ? this.renderer.selectRootElement(this.dropdownToggleButton.nativeElement, true).offsetWidth
            : 0;
        this.buttonItemsQueryList.forEach((item, index) => {
            totalButtonsWidth += this.renderer.selectRootElement(item.nativeElement, true).offsetWidth;
            const containerFitsButton = Math.floor(containerWidth) >= Math.ceil(totalButtonsWidth) + toggleButtonOffsetWidth;
            this.childLayouts[index].showInDropdown = !containerFitsButton;
            if (!isUndefined(this.childLayouts[index - 1]) &&
                this.childLayouts.filter((button) => button.showInDropdown).length < 2) {
                this.childLayouts[index - 1].showInDropdown = !containerFitsButton;
            }
        });
        this.isDropdownVisible = isEmpty(this.childLayouts) ? false : last(this.childLayouts).showInDropdown;
    }
    trackByFn(index, item) {
        return item.guid;
    }
    setProperty(propertyPath, propertyValue) {
        if (propertyPath === 'hidden') {
            this.isHidden = propertyValue;
            this.notifyPropertyChanged(propertyPath, this.isHidden);
        }
        else {
            return throwError(`Button Bar: property ${propertyPath} is not settable.`);
        }
    }
}
ButtonBarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarComponent, deps: [{ token: i0.ElementRef }, { token: i1$2.RuntimeViewCanvasItemComponent }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: RxButtonBarService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
ButtonBarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ButtonBarComponent, selector: "rx-button-bar", viewQueries: [{ propertyName: "dropdownToggleButton", first: true, predicate: ["dropdownToggle"], descendants: true, read: ElementRef }, { propertyName: "buttonItemsQueryList", predicate: ["buttonItems"], descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<div class=\"button-container\" [ngClass]=\"alignClass\" *ngIf=\"childLayouts && !isHidden\">\n  <div\n    *ngFor=\"let buttonLayout of childLayouts; trackBy: trackByFn\"\n    [ngClass]=\"{ 'nav-item--hidden': buttonLayout.showInDropdown }\"\n  >\n    <rx-runtime-view-canvas-item #buttonItems [layout]=\"buttonLayout\"></rx-runtime-view-canvas-item>\n  </div>\n\n  <div\n    *ngIf=\"isDropdownVisible\"\n    class=\"dropdown\"\n    adaptDropdown\n    [placement]=\"['bottom-right', 'bottom-left', 'bottom', 'top-right', 'top-left', 'top', 'auto']\"\n  >\n    <button\n      class=\"btn btn-secondary rx-toggle\"\n      [attr.id]=\"'rx-' + guid\"\n      type=\"button\"\n      adaptDropdownToggle\n      #dropdownToggle\n    ></button>\n    <div class=\"dropdown-menu\" [attr.aria-labelledby]=\"'rx-' + guid\" adaptDropdownMenu>\n      <ng-container *ngFor=\"let buttonLayout of childLayouts; trackBy: trackByFn\">\n        <rx-button-bar-dropdown-item-component\n          *ngIf=\"buttonLayout.showInDropdown\"\n          [config]=\"buttonLayout.config\"\n          [runtimeViewModelApi]=\"buttonLayout.runtimeViewModelApi\"\n          [guid]=\"buttonLayout.guid\"\n        ></rx-button-bar-dropdown-item-component>\n      </ng-container>\n    </div>\n  </div>\n</div>\n", styles: [":host{display:block}.button-container{display:flex}.button-container.align-center{justify-content:center}.button-container.align-right{justify-content:flex-end}.button-container.align-left{justify-content:flex-start}.button-container rx-runtime-view-canvas-item{display:inline-block}.button-container rx-runtime-view-canvas-item:not(:has(> [hidden])){padding-right:5px}.rx-toggle{padding-left:1px;height:100%}\n"], components: [{ type: i1$2.RuntimeViewCanvasItemComponent, selector: "rx-runtime-view-canvas-item", inputs: ["layout"] }, { type: i1.AdaptDropdownDirective, selector: "adapt-dropdown, [adaptDropdown]", inputs: ["autoClose", "customClass", "closeOnEscape", "placement", "animationPlacement", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "focusNextElementAfterClose", "appendToBody", "appendTo", "positionTo", "anchorPositionTrackingIntervalMs", "enableAnchorPositionTracking", "recalculatePositionOnElementResize", "setMobileState", "mobileView"], outputs: ["onOpen", "onClose", "anchorPositionChange", "popupAnimationDone"], exportAs: ["adaptDropdown"] }, { type: ButtonBarDropdownItemComponent, selector: "rx-button-bar-dropdown-item-component", inputs: ["guid", "config", "runtimeViewModelApi"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.AdaptDropdownToggleDirective, selector: "[adaptDropdownToggle]", inputs: ["showCaret", "dropdownTogglerType"] }, { type: i1.AdaptDropdownMenuDirective, selector: "[adaptDropdownMenu]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-button-bar',
                    templateUrl: './button-bar.component.html',
                    styleUrls: ['./button-bar.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1$2.RuntimeViewCanvasItemComponent }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: RxButtonBarService }, { type: i0.Renderer2 }]; }, propDecorators: { buttonItemsQueryList: [{
                type: ViewChildren,
                args: ['buttonItems', { read: ElementRef }]
            }], dropdownToggleButton: [{
                type: ViewChild,
                args: ['dropdownToggle', { read: ElementRef }]
            }] } });

class ButtonBarModule {
}
ButtonBarModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ButtonBarModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarModule, declarations: [ButtonBarComponent, ButtonBarDropdownItemComponent], imports: [CommonModule, RuntimeViewCanvasModule, i1.AdaptDropdownModule], exports: [ButtonBarComponent] });
ButtonBarModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarModule, providers: [RxButtonBarService], imports: [[CommonModule, RuntimeViewCanvasModule, AdaptDropdownModule.forRoot()]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ButtonBarComponent, ButtonBarDropdownItemComponent],
                    imports: [CommonModule, RuntimeViewCanvasModule, AdaptDropdownModule.forRoot()],
                    exports: [ButtonBarComponent],
                    entryComponents: [ButtonBarComponent],
                    providers: [RxButtonBarService]
                }]
        }] });

class ButtonBarDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.hasChildren$ = this.sandbox.getChildComponentGuids().pipe(map((guids) => !isEmpty(guids)));
        this.componentProperties$ = this.sandbox.componentProperties$;
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({ alignment: RxButtonBarAlignment.Left, name: null }, RX_STANDARD_PROPS_DEFAULT_VALUES), initialProperties);
    }
    rxInit() {
        this.componentProperties$.pipe(take(1)).subscribe(() => {
            this.sandbox.updateInspectorConfig(this.getInspector());
        });
        this.sandbox.getComponentPropertyValue('name').subscribe((name) => {
            const componentName = name ? `${this.sandbox.descriptor.name} (${name})` : this.sandbox.descriptor.name;
            this.sandbox.setSettablePropertiesDataDictionary(componentName, [
                {
                    label: 'Hidden',
                    expression: this.getExpressionForProperty('hidden')
                }
            ]);
        });
        this.componentProperties$.subscribe((props) => {
            this.validate(props);
        });
    }
    dropPredicate(data) {
        return data.draggedViewComponentDescriptor.type === RxViewComponentType.ActionButton;
    }
    validate(model) {
        this.sandbox.setValidationIssues(validateStandardProps(model));
    }
    getInspector() {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'name',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Name',
                                tooltip: new Tooltip('Enter a name to uniquely identify the Button bar.')
                            }
                        },
                        {
                            name: 'alignment',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Alignment',
                                options: values(RX_BUTTON_BAR.alignmentOptions),
                                sortAlphabetically: false
                            }
                        },
                        ...getStandardPropsInspectorConfigs()
                    ]
                }
            ]
        };
    }
}

class ButtonBarDesignComponent {
    constructor(rxButtonBarService) {
        this.rxButtonBarService = rxButtonBarService;
        this.alignment = '';
        this.destroyed$ = new ReplaySubject(1);
    }
    ngOnInit() {
        this.model.componentProperties$.pipe(takeUntil(this.destroyed$)).subscribe((componentProperties) => {
            this.alignment = this.rxButtonBarService.getAlignClass(componentProperties.alignment);
        });
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
}
ButtonBarDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarDesignComponent, deps: [{ token: RxButtonBarService }], target: i0.ɵɵFactoryTarget.Component });
ButtonBarDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ButtonBarDesignComponent, selector: "rx-button-bar-design", inputs: { model: "model" }, ngImport: i0, template: "<rx-canvas-outlet\n  class=\"button-bar-design-container border\"\n  [class.border-transparent]=\"model.hasChildren$ | async\"\n  [ngClass]=\"alignment\"\n  [dropPredicate]=\"model.dropPredicate\"\n  dropListOrientation=\"horizontal\"\n></rx-canvas-outlet>\n", styles: [":host::ng-deep .button-bar-design-container{display:block}:host::ng-deep .button-bar-design-container.align-center .cdk-drop-list{justify-content:center}:host::ng-deep .button-bar-design-container.align-right .cdk-drop-list{justify-content:flex-end}:host::ng-deep .button-bar-design-container.align-left .cdk-drop-list{justify-content:flex-start}:host::ng-deep .button-bar-design-container rx-canvas-item-container{min-width:100%}:host::ng-deep .button-bar-design-container rx-canvas-item-container .cdk-drop-list{min-height:50px;display:flex;flex-flow:row wrap}.border-transparent{border-color:transparent!important}\n"], components: [{ type: i1$3.CanvasOutletComponent, selector: "rx-canvas-outlet", inputs: ["name", "skipParentPredicate", "containerComponent", "dropListOrientation", "dropPredicate"], outputs: ["beforeViewComponentDrop"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-button-bar-design',
                    templateUrl: './button-bar-design.component.html',
                    styleUrls: ['./button-bar-design.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: RxButtonBarService }]; }, propDecorators: { model: [{
                type: Input
            }] } });

class ButtonBarDesignModule {
}
ButtonBarDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ButtonBarDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarDesignModule, declarations: [ButtonBarDesignComponent], imports: [CommonModule, ViewDesignerCanvasModule] });
ButtonBarDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarDesignModule, providers: [RxButtonBarService], imports: [[CommonModule, ViewDesignerCanvasModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ViewDesignerCanvasModule],
                    declarations: [ButtonBarDesignComponent],
                    entryComponents: [ButtonBarDesignComponent],
                    providers: [RxButtonBarService]
                }]
        }] });

class ContainerComponent extends BaseViewComponent {
    constructor(elementRef, renderer) {
        super();
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.state = {};
        this.api = {
            setProperty: this.setProperty.bind(this)
        };
    }
    ngOnInit() {
        super.ngOnInit();
        this.notifyPropertyChanged('api', this.api);
        this.config.pipe(takeUntil(this.destroyed$)).subscribe((config) => {
            this.isHidden = Boolean(config.hidden);
            this.state = Object.assign({}, config);
        });
    }
    setProperty(propertyPath, propertyValue) {
        if (propertyPath === 'hidden') {
            this.state.hidden = propertyValue;
            this.notifyPropertyChanged(propertyPath, propertyValue);
        }
        else {
            const componentName = this.renderer.selectRootElement(this.elementRef.nativeElement, true).tagName.toLowerCase();
            return throwError(`${componentName}: property ${propertyPath} is not settable.`);
        }
    }
}
ContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
ContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ContainerComponent, selector: "rx-container", usesInheritance: true, ngImport: i0, template: "<rx-runtime-view-canvas-outlet [hidden]=\"state.hidden\"></rx-runtime-view-canvas-outlet>\n", styles: [":host{display:block}:host.rx-auto-fill::ng-deep>rx-runtime-view-canvas-outlet>rx-runtime-view-canvas-item-container{display:flex;flex-direction:column;height:100%}\n"], components: [{ type: i1$2.RuntimeViewCanvasOutletComponent, selector: "rx-runtime-view-canvas-outlet", inputs: ["name"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-container',
                    templateUrl: './container.component.html',
                    styleUrls: ['./container.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; } });

class ContainerComponentDefinitionAdapterService {
    constructor(viewDefinitionParserService, rxJsonParserService) {
        this.viewDefinitionParserService = viewDefinitionParserService;
        this.rxJsonParserService = rxJsonParserService;
        this.componentDefinitionType = RxViewComponentType.Container;
    }
    // converting layout of old view definition into new format
    adaptDefinition(containerComponentDefinition) {
        this.viewDefinitionParserService
            .getComponents(containerComponentDefinition)
            .filter((componentPair) => componentPair.componentDefinition.type === this.componentDefinitionType)
            .map((componentPair) => componentPair.componentDefinition)
            .forEach((componentDefinition) => {
            if (componentDefinition.layout) {
                let layout = this.rxJsonParserService.tryParseJson(componentDefinition.layout);
                if (layout && layout.componentDefinitionId) {
                    const columns = layout.columns.map((column) => {
                        const rowWrap = componentDefinition.propertiesByName.rowWrap || 'sm';
                        const columnSpan = column.span || 12;
                        const columnClass = rowWrap === 'xs' ? `col-${columnSpan}` : `col-${rowWrap}-${columnSpan}`;
                        const marginBottomClass = rowWrap !== 'xs' ? `rx-mb-${rowWrap}` : '';
                        return {
                            cssClass: `${columnClass} ${marginBottomClass}`,
                            children: column.children.map((child) => child.componentDefinitionId)
                        };
                    });
                    layout = {
                        outlets: [
                            {
                                name: 'DEFAULT',
                                columns: columns
                            }
                        ]
                    };
                    componentDefinition.layout = JSON.stringify(layout);
                }
                else if (layout && layout.outlets) {
                    layout.outlets.forEach((outlet) => {
                        outlet.columns
                            .filter((column) => !column.cssClass)
                            .forEach((column) => {
                            const rowWrap = componentDefinition.propertiesByName.rowWrap || 'sm';
                            const columnSpan = column.span || 12;
                            const columnClass = rowWrap === 'xs' ? `col-${columnSpan}` : `col-${rowWrap}-${columnSpan}`;
                            const marginBottomClass = rowWrap !== 'xs' ? `rx-mb-${rowWrap}` : '';
                            column.cssClass = `${columnClass} ${marginBottomClass}`;
                        });
                    });
                    componentDefinition.layout = JSON.stringify(layout);
                }
            }
        });
    }
}
ContainerComponentDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerComponentDefinitionAdapterService, deps: [{ token: i1$4.RxViewDefinitionParserService }, { token: i2$1.RxJsonParserService }], target: i0.ɵɵFactoryTarget.Injectable });
ContainerComponentDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerComponentDefinitionAdapterService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerComponentDefinitionAdapterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewDefinitionParserService }, { type: i2$1.RxJsonParserService }]; } });

class ContainerModule {
    constructor(containerComponentDefinitionAdapterService, rxDefinitionAdapterRegistryService) {
        this.containerComponentDefinitionAdapterService = containerComponentDefinitionAdapterService;
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.Container, this.containerComponentDefinitionAdapterService);
    }
}
ContainerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerModule, deps: [{ token: ContainerComponentDefinitionAdapterService }, { token: i1$1.RxDefinitionAdapterRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
ContainerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerModule, declarations: [ContainerComponent], imports: [CommonModule, RuntimeViewCanvasModule], exports: [ContainerComponent] });
ContainerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerModule, imports: [[CommonModule, RuntimeViewCanvasModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ContainerComponent],
                    exports: [ContainerComponent],
                    entryComponents: [ContainerComponent],
                    imports: [CommonModule, RuntimeViewCanvasModule]
                }]
        }], ctorParameters: function () { return [{ type: ContainerComponentDefinitionAdapterService }, { type: i1$1.RxDefinitionAdapterRegistryService }]; } });

class ContainerCanvasItemComponent extends CanvasItemContainerComponent {
    constructor(canvasItemApi, canvasOutletHelperService, elementRef, renderer) {
        super(canvasItemApi, canvasOutletHelperService);
        this.canvasItemApi = canvasItemApi;
        this.canvasOutletHelperService = canvasOutletHelperService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.maxNumberOfColumns = 12;
        this.defaultGutterStep = 50;
        this.percentSpanSize = 100 / this.maxNumberOfColumns;
        this.gutterStep = this.defaultGutterStep;
        this.columnResize = new EventEmitter();
    }
    onWindowResize() {
        this.setGutterStep();
    }
    ngAfterViewInit() {
        const spans = this.outlet.columns.map((column) => column.span);
        this.setSpanSizes(spans);
        this.setGutterStep();
    }
    onDragEnd(event) {
        const spans = this.getPercentToSpanSizes(event.sizes);
        this.columnResize.emit(spans);
        this.setSpanSizes(spans);
    }
    getPercentToSpanSizes(percentSizes) {
        return percentSizes.map((size) => Math.round((size * this.maxNumberOfColumns) / 100));
    }
    setSpanSizes(spans) {
        this.splitComponent.setVisibleAreaSizes(this.getSpanToPercentSizes(spans));
    }
    getSpanToPercentSizes(spans) {
        return spans.map((span) => span * this.percentSpanSize);
    }
    setGutterStep() {
        const element = this.renderer.selectRootElement(this.elementRef.nativeElement, true);
        this.gutterStep = Math.round(element.clientWidth / this.maxNumberOfColumns) || this.defaultGutterStep;
    }
}
ContainerCanvasItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerCanvasItemComponent, deps: [{ token: ViewDesignerCanvasItemApiToken }, { token: i1$3.CanvasOutletHelperService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
ContainerCanvasItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ContainerCanvasItemComponent, selector: "rx-container-canvas-item", outputs: { columnResize: "columnResize" }, host: { listeners: { "window:resize": "onWindowResize()" } }, viewQueries: [{ propertyName: "splitComponent", first: true, predicate: SplitComponent, descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<as-split\n  unit=\"percent\"\n  [class.selected]=\"layout.isSelected$ | async\"\n  [class.readonly]=\"isReadOnly\"\n  [gutterStep]=\"gutterStep\"\n  gutterSize=\"1\"\n  (dragEnd)=\"onDragEnd($event)\"\n>\n  <as-split-area\n    *ngFor=\"\n      let column of outlet.columns;\n      trackBy: trackByColFn;\n      let colIndex = index;\n      let first = first;\n      let last = last\n    \"\n    minSize=\"8\"\n  >\n    <rx-canvas-item-column\n      [isReadOnly]=\"isReadOnly\"\n      [colIndex]=\"colIndex\"\n      [column]=\"column\"\n      [layout]=\"layout\"\n      (dropListDropped)=\"onDropListDropped($event)\"\n    ></rx-canvas-item-column>\n  </as-split-area>\n</as-split>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{display:block}as-split:not(.readonly).selected ::ng-deep>.as-split-gutter{visibility:visible}as-split ::ng-deep as-split-area{height:revert!important;min-height:200px}as-split ::ng-deep as-split-area>rx-canvas-item-column{height:100%}as-split ::ng-deep as-split-area>rx-canvas-item-column>.cdk-drop-list{height:100%;min-height:auto}as-split ::ng-deep .as-split-gutter{visibility:hidden;height:revert!important;position:relative;background-color:#d6d7d8!important}as-split ::ng-deep .as-split-gutter .as-split-gutter-icon{border:1px solid #d6d7d8;height:72px!important;width:11px!important;background:white!important;border-radius:2px;position:absolute}as-split ::ng-deep .as-split-gutter .as-split-gutter-icon:hover:before,as-split ::ng-deep .as-split-gutter .as-split-gutter-icon:hover:after{background-color:#d6d7d8}as-split ::ng-deep .as-split-gutter .as-split-gutter-icon:before,as-split ::ng-deep .as-split-gutter .as-split-gutter-icon:after{display:inline-block;content:\"\";position:absolute;top:50%;width:2px;height:64px;background-color:#f0f1f1;border-radius:2px;transform:translateY(-50%);transition:background-color .25s ease}as-split ::ng-deep .as-split-gutter .as-split-gutter-icon:before{left:2px}as-split ::ng-deep .as-split-gutter .as-split-gutter-icon:after{left:5px}\n"], components: [{ type: i2$2.SplitComponent, selector: "as-split", inputs: ["direction", "unit", "gutterSize", "gutterStep", "restrictMove", "useTransition", "disabled", "dir", "gutterDblClickDuration"], outputs: ["dragStart", "dragEnd", "gutterClick", "gutterDblClick", "transitionEnd"], exportAs: ["asSplit"] }, { type: i1$3.CanvasItemColumnComponent, selector: "rx-canvas-item-column", inputs: ["isReadOnly", "colIndex", "column", "layout"], outputs: ["dropListDropped"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2$2.SplitAreaDirective, selector: "as-split-area, [as-split-area]", inputs: ["order", "size", "minSize", "maxSize", "lockSize", "visible"], exportAs: ["asSplitArea"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerCanvasItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-container-canvas-item',
                    templateUrl: './container-canvas-item.component.html',
                    styleUrls: ['./container-canvas-item.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1$3.CanvasItemApi, decorators: [{
                    type: Inject,
                    args: [ViewDesignerCanvasItemApiToken]
                }] }, { type: i1$3.CanvasOutletHelperService }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { splitComponent: [{
                type: ViewChild,
                args: [SplitComponent, { static: true }]
            }], columnResize: [{
                type: Output
            }], onWindowResize: [{
                type: HostListener,
                args: ['window:resize']
            }] } });

var ContainerRowWrap;
(function (ContainerRowWrap) {
    ContainerRowWrap["Xs"] = "xs";
    ContainerRowWrap["Sm"] = "sm";
    ContainerRowWrap["Md"] = "md";
    ContainerRowWrap["Lg"] = "lg";
    ContainerRowWrap["Xl"] = "xl";
    ContainerRowWrap["Xxl"] = "xxl";
})(ContainerRowWrap || (ContainerRowWrap = {}));

const RX_CONTAINER = {
    type: RxViewComponentType.Container,
    maxColumnSpan: 12,
    rowWrapOptions: {
        xs: {
            id: ContainerRowWrap.Xs,
            name: 'Extra Small (No wrapping)'
        },
        sm: {
            id: ContainerRowWrap.Sm,
            name: 'Small (576 px)'
        },
        md: {
            id: ContainerRowWrap.Md,
            name: 'Medium (768 px)'
        },
        lg: {
            id: ContainerRowWrap.Lg,
            name: 'Large (992 px)'
        },
        xl: {
            id: ContainerRowWrap.Xl,
            name: 'Extra Large (1200 px)'
        },
        xxl: {
            id: ContainerRowWrap.Xxl,
            name: 'Extra Extra Large (1600 px)'
        }
    }
};

const cssClassesAutocompleteValues = RX_VIEW_DEFINITION.styles.map((style) => ({ text: style.name, data: { value: style.id } }));
class ContainerDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.componentProperties$ = this.sandbox.componentProperties$;
        this.hasChildren$ = this.sandbox.getChildComponentGuids().pipe(map((guids) => !isEmpty(guids)));
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({ name: null, rowWrap: ContainerRowWrap.Sm, columnCount: '1' }, RX_STANDARD_PROPS_DEFAULT_VALUES), initialProperties);
    }
    rxInit() {
        this.componentProperties$.pipe(take(1)).subscribe(() => {
            this.sandbox.updateInspectorConfig(this.getInspector());
        });
        this.componentProperties$.subscribe((componentProperties) => this.validate(componentProperties));
        this.sandbox
            .getComponentPropertyValue('columnCount')
            .pipe(skip(1), takeUntil(this.sandbox.destroyed$))
            .subscribe((columnCount) => {
            this.sandbox.setLayout(this.getDefaultColumnSpans(Number(columnCount)));
        });
        this.sandbox.getComponentPropertyValue('name').subscribe((name) => {
            const componentName = name ? `${this.sandbox.descriptor.name} (${name})` : this.sandbox.descriptor.name;
            this.sandbox.setSettablePropertiesDataDictionary(componentName, [
                {
                    label: 'Hidden',
                    expression: this.getExpressionForProperty('hidden')
                }
            ]);
        });
    }
    validate(model) {
        this.sandbox.setValidationIssues(validateStandardProps(model));
    }
    getPropertiesByName(properties) {
        const result = Object.assign({}, properties);
        if (!result.styles) {
            delete result.styles;
        }
        return result;
    }
    setContainerLayout(columnSizes) {
        this.sandbox.setLayout(columnSizes);
    }
    getDefaultColumnSpans(columnCount) {
        const columnSpans = [];
        const span = Math.floor(RX_CONTAINER.maxColumnSpan / columnCount);
        times(columnCount, () => columnSpans.push(span));
        columnSpans[columnSpans.length - 1] = (RX_CONTAINER.maxColumnSpan % columnCount) + span;
        return columnSpans;
    }
    getInspector() {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'name',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Name',
                                tooltip: new Tooltip('Enter a name to uniquely identify the Container.')
                            }
                        },
                        {
                            name: 'columnCount',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Number of columns',
                                required: true,
                                tooltip: new Tooltip('Resize container columns on the canvas by dragging the dashed column separator line.'),
                                options: times(6, (index) => ({ id: (++index).toString(), name: index.toString() }))
                            }
                        },
                        {
                            name: 'rowWrap',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Row wrap',
                                sortAlphabetically: false,
                                options: values(RX_CONTAINER.rowWrapOptions),
                                tooltip: new Tooltip(`The Row wrap property controls the layout of multi-column containers based on
                    the width of the view. When the width of the view is decreased to a width less
                    than the selected Row wrap value, each container column after the first one
                    wraps onto a new line.`)
                            }
                        },
                        getHiddenFieldInspectorConfig(),
                        getAvailableOnDevicesInspectorConfig(),
                        getStylesFieldInspectorConfig(cssClassesAutocompleteValues)
                    ]
                }
            ]
        };
    }
}

class ContainerDesignComponent {
    constructor() {
        this.containerCanvasItemComponent = ContainerCanvasItemComponent;
        this.destroyed$ = new ReplaySubject(1);
    }
    ngAfterViewInit() {
        this.canvasOutletComponent.containerComponentInstance.columnResize
            .pipe(takeUntil(this.destroyed$))
            .subscribe((columnSizes) => {
            this.model.setContainerLayout(columnSizes);
        });
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
}
ContainerDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ContainerDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ContainerDesignComponent, selector: "rx-container-design", inputs: { model: "model" }, viewQueries: [{ propertyName: "canvasOutletComponent", first: true, predicate: CanvasOutletComponent, descendants: true, static: true }], ngImport: i0, template: "<rx-canvas-outlet\n  class=\"border d-block\"\n  [class.has-children]=\"model.hasChildren$ | async\"\n  [containerComponent]=\"containerCanvasItemComponent\"\n></rx-canvas-outlet>\n", styles: [".has-children ::ng-deep>rx-container-canvas-item>as-split>as-split-area{min-height:auto}\n"], components: [{ type: i1$3.CanvasOutletComponent, selector: "rx-canvas-outlet", inputs: ["name", "skipParentPredicate", "containerComponent", "dropListOrientation", "dropPredicate"], outputs: ["beforeViewComponentDrop"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-container-design',
                    templateUrl: './container-design.component.html',
                    styleUrls: ['./container-design.component.scss']
                }]
        }], propDecorators: { model: [{
                type: Input
            }], canvasOutletComponent: [{
                type: ViewChild,
                args: [CanvasOutletComponent, { static: true }]
            }] } });

class ContainerDesignModule {
}
ContainerDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ContainerDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerDesignModule, declarations: [ContainerDesignComponent, ContainerCanvasItemComponent], imports: [CommonModule, ViewDesignerCanvasModule, AngularSplitModule, DragDropModule] });
ContainerDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerDesignModule, providers: [RxActionButtonService], imports: [[CommonModule, ViewDesignerCanvasModule, AngularSplitModule, DragDropModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ViewDesignerCanvasModule, AngularSplitModule, DragDropModule],
                    declarations: [ContainerDesignComponent, ContainerCanvasItemComponent],
                    entryComponents: [ContainerDesignComponent, ContainerCanvasItemComponent],
                    providers: [RxActionButtonService]
                }]
        }] });

const RECORD_EDITOR = {
    type: RxViewComponentType.RecordEditor,
    fieldTypes: {
        [RX_RECORD_DEFINITION.resourceTypes.character]: RxViewComponentType.Character,
        [RX_RECORD_DEFINITION.resourceTypes.dateTime]: RxViewComponentType.DateTime,
        [RX_RECORD_DEFINITION.resourceTypes.selection]: RxViewComponentType.Selection,
        [RX_RECORD_DEFINITION.resourceTypes.timeOnly]: RxViewComponentType.Time,
        [RX_RECORD_DEFINITION.resourceTypes.dateOnly]: RxViewComponentType.Date,
        [RX_RECORD_DEFINITION.resourceTypes.boolean]: RxViewComponentType.Boolean,
        [RX_RECORD_DEFINITION.resourceTypes.attachment]: RxViewComponentType.Attachment,
        [RX_RECORD_DEFINITION.resourceTypes.integer]: RxViewComponentType.Integer,
        [RX_RECORD_DEFINITION.resourceTypes.real]: RxViewComponentType.Floating,
        [RX_RECORD_DEFINITION.resourceTypes.decimal]: RxViewComponentType.Decimal,
        [RX_RECORD_DEFINITION.resourceTypes.localizedCharacter]: RxViewComponentType.LocalizedCharacter
    }
};
var RecordEditorMode;
(function (RecordEditorMode) {
    RecordEditorMode["Create"] = "CREATE";
    RecordEditorMode["Edit"] = "EDIT";
    RecordEditorMode["BulkEdit"] = "BULK EDIT";
    RecordEditorMode["Temporary"] = "TEMPORARY";
})(RecordEditorMode || (RecordEditorMode = {}));
var RecordEditorState;
(function (RecordEditorState) {
    RecordEditorState["Read"] = "READ";
    RecordEditorState["Edit"] = "EDIT";
})(RecordEditorState || (RecordEditorState = {}));

class FieldSelectorComponent {
    constructor(context, stringService) {
        this.context = context;
        this.stringService = stringService;
        this.selectedFieldIdsModel = {};
        this.availableFieldGroups = [];
        this.hideSystemFields = false;
        this.isApplyButtonDisabled = true;
        this.selectedFieldDefinitionIds = [];
        this.availableFieldDefinitions = [];
    }
    ngOnInit() {
        const data = this.context.getData();
        this.availableFieldDefinitions = data.availableFields;
        this.selectedFieldDefinitionIds = data.selectedFieldIds;
        this.hideSystemFields = Boolean(data.hideSystemFields);
        this.availableFieldGroups = this.groupFieldsByFieldOption(this.availableFieldDefinitions);
        this.selectedFieldIdsModel = this.idsToModel(this.selectedFieldDefinitionIds);
    }
    closeModal() {
        this.context.close(this.modelToIds(this.selectedFieldIdsModel));
    }
    search(searchQuery) {
        this.availableFieldGroups = this.groupFieldsByFieldOption(this.availableFieldDefinitions)
            .map((fieldGroup) => (Object.assign(Object.assign({}, fieldGroup), { fields: fieldGroup.fields.filter((field) => this.stringService.caseInsensitiveSearch(field.name, searchQuery)) })))
            .filter((fieldGroup) => !isEmpty(fieldGroup.fields));
    }
    select(groupName) {
        if (groupName === 'all') {
            const ids = this.availableFieldDefinitions
                .filter((recordField) => {
                return recordField.fieldOption !== RecordFieldOption.System || !this.hideSystemFields;
            })
                .map((recordField) => recordField.id);
            this.selectedFieldIdsModel = this.idsToModel(ids);
        }
        else {
            const ids = this.availableFieldGroups
                .find((group) => group.groupLabel === groupName)
                .fields.map((recordField) => recordField.id);
            this.selectedFieldIdsModel = Object.assign(Object.assign({}, this.selectedFieldIdsModel), this.idsToModel(ids));
        }
        this.updateApplyButtonDisabledStatus();
    }
    updateApplyButtonDisabledStatus() {
        this.isApplyButtonDisabled = !xor(this.selectedFieldDefinitionIds, this.modelToIds(this.selectedFieldIdsModel))
            .length;
    }
    groupFieldsByFieldOption(availableFields) {
        const groups = groupBy(availableFields, 'fieldOption');
        const groupTypes = [RecordFieldOption.Required, RecordFieldOption.Optional];
        if (!this.hideSystemFields) {
            groupTypes.push(RecordFieldOption.System);
        }
        return groupTypes
            .filter((groupType) => groups[groupType])
            .map((groupType) => ({
            groupLabel: `${this.stringService.prettify(groupType)} fields`,
            selectAllFieldsInGroupButtonLabel: `Select all ${groupType.toLowerCase()} fields`,
            fields: groups[groupType].map(({ id, name }) => ({ id, name })).sort((a, b) => a.name.localeCompare(b.name))
        }));
    }
    trackByLabel(index, item) {
        return item.groupLabel;
    }
    trackById(index, item) {
        return item.id;
    }
    idsToModel(ids, selected = true) {
        return ids.filter(Boolean).reduce((result, id) => {
            result[id] = selected;
            return result;
        }, {});
    }
    modelToIds(model) {
        return reduce(model, (result, value, id) => {
            if (value) {
                result.push(id);
            }
            return result;
        }, []);
    }
}
FieldSelectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldSelectorComponent, deps: [{ token: i1.ActiveModalRef }, { token: i2$1.RxStringService }], target: i0.ɵɵFactoryTarget.Component });
FieldSelectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: FieldSelectorComponent, selector: "ng-component", ngImport: i0, template: "<div class=\"modal-header pr-0\">\n  <h5 class=\"modal-title pl-0 mr-auto\">Quick edit fields</h5>\n\n  <button\n    adapt-button\n    type=\"button\"\n    size=\"small\"\n    btn-type=\"primary\"\n    rx-id=\"apply-button\"\n    (click)=\"closeModal()\"\n    [disabled]=\"isApplyButtonDisabled\"\n    class=\"mr-5\"\n  >\n    Apply\n  </button>\n\n  <button\n    class=\"close my-1\"\n    adapt-button\n    type=\"button\"\n    size=\"small\"\n    btn-type=\"tertiary\"\n    (click)=\"context.dismiss(0)\"\n    rx-id=\"x-button\"\n  ></button>\n</div>\n\n<div class=\"modal-body\">\n  <div class=\"body-controls\">\n    <adapt-button btn-type=\"tertiary\" rx-id=\"select-all-button\" class=\"pl-0\" (click)=\"select('all')\">\n      Select all\n    </adapt-button>\n\n    <adapt-rx-textfield\n      [placeholder]=\"'Search fields'\"\n      [ngModel]=\"searchQuery\"\n      [attr.rx-id]=\"'search-field'\"\n      (ngModelChange)=\"search($event)\"\n      class=\"form-group\"\n    >\n    </adapt-rx-textfield>\n  </div>\n\n  <div class=\"rx-record-definition-fields\">\n    <div\n      class=\"rx-record-definition-field-group\"\n      *ngFor=\"let availableFieldsGroup of availableFieldGroups; trackBy: trackByLabel\"\n    >\n      <div class=\"font-weight-bold\">\n        {{ availableFieldsGroup.groupLabel }}\n      </div>\n\n      <adapt-button btn-type=\"tertiary\" class=\"py-0 pl-0\" (click)=\"select(availableFieldsGroup.groupLabel)\">\n        {{ availableFieldsGroup.selectAllFieldsInGroupButtonLabel }}\n      </adapt-button>\n\n      <div class=\"checkbox\" *ngFor=\"let availableField of availableFieldsGroup.fields; trackBy: trackById\">\n        <label>\n          <input\n            type=\"checkbox\"\n            [(ngModel)]=\"selectedFieldIdsModel[availableField.id]\"\n            (ngModelChange)=\"updateApplyButtonDisabledStatus()\"\n          />\n\n          <span class=\"checkbox__item\">{{ availableField.name }}</span>\n        </label>\n      </div>\n    </div>\n\n    <div *ngIf=\"availableFieldGroups.length === 0\">No Fields Found</div>\n  </div>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.modal-title{margin:auto 0}span[rx-id=x-button]{cursor:pointer;margin:auto 0}span[rx-id=x-button]:hover{color:#959899}.body-controls{display:flex}.body-controls adapt-rx-textfield{flex:1}.rx-record-definition-fields{padding:10px;border:1px solid #d6d7d8;max-height:300px;overflow:auto}.rx-record-definition-field-group{margin-bottom:20px}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2$3.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldSelectorComponent, decorators: [{
            type: Component,
            args: [{
                    templateUrl: './field-selector.component.html',
                    styleUrls: ['./field-selector.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i2$1.RxStringService }]; } });

class FieldsInspectorWidgetComponent extends InspectorWidgetBase {
    constructor(injector, adaptModalService, renderer) {
        super(injector);
        this.adaptModalService = adaptModalService;
        this.renderer = renderer;
        this.encapsulateClass = true;
    }
    focus() {
        this.renderer.selectRootElement(this.openModalButton.nativeElement, true).click();
    }
    openModal() {
        combineLatest([
            this.designerItemModel.childFieldIds$,
            this.designerItemModel.recordFieldDefinitionItems$,
            this.designerItemModel.isExtensionView$,
            this.designerItemModel.associationDefinitionName$
        ])
            .pipe(take(1), concatMap(([selectedFieldIds, availableFields, isExtensionView, associationDefinitionName]) => this.adaptModalService.open({
            content: FieldSelectorComponent,
            data: {
                selectedFieldIds,
                availableFields: isExtensionView && associationDefinitionName
                    ? availableFields.filter((field) => field.resourceType !== RX_RECORD_DEFINITION.resourceTypes.attachment)
                    : availableFields,
                hideSystemFields: this.options.hideSystemFields
            },
            size: 'sm',
            hideBackdrop: false,
            customClass: 'rx-record-editor-field-selector-modal'
        })))
            .subscribe((selectedFieldIds) => {
            this.designerItemModel.updateSelectedFieldComponents(selectedFieldIds);
        });
    }
    removeField(guid) {
        this.designerItemModel.removeComponent([guid]);
    }
    trackByGuid(index, item) {
        return item.guid;
    }
}
FieldsInspectorWidgetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldsInspectorWidgetComponent, deps: [{ token: i0.Injector }, { token: i1.AdaptModalService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
FieldsInspectorWidgetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: FieldsInspectorWidgetComponent, selector: "rx-fields-inspector-widget", host: { properties: { "class.rx-record-definition-fields": "this.encapsulateClass" } }, viewQueries: [{ propertyName: "openModalButton", first: true, predicate: ["openModalButton"], descendants: true, read: ElementRef, static: true }], usesInheritance: true, ngImport: i0, template: "<adapt-button\n  btn-type=\"tertiary\"\n  #openModalButton\n  rx-id=\"open-modal-button\"\n  class=\"px-0 py-0\"\n  (click)=\"openModal()\"\n  [hidden]=\"options.isDisabled\"\n>\n  <span class=\"d-icon-plus_circle\"></span>\n  Quick edit fields\n</adapt-button>\n\n<div rx-id=\"columns\">\n  <span *ngIf=\"(designerItemModel.selectedFieldComponents$ | async).length === 0\" class=\"text-tertiary\"\n    >No fields added.</span\n  >\n</div>\n\n<div class=\"mt-2\">\n  <div\n    class=\"rx-field-item\"\n    *ngFor=\"let field of designerItemModel.selectedFieldComponents$ | async; trackBy: trackByGuid\"\n  >\n    <div>\n      <div class=\"rx-field-name\">{{ field.label }}</div>\n\n      <div class=\"rx-field-type\">\n        <small>{{ field.componentName }}</small>\n      </div>\n    </div>\n\n    <div class=\"rx-action-button\">\n      <span\n        *ngIf=\"!options.isDisabled\"\n        (click)=\"removeField(field.guid)\"\n        class=\"d-icon-cross btn-link\"\n        rx-id=\"delete-button\"\n      >\n      </span>\n    </div>\n  </div>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.rx-record-definition-fields .rx-field-item{margin-bottom:5px;border:1px solid #d6d7d8;border-radius:2px;padding:5px 10px;font-size:12px;display:flex;justify-content:space-between;word-break:break-all}.rx-record-definition-fields .rx-field-name{font-weight:var(--font-weight-bold)}.rx-record-definition-fields .rx-field-type{color:#959899}.rx-record-definition-fields .d-icon-cross{cursor:pointer}.rx-record-definition-fields .d-icon-cross:not(:hover){color:#313538}.rx-record-editor-field-selector-modal .modal{justify-content:flex-end}.rx-record-editor-field-selector-modal .modal-scroll-container{padding:15px;min-height:0}.rx-record-editor-field-selector-modal .modal-dialog{margin:auto 0 0 auto;min-height:0;width:350px}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldsInspectorWidgetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-fields-inspector-widget',
                    templateUrl: './fields-inspector-widget.component.html',
                    styleUrls: ['./fields-inspector-widget.component.scss'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.AdaptModalService }, { type: i0.Renderer2 }]; }, propDecorators: { encapsulateClass: [{
                type: HostBinding,
                args: ['class.rx-record-definition-fields']
            }], openModalButton: [{
                type: ViewChild,
                args: ['openModalButton', { read: ElementRef, static: true }]
            }] } });

class RxRecordEditorDesignHelpersService {
    constructor(rxRecordDefinitionCacheService, rxModalService, rxFieldDefinitionService, rxViewDefinitionCacheService, rxAssociationDefinitionDataPageService, rxDefinitionNameService, rxViewComponentRegistryService, rxViewDefinitionParserService) {
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.rxModalService = rxModalService;
        this.rxFieldDefinitionService = rxFieldDefinitionService;
        this.rxViewDefinitionCacheService = rxViewDefinitionCacheService;
        this.rxAssociationDefinitionDataPageService = rxAssociationDefinitionDataPageService;
        this.rxDefinitionNameService = rxDefinitionNameService;
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.rxViewDefinitionParserService = rxViewDefinitionParserService;
    }
    getRecordFieldDefinitionItems(recordDefinition) {
        return recordDefinition.fieldDefinitions.map((fieldDefinition) => ({
            id: String(fieldDefinition.id),
            name: fieldDefinition.name,
            resourceType: fieldDefinition.resourceType,
            fieldOption: fieldDefinition.fieldOption,
            viewComponentType: this.getViewComponentType(fieldDefinition)
        }));
    }
    getViewComponentType(fieldDefinition) {
        let viewComponentType = RECORD_EDITOR.fieldTypes[fieldDefinition.resourceType];
        if (fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.character) {
            viewComponentType =
                fieldDefinition.namedListDefinition || inRange(fieldDefinition.maxLength, 1, 255)
                    ? RxViewComponentType.Character
                    : RxViewComponentType.Textarea;
        }
        if (fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.real) {
            viewComponentType = RxViewComponentType.Decimal;
        }
        return viewComponentType;
    }
    getComponentProperties(properties) {
        const requiredPropertyNames = ['recordDefinitionName', 'mode', 'allowEdit'];
        return flow(
        // Remove design properties.
        (props) => omit(props, 'showReadOnlyState'), 
        // Remove optional properties with empty values.
        (props) => omitBy(props, (propertyValue, propertyName) => !requiredPropertyNames.includes(propertyName) && (isNil(propertyValue) || propertyValue === '')))(properties);
    }
    getRecordDefinition(recordDefinitionName) {
        if (recordDefinitionName) {
            return this.rxRecordDefinitionCacheService
                .getRecordDefinition(recordDefinitionName)
                .pipe(catchError((error) => EMPTY));
        }
        else {
            return of(null);
        }
    }
    validate(sandbox, properties, recordDefinition, childFieldIds, isAssociationRequired = false, isExtensionView = false) {
        const validationIssues = [];
        if (!properties.recordDefinitionName) {
            validationIssues.push(sandbox.createError('Record definition name cannot be blank.', 'recordDefinitionName'));
        }
        if (isAssociationRequired && properties.recordDefinitionName && !properties.associationDefinitionName) {
            validationIssues.push(sandbox.createError('Association to use cannot be blank.', 'associationDefinitionName'));
        }
        if (!isExtensionView && properties.mode === RecordEditorMode.Edit && !properties.recordInstanceId) {
            validationIssues.push(sandbox.createError('Record ID cannot be blank.', 'recordInstanceId'));
        }
        if (recordDefinition && properties.recordDefinitionName && properties.mode === RecordEditorMode.Create) {
            // Add warning for Join Record Definition case
            if (recordDefinition.resourceType === RX_RECORD_DEFINITION.recordDefinitionTypes.join.recordDefinitionType) {
                validationIssues.push(sandbox.createWarning(`You have configured a record editor to create join record instances.
                        Please ensure that one or more processes or rules have been defined to perform the creation
                        of the join record instance.`, undefined, true));
            }
            // System fields in 'CREATE' mode cannot be chosen
            const systemFieldNames = childFieldIds
                .map((selectedFieldId) => recordDefinition.fieldDefinitions.find((fieldDefinition) => fieldDefinition.id === Number(selectedFieldId)))
                .filter(this.rxFieldDefinitionService.isSystemField)
                .map((fieldDefinition) => fieldDefinition.name);
            if (systemFieldNames.length) {
                validationIssues.push(sandbox.createError(`System fields (${systemFieldNames.join(', ')}) cannot be present when Record editor is in Create mode.`));
            }
            // Required fields without default value must be included when in 'CREATE' mode.
            // When in extension view, this validation is only needed when the Record Editor
            // is bound to an associated record, i.e. not the same record as the target Record Editor,
            // which should already contain all such fields.
            if (!isExtensionView || properties.associationDefinitionName) {
                const requiredFieldsWithoutDefaultValues = recordDefinition.fieldDefinitions.filter((fieldDefinition) => {
                    const isLocalizedCharacterField = fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.localizedCharacter;
                    const hasDefaultValue = fieldDefinition.defaultValue ||
                        isFinite(fieldDefinition.defaultValue) ||
                        (isLocalizedCharacterField && !isEmpty(fieldDefinition.defaultValueByLocale));
                    return fieldDefinition.fieldOption === RX_RECORD_DEFINITION.fieldOptions.required && !hasDefaultValue;
                });
                const requiredFieldNames = requiredFieldsWithoutDefaultValues
                    .filter((fieldDefinition) => !childFieldIds.includes(String(fieldDefinition.id)))
                    .map((fieldDefinition) => fieldDefinition.name);
                if (requiredFieldNames.length) {
                    validationIssues.push(sandbox.createError(`Required fields are missing: ${requiredFieldNames.join(', ')}.`));
                }
            }
        }
        validationIssues.push(...validateStandardProps(properties));
        return validationIssues;
    }
    getViewDefinition(viewDefinitionName) {
        if (viewDefinitionName) {
            return this.rxViewDefinitionCacheService.getViewDefinition(viewDefinitionName).pipe(catchError(() => of(null)));
        }
        else {
            return of(null);
        }
    }
    getInspector(recordDefinitionName, mode, showReadOnlyState, recordFieldDefinitionItems = [], isExtensionView = false, associationOptions = [], isAssociationRequired = false, onBeforeModeChange) {
        const inspectorConfig = {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'name',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Name',
                                tooltip: new Tooltip('Enter a name to uniquely identify the Record editor.')
                            }
                        },
                        {
                            name: 'recordDefinitionName',
                            component: RxDefinitionPickerComponent,
                            options: {
                                label: 'Record definition name',
                                definitionType: RxDefinitionPickerType.StandardDataRecord,
                                required: true,
                                beforeValueChange: (oldValue, newValue) => {
                                    if (Boolean(oldValue)) {
                                        return this.rxModalService.confirm({
                                            title: 'Warning',
                                            modalStyle: RX_MODAL.modalStyles.warning,
                                            message: 'All view components will be removed from the Record editor. Do you want to continue?'
                                        });
                                    }
                                    else {
                                        return Promise.resolve(true);
                                    }
                                }
                            }
                        },
                        {
                            name: 'mode',
                            component: GroupButtonFormControlComponent,
                            options: {
                                label: 'Mode',
                                tooltip: new Tooltip('<b>Record editor modes:</b><br><ul><li>Create mode is for creating new records.</li><li>Edit mode is for updating records.</li><li>Temporary mode is for holding data that does not need to be saved.</li></ul>'),
                                required: true,
                                items: [
                                    {
                                        name: 'Create',
                                        value: RecordEditorMode.Create
                                    },
                                    {
                                        name: 'Edit',
                                        value: RecordEditorMode.Edit
                                    },
                                    {
                                        name: 'Temporary',
                                        value: RecordEditorMode.Temporary
                                    }
                                ],
                                beforeValueChange: onBeforeModeChange
                            }
                        }
                    ]
                }
            ]
        };
        const generalSectionControls = inspectorConfig.inspectorSectionConfigs[0].controls;
        if (mode === RecordEditorMode.Edit && !isExtensionView) {
            generalSectionControls.push({
                name: 'recordInstanceId',
                component: ExpressionInspectorControlComponent,
                options: {
                    label: 'Record ID',
                    tooltip: new Tooltip('Enter the record ID of the record that the users need to edit.'),
                    isRequired: true
                }
            });
            generalSectionControls.push({
                name: 'showReadOnlyState',
                component: SwitchFormControlComponent,
                options: {
                    label: 'Enable read state'
                }
            });
            if (showReadOnlyState) {
                generalSectionControls.push({
                    name: 'defaultState',
                    component: GroupButtonFormControlComponent,
                    options: {
                        label: 'Default state',
                        items: [
                            {
                                name: 'Read',
                                value: RecordEditorState.Read
                            },
                            {
                                name: 'Edit',
                                value: RecordEditorState.Edit
                            }
                        ]
                    }
                });
            }
            generalSectionControls.push({
                name: 'allowEdit',
                component: OptionalExpressionInspectorControlComponent,
                options: {
                    label: 'Allow edit'
                }
            });
        }
        generalSectionControls.push(getAvailableOnDevicesInspectorConfig(), getStylesFieldInspectorConfig());
        if (isExtensionView) {
            generalSectionControls.splice(1, 0, {
                name: 'label',
                component: TextFormControlComponent,
                options: {
                    label: 'Display label',
                    tooltip: new Tooltip(`Enter a Display label for the Record editor. When this view is injected into the view to extend,
              the Display label will be shown above the Record editor's fields. If a Display label is not defined,
              the name of the source application or library will be shown above the fields.`)
                }
            });
            if (recordDefinitionName) {
                generalSectionControls.splice(3, 0, {
                    name: 'associationDefinitionName',
                    component: SelectFormControlComponent,
                    options: {
                        label: 'Association to use',
                        options: associationOptions,
                        emptyOption: !isAssociationRequired,
                        required: isAssociationRequired
                    }
                });
            }
        }
        const formContentsSection = {
            label: 'Form contents',
            controls: [
                {
                    component: FieldsInspectorWidgetComponent,
                    options: {
                        label: 'Selected fields',
                        hideSystemFields: mode === RecordEditorMode.Create
                    }
                }
            ]
        };
        if (recordDefinitionName) {
            inspectorConfig.inspectorSectionConfigs.push(formContentsSection);
        }
        return inspectorConfig;
    }
    getAssociationOptions(firstRecordDefinitionName, secondRecordDefinitionName) {
        if (firstRecordDefinitionName && secondRecordDefinitionName) {
            return this.getAssociations(firstRecordDefinitionName, secondRecordDefinitionName).pipe(map((res) => res.data
                .filter((association) => association.nodeAId === firstRecordDefinitionName)
                .map((association) => ({
                id: association.name,
                name: this.rxDefinitionNameService.getDisplayName(association.name)
            }))));
        }
        else {
            return of([]);
        }
    }
    getAssociations(firstRecordDefinitionName, secondRecordDefinitionName) {
        return this.rxAssociationDefinitionDataPageService.get({
            params: {
                propertySelection: ['name', 'scope', 'nodeAId'],
                firstRecordDefinitionName: firstRecordDefinitionName,
                secondRecordDefinitionName: secondRecordDefinitionName,
                cardinality: RX_ASSOCIATION_DEFINITION.cardinality.oneToOne.value,
                nodeAModality: RX_ASSOCIATION_DEFINITION.modality.required,
                shouldCascadeDelete: true
            },
            headers: { 'default-bundle-scope': '' }
        });
    }
    getTargetRecordEditorProperties(viewDefinition, targetExtensionContainerGuid) {
        let targetRecordEditor;
        if (viewDefinition && targetExtensionContainerGuid) {
            targetRecordEditor = this.rxViewDefinitionParserService.findParentComponentDefinition(viewDefinition, { guid: targetExtensionContainerGuid }, (definition) => definition.type === RxViewComponentType.RecordEditor);
        }
        return get(targetRecordEditor, 'propertiesByName', {});
    }
    confirmSystemFieldRemoval() {
        return from(this.rxModalService.confirm({
            title: 'Warning',
            modalStyle: RX_MODAL.modalStyles.warning,
            message: 'System fields will be removed. Do you want to continue?'
        }));
    }
    getSystemFieldModelGuids(plainFieldModels, recordDefinition) {
        if (!isEmpty(plainFieldModels)) {
            return plainFieldModels.reduce((systemFieldGuids, model) => {
                const fieldDefinition = recordDefinition.fieldDefinitions.find((definition) => String(definition.id) === model.data.fieldId);
                if (this.rxFieldDefinitionService.isSystemField(fieldDefinition)) {
                    systemFieldGuids.push(model.guid);
                }
                return systemFieldGuids;
            }, []);
        }
        else {
            return [];
        }
    }
    isFieldComponent(component) {
        return (![
            RxViewComponentType.Action,
            RxViewComponentType.ActionButton,
            RxViewComponentType.Association,
            RxViewComponentType.AssociatedRecordField
        ].includes(component.type) &&
            Boolean(this.rxViewComponentRegistryService.get(component.type).properties.find((prop) => prop.name === 'fieldId')));
    }
}
RxRecordEditorDesignHelpersService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordEditorDesignHelpersService, deps: [{ token: i1$5.RxRecordDefinitionCacheService }, { token: i1$6.RxModalService }, { token: i1$5.RxFieldDefinitionService }, { token: i1$4.RxViewDefinitionCacheService }, { token: i2$4.RxAssociationDefinitionDataPageService }, { token: i1$1.RxDefinitionNameService }, { token: i1$4.RxViewComponentRegistryService }, { token: i1$4.RxViewDefinitionParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordEditorDesignHelpersService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordEditorDesignHelpersService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordEditorDesignHelpersService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$5.RxRecordDefinitionCacheService }, { type: i1$6.RxModalService }, { type: i1$5.RxFieldDefinitionService }, { type: i1$4.RxViewDefinitionCacheService }, { type: i2$4.RxAssociationDefinitionDataPageService }, { type: i1$1.RxDefinitionNameService }, { type: i1$4.RxViewComponentRegistryService }, { type: i1$4.RxViewDefinitionParserService }]; } });

class RecordEditorDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.rxFieldDefinitionService = this.injector.get(RxFieldDefinitionService);
        this.rxViewComponentRegistryService = this.injector.get(RxViewComponentRegistryService);
        this.rxRecordEditorDesignHelpersService = this.injector.get(RxRecordEditorDesignHelpersService);
        this.rxDefinitionNameService = this.injector.get(RxDefinitionNameService);
        this.updateInspector$ = new Subject();
        this.recordDefinitionName$ = this.sandbox.getComponentPropertyValue('recordDefinitionName');
        this.mode$ = this.sandbox.getComponentPropertyValue('mode');
        this.showReadOnlyState$ = this.sandbox.getComponentPropertyValue('showReadOnlyState');
        this.targetExtensionContainerGuid$ = this.sandbox.getViewPropertyValue('targetExtensionContainerGuid');
        this.targetViewDefinitionName$ = this.sandbox.getViewPropertyValue('targetViewDefinitionName');
        this.recordDefinition$ = this.recordDefinitionName$.pipe(switchMap((name) => this.rxRecordEditorDesignHelpersService.getRecordDefinition(name)), shareReplay(1));
        this.childComponentGuids$ = this.sandbox.getChildComponentGuids().pipe(shareReplay(1));
        this.allChildFieldComponentGuids$ = this.sandbox
            .getChildComponentGuids((component) => this.rxRecordEditorDesignHelpersService.isFieldComponent(component), true)
            .pipe(distinctUntilChanged(isEqual), shareReplay(1));
        this.isExtensionView$ = this.targetViewDefinitionName$.pipe(map(Boolean), shareReplay(1));
        this.childFieldIds$ = this.allChildFieldComponentGuids$.pipe(switchMap((guids) => guids.length
            ? combineLatest(guids.map((guid) => this.sandbox.getComponentPropertyValue('fieldId', guid))).pipe(map(uniq))
            : of([])), shareReplay(1));
        this.selectedFieldComponents$ = this.allChildFieldComponentGuids$.pipe(switchMap((guids) => guids.length
            ? combineLatest(guids.map((guid) => combineLatest([
                this.sandbox.getComponent(guid).pipe(take(1), map((component) => this.rxViewComponentRegistryService.get(component.type).name)),
                this.sandbox.getComponentPropertyValue('fieldId', guid),
                this.sandbox.getComponentPropertyValue('label', guid)
            ]).pipe(map(([componentName, fieldId, label]) => ({
                fieldId,
                label: label || '<No field selected>',
                componentName,
                guid
            })))))
            : of([])), shareReplay(1));
        this.associationComponentGuids$ = this.sandbox
            .getChildComponentGuids((component) => component.type === RxViewComponentType.Association, true)
            .pipe(shareReplay(1), takeUntil(this.sandbox.destroyed$));
        this.associationDefinitionName$ = this.sandbox.getComponentPropertyValue('associationDefinitionName');
        this.hasChildren$ = this.childComponentGuids$.pipe(map((guids) => Boolean(guids.length)), distinctUntilChanged(), shareReplay(1));
        this.systemFieldComponentGuids$ = this.recordDefinition$.pipe(mergeMap((recordDefinition) => recordDefinition
            ? this.selectedFieldComponents$.pipe(map((components) => components
                .filter((component) => {
                const fieldDefinition = recordDefinition.fieldDefinitions.find((definition) => String(definition.id) === component.fieldId);
                return this.rxFieldDefinitionService.isSystemField(fieldDefinition);
            })
                .map((component) => component.guid)), take(1))
            : of([])));
        this.recordFieldDefinitionItems$ = this.recordDefinition$.pipe(map((recordDefinition) => recordDefinition ? this.rxRecordEditorDesignHelpersService.getRecordFieldDefinitionItems(recordDefinition) : []), shareReplay(1));
    }
    static getInitialProperties(initialProps) {
        const result = Object.assign(Object.assign({ name: null, label: null, mode: RecordEditorMode.Edit, recordInstanceId: null, recordDefinitionName: null, associationDefinitionName: null, defaultState: initialProps.defaultState || null, allowEdit: '1', styles: null }, RX_AVAILABLE_ON_DEVICES_DEFAULT_VALUE), initialProps);
        return Object.assign(Object.assign({}, result), { showReadOnlyState: Boolean(result.defaultState), allowEdit: result.mode === RecordEditorMode.Edit ? result.allowEdit : null });
    }
    rxInit() {
        const targetRecordEditorProperties$ = combineLatest([
            this.targetViewDefinitionName$.pipe(switchMap((targetViewDefinitionName) => this.rxRecordEditorDesignHelpersService.getViewDefinition(targetViewDefinitionName))),
            this.targetExtensionContainerGuid$
        ]).pipe(map(([viewDefinition, targetExtensionContainerGuid]) => this.rxRecordEditorDesignHelpersService.getTargetRecordEditorProperties(viewDefinition, targetExtensionContainerGuid)));
        this.associationOptions$ = combineLatest([targetRecordEditorProperties$, this.recordDefinitionName$]).pipe(switchMap(([targetRecordEditorProperties, extensionRecordDefinitionName]) => this.rxRecordEditorDesignHelpersService.getAssociationOptions(targetRecordEditorProperties.recordDefinitionName, extensionRecordDefinitionName)));
        this.isAssociationRequired$ = combineLatest([
            this.isExtensionView$,
            this.recordDefinitionName$,
            targetRecordEditorProperties$
        ]).pipe(map(([isExtensionView, recordDefinitionName, targetRecordEditorProperties]) => isExtensionView && recordDefinitionName !== targetRecordEditorProperties.recordDefinitionName));
        this.updateInspector$.pipe(takeUntil(this.sandbox.destroyed$)).subscribe((inspector) => {
            this.sandbox.updateInspectorConfig(inspector);
        });
        // initial set of inspector
        combineLatest([
            this.sandbox.componentProperties$,
            this.isExtensionView$,
            this.associationOptions$,
            this.isAssociationRequired$,
            targetRecordEditorProperties$
        ])
            .pipe(first(), takeUntil(this.sandbox.destroyed$))
            .subscribe(([{ recordDefinitionName, mode, showReadOnlyState }, isExtensionView, associationOptions, isAssociationRequired, targetRecordEditorProperties]) => {
            if (isExtensionView && !recordDefinitionName) {
                recordDefinitionName = targetRecordEditorProperties.recordDefinitionName;
                mode = targetRecordEditorProperties.mode;
                this.sandbox.updateComponentProperties({ mode, recordDefinitionName });
            }
            this.updateInspector$.next(this.rxRecordEditorDesignHelpersService.getInspector(recordDefinitionName, mode, showReadOnlyState, [], isExtensionView, associationOptions, isAssociationRequired, this._onBeforeModeChange.bind(this)));
        });
        this.mode$
            .pipe(skip(1), withLatestFrom(this.sandbox.componentProperties$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([mode, props]) => {
            this.sandbox.updateComponentProperties(mode === RecordEditorMode.Create || mode === RecordEditorMode.Temporary
                ? Object.assign(Object.assign({}, props), { recordInstanceId: null, defaultState: null, allowEdit: null, showReadOnlyState: null }) : Object.assign(Object.assign({}, props), { defaultState: null, allowEdit: '1', showReadOnlyState: false }));
        });
        this.showReadOnlyState$
            .pipe(skip(1), withLatestFrom(this.sandbox.componentProperties$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([showReadOnlyState, props]) => {
            this.sandbox.updateComponentProperties(Object.assign(Object.assign({}, props), { defaultState: showReadOnlyState ? RecordEditorState.Read : null }));
        });
        combineLatest([
            combineLatest([
                this.sandbox.getComponentPropertyValue('recordDefinitionName'),
                this.sandbox.getComponentPropertyValue('mode'),
                this.showReadOnlyState$
            ]).pipe(skip(1)),
            this.recordFieldDefinitionItems$,
            this.isExtensionView$,
            this.associationOptions$,
            this.isAssociationRequired$
        ])
            .pipe(map(([[recordDefinitionName, mode, showReadOnlyState], recordFieldDefinitionItems, isExtensionView, associationOptions, isAssociationRequired]) => this.rxRecordEditorDesignHelpersService.getInspector(recordDefinitionName, mode, showReadOnlyState, recordFieldDefinitionItems, isExtensionView, associationOptions, isAssociationRequired, this._onBeforeModeChange.bind(this))), takeUntil(this.sandbox.destroyed$))
            .subscribe(this.updateInspector$);
        // clear child components after changing of record definition
        this.recordDefinitionName$
            .pipe(pairwise(), takeUntil(this.sandbox.destroyed$))
            .subscribe(([prevName, currentName]) => {
            if (prevName) {
                this.sandbox.setChildren([]);
                this.sandbox.updateComponentProperties({ associationDefinitionName: null });
            }
        });
        this.associationOptions$
            .pipe(skip(1), filter((associationOptions) => associationOptions.length === 1), withLatestFrom(this.isAssociationRequired$), filter(([, isAssociationRequired]) => isAssociationRequired), takeUntil(this.sandbox.destroyed$))
            .subscribe(([[{ id: associationDefinitionName }]]) => this.sandbox.updateComponentProperties({ associationDefinitionName }));
        // TODO: performance
        // validation
        combineLatest([
            this.sandbox.componentProperties$,
            this.recordDefinition$,
            this.childFieldIds$,
            this.isAssociationRequired$,
            this.isExtensionView$
        ])
            .pipe(map(([componentProperties, recordDefinition, childFieldIds, isAssociationRequired, isExtensionView]) => {
            return this.rxRecordEditorDesignHelpersService.validate(this.sandbox, componentProperties, recordDefinition, childFieldIds, isAssociationRequired, isExtensionView);
        }), distinctUntilChanged(isEqual), takeUntil(this.sandbox.destroyed$))
            .subscribe((validationIssues) => {
            this.sandbox.setValidationIssues(validationIssues);
        });
        combineLatest([
            this.sandbox.getComponentPropertyValue('name').pipe(map((name) => name || null), distinctUntilChanged()),
            this.recordDefinition$
        ])
            .pipe(takeUntil(this.sandbox.destroyed$))
            .subscribe(([name, recordDefinition]) => {
            this._setSettableProperties(name, recordDefinition);
            this._setCommonDataDictionary(name, recordDefinition);
        });
    }
    removeComponent(guids) {
        this.sandbox.removeComponents(guids);
    }
    updateSelectedFieldComponents(fieldIds) {
        this.selectedFieldComponents$
            .pipe(take(1), mergeMap((components) => {
            const fieldIdsToAdd = fieldIds.filter((fieldId) => !components.find((component) => component.fieldId === fieldId));
            const fieldComponentsToAdd$ = fieldIdsToAdd.length
                ? this.recordFieldDefinitionItems$.pipe(map((items) => fieldIdsToAdd.map((fieldId) => {
                    const { viewComponentType: type, name: label } = items.find((item) => item.id === fieldId);
                    return {
                        type,
                        propertiesByName: {
                            fieldId,
                            label
                        }
                    };
                })), take(1))
                : of([]);
            const fieldIdsSet = new Set(fieldIds);
            const componentGuidsToRemove = components
                .filter((component) => component.fieldId)
                .filter((component) => !fieldIdsSet.has(component.fieldId))
                .map((component) => component.guid);
            return forkJoin([fieldComponentsToAdd$, of(componentGuidsToRemove)]);
        }), takeUntil(this.sandbox.destroyed$))
            .subscribe(([fieldComponentsToAdd, fieldGuidsToRemove]) => {
            if (fieldComponentsToAdd.length) {
                this.sandbox.addComponent(fieldComponentsToAdd);
            }
            if (fieldGuidsToRemove.length) {
                this.sandbox.removeComponents(fieldGuidsToRemove);
            }
        });
    }
    getPropertiesByName(properties) {
        return this.rxRecordEditorDesignHelpersService.getComponentProperties(properties);
    }
    _dropPredicate(data) {
        var _a;
        return (_a = data.draggedViewComponentDescriptor.options) === null || _a === void 0 ? void 0 : _a.canBeEmbeddedInRecordEditor;
    }
    _onBeforeModeChange(prevMode, currentMode) {
        if (prevMode !== RecordEditorMode.Create && currentMode === RecordEditorMode.Create) {
            return this.systemFieldComponentGuids$
                .pipe(mergeMap((systemFieldComponentGuids) => systemFieldComponentGuids.length
                ? this.rxRecordEditorDesignHelpersService.confirmSystemFieldRemoval().pipe(tap((isConfirmed) => {
                    if (isConfirmed) {
                        this.sandbox.removeComponents(systemFieldComponentGuids);
                    }
                }))
                : of(true)), take(1))
                .toPromise();
        }
        else {
            return Promise.resolve(true);
        }
    }
    dropPredicate(data) {
        var _a;
        return (_a = data.draggedViewComponentDescriptor.options) === null || _a === void 0 ? void 0 : _a.canBeEmbeddedInRecordEditor;
    }
    _setCommonDataDictionary(name, recordDefinition) {
        const componentName = this._getComponentName(name, recordDefinition);
        this.sandbox.setCommonDataDictionary(this._getCommonProps(componentName, recordDefinition));
    }
    _setSettableProperties(name, recordDefinition) {
        const componentName = this._getComponentName(name, recordDefinition);
        this.sandbox.setSettablePropertiesDataDictionary(componentName, [
            {
                label: 'Edit state',
                expression: this.getExpressionForProperty('editState')
            },
            {
                label: 'Read state',
                expression: this.getExpressionForProperty('readState')
            },
            ...(recordDefinition
                ? [
                    {
                        label: 'Record instance',
                        children: recordDefinition.fieldDefinitions.map((definition) => ({
                            label: definition.name,
                            expression: this.getExpressionForProperty(`recordInstance.fieldInstances.${definition.id}.value`)
                        }))
                    }
                ]
                : [])
        ]);
    }
    _getCommonProps(componentName, recordDefinition) {
        return {
            label: componentName,
            expression: this.getExpressionForProperty('api'),
            children: [
                {
                    label: 'Can save',
                    expression: this.getExpressionForProperty('canSave')
                },
                {
                    label: 'In read state',
                    expression: this.getExpressionForProperty('inReadState')
                },
                {
                    label: 'Is dirty',
                    expression: this.getExpressionForProperty('isDirty')
                },
                {
                    label: 'Is valid',
                    expression: this.getExpressionForProperty('isValid')
                },
                {
                    label: 'Record definition name',
                    expression: this.getExpressionForProperty('recordDefinitionName')
                },
                {
                    label: 'Record instance',
                    expression: this.getExpressionForProperty('recordInstance'),
                    children: recordDefinition ? this._getRecordInstanceChildProps(recordDefinition) : []
                },
                {
                    label: 'Record instance ID',
                    expression: this.getExpressionForProperty('recordInstanceId')
                }
            ]
        };
    }
    _getRecordInstanceChildProps(recordDefinition) {
        return flow((fieldDefinitions) => reject(fieldDefinitions, { resourceType: RX_RECORD_DEFINITION.resourceTypes.attachment }), (fieldDefinitions) => map$1(fieldDefinitions, (fieldDefinition) => {
            const child = {
                label: fieldDefinition.name,
                expression: this.getExpressionForProperty(`recordInstance.fieldInstances.${fieldDefinition.id}.value`)
            };
            if (fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.selection) {
                const children = (child.autocompleteOptions = map$1(fieldDefinition.optionNamesById, (optionName, optionValue) => ({
                    label: optionName,
                    expression: this.getExpressionForProperty(`recordDefinition.fieldDefinitionsById[${fieldDefinition.id}].optionsById[${optionValue}].id`)
                })));
                child.children = [
                    {
                        label: `${fieldDefinition.name} (Option name)`,
                        expression: this.getExpressionForProperty(`selectionFieldOptionNamesById.${fieldDefinition.id}`)
                    },
                    {
                        label: 'Options',
                        children
                    }
                ];
            }
            return child;
        }))(recordDefinition.fieldDefinitions);
    }
    _getComponentName(name, recordDefinition) {
        let componentName = this.sandbox.descriptor.name;
        const recordDefinitionName = recordDefinition
            ? this.rxDefinitionNameService.getDisplayName(recordDefinition.name)
            : null;
        if (recordDefinitionName && name) {
            componentName += ` (${recordDefinitionName}: ${name})`;
        }
        else if (recordDefinitionName) {
            componentName += ` (${recordDefinitionName})`;
        }
        else if (name) {
            componentName += ` (${name})`;
        }
        return componentName;
    }
}

class RecordEditorDesignComponent {
    ngOnInit() {
        this.dropPredicateFn = this.model._dropPredicate.bind(this.model);
    }
}
RecordEditorDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RecordEditorDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordEditorDesignComponent, selector: "rx-record-editor-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-empty-state\n  *ngIf=\"(model.hasChildren$ | async) === false\"\n  type=\"objects\"\n  label=\"Drop fields from the Palette here or select a Record definition and add fields in the Properties panel.\"\n></adapt-empty-state>\n\n<rx-canvas-outlet [dropPredicate]=\"dropPredicateFn\"></rx-canvas-outlet>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{border:1px solid #d6d7d8;display:block;position:relative;padding:1rem;min-height:200px}adapt-empty-state{position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden}rx-canvas-outlet ::ng-deep>rx-canvas-item-container>.row>.col>rx-canvas-item-column>.cdk-drop-list{min-height:calc(200px - 1rem * 2)}\n"], components: [{ type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }, { type: i1$3.CanvasOutletComponent, selector: "rx-canvas-outlet", inputs: ["name", "skipParentPredicate", "containerComponent", "dropListOrientation", "dropPredicate"], outputs: ["beforeViewComponentDrop"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-editor-design',
                    templateUrl: './record-editor-design.component.html',
                    styleUrls: ['./record-editor-design.component.scss']
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class FieldsInspectorWidgetModule {
}
FieldsInspectorWidgetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldsInspectorWidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FieldsInspectorWidgetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldsInspectorWidgetModule, declarations: [FieldSelectorComponent, FieldsInspectorWidgetComponent], imports: [CommonModule, FormsModule, AdaptButtonModule, AdaptRxTextfieldModule], exports: [FieldsInspectorWidgetComponent] });
FieldsInspectorWidgetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldsInspectorWidgetModule, imports: [[CommonModule, FormsModule, AdaptButtonModule, AdaptRxTextfieldModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldsInspectorWidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [FieldSelectorComponent, FieldsInspectorWidgetComponent],
                    exports: [FieldsInspectorWidgetComponent],
                    entryComponents: [FieldSelectorComponent, FieldsInspectorWidgetComponent],
                    imports: [CommonModule, FormsModule, AdaptButtonModule, AdaptRxTextfieldModule]
                }]
        }] });

class RecordEditorDesignModule {
}
RecordEditorDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RecordEditorDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorDesignModule, declarations: [RecordEditorDesignComponent], imports: [CommonModule,
        RxDefinitionPickerModule,
        FormsModule,
        FormControlsModule,
        ViewDesignerCanvasModule,
        FieldsInspectorWidgetModule,
        AdaptEmptyStateModule] });
RecordEditorDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorDesignModule, providers: [RxRecordEditorDesignHelpersService], imports: [[
            CommonModule,
            RxDefinitionPickerModule,
            FormsModule,
            FormControlsModule,
            ViewDesignerCanvasModule,
            FieldsInspectorWidgetModule,
            AdaptEmptyStateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RxDefinitionPickerModule,
                        FormsModule,
                        FormControlsModule,
                        ViewDesignerCanvasModule,
                        FieldsInspectorWidgetModule,
                        AdaptEmptyStateModule
                    ],
                    declarations: [RecordEditorDesignComponent],
                    entryComponents: [RecordEditorDesignComponent],
                    providers: [RxRecordEditorDesignHelpersService]
                }]
        }] });

var CardinalityType;
(function (CardinalityType) {
    CardinalityType["One"] = "ONE";
    CardinalityType["Many"] = "MANY";
})(CardinalityType || (CardinalityType = {}));
let RxAssociationManagerService = class RxAssociationManagerService {
    constructor(options, rxAssociationInstanceDataPageService, rxRecordDefinitionCacheService, rxRecordInstanceUtilsService, rxRecordInstanceService, rxJsonParserService, rxAssociationDefinitionCacheService) {
        this.options = options;
        this.rxAssociationInstanceDataPageService = rxAssociationInstanceDataPageService;
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.rxRecordInstanceUtilsService = rxRecordInstanceUtilsService;
        this.rxRecordInstanceService = rxRecordInstanceService;
        this.rxJsonParserService = rxJsonParserService;
        this.rxAssociationDefinitionCacheService = rxAssociationDefinitionCacheService;
        this.extensions = [];
        this.existing = [];
        this.pending = [];
        this.deleted = [];
        this.existingSubject$ = new BehaviorSubject([]);
        this.existing$ = this.existingSubject$.asObservable();
        this.pendingSubject$ = new BehaviorSubject([]);
        this.pending$ = this.pendingSubject$.asObservable();
        this.extensionsSubject$ = new BehaviorSubject([]);
        this.extensions$ = this.extensionsSubject$.asObservable();
        this.cardinalityTypes = CardinalityType;
        this.totalExistingCount = 0;
        this.associationDefinition = null;
        this.cardinalityType = null;
        this.remainingAssociatedRecordCount = 0;
        // create a shared observable to eliminate duplicate API calls from multiple association components in dropdown mode
        this.getExistingAssociationInstances$ = defer(() => this.getExistingAssociationInstances()).pipe(share());
        assign(this.options, {
            canLoadAssociations: Boolean(this.options.associatedRecordInstanceId),
            pageSize: 10,
            startIndex: 0
        });
        this.extensions = this.options.associationInstances.extensions;
        this.existing = this.options.associationInstances.existing;
        this.pending = this.options.associationInstances.pending;
        this.deleted = this.options.associationInstances.deleted;
        this.options.fieldIds = this.options.fieldIds || [];
        // add id to core fields for tracking changes on associationInstances
        this.mergeFieldIds([RX_RECORD_DEFINITION.coreFieldIds.id]);
    }
    initialize() {
        this.isDataLoading = true;
        if (!this.initialize$) {
            this.initialize$ = forkJoin([
                this.rxAssociationDefinitionCacheService.getAssociationDefinition(this.options.associationDefinitionName),
                this.rxRecordDefinitionCacheService.getRecordDefinition(this.options.recordDefinitionName)
            ]).pipe(tap(([associationDefinition, recordDefinition]) => {
                this.isDataLoading = false;
                this.associationDefinition = associationDefinition;
                this.recordDefinition = recordDefinition;
                // determine whether a single or multiple instances can be associated based on association's cardinality and record role
                this.cardinalityType = this.getCardinalityType(this.associationDefinition.cardinality, this.options.associatedRecordNodeSide);
                // set up field ids if they are not be provided
                if (this.options.allFieldIds) {
                    this.options.fieldIds = map$1(this.recordDefinition.fieldDefinitions, 'id');
                    this.mergeFieldIds([RX_RECORD_DEFINITION.coreFieldIds.id]);
                }
            }));
        }
        return this.initialize$;
    }
    loadExistingAssociations() {
        if (this.options.canLoadAssociations) {
            return this.initialize().pipe(switchMap(() => {
                return this.getExistingAssociationInstances$.pipe(tap((instances) => {
                    forEach(instances.data, (instance) => {
                        this.addToExisting(this.rxRecordInstanceUtilsService.convertFromDataPageRowToPlainRecordInstance(instance));
                    });
                    this.options.startIndex += instances.data.length;
                    this.remainingAssociatedRecordCount = instances.totalSize - this.options.startIndex;
                }));
            }));
        }
        else {
            return of([]);
        }
    }
    loadExtensions() {
        return this.initialize().pipe(switchMap(() => {
            return this.getExtensionRecordInstance().pipe(tap((extensionRecordInstance) => {
                if (extensionRecordInstance) {
                    this.addExtension(extensionRecordInstance);
                }
            }));
        }));
    }
    addToExisting(association) {
        // Existing association can be loaded twice by parallel requests either with or without filtering by `roleName` attribute.
        const existingAssociation = this.isInExisting(association.id);
        if (existingAssociation) {
            if (this.isDefaultNodeRoleUsed(existingAssociation) && !this.isDefaultNodeRoleUsed(this.options.rolesConfig)) {
                // Remove and add association again instead of config update is needed to correctly observe associations collection change.
                remove(this.existing, existingAssociation);
                association.rolesConfig = this.options.rolesConfig;
                this.existing.push(association);
                this.existingSubject$.next(this.existing);
            }
            else {
                // Existing association already has custom roles of nodes, so newly added association instance will be skipped.
            }
        }
        else {
            if (this.options.rolesConfig && !association.rolesConfig) {
                association.rolesConfig = this.options.rolesConfig;
            }
            this.existing.push(association);
            this.existingSubject$.next(this.existing);
        }
    }
    isDefaultNodeRoleUsed(association) {
        return this.rxJsonParserService.tryParseJson(get(association, 'rolesConfig.useDefaultRoles', true));
    }
    addToPending(associations, rolesConfig) {
        if (!isEmpty(associations) && this.associationDefinition) {
            if (this.cardinalityType === CardinalityType.Many) {
                const associationsForAppending = filter$1(associations, (association) => {
                    return (!this.isInExisting(association.id) && !this.isInDeleted(association.id) && !this.isInPending(association.id));
                });
                if (rolesConfig) {
                    forEach(associationsForAppending, (association) => {
                        association.rolesConfig = rolesConfig;
                    });
                }
                Array.prototype.push.apply(this.pending, associationsForAppending);
                this.pendingSubject$.next(this.pending);
                const previouslyDeletedAssociations = remove(this.deleted, (deletedAssociation) => {
                    return find(associations, {
                        id: deletedAssociation.id
                    });
                });
                forEach(previouslyDeletedAssociations, (deletedAssociation) => {
                    this.addToExisting(deletedAssociation);
                });
            }
            else if (this.cardinalityType === CardinalityType.One) {
                const association = associations[0];
                switch (true) {
                    case isEmpty(this.existing) && isEmpty(this.deleted):
                        this.pending.length = 0;
                        this.pending.push(association);
                        break;
                    case isEmpty(this.existing):
                        const deletedAssociation = this.deleted[0];
                        this.pending.length = 0;
                        if (deletedAssociation.id === association.id) {
                            this.addToExisting(this.deleted.splice(0, 1)[0]);
                        }
                        else {
                            this.pending.push(association);
                        }
                        break;
                    case isEmpty(this.deleted):
                        const existingAssociation = this.existing[0];
                        if (existingAssociation.id !== association.id) {
                            this.deleteFromExisting(existingAssociation.id);
                            this.pending.length = 0;
                            this.pending.push(association);
                        }
                        break;
                }
                this.pendingSubject$.next(this.pending);
            }
        }
    }
    addExtension(extensionRecordInstance) {
        this.extensions.push(extensionRecordInstance);
        this.extensionsSubject$.next(this.extensions);
    }
    restore() {
        this.extensionsSubject$.next(this.extensions);
        forEach(this.deleted, (deletedAssociation) => {
            this.addToExisting(deletedAssociation);
        });
        this.deleted.splice(0, this.deleted.length);
        this.deleteAllPending();
    }
    reset() {
        this.existing.splice(0, this.existing.length);
        this.pending.splice(0, this.pending.length);
        this.deleted.splice(0, this.deleted.length);
        this.totalExistingCount = 0;
        this.options.startIndex = 0;
    }
    delete(associationId) {
        if (this.isInExisting(associationId)) {
            this.deleteFromExisting(associationId);
        }
        else if (this.isInPending(associationId)) {
            this.deleteFromPending(associationId);
        }
    }
    deleteAllExisting() {
        const associationIds = map$1(this.existing, 'id');
        forEach(associationIds, (associationId) => {
            this.deleteFromExisting(associationId);
        });
    }
    deleteAllPending() {
        this.pending.splice(0, this.pending.length);
        this.pendingSubject$.next(this.pending);
    }
    mergeFieldIds(fieldIds) {
        if (fieldIds) {
            this.options.fieldIds = uniq(this.options.fieldIds.concat(fieldIds));
        }
    }
    extendOptions(options) {
        if (options.fieldIds) {
            this.mergeFieldIds(options.fieldIds);
        }
        this.options.allFieldIds = options.allFieldIds;
    }
    getCardinalityType(cardinality, associatedRecordNodeSide) {
        let cardinalityType;
        switch (true) {
            case cardinality === RX_ASSOCIATION_DEFINITION.cardinality.oneToOne.value:
                cardinalityType = CardinalityType.One;
                break;
            case cardinality === RX_ASSOCIATION_DEFINITION.cardinality.oneToMany.value:
                if (associatedRecordNodeSide === RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value) {
                    cardinalityType = CardinalityType.Many;
                }
                else {
                    cardinalityType = CardinalityType.One;
                }
                break;
            case cardinality === RX_ASSOCIATION_DEFINITION.cardinality.manyToMany.value:
                cardinalityType = CardinalityType.Many;
                break;
        }
        return cardinalityType;
    }
    getExtensionRecordInstance(loadFullInstance = true) {
        const fields = loadFullInstance ? RX_RECORD_DEFINITION.coreFieldIds.id : this.options.fieldIds.join(',');
        return this.rxAssociationInstanceDataPageService
            .post({
            params: {
                associationDefinition: this.options.associationDefinitionName,
                nodeToQuery: this.options.associatedRecordNodeSide,
                associatedRecordInstanceId: this.options.associatedRecordInstanceId,
                propertySelection: fields
            }
        })
            .pipe(map((instances) => instances.data[0]), switchMap((dataPageRow) => {
            if (dataPageRow && loadFullInstance) {
                return this.rxRecordInstanceService.get(this.options.recordDefinitionName, dataPageRow[RX_RECORD_DEFINITION.coreFieldIds.id]);
            }
            else if (dataPageRow && !loadFullInstance) {
                return of(this.rxRecordInstanceService.createInstanceFromDataPageRow(dataPageRow, this.recordDefinition));
            }
            else {
                return of(null);
            }
        }));
    }
    getExistingAssociationInstances() {
        const params = {
            pageSize: this.options.pageSize,
            startIndex: this.options.startIndex,
            associationDefinition: this.options.associationDefinitionName,
            nodeToQuery: this.options.associatedRecordNodeSide,
            associatedRecordInstanceId: this.options.associatedRecordInstanceId,
            propertySelection: this.options.fieldIds.join(','),
            useDefaultRoleNames: false,
            nodeARoleName: '',
            nodeBRoleName: ''
        };
        if (this.options.rolesConfig.useDefaultRoles) {
            params.useDefaultRoleNames = this.options.rolesConfig.useDefaultRoles;
            delete params.nodeARoleName;
            delete params.nodeBRoleName;
        }
        else {
            delete params.useDefaultRoleNames;
            params.nodeARoleName = this.options.rolesConfig.nodeARole || '';
            params.nodeBRoleName = this.options.rolesConfig.nodeBRole || '';
        }
        return this.rxAssociationInstanceDataPageService.post({ params });
    }
    isInExisting(associationId) {
        return find(this.existing, {
            id: associationId
        });
    }
    isInPending(associationId) {
        return find(this.pending, {
            id: associationId
        });
    }
    getFieldIds() {
        return clone(this.options.fieldIds);
    }
    isInDeleted(associationId) {
        return find(this.deleted, {
            id: associationId
        });
    }
    deleteFromExisting(associationId) {
        const removedAssociation = remove(this.existing, {
            id: associationId
        })[0];
        this.deleted.push(removedAssociation);
        this.existingSubject$.next(this.existing);
    }
    deleteFromPending(associationId) {
        remove(this.pending, {
            id: associationId
        });
        this.pendingSubject$.next(this.pending);
    }
    destroy() {
        this.existingSubject$.complete();
        this.pendingSubject$.complete();
        this.extensionsSubject$.complete();
    }
};
RxAssociationManagerService = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [Object, RxAssociationInstanceDataPageService,
        RxRecordDefinitionCacheService,
        RxRecordInstanceUtilsService,
        RxRecordInstanceService,
        RxJsonParserService,
        RxAssociationDefinitionCacheService])
], RxAssociationManagerService);

class RxRecordEditorUtilsService {
    getComponentDefinitionsAsFlatList(componentDefinitions) {
        return flattenDeep(transform(componentDefinitions, (result, componentDefinition) => {
            // do not include container view components
            if (componentDefinition.resourceType !== RX_VIEW_DEFINITION.resourceTypes.containerViewComponent) {
                result.push(componentDefinition);
                // do not look inside container view components that have their own recordDefinitionName property,
                // e.g. Association View Component
            }
            else if (!componentDefinition.propertiesByName.recordDefinitionName) {
                result.push(...this.getComponentDefinitionsAsFlatList(componentDefinition.componentDefinitions));
            }
        }));
    }
    getSelectionFieldOptionNames(recordDefinition, recordInstance) {
        const selectionFieldOptionNamesById = {};
        filter$1(recordDefinition.fieldDefinitions, { resourceType: RX_RECORD_DEFINITION.resourceTypes.selection }).forEach((fieldDefinition) => {
            const selectionFieldLocalizableStrings = get(recordDefinition.localizableStringsByFieldId, fieldDefinition.id);
            const fieldInstance = recordInstance.fieldInstances[fieldDefinition.id];
            if (fieldInstance) {
                if (isObject(fieldDefinition.optionNamesById) &&
                    selectionFieldLocalizableStrings &&
                    isEmpty(selectionFieldLocalizableStrings)) {
                    const localizableStringId = fieldDefinition.optionNamesById[fieldInstance.value];
                    selectionFieldOptionNamesById[fieldDefinition.id] = selectionFieldLocalizableStrings[localizableStringId];
                }
                else {
                    selectionFieldOptionNamesById[fieldDefinition.id] = fieldDefinition.optionNamesById[fieldInstance.value];
                }
            }
            else {
                // field instance is not available for system selection fields,
                // e.g. field 16 (Notifier Listening), when the record instance
                // is retrieved via GET recordinstance/0 API (get new record instance)
                selectionFieldOptionNamesById[fieldDefinition.id] = '';
            }
        });
        return selectionFieldOptionNamesById;
    }
}
RxRecordEditorUtilsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordEditorUtilsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordEditorUtilsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordEditorUtilsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordEditorUtilsService, decorators: [{
            type: Injectable
        }] });

class RecordEditorFormControl extends FormControl {
    constructor() {
        super(...arguments);
        this._touchedSubject = new BehaviorSubject(this.touched);
        this.touched$ = this._touchedSubject.asObservable().pipe(distinctUntilChanged());
    }
    markAsTouched(opts) {
        super.markAsTouched(opts);
        this._touchedSubject.next(this.touched);
    }
    markAsUntouched(opts) {
        super.markAsUntouched(opts);
        this._touchedSubject.next(this.touched);
    }
}

const RecordEditorFormDelimiter = '%';
const BASE_FORM_GROUP_KEY = 'baseFormGroup';
class RecordEditorForm extends FormGroup {
    constructor(rxGuidService, rxRecordInstanceUtilsService) {
        super({});
        this.rxGuidService = rxGuidService;
        this.rxRecordInstanceUtilsService = rxRecordInstanceUtilsService;
    }
    addFieldControl(fieldId, guid, initialValue = null, validator, asyncValidator) {
        const formControl = new RecordEditorFormControl('', validator, asyncValidator);
        const formGroup = this.controls[BASE_FORM_GROUP_KEY];
        formControl.setValue(initialValue);
        if (!formGroup) {
            this.addControl(BASE_FORM_GROUP_KEY, new FormGroup({
                [this.getControlId(fieldId, guid)]: formControl
            }));
        }
        else {
            formGroup.addControl(this.getControlId(fieldId, guid), formControl);
        }
        return formControl;
    }
    addAssociatedFieldControl(fieldId, guid, associatedRecordPath, initialValue = null, validator, asyncValidator) {
        const associatedFormGroupName = associatedRecordPath.join(RecordEditorFormDelimiter);
        const associatedFormGroup = this.controls[associatedFormGroupName];
        const formControl = new RecordEditorFormControl(initialValue, validator, asyncValidator);
        if (!associatedFormGroup) {
            this.addControl(associatedFormGroupName, new FormGroup({
                [this.getControlId(fieldId, guid)]: formControl
            }));
        }
        else {
            associatedFormGroup.addControl(this.getControlId(fieldId, guid), formControl);
        }
        return formControl;
    }
    resetFieldControls(formStateByFieldId, associatedRecordPath) {
        const formGroup = this.controls[associatedRecordPath ? associatedRecordPath.join(RecordEditorFormDelimiter) : BASE_FORM_GROUP_KEY];
        if (formStateByFieldId) {
            formGroup.reset(this.prepareFormGroupState(formStateByFieldId, formGroup));
        }
        else {
            formGroup.reset();
        }
    }
    syncFormControlValues(fieldId, value, associatedFromGroupName, options = {}) {
        this.getControlsBoundToRecordField(String(fieldId), associatedFromGroupName).forEach((formControl) => {
            if (options.markAsDirty !== false) {
                formControl.markAsDirty();
            }
            if (options.markAsTouched !== false) {
                formControl.markAsTouched();
            }
            if (!this.rxRecordInstanceUtilsService.isFieldValueEqual(formControl.value, value)) {
                formControl.setValue(value);
            }
        });
    }
    getFieldIds(associatedRecordPath) {
        const formGroup = this.controls[associatedRecordPath ? associatedRecordPath.join(RecordEditorFormDelimiter) : BASE_FORM_GROUP_KEY];
        if (formGroup) {
            return reduce(formGroup.controls, (result, control, formControlId) => {
                const fieldId = this.getFieldId(formControlId);
                if (control instanceof FormControl && !includes(result, fieldId)) {
                    result.push(fieldId);
                }
                return result;
            }, []);
        }
        else {
            return [];
        }
    }
    clearAndReset() {
        forOwn(this.controls, (control, name) => this.removeControl(name));
        this.reset();
    }
    markInvalidControlsAsTouched() {
        forEach(this.controls, (formGroup) => {
            forEach(formGroup.controls, (control) => {
                if (control.invalid) {
                    control.markAsTouched();
                }
            });
        });
    }
    getFormControl(fieldId, guid, associatedRecordPath) {
        let control;
        let formGroup;
        formGroup = this.controls[associatedRecordPath ? associatedRecordPath.join(RecordEditorFormDelimiter) : BASE_FORM_GROUP_KEY];
        if (formGroup) {
            control = formGroup.get(this.getControlId(fieldId, guid));
        }
        return control;
    }
    getControlsBoundToRecordField(fieldId, associatedFormGroupName) {
        const formGroup = this.controls[associatedFormGroupName || BASE_FORM_GROUP_KEY];
        return reduce(formGroup.controls, (result, control, formControlId) => {
            if (control instanceof FormControl && this.getFieldId(formControlId) === fieldId) {
                result.push(control);
            }
            return result;
        }, []);
    }
    getControlId(fieldId, guid) {
        return `${fieldId}:${guid || this.rxGuidService.generate()}`;
    }
    getFieldId(formControlId) {
        return formControlId.split(':')[0];
    }
    prepareFormGroupState(formStateByFieldId, formGroup) {
        return reduce(formGroup.controls, (result, control, formControlId) => {
            result[formControlId] = formStateByFieldId[this.getFieldId(formControlId)];
            return result;
        }, {});
    }
}
RecordEditorForm.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorForm, deps: [{ token: i2$1.RxGuidService }, { token: i1$5.RxRecordInstanceUtilsService }], target: i0.ɵɵFactoryTarget.Injectable });
RecordEditorForm.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorForm });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorForm, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i2$1.RxGuidService }, { type: i1$5.RxRecordInstanceUtilsService }]; } });

class RecordEditorComponent extends BaseViewComponent {
    constructor(rxRecordInstanceService, rxRecordInstanceUpdateService, translateService, rxGlobalEventsService, rxNotificationService, rxRecordDefinitionService, rxRecordEditorUtilsService, rxRecordInstanceUtilsService, rxStringService, rxLogService, rxUtilityModalsService, recordEditorForm, rxAssociationManagerServiceFactory) {
        super();
        this.rxRecordInstanceService = rxRecordInstanceService;
        this.rxRecordInstanceUpdateService = rxRecordInstanceUpdateService;
        this.translateService = translateService;
        this.rxGlobalEventsService = rxGlobalEventsService;
        this.rxNotificationService = rxNotificationService;
        this.rxRecordDefinitionService = rxRecordDefinitionService;
        this.rxRecordEditorUtilsService = rxRecordEditorUtilsService;
        this.rxRecordInstanceUtilsService = rxRecordInstanceUtilsService;
        this.rxStringService = rxStringService;
        this.rxLogService = rxLogService;
        this.rxUtilityModalsService = rxUtilityModalsService;
        this.rxAssociationManagerServiceFactory = rxAssociationManagerServiceFactory;
        this.api = {
            refresh: this.refresh.bind(this),
            isDirty: this.isDirty.bind(this),
            isReady: this.isReady.bind(this),
            isValid: this.isValid.bind(this),
            notifyComponentReady: this.notifyComponentReady.bind(this),
            save: this.save.bind(this),
            setProperty: this.setProperty.bind(this),
            setFieldValue: this.setFieldValue.bind(this),
            getFieldValue: this.getFieldValue.bind(this),
            getAssociationManager: this.getAssociationManager.bind(this),
            getFieldControl: this.getFieldControl.bind(this),
            downloadAttachment: this.downloadAttachment.bind(this),
            getAttachmentDownloadUrl: this.getAttachmentDownloadUrl.bind(this),
            getPermissionType: this.getPermissionType.bind(this),
            getFieldInstanceProp: this.getFieldInstanceProp.bind(this),
            getRecordEditorMode: this.getRecordEditorMode.bind(this),
            setFieldInstanceProp: this.setFieldInstanceProp.bind(this),
            markAsDirty: this.markAsDirty.bind(this)
        };
        this.state = {
            recordInstanceId: '',
            recordDefinitionName: '',
            recordInstance: null,
            recordDefinition: null,
            isDataLoading: false,
            isDirty: false,
            isSaving: false,
            canSave: false,
            mode: null,
            isReadOnlyStateAvailable: false,
            defaultState: null,
            currentState: RecordEditorState.Edit,
            form: null,
            selectionFieldOptionNamesById: {},
            allowEdit: null
        };
        this.recordInstanceChangedSubject = new Subject();
        this.notReadyComponentIds = {};
        this.associationManagers = {};
        this.associationInstances = {};
        this.recordInstanceChanged$ = this.recordInstanceChangedSubject.asObservable();
        this.state.form = recordEditorForm;
        this.state.form.statusChanges.pipe(distinctUntilChanged(), takeUntil(this.destroyed$)).subscribe(() => {
            this.notifyPropertyChanged('isValid', this.isValid());
        });
    }
    ngOnInit() {
        super.ngOnInit();
        this.notifyPropertyChanged('api', this.api);
        this.notifyPropertyChanged('isDirty', this.state.isDirty);
        this.notifyPropertyChanged('canSave', this.state.canSave);
        const config$ = this.config.pipe(distinctUntilChanged(isEqual), tap((config) => Object.assign(this.state, config)));
        config$.pipe(take(1)).subscribe((config) => {
            if (config.mode === RecordEditorMode.Create) {
                this.notifyPropertyChanged('inReadState', false);
            }
            else if (config.mode === RecordEditorMode.Temporary) {
                this.notifyPropertyChanged('inReadState', false);
                this.updateCanSaveProperty();
            }
            else if (this.state.defaultState) {
                this.state.isReadOnlyStateAvailable = true;
            }
        });
        merge(config$.pipe(takeWhile((config) => config.mode === RecordEditorMode.Edit)), config$.pipe(takeWhile((config) => includes([RecordEditorMode.Create, RecordEditorMode.BulkEdit, RecordEditorMode.Temporary], config.mode)), take(1)))
            .pipe(map((config) => config.recordInstanceId || null), distinctUntilChanged(), switchMap(() => this.initializeRecordInstance().pipe(catchError((error) => {
            if (this.rxRecordInstanceUtilsService.isNoRecordFoundError(error)) {
                this.runtimeViewModelApi.cancel(true).subscribe();
            }
            return throwError(error);
        }))), takeUntil(this.destroyed$))
            .subscribe();
        config$
            .pipe(takeWhile((config) => config.mode === RecordEditorMode.Edit), pluck('allowEdit'), distinctUntilChanged(), takeUntil(this.destroyed$))
            .subscribe((allowEdit) => {
            const state = allowEdit ? this.state.defaultState || RecordEditorState.Edit : RecordEditorState.Read;
            this.setRecordEditorState(state);
        });
    }
    downloadAttachment(fieldId) {
        if (this.isInEditMode() && !this.isNewAttachment(fieldId)) {
            this.rxRecordInstanceService.downloadAttachment(this.state.recordDefinitionName, fieldId, this.state.recordInstanceId, this.state.recordInstance.fieldInstances[fieldId].value);
        }
    }
    getAttachmentDownloadUrl(fieldId) {
        let attachmentDownloadUrl = '';
        if (this.isInEditMode() && !this.isNewAttachment(fieldId)) {
            attachmentDownloadUrl = this.rxRecordInstanceService.getAttachmentDownloadUrl(this.state.recordDefinitionName, fieldId, this.state.recordInstanceId);
        }
        return attachmentDownloadUrl;
    }
    getAssociationManager(options) {
        // Custom roles config:
        // {
        //   useDefaultRoles: 'false',
        //   nodeARole: 'CustomA',
        //   nodeBRole: 'CustomB'
        // }
        // will be converted to 'false_CustomA_CustomB'
        // Default roles config (node roles are null) will be converted to 'true__'
        // Empty roles config will be converted to an empty string
        const rolesConfigValues = values(options.rolesConfig).join('_');
        const associationManagerKey = compact([
            options.associationDefinitionName,
            rolesConfigValues,
            options.associatedRecordNodeSide
        ]).join(':');
        let associationManager = this.associationManagers[associationManagerKey];
        if (!associationManager) {
            options.associationInstances = this.getAssociationInstances(options.associationDefinitionName, options.associatedRecordNodeSide, rolesConfigValues);
            associationManager = this.rxAssociationManagerServiceFactory(options);
            merge(associationManager.pending$, associationManager.existing$)
                .pipe(filter(() => associationManager.deleted.length !== 0 || associationManager.pending.length !== 0), take(1))
                .subscribe(() => this.markAsDirty());
            associationManager.extensions$
                .pipe(
            // Extensions will be an empty array on first emit as initial value and
            // when no extension containers are used in the record editor.
            filter((extensions) => !isEmpty(extensions)), takeUntil(this.destroyed$))
                .subscribe(() => {
                this.syncRecordInstanceWithForm(options.associatedRecordPath);
                this.notifyPropertyChanged('recordInstance', this.state.recordInstance);
            });
            this.associationManagers[associationManagerKey] = associationManager;
        }
        else {
            associationManager.extendOptions(options);
        }
        return associationManager;
    }
    markAsDirty() {
        this.state.form.markAsTouched();
        this.state.form.markAsDirty();
        this.updateIsDirtyProperty();
        this.updateCanSaveProperty();
    }
    refresh() {
        if (this.isInEditMode() && this.state.currentState === RecordEditorState.Read) {
            return this.initializeRecordInstance().pipe(catchError((error) => this.handleNoRecordFoundError(error)));
        }
        else {
            return EMPTY;
        }
    }
    isDirty() {
        return this.isInTemporaryMode() ? false : this.state.form.dirty;
    }
    isReady() {
        return isEmpty(this.notReadyComponentIds);
    }
    notifyComponentReady(componentId, isReady) {
        if (isReady) {
            delete this.notReadyComponentIds[componentId];
        }
        else {
            this.notReadyComponentIds[componentId] = true;
        }
    }
    setProperty(propertyPath, propertyValue) {
        const matchFieldInstanceId = propertyPath.match(/^recordInstance\.fieldInstances\.(\d+)\.value$/);
        const shouldSwitchToReadState = (propertyPath === 'readState' && propertyValue) || (propertyPath === 'editState' && !propertyValue);
        const shouldSwitchToEditState = (propertyPath === 'readState' && !propertyValue) || (propertyPath === 'editState' && propertyValue);
        if (shouldSwitchToReadState) {
            if (this.state.currentState !== RecordEditorState.Read) {
                return this.cancel();
            }
        }
        else if (shouldSwitchToEditState) {
            if (this.state.currentState !== RecordEditorState.Edit) {
                this.switchToEditState();
            }
        }
        else if (matchFieldInstanceId) {
            const fieldId = Number(matchFieldInstanceId[1]);
            this.setFieldValue(fieldId, propertyValue);
        }
        else {
            return throwError(`Record editor: property ${propertyPath} is not settable.`);
        }
    }
    setFieldValue(fieldId, value, associatedRecordPath, options = {}) {
        if (this.state.recordInstance &&
            this.state.recordInstance.getRecordInstance(associatedRecordPath) &&
            this.state.recordInstance.isFieldValueChanged(fieldId, value, associatedRecordPath)) {
            this.state.recordInstance.setFieldValue(fieldId, value, associatedRecordPath);
            this.state.form.syncFormControlValues(String(fieldId), this.state.recordInstance.getFieldValue(fieldId, associatedRecordPath), associatedRecordPath && associatedRecordPath.join(RecordEditorFormDelimiter), options);
            this.updateSelectionFieldOptionNames(this.state.recordInstance);
            this.notifyPropertyChanged('recordInstance', this.state.recordInstance);
            this.updateIsDirtyProperty();
            this.updateCanSaveProperty();
        }
    }
    getFieldValue(fieldId, associatedRecordPath) {
        return this.state.recordInstance && this.state.recordInstance.getFieldValue(fieldId, associatedRecordPath);
    }
    save(closeViewAfterSave = false) {
        if (this.isInTemporaryMode()) {
            this.rxLogService.debug('Record Editor: skip saving record instance in Temporary mode.');
            return EMPTY;
        }
        else if (!this.isValid()) {
            this.state.form.markInvalidControlsAsTouched();
            this.rxNotificationService.addErrorMessage(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-editor.validation-error.message'));
            return throwError(null);
        }
        else if (this.canSave()) {
            let savingObservable$;
            this.state.isSaving = true;
            this.updateCanSaveProperty();
            if (this.isInCreateMode()) {
                savingObservable$ = this.rxRecordInstanceService.create(this.state.recordInstance).pipe(tap((recordInstance) => {
                    this.rxNotificationService.addSuccessMessage(this.translateService.instant('com.bmc.arsys.rx.client.common.saved-successfully.message'));
                    if (!this.state.recordInstanceId) {
                        set(this.state.recordInstance, `fieldInstances[${RX_RECORD_DEFINITION.coreFieldIds.id}].value`, recordInstance.id);
                        this.state.recordInstance.id = recordInstance.id;
                        this.state.recordInstanceId = recordInstance.id;
                    }
                    this.notifyPropertyChanged('recordInstance', this.state.recordInstance);
                    this.notifyPropertyChanged('recordInstanceId', this.state.recordInstanceId);
                    if (!closeViewAfterSave) {
                        this.rxGlobalEventsService.viewActionsCompleted$
                            .pipe(take(1), switchMap(() => this.initializeRecordInstance()), takeUntil(this.destroyed$))
                            .subscribe();
                    }
                }), switchMapTo(EMPTY));
            }
            else if (this.isInEditMode()) {
                savingObservable$ = this.rxRecordInstanceUpdateService.execute(this.state.recordInstance).pipe(tap(() => {
                    this.rxNotificationService.addSuccessMessage(this.translateService.instant('com.bmc.arsys.rx.client.common.saved-successfully.message'));
                }), switchMap(() => {
                    return this.initializeRecordInstance().pipe(catchError((error) => this.handleNoRecordFoundError(error)), tap({
                        complete: () => {
                            if (this.state.isReadOnlyStateAvailable) {
                                this.setRecordEditorState(RecordEditorState.Read);
                            }
                        }
                    }));
                }));
            }
            return savingObservable$.pipe(tap({
                complete: () => {
                    // Mark record editor form as pristine due to:
                    // - prevent showing dirty state confirmation dialog when any action after
                    // the save will close current view e.g open view in the same window action.
                    // - we don't have to wait until all extension containers data will be loaded
                    // to reset record editor form while synchronization.
                    this.state.form.markAsPristine();
                }
            }), finalize(() => {
                this.state.isSaving = false;
                this.updateCanSaveProperty();
                this.updateIsDirtyProperty();
            }));
        }
        else {
            this.rxLogService.debug('Record Editor: cannot save unmodified record instance.');
            return throwError(null);
        }
    }
    getFieldControl(fieldId, guid, validator = [], associatedRecordPath) {
        const existingControl = this.state.form.getFormControl(String(fieldId), guid, associatedRecordPath);
        if (existingControl) {
            return existingControl;
        }
        const initialValue = this.state.recordInstance
            ? this.state.recordInstance.getFieldValue(fieldId, associatedRecordPath)
            : null;
        const recordInstanceValidator = this.getFieldInstanceControlValidator(fieldId, associatedRecordPath);
        validator = Array.isArray(validator) ? validator : [validator];
        validator.push(recordInstanceValidator);
        let formControl;
        if (associatedRecordPath) {
            formControl = this.state.form.addAssociatedFieldControl(String(fieldId), guid, associatedRecordPath, initialValue, validator);
        }
        else {
            formControl = this.state.form.addFieldControl(String(fieldId), guid, initialValue, validator);
        }
        formControl.valueChanges
            .pipe(distinctUntilChanged(this.rxRecordInstanceUtilsService.isFieldValueEqual), 
        // Use asyncScheduler to allow all observers to be notified about the original (non-normalized) field value change,
        // before the value gets normalized by `this.setFieldValue` call in the subscription below.
        // This resolves an issue where the subscriptions were executed with the normalized value first, followed by
        // non-normalized value.
        // In the example below, the actual form control value is already normalized but valueChange observer
        // receives a non-normalized value.
        // formControl.valueChange.subscribe(nonNormalizedValue => formControl.value !== nonNormalizedValue);
        observeOn(asyncScheduler), takeUntil(this.destroyed$))
            .subscribe(() => {
            // Use formControl.value instead of the emitted value that comes asynchronously
            // and may be different than the actual value, e.g. when user types quickly
            this.setFieldValue(fieldId, formControl.value, associatedRecordPath, {
                markAsDirty: formControl.dirty,
                markAsTouched: false
            });
        });
        return formControl;
    }
    getPermissionType(fieldId, associatedRecordPath) {
        const fieldInstance = this.state.recordInstance
            ? this.state.recordInstance.getFieldInstance(fieldId, associatedRecordPath)
            : null;
        if (fieldInstance) {
            return get(fieldInstance, 'permissionType') || RX_RECORD_DEFINITION.fieldPermissionTypes.change;
        }
        else {
            return null;
        }
    }
    getFieldInstanceProp(fieldId, prop, associatedRecordPath) {
        return this.state.recordInstance && this.state.recordInstance.getFieldProp(fieldId, prop, associatedRecordPath);
    }
    getRecordEditorMode() {
        return this.state.mode;
    }
    setFieldInstanceProp(fieldId, prop, value, associatedRecordPath) {
        if (this.state.recordInstance) {
            this.state.recordInstance.setFieldProp(fieldId, prop, value, associatedRecordPath);
        }
    }
    isValid() {
        return this.state.form.valid;
    }
    switchToEditState() {
        this.setRecordEditorState(RecordEditorState.Edit);
    }
    isEditStateAvailable() {
        return (this.state.isReadOnlyStateAvailable &&
            this.state.currentState === RecordEditorState.Read &&
            Boolean(this.state.recordInstanceId) &&
            Boolean(this.state.allowEdit));
    }
    isSaveButtonAvailable() {
        return this.state.isReadOnlyStateAvailable && this.state.currentState === RecordEditorState.Edit;
    }
    isSaveButtonDisabled() {
        return !this.canSave();
    }
    isCancelButtonAvailable() {
        return (this.state.isReadOnlyStateAvailable && this.state.currentState === RecordEditorState.Edit && this.isInEditMode());
    }
    cancel() {
        if (this.state.isReadOnlyStateAvailable && this.state.recordInstance) {
            if (this.isDirty()) {
                return defer(() => from(this.rxUtilityModalsService.confirmUnsavedChanges())).pipe(switchMap((isConfirmed) => {
                    if (isConfirmed) {
                        this.restoreRecordEditor();
                        this.setRecordEditorState(RecordEditorState.Read);
                        return EMPTY;
                    }
                    else {
                        return throwError(null);
                    }
                }));
            }
            else {
                this.setRecordEditorState(RecordEditorState.Read);
            }
        }
        return EMPTY;
    }
    canSave() {
        return this.isInTemporaryMode() ? true : !this.state.isSaving && (this.isInCreateMode() || this.isDirty());
    }
    isConfigValid() {
        return this.isInEditMode() ? this.rxStringService.isNonEmptyString(this.state.recordInstanceId) : true;
    }
    onSaveClick() {
        this.save()
            .pipe(take(1), catchError((error) => (error === null ? of(error) : throwError(error))))
            .subscribe();
    }
    onCancelClick() {
        this.cancel().subscribe();
    }
    initializeRecordInstance() {
        let initialize$ = EMPTY;
        if (this.isConfigValid()) {
            this.state.isDataLoading = true;
            initialize$ = this.getRecordInstance().pipe(tap((recordInstance) => {
                this.setRecordInstance(recordInstance);
                this.setRecordDefinition(recordInstance.recordDefinition);
                this.updateSelectionFieldOptionNames(recordInstance);
            }), switchMapTo(EMPTY), catchError((error) => {
                // delay record instance id update to allow throwing an error.
                asapScheduler.schedule(() => {
                    this.setRecordInstance(null);
                    this.setRecordDefinition(null);
                });
                return throwError(error);
            }), finalize(() => {
                this.state.isDataLoading = false;
            }));
        }
        else {
            if (this.state.recordInstanceId !== '' && !isNil(this.state.recordInstanceId)) {
                this.rxNotificationService.addErrorMessage(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-editor.invalid-record-instance-id.message'));
            }
            if (this.state.recordInstance) {
                this.setRecordInstance(null);
                this.setRecordDefinition(null);
            }
        }
        return initialize$;
    }
    handleNoRecordFoundError(error) {
        const isNoRecordFoundError = this.rxRecordInstanceUtilsService.isNoRecordFoundError(error);
        if (isNoRecordFoundError) {
            this.rxNotificationService.addWarningMessage(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-editor.no-access-to-record.message'));
            this.runtimeViewModelApi.cancel(true).subscribe();
        }
        return throwError(isNoRecordFoundError ? null : error);
    }
    updateIsDirtyProperty() {
        const isDirty = this.isDirty();
        if (this.state.isDirty !== isDirty) {
            this.state.isDirty = isDirty;
            this.notifyPropertyChanged('isDirty', isDirty);
        }
    }
    updateCanSaveProperty() {
        const canSave = this.canSave();
        if (this.state.canSave !== canSave) {
            this.state.canSave = canSave;
            this.notifyPropertyChanged('canSave', canSave);
        }
    }
    setRecordInstance(recordInstance) {
        forEach(this.associationManagers, (manager) => manager.destroy());
        this.associationInstances = {};
        this.associationManagers = {};
        if (recordInstance && !recordInstance.associationInstances) {
            recordInstance.associationInstances = {};
            this.associationInstances = recordInstance.associationInstances;
        }
        this.state.recordInstance = recordInstance;
        this.state.recordInstanceId = recordInstance && recordInstance.id;
        recordInstance ? this.syncRecordInstanceWithForm() : this.state.form.clearAndReset();
        this.notifyPropertyChanged('recordInstance', this.state.recordInstance);
        this.notifyPropertyChanged('recordInstanceId', this.state.recordInstanceId);
        this.updateIsDirtyProperty();
        this.updateCanSaveProperty();
        if (recordInstance) {
            this.recordInstanceChangedSubject.next();
        }
    }
    getFieldInstanceControlValidator(fieldId, associatedRecordPath) {
        return (control) => this.state.recordInstance &&
            this.state.recordInstance.validateSingleField(fieldId, control.value, associatedRecordPath);
    }
    setRecordDefinition(recordDefinition) {
        if (recordDefinition) {
            if (this.isInBulkEditMode()) {
                recordDefinition = this.rxRecordDefinitionService.setFieldDefinitionsToOptional(recordDefinition);
            }
            recordDefinition.fieldDefinitionsById =
                this.rxRecordDefinitionService.buildFieldDefinitionsByIdMap(recordDefinition);
        }
        this.state.recordDefinition = recordDefinition;
        this.notifyPropertyChanged('recordDefinition', this.state.recordDefinition);
    }
    getRecordInstance() {
        if (this.isInCreateMode() || this.isInTemporaryMode()) {
            if (this.state.recordInstance) {
                this.state.recordInstance = this.state.recordInstance.getOriginalRecordInstance();
                return of(this.state.recordInstance);
            }
            else {
                return this.rxRecordInstanceService.getNew(this.state.recordDefinitionName);
            }
        }
        else if (this.isInBulkEditMode()) {
            return this.rxRecordInstanceService.getEmpty(this.state.recordDefinitionName);
        }
        else if (this.isInEditMode()) {
            return this.rxRecordInstanceService.get(this.state.recordDefinitionName, this.state.recordInstanceId);
        }
    }
    getAssociationInstances(associationDefinitionName, nodeSide, rolesConfigKey) {
        const nodeSideRolesConfigKey = compact([nodeSide, rolesConfigKey]).join(':');
        let associationRecords = get(this.associationInstances, [
            associationDefinitionName,
            nodeSideRolesConfigKey
        ]);
        if (!associationRecords) {
            associationRecords = {
                existing: [],
                pending: [],
                deleted: [],
                extensions: []
            };
            set(this.associationInstances, [associationDefinitionName, nodeSideRolesConfigKey], associationRecords);
        }
        return associationRecords;
    }
    setRecordEditorState(state) {
        this.state.currentState = state;
        this.notifyPropertyChanged('inReadState', state === RecordEditorState.Read);
    }
    isInCreateMode() {
        return this.state.mode === RecordEditorMode.Create;
    }
    isInBulkEditMode() {
        return this.state.mode === RecordEditorMode.BulkEdit;
    }
    isInEditMode() {
        return this.state.mode === RecordEditorMode.Edit;
    }
    isInTemporaryMode() {
        return this.state.mode === RecordEditorMode.Temporary;
    }
    isNewAttachment(fieldId) {
        return Boolean(this.state.recordInstance.fieldInstances[fieldId].file);
    }
    updateSelectionFieldOptionNames(recordInstance) {
        if (recordInstance && get(this.state.recordDefinition, 'fieldDefinitions')) {
            const newSelectionFieldOptionNames = this.rxRecordEditorUtilsService.getSelectionFieldOptionNames(this.state.recordDefinition, recordInstance);
            if (!isEqual(this.state.selectionFieldOptionNamesById, newSelectionFieldOptionNames)) {
                this.notifyPropertyChanged('selectionFieldOptionNamesById', newSelectionFieldOptionNames);
            }
        }
    }
    syncRecordInstanceWithForm(associatedRecordPath) {
        const fieldIds = this.state.form.getFieldIds(associatedRecordPath);
        if (!isEmpty(fieldIds)) {
            const formStateByFieldId = fieldIds.reduce((result, fieldId) => {
                result[fieldId] = this.state.recordInstance.getFieldValue(Number(fieldId), associatedRecordPath);
                return result;
            }, {});
            this.state.form.resetFieldControls(formStateByFieldId, associatedRecordPath);
        }
    }
    restoreRecordEditor() {
        this.state.recordInstance.revertFieldInstances();
        forEach(this.associationManagers, (manager) => manager.restore());
        this.syncRecordInstanceWithForm();
        this.notifyPropertyChanged('recordInstance', this.state.recordInstance);
        this.updateIsDirtyProperty();
        this.updateCanSaveProperty();
    }
}
RecordEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorComponent, deps: [{ token: i1$5.RxRecordInstanceService }, { token: i1$5.RxRecordInstanceUpdateService }, { token: i2.TranslateService }, { token: i1$1.RxGlobalEventsService }, { token: i1$1.RxNotificationService }, { token: i1$5.RxRecordDefinitionService }, { token: RxRecordEditorUtilsService }, { token: i1$5.RxRecordInstanceUtilsService }, { token: i2$1.RxStringService }, { token: i1$1.RxLogService }, { token: i1$6.RxUtilityModalsService }, { token: RecordEditorForm }, { token: RxAssociationManagerService }], target: i0.ɵɵFactoryTarget.Component });
RecordEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordEditorComponent, selector: "rx-record-editor", inputs: { config: "config", runtimeViewModelApi: "runtimeViewModelApi" }, providers: [RecordEditorForm], usesInheritance: true, ngImport: i0, template: "<div class=\"loader-container\" *ngIf=\"state.isDataLoading && !state.recordInstance\">\n  <div class=\"loader-inline mr-1\"></div>\n  <span>{{ 'com.bmc.arsys.rx.client.common.loading-data' | translate }}</span>\n</div>\n\n<div *ngIf=\"!state.isDataLoading && (!isConfigValid() || !state.recordInstance)\">\n  {{ 'com.bmc.arsys.rx.client.view-components.record-editor.invalid-record.message' | translate }}\n</div>\n\n<div *ngIf=\"state.recordInstance && isConfigValid()\" class=\"clearfix\">\n  <div class=\"d-flex justify-content-end\">\n    <button\n      *ngIf=\"isEditStateAvailable()\"\n      class=\"py-0 mb-1\"\n      adapt-button\n      size=\"small\"\n      btn-type=\"tertiary\"\n      (click)=\"switchToEditState()\"\n    >\n      {{ 'com.bmc.arsys.rx.client.common.edit.label' | translate }}\n    </button>\n  </div>\n\n  <rx-runtime-view-canvas-outlet></rx-runtime-view-canvas-outlet>\n\n  <button\n    *ngIf=\"isSaveButtonAvailable()\"\n    class=\"mr-1 mt-3\"\n    rx-id=\"save-button\"\n    adapt-button\n    btn-type=\"primary\"\n    size=\"small\"\n    [disabled]=\"isSaveButtonDisabled()\"\n    (click)=\"onSaveClick()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button\n    *ngIf=\"isCancelButtonAvailable()\"\n    class=\"mt-3\"\n    rx-id=\"cancel-button\"\n    adapt-button\n    btn-type=\"secondary\"\n    size=\"small\"\n    (click)=\"onCancelClick()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.cancel.label' | translate }}\n  </button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{display:block;border:1px solid #d6d7d8;padding:1rem;position:relative}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1$2.RuntimeViewCanvasOutletComponent, selector: "rx-runtime-view-canvas-outlet", inputs: ["name"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-editor',
                    templateUrl: './record-editor.component.html',
                    styleUrls: ['record-editor.component.scss'],
                    providers: [RecordEditorForm]
                }]
        }], ctorParameters: function () { return [{ type: i1$5.RxRecordInstanceService }, { type: i1$5.RxRecordInstanceUpdateService }, { type: i2.TranslateService }, { type: i1$1.RxGlobalEventsService }, { type: i1$1.RxNotificationService }, { type: i1$5.RxRecordDefinitionService }, { type: RxRecordEditorUtilsService }, { type: i1$5.RxRecordInstanceUtilsService }, { type: i2$1.RxStringService }, { type: i1$1.RxLogService }, { type: i1$6.RxUtilityModalsService }, { type: RecordEditorForm }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [RxAssociationManagerService]
                }] }]; }, propDecorators: { config: [{
                type: Input
            }], runtimeViewModelApi: [{
                type: Input
            }] } });

class RecordEditorComponentDefinitionAdapterService {
    constructor(viewDefinitionParserService) {
        this.viewDefinitionParserService = viewDefinitionParserService;
    }
    adaptDefinition(recordEditorComponentDefinition) {
        const properties = get(recordEditorComponentDefinition, 'propertiesByName');
        if (properties.mode === RecordEditorMode.Edit && isUndefined(properties.allowEdit)) {
            properties.allowEdit = '1';
        }
        this.viewDefinitionParserService
            .getComponents(recordEditorComponentDefinition)
            .filter((componentPair) => componentPair.componentDefinition.type !== RxViewComponentType.ActionButton &&
            (componentPair.componentDefinition.propertiesByName.hasOwnProperty('fieldId') ||
                componentPair.componentDefinition.type === RxViewComponentType.Association))
            .map((componentPair) => componentPair.componentDefinition)
            .forEach((fieldComponentDefinition) => {
            Object.assign(fieldComponentDefinition.propertiesByName, {
                api: `\${view.components.${recordEditorComponentDefinition.guid}.api}`,
                inReadState: `\${view.components.${recordEditorComponentDefinition.guid}.inReadState}`,
                recordDefinition: `\${view.components.${recordEditorComponentDefinition.guid}.recordDefinition}`,
                recordInstance: `\${view.components.${recordEditorComponentDefinition.guid}.recordInstance}`
            });
        });
    }
}
RecordEditorComponentDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorComponentDefinitionAdapterService, deps: [{ token: i1$4.RxViewDefinitionParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RecordEditorComponentDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorComponentDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorComponentDefinitionAdapterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$4.RxViewDefinitionParserService }]; } });

// AoT requires an exported function for factories
function AssociationManagerFactory(rxAssociationInstanceDataPageService, rxRecordDefinitionCacheService, rxRecordInstanceUtilsService, rxRecordInstanceService, rxJsonParserService, rxAssociationDefinitionCacheService) {
    const service = function (options) {
        return new RxAssociationManagerService(options, rxAssociationInstanceDataPageService, rxRecordDefinitionCacheService, rxRecordInstanceUtilsService, rxRecordInstanceService, rxJsonParserService, rxAssociationDefinitionCacheService);
    };
    return service;
}
class RecordEditorModule {
    constructor(rxDefinitionAdapterRegistryService, recordEditorComponentDefinitionAdapterService) {
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.recordEditorComponentDefinitionAdapterService = recordEditorComponentDefinitionAdapterService;
        rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.RecordEditor, this.recordEditorComponentDefinitionAdapterService);
    }
}
RecordEditorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: RecordEditorComponentDefinitionAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
RecordEditorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorModule, declarations: [RecordEditorComponent], imports: [CommonModule,
        RuntimeViewCanvasModule,
        ReactiveFormsModule,
        AdaptButtonModule,
        RxModalModule,
        TranslateModule, i1.AdaptAlertModule], exports: [RecordEditorComponent] });
RecordEditorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorModule, providers: [
        RecordEditorComponentDefinitionAdapterService,
        RxRecordEditorUtilsService,
        {
            provide: RxAssociationManagerService,
            useFactory: AssociationManagerFactory,
            deps: [
                RxAssociationInstanceDataPageService,
                RxRecordDefinitionCacheService,
                RxRecordInstanceUtilsService,
                RxRecordInstanceService,
                RxJsonParserService,
                RxAssociationDefinitionCacheService
            ]
        }
    ], imports: [[
            CommonModule,
            RuntimeViewCanvasModule,
            ReactiveFormsModule,
            AdaptButtonModule,
            RxModalModule,
            TranslateModule,
            AdaptAlertModule.forRoot()
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RuntimeViewCanvasModule,
                        ReactiveFormsModule,
                        AdaptButtonModule,
                        RxModalModule,
                        TranslateModule,
                        AdaptAlertModule.forRoot()
                    ],
                    providers: [
                        RecordEditorComponentDefinitionAdapterService,
                        RxRecordEditorUtilsService,
                        {
                            provide: RxAssociationManagerService,
                            useFactory: AssociationManagerFactory,
                            deps: [
                                RxAssociationInstanceDataPageService,
                                RxRecordDefinitionCacheService,
                                RxRecordInstanceUtilsService,
                                RxRecordInstanceService,
                                RxJsonParserService,
                                RxAssociationDefinitionCacheService
                            ]
                        }
                    ],
                    exports: [RecordEditorComponent],
                    declarations: [RecordEditorComponent],
                    entryComponents: [RecordEditorComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: RecordEditorComponentDefinitionAdapterService }]; } });

class RxDefaultRecordEditorInputType {
    constructor() {
        this.resourceTypeFieldTypeMap = {};
        this.initResourceTypeFieldTypeMap();
    }
    getFieldTypeByFieldDefinition(fieldDefinition) {
        if (isFunction(this.resourceTypeFieldTypeMap[fieldDefinition.resourceType])) {
            return this.resourceTypeFieldTypeMap[fieldDefinition.resourceType](fieldDefinition);
        }
        else {
            return this.resourceTypeFieldTypeMap[fieldDefinition.resourceType];
        }
    }
    initResourceTypeFieldTypeMap() {
        this.resourceTypeFieldTypeMap = Object.assign(Object.assign({}, RECORD_EDITOR.fieldTypes), { [RX_RECORD_DEFINITION.resourceTypes.character]: (fieldDefinition) => {
                return fieldDefinition.namedListDefinition || inRange(fieldDefinition.maxLength, 1, 255)
                    ? RxViewComponentType.Character
                    : RxViewComponentType.Textarea;
            } });
    }
}
RxDefaultRecordEditorInputType.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDefaultRecordEditorInputType, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
RxDefaultRecordEditorInputType.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDefaultRecordEditorInputType, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDefaultRecordEditorInputType, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

const RX_ASSOCIATION = {
    actions: {
        associate: 'associate',
        createAndAssociate: 'createAndAssociate'
    },
    componentTypes: {
        associationFilter: 'rx-association-filter',
        associatedRecordField: 'rx-associated-record-field'
    }
};
var RxAssociationEditingMode;
(function (RxAssociationEditingMode) {
    RxAssociationEditingMode["Dropdown"] = "dropdown";
    RxAssociationEditingMode["Views"] = "views";
})(RxAssociationEditingMode || (RxAssociationEditingMode = {}));

class RxRecordPreviewCardComponent {
    ngOnInit() {
        this.maxFieldValueLength = this.config.maxFieldValueLength || 200;
    }
    isEditableState() {
        return this.config.state === RecordEditorState.Edit;
    }
}
RxRecordPreviewCardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordPreviewCardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxRecordPreviewCardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxRecordPreviewCardComponent, selector: "rx-record-preview-card", inputs: { config: "config" }, ngImport: i0, template: "<div class=\"rx-record-preview-card d-flex align-items-start justify-content-between w-100\">\n  <ul class=\"rx-card-fields d-flex flex-column list-unstyled focusable mb-0\" tabindex=\"0\">\n    <li class=\"d-flex rx-card-field\" *ngFor=\"let field of config.fields\">\n      <span class=\"rx-card-field-label\" *ngIf=\"field.label\">{{ field.label }}</span>\n      <span *ngIf=\"field.label\">: </span>\n      <span class=\"rx-card-field-value px-1\" [ngClass]=\"{ 'font-weight-bold': !isEditableState() }\">{{\n        field.value\n      }}</span>\n    </li>\n  </ul>\n\n  <button\n    *ngIf=\"isEditableState()\"\n    (click)=\"config.onDelete(config.id)\"\n    class=\"btn btn-link d-icon-cross p-0\"\n    adapt-button\n    size=\"small\"\n    btn-type=\"tertiary\"\n    [attr.aria-label]=\"'com.bmc.arsys.rx.client.common.remove.label' | translate\"\n  ></button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{display:flex}.rx-record-preview-card{flex:1}.rx-card-field{flex:1;line-height:20px}.rx-card-field:not(:first-child){color:#959899}.rx-card-fields{flex:1;white-space:nowrap;min-width:0}.rx-card-field-label{flex-shrink:0;max-width:30%;text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.rx-card-field-value{text-overflow:ellipsis;overflow:hidden}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordPreviewCardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-preview-card',
                    templateUrl: './record-preview-card.component.html',
                    styleUrls: ['./record-preview-card.component.scss']
                }]
        }], propDecorators: { config: [{
                type: Input
            }] } });

class RxAssociationComponent extends BaseViewComponent {
    constructor(datePipe, rxAssociationDefinitionService, rxAssociationInstanceDataPageService, rxRecordDefinitionInheritanceDataPageService, rxRecordInstanceDataPageService, rxRecordInstanceUtilsService) {
        super();
        this.datePipe = datePipe;
        this.rxAssociationDefinitionService = rxAssociationDefinitionService;
        this.rxAssociationInstanceDataPageService = rxAssociationInstanceDataPageService;
        this.rxRecordDefinitionInheritanceDataPageService = rxRecordDefinitionInheritanceDataPageService;
        this.rxRecordInstanceDataPageService = rxRecordInstanceDataPageService;
        this.rxRecordInstanceUtilsService = rxRecordInstanceUtilsService;
        this.isDisabled = false;
        this.api = {
            associate: (associations) => {
                this.associationManager.addToPending(associations, this.extractRolesConfig());
            }
        };
        this.modelToViewValueAdapterFunc = this.modelToViewValueAdapter.bind(this);
        this.optionLoaderFunc = this.getAssociationsOptionPage.bind(this);
        this.viewToModelValueAdapterFunc = this.viewToModelValueAdapter.bind(this);
        this.existingPreviewConfigurations = [];
        this.pendingPreviewConfigurations = [];
        this.selectedOptions = [];
        this.pendingPageSize = 10;
        this.currentPendingCount = 10;
        this.totalPendingCount = 0;
        this.associationCandidateRecordInstances = [];
        this.fieldDefinitions = {};
        this.fieldId = null;
        this.fields = [];
        this.inReadState = false;
        this.label = null;
        this.recordDefinition = null;
        this.recordDefinitionName = null;
        this.useDefaultRoles = null;
        this.nodeARole = null;
        this.nodeBRole = null;
        this.formControl = new FormControl('', null);
        this.isHidden = false;
    }
    ngOnInit() {
        super.ngOnInit();
        const config$ = this.config.pipe(filter((config) => Boolean(config.api && config.recordDefinition)), takeUntil(this.destroyed$));
        config$.pipe(take(1)).subscribe((config) => {
            this.onConfigInitialized(config);
            this.onConfigUpdated(config);
        });
        config$.pipe(skip(1)).subscribe(this.onConfigUpdated.bind(this));
        this.notifyPropertyChanged('api', this.api);
        this.previewRolesConfig = this.extractRolesConfig();
    }
    ngAfterViewInit() {
        if (this.editingMode === RxAssociationEditingMode.Dropdown) {
            this.formControl.valueChanges
                .pipe(distinctUntilChanged(), startWith(this.formControl.value), takeUntil(this.destroyed$))
                .subscribe(() => {
                this.updateSelectedOptions();
            });
        }
    }
    onConfigInitialized(config) {
        this.associationDefinitionName = config.associationDefinitionName;
        this.associatedRecordNodeSide = config.associatedRecordNodeSide;
        this.editingMode = config.editingMode || RxAssociationEditingMode.Views;
        this.fieldId = config.fieldId;
        this.fields = config.fields;
        this.recordDefinition = config.recordDefinition;
        this.recordDefinitionName = config.recordDefinitionName;
        this.recordEditorApi = config.api;
        this.state = config.state;
        this.useDefaultRoles = config.useDefaultRoles;
        this.nodeARole = config.nodeARole;
        this.nodeBRole = config.nodeBRole;
        if (this.fieldId) {
            this.fieldDefinition = config.recordDefinition.fieldDefinitions.find((definition) => definition.id === Number(this.fieldId));
        }
    }
    onConfigUpdated(config) {
        var _a;
        const inReadState = Boolean(config.inReadState);
        const isDisabled = Boolean(config.disabled) || this.permissionType === RX_RECORD_DEFINITION.fieldPermissionTypes.view;
        let forceUpdatePreviewCardConfigState = false;
        this.isHidden = Boolean(config.hidden);
        this.areActionsAvailable = !inReadState && this.editingMode === RxAssociationEditingMode.Views;
        if (this.isDisabled !== isDisabled) {
            this.isDisabled = isDisabled;
            forceUpdatePreviewCardConfigState = true;
        }
        if (this.inReadState !== inReadState) {
            this.inReadState = inReadState;
            forceUpdatePreviewCardConfigState = true;
        }
        if (forceUpdatePreviewCardConfigState && this.existingPreviewConfigurations.length) {
            this.updatePreviewCardConfigState();
        }
        this.label = isUndefined(config.label) ? (_a = this.fieldDefinition.name) !== null && _a !== void 0 ? _a : '' : config.label;
        if (this.selectWithPaginationComponent &&
            this.associationFilter &&
            get(config, 'associationFilter[0]') &&
            this.associationFilter.recordInstanceId !== config.associationFilter[0].recordInstanceId) {
            // Do not delete existing association until Record editor is ready.
            // This is needed in case when e.g. one association view component
            // is filtered by the value selected in the other association view component.
            // If during initialization, the value in the second view component gets loaded
            // faster than the value in the first one, the value in the second view component
            // would be cleared after the first component's value is loaded.
            if (this.recordEditorApi.isReady()) {
                this.deleteAllExisting();
            }
            this.deleteAllPending();
            this.selectWithPaginationComponent.resetLoadedOptions();
            this.associationCandidateRecordInstances = [];
            if (!this.associationFilterNodeSide) {
                this.rxAssociationDefinitionService
                    .get(this.associationFilter.associationDefinitionName)
                    .pipe(switchMap((associationDefinition) => {
                    if (associationDefinition.nodeAId === this.recordDefinitionName) {
                        this.associationFilterNodeSide = RxAssociatedRecordNodeSide.NodeA;
                    }
                    else if (associationDefinition.nodeBId === this.recordDefinitionName) {
                        this.associationFilterNodeSide = RxAssociatedRecordNodeSide.NodeB;
                    }
                    else {
                        return this.rxRecordDefinitionInheritanceDataPageService
                            .get({ params: { recorddefinition: this.recordDefinitionName } })
                            .pipe(tap((recordDefinitionInheritanceDataPage) => {
                            const recordDefinitionAncestors = recordDefinitionInheritanceDataPage.data;
                            if (includes(recordDefinitionAncestors, associationDefinition.nodeAId)) {
                                this.associationFilterNodeSide = RxAssociatedRecordNodeSide.NodeA;
                            }
                            else if (includes(recordDefinitionAncestors, associationDefinition.nodeBId)) {
                                this.associatedRecordNodeSide = RxAssociatedRecordNodeSide.NodeB;
                            }
                            else {
                                throw new Error('No matches for association definition node side within inheritance ancestors.');
                            }
                        }));
                    }
                    return EMPTY;
                }))
                    .subscribe();
            }
        }
        this.associationFilter = head(config.associationFilter);
        if (config.recordInstance && this.recordInstance !== config.recordInstance) {
            this.recordInstance = config.recordInstance;
            this.isDisabled = true;
            this.notifyPropertyChanged('isDisabled', this.isDisabled);
            this.recordEditorApi.notifyComponentReady(this.guid, false);
            this.associationManager = this.getAssociationManager();
            this.associationManager
                .initialize()
                .pipe(delay(0), switchMap(() => this.associationManager.loadExistingAssociations()), tap(() => {
                this.isDisabled =
                    Boolean(config.disabled) || this.permissionType === RX_RECORD_DEFINITION.fieldPermissionTypes.view;
                this.notifyPropertyChanged('isDisabled', this.isDisabled);
                this.areActionsAvailable = !this.inReadState && this.editingMode === RxAssociationEditingMode.Views;
                if (this.editingMode === RxAssociationEditingMode.Views) {
                    this.fieldDefinitions = transform(this.fields, (result, field) => {
                        const fieldDefinition = find(this.associationManager.recordDefinition.fieldDefinitions, {
                            id: Number(field.fieldId)
                        });
                        result[fieldDefinition.id] = fieldDefinition;
                    }, {});
                }
                this.associationManager.existing$.pipe(takeUntil(this.destroyed$)).subscribe((newValue) => {
                    this.onAssociationsChanged(newValue, 'existingPreviewConfigurations');
                    this.updateTotalExistingAssociationsCount();
                });
                this.associationManager.pending$.pipe(takeUntil(this.destroyed$)).subscribe((newValue) => {
                    this.onAssociationsChanged(newValue, 'pendingPreviewConfigurations');
                    this.totalPendingCount = this.pendingPreviewConfigurations.length;
                });
                combineLatest([this.associationManager.pending$, this.associationManager.existing$])
                    .pipe(take(1))
                    .subscribe(() => {
                    this.recordEditorApi.notifyComponentReady(this.guid, true);
                });
            }))
                .subscribe();
        }
    }
    getAssociationManager() {
        const fieldsIds = this.fieldId
            ? [this.fieldId, RX_RECORD_DEFINITION.coreFieldIds.id]
            : map$1(this.fields, 'fieldId');
        return this.recordEditorApi.getAssociationManager({
            associationDefinitionName: this.associationDefinitionName,
            associatedRecordNodeSide: this.associatedRecordNodeSide || RX_ASSOCIATION_DEFINITION.roles.second.value,
            associatedRecordInstanceId: this.recordInstance.id,
            recordDefinitionName: this.recordDefinitionName,
            fieldIds: fieldsIds,
            rolesConfig: this.extractRolesConfig()
        });
    }
    getAssociationsOptionPage(startIndex, pageSize, searchQuery) {
        const params = {
            pageSize: pageSize,
            startIndex: startIndex,
            recorddefinition: this.recordDefinitionName,
            propertySelection: this.associationManager.getFieldIds()
        };
        let instanceDataPageService;
        if (this.associationFilter) {
            if (this.associationFilter.recordInstanceId) {
                params.associationDefinition = this.associationFilter.associationDefinitionName;
                params.associatedRecordInstanceId = this.associationFilter.recordInstanceId;
                params.nodeToQuery = this.associationFilterNodeSide;
                instanceDataPageService = this.rxAssociationInstanceDataPageService;
            }
        }
        else {
            params.sortBy = this.fieldId;
            if (searchQuery) {
                params.queryExpression = `('${this.fieldId}' LIKE "%${this.rxRecordInstanceUtilsService.escapeTextWildcards(searchQuery)}%")`;
            }
            instanceDataPageService = this.rxRecordInstanceDataPageService;
        }
        return instanceDataPageService
            ? instanceDataPageService.post({ params: params }).pipe(map((result) => {
                this.associationCandidateRecordInstances.push(...result.data);
                return {
                    totalSize: result.totalSize,
                    options: result.data.map((recordInstance) => ({
                        displayValue: recordInstance[this.fieldId] || '',
                        value: recordInstance[RX_RECORD_DEFINITION.coreFieldIds.id]
                    }))
                };
            }))
            : of({
                options: [],
                totalSize: 0
            });
    }
    deleteAllExisting() {
        this.associationManager.deleteAllExisting();
    }
    deleteAllPending() {
        this.associationManager.deleteAllPending();
    }
    loadExistingAssociations() {
        this.associationManager
            .loadExistingAssociations()
            .pipe(takeUntil(this.destroyed$))
            .subscribe(() => this.updateTotalExistingAssociationsCount());
    }
    isReadModeEnabled() {
        return this.inReadState;
    }
    isEditModeEnabled() {
        return !this.inReadState;
    }
    getAssociatedValue() {
        return get(this, 'selectedOptions[0].displayValue');
    }
    // [{displayValue: 'FOO', value: 'foo'}, {displayValue: 'BAR', value: 'bar'}] -> 'foo;bar;baz'
    viewToModelValueAdapter(selectedOptions) {
        return selectedOptions.map((option) => option.value).join(';');
    }
    // 'foo;bar;baz' -> [{displayValue: 'FOO', value: 'foo'}, {displayValue: 'BAR', value: 'bar'}]
    modelToViewValueAdapter(modelValue) {
        return modelValue ? castArray(this.selectedOptions) : [];
    }
    resetDropdownSelection() {
        this.selectedOptions = [];
    }
    updatePreviewCardConfigState() {
        forEach(this.existingPreviewConfigurations, (previewCardConfig) => {
            previewCardConfig.state = this.getStateForPreviewConfiguration();
        });
    }
    updateSelectedOptions() {
        if (this.formControl.value && !isNil(this.formControl.value)) {
            const pendingAssociation = {
                id: this.formControl.value,
                fieldInstances: null
            };
            const selectedRecordInstance = find(this.associationCandidateRecordInstances, function (association) {
                return association[RX_RECORD_DEFINITION.coreFieldIds.id] === pendingAssociation.id;
            });
            pendingAssociation.fieldInstances = transform(selectedRecordInstance, function (result, value, filedId) {
                result[filedId] = { value: value };
            }, {});
            this.associationManager.addToPending([pendingAssociation], null);
        }
        else {
            this.deleteAllExisting();
            this.deleteAllPending();
        }
    }
    buildPreviewConfig(association, fields, state) {
        return {
            id: association.id,
            state: state,
            onDelete: (associationId) => {
                this.associationManager.delete(associationId);
            },
            fields: map$1(fields, (field) => {
                const fieldDefinition = this.fieldDefinitions[field.fieldId];
                const fieldInstance = association.fieldInstances[field.fieldId];
                let value;
                if (fieldInstance) {
                    value = fieldInstance.value;
                }
                if (fieldDefinition.resourceType === RX_RECORD_DEFINITION.dataTypes.selection.resourceType) {
                    value = fieldDefinition.optionNamesById[value];
                }
                if (fieldDefinition.resourceType === RX_RECORD_DEFINITION.dataTypes.dateTime.resourceType ||
                    (fieldDefinition.resourceType === RX_RECORD_DEFINITION.dataTypes.dateOnly.resourceType && isString(value))) {
                    value = this.datePipe.transform(value, 'mediumDate');
                }
                return {
                    label: field.label,
                    value: value || '<unknown>',
                    index: field.index,
                    fieldId: field.fieldId
                };
            })
        };
    }
    showPendingAssociations() {
        this.currentPendingCount += this.pendingPageSize;
    }
    getPendingPreviewConfigurations() {
        return this.pendingPreviewConfigurations.slice(0, this.currentPendingCount);
    }
    extractRolesConfig() {
        return {
            useDefaultRoles: this.useDefaultRoles,
            nodeARole: this.nodeARole,
            nodeBRole: this.nodeBRole
        };
    }
    updateTotalExistingAssociationsCount() {
        this.associationManager.totalExistingCount =
            (this.associationManager.remainingAssociatedRecordCount || 0) + this.existingPreviewConfigurations.length;
    }
    getStateForPreviewConfiguration() {
        return this.areActionsAvailable && !this.isDisabled ? RecordEditorState.Edit : RecordEditorState.Read;
    }
    getFirstAssociationRecord() {
        return this.associationManager.existing[0] || this.associationManager.pending[0] || {};
    }
    onAssociationsChanged(associations, configName) {
        var _a;
        const firstAssociatedRecord = this.getFirstAssociationRecord();
        this.notifyPropertyChanged('firstAssociatedRecord', { id: firstAssociatedRecord.id || '' });
        if (this.editingMode === RxAssociationEditingMode.Views) {
            const associationsToPreview = associations.filter((association) => every(this.previewRolesConfig, isEmpty) || isEqual(this.previewRolesConfig, association.rolesConfig));
            this[configName] = this.rebuildPreviewConfigurations(associationsToPreview);
        }
        else if (this.editingMode === RxAssociationEditingMode.Dropdown) {
            if (firstAssociatedRecord.id) {
                this.selectedOptions = [
                    {
                        displayValue: (_a = firstAssociatedRecord.fieldInstances[this.fieldId]) === null || _a === void 0 ? void 0 : _a.value,
                        value: firstAssociatedRecord.id
                    }
                ];
            }
            else {
                this.resetDropdownSelection();
            }
            this.formControl.setValue(firstAssociatedRecord.id);
        }
    }
    rebuildPreviewConfigurations(associations) {
        const state = this.getStateForPreviewConfiguration();
        return map$1(associations, (association) => {
            return this.buildPreviewConfig(association, this.fields, state);
        });
    }
}
RxAssociationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationComponent, deps: [{ token: i3.DatePipe }, { token: i2$4.RxAssociationDefinitionService }, { token: i2$4.RxAssociationInstanceDataPageService }, { token: i1$5.RxRecordDefinitionInheritanceDataPageService }, { token: i1$5.RxRecordInstanceDataPageService }, { token: i1$5.RxRecordInstanceUtilsService }], target: i0.ɵɵFactoryTarget.Component });
RxAssociationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxAssociationComponent, selector: "rx-association", host: { properties: { "class.rx-field-disabled": "this.isDisabled" } }, viewQueries: [{ propertyName: "selectWithPaginationComponent", first: true, predicate: RxSelectWithPaginationComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<rx-read-only-field\n  *ngIf=\"!isHidden && isReadModeEnabled() && (existingPreviewConfigurations.length === 0 || editingMode === 'dropdown')\"\n  [label]=\"label\"\n  [value]=\"getAssociatedValue()\"\n></rx-read-only-field>\n\n<div *ngIf=\"!isHidden\" [ngSwitch]=\"editingMode\">\n  <div *ngSwitchCase=\"'views'\" [attr.aria-label]=\"label\" [ngClass]=\"{ 'read-state': isReadModeEnabled() }\">\n    <adapt-rx-control-label *ngIf=\"isEditModeEnabled() || existingPreviewConfigurations.length > 0\" [label]=\"label\">\n    </adapt-rx-control-label>\n\n    <div *ngIf=\"areActionsAvailable\">\n      <rx-runtime-view-canvas-outlet></rx-runtime-view-canvas-outlet>\n    </div>\n\n    <div *ngIf=\"isReadModeEnabled()\">\n      <div [ngSwitch]=\"associationManager.cardinalityType\">\n        <div *ngSwitchCase=\"associationManager.cardinalityTypes.One\">\n          <div *ngIf=\"existingPreviewConfigurations.length || pendingPreviewConfigurations.length\" class=\"list-group\">\n            <rx-record-preview-card\n              [config]=\"existingPreviewConfigurations[0] || pendingPreviewConfigurations[0]\"\n              class=\"list-group-item\"\n            ></rx-record-preview-card>\n          </div>\n        </div>\n\n        <div *ngSwitchDefault>\n          <div class=\"list-group\">\n            <rx-record-preview-card\n              *ngFor=\"let previewCardConfig of existingPreviewConfigurations\"\n              [config]=\"previewCardConfig\"\n              class=\"list-group-item\"\n            ></rx-record-preview-card>\n          </div>\n\n          <button\n            *ngIf=\"\n              associationManager.totalExistingCount >\n              existingPreviewConfigurations.length + associationManager.deleted.length\n            \"\n            (click)=\"loadExistingAssociations()\"\n            adapt-button\n            size=\"small\"\n            btn-type=\"tertiary\"\n            type=\"button\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.show-more.label' | translate }}\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <div *ngIf=\"isEditModeEnabled()\">\n      <div *ngIf=\"existingPreviewConfigurations.length\" class=\"form-group\">\n        <div class=\"d-flex justify-content-end pb-1\">\n          <span class=\"preview-count\">\n            {{\n              associationManager.totalExistingCount > 1\n                ? ('com.bmc.arsys.rx.client.view-components.record-editor.association.total-items.label'\n                  | translate\n                    : {\n                        count: associationManager.totalExistingCount\n                      })\n                : ('com.bmc.arsys.rx.client.view-components.record-editor.association.single-item.label' | translate)\n            }}\n          </span>\n\n          <button\n            [hidden]=\"!areActionsAvailable || isDisabled\"\n            (click)=\"deleteAllExisting()\"\n            adapt-button\n            size=\"small\"\n            btn-type=\"tertiary\"\n            class=\"btn btn-link py-0\"\n            type=\"button\"\n          >\n            {{ 'com.bmc.arsys.rx.client.view-components.record-editor.association.button.clear-all.label' | translate }}\n          </button>\n        </div>\n\n        <div class=\"list-group\">\n          <rx-record-preview-card\n            *ngFor=\"let previewCardConfig of existingPreviewConfigurations\"\n            [config]=\"previewCardConfig\"\n            class=\"list-group-item\"\n          ></rx-record-preview-card>\n        </div>\n\n        <button\n          *ngIf=\"\n            associationManager.totalExistingCount >\n            existingPreviewConfigurations.length + associationManager.deleted.length\n          \"\n          (click)=\"loadExistingAssociations()\"\n          adapt-button\n          size=\"small\"\n          btn-type=\"tertiary\"\n          type=\"button\"\n        >\n          {{ 'com.bmc.arsys.rx.client.common.show-more.label' | translate }}\n        </button>\n      </div>\n\n      <div *ngIf=\"pendingPreviewConfigurations.length\" class=\"form-group mt-3\">\n        <div class=\"d-flex justify-content-between\">\n          <div class=\"m-0\">\n            {{\n              'com.bmc.arsys.rx.client.view-components.record-editor.association.pending-associations.label' | translate\n            }}\n            :\n          </div>\n\n          <div class=\"d-flex pb-1\">\n            <span class=\"preview-count\">\n              {{\n                totalPendingCount > 1\n                  ? ('com.bmc.arsys.rx.client.view-components.record-editor.association.total-items.label'\n                    | translate\n                      : {\n                          count: totalPendingCount\n                        })\n                  : ('com.bmc.arsys.rx.client.view-components.record-editor.association.single-item.label' | translate)\n              }}\n            </span>\n\n            <button\n              [hidden]=\"!areActionsAvailable || isDisabled\"\n              (click)=\"deleteAllPending()\"\n              adapt-button\n              size=\"small\"\n              btn-type=\"tertiary\"\n              class=\"btn btn-link py-0\"\n              type=\"button\"\n            >\n              {{\n                'com.bmc.arsys.rx.client.view-components.record-editor.association.button.clear-all.label' | translate\n              }}\n            </button>\n          </div>\n        </div>\n\n        <div class=\"list-group\">\n          <rx-record-preview-card\n            *ngFor=\"let previewCardConfig of getPendingPreviewConfigurations()\"\n            [config]=\"previewCardConfig\"\n            class=\"list-group-item\"\n          ></rx-record-preview-card>\n        </div>\n\n        <button\n          *ngIf=\"totalPendingCount > currentPendingCount\"\n          (click)=\"showPendingAssociations()\"\n          adapt-button\n          size=\"small\"\n          btn-type=\"tertiary\"\n          type=\"button\"\n        >\n          {{ 'com.bmc.arsys.rx.client.common.show-more.label' | translate }}\n        </button>\n      </div>\n    </div>\n  </div>\n\n  <div *ngSwitchCase=\"'dropdown'\">\n    <div *ngIf=\"isEditModeEnabled()\" [attr.aria-label]=\"label\">\n      <rx-select-with-pagination\n        [formControl]=\"formControl\"\n        [readonly]=\"isDisabled\"\n        [label]=\"label\"\n        [modelToViewValueAdapter]=\"modelToViewValueAdapterFunc\"\n        [optionLoader]=\"optionLoaderFunc\"\n        [viewToModelValueAdapter]=\"viewToModelValueAdapterFunc\"\n      ></rx-select-with-pagination>\n    </div>\n  </div>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{display:block}:host::ng-deep rx-runtime-view-canvas-item-container{display:flex}:host::ng-deep .rx-runtime-view-canvas-item-margin{margin-bottom:0}:host::ng-deep rx-runtime-view-canvas-item+rx-runtime-view-canvas-item{margin-left:5px}:host::ng-deep .read-state .form-control-label{font-weight:var(--font-weight-normal)}.rx-group-title{font-size:.8125rem;color:#959899;display:flex;align-items:center}.rx-preview-existing-head{margin-top:-30px}.rx-preview-count{font-size:.8125rem;color:#959899;vertical-align:middle}\n"], components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxControlLabelComponent, selector: "adapt-rx-control-label", inputs: ["for", "id", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"] }, { type: i1$2.RuntimeViewCanvasOutletComponent, selector: "rx-runtime-view-canvas-outlet", inputs: ["name"] }, { type: RxRecordPreviewCardComponent, selector: "rx-record-preview-card", inputs: ["config"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i2$5.RxSelectWithPaginationComponent, selector: "rx-select-with-pagination", inputs: ["label", "required", "isMultiSelectionMode", "optionLoader", "pageSize", "showDefaultTitle", "showUncheckAll", "readonly", "template", "viewToModelValueAdapter", "modelToViewValueAdapter", "optionFormatter"], outputs: ["toggleDropdown", "selectionChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i3.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-association',
                    templateUrl: './association.component.html',
                    styleUrls: ['./association.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i3.DatePipe }, { type: i2$4.RxAssociationDefinitionService }, { type: i2$4.RxAssociationInstanceDataPageService }, { type: i1$5.RxRecordDefinitionInheritanceDataPageService }, { type: i1$5.RxRecordInstanceDataPageService }, { type: i1$5.RxRecordInstanceUtilsService }]; }, propDecorators: { selectWithPaginationComponent: [{
                type: ViewChild,
                args: [RxSelectWithPaginationComponent]
            }], isDisabled: [{
                type: HostBinding,
                args: ['class.rx-field-disabled']
            }] } });

class RxAssociationDefinitionAdapterService {
    constructor(rxViewDefinitionParserService) {
        this.rxViewDefinitionParserService = rxViewDefinitionParserService;
    }
    adaptDefinition(associationComponentDefinition, viewDefinition) {
        const targetRecordEditorComponentDefinition = this.getTargetRecordEditorComponentDefinition(viewDefinition, associationComponentDefinition);
        const childButtons = associationComponentDefinition.componentDefinitions.filter((component) => component.type === RxViewComponentType.ActionButton);
        const childSortedButtons = sortBy(childButtons, (componentDefinition) => componentDefinition.propertiesByName.action === RX_ASSOCIATION.actions.associate ? 0 : 1);
        associationComponentDefinition.propertiesByName.state = targetRecordEditorComponentDefinition.propertiesByName.mode;
        associationComponentDefinition.propertiesByName.useDefaultRoles =
            associationComponentDefinition.propertiesByName.useDefaultRoles === 'true';
        associationComponentDefinition.propertiesByName.fields = flow((componentDefinitions) => filter$1(componentDefinitions, {
            type: RX_ASSOCIATION.componentTypes.associatedRecordField
        }), (componentDefinitions) => map$1(componentDefinitions, (fieldComponentDefinition) => ({
            fieldId: fieldComponentDefinition.propertiesByName.fieldId,
            label: fieldComponentDefinition.propertiesByName.label,
            index: Number(fieldComponentDefinition.propertiesByName.index)
        })), (componentDefinitions) => sortBy(componentDefinitions, 'index'))(associationComponentDefinition.componentDefinitions);
        associationComponentDefinition.layout = JSON.stringify({
            outlets: [
                {
                    name: 'DEFAULT',
                    columns: [
                        {
                            children: childSortedButtons.map((component) => component.guid)
                        }
                    ]
                }
            ]
        });
        associationComponentDefinition.componentDefinitions
            .filter((componentDefinition) => componentDefinition.type === RxViewComponentType.ActionButton)
            .forEach((componentDefinition) => {
            componentDefinition.propertiesByName.disabled =
                associationComponentDefinition.propertiesByName.disabled +
                    ' OR ${view.components.' +
                    associationComponentDefinition.guid +
                    '.isDisabled}';
        });
    }
    getTargetRecordEditorComponentDefinition(viewDefinition, extensionContainerComponentDefinition) {
        return this.rxViewDefinitionParserService.findParentComponentDefinition(viewDefinition, extensionContainerComponentDefinition, (parentComponentDefinition) => parentComponentDefinition.type === RxViewComponentType.RecordEditor);
    }
}
RxAssociationDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationDefinitionAdapterService, deps: [{ token: i1$4.RxViewDefinitionParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxAssociationDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationDefinitionAdapterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$4.RxViewDefinitionParserService }]; } });

class AssociationModule {
    constructor(rxAssociationDefinitionAdapterService, rxDefinitionAdapterRegistryService) {
        this.rxAssociationDefinitionAdapterService = rxAssociationDefinitionAdapterService;
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.Association, this.rxAssociationDefinitionAdapterService);
    }
}
AssociationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationModule, deps: [{ token: RxAssociationDefinitionAdapterService }, { token: i1$1.RxDefinitionAdapterRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
AssociationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationModule, declarations: [RxAssociationComponent, RxRecordPreviewCardComponent], imports: [AdaptButtonModule,
        AdaptRxFormControlModule,
        CommonModule,
        FormsModule,
        ReadOnlyFieldModule,
        ReactiveFormsModule,
        RuntimeViewCanvasModule,
        RxSelectWithPaginationModule,
        TranslateModule] });
AssociationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationModule, providers: [DatePipe, RxAssociationDefinitionAdapterService], imports: [[
            AdaptButtonModule,
            AdaptRxFormControlModule,
            CommonModule,
            FormsModule,
            ReadOnlyFieldModule,
            ReactiveFormsModule,
            RuntimeViewCanvasModule,
            RxSelectWithPaginationModule,
            TranslateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptButtonModule,
                        AdaptRxFormControlModule,
                        CommonModule,
                        FormsModule,
                        ReadOnlyFieldModule,
                        ReactiveFormsModule,
                        RuntimeViewCanvasModule,
                        RxSelectWithPaginationModule,
                        TranslateModule
                    ],
                    declarations: [RxAssociationComponent, RxRecordPreviewCardComponent],
                    entryComponents: [RxAssociationComponent, RxRecordPreviewCardComponent],
                    providers: [DatePipe, RxAssociationDefinitionAdapterService]
                }]
        }], ctorParameters: function () { return [{ type: RxAssociationDefinitionAdapterService }, { type: i1$1.RxDefinitionAdapterRegistryService }]; } });

class AssociationRecordFieldSelectorEditorDialogComponent extends RxModalClass {
    constructor(rxStringService, rxGuidService, activeModalRef, injector) {
        super(activeModalRef, injector);
        this.rxStringService = rxStringService;
        this.rxGuidService = rxGuidService;
        this.activeModalRef = activeModalRef;
        this.injector = injector;
        this.availableFieldTreeNodes = [];
        this.canSave = false;
        this.selectedFields = [];
        this.treeWrap = TreeWrap.WrapAll;
        this.config = this.activeModalRef.getData();
    }
    isDirty() {
        return this.canSave;
    }
    ngOnInit() {
        super.ngOnInit();
        this.fieldLabelsMap = transform(this.config.fields, (result, field) => {
            result[field.id] = field.name;
        }, {});
        this.availableFieldTreeNodes = this.config.fields
            .map((field) => ({
            data: field,
            label: field.name
        }))
            .sort((field1, field2) => field1.label.localeCompare(field2.label));
        this.selectedFields = map$1(this.config.selectedFields, (field) => {
            const descriptor = this.config.fields.find((fieldItem) => fieldItem.id === Number(field.data.fieldId));
            return Object.assign(Object.assign({}, field), { labelText: field.data.label, indexOrder: Number(field.data.index), descriptor, isOpen: field === this.config.fieldToEdit });
        });
        this.refreshFieldDescriptorsList();
    }
    addField(field) {
        this.canSave = true;
        this.selectedFields.push({
            guid: this.rxGuidService.generate(),
            data: {
                fieldId: String(field.id),
                label: field.name,
                index: String(this.selectedFields.length)
            },
            descriptor: field,
            labelText: field.name,
            indexOrder: this.selectedFields.length,
            isOpen: true
        });
        this.refreshFieldDescriptorsList();
    }
    onSelectedFieldsListDrop(event) {
        this.addField(event.item.data);
    }
    onSave() {
        const result = this.selectedFields.map((field) => {
            return {
                guid: field.guid,
                type: 'rx-associated-record-field',
                data: {
                    fieldId: field.data.fieldId,
                    index: String(field.indexOrder),
                    label: field.labelText
                }
            };
        });
        this.activeModalRef.close(result);
    }
    onRemove(field) {
        this.canSave = true;
        pull(this.selectedFields, field);
        this.refreshFieldDescriptorsList();
    }
    onMoveUp(field, index) {
        this.canSave = true;
        const prevField = this.selectedFields[index - 1];
        if (prevField) {
            prevField.indexOrder++;
            field.indexOrder--;
            this.sortFields();
        }
    }
    onMoveDown(field, index) {
        this.canSave = true;
        const nextAction = this.selectedFields[index + 1];
        if (nextAction) {
            nextAction.indexOrder--;
            field.indexOrder++;
            this.sortFields();
        }
    }
    toggleOpen(expandAll) {
        this.selectedFields.forEach((field) => (field.isOpen = expandAll));
    }
    sortFields() {
        this.selectedFields = sortBy(this.selectedFields, (field) => field.indexOrder);
    }
    refreshFieldDescriptorsList() {
        const selectedFieldIds = this.selectedFields.map((field) => String(field.data.fieldId));
        this.filteredFieldDescriptors = this.config.fields
            .filter((fieldDescriptor) => !includes(selectedFieldIds, String(fieldDescriptor.id)))
            .sort((field1, field2) => field1.name.localeCompare(field2.name));
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
}
AssociationRecordFieldSelectorEditorDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorEditorDialogComponent, deps: [{ token: i2$1.RxStringService }, { token: i2$1.RxGuidService }, { token: i1.ActiveModalRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
AssociationRecordFieldSelectorEditorDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: AssociationRecordFieldSelectorEditorDialogComponent, selector: "rx-association-record-field-selector-editor-dialog", usesInheritance: true, ngImport: i0, template: "<div class=\"designer-modal-body modal-body d-flex mh-100\">\n  <div class=\"row flex-grow-1 w-100\">\n    <div *ngIf=\"!config.isReadOnly\" class=\"col-4 border-right d-flex flex-column mh-100\">\n      <div class=\"d-flex align-items-start justify-content-between\">\n        <h4 class=\"mt-2\">Available fields</h4>\n      </div>\n\n      <div class=\"rx-card card flex-grow-1 mt-2\">\n        <div class=\"card-block\">\n          <div\n            *ngIf=\"availableFieldTreeNodes.length; else adaptTreeEmptyStateTemplate\"\n            cdkDropList\n            cdkDropListSortingDisabled\n            [cdkDropListConnectedTo]=\"['selected-fields']\"\n          >\n            <adapt-tree [value]=\"availableFieldTreeNodes\" filter=\"true\" [wrap]=\"treeWrap\">\n              <ng-template let-field adaptTreeNodeTemplate>\n                <div *ngIf=\"field.data\" class=\"rx-tree-draggable-node\" cdkDrag [cdkDragData]=\"field.data\">\n                  <div (dblclick)=\"addField(field.data)\">\n                    <button\n                      type=\"button\"\n                      class=\"rx-button-unstyled d-icon-plus_circle\"\n                      (click)=\"addField(field.data)\"\n                    ></button>\n\n                    <span class=\"rx-tree-node-label ml-3\">{{ field.data.name }}</span>\n                  </div>\n                </div>\n              </ng-template>\n            </adapt-tree>\n          </div>\n\n          <ng-template #adaptTreeEmptyStateTemplate>\n            <div class=\"d-flex justify-content-center h-100 align-items-center mt-2\">\n              <adapt-empty-state class=\"w-100\" label=\"No fields found\" type=\"search\"></adapt-empty-state>\n            </div>\n          </ng-template>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"d-flex flex-column mh-100 {{ config.isReadOnly ? 'col' : 'col-8' }}\">\n      <div class=\"d-flex align-items-start justify-content-between\">\n        <h4 class=\"mt-2\">Selected fileds</h4>\n\n        <div *ngIf=\"selectedFields.length\" class=\"btn-group\">\n          <button adapt-button btn-type=\"tertiary\" type=\"button\" rx-id=\"expand-all-button\" (click)=\"toggleOpen(true)\">\n            {{ 'com.bmc.arsys.rx.client.common.expand-all.label' | translate }}\n          </button>\n\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"collapse-all-button\"\n            (click)=\"toggleOpen(false)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.collapse-all.label' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <div\n        id=\"selected-fields\"\n        class=\"designer-modal-accordion-wrapper\"\n        cdkDropList\n        (cdkDropListDropped)=\"onSelectedFieldsListDrop($event)\"\n      >\n        <adapt-accordion [multiselect]=\"true\">\n          <div\n            *ngFor=\"let field of selectedFields; let index = index; let first = first; let last = last\"\n            class=\"designer-modal-accordion-content\"\n            cdkDrag\n            cdkDragLockAxis=\"y\"\n            [cdkDragDisabled]=\"true\"\n          >\n            <adapt-accordion-tab\n              class=\"d-block\"\n              [isOpen]=\"field.isOpen\"\n              (open)=\"field.isOpen = true\"\n              (close)=\"field.isOpen = false\"\n            >\n              <div class=\"card-title-text w-100\">\n                <div class=\"designer-modal-card-title-content\">\n                  <div class=\"left-header-block pl-0\">\n                    <div class=\"rx-ellipsis\" [title]=\"fieldLabelsMap[field.data.fieldId]\" rx-id=\"card-title\">\n                      {{ fieldLabelsMap[field.data.fieldId] }}\n                    </div>\n                  </div>\n\n                  <div *ngIf=\"!config.isReadOnly\" class=\"right-header-block\">\n                    <div class=\"designer-modal-card-title-index-buttons\">\n                      <button\n                        class=\"d-icon-left-triangle_down rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"last\"\n                        (click)=\"$event.stopPropagation(); onMoveDown(field, index)\"\n                        rx-id=\"move-down-button\"\n                      ></button>\n\n                      <button\n                        class=\"d-icon-left-triangle_up rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"first\"\n                        (click)=\"$event.stopPropagation(); onMoveUp(field, index)\"\n                        rx-id=\"move-up-button\"\n                      ></button>\n                    </div>\n\n                    <button\n                      class=\"d-icon-left-cross_adapt p-1 pr-4 ml-3\"\n                      adapt-button\n                      size=\"small\"\n                      type=\"button\"\n                      (click)=\"onRemove(field)\"\n                      rx-id=\"remove-button\"\n                    >\n                      {{ 'com.bmc.arsys.rx.client.common.remove.label' | translate }}\n                    </button>\n                  </div>\n                </div>\n              </div>\n\n              <adapt-rx-textfield\n                class=\"text-aria-resize\"\n                label=\"Label\"\n                [(ngModel)]=\"field.labelText\"\n                (ngModelChange)=\"canSave = true\"\n              >\n              </adapt-rx-textfield>\n            </adapt-accordion-tab>\n          </div>\n        </adapt-accordion>\n      </div>\n\n      <div *ngIf=\"!selectedFields.length\" class=\"d-flex justify-content-center h-100 align-items-center mt-2\">\n        <adapt-empty-state class=\"w-100\" label=\"No fields selected\" type=\"config\"></adapt-empty-state>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    *ngIf=\"!config.isReadOnly\"\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"!canSave\"\n    (click)=\"onSave()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{\n      config.isReadOnly\n        ? ('com.bmc.arsys.rx.client.common.close.label' | translate)\n        : ('com.bmc.arsys.rx.client.common.cancel.label' | translate)\n    }}\n  </button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.designer-modal-body{height:645px;min-height:calc(100% - 61px)!important}.designer-modal-accordion-wrapper{display:flex;flex-direction:column;height:100%;overflow:auto;padding-top:10px}.designer-modal-accordion-content{position:relative}.designer-modal-accordion-content.cdk-drag-preview{z-index:1200!important}.designer-modal-drag-handle{cursor:move;position:absolute;top:0;left:0;height:46px;padding:14px 10px 14px 14px;z-index:1}.designer-modal-card-title-content{width:100%;display:flex}.designer-modal-card-title-content .left-header-block,.designer-modal-card-title-content .right-header-block{display:flex;align-items:center}.designer-modal-card-title-content .left-header-block{flex-grow:1;min-width:0;font-size:14px;padding-left:22px}.designer-modal-card-sub-title{color:#7c7f81;font-weight:normal}.designer-modal-card-title-index-buttons{display:flex;font-size:19px}.rx-card{overflow:auto}.rx-tree-draggable-node{cursor:pointer}.rx-tree-draggable-node.cdk-drag-preview{z-index:1200!important}.rx-tree-draggable-node.cdk-drag{opacity:1}.rx-tree-node-label{word-break:break-all}rx-form-builder{max-width:400px}\n"], components: [{ type: i1.AdaptTreeComponent, selector: "adapt-tree", inputs: ["value", "filter", "texts", "filterBtnClearText", "filterPlaceholder", "testID", "lazy", "lazyLoading", "trim", "wrap", "selectAllButton", "deselectAllButton", "treeScrollHeight", "adaptRadarDisableEventSending", "draggableScope", "droppableScope", "draggableNodes", "droppableNodes", "validateDrop"], outputs: ["onNodeDrop", "lazyLoad"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "id", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListAutoScrollDisabled", "cdkDropListOrientation", "cdkDropListLockAxis", "cdkDropListData", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i1.AdaptTreeNodeTemplateDirective, selector: "[adaptTreeNodeTemplate]", inputs: ["adaptTreeNodeTemplate"] }, { type: i8.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragDisabled", "cdkDragStartDelay", "cdkDragLockAxis", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragBoundary", "cdkDragRootElement", "cdkDragPreviewContainer", "cdkDragData", "cdkDragFreeDragPosition"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorEditorDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-association-record-field-selector-editor-dialog',
                    templateUrl: './association-record-field-selector-editor-dialog.component.html',
                    styleUrls: ['./association-record-field-selector-editor-dialog.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i2$1.RxStringService }, { type: i2$1.RxGuidService }, { type: i1.ActiveModalRef }, { type: i0.Injector }]; } });

class AssociationRecordFieldSelectorFormControlComponent extends ValueAccessor {
    constructor(rxModalService, renderer) {
        super();
        this.rxModalService = rxModalService;
        this.renderer = renderer;
        this.selectedFields = [];
    }
    focus() {
        this.renderer.selectRootElement(this.openModalButton.nativeElement, true).click();
    }
    openFieldSelector(fieldToEdit) {
        this.rxModalService
            .openModal({
            title: this.options.label,
            data: {
                fields: this.options.fields,
                selectedFields: this.value,
                fieldToEdit: fieldToEdit,
                isReadOnly: this.isDisabled
            },
            content: AssociationRecordFieldSelectorEditorDialogComponent
        })
            .then((fields) => {
            this.value = fields;
        })
            .catch(noop);
    }
    onSetValue() {
        this.updateSortedFieldList();
    }
    onWriteValue(value) {
        this.updateSortedFieldList();
    }
    removeField(guid) {
        this.value = this.value.filter((field) => field.guid !== guid);
    }
    editField(field) {
        this.openFieldSelector(field);
    }
    updateSortedFieldList() {
        this.selectedFields = sortBy(this.value, (field) => Number(field.data.index)).map((field) => (Object.assign(Object.assign({}, field), { label: this.options.fields.find((fieldDefinition) => fieldDefinition.id === Number(field.data.fieldId)).name })));
    }
}
AssociationRecordFieldSelectorFormControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorFormControlComponent, deps: [{ token: i1$6.RxModalService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
AssociationRecordFieldSelectorFormControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: AssociationRecordFieldSelectorFormControlComponent, selector: "rx-association-record-field-selector-form-control", inputs: { options: "options" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: AssociationRecordFieldSelectorFormControlComponent,
            multi: true
        }
    ], viewQueries: [{ propertyName: "openModalButton", first: true, predicate: ["openModalButton"], descendants: true, read: ElementRef, static: true }], usesInheritance: true, ngImport: i0, template: "<button\n  #openModalButton\n  adapt-button\n  type=\"button\"\n  class=\"px-0 py-0\"\n  btn-type=\"tertiary\"\n  (click)=\"openFieldSelector()\"\n  [disabled]=\"isDisabled\"\n>\n  <adapt-icon name=\"plus_circle\" class=\"mr-1\"></adapt-icon>\n  {{ options.label }}\n</button>\n\n<ul class=\"list-unstyled mb-0 mt-2\" *ngIf=\"selectedFields.length > 0\">\n  <li class=\"border px-2 py-1 mb-1 d-flex align-items-center\" *ngFor=\"let field of selectedFields\">\n    <strong class=\"mr-auto\">{{ field.label }}</strong>\n\n    <button\n      class=\"d-icon-left-pencil p-1\"\n      adapt-button\n      btn-type=\"tertiary\"\n      size=\"small\"\n      type=\"button\"\n      [disabled]=\"isDisabled\"\n      (click)=\"editField(field)\"\n    ></button>\n\n    <button\n      class=\"d-icon-left-cross_adapt p-1\"\n      adapt-button\n      btn-type=\"tertiary\"\n      size=\"small\"\n      type=\"button\"\n      [disabled]=\"isDisabled\"\n      (click)=\"removeField(field.guid)\"\n    ></button>\n  </li>\n</ul>\n", components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptIconComponent, selector: "adapt-icon", inputs: ["name", "classList", "description", "testID"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorFormControlComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-association-record-field-selector-form-control',
                    templateUrl: './association-record-field-selector-form-control.component.html',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: AssociationRecordFieldSelectorFormControlComponent,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i1$6.RxModalService }, { type: i0.Renderer2 }]; }, propDecorators: { options: [{
                type: Input
            }], openModalButton: [{
                type: ViewChild,
                args: ['openModalButton', { read: ElementRef, static: true }]
            }] } });

class AssociationRecordFieldSelectorEditorDialogModule {
}
AssociationRecordFieldSelectorEditorDialogModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorEditorDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AssociationRecordFieldSelectorEditorDialogModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorEditorDialogModule, declarations: [AssociationRecordFieldSelectorEditorDialogComponent], imports: [CommonModule,
        AdaptRxSearchModule,
        AdaptButtonModule,
        AdaptAccordionModule,
        FormsModule,
        AdaptRxTextfieldModule,
        DragDropModule,
        AdaptTreeModule,
        AdaptEmptyStateModule,
        TranslateModule], exports: [AssociationRecordFieldSelectorEditorDialogComponent] });
AssociationRecordFieldSelectorEditorDialogModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorEditorDialogModule, imports: [[
            CommonModule,
            AdaptRxSearchModule,
            AdaptButtonModule,
            AdaptAccordionModule,
            FormsModule,
            AdaptRxTextfieldModule,
            DragDropModule,
            AdaptTreeModule,
            AdaptEmptyStateModule,
            TranslateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorEditorDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [AssociationRecordFieldSelectorEditorDialogComponent],
                    exports: [AssociationRecordFieldSelectorEditorDialogComponent],
                    entryComponents: [AssociationRecordFieldSelectorEditorDialogComponent],
                    imports: [
                        CommonModule,
                        AdaptRxSearchModule,
                        AdaptButtonModule,
                        AdaptAccordionModule,
                        FormsModule,
                        AdaptRxTextfieldModule,
                        DragDropModule,
                        AdaptTreeModule,
                        AdaptEmptyStateModule,
                        TranslateModule
                    ]
                }]
        }] });

class AssociationRecordFieldSelectorFormControlModule {
}
AssociationRecordFieldSelectorFormControlModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorFormControlModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AssociationRecordFieldSelectorFormControlModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorFormControlModule, declarations: [AssociationRecordFieldSelectorFormControlComponent], imports: [CommonModule,
        FormsModule,
        AdaptButtonModule,
        AdaptIconModule,
        AssociationRecordFieldSelectorEditorDialogModule], exports: [AssociationRecordFieldSelectorFormControlComponent] });
AssociationRecordFieldSelectorFormControlModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorFormControlModule, imports: [[
            CommonModule,
            FormsModule,
            AdaptButtonModule,
            AdaptIconModule,
            AssociationRecordFieldSelectorEditorDialogModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRecordFieldSelectorFormControlModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [AssociationRecordFieldSelectorFormControlComponent],
                    exports: [AssociationRecordFieldSelectorFormControlComponent],
                    entryComponents: [AssociationRecordFieldSelectorFormControlComponent],
                    imports: [
                        CommonModule,
                        FormsModule,
                        AdaptButtonModule,
                        AdaptIconModule,
                        AssociationRecordFieldSelectorEditorDialogModule
                    ]
                }]
        }] });

class AssociationDesignHelperService {
    constructor(rxRecordDefinitionCacheService, rxAssociationDefinitionDataPageService, rxGuidService, rxDefinitionNameService) {
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.rxAssociationDefinitionDataPageService = rxAssociationDefinitionDataPageService;
        this.rxGuidService = rxGuidService;
        this.rxDefinitionNameService = rxDefinitionNameService;
    }
    getDropdownModeInspectorControls(recordDefinitionField, associationDefinitionFilters) {
        return [
            {
                name: 'fieldId',
                component: SelectFormControlComponent,
                options: {
                    label: 'Field to display',
                    options: recordDefinitionField
                        ? recordDefinitionField
                            .filter((associationDefinitionField) => [
                            RX_RECORD_DEFINITION.resourceTypes.character,
                            RX_RECORD_DEFINITION.resourceTypes.localizedCharacter
                        ].includes(associationDefinitionField.resourceType))
                            .map((associationDefinitionField) => ({
                            id: String(associationDefinitionField.id),
                            name: associationDefinitionField.name
                        }))
                        : [],
                    emptyOption: true,
                    required: true
                }
            },
            {
                name: 'filterByAssociation',
                component: SelectFormControlComponent,
                options: {
                    label: 'Filter by association',
                    options: associationDefinitionFilters
                        ? associationDefinitionFilters.map((associationDefinition) => ({
                            id: associationDefinition.name,
                            name: this.rxDefinitionNameService.getDisplayName(associationDefinition.name)
                        }))
                        : [],
                    emptyOption: true
                }
            }
        ];
    }
    getDisplayedFieldsControl(recordDefinitionFields) {
        return {
            name: 'displayedFields',
            component: AssociationRecordFieldSelectorFormControlComponent,
            options: {
                label: 'Show/Hide fields',
                fields: recordDefinitionFields,
                required: true
            }
        };
    }
    getRecordIdControl() {
        return {
            name: 'recordId',
            component: ExpressionInspectorControlComponent,
            options: {
                label: 'Record ID',
                isRequired: true
            }
        };
    }
    getUseDefaultRolesControl() {
        return {
            name: 'useDefaultRoles',
            component: SwitchFormControlComponent,
            options: {
                label: 'Use default roles'
            }
        };
    }
    getNodeABRoleControls() {
        return [
            {
                name: 'nodeARole',
                component: ExpressionInspectorControlComponent,
                options: {
                    label: 'First record role'
                }
            },
            {
                name: 'nodeBRole',
                component: ExpressionInspectorControlComponent,
                options: {
                    label: 'Second record role'
                }
            }
        ];
    }
    getViewModeInspectorControls() {
        return [
            {
                name: 'viewDefinitionNameForSelect',
                component: RxDefinitionPickerComponent,
                options: {
                    label: 'View for selecting associated records',
                    definitionType: RxDefinitionPickerType.View,
                    required: true
                }
            },
            {
                name: 'viewDefinitionNameForCreate',
                component: RxDefinitionPickerComponent,
                options: {
                    label: 'View for creating associated records',
                    definitionType: RxDefinitionPickerType.View
                }
            }
        ];
    }
    getInitialInspectorControls(expressionConfigurator) {
        return [
            {
                name: 'label',
                component: TextFormControlComponent,
                options: {
                    label: 'Display label'
                }
            },
            getDisabledFieldInspectorConfig(),
            ...getStandardPropsInspectorConfigs()
        ];
    }
    getInitialProperties() {
        return Object.assign(Object.assign({ associatedRecordNodeSide: '', associationDefinitionName: '', displayedFields: [], editingMode: RxAssociationEditingMode.Views, fieldId: null, filterByAssociation: '', label: null, nodeARole: '', nodeBRole: '', recordDefinition: '', recordDefinitionName: '', recordId: '', recordInstance: '', useDefaultRoles: true, viewDefinitionNameForCreate: '', viewDefinitionNameForSelect: '' }, RX_DISABLED_PROP_DEFAULT_VALUE), RX_STANDARD_PROPS_DEFAULT_VALUES);
    }
    getActionButtonDefinition(componentProperties, action, parentGuid) {
        return {
            type: RxViewComponentType.ActionButton,
            guid: this.rxGuidService.generate(),
            propertiesByName: {
                labelKey: action === RX_ASSOCIATION.actions.associate
                    ? 'com.bmc.arsys.rx.client.view-components.record-editor.association.button.associate.label'
                    : 'com.bmc.arsys.rx.client.view-components.record-editor.association.button.create-new.label',
                style: 'secondary',
                action
            },
            children: [
                {
                    guid: this.rxGuidService.generate(),
                    type: RxViewComponentType.Action,
                    propertiesByName: {
                        name: 'rxAvcAssociate',
                        associationViewComponent: `\${view.components.${parentGuid}.api}`,
                        viewDefinitionName: action === RX_ASSOCIATION.actions.associate
                            ? componentProperties.viewDefinitionNameForSelect
                            : componentProperties.viewDefinitionNameForCreate
                    }
                }
            ],
            insertIndex: action === RX_ASSOCIATION.actions.associate ? 0 : 1
        };
    }
    isCardinalityOne(componentProperties, associationDefinitions) {
        const associationDefinition = associationDefinitions.find((association) => association.name === componentProperties.associationDefinitionName);
        return Boolean(associationDefinition &&
            (associationDefinition.cardinality === RX_ASSOCIATION_DEFINITION.cardinality.oneToOne.value ||
                (associationDefinition.cardinality === RX_ASSOCIATION_DEFINITION.cardinality.oneToMany.value &&
                    componentProperties.associatedRecordNodeSide === RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA.value)));
    }
    getAvailableAssociations(firstRecordDefinitionName, secondRecordDefinitionName) {
        const getParametersForAssociation = {
            headers: { 'default-bundle-scope': '' },
            params: { firstRecordDefinitionName, secondRecordDefinitionName, requireDependent: true }
        };
        return this.rxAssociationDefinitionDataPageService
            .get(getParametersForAssociation)
            .pipe(map((response) => response.data));
    }
    getRecordDefinition(recordDefinitionToAssociateName) {
        return this.rxRecordDefinitionCacheService.getRecordDefinition(recordDefinitionToAssociateName);
    }
    getFieldsInChildComponentsWithNames(components, availableFields) {
        return components.reduce((acc, definition) => {
            const fieldDescriptor = availableFields.find((fieldDescriptorItem) => fieldDescriptorItem.id === Number(definition.data.fieldId));
            acc.push(Object.assign(Object.assign({}, definition), { data: Object.assign(Object.assign({}, definition.data), { name: fieldDescriptor ? fieldDescriptor.name : definition.data.label }) }));
            return acc;
        }, []);
    }
    cleanEditingModeDependentData(componentProperties) {
        if (componentProperties.editingMode === RxAssociationEditingMode.Dropdown) {
            componentProperties.viewDefinitionNameForSelect = null;
            componentProperties.viewDefinitionNameForCreate = null;
            componentProperties.displayedFields = [];
        }
        else {
            componentProperties.filterByAssociation = null;
            componentProperties.recordId = null;
            componentProperties.fieldId = null;
        }
    }
    getNodeSideOptions(associationDefinition) {
        return associationDefinition.nodeAId === associationDefinition.nodeBId
            ? [
                {
                    id: RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA.value,
                    name: associationDefinition.nodeAName || RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA.defaultName
                },
                {
                    id: RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value,
                    name: associationDefinition.nodeBName || RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.defaultName
                }
            ]
            : [];
    }
    resetRolesData(componentProperties) {
        componentProperties.useDefaultRoles = false;
        componentProperties.nodeARole = null;
        componentProperties.nodeBRole = null;
    }
    validate(sandbox, properties, associationDefinition, childComponents) {
        const validationIssues = [];
        if (!properties.recordDefinitionName) {
            validationIssues.push(sandbox.createError('Record definition to associate cannot be blank.', 'recordDefinitionName'));
        }
        if (properties.recordDefinitionName && !properties.associationDefinitionName) {
            validationIssues.push(sandbox.createError('Association to Use cannot be blank.', 'associationDefinitionName'));
        }
        if (properties.associationDefinitionName) {
            if (associationDefinition.nodeAId === associationDefinition.nodeBId && !properties.associatedRecordNodeSide) {
                validationIssues.push(sandbox.createError('Associated Record Node Side cannot be blank.', 'fieldId'));
            }
        }
        if (properties.editingMode === RxAssociationEditingMode.Views || !properties.editingMode) {
            if (properties.recordDefinitionName && childComponents.displayedFields.length === 0) {
                validationIssues.push(sandbox.createError('Preview Fields cannot be empty.', 'displayedFields'));
            }
            if (!properties.viewDefinitionNameForSelect) {
                validationIssues.push(sandbox.createError('View for selecting associated records cannot be blank.', 'viewDefinitionNameForSelect'));
            }
        }
        else if (properties.editingMode === RxAssociationEditingMode.Dropdown) {
            if (properties.filterByAssociation && !childComponents.recordId) {
                validationIssues.push(sandbox.createError('Record ID cannot be blank.', 'recordId'));
            }
            if (!properties.fieldId) {
                validationIssues.push(sandbox.createError('Field to display cannot be blank.', 'fieldId'));
            }
        }
        validationIssues.push(...validateStandardProps(properties));
        return validationIssues;
    }
}
AssociationDesignHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignHelperService, deps: [{ token: i1$5.RxRecordDefinitionCacheService }, { token: i2$4.RxAssociationDefinitionDataPageService }, { token: i2$1.RxGuidService }, { token: i1$1.RxDefinitionNameService }], target: i0.ɵɵFactoryTarget.Injectable });
AssociationDesignHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignHelperService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignHelperService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$5.RxRecordDefinitionCacheService }, { type: i2$4.RxAssociationDefinitionDataPageService }, { type: i2$1.RxGuidService }, { type: i1$1.RxDefinitionNameService }]; } });

class AssociationDesignModel extends ViewDesignerComponentModel {
    constructor(injector, sandbox) {
        super(injector, sandbox);
        this.injector = injector;
        this.sandbox = sandbox;
        this.rxAssociationDefinitionCacheService = this.injector.get(RxAssociationDefinitionCacheService);
        this.rxGuidService = this.injector.get(RxGuidService);
        this.rxDefinitionNameService = this.injector.get(RxDefinitionNameService);
        this.associationDesignHelperService = this.injector.get(AssociationDesignHelperService);
        this.updateInspector$ = new Subject();
        this.childComponents$ = this.sandbox.getChildComponentsTree();
        this.associationChildComponentsData$ = this.getChildComponentsData();
        this.associationDefinitions = [];
        this.associationDefinitionFilters = [];
        this.recordDefinitionFields = [];
        this.associatedRecordNodeSide = [];
        this.isManyToManyAssociation = false;
        this.editingMode$ = this.sandbox.getComponentPropertyValue('editingMode');
        this.label$ = this.sandbox.getComponentPropertyValue('label');
        // TODO: performance
        this.updateInspector$
            .pipe(distinctUntilChanged(isEqual), takeUntil(this.sandbox.destroyed$))
            .subscribe((inspector) => {
            this.sandbox.updateInspectorConfig(inspector);
        });
        const recordDefinitionName$ = sandbox.getComponentPropertyValue('recordDefinitionName');
        const recordDefinitionFields$ = recordDefinitionName$.pipe(switchMap((recordDefinitionName) => recordDefinitionName ? this.updateRecordDefinitionFields(recordDefinitionName) : of([])));
        this.displayedFields$ = combineLatest([
            this.sandbox.getChildComponents((component) => component.type === RX_ASSOCIATION.componentTypes.associatedRecordField),
            recordDefinitionFields$
        ]).pipe(map(([components, availableFields]) => this.associationDesignHelperService.getFieldsInChildComponentsWithNames(components, availableFields)));
        this.recordEditorGuid$ = this.sandbox.getParentComponentGuid(RxViewComponentType.RecordEditor).pipe(take(1));
        this.otherAssociationRecordEditorComponentGuids$ = this.recordEditorGuid$.pipe(map((guid) => this.sandbox.getComponentModel(guid)), switchMap((model) => model.associationComponentGuids$.pipe(map((guids) => guids.filter((guid) => guid !== this.sandbox.guid)))), shareReplay(1), takeUntil(this.sandbox.destroyed$));
        this.recordDefinitionNameFromHostRecordEditor$ = this.recordEditorGuid$.pipe(switchMap((recordEditorGuid) => {
            return this.sandbox.getComponentPropertyValue('recordDefinitionName', recordEditorGuid);
        }), shareReplay(1));
        this.recordDefinitionNameFromHostRecordEditor$
            .pipe(switchMap((recordDefinitionRecordEditorName) => recordDefinitionRecordEditorName
            ? combineLatest([this.sandbox.componentProperties$, this.associationChildComponentsData$]).pipe(switchMap(([componentProperties, associationChildComponentsData]) => {
                const updateParameters = recordDefinitionRecordEditorName
                    ? this.generateInitialUpdateParameters(componentProperties)
                    : [];
                const updateParameters$ = updateParameters.length > 0 ? combineLatest(updateParameters) : of(null);
                return updateParameters$.pipe(map(() => ({
                    componentProperties: Object.assign(Object.assign({}, associationChildComponentsData), componentProperties),
                    recordDefinitionRecordEditorName
                })));
            }), take(1))
            : of({
                componentProperties: null,
                recordDefinitionRecordEditorName: null
            })), withLatestFrom(this.recordEditorGuid$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([{ componentProperties, recordDefinitionRecordEditorName }, recordEditorGuid]) => {
            const initialProperties = this.associationDesignHelperService.getInitialProperties();
            const properties = Object.assign(Object.assign(Object.assign({}, initialProperties), componentProperties), { useDefaultRoles: Boolean((componentProperties === null || componentProperties === void 0 ? void 0 : componentProperties.useDefaultRoles) === 'true') });
            this.recordEditorGuid = recordEditorGuid;
            this.sandbox.updateComponentProperties(properties);
            this.updateInspector$.next(this.getInspectorConfig(properties, recordDefinitionRecordEditorName, recordEditorGuid));
        });
        const childComponentGuids$ = this.childComponents$.pipe(map((components) => components.map((component) => component.guid)));
        this.sandbox
            .getComponentPropertyValue('recordDefinitionName')
            .pipe(skip(1), withLatestFrom(childComponentGuids$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([recordDefinitionName, childComponentGuids]) => {
            this.sandbox.updateComponentProperties({
                recordDefinitionName,
                label: null,
                associationDefinitionName: null,
                associatedRecordNodeSide: null,
                editingMode: RxAssociationEditingMode.Views,
                viewDefinitionNameForSelect: null,
                viewDefinitionNameForCreate: null,
                fieldId: null,
                useDefaultRoles: false,
                nodeARole: null,
                nodeBRole: null,
                displayedFields: [],
                filterByAssociation: null,
                recordId: null
            });
            this.sandbox.removeComponents(childComponentGuids);
        });
        this.sandbox
            .getComponentPropertyValue('recordDefinitionName')
            .pipe(skip(1), concatMapTo(this.sandbox.componentProperties$), concatMap((props) => combineLatest([
            this.updateAssociationDefinitionsOptions(props.recordDefinitionName),
            this.updateRecordDefinitionFields(props.recordDefinitionName),
            this.updateAssociationDefinitionsFilterOptions(props.recordDefinitionName),
            this.updateAssociationNodeSideOptions(props.associationDefinitionName),
            this.updatePreviousDropdownFieldDefinition(props.recordDefinitionName, props.fieldId)
        ]).pipe(take(1), mapTo(props))), withLatestFrom(this.recordDefinitionNameFromHostRecordEditor$, this.recordEditorGuid$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([componentProps, recordDefinitionNameFromHostRecordEditor, recordEditorGuid]) => {
            this.updateInspector$.next(this.getInspectorConfig(componentProps, recordDefinitionNameFromHostRecordEditor, recordEditorGuid));
        });
        this.sandbox
            .getComponentPropertyValue('editingMode')
            .pipe(skip(1), withLatestFrom(childComponentGuids$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([editingMode, childComponentGuids]) => {
            this.sandbox.updateComponentProperties({
                editingMode,
                viewDefinitionNameForSelect: null,
                viewDefinitionNameForCreate: null,
                fieldId: null,
                useDefaultRoles: false,
                nodeARole: null,
                nodeBRole: null,
                displayedFields: [],
                filterByAssociation: null,
                recordId: null
            });
            this.sandbox.removeComponents(childComponentGuids);
        });
        this.sandbox.componentProperties$
            .pipe(skip(1), pairwise(), withLatestFrom(this.childComponents$), switchMap(([[previousProperties, properties], children]) => {
            const updatedProperties = Object.assign({}, properties);
            const updatedParametersStreams = [];
            switch (true) {
                case previousProperties.viewDefinitionNameForSelect !== properties.viewDefinitionNameForSelect:
                    this.updateChildActionButtonDefinition(properties, children, RX_ASSOCIATION.actions.associate);
                    break;
                case previousProperties.viewDefinitionNameForCreate !== properties.viewDefinitionNameForCreate:
                    this.updateChildActionButtonDefinition(properties, children, RX_ASSOCIATION.actions.createAndAssociate);
                    break;
                case previousProperties.filterByAssociation !== properties.filterByAssociation:
                case previousProperties.recordId !== properties.recordId:
                    const filterComponent = children.find((component) => component.type === RX_ASSOCIATION.componentTypes.associationFilter);
                    this.updateAssociationFilterComponent(properties, filterComponent);
                    break;
                case !isEqual(previousProperties.displayedFields, properties.displayedFields):
                    this.updateComponentRecordFields(properties.displayedFields, children);
                    break;
                case previousProperties.associationDefinitionName !== properties.associationDefinitionName:
                    updatedProperties.editingMode = RxAssociationEditingMode.Views;
                    this.associationDesignHelperService.cleanEditingModeDependentData(updatedProperties);
                    if (properties.associationDefinitionName) {
                        updatedParametersStreams.push(this.rxAssociationDefinitionCacheService
                            .getAssociationDefinition(properties.associationDefinitionName)
                            .pipe(map((associationDefinition) => {
                            updatedProperties.associatedRecordNodeSide =
                                associationDefinition.nodeAId === properties.recordDefinitionName
                                    ? RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA.value
                                    : RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value;
                            this.setIsManyToManyAssociation(associationDefinition);
                            this.sandbox.updateComponentProperties(updatedProperties);
                            if (this.isManyToManyAssociation) {
                                this.associationDesignHelperService.resetRolesData(updatedProperties);
                            }
                        })));
                    }
                    else {
                        this.isManyToManyAssociation = false;
                    }
                    updatedParametersStreams.push(this.updateAssociationNodeSideOptions(properties.associationDefinitionName));
                    break;
                case previousProperties.associatedRecordNodeSide !== properties.associatedRecordNodeSide:
                    updatedProperties.editingMode = RxAssociationEditingMode.Views;
                    this.associationDesignHelperService.cleanEditingModeDependentData(updatedProperties);
                    break;
                case previousProperties.useDefaultRoles !== properties.useDefaultRoles:
                    if (properties.useDefaultRoles === true) {
                        updatedProperties.nodeARole = null;
                        updatedProperties.nodeBRole = null;
                    }
                    break;
                case previousProperties.nodeARole !== properties.nodeARole ||
                    previousProperties.nodeBRole !== properties.nodeBRole:
                    if (isUndefined(properties.useDefaultRoles)) {
                        defaults(updatedProperties, {
                            nodeARole: null,
                            nodeBRole: null,
                            useDefaultRoles: false
                        });
                    }
                    else {
                        updatedProperties.useDefaultRoles = false;
                    }
                    break;
            }
            const updateParameters$ = updatedParametersStreams.length > 0 ? combineLatest(updatedParametersStreams) : of(null);
            return updateParameters$.pipe(map((parameters) => ({ parameters, componentProperties: updatedProperties })), withLatestFrom(this.recordDefinitionNameFromHostRecordEditor$, this.recordEditorGuid$));
        }), takeUntil(this.sandbox.destroyed$))
            .subscribe(([{ parameters, componentProperties }, recordDefinitionNameFromHostRecordEditor, recordEditorGuid]) => {
            const initialProperties = this.associationDesignHelperService.getInitialProperties();
            this.recordEditorGuid = recordEditorGuid;
            this.updateInspector$.next(this.getInspectorConfig(Object.assign(Object.assign({}, initialProperties), componentProperties), recordDefinitionNameFromHostRecordEditor, recordEditorGuid));
        });
        this.sandbox
            .getComponentPropertyValue('fieldId')
            .pipe(
        // transform initial value to null if it is undefined
        map((value) => (isNil(value) ? null : value)), distinctUntilChanged(), pairwise())
            .pipe(withLatestFrom(this.sandbox.componentProperties$), 
        // Check if editing mode is dropdown to prevent label reset after change fieldId to null.
        filter(([fieldIds, props]) => Boolean(props.editingMode === RxAssociationEditingMode.Dropdown)), switchMap(([[prevFieldId, fieldId], props]) => this.associationDesignHelperService.getRecordDefinition(props.recordDefinitionName).pipe(map((recordDefinition) => {
            var _a, _b;
            const prevFieldDefinitionName = (_a = recordDefinition.fieldDefinitions.find((field) => field.id === Number(prevFieldId))) === null || _a === void 0 ? void 0 : _a.name;
            const currentFieldDefinitionName = (_b = recordDefinition.fieldDefinitions.find((field) => field.id === Number(fieldId))) === null || _b === void 0 ? void 0 : _b.name;
            // If the label is changed by user it must not be updated after fieldId change.
            return !props.label || prevFieldDefinitionName === props.label ? currentFieldDefinitionName : props.label;
        }))), distinctUntilChanged(), takeUntil(this.sandbox.destroyed$))
            .subscribe((label) => {
            this.sandbox.updateComponentProperties({ label });
        });
        combineLatest([
            this.sandbox.componentProperties$,
            this.associationChildComponentsData$.pipe(distinctUntilChanged(isEqual))
        ])
            .pipe(switchMap(([componentProperties, childComponents]) => {
            const association$ = componentProperties.associationDefinitionName
                ? this.rxAssociationDefinitionCacheService.getAssociationDefinition(componentProperties.associationDefinitionName)
                : of({});
            return association$.pipe(map((associationDefinition) => {
                return this.associationDesignHelperService.validate(this.sandbox, componentProperties, associationDefinition, childComponents);
            }));
        }), takeUntil(this.sandbox.destroyed$))
            .subscribe((validationIssues) => {
            this.sandbox.setValidationIssues(validationIssues);
        });
        combineLatest([
            this.label$,
            this.sandbox
                .getComponentPropertyValue('associationDefinitionName')
                .pipe(map((associationDefinitionName) => associationDefinitionName ? this.rxDefinitionNameService.getDisplayName(associationDefinitionName) : null))
        ])
            .pipe(map(([label, definitionDisplayName]) => {
            let componentName = this.sandbox.descriptor.name;
            if (definitionDisplayName && label) {
                componentName += ` (${definitionDisplayName}: ${label})`;
            }
            else if (definitionDisplayName || label) {
                componentName += ` (${definitionDisplayName || label})`;
            }
            return componentName;
        }), distinctUntilChanged(), takeUntil(this.sandbox.destroyed$))
            .subscribe((componentName) => {
            this.sandbox.setSettablePropertiesDataDictionary(componentName, [
                {
                    label: 'Disabled',
                    expression: this.getExpressionForProperty('disabled')
                },
                {
                    label: 'Hidden',
                    expression: this.getExpressionForProperty('hidden')
                }
            ]);
        });
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({}, RX_AVAILABLE_ON_DEVICES_DEFAULT_VALUE), initialProperties);
    }
    getPropertiesByName(properties) {
        return omit(Object.assign(Object.assign({}, properties), { recordInstance: this.recordEditorGuid
                ? `\${view.components.${this.recordEditorGuid}.recordInstance}`
                : properties.recordInstance, recordDefinition: this.recordEditorGuid
                ? `\${view.components.${this.recordEditorGuid}.recordDefinition}`
                : properties.recordDefinition }), [
            'displayedFields',
            'filterByAssociation',
            'recordId',
            'viewDefinitionNameForSelect',
            'viewDefinitionNameForCreate'
        ]);
    }
    updateAssociationFilterComponent(componentProperties, filterComponent) {
        if (filterComponent) {
            this.sandbox.removeComponents([filterComponent.guid]);
        }
        if (componentProperties.filterByAssociation) {
            const filterNew = {
                guid: this.rxGuidService.generate(),
                type: RX_ASSOCIATION.componentTypes.associationFilter,
                propertiesByName: {
                    associationDefinitionName: componentProperties.filterByAssociation,
                    recordInstanceId: componentProperties.recordId
                }
            };
            this.sandbox.addComponent([filterNew]);
        }
    }
    updateChildActionButtonDefinition(properties, children, action) {
        const actionButtonComponent = children.find((component) => component.type === RxViewComponentType.ActionButton && component.data['action'] === action);
        const viewDefinitionNameToUpdate = action === RX_ASSOCIATION.actions.createAndAssociate
            ? properties.viewDefinitionNameForCreate
            : properties.viewDefinitionNameForSelect;
        if (actionButtonComponent) {
            this.sandbox.removeComponents([actionButtonComponent.guid]);
        }
        if (viewDefinitionNameToUpdate) {
            const button = this.associationDesignHelperService.getActionButtonDefinition(properties, action, this.sandbox['guid']);
            this.sandbox.addComponent([button]);
        }
    }
    updateComponentRecordFields(displayedFields, children) {
        const guids = children
            .filter((component) => component.type === RX_ASSOCIATION.componentTypes.associatedRecordField)
            .map((component) => component.guid);
        const recordFields = displayedFields.map((field) => ({
            type: RX_ASSOCIATION.componentTypes.associatedRecordField,
            guid: this.rxGuidService.generate(),
            propertiesByName: {
                fieldId: field.data.fieldId,
                label: field.data.label || '',
                index: field.data.index
            }
        }));
        if (guids.length > 0) {
            this.sandbox.removeComponents(guids);
        }
        this.sandbox.addComponent(recordFields);
    }
    getChildComponentsData() {
        return this.childComponents$.pipe(map((components) => {
            var _a, _b;
            const associationChildComponentsData = {};
            const associationFilters = components.filter((component) => component.type === RX_ASSOCIATION.componentTypes.associationFilter);
            associationChildComponentsData.displayedFields = components.filter((definition) => definition.type === RX_ASSOCIATION.componentTypes.associatedRecordField);
            if (associationFilters.length > 0) {
                associationChildComponentsData.recordId = (_a = associationFilters[0].data) === null || _a === void 0 ? void 0 : _a.recordInstanceId;
                associationChildComponentsData.filterByAssociation = (_b = associationFilters[0].data) === null || _b === void 0 ? void 0 : _b.associationDefinitionName;
            }
            const createAndAssociateView = this.getViewDefinitionNameForAssociation(components, RX_ASSOCIATION.actions.createAndAssociate);
            if (createAndAssociateView) {
                associationChildComponentsData.viewDefinitionNameForCreate = createAndAssociateView;
            }
            const associateView = this.getViewDefinitionNameForAssociation(components, RX_ASSOCIATION.actions.associate);
            if (associateView) {
                associationChildComponentsData.viewDefinitionNameForSelect = associateView;
            }
            return associationChildComponentsData;
        }));
    }
    generateInitialUpdateParameters(componentProperties) {
        const updateParameters = [];
        if (componentProperties.recordDefinitionName) {
            updateParameters.push(this.updateRecordDefinitionFields(componentProperties.recordDefinitionName));
            if (componentProperties.fieldId) {
                updateParameters.push(this.updatePreviousDropdownFieldDefinition(componentProperties.recordDefinitionName, componentProperties.fieldId));
            }
            updateParameters.push(this.updateAssociationDefinitionsOptions(componentProperties.recordDefinitionName));
        }
        if (componentProperties.associationDefinitionName) {
            updateParameters.push(this.updateAssociationDefinitionsFilterOptions(componentProperties.recordDefinitionName));
            updateParameters.push(this.rxAssociationDefinitionCacheService
                .getAssociationDefinition(componentProperties.associationDefinitionName)
                .pipe(map((associationDefinition) => this.setIsManyToManyAssociation(associationDefinition))));
        }
        if (componentProperties.associatedRecordNodeSide) {
            updateParameters.push(this.updateAssociationNodeSideOptions(componentProperties.associationDefinitionName));
        }
        return updateParameters;
    }
    updatePreviousDropdownFieldDefinition(recordDefinitionToAssociateName, fieldId) {
        return this.updateRecordDefinitionFields(recordDefinitionToAssociateName).pipe(map((fields) => {
            return (this.previousDropdownFieldDefinition = fields.find((field) => field.id === Number(fieldId)));
        }));
    }
    setIsManyToManyAssociation(associationDefinition) {
        if (associationDefinition) {
            this.isManyToManyAssociation =
                associationDefinition.cardinality === RX_ASSOCIATION_DEFINITION.cardinality.manyToMany.value;
        }
    }
    getViewDefinitionNameForAssociation(components, action) {
        const actionButton = components.find((definition) => { var _a; return ((_a = definition.data) === null || _a === void 0 ? void 0 : _a.action) === action; });
        return actionButton && actionButton.children ? this.getViewDefinitionNameFromActionButton(actionButton) : null;
    }
    getViewDefinitionNameFromActionButton(actionButton) {
        const actionComponent = actionButton.children.find((children) => children.type === RxViewComponentType.Action);
        return get(actionComponent, 'data.viewDefinitionName', null);
    }
    updateRecordDefinitionFields(recordDefinitionToAssociateName) {
        return (recordDefinitionToAssociateName
            ? this.associationDesignHelperService
                .getRecordDefinition(recordDefinitionToAssociateName)
                .pipe(map((recordDefinition) => recordDefinition.fieldDefinitions))
            : of([])).pipe(tap((fieldDefinitions) => (this.recordDefinitionFields = fieldDefinitions)));
    }
    updateAssociationNodeSideOptions(associationDefinitionName) {
        const associatedRecordNodeSideOptions$ = associationDefinitionName
            ? this.rxAssociationDefinitionCacheService
                .getAssociationDefinition(associationDefinitionName)
                .pipe(map((associationDefinition) => this.associationDesignHelperService.getNodeSideOptions(associationDefinition)))
            : of([]);
        return associatedRecordNodeSideOptions$.pipe(tap((associatedRecordNodeSideOptions) => (this.associatedRecordNodeSide = associatedRecordNodeSideOptions)));
    }
    updateAssociationDefinitionsOptions(recordDefinitionToAssociateName) {
        return this.recordDefinitionNameFromHostRecordEditor$.pipe(switchMap((associatedRecordName) => recordDefinitionToAssociateName && associatedRecordName
            ? this.associationDesignHelperService.getAvailableAssociations(recordDefinitionToAssociateName, associatedRecordName)
            : of([])), tap((associationDefinitionOptions) => (this.associationDefinitions = associationDefinitionOptions)));
    }
    updateAssociationDefinitionsFilterOptions(recordDefinitionToAssociateName) {
        return this.otherAssociationRecordEditorComponentGuids$.pipe(mergeMap((guids) => guids.length
            ? combineLatest(guids.map((guid) => this.sandbox.getComponentPropertyValue('recordDefinitionName', guid))).pipe(take(1))
            : of([])), switchMap((associatedRecordNames) => associatedRecordNames.length && recordDefinitionToAssociateName
            ? merge(...associatedRecordNames.map((associatedRecordName) => this.associationDesignHelperService.getAvailableAssociations(recordDefinitionToAssociateName, associatedRecordName)))
            : of([])), map((associationDefinitionFilters) => (this.associationDefinitionFilters = associationDefinitionFilters)));
    }
    getInspectorConfig(properties, recordDefinitionNameFromHostRecordEditor, recordEditorGuid) {
        const inspectorConfig = {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: []
                }
            ]
        };
        if (recordDefinitionNameFromHostRecordEditor) {
            const generalSectionControls = inspectorConfig.inspectorSectionConfigs[0].controls;
            generalSectionControls.push({
                name: 'recordDefinitionName',
                component: RxDefinitionPickerComponent,
                options: {
                    label: 'Record definition to associate',
                    definitionType: RxDefinitionPickerType.StandardDataRecord,
                    required: true
                }
            });
            if (properties.recordDefinitionName) {
                generalSectionControls.push({
                    name: 'associationDefinitionName',
                    component: SelectFormControlComponent,
                    options: {
                        label: 'Association to use',
                        options: this.associationDefinitions.map((associationDefinition) => ({
                            id: associationDefinition.name,
                            name: this.rxDefinitionNameService.getDisplayName(associationDefinition.name)
                        })),
                        emptyOption: true,
                        required: true
                    }
                });
            }
            if (properties.recordDefinitionName && this.associatedRecordNodeSide.length > 0) {
                generalSectionControls.push({
                    name: 'associatedRecordNodeSide',
                    component: SelectFormControlComponent,
                    options: {
                        label: 'Associated record node Side',
                        options: this.associatedRecordNodeSide,
                        required: true
                    }
                });
            }
            if (properties.recordDefinitionName &&
                this.associationDesignHelperService.isCardinalityOne(properties, this.associationDefinitions)) {
                generalSectionControls.push({
                    name: 'editingMode',
                    component: SelectFormControlComponent,
                    options: {
                        label: 'Association editing mode',
                        options: map$1(RxAssociationEditingMode, (id, name) => ({ id, name })),
                        required: true
                    }
                });
            }
            // View Mode
            if (!properties.editingMode || properties.editingMode === RxAssociationEditingMode.Views) {
                generalSectionControls.push(...this.associationDesignHelperService.getViewModeInspectorControls());
                if (this.isManyToManyAssociation && properties.associationDefinitionName) {
                    generalSectionControls.push(this.associationDesignHelperService.getUseDefaultRolesControl());
                    if (!properties.useDefaultRoles) {
                        generalSectionControls.push(...this.associationDesignHelperService.getNodeABRoleControls());
                    }
                }
                if (properties.recordDefinitionName) {
                    generalSectionControls.push(this.associationDesignHelperService.getDisplayedFieldsControl(this.recordDefinitionFields));
                }
            }
            // Dropdown Mode
            if (properties.editingMode === RxAssociationEditingMode.Dropdown) {
                generalSectionControls.push(...this.associationDesignHelperService.getDropdownModeInspectorControls(this.recordDefinitionFields, this.associationDefinitionFilters));
                if (properties.filterByAssociation) {
                    generalSectionControls.push(this.associationDesignHelperService.getRecordIdControl());
                }
            }
            generalSectionControls.push(...this.associationDesignHelperService.getInitialInspectorControls(this.expressionConfigurator));
        }
        else {
            inspectorConfig.inspectorSectionConfigs[0].controls = [
                {
                    component: ValidationFormControlComponent,
                    options: {
                        text: 'You must select a Record definition before editing field component.',
                        componentGuid: recordEditorGuid,
                        propertyName: 'recordDefinitionName'
                    }
                }
            ];
        }
        return inspectorConfig;
    }
}

class RxAssociationDesignContainerComponent {
}
RxAssociationDesignContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationDesignContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxAssociationDesignContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxAssociationDesignContainerComponent, selector: "rx-association-design-item-container", inputs: { outlet: "outlet", isReadOnly: "isReadOnly", layout: "layout" }, ngImport: i0, template: "<rx-canvas-item\n  *ngFor=\"let layout of outlet.columns[0].children\"\n  [interactive]=\"false\"\n  [layout]=\"layout\"\n  [isReadOnly]=\"isReadOnly\"\n  class=\"mr-1\"\n>\n</rx-canvas-item>\n", styles: [":host{display:flex}\n"], components: [{ type: i1$3.CanvasItemComponent, selector: "rx-canvas-item", inputs: ["layout", "interactive", "isReadOnly"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationDesignContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-association-design-item-container',
                    templateUrl: './association-design-container.component.html',
                    styleUrls: ['./association-design-container.component.scss']
                }]
        }], propDecorators: { outlet: [{
                type: Input
            }], isReadOnly: [{
                type: Input
            }], layout: [{
                type: Input
            }] } });

class RxAssociationDesignComponent {
    constructor() {
        this.hidePlaceholder = false;
        this.destroyed$ = new ReplaySubject(1);
        this.containerComponent = RxAssociationDesignContainerComponent;
    }
    ngOnInit() {
        this.model.displayedFields$.pipe(takeUntil(this.destroyed$)).subscribe((fields) => {
            this.hidePlaceholder = fields.length > 0;
        });
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
}
RxAssociationDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxAssociationDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxAssociationDesignComponent, selector: "rx-association-field-design", inputs: { model: "model" }, ngImport: i0, template: "<div [ngSwitch]=\"model.editingMode$ | async\">\n  <div *ngSwitchCase=\"'views'\" [attr.aria-label]=\"model.label$ | async\">\n    <label class=\"d-block form-control-label\">{{ model.label$ | async }}</label>\n\n    <div class=\"d-flex flex-wrap\">\n      <rx-canvas-outlet class=\"flex-grow-1\" [containerComponent]=\"containerComponent\"></rx-canvas-outlet>\n\n      <button\n        adapt-button\n        size=\"small\"\n        btn-type=\"tertiary\"\n        class=\"btn btn-link py-0 align-right\"\n        type=\"button\"\n        [hidden]=\"!hidePlaceholder\"\n      >\n        {{ 'com.bmc.arsys.rx.client.view-components.record-editor.association.button.clear-all.label' | translate }}\n      </button>\n    </div>\n\n    <adapt-empty-state\n      [hidden]=\"hidePlaceholder\"\n      type=\"objects\"\n      label=\"Add fields in the Properties panel.\"\n    ></adapt-empty-state>\n\n    <div class=\"form-group mt-2\" [hidden]=\"!hidePlaceholder\">\n      <div class=\"list-group\">\n        <div class=\"list-group-item\">\n          <div class=\"rx-record-preview-card w-100\">\n            <button\n              class=\"btn btn-link float-right d-icon-cross p-0\"\n              adapt-button\n              size=\"small\"\n              btn-type=\"tertiary\"\n              type=\"button\"\n            ></button>\n\n            <ul class=\"list-unstyled mb-0\">\n              <li class=\"rx-record-preview-card__field\" *ngFor=\"let field of model.displayedFields$ | async\">\n                <span class=\"rx-record-preview-card__label\" *ngIf=\"field.data.label\">{{ field.data.label }}</span>\n                <span *ngIf=\"field.data.label\">: </span>\n                <span class=\"rx-record-preview-card__value\">{{ field.data.name }}</span>\n              </li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <div *ngSwitchCase=\"'dropdown'\">\n    <div [attr.aria-label]=\"model.label$ | async\">\n      <adapt-rx-select [label]=\"model.label$ | async\" [disabled]=\"true\" ngModel></adapt-rx-select>\n    </div>\n  </div>\n</div>\n", components: [{ type: i1$3.CanvasOutletComponent, selector: "rx-canvas-outlet", inputs: ["name", "skipParentPredicate", "containerComponent", "dropListOrientation", "dropPredicate"], outputs: ["beforeViewComponentDrop"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }, { type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }], directives: [{ type: i3.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i3.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "async": i3.AsyncPipe, "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAssociationDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-association-field-design',
                    templateUrl: './association-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class AssociationDesignAdapterService {
    adaptDefinition(componentDefinition) {
        var _a, _b, _c, _d, _e;
        // If a view from old view designer gets opened we have to add a layout with
        // action button guids, so they can be rendered inside association view component.
        if (!componentDefinition.layout) {
            const actionButtonGuids = componentDefinition.componentDefinitions
                .filter((definition) => definition.type === RxViewComponentType.ActionButton)
                .map((definition) => definition.guid);
            componentDefinition.layout = JSON.stringify({
                outlets: [
                    {
                        name: RX_VIEW_DEFINITION.defaultOutletName,
                        columns: [
                            {
                                children: actionButtonGuids
                            }
                        ]
                    }
                ]
            });
        }
        const adaptedProperties = {
            editingMode: (_a = componentDefinition.propertiesByName.editingMode) !== null && _a !== void 0 ? _a : RxAssociationEditingMode.Views,
            nodeARole: (_b = componentDefinition.propertiesByName.nodeARole) !== null && _b !== void 0 ? _b : null,
            nodeBRole: (_c = componentDefinition.propertiesByName.nodeBRole) !== null && _c !== void 0 ? _c : null,
            styles: (_d = componentDefinition.propertiesByName.styles) !== null && _d !== void 0 ? _d : null,
            useDefaultRoles: (_e = componentDefinition.propertiesByName.useDefaultRoles) !== null && _e !== void 0 ? _e : false
        };
        Object.assign(componentDefinition.propertiesByName, adaptedProperties);
    }
}
AssociationDesignAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignAdapterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
AssociationDesignAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignAdapterService, decorators: [{
            type: Injectable
        }] });

class AssociationDesignModule {
    constructor(associationDesignAdapterService, rxDefinitionAdapterRegistryService) {
        rxDefinitionAdapterRegistryService.registerDesignAdapter(RxViewComponentType.Association, associationDesignAdapterService);
    }
}
AssociationDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignModule, deps: [{ token: AssociationDesignAdapterService }, { token: i1$1.RxDefinitionAdapterRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
AssociationDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignModule, declarations: [RxAssociationDesignComponent, RxAssociationDesignContainerComponent], imports: [CommonModule,
        AdaptButtonModule,
        TranslateModule,
        AssociationRecordFieldSelectorFormControlModule,
        AdaptRxSelectModule,
        FormsModule,
        AdaptEmptyStateModule,
        ViewDesignerCanvasModule] });
AssociationDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignModule, providers: [AssociationDesignHelperService, AssociationDesignAdapterService], imports: [[
            CommonModule,
            AdaptButtonModule,
            TranslateModule,
            AssociationRecordFieldSelectorFormControlModule,
            AdaptRxSelectModule,
            FormsModule,
            AdaptEmptyStateModule,
            ViewDesignerCanvasModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        AdaptButtonModule,
                        TranslateModule,
                        AssociationRecordFieldSelectorFormControlModule,
                        AdaptRxSelectModule,
                        FormsModule,
                        AdaptEmptyStateModule,
                        ViewDesignerCanvasModule
                    ],
                    declarations: [RxAssociationDesignComponent, RxAssociationDesignContainerComponent],
                    entryComponents: [RxAssociationDesignComponent],
                    providers: [AssociationDesignHelperService, AssociationDesignAdapterService]
                }]
        }], ctorParameters: function () { return [{ type: AssociationDesignAdapterService }, { type: i1$1.RxDefinitionAdapterRegistryService }]; } });

const RX_BASE_FIELD_PROPERTIES = [
    'api',
    'disabled',
    'recordDefinition',
    'recordInstance',
    'hidden',
    'inReadState',
    'value'
].map((propertyName) => {
    const result = {
        name: propertyName,
        enableExpressionEvaluation: true
    };
    if (['hidden', 'disabled'].includes(propertyName)) {
        result.type = ViewComponentPropertyType.Boolean;
    }
    return result;
});
RX_BASE_FIELD_PROPERTIES.push({
    name: 'label',
    localizable: true
}, {
    name: 'fieldId'
}, RX_AVAILABLE_ON_DEVICES_PROP_DESC);

const RX_FIELD_COMPONENTS = {
    stencilGroupName: 'Record editor inputs'
};

class AssociationExpressionConfigurator extends RxViewComponentExpressionConfigurator {
    constructor(injector, componentGuid, componentModel) {
        super(injector, componentGuid, componentModel);
        this.injector = injector;
        this.componentGuid = componentGuid;
        this.componentModel = componentModel;
        this.rxDefinitionNameService = this.injector.get(RxDefinitionNameService);
        this.configureForProperty({
            propertyPath: 'recordId',
            dataDictionary$: componentModel.recordEditorGuid$.pipe(concatMap((recordEditorGuid) => this.getCommonDataDictionary(this.getRecordEditorBranch(recordEditorGuid), recordEditorGuid)))
        });
    }
    getRecordEditorBranch(recordEditorGuid) {
        const associationsBranch$ = this.componentModel.otherAssociationRecordEditorComponentGuids$.pipe(switchMap((guids) => guids.length
            ? combineLatest(guids.map((guid) => this.componentModel.sandbox
                .getComponentPropertyValue('associationDefinitionName', guid)
                .pipe(map((associationDefinitionName) => ({
                label: this.rxDefinitionNameService.getDisplayName(associationDefinitionName),
                children: [
                    {
                        label: 'First associated record',
                        children: [
                            {
                                label: 'ID',
                                expression: `\${view.components.${guid}.firstAssociatedRecord.id}`
                            }
                        ]
                    }
                ]
            }))))).pipe(map((children) => ({
                label: 'Associations',
                children
            })))
            : of(null)));
        return this.getComponentCommonDataDictionary(recordEditorGuid).pipe(switchMap((recordEditorBranch) => associationsBranch$.pipe(map((associationsBranch) => associationsBranch
            ? Object.assign(Object.assign({}, recordEditorBranch), { children: [associationsBranch, ...recordEditorBranch.children] }) : recordEditorBranch))));
    }
}

class AssociationRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Association,
            isContainerComponent: true,
            designComponentModel: AssociationDesignModel,
            bundleId: RX_APPLICATION.platformBundleId,
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(RxAssociationDesignComponent),
            expressionConfigurator: AssociationExpressionConfigurator,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(RxAssociationComponent),
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            name: 'Association',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'arrow_schema',
            properties: RX_BASE_FIELD_PROPERTIES.concat({
                name: 'recordInstance',
                enableExpressionEvaluation: true
            }),
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ]
        }, {
            type: RX_ASSOCIATION.componentTypes.associationFilter,
            configPropertyName: 'associationFilter',
            properties: [
                {
                    name: 'associationDefinitionName'
                },
                {
                    name: 'recordInstanceId',
                    enableExpressionEvaluation: true
                }
            ],
            isDataComponent: true
        }, {
            type: RX_ASSOCIATION.componentTypes.associatedRecordField,
            configPropertyName: 'associatedRecordField',
            isDataComponent: true,
            properties: [
                {
                    name: 'label',
                    localizable: true
                }
            ]
        });
    }
}
AssociationRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
AssociationRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRegistrationModule, imports: [AssociationModule, AssociationDesignModule] });
AssociationRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRegistrationModule, imports: [[AssociationModule, AssociationDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AssociationRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [AssociationModule, AssociationDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class BaseRecordEditorFieldDesign extends ViewDesignerComponentModel {
    constructor(injector, sandbox) {
        super(injector, sandbox);
        this.injector = injector;
        this.sandbox = sandbox;
        this.rxRecordDefinitionCacheService = this.injector.get(RxRecordDefinitionCacheService);
        this.rxDefinitionNameService = this.injector.get(RxDefinitionNameService);
        this.rxFieldDefinitionService = this.injector.get(RxFieldDefinitionService);
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign(Object.assign({ fieldId: null, label: null, value: null }, RX_DISABLED_PROP_DEFAULT_VALUE), RX_STANDARD_PROPS_DEFAULT_VALUES), initialProperties);
    }
    rxInit() {
        this.pipeline();
    }
    pipeline() {
        this.parentGuid$ = this.sandbox.getParentComponentGuid(RxViewComponentType.RecordEditor).pipe(take(1));
        this.recordEditorMode$ = this.parentGuid$.pipe(switchMap((recordEditorGuid) => {
            return this.sandbox.getComponentPropertyValue('mode', recordEditorGuid);
        }));
        this.recordDefinitionName$ = this.parentGuid$.pipe(switchMap((recordEditorGuid) => {
            return this.sandbox.getComponentPropertyValue('recordDefinitionName', recordEditorGuid);
        }), shareReplay(1));
        this.recordDefinition$ = this.recordDefinitionName$.pipe(switchMap((recordDefinitionName) => {
            if (recordDefinitionName) {
                return this.rxRecordDefinitionCacheService
                    .getRecordDefinition(recordDefinitionName)
                    .pipe(catchError((error) => EMPTY));
            }
            else {
                return of(null);
            }
        }), distinctUntilChanged());
        this.selectedFieldDefinition$ = this.sandbox.getComponentPropertyValue('fieldId').pipe(switchMap((fieldId) => this.recordDefinition$.pipe(map((recordDefinition) => {
            if (recordDefinition && fieldId) {
                return (recordDefinition.fieldDefinitions.find((fieldDefinition) => fieldDefinition.id === Number(fieldId)) || null);
            }
            else {
                return null;
            }
        }))), shareReplay(1));
        this.isRequired$ = this.selectedFieldDefinition$.pipe(map((selectedFieldDefinition) => selectedFieldDefinition && selectedFieldDefinition.fieldOption === RX_RECORD_DEFINITION.fieldOptions.required));
        this.isSystemField$ = this.selectedFieldDefinition$.pipe(startWith(false), map((selectedFieldDefinition) => this.rxFieldDefinitionService.isSystemField(selectedFieldDefinition)));
        // set field label
        this.selectedFieldDefinition$
            .pipe(pairwise(), withLatestFrom(this.sandbox.componentProperties$), filter(([[oldField, newField], componentProperties]) => newField && ((oldField && oldField.name === componentProperties.label) || !componentProperties.label)), map(([[oldField, newField]]) => newField.name))
            .subscribe((label) => {
            this.sandbox.updateComponentProperties({ label });
        });
        this.availableFieldDefinitions$ = combineLatest([this.recordDefinition$, this.recordEditorMode$]).pipe(map(([recordDefinition, recordEditorMode]) => {
            if (recordDefinition && recordDefinition.fieldDefinitions) {
                return recordDefinition.fieldDefinitions
                    .filter((fieldDefinition) => includes(this.fieldResourceTypes, fieldDefinition.resourceType))
                    .filter((fieldDefinition) => {
                    const isSystemField = this.rxFieldDefinitionService.isSystemField(fieldDefinition);
                    return !isSystemField || (isSystemField && recordEditorMode === RecordEditorMode.Edit);
                });
            }
            else {
                return [];
            }
        }), shareReplay(1));
        this.label$ = this.sandbox.componentProperties$.pipe(map((componentProperties) => {
            return componentProperties && componentProperties.fieldId ? componentProperties.label : '<No field selected>';
        }));
        this.sandbox.componentProperties$
            .pipe(mergeMap((componentProperties) => this.validate(componentProperties)), distinctUntilChanged(isEqual))
            .subscribe((validationIssues) => {
            this.sandbox.setValidationIssues(validationIssues);
        });
        this.availableFieldDefinitions$
            .pipe(switchMap(() => this.getInspectorConfig()))
            .subscribe((inspectorConfig) => {
            this.sandbox.updateInspectorConfig(inspectorConfig);
        });
        this.sandbox.componentProperties$
            .pipe(switchMap(() => this.getBreadcrumb()), distinctUntilChanged())
            .subscribe((breadcrumb) => {
            this.sandbox.setBreadcrumbs(breadcrumb);
        });
        combineLatest([this.sandbox.getComponentPropertyValue('label'), this.selectedFieldDefinition$])
            .pipe(map(([label, fieldDefinition]) => label || (fieldDefinition ? `[${fieldDefinition.name}]` : `[${this.sandbox.descriptor.name}]`)), distinctUntilChanged())
            .subscribe((componentName) => {
            this.sandbox.setSettablePropertiesDataDictionary(componentName, this.getSettableProperties());
        });
    }
    getPropertiesByName(properties) {
        const result = Object.assign({}, properties);
        if (!result.styles) {
            delete result.styles;
        }
        return result;
    }
    validate(componentProperties) {
        const validationIssues = [];
        if (isEmpty(componentProperties.fieldId)) {
            validationIssues.push(this.sandbox.createError('Field name cannot be blank.', 'fieldId'));
        }
        validationIssues.push(...validateStandardProps(componentProperties));
        return of(validationIssues);
    }
    getBreadcrumb() {
        return of(null).pipe(withLatestFrom(this.sandbox.componentProperties$), map(([initial, componentProperties]) => componentProperties.label));
    }
    getInspectorConfig() {
        return of(null).pipe(withLatestFrom(this.availableFieldDefinitions$, this.recordDefinitionName$, this.parentGuid$, this.isSystemField$), map(([initial, recordFieldsSelectItems, recordDefinitionName, parentGuid, isSystemField]) => {
            return this.getBaseInspectorConfig(recordFieldsSelectItems, recordDefinitionName, parentGuid, isSystemField);
        }));
    }
    getSettableProperties() {
        const disabledPropDataDictionary = find(this.sandbox.descriptor.properties, { name: 'disabled' })
            ? [
                {
                    label: 'Disabled',
                    expression: `\${view.components.${this.sandbox.guid}.disabled}`
                }
            ]
            : [];
        const hiddenPropDataDictionary = find(this.sandbox.descriptor.properties, { name: 'disabled' })
            ? [
                {
                    label: 'Hidden',
                    expression: `\${view.components.${this.sandbox.guid}.hidden}`
                }
            ]
            : [];
        return [...disabledPropDataDictionary, ...hiddenPropDataDictionary];
    }
    getBaseInspectorFields(selectedFieldDefinitions, isSystemField) {
        return [].concat([
            {
                name: 'fieldId',
                component: SelectFormControlComponent,
                options: {
                    label: 'Field name',
                    required: true,
                    options: selectedFieldDefinitions.map((definition) => ({
                        name: definition.name,
                        id: String(definition.id)
                    }))
                }
            },
            {
                name: 'label',
                component: TextFormControlComponent,
                options: {
                    label: 'Display label'
                }
            }
        ], isSystemField
            ? []
            : [
                {
                    name: 'value',
                    component: ExpressionInspectorControlComponent,
                    options: {
                        label: 'Value'
                    }
                },
                getDisabledFieldInspectorConfig()
            ], getStandardPropsInspectorConfigs());
    }
    getBaseInspectorConfig(recordFieldsSelectItems, recordDefinitionName, parentGuid, isSystemField) {
        const displayName = this.rxDefinitionNameService.getDisplayName(recordDefinitionName || '');
        let controls;
        if (recordDefinitionName) {
            if (recordFieldsSelectItems.length) {
                controls = this.getBaseInspectorFields(recordFieldsSelectItems, isSystemField);
            }
            else {
                controls = [
                    {
                        component: ValidationFormControlComponent,
                        options: {
                            text: `${displayName} does not have fields that can be bound to this field type.`,
                            componentGuid: parentGuid,
                            propertyName: 'recordDefinitionName'
                        }
                    }
                ];
            }
        }
        else {
            controls = [
                {
                    component: ValidationFormControlComponent,
                    options: {
                        text: 'You must select a Record definition before editing field component.',
                        componentGuid: parentGuid,
                        propertyName: 'recordDefinitionName' // todo remove that hardcode
                    }
                }
            ];
        }
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls
                }
            ]
        };
    }
}

class AttachmentFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.attachment];
    }
    static getInitialProperties(initialProperties) {
        const result = BaseRecordEditorFieldDesign.getInitialProperties(initialProperties);
        delete result.value;
        return result;
    }
    getInspectorConfig() {
        return super.getInspectorConfig().pipe(map((inspectorConfig) => {
            inspectorConfig.inspectorSectionConfigs[0].controls =
                inspectorConfig.inspectorSectionConfigs[0].controls.filter((field) => field.name !== 'value');
            return inspectorConfig;
        }));
    }
}

class AttachmentFieldDesignComponent {
}
AttachmentFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
AttachmentFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: AttachmentFieldDesignComponent, selector: "rx-attachment-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-uploader\n  class=\"rx-pointer-events-none\"\n  [required]=\"model.isRequired$ | async\"\n  [ngModel]=\"[]\"\n  [disabled]=\"true\"\n  [label]=\"model.label$ | async\"\n></adapt-rx-uploader>\n", styles: ["adapt-rx-uploader ::ng-deep .adapt-rx-uploader__restrict{display:none}\n"], components: [{ type: i1.AdaptRxUploaderComponent, selector: "adapt-rx-uploader", inputs: ["uploadMode", "selectionMode", "enableFileDialog", "allowedTypes", "forbiddenTypes", "suppressParallel", "filesCount", "allowDuplicates", "showUploadFolderAlert", "visibleFiles", "reusable", "allowDeletion", "customErrors", "indeterminateFileLoader", "url", "deleteUrl", "droppableArea", "enableCustomDownload", "customDownload", "popoverAppendToBody", "showTypesRestriction", "showMinSizeRestriction", "showMaxSizeRestriction", "showFilesCountRestriction", "texts", "icons", "fileErrors", "enableDnD", "maxFileSize", "minFileSize", "chunkSize", "testID"], outputs: ["beforeFileDialogOpen", "afterFileDialogOpen", "beforeFilesAdded", "afterFilesAdded", "dropped", "dragOver", "startFileUploading", "processFileUploading", "endFileUploading", "errorFileUploading", "finishedFileUploading", "removedFileFromQueue", "deletedFile", "cancelUploading"] }], directives: [{ type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-attachment-field-design',
                    templateUrl: './attachment-field-design.component.html',
                    styleUrls: ['./attachment-field-design.component.scss']
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class AttachmentFieldDesignModule {
}
AttachmentFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AttachmentFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldDesignModule, declarations: [AttachmentFieldDesignComponent], imports: [CommonModule, FormsModule, AdaptRxUploaderModule] });
AttachmentFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldDesignModule, imports: [[CommonModule, FormsModule, AdaptRxUploaderModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, FormsModule, AdaptRxUploaderModule],
                    declarations: [AttachmentFieldDesignComponent],
                    entryComponents: [AttachmentFieldDesignComponent]
                }]
        }] });

// tslint:disable-next-line:directive-class-suffix
class BaseRecordEditorFieldComponent extends BaseViewComponent {
    constructor(injector) {
        super();
        this.injector = injector;
        this.isRequired = false;
        this.isDisabled = false;
        this.translateService = this.injector.get(TranslateService);
        this.api = {
            setProperty: this.setProperty.bind(this)
        };
        this.inReadState = false;
        this.isLoading = true;
        this.validationErrorMessage = null;
    }
    ngOnInit() {
        super.ngOnInit();
        this.notifyPropertyChanged('api', this.api);
        this.configReady$ = this.config.pipe(filter((config) => Boolean(config.api && config.recordDefinition)), takeUntil(this.destroyed$));
        this.recordInstance$ = this.configReady$.pipe(pluck('recordInstance'), distinctUntilChanged(), skip(1), takeUntil(this.destroyed$));
        this.recordInstance$.subscribe(this.subscribeOnConfigValueChange.bind(this));
        this.configReady$.pipe(take(1)).subscribe((config) => {
            this.isLoading = false;
            this.onConfigInitialized(config);
            this.onConfigUpdated(config);
        });
        this.configReady$
            .pipe(skip(1), filter((config) => Boolean(config.recordInstance)), takeUntil(this.destroyed$))
            .subscribe(this.onConfigUpdated.bind(this));
    }
    setFieldValue(value, options = {}) {
        if (!isEqual(value, this.formControl.value)) {
            if (options.markAsDirty !== false) {
                this.formControl.markAsDirty();
            }
            if (options.markAsTouched !== false) {
                this.formControl.markAsTouched();
            }
            this.formControl.setValue(value);
        }
    }
    getFieldValue() {
        var _a;
        return (_a = this.formControl) === null || _a === void 0 ? void 0 : _a.value;
    }
    getDisplayValue() {
        return this.getFieldValue();
    }
    onConfigInitialized(config) {
        this.fieldId = Number(config.fieldId);
        this.fieldDefinition = find(config.recordDefinition.fieldDefinitions, { id: this.fieldId });
        this.isRequired = this.fieldDefinition.fieldOption === RX_RECORD_DEFINITION.fieldOptions.required;
        this.recordEditorApi = config.api;
        this.formControl = this.recordEditorApi.getFieldControl(this.fieldId, this.guid, this.getFieldValidators(), config.associatedRecordPath);
        this.associatedRecordPath = config.associatedRecordPath;
        this.permissionType = this.recordEditorApi.getPermissionType(this.fieldId, this.associatedRecordPath);
        this.subscribeOnConfigValueChange();
        this.formControl.valueChanges.pipe(startWith(this.formControl.value), takeUntil(this.destroyed$)).subscribe(() => {
            this.checkValidation();
            this.updateValidationMessage();
        });
        this.isAlwaysDisabled =
            this.permissionType === RX_RECORD_DEFINITION.fieldPermissionTypes.view ||
                this.injector.get(RxFieldDefinitionService).isSystemField(this.fieldDefinition);
        this.isAlwaysHidden = !this.permissionType;
        const recordEditorMode = config.api.getRecordEditorMode();
        if (Number(config.fieldId) === RX_RECORD_DEFINITION.coreFieldIds.createdBy) {
            const submitterMode = this.injector
                .get(RxSystemConfigurationService)
                .getConfigurationSync('Submitter-Mode');
            this.isAlwaysDisabled =
                this.isAlwaysDisabled ||
                    (recordEditorMode === RecordEditorMode.Edit && submitterMode === RX_ADMINISTRATION.submitterModes.locked);
        }
    }
    onConfigUpdated(config) {
        const isDisabled = this.isAlwaysDisabled || Boolean(config.disabled);
        if (this.isDisabled !== isDisabled) {
            // In order to support accessibility for fields, "disabled" control status will be always "false" and will not
            // be synced with "isDisabled" component property. Field might not be focusable when control is disabled.
            this.isDisabled = isDisabled;
            if (!this.isDisabled) {
                // Update validation status of the control after change "isDisabled" status to false.
                this.formControl.updateValueAndValidity();
            }
            this.checkValidation();
        }
        this.isHidden = this.isAlwaysHidden || Boolean(config.hidden);
        this.label = isUndefined(config.label) ? this.fieldDefinition.name : config.label;
        this.inReadState = Boolean(config.inReadState);
    }
    getFieldValidators() {
        return [];
    }
    getRequiredFieldValidationError() {
        return this.translateService.instant('com.bmc.arsys.rx.client.view-components.validation.required.message');
    }
    getFieldInstanceProp(prop, fieldId = this.fieldId, associatedRecordPath = this.associatedRecordPath) {
        return this.recordEditorApi.getFieldInstanceProp(fieldId, prop, associatedRecordPath);
    }
    setFieldInstanceProp(prop, value, fieldId = this.fieldId, associatedRecordPath = this.associatedRecordPath) {
        this.recordEditorApi.setFieldInstanceProp(fieldId, prop, value, associatedRecordPath);
    }
    setProperty(propertyPath, propertyValue) {
        if (includes(['hidden', 'disabled'], propertyPath)) {
            this.notifyPropertyChanged(propertyPath, propertyValue);
        }
        else {
            return throwError(`Field property ${propertyPath} is not settable.`);
        }
    }
    subscribeOnConfigValueChange() {
        const value$ = this.configReady$.pipe(pluck('value'), 
        // Do not update field value if expression gets evaluated to undefined, e.g when:
        // - expression references a removed view component, or
        // - view component hasn't loaded the data yet
        filter((val) => !isUndefined(val)), distinctUntilChanged(), takeUntil(this.recordInstance$), takeUntil(this.destroyed$));
        value$.pipe(take(1)).subscribe((val) => {
            // Only update field with non empty value on first expression change.
            // At this time we don't know if null is a default value or it was evaluated from expression.
            if (!isNull(val)) {
                this.setFieldValue(val, { markAsTouched: false, markAsDirty: false });
            }
        });
        value$.pipe(skip(1)).subscribe((val) => this.setFieldValue(val));
    }
    checkValidation() {
        if (this.isDisabled && this.formControl.invalid) {
            // Remove errors to make control valid when "isDisabled" status is true.
            this.formControl.setErrors(null);
            this.updateValidationMessage();
        }
    }
    updateValidationMessage() {
        if (this.formControl.errors) {
            if (this.formControl.errors.required) {
                this.formControl.errors.required = this.getRequiredFieldValidationError();
            }
            this.validationErrorMessage = values(this.formControl.errors).join(', ');
        }
        else {
            this.validationErrorMessage = null;
        }
    }
}
BaseRecordEditorFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BaseRecordEditorFieldComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Directive });
BaseRecordEditorFieldComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.1.3", type: BaseRecordEditorFieldComponent, inputs: { config: "config" }, host: { properties: { "class.rx-field-required": "this.isRequired", "class.rx-field-disabled": "this.isDisabled" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BaseRecordEditorFieldComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.Injector }]; }, propDecorators: { isRequired: [{
                type: HostBinding,
                args: ['class.rx-field-required']
            }], isDisabled: [{
                type: HostBinding,
                args: ['class.rx-field-disabled']
            }], config: [{
                type: Input
            }] } });

const RX_ATTACHMENT_FIELD = {
    defaultOptions: {
        filesCount: 1,
        mode: UploaderMode.Manual,
        selectionMode: UploaderSelectionMode.File,
        chunkSize: '100KB',
        maxFileSize: '2GB' // Default is 20 MB
    }
};

class AttachmentFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector) {
        super(injector);
        // Uploader options
        this.filesCount = RX_ATTACHMENT_FIELD.defaultOptions.filesCount;
        this.mode = RX_ATTACHMENT_FIELD.defaultOptions.mode;
        this.selectionMode = RX_ATTACHMENT_FIELD.defaultOptions.selectionMode;
        this.chunkSize = RX_ATTACHMENT_FIELD.defaultOptions.chunkSize;
        this.maxFileSize = RX_ATTACHMENT_FIELD.defaultOptions.maxFileSize;
        this.showFiles = [];
        this.texts = {};
        this.readStateConfig = {
            fileName: null,
            downloadURL: null
        };
    }
    onConfigInitialized(config) {
        super.onConfigInitialized(config);
        this.attachmentFormControl = new FormControl(this.showFiles);
        this.maxFileSize = this.fieldDefinition.maxSize
            ? toString(this.fieldDefinition.maxSize)
            : RX_ATTACHMENT_FIELD.defaultOptions.maxFileSize;
        this.formControl.valueChanges
            .pipe(startWith(this.formControl.value), 
        // Update ADAPT component only when formControl value will be a file name string.
        // When value comes as a File, it means this file is already attached to ADAPT component.
        filter((value) => !(value instanceof File)), distinctUntilChanged((previous, next) => {
            return (previous === next &&
                // After uploading a file, adapt-rx-uploader component has to be updated with the URL to download the file.
                // This happens when the record editor updates the entire form with values from the saved record instance.
                // valueChange will emit the same value as before, but adapt-rx-uploader will not have a downloadURL yet.
                has(this.attachmentFormControl.value, '[0].downloadURL'));
        }), takeUntil(this.destroyed$))
            .subscribe(() => {
            this.attachmentFormControl.reset();
            this.addAttachedFileToAttachmentList(this.getFieldValue());
        });
        this.formControl.touched$.pipe(takeUntil(this.destroyed$)).subscribe((touched) => {
            touched ? this.attachmentFormControl.markAsTouched() : this.attachmentFormControl.markAsUntouched();
        });
    }
    addAttachedFileToAttachmentList(fileName) {
        if (fileName) {
            const downloadAttachmentUrl = this.recordEditorApi.getAttachmentDownloadUrl(this.fieldId);
            let attachment;
            attachment = {
                data: {
                    name: fileName
                },
                isUploading: true
            };
            if (downloadAttachmentUrl) {
                attachment.downloadURL = downloadAttachmentUrl;
            }
            this.showFiles = [attachment];
        }
        else {
            this.showFiles = [];
        }
        this.attachmentFormControl.setValue(this.showFiles);
    }
    onConfigUpdated(config) {
        super.onConfigUpdated(config);
        if (this.inReadState) {
            this.readStateConfig = {
                fileName: this.getDisplayValue(),
                downloadURL: this.recordEditorApi.getAttachmentDownloadUrl(this.fieldId)
            };
        }
    }
    removeAttachment(attachment) {
        if (attachment) {
            this.attachment = null;
        }
        this.addAttachedFileToAttachmentList();
        this.setFieldValue(this.attachment);
    }
    addAttachment(attachments) {
        const attachment = first$1(attachments);
        if (attachment) {
            this.attachment = attachment.data;
            this.setFieldValue(this.attachment);
        }
    }
    onBlur() {
        this.formControl.markAsTouched();
    }
}
AttachmentFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
AttachmentFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: AttachmentFieldComponent, selector: "rx-attachment-field", usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <ng-container *ngIf=\"inReadState; else editStateElementRef\">\n    <div *ngIf=\"getDisplayValue(); else emptyReadonlyField\" [attr.aria-label]=\"label\">\n      <label aria-hidden=\"true\">{{ label }}</label>\n\n      <adapt-downloader class=\"d-block\" *ngIf=\"getDisplayValue()\" [config]=\"readStateConfig\"></adapt-downloader>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-uploader\n    [ngClass]=\"{ 'attachment-disabled': isDisabled }\"\n    [reusable]=\"true\"\n    [label]=\"label\"\n    [readonly]=\"isDisabled\"\n    [required]=\"isRequired\"\n    [allowDeletion]=\"false\"\n    [uploadMode]=\"mode\"\n    [selectionMode]=\"selectionMode\"\n    [filesCount]=\"filesCount\"\n    [maxFileSize]=\"maxFileSize\"\n    [chunkSize]=\"chunkSize\"\n    [texts]=\"texts\"\n    (removedFileFromQueue)=\"removeAttachment($event)\"\n    (deletedFile)=\"removeAttachment($event)\"\n    (afterFilesAdded)=\"addAttachment($event)\"\n    [formControl]=\"attachmentFormControl\"\n    (onBlur)=\"onBlur()\"\n  >\n  </adapt-rx-uploader>\n</ng-template>\n\n<ng-template #emptyReadonlyField>\n  <rx-read-only-field [label]=\"label\" [value]=\"'-'\"></rx-read-only-field>\n</ng-template>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}::ng-deep .d-icon-exclamation_triangle{display:none}::ng-deep .adapt-rx-uploader__restrict{display:none}::ng-deep .upload-status{display:none}::ng-deep .adapt-uploader-item{border-top:0;height:37px!important;border-bottom:0}::ng-deep .adapt-rx-uploader-file-attach-btn__wrp{max-width:100%}::ng-deep .adapt-rx-uploader-attach-btn{overflow:hidden;text-overflow:ellipsis;max-width:100%}::ng-deep .adapt-uploader-file{margin-left:0;padding-bottom:10px;padding-left:0!important;flex:auto;height:100%;border-bottom:1px solid #f0f1f1}::ng-deep .adapt-uploader-status{margin-right:20px;width:15px;border-bottom:1px solid #f0f1f1}::ng-deep .attachment-disabled .adapt-uploader-list-files-zone__header{margin:0;display:none}::ng-deep .attachment-disabled .empty-state{display:none}::ng-deep .attachment-disabled .empty-state__container{margin:0;padding:0}::ng-deep .attachment-disabled .empty-state__label{margin-top:0;text-align:left}\n"], components: [{ type: i1.AdaptDownloaderComponent, selector: "adapt-downloader", inputs: ["config", "icons", "width"], outputs: ["downloadLinkPressed"] }, { type: i1.AdaptRxUploaderComponent, selector: "adapt-rx-uploader", inputs: ["uploadMode", "selectionMode", "enableFileDialog", "allowedTypes", "forbiddenTypes", "suppressParallel", "filesCount", "allowDuplicates", "showUploadFolderAlert", "visibleFiles", "reusable", "allowDeletion", "customErrors", "indeterminateFileLoader", "url", "deleteUrl", "droppableArea", "enableCustomDownload", "customDownload", "popoverAppendToBody", "showTypesRestriction", "showMinSizeRestriction", "showMaxSizeRestriction", "showFilesCountRestriction", "texts", "icons", "fileErrors", "enableDnD", "maxFileSize", "minFileSize", "chunkSize", "testID"], outputs: ["beforeFileDialogOpen", "afterFileDialogOpen", "beforeFilesAdded", "afterFilesAdded", "dropped", "dragOver", "startFileUploading", "processFileUploading", "endFileUploading", "errorFileUploading", "finishedFileUploading", "removedFileFromQueue", "deletedFile", "cancelUploading"] }, { type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-attachment-field',
                    styleUrls: ['./attachment-field.scss'],
                    templateUrl: './attachment-field.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });

function UploaderFactory() {
    return new UploaderService();
}
class AttachmentFieldModule {
}
AttachmentFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AttachmentFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldModule, declarations: [AttachmentFieldComponent], imports: [i1.AdaptRxUploaderModule, CommonModule,
        ReadOnlyFieldModule,
        ReactiveFormsModule,
        TranslateModule,
        AdaptDownloadModule] });
AttachmentFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldModule, imports: [[
            AdaptRxUploaderModule.forRoot({
                uploader: {
                    provide: 'UploaderService',
                    useFactory: UploaderFactory,
                    deps: []
                }
            }),
            CommonModule,
            ReadOnlyFieldModule,
            ReactiveFormsModule,
            TranslateModule,
            AdaptDownloadModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptRxUploaderModule.forRoot({
                            uploader: {
                                provide: 'UploaderService',
                                useFactory: UploaderFactory,
                                deps: []
                            }
                        }),
                        CommonModule,
                        ReadOnlyFieldModule,
                        ReactiveFormsModule,
                        TranslateModule,
                        AdaptDownloadModule
                    ],
                    declarations: [AttachmentFieldComponent],
                    entryComponents: [AttachmentFieldComponent]
                }]
        }] });

class AttachmentFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Attachment,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(AttachmentFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Attachment',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'paperclip',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(AttachmentFieldDesignComponent),
            designComponentModel: AttachmentFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
AttachmentFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
AttachmentFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldRegistrationModule, imports: [AttachmentFieldModule, AttachmentFieldDesignModule] });
AttachmentFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldRegistrationModule, imports: [[AttachmentFieldModule, AttachmentFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AttachmentFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [AttachmentFieldModule, AttachmentFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

var BooleanFieldEditingMode;
(function (BooleanFieldEditingMode) {
    BooleanFieldEditingMode["Checkbox"] = "checkbox";
    BooleanFieldEditingMode["Switch"] = "switch";
})(BooleanFieldEditingMode || (BooleanFieldEditingMode = {}));
var BooleanFieldModelValue;
(function (BooleanFieldModelValue) {
    BooleanFieldModelValue[BooleanFieldModelValue["True"] = 1] = "True";
    BooleanFieldModelValue[BooleanFieldModelValue["False"] = 0] = "False";
})(BooleanFieldModelValue || (BooleanFieldModelValue = {}));

class BooleanFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor(injector, sandbox) {
        super(injector, sandbox);
        this.injector = injector;
        this.sandbox = sandbox;
        this.componentProperties$ = this.sandbox.componentProperties$;
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.boolean];
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign(Object.assign({}, BaseRecordEditorFieldDesign.getInitialProperties()), { editingMode: BooleanFieldEditingMode.Switch }), initialProperties);
    }
    getInspectorConfig() {
        return super
            .getInspectorConfig()
            .pipe(map((inspectorConfig) => this.editInspectorConfig(inspectorConfig)));
    }
    editInspectorConfig(inspectorConfig) {
        const valueControlIndex = findIndex(inspectorConfig.inspectorSectionConfigs[0].controls, (item) => item.name === 'value');
        const editingModeControl = {
            name: 'editingMode',
            component: SelectFormControlComponent,
            options: {
                label: 'Editing mode',
                tooltip: new Tooltip('An optional Boolean field will always be displayed as a Switch.'),
                required: false,
                options: map$1(BooleanFieldEditingMode, (value, name) => ({
                    id: value,
                    name
                }))
            }
        };
        if (valueControlIndex !== -1) {
            inspectorConfig.inspectorSectionConfigs[0].controls.splice(valueControlIndex, 0, editingModeControl);
        }
        return inspectorConfig;
    }
}

class BooleanFieldDesignComponent {
    constructor() {
        this.shouldDisplayAsCheckbox = false;
        this.destroyed$ = new ReplaySubject(1);
    }
    ngOnInit() {
        const editingMode$ = this.model.componentProperties$.pipe(map((componentProperties) => componentProperties.editingMode || BooleanFieldEditingMode.Switch));
        combineLatest([editingMode$, this.model.isRequired$])
            .pipe(takeUntil(this.destroyed$))
            .subscribe(([editingMode, isRequired]) => {
            this.shouldDisplayAsCheckbox = isRequired && editingMode === BooleanFieldEditingMode.Checkbox;
        });
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
}
BooleanFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
BooleanFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: BooleanFieldDesignComponent, selector: "rx-boolean-field-design", inputs: { model: "model" }, ngImport: i0, template: "<ng-container *ngIf=\"!shouldDisplayAsCheckbox\">\n  <div>\n    <strong>\n      {{ model.label$ | async }}\n      <span *ngIf=\"model.isRequired$ | async\" class=\"form-control-required\">(required)</span>\n    </strong>\n  </div>\n  <adapt-rx-switch [(ngModel)]=\"booleanValue\" [disabled]=\"true\"></adapt-rx-switch>\n</ng-container>\n\n<ng-container *ngIf=\"shouldDisplayAsCheckbox\">\n  <adapt-rx-checkbox\n    [(ngModel)]=\"booleanValue\"\n    [label]=\"model.label$ | async\"\n    [required]=\"model.isRequired$ | async\"\n    [disabled]=\"true\"\n  >\n  </adapt-rx-checkbox>\n</ng-container>\n", components: [{ type: i1.AdaptRxSwitchComponent, selector: "adapt-rx-switch", inputs: ["value", "size", "isLabelBefore", "checked"] }, { type: i1.AdaptRxCheckboxComponent, selector: "adapt-rx-checkbox", inputs: ["value", "checked", "indeterminate"], outputs: ["indeterminateChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-boolean-field-design',
                    templateUrl: './boolean-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class BooleanFieldDesignModule {
}
BooleanFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BooleanFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldDesignModule, declarations: [BooleanFieldDesignComponent], imports: [CommonModule, FormsModule, AdaptRxSwitchModule, AdaptRxCheckboxModule], exports: [BooleanFieldDesignComponent] });
BooleanFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldDesignModule, imports: [[CommonModule, FormsModule, AdaptRxSwitchModule, AdaptRxCheckboxModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, FormsModule, AdaptRxSwitchModule, AdaptRxCheckboxModule],
                    declarations: [BooleanFieldDesignComponent],
                    exports: [BooleanFieldDesignComponent],
                    entryComponents: [BooleanFieldDesignComponent]
                }]
        }] });

class BooleanFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector, rxBooleanPipe) {
        super(injector);
        this.rxBooleanPipe = rxBooleanPipe;
    }
    get booleanValue() {
        const value = this.getFieldValue();
        return isNull(value) ? null : Boolean(value);
    }
    set booleanValue(value) {
        if (isNull(value)) {
            this.setFieldValue(null);
        }
        else {
            this.setFieldValue(Number(value));
        }
    }
    getDisplayValue() {
        const displayValue = super.getDisplayValue();
        if (!isNil(displayValue)) {
            return this.rxBooleanPipe.transform(displayValue);
        }
        else {
            return '-';
        }
    }
    onConfigInitialized(config) {
        super.onConfigInitialized(config);
        this.editingMode = config.editingMode;
    }
    onConfigUpdated(config) {
        super.onConfigUpdated(config);
        // Set 0 as a default value for checkbox, e.g. scenario in the create record editor mode
        if (this.shouldDisplayAsCheckbox && this.getFieldValue() === null) {
            this.setFieldValue(BooleanFieldModelValue.False, { markAsDirty: false, markAsTouched: false });
        }
    }
    ngAfterViewInit() {
        this.formControl.touched$
            .pipe(takeUntil(this.destroyed$))
            .subscribe((touched) => { var _a, _b; return touched ? (_a = this.ngModel) === null || _a === void 0 ? void 0 : _a.control.markAsTouched() : (_b = this.ngModel) === null || _b === void 0 ? void 0 : _b.control.markAsUntouched(); });
    }
    get shouldDisplayAsCheckbox() {
        return this.editingMode === BooleanFieldEditingMode.Checkbox && this.isRequired;
    }
    onBlur() {
        this.formControl.markAsTouched();
    }
}
BooleanFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldComponent, deps: [{ token: i0.Injector }, { token: i1$1.RxBooleanPipe }], target: i0.ɵɵFactoryTarget.Component });
BooleanFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: BooleanFieldComponent, selector: "rx-boolean-field", viewQueries: [{ propertyName: "ngModel", first: true, predicate: ["booleanComponent"], descendants: true, read: NgModel }], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <rx-boolean\n    #booleanComponent\n    [hidden]=\"isHidden\"\n    [label]=\"label\"\n    [isDisabled]=\"isDisabled\"\n    [required]=\"isRequired\"\n    [shouldDisplayAsCheckbox]=\"shouldDisplayAsCheckbox\"\n    [(ngModel)]=\"booleanValue\"\n    (rxBlur)=\"onBlur()\"\n  >\n  </rx-boolean>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i2$5.RxBooleanComponent, selector: "rx-boolean", inputs: ["shouldDisplayAsCheckbox", "required", "isDisabled", "label", "tooltip"], outputs: ["rxBlur"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-boolean-field',
                    templateUrl: './boolean-field.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$1.RxBooleanPipe }]; }, propDecorators: { ngModel: [{
                type: ViewChild,
                args: ['booleanComponent', { read: NgModel }]
            }] } });

class BooleanFieldModule {
}
BooleanFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BooleanFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldModule, declarations: [BooleanFieldComponent], imports: [CommonModule,
        AdaptRxFormControlModule,
        ReadOnlyFieldModule,
        AdaptButtonModule,
        AdaptRxCheckboxModule,
        TranslateModule,
        ReactiveFormsModule,
        FormsModule,
        RxBooleanModule] });
BooleanFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldModule, imports: [[
            CommonModule,
            AdaptRxFormControlModule,
            ReadOnlyFieldModule,
            AdaptButtonModule,
            AdaptRxCheckboxModule,
            TranslateModule,
            ReactiveFormsModule,
            FormsModule,
            RxBooleanModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        AdaptRxFormControlModule,
                        ReadOnlyFieldModule,
                        AdaptButtonModule,
                        AdaptRxCheckboxModule,
                        TranslateModule,
                        ReactiveFormsModule,
                        FormsModule,
                        RxBooleanModule
                    ],
                    declarations: [BooleanFieldComponent],
                    entryComponents: [BooleanFieldComponent]
                }]
        }] });

class BooleanFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Boolean,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(BooleanFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Boolean',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'switcher_check',
            designComponentModel: BooleanFieldDesignModel,
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(BooleanFieldDesignComponent),
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
BooleanFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
BooleanFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldRegistrationModule, imports: [BooleanFieldModule, BooleanFieldDesignModule] });
BooleanFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldRegistrationModule, imports: [[BooleanFieldModule, BooleanFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: BooleanFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [BooleanFieldModule, BooleanFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class DateFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.dateOnly];
    }
}

class DateFieldDesignComponent {
}
DateFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
DateFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: DateFieldDesignComponent, selector: "rx-date-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-datetime\n  class=\"rx-pointer-events-none\"\n  [required]=\"model.isRequired$ | async\"\n  [(ngModel)]=\"dateValue\"\n  [disabled]=\"true\"\n  [label]=\"model.label$ | async\"\n></adapt-rx-datetime>\n", components: [{ type: i1.AdaptRxDatetimeComponent, selector: "adapt-rx-datetime", inputs: ["placeholder", "inline", "placement", "appendToBody", "inlineLight", "inlineCompact", "dayFilter", "disableWizard", "mode", "hasSeconds", "use12HoursTime", "firstDayOfWeek", "initialDatetime", "defaultDatetime", "disabledStyleForReadonlyState", "popupClass", "texts", "inputFormat"], outputs: ["onPopupOpenChange", "onDatetimeChange"] }], directives: [{ type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-date-field-design',
                    templateUrl: './date-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class DateFieldDesignModule {
}
DateFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DateFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldDesignModule, declarations: [DateFieldDesignComponent], imports: [AdaptRxDatetimeModule, CommonModule, FormsModule] });
DateFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldDesignModule, imports: [[AdaptRxDatetimeModule, CommonModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [AdaptRxDatetimeModule, CommonModule, FormsModule],
                    declarations: [DateFieldDesignComponent],
                    entryComponents: [DateFieldDesignComponent]
                }]
        }] });

class DateAdapter extends AdaptRxDatetimeAdapter {
    constructor() {
        super(...arguments);
        this.storeDateFormat = 'YYYY-MM-DD'; // AR server only accepts this format for Date.
    }
    fromModel(dateString) {
        let adaptedValue = null;
        const date = moment(dateString);
        if (date && date.isValid()) {
            adaptedValue = {
                year: date.year(),
                month: date.month(),
                date: date.date(),
                hours: date.hours(),
                minutes: date.minutes(),
                seconds: date.seconds()
            };
        }
        return adaptedValue;
    }
    toModel(date) {
        return date
            ? date.parseError
                ? moment.invalid().toString()
                : moment([date.year || 0, date.month || 0, date.date || 0]).format(this.storeDateFormat)
            : null;
    }
}
DateAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
DateAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateAdapter, decorators: [{
            type: Injectable
        }] });

class DateFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector, datePipe) {
        super(injector);
        this.datePipe = datePipe;
    }
    getDisplayValue() {
        const displayValue = super.getDisplayValue();
        if (displayValue) {
            return this.datePipe.transform(displayValue, 'mediumDate');
        }
    }
    getFieldValidators() {
        const validatorFn = (control) => {
            const date = control.value ? moment(control.value) : null;
            return control.value && date && !date.isValid()
                ? { rxDatetimeFormat: { mode: RxDatetimePickerMode.Date } }
                : null;
        };
        return [validatorFn];
    }
}
DateFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldComponent, deps: [{ token: i0.Injector }, { token: i3.DatePipe }], target: i0.ɵɵFactoryTarget.Component });
DateFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: DateFieldComponent, selector: "rx-date-field", providers: [{ provide: AdaptRxDatetimeAdapter, useClass: DateAdapter }], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-datetime\n    [label]=\"label\"\n    [required]=\"isRequired\"\n    [formControl]=\"formControl\"\n    [readonly]=\"isDisabled\"\n    [disabledStyleForReadonlyState]=\"true\"\n  ></adapt-rx-datetime>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxDatetimeComponent, selector: "adapt-rx-datetime", inputs: ["placeholder", "inline", "placement", "appendToBody", "inlineLight", "inlineCompact", "dayFilter", "disableWizard", "mode", "hasSeconds", "use12HoursTime", "firstDayOfWeek", "initialDatetime", "defaultDatetime", "disabledStyleForReadonlyState", "popupClass", "texts", "inputFormat"], outputs: ["onPopupOpenChange", "onDatetimeChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-date-field',
                    templateUrl: './date-field.component.html',
                    providers: [{ provide: AdaptRxDatetimeAdapter, useClass: DateAdapter }]
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i3.DatePipe }]; } });

class DateFieldModule {
}
DateFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DateFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldModule, declarations: [DateFieldComponent], imports: [AdaptRxDatetimeModule,
        CommonModule,
        FormsModule,
        ReactiveFormsModule,
        ReadOnlyFieldModule,
        TranslateModule] });
DateFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldModule, providers: [DatePipe], imports: [[
            AdaptRxDatetimeModule,
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            ReadOnlyFieldModule,
            TranslateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptRxDatetimeModule,
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        ReadOnlyFieldModule,
                        TranslateModule
                    ],
                    declarations: [DateFieldComponent],
                    providers: [DatePipe],
                    entryComponents: [DateFieldComponent]
                }]
        }] });

class DateFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Date,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(DateFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Date',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'calendar',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(DateFieldDesignComponent),
            designComponentModel: DateFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
DateFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
DateFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldRegistrationModule, imports: [DateFieldModule, DateFieldDesignModule] });
DateFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldRegistrationModule, imports: [[DateFieldModule, DateFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [DateFieldModule, DateFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class DateTimeFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.dateTime];
    }
}

class DateTimeFieldDesignComponent {
    constructor() {
        this.pickerMode = RxDatetimePickerMode.DateTime;
    }
}
DateTimeFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
DateTimeFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: DateTimeFieldDesignComponent, selector: "rx-date-time-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-datetime\n  class=\"rx-pointer-events-none\"\n  [required]=\"model.isRequired$ | async\"\n  [(ngModel)]=\"dateTimeValue\"\n  [disabled]=\"true\"\n  [mode]=\"pickerMode\"\n  [label]=\"model.label$ | async\"\n>\n</adapt-rx-datetime>\n", components: [{ type: i1.AdaptRxDatetimeComponent, selector: "adapt-rx-datetime", inputs: ["placeholder", "inline", "placement", "appendToBody", "inlineLight", "inlineCompact", "dayFilter", "disableWizard", "mode", "hasSeconds", "use12HoursTime", "firstDayOfWeek", "initialDatetime", "defaultDatetime", "disabledStyleForReadonlyState", "popupClass", "texts", "inputFormat"], outputs: ["onPopupOpenChange", "onDatetimeChange"] }], directives: [{ type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-date-time-field-design',
                    templateUrl: './date-time-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class DateTimeFieldDesignModule {
}
DateTimeFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DateTimeFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldDesignModule, declarations: [DateTimeFieldDesignComponent], imports: [AdaptRxDatetimeModule, CommonModule, FormsModule] });
DateTimeFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldDesignModule, imports: [[AdaptRxDatetimeModule, CommonModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [AdaptRxDatetimeModule, CommonModule, FormsModule],
                    declarations: [DateTimeFieldDesignComponent],
                    entryComponents: [DateTimeFieldDesignComponent]
                }]
        }] });

class DateTimeAdapter extends AdaptRxDatetimeAdapter {
    fromModel(dateString) {
        let adaptedValue = null;
        const date = moment(dateString);
        if (date && date.isValid()) {
            adaptedValue = {
                year: date.year(),
                month: date.month(),
                date: date.date(),
                hours: date.hours(),
                minutes: date.minutes(),
                seconds: date.seconds()
            };
        }
        return adaptedValue;
    }
    toModel(date) {
        return date
            ? date.parseError
                ? moment.invalid().toString()
                : moment([
                    date.year || 0,
                    date.month || 0,
                    date.date || 0,
                    date.hours || 0,
                    date.minutes || 0,
                    date.seconds || 0
                ]).toISOString()
            : null;
    }
}
DateTimeAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
DateTimeAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeAdapter, decorators: [{
            type: Injectable
        }] });

class DateTimeFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector, datePipe) {
        super(injector);
        this.datePipe = datePipe;
        this.pickerMode = RxDatetimePickerMode.DateTime;
    }
    getDisplayValue() {
        const displayValue = super.getDisplayValue();
        if (displayValue) {
            return this.datePipe.transform(displayValue, 'medium');
        }
    }
    getFieldValidators() {
        const validatorFn = (control) => {
            const date = control.value ? moment(control.value) : null;
            return control.value && date && !date.isValid()
                ? { rxDatetimeFormat: { mode: this.pickerMode, hasSeconds: true } }
                : null;
        };
        return [validatorFn];
    }
}
DateTimeFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldComponent, deps: [{ token: i0.Injector }, { token: i3.DatePipe }], target: i0.ɵɵFactoryTarget.Component });
DateTimeFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: DateTimeFieldComponent, selector: "rx-date-time-field", providers: [{ provide: AdaptRxDatetimeAdapter, useClass: DateTimeAdapter }], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-datetime\n    [label]=\"label\"\n    [required]=\"isRequired\"\n    [formControl]=\"formControl\"\n    [readonly]=\"isDisabled\"\n    [disabledStyleForReadonlyState]=\"true\"\n    [mode]=\"pickerMode\"\n    hasSeconds=\"true\"\n  ></adapt-rx-datetime>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxDatetimeComponent, selector: "adapt-rx-datetime", inputs: ["placeholder", "inline", "placement", "appendToBody", "inlineLight", "inlineCompact", "dayFilter", "disableWizard", "mode", "hasSeconds", "use12HoursTime", "firstDayOfWeek", "initialDatetime", "defaultDatetime", "disabledStyleForReadonlyState", "popupClass", "texts", "inputFormat"], outputs: ["onPopupOpenChange", "onDatetimeChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-date-time-field',
                    templateUrl: './date-time-field.component.html',
                    providers: [{ provide: AdaptRxDatetimeAdapter, useClass: DateTimeAdapter }]
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i3.DatePipe }]; } });

class DateTimeFieldModule {
}
DateTimeFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DateTimeFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldModule, declarations: [DateTimeFieldComponent], imports: [AdaptRxDatetimeModule,
        CommonModule,
        FormsModule,
        ReactiveFormsModule,
        ReadOnlyFieldModule,
        TranslateModule] });
DateTimeFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldModule, providers: [DatePipe], imports: [[
            AdaptRxDatetimeModule,
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            ReadOnlyFieldModule,
            TranslateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptRxDatetimeModule,
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        ReadOnlyFieldModule,
                        TranslateModule
                    ],
                    declarations: [DateTimeFieldComponent],
                    providers: [DatePipe],
                    entryComponents: [DateTimeFieldComponent]
                }]
        }] });

class DateTimeFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.DateTime,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(DateTimeFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Date/Time',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'calendar_clock_o',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(DateTimeFieldDesignComponent),
            designComponentModel: DateTimeFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
DateTimeFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
DateTimeFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldRegistrationModule, imports: [DateTimeFieldModule, DateTimeFieldDesignModule] });
DateTimeFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldRegistrationModule, imports: [[DateTimeFieldModule, DateTimeFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DateTimeFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [DateTimeFieldModule, DateTimeFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class DecimalFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.decimal, RX_RECORD_DEFINITION.resourceTypes.real];
    }
}

class DecimalFieldDesignComponent {
}
DecimalFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
DecimalFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: DecimalFieldDesignComponent, selector: "rx-decimal-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-textfield\n  class=\"rx-pointer-events-none\"\n  [required]=\"model.isRequired$ | async\"\n  [label]=\"model.label$ | async\"\n  [disabled]=\"true\"\n  ngModel\n></adapt-rx-textfield>\n", components: [{ type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-decimal-field-design',
                    templateUrl: './decimal-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class DecimalFieldDesignModule {
}
DecimalFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DecimalFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldDesignModule, declarations: [DecimalFieldDesignComponent], imports: [CommonModule, AdaptRxTextfieldModule, FormsModule] });
DecimalFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldDesignModule, imports: [[CommonModule, AdaptRxTextfieldModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptRxTextfieldModule, FormsModule],
                    declarations: [DecimalFieldDesignComponent],
                    entryComponents: [DecimalFieldDesignComponent]
                }]
        }] });

class IntegerFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector) {
        super(injector);
        this.hasFocus = false;
        this.decimalPipe = injector.get(DecimalPipe);
    }
    onConfigInitialized(config) {
        super.onConfigInitialized(config);
        // A separate formControl is used to handle the scenario when invalid number typed to the counter component.
        this.counterFormControl = new FormControl(this.formControl.value, this.formControl.validator);
        this.counterFormControl.valueChanges
            .pipe(filter((value) => !isEqual(this.formControl.value, value)), takeUntil(this.destroyed$))
            .subscribe((value) => {
            this.setFieldValue(value);
        });
        this.formControl.valueChanges
            .pipe(startWith(this.formControl.value), distinctUntilChanged(isEqual), takeUntil(this.destroyed$))
            .subscribe(() => {
            // To prevent reset the counter invalid value (e.g '-', 'e') during the typing,
            // in this case counterFormControl value is NaN and formControl value is null,
            // counter must be updated only when it doesn't have a focus
            if (!this.hasFocus) {
                this.counterFormControl.setValue(this.formControl.value);
            }
        });
        this.formControl.touched$.pipe(takeUntil(this.destroyed$)).subscribe((touched) => {
            touched ? this.counterFormControl.markAsTouched() : this.counterFormControl.markAsUntouched();
        });
    }
    onBlur() {
        this.hasFocus = false;
        this.formControl.markAsTouched();
    }
    onFocus() {
        this.hasFocus = true;
    }
    getDisplayValue() {
        const fieldValue = this.getFieldValue();
        return isNil(fieldValue) ? fieldValue : this.decimalPipe.transform(String(fieldValue));
    }
    setFieldValue(value) {
        if (!isNull(value) && isFinite(value)) {
            const bigNumberVal = new BigNumber(value);
            if (!bigNumberVal.eq(this.formControl.value)) {
                this.formControl.markAsDirty();
                this.formControl.setValue(bigNumberVal);
            }
        }
        else {
            super.setFieldValue(value);
        }
    }
}
IntegerFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
IntegerFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: IntegerFieldComponent, selector: "rx-integer-field", viewQueries: [{ propertyName: "counterComponent", first: true, predicate: ["counterComponent"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-counter\n    #counterComponent\n    class=\"mb-0\"\n    [label]=\"label\"\n    [formControl]=\"counterFormControl\"\n    [readonly]=\"isDisabled\"\n    [disabledStyleForReadonlyState]=\"true\"\n    [required]=\"isRequired\"\n    [min]=\"fieldDefinition.minValue\"\n    [max]=\"fieldDefinition.maxValue\"\n    [adaptMin]=\"fieldDefinition.minValue\"\n    [adaptMax]=\"fieldDefinition.maxValue\"\n    adaptIntegerNumber\n    (onBlur)=\"onBlur()\"\n    (onFocus)=\"onFocus()\"\n  ></adapt-rx-counter>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxCounterComponent, selector: "adapt-rx-counter", inputs: ["prefix", "suffix", "max", "min", "step", "size", "placeholder", "disabledStyleForReadonlyState"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.AdaptIntegerNumberValidatorDirective, selector: "[adaptIntegerNumber][ngModel], [adaptIntegerNumber][formControl]", inputs: ["adaptIntegerNumberMessageFn"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i1.AdaptMinValidatorDirective, selector: "[adaptMin][ngModel],[adaptMin][formControl]", inputs: ["adaptMin", "adaptMinMessageFn"] }, { type: i1.AdaptMaxValidatorDirective, selector: "[adaptMax][ngModel],[adaptMax][formControl]", inputs: ["adaptMax", "adaptMaxMessageFn"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-integer-field',
                    templateUrl: './integer-field.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; }, propDecorators: { counterComponent: [{
                type: ViewChild,
                args: ['counterComponent']
            }] } });

class DecimalFieldComponent extends IntegerFieldComponent {
    getDisplayValue() {
        const fieldValue = this.getFieldValue();
        const precision = this.fieldDefinition.precision;
        const digitsInfo = precision === -1 ? null : `1.${precision}-${precision}`;
        return isNil(fieldValue) ? fieldValue : this.decimalPipe.transform(String(fieldValue), digitsInfo);
    }
}
DecimalFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
DecimalFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: DecimalFieldComponent, selector: "rx-decimal-field", usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-counter\n    class=\"mb-0\"\n    [label]=\"label\"\n    [formControl]=\"counterFormControl\"\n    [required]=\"isRequired\"\n    [min]=\"fieldDefinition.minValue\"\n    [max]=\"fieldDefinition.maxValue\"\n    [adaptMin]=\"fieldDefinition.minValue\"\n    [adaptMax]=\"fieldDefinition.maxValue\"\n    (onBlur)=\"onBlur()\"\n    (onFocus)=\"onFocus()\"\n    [readonly]=\"isDisabled\"\n    [disabledStyleForReadonlyState]=\"true\"\n    [requiredLabel]=\"'com.bmc.arsys.rx.client.common.required-field.label' | translate\"\n  ></adapt-rx-counter>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxCounterComponent, selector: "adapt-rx-counter", inputs: ["prefix", "suffix", "max", "min", "step", "size", "placeholder", "disabledStyleForReadonlyState"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i1.AdaptMinValidatorDirective, selector: "[adaptMin][ngModel],[adaptMin][formControl]", inputs: ["adaptMin", "adaptMinMessageFn"] }, { type: i1.AdaptMaxValidatorDirective, selector: "[adaptMax][ngModel],[adaptMax][formControl]", inputs: ["adaptMax", "adaptMaxMessageFn"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-decimal-field',
                    templateUrl: './decimal-field.component.html'
                }]
        }] });

class DecimalFieldModule {
}
DecimalFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DecimalFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldModule, declarations: [DecimalFieldComponent], imports: [AdaptTextFieldFormBuilderModule,
        AdaptRxCounterModule,
        AdaptRxValidatorsModule,
        CommonModule,
        ReactiveFormsModule,
        ReadOnlyFieldModule,
        TranslateModule] });
DecimalFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldModule, imports: [[
            AdaptTextFieldFormBuilderModule,
            AdaptRxCounterModule,
            AdaptRxValidatorsModule,
            CommonModule,
            ReactiveFormsModule,
            ReadOnlyFieldModule,
            TranslateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptTextFieldFormBuilderModule,
                        AdaptRxCounterModule,
                        AdaptRxValidatorsModule,
                        CommonModule,
                        ReactiveFormsModule,
                        ReadOnlyFieldModule,
                        TranslateModule
                    ],
                    declarations: [DecimalFieldComponent],
                    entryComponents: [DecimalFieldComponent]
                }]
        }] });

class DecimalFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        const decimalFieldComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DecimalFieldComponent);
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Decimal,
            aliases: [RxViewComponentType.Floating],
            componentFactory: decimalFieldComponentFactory,
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Decimal',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'field_decimal_number',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(DecimalFieldDesignComponent),
            designComponentModel: DecimalFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
DecimalFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
DecimalFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldRegistrationModule, imports: [DecimalFieldModule, DecimalFieldDesignModule] });
DecimalFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldRegistrationModule, imports: [[DecimalFieldModule, DecimalFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: DecimalFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [DecimalFieldModule, DecimalFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class IntegerFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.integer];
    }
}

class IntegerFieldDesignComponent {
}
IntegerFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
IntegerFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: IntegerFieldDesignComponent, selector: "rx-integer-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-textfield\n  class=\"rx-pointer-events-none\"\n  [required]=\"model.isRequired$ | async\"\n  [label]=\"model.label$ | async\"\n  [disabled]=\"true\"\n  ngModel\n></adapt-rx-textfield>\n", components: [{ type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-integer-field-design',
                    templateUrl: './integer-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class IntegerFieldDesignModule {
}
IntegerFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IntegerFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldDesignModule, declarations: [IntegerFieldDesignComponent], imports: [CommonModule, AdaptRxTextfieldModule, FormsModule] });
IntegerFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldDesignModule, imports: [[CommonModule, AdaptRxTextfieldModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptRxTextfieldModule, FormsModule],
                    declarations: [IntegerFieldDesignComponent],
                    entryComponents: [IntegerFieldDesignComponent]
                }]
        }] });

class IntegerFieldModule {
}
IntegerFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IntegerFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldModule, declarations: [IntegerFieldComponent], imports: [AdaptTextFieldFormBuilderModule,
        AdaptRxCounterModule,
        AdaptRxValidatorsModule,
        CommonModule,
        ReadOnlyFieldModule,
        ReactiveFormsModule,
        TranslateModule] });
IntegerFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldModule, imports: [[
            AdaptTextFieldFormBuilderModule,
            AdaptRxCounterModule,
            AdaptRxValidatorsModule,
            CommonModule,
            ReadOnlyFieldModule,
            ReactiveFormsModule,
            TranslateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptTextFieldFormBuilderModule,
                        AdaptRxCounterModule,
                        AdaptRxValidatorsModule,
                        CommonModule,
                        ReadOnlyFieldModule,
                        ReactiveFormsModule,
                        TranslateModule
                    ],
                    declarations: [IntegerFieldComponent],
                    entryComponents: [IntegerFieldComponent]
                }]
        }] });

class IntegerFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Integer,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(IntegerFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Integer',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'field_integer_number',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(IntegerFieldDesignComponent),
            designComponentModel: IntegerFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
IntegerFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
IntegerFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldRegistrationModule, imports: [IntegerFieldModule, IntegerFieldDesignModule] });
IntegerFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldRegistrationModule, imports: [[IntegerFieldModule, IntegerFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IntegerFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [IntegerFieldModule, IntegerFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

const RX_SELECTION_FIELD = {
    emptyOption: {
        id: null,
        name: 'None'
    },
    editingMode: {
        radioButtons: 'Radio Buttons',
        dropdown: 'Dropdown'
    },
    editingModeValue: {
        radioButtons: 'radio-buttons',
        dropdown: 'dropdown'
    }
};

class SelectionFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor(injector, sandbox) {
        super(injector, sandbox);
        this.injector = injector;
        this.sandbox = sandbox;
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.selection];
        this.editingMode$ = this.sandbox.componentProperties$.pipe(map((componentProperties) => componentProperties.editingMode));
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign(Object.assign({}, BaseRecordEditorFieldDesign.getInitialProperties()), { editingMode: RX_SELECTION_FIELD.editingModeValue.dropdown }), initialProperties);
    }
    getInspectorConfig() {
        return super
            .getInspectorConfig()
            .pipe(map((inspectorConfig) => this.editInspectorConfig(inspectorConfig)));
    }
    editInspectorConfig(inspectorConfig) {
        const valueControlIndex = findIndex(inspectorConfig.inspectorSectionConfigs[0].controls, (item) => item.name === 'value');
        const editingModeControl = {
            name: 'editingMode',
            component: SelectFormControlComponent,
            options: {
                label: 'Editing mode',
                required: false,
                options: [
                    {
                        id: RX_SELECTION_FIELD.editingModeValue.dropdown,
                        name: RX_SELECTION_FIELD.editingMode.dropdown
                    },
                    {
                        id: RX_SELECTION_FIELD.editingModeValue.radioButtons,
                        name: RX_SELECTION_FIELD.editingMode.radioButtons
                    }
                ]
            }
        };
        if (valueControlIndex !== -1) {
            inspectorConfig.inspectorSectionConfigs[0].controls.splice(valueControlIndex, 0, editingModeControl);
        }
        return inspectorConfig;
    }
}

class SelectionFieldDesignComponent {
    ngOnInit() {
        this.model.editingMode$.subscribe((mode) => {
            this.setMode(mode);
        });
    }
    setMode(mode) {
        this.isRadioButtonMode = mode === RX_SELECTION_FIELD.editingModeValue.radioButtons;
    }
}
SelectionFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SelectionFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: SelectionFieldDesignComponent, selector: "rx-selection-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-select\n  class=\"rx-pointer-events-none\"\n  [label]=\"model.label$ | async\"\n  [options]=\"[]\"\n  [disabled]=\"true\"\n  *ngIf=\"!isRadioButtonMode\"\n  [required]=\"model.isRequired$ | async\"\n  ngModel\n>\n</adapt-rx-select>\n\n<ng-container *ngIf=\"isRadioButtonMode\">\n  <div class=\"form-group\">\n    <label class=\"form-control-label\">\n      {{ model.label$ | async }}\n      <span *ngIf=\"model.isRequired$ | async\" class=\"form-control-required\">(required)</span>\n    </label>\n\n    <adapt-rx-radiobutton-group [(ngModel)]=\"isRadioButtonMode\" [disabled]=\"true\">\n      <adapt-rx-radiobutton *ngIf=\"!(model.isRequired$ | async)\" value=\"None\" label=\"None\"></adapt-rx-radiobutton>\n      <adapt-rx-radiobutton label=\"Option 1\"></adapt-rx-radiobutton>\n      <adapt-rx-radiobutton label=\"Option 2\"></adapt-rx-radiobutton>\n    </adapt-rx-radiobutton-group>\n  </div>\n</ng-container>\n", styles: ["::ng-deep adapt-select{width:100%}\n"], components: [{ type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }, { type: i1.AdaptRxRadiobuttonGroupComponent, selector: "adapt-rx-radiobutton-group", inputs: ["formControlName"] }, { type: i1.AdaptRxRadiobuttonComponent, selector: "adapt-rx-radiobutton", inputs: ["name", "label", "id", "value", "checked", "disabled", "ariaLabel", "ariaLabeledBy", "ariaDescribedBy", "testID", "tabIndex"], outputs: ["onFocus", "onBlur", "checkedChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-selection-field-design',
                    templateUrl: './selection-field-design.component.html',
                    styleUrls: ['./selection-field-design.component.scss']
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class SelectionFieldDesignModule {
}
SelectionFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SelectionFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldDesignModule, declarations: [SelectionFieldDesignComponent], imports: [CommonModule, AdaptRxRadiobuttonModule, FormsModule, AdaptRxSelectModule] });
SelectionFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldDesignModule, imports: [[CommonModule, AdaptRxRadiobuttonModule, FormsModule, AdaptRxSelectModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptRxRadiobuttonModule, FormsModule, AdaptRxSelectModule],
                    declarations: [SelectionFieldDesignComponent],
                    entryComponents: [SelectionFieldDesignComponent]
                }]
        }] });

var SelectionFieldMode;
(function (SelectionFieldMode) {
    SelectionFieldMode["RadioButton"] = "radio-buttons";
    SelectionFieldMode["Dropdown"] = "dropdown";
})(SelectionFieldMode || (SelectionFieldMode = {}));

class SelectionFieldComponent extends BaseRecordEditorFieldComponent {
    getSelectValue() {
        return isNil(this.formControl.value)
            ? []
            : compact([this.selectOptions.find((option) => option.id === Number(this.formControl.value))]);
    }
    onConfigInitialized(config) {
        super.onConfigInitialized(config);
        this.isRadioButtonMode = config.editingMode === SelectionFieldMode.RadioButton;
        this.generateControlOptions(this.fieldDefinition);
        this.selectFormControl = new FormControl(this.getSelectValue());
        this.selectFormControl.valueChanges.pipe(takeUntil(this.destroyed$)).subscribe((value) => {
            this.setFieldValue(get(value, '[0].id', null));
        });
        this.formControl.valueChanges
            .pipe(startWith(this.formControl.value), distinctUntilChanged(), takeUntil(this.destroyed$))
            .subscribe(() => {
            this.selectFormControl.setValue(this.getSelectValue());
        });
        this.formControl.touched$.pipe(takeUntil(this.destroyed$)).subscribe((touched) => {
            touched ? this.selectFormControl.markAsTouched() : this.selectFormControl.markAsUntouched();
        });
    }
    generateControlOptions(fieldDefinition) {
        this.selectOptions = map$1(fieldDefinition.optionLabelsById, (label, optionId) => ({
            name: label,
            id: Number(optionId)
        }));
        if (!this.isRequired && this.isRadioButtonMode) {
            this.selectOptions.unshift(RX_SELECTION_FIELD.emptyOption);
        }
    }
    getDisplayValue() {
        return this.fieldDefinition.optionLabelsById[this.formControl.value];
    }
    optionFormatter(option) {
        return option.name;
    }
    onPopupStatusChange(isOpen) {
        if (!isOpen) {
            this.formControl.markAsTouched();
        }
    }
}
SelectionFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
SelectionFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: SelectionFieldComponent, selector: "rx-selection-field", usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-radiobutton-group\n    *ngIf=\"isRadioButtonMode\"\n    [name]=\"guid\"\n    [formControl]=\"formControl\"\n    [readonly]=\"isDisabled\"\n    [label]=\"label\"\n  >\n    <adapt-rx-radiobutton\n      *ngFor=\"let item of selectOptions; last as isLast\"\n      [value]=\"item.id\"\n      [label]=\"item.name\"\n      class=\"mt-0 {{ isLast ? 'mb-1' : '' }}\"\n    >\n    </adapt-rx-radiobutton>\n  </adapt-rx-radiobutton-group>\n\n  <adapt-rx-select\n    *ngIf=\"!isRadioButtonMode\"\n    [options]=\"selectOptions\"\n    [required]=\"isRequired\"\n    [label]=\"label\"\n    [formControl]=\"selectFormControl\"\n    [readonly]=\"isDisabled\"\n    [optionFormatter]=\"optionFormatter\"\n    [enableFilter]=\"true\"\n    [emptyOption]=\"!isRequired\"\n    (onPopupOpenChange)=\"onPopupStatusChange($event)\"\n  >\n  </adapt-rx-select>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxRadiobuttonGroupComponent, selector: "adapt-rx-radiobutton-group", inputs: ["formControlName"] }, { type: i1.AdaptRxRadiobuttonComponent, selector: "adapt-rx-radiobutton", inputs: ["name", "label", "id", "value", "checked", "disabled", "ariaLabel", "ariaLabeledBy", "ariaDescribedBy", "testID", "tabIndex"], outputs: ["onFocus", "onBlur", "checkedChange"] }, { type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-selection-field',
                    templateUrl: './selection-field.component.html'
                }]
        }] });

class SelectionFieldModule {
}
SelectionFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SelectionFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldModule, declarations: [SelectionFieldComponent], imports: [AdaptRxFormControlModule,
        AdaptRxRadiobuttonModule,
        CommonModule,
        ReadOnlyFieldModule,
        FormsModule,
        ReactiveFormsModule,
        TranslateModule,
        AdaptRxLabelModule,
        AdaptRxSelectModule] });
SelectionFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldModule, imports: [[
            AdaptRxFormControlModule,
            AdaptRxRadiobuttonModule,
            CommonModule,
            ReadOnlyFieldModule,
            FormsModule,
            ReactiveFormsModule,
            TranslateModule,
            AdaptRxLabelModule,
            AdaptRxSelectModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptRxFormControlModule,
                        AdaptRxRadiobuttonModule,
                        CommonModule,
                        ReadOnlyFieldModule,
                        FormsModule,
                        ReactiveFormsModule,
                        TranslateModule,
                        AdaptRxLabelModule,
                        AdaptRxSelectModule
                    ],
                    declarations: [SelectionFieldComponent],
                    entryComponents: [SelectionFieldComponent]
                }]
        }] });

class SelectionFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Selection,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(SelectionFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Select',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'field_dropdown',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(SelectionFieldDesignComponent),
            designComponentModel: SelectionFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
SelectionFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
SelectionFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldRegistrationModule, imports: [SelectionFieldModule, SelectionFieldDesignModule] });
SelectionFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldRegistrationModule, imports: [[SelectionFieldModule, SelectionFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectionFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [SelectionFieldModule, SelectionFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class SelectGroupComponent extends BaseViewComponent {
    constructor() {
        super(...arguments);
        this.fieldComponents = new Map();
    }
    registerFieldComponent(fieldIndex, component) {
        this.fieldComponents.set(fieldIndex, component);
    }
    getValueForPreviousField(currentFieldIndex) {
        const component = this.fieldComponents.get(currentFieldIndex - 1);
        return component ? component.getFieldValue() : null;
    }
    resetValueForNextFields(currentFieldIndex) {
        const nextFieldIndex = currentFieldIndex + 1;
        const component = this.fieldComponents.get(nextFieldIndex);
        if (component) {
            component.resetFieldValue();
            this.resetValueForNextFields(nextFieldIndex);
        }
    }
}
SelectGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
SelectGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: SelectGroupComponent, selector: "rx-select-group", inputs: { config: "config" }, usesInheritance: true, ngImport: i0, template: "<rx-runtime-view-canvas-outlet></rx-runtime-view-canvas-outlet>\n", components: [{ type: i1$2.RuntimeViewCanvasOutletComponent, selector: "rx-runtime-view-canvas-outlet", inputs: ["name"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-select-group',
                    templateUrl: './select-group.component.html'
                }]
        }], propDecorators: { config: [{
                type: Input
            }] } });

class SelectGroupFieldComponent$1 extends BaseRecordEditorFieldComponent {
    constructor(injector, selectGroupComponent, rxNamedListDefinitionService, rxNamedListService) {
        super(injector);
        this.selectGroupComponent = selectGroupComponent;
        this.rxNamedListDefinitionService = rxNamedListDefinitionService;
        this.rxNamedListService = rxNamedListService;
        this.optionLoaderFunc = this.getNamedListOptionPage.bind(this);
        this.viewToModelValueAdapterFunc = this.viewToModelValueAdapter.bind(this);
        this.modelToViewValueAdapterFunc = this.modelToViewValueAdapter.bind(this);
        this.selectedOptions = [];
    }
    onConfigInitialized(config) {
        super.onConfigInitialized(config);
        this.fieldIndex = Number(config.index);
        this.namedListDefinitionName = config.namedListDefinitionName;
        this.selectGroupComponent.registerFieldComponent(this.fieldIndex, this);
        const namedListDefinition$ = this.rxNamedListDefinitionService.get(this.namedListDefinitionName).pipe(take(1));
        const valueChanges$ = this.formControl.valueChanges.pipe(distinctUntilChanged(isEqual), startWith(this.formControl.value), takeUntil(this.destroyed$));
        combineLatest([namedListDefinition$, valueChanges$]).subscribe(([namedListDefinition]) => {
            this.namedListDefinition = namedListDefinition;
            this.fieldIdToFilterBy = config.optionFilterFieldId || namedListDefinition.valueFieldId;
            this.updateSelectedOption();
            // do not reset value for next fields after record instance id change,
            // in this case formControl is pristine and untouched
            if (this.formControl.dirty) {
                this.selectGroupComponent.resetValueForNextFields(this.fieldIndex);
            }
            else {
                this.resetLoadedOptions();
            }
        });
    }
    resetFieldValue() {
        super.setFieldValue(null);
        this.resetLoadedOptions();
    }
    getDisplayValue() {
        return this.readOnlyValue;
    }
    getNamedListOptionPage(startIndex, pageSize, searchQuery) {
        return this.rxNamedListService.getOptionPage(this.namedListDefinition, searchQuery, this.getSelectionQueryCriteria(), startIndex, pageSize);
    }
    // [{displayValue: 'FOO', value: 'foo'}] -> 'foo'
    viewToModelValueAdapter(selectedOptions) {
        return get(selectedOptions, '[0].value', '');
    }
    // 'foo' -> [{displayValue: 'FOO', value: 'foo'}]
    modelToViewValueAdapter(modelValue) {
        return isNil(modelValue) ? [] : this.selectedOptions;
    }
    updateSelectedOption() {
        this.showDefaultTitle = false;
        let namedListOptions$;
        if (isEmpty(this.formControl.value)) {
            namedListOptions$ = of([]);
        }
        else {
            // Select with pagination component is not available in the record editor READ mode.
            const loadedOptions = get(this.selectWithPaginationComponent, 'options', []);
            const namedListOptionCandidate = find(loadedOptions, { value: this.formControl.value });
            namedListOptions$ = namedListOptionCandidate
                ? of([namedListOptionCandidate])
                : this.rxNamedListService.getOptionsForValues(this.namedListDefinition, [this.formControl.value]);
        }
        namedListOptions$.pipe(take(1)).subscribe((options) => {
            this.showDefaultTitle = true;
            this.selectedOptions = options;
            if (isEmpty(options) && this.formControl.value) {
                // Selected option might be removed from the named list,
                // in this case we have to show an empty display value.
                this.selectedOptions = [
                    {
                        displayValue: null,
                        value: this.formControl.value
                    }
                ];
            }
            if (this.formControl.dirty) {
                this.formControl.markAsTouched();
            }
            this.triggerModelToViewValueUpdate();
            this.updateReadOnlyValue();
        });
    }
    resetLoadedOptions() {
        if (this.selectWithPaginationComponent) {
            this.selectWithPaginationComponent.resetLoadedOptions();
        }
    }
    getSelectionQueryCriteria() {
        let queryCriteria = null;
        if (this.fieldIndex > 0) {
            const previousFieldValue = this.selectGroupComponent.getValueForPreviousField(this.fieldIndex);
            if (previousFieldValue) {
                queryCriteria = `('${this.fieldIdToFilterBy}' = "${previousFieldValue}")`;
            }
        }
        return queryCriteria;
    }
    updateReadOnlyValue() {
        this.readOnlyValue = get(this.selectedOptions, '[0].displayValue', null);
    }
    triggerModelToViewValueUpdate() {
        // trigger writeValue function in the control value accessor
        this.formControl.setValue(this.formControl.value, { emitEvent: false });
    }
}
SelectGroupFieldComponent$1.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupFieldComponent$1, deps: [{ token: i0.Injector }, { token: SelectGroupComponent }, { token: i2$6.RxNamedListDefinitionService }, { token: i2$6.RxNamedListService }], target: i0.ɵɵFactoryTarget.Component });
SelectGroupFieldComponent$1.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: SelectGroupFieldComponent$1, selector: "rx-select-group-field", viewQueries: [{ propertyName: "selectWithPaginationComponent", first: true, predicate: RxSelectWithPaginationComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <rx-select-with-pagination\n    [label]=\"label\"\n    [formControl]=\"formControl\"\n    [required]=\"isRequired\"\n    [readonly]=\"isDisabled\"\n    [optionLoader]=\"optionLoaderFunc\"\n    [showDefaultTitle]=\"showDefaultTitle\"\n    [viewToModelValueAdapter]=\"viewToModelValueAdapterFunc\"\n    [modelToViewValueAdapter]=\"modelToViewValueAdapterFunc\"\n  ></rx-select-with-pagination>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i2$5.RxSelectWithPaginationComponent, selector: "rx-select-with-pagination", inputs: ["label", "required", "isMultiSelectionMode", "optionLoader", "pageSize", "showDefaultTitle", "showUncheckAll", "readonly", "template", "viewToModelValueAdapter", "modelToViewValueAdapter", "optionFormatter"], outputs: ["toggleDropdown", "selectionChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupFieldComponent$1, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-select-group-field',
                    templateUrl: './select-group-field.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: SelectGroupComponent }, { type: i2$6.RxNamedListDefinitionService }, { type: i2$6.RxNamedListService }]; }, propDecorators: { selectWithPaginationComponent: [{
                type: ViewChild,
                args: [RxSelectWithPaginationComponent]
            }] } });

class SelectGroupComponentDefinitionAdapterService {
    adaptDefinition(componentDefinition) {
        componentDefinition.componentDefinitions.forEach((childComponentDefinition) => {
            assign(childComponentDefinition.propertiesByName, {
                disabled: componentDefinition.propertiesByName.disabled,
                hidden: componentDefinition.propertiesByName.hidden,
                index: Number(childComponentDefinition.propertiesByName.index)
            });
            delete childComponentDefinition.propertiesByName.labelId;
        });
        const layout = {
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName,
                    columns: [
                        {
                            children: sortBy(componentDefinition.componentDefinitions, 'propertiesByName.index').map((component) => component.guid)
                        }
                    ]
                }
            ]
        };
        componentDefinition.propertiesByName = omit(componentDefinition.propertiesByName, [
            'disabled',
            'hidden',
            'recordInstance',
            'recordDefinition'
        ]);
        componentDefinition.layout = JSON.stringify(layout);
    }
}
SelectGroupComponentDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupComponentDefinitionAdapterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SelectGroupComponentDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupComponentDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupComponentDefinitionAdapterService, decorators: [{
            type: Injectable
        }] });

class SelectGroupModule {
    constructor(viewComponentDefinitionAdapterRegistryService, selectGroupComponentDefinitionAdapterService) {
        this.viewComponentDefinitionAdapterRegistryService = viewComponentDefinitionAdapterRegistryService;
        this.selectGroupComponentDefinitionAdapterService = selectGroupComponentDefinitionAdapterService;
        viewComponentDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.SelectGroup, this.selectGroupComponentDefinitionAdapterService);
    }
}
SelectGroupModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: SelectGroupComponentDefinitionAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
SelectGroupModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupModule, declarations: [SelectGroupComponent, SelectGroupFieldComponent$1], imports: [CommonModule,
        RuntimeViewCanvasModule,
        ReactiveFormsModule,
        RxSelectWithPaginationModule,
        ReadOnlyFieldModule] });
SelectGroupModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupModule, providers: [SelectGroupComponentDefinitionAdapterService], imports: [[
            CommonModule,
            RuntimeViewCanvasModule,
            ReactiveFormsModule,
            RxSelectWithPaginationModule,
            ReadOnlyFieldModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RuntimeViewCanvasModule,
                        ReactiveFormsModule,
                        RxSelectWithPaginationModule,
                        ReadOnlyFieldModule
                    ],
                    declarations: [SelectGroupComponent, SelectGroupFieldComponent$1],
                    providers: [SelectGroupComponentDefinitionAdapterService],
                    entryComponents: [SelectGroupComponent, SelectGroupFieldComponent$1]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: SelectGroupComponentDefinitionAdapterService }]; } });

class SelectGroupFieldComponent {
    constructor(rxDefinitionNameService, rxNamedListDefinitionCacheService, rxRecordDefinitionCacheService) {
        this.rxDefinitionNameService = rxDefinitionNameService;
        this.rxNamedListDefinitionCacheService = rxNamedListDefinitionCacheService;
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.definitionPickerOptions = {
            label: 'Named list for options',
            definitionType: RxDefinitionPickerType.NamedList,
            required: true
        };
        this.filterField = [];
        this.filterFieldIdOptions = [];
        this.sourceRecordDefinitionDisplayName = '';
        this.fieldId = [];
    }
    ngOnInit() {
        this.onNamedListDefinitionNameChange(false);
    }
    onNamedListDefinitionNameChange(emitEvent = true) {
        of(this.fieldformGroup.get('namedListDefinitionName').value)
            .pipe(switchMap((namedListDefinitionName) => {
            if (namedListDefinitionName) {
                return this.rxNamedListDefinitionCacheService
                    .getNamedListDefinition(namedListDefinitionName)
                    .pipe(map((namedListDefinition) => namedListDefinition.recordDefinitionName));
            }
            else {
                return of(null);
            }
        }), take(1))
            .subscribe((sourceRecordDefinitionName) => {
            this.fieldformGroup.get('sourceRecordDefinitionName').setValue(sourceRecordDefinitionName, { emitEvent });
            this.filterFieldIdOptions = [];
            this.setFilterId();
            if (this.index > 0) {
                this.setOptionFilterFieldIdOptions();
                this.setSourceRecordDefinitionDisplayName();
            }
        });
    }
    setFilterId() {
        const fieldId = this.fieldformGroup.get('fieldId').value;
        this.fieldId = isEmpty(fieldId) ? [] : [this.targetFieldOptions.find((option) => option.id === fieldId)];
    }
    setSourceRecordDefinitionDisplayName() {
        const recordDefinitionName = this.fieldformGroup.get('sourceRecordDefinitionName').value;
        this.sourceRecordDefinitionDisplayName =
            recordDefinitionName && this.rxDefinitionNameService.getDisplayName(recordDefinitionName);
    }
    setOptionFilterFieldIdOptions() {
        const recordDefinitionName = this.fieldformGroup.get('sourceRecordDefinitionName').value;
        this.filterField = [];
        if (recordDefinitionName) {
            this.rxRecordDefinitionCacheService
                .getRecordDefinition(recordDefinitionName)
                .pipe(map((recordDefinition) => {
                return recordDefinition.fieldDefinitions.map((fieldDefinition) => ({
                    name: fieldDefinition.name,
                    id: String(fieldDefinition.id)
                }));
            }))
                .subscribe((fieldIdOptions) => {
                const filterFieldId = this.fieldformGroup.get('optionFilterFieldId').value;
                this.filterFieldIdOptions = fieldIdOptions;
                this.filterField = isEmpty(filterFieldId)
                    ? []
                    : [this.filterFieldIdOptions.find((option) => option.id === filterFieldId)];
            });
        }
    }
    optionFormatter(option) {
        return option.name;
    }
    onSelectFilterField(filterField) {
        this.fieldformGroup.get('optionFilterFieldId').setValue(head(filterField).id);
    }
    onSelectField(field) {
        this.fieldformGroup.get('fieldId').setValue(head(field).id);
    }
}
SelectGroupFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupFieldComponent, deps: [{ token: i1$1.RxDefinitionNameService }, { token: i2$6.RxNamedListDefinitionCacheService }, { token: i1$5.RxRecordDefinitionCacheService }], target: i0.ɵɵFactoryTarget.Component });
SelectGroupFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: SelectGroupFieldComponent, selector: "rx-select-group-field", inputs: { fieldformGroup: "fieldformGroup", index: "index", targetFieldOptions: "targetFieldOptions" }, ngImport: i0, template: "<div>\n  <adapt-rx-textfield\n    label=\"Display label\"\n    required=\"true\"\n    rx-id=\"display-label-field\"\n    [formControl]=\"fieldformGroup.get('label')\"\n    class=\"form-group d-block\"\n  ></adapt-rx-textfield>\n\n  <rx-definition-picker\n    [options]=\"definitionPickerOptions\"\n    [formControl]=\"fieldformGroup.get('namedListDefinitionName')\"\n    (ngModelChange)=\"onNamedListDefinitionNameChange()\"\n    required=\"true\"\n    rx-id=\"named-list-definition-name-field\"\n    class=\"form-group d-block\"\n  ></rx-definition-picker>\n\n  <adapt-rx-select\n    label=\"Field for storing selected option value\"\n    rx-id=\"selected-option-value-target-field\"\n    [ngModel]=\"fieldId\"\n    (ngModelChange)=\"onSelectField($event)\"\n    [options]=\"targetFieldOptions\"\n    [optionFormatter]=\"optionFormatter\"\n    [required]=\"true\"\n    [disabled]=\"fieldformGroup.disabled\"\n    [ngClass]=\"{ 'form-group d-block': index > 0 }\"\n  ></adapt-rx-select>\n\n  <adapt-rx-textfield\n    label=\"Source record definition\"\n    *ngIf=\"index > 0\"\n    class=\"form-group d-block\"\n    [ngModel]=\"sourceRecordDefinitionDisplayName\"\n    disabled\n    rx-id=\"source-record-definition-name-field\"\n    [tooltip]=\"{\n      iconName: 'question_circle_o',\n      content: 'This is the record definition that provides the option values for this named list.',\n      placement: 'top',\n      popoverMode: true\n    }\"\n  ></adapt-rx-textfield>\n\n  <adapt-rx-select\n    *ngIf=\"index > 0\"\n    label=\"Field for filtering option values\"\n    rx-id=\"option-values-filter-field\"\n    [ngModel]=\"filterField\"\n    (ngModelChange)=\"onSelectFilterField($event)\"\n    [options]=\"filterFieldIdOptions\"\n    [optionFormatter]=\"optionFormatter\"\n    [disabled]=\"fieldformGroup.disabled\"\n    [tooltip]=\"{\n      iconName: 'question_circle_o',\n      content: 'Select the field in the source record definition that filters the option values for this named list.',\n      placement: 'top',\n      popoverMode: true\n    }\"\n  ></adapt-rx-select>\n</div>\n", components: [{ type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: i2$5.RxDefinitionPickerComponent, selector: "rx-definition-picker", inputs: ["options", "isDisabled"] }, { type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }], directives: [{ type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-select-group-field',
                    templateUrl: './select-group-field.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionNameService }, { type: i2$6.RxNamedListDefinitionCacheService }, { type: i1$5.RxRecordDefinitionCacheService }]; }, propDecorators: { fieldformGroup: [{
                type: Input
            }], index: [{
                type: Input
            }], targetFieldOptions: [{
                type: Input
            }] } });

class FieldSetFormControlComponent extends InspectorWidgetBase {
    constructor(formBuilder, rxGuidService, rxModalService, injector) {
        super(injector);
        this.formBuilder = formBuilder;
        this.rxGuidService = rxGuidService;
        this.rxModalService = rxModalService;
        this.formArray = this.formBuilder.array([]);
        this.maxSelectGroupFieldCount = 6;
        this.destroyed$ = new ReplaySubject(1);
    }
    ngOnInit() {
        this.designerItemModel.fieldProperties$
            .pipe(takeUntil(this.destroyed$))
            .subscribe((fieldModels) => this.onWriteValue(fieldModels));
        this.setDisabledState(this.isDisabled);
    }
    onWriteValue(fieldModels) {
        var _a;
        (_a = this.valueChangeSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        const formGroups = fieldModels
            .sort((a, b) => Number(a.index) - Number(b.index))
            .map((model) => this.formBuilder.group(Object.assign(Object.assign({}, omit(model, 'index')), { sourceRecordDefinitionName: { value: null, disabled: true } })));
        this.formArray = this.formBuilder.array(formGroups);
        this.valueChangeSubscription = this.formArray.valueChanges
            .pipe(takeUntil(this.destroyed$))
            .subscribe(this.onFormValueChange.bind(this));
    }
    onFormValueChange(formValue) {
        const value = formValue.map((formGroup, index) => {
            const inspectorFieldModel = Object.assign(Object.assign({}, omit(formGroup, ['sourceRecordDefinitionName', 'optionFilterFieldId'])), { index: String(index), fieldId: formGroup.namedListDefinitionName ? formGroup.fieldId : null });
            if (index > 0) {
                inspectorFieldModel.optionFilterFieldId = formGroup.namedListDefinitionName
                    ? formGroup.optionFilterFieldId
                    : null;
            }
            return inspectorFieldModel;
        });
        this.designerItemModel.onFieldPropertiesChange(value);
    }
    addField() {
        this.formArray.push(this.getFieldFormGroup());
    }
    removeField(index) {
        this.rxModalService
            .confirm({
            title: 'Warning',
            modalStyle: RX_MODAL.modalStyles.warning,
            message: 'Are you sure you want to delete this field?'
        })
            .then((response) => {
            if (response) {
                this.formArray.removeAt(index);
            }
        });
    }
    isAddFieldButtonDisabled() {
        return this.isDisabled || this.formArray.length >= this.maxSelectGroupFieldCount;
    }
    trackByFn(index, control) {
        return control.get('guid').value;
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
    getFieldFormGroup() {
        return this.formBuilder.group({
            guid: this.rxGuidService.generate(),
            label: null,
            namedListDefinitionName: null,
            fieldId: null,
            sourceRecordDefinitionName: null,
            optionFilterFieldId: null
        });
    }
    setDisabledState(isDisabled) {
        isDisabled ? this.formArray.disable() : this.formArray.enable();
    }
}
FieldSetFormControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldSetFormControlComponent, deps: [{ token: i2$3.FormBuilder }, { token: i2$1.RxGuidService }, { token: i1$6.RxModalService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
FieldSetFormControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: FieldSetFormControlComponent, selector: "rx-field-set-form-control", inputs: { options: "options", isDisabled: "isDisabled" }, usesInheritance: true, ngImport: i0, template: "<adapt-button\n  btn-type=\"tertiary\"\n  rx-id=\"add-field-button\"\n  class=\"d-icon-plus_circle px-0 py-0\"\n  (click)=\"addField()\"\n  [disabled]=\"isAddFieldButtonDisabled()\"\n>\n  Add dependent field\n</adapt-button>\n\n<div\n  class=\"card mt-2\"\n  *ngFor=\"let formGroupControl of formArray.controls; trackBy: trackByFn; let index = index\"\n  rx-id=\"select-group-field-card\"\n>\n  <div class=\"card-block p-2\">\n    <button\n      (click)=\"removeField(index)\"\n      class=\"close position-relative\"\n      type=\"button\"\n      aria-label=\"Remove\"\n      rx-id=\"remove-field-button\"\n      *ngIf=\"!isDisabled\"\n    ></button>\n\n    <rx-select-group-field\n      [fieldformGroup]=\"formGroupControl\"\n      [index]=\"index\"\n      [targetFieldOptions]=\"options.targetFieldOptions\"\n    ></rx-select-group-field>\n  </div>\n</div>\n", styles: [".close{z-index:1}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: SelectGroupFieldComponent, selector: "rx-select-group-field", inputs: ["fieldformGroup", "index", "targetFieldOptions"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldSetFormControlComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-field-set-form-control',
                    templateUrl: './field-set-form-control.component.html',
                    styleUrls: ['./field-set-form-control.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i2$3.FormBuilder }, { type: i2$1.RxGuidService }, { type: i1$6.RxModalService }, { type: i0.Injector }]; }, propDecorators: { options: [{
                type: Input
            }], isDisabled: [{
                type: Input
            }] } });

class SelectGroupDesignModel extends ViewDesignerComponentModel {
    constructor(injector, sandbox) {
        super(injector, sandbox);
        this.injector = injector;
        this.sandbox = sandbox;
        this.rxRecordDefinitionCacheService = this.injector.get(RxRecordDefinitionCacheService);
        this.rxFieldDefinitionService = this.injector.get(RxFieldDefinitionService);
        this.recordEditorGuid$ = this.sandbox
            .getParentComponentGuid(RxViewComponentType.RecordEditor)
            .pipe(take(1), shareReplay(1));
        this.recordEditorMode$ = this.recordEditorGuid$.pipe(switchMap((recordEditorGuid) => {
            return this.sandbox.getComponentPropertyValue('mode', recordEditorGuid);
        }));
        this.recordDefinitionName$ = this.recordEditorGuid$.pipe(switchMap((recordEditorGuid) => {
            return this.sandbox.getComponentPropertyValue('recordDefinitionName', recordEditorGuid);
        }), shareReplay(1));
        this.fieldDefinitions$ = this.recordDefinitionName$.pipe(switchMap((recordDefinitionName) => {
            if (recordDefinitionName) {
                return this.rxRecordDefinitionCacheService
                    .getRecordDefinition(recordDefinitionName)
                    .pipe(catchError((error) => EMPTY));
            }
            else {
                return of(null);
            }
        }), distinctUntilChanged(), map((recordDefinition) => {
            if (recordDefinition && recordDefinition.fieldDefinitions) {
                return filter$1(recordDefinition.fieldDefinitions, {
                    resourceType: RX_RECORD_DEFINITION.resourceTypes.character
                });
            }
            else {
                return [];
            }
        }), shareReplay(1));
        this.inspectorTargetFieldOptions$ = combineLatest([this.fieldDefinitions$, this.recordEditorMode$]).pipe(map(([fieldDefinitions, recordEditorMode]) => [
            filter$1(fieldDefinitions, { resourceType: RX_RECORD_DEFINITION.resourceTypes.character }),
            recordEditorMode
        ]), map(([characterFieldDefinitions, recordEditorMode]) => flow((fieldDefinitions) => filter$1(fieldDefinitions, (definition) => {
            const isSystemField = this.rxFieldDefinitionService.isSystemField(definition);
            return !isSystemField || (isSystemField && recordEditorMode === RecordEditorMode.Edit);
        }), (fieldDefinitions) => map$1(fieldDefinitions, (definition) => ({
            name: definition.name,
            id: String(definition.id)
        })), (options) => sortBy(options, 'name'))(characterFieldDefinitions)), shareReplay(1));
        this.fieldsDesignData$ = this.sandbox.getChildComponents();
        this.fieldProperties$ = this.fieldsDesignData$.pipe(map((fieldComponentsDesignData) => map$1(fieldComponentsDesignData, (field) => (Object.assign(Object.assign({}, field.data), { guid: field.guid })))));
        // initial inspector configuration and component properties set
        combineLatest([this.recordDefinitionName$, this.inspectorTargetFieldOptions$, this.recordEditorGuid$])
            .pipe(take(1))
            .subscribe(([recordDefinitionName, inspectorTargetFieldOptions, recordEditorGuid]) => {
            this.sandbox.updateInspectorConfig(this.getBaseInspectorConfig(inspectorTargetFieldOptions, recordDefinitionName, recordEditorGuid));
        });
        this.inspectorTargetFieldOptions$
            .pipe(withLatestFrom(this.recordDefinitionName$, this.recordEditorGuid$))
            .subscribe(([inspectorTargetFieldOptions, recordDefinitionName, recordEditorGuid]) => {
            this.sandbox.updateInspectorConfig(this.getBaseInspectorConfig(inspectorTargetFieldOptions, recordDefinitionName, recordEditorGuid));
        });
        combineLatest([this.sandbox.componentProperties$, this.fieldProperties$])
            .pipe(switchMap(([componentProperties, fieldProperties]) => this.validate(componentProperties, fieldProperties)))
            .subscribe((validationIssues) => {
            this.sandbox.setValidationIssues(validationIssues);
        });
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign(Object.assign({}, RX_DISABLED_PROP_DEFAULT_VALUE), RX_STANDARD_PROPS_DEFAULT_VALUES), initialProperties);
    }
    onFieldPropertiesChange(fieldProperties) {
        const fieldComponentPayloads = this.getFieldComponentPayloads(fieldProperties);
        this.sandbox.setChildren(fieldComponentPayloads);
    }
    isFieldRequired(field) {
        return this.fieldDefinitions$.pipe(map((fieldDefinitions) => {
            const fieldDefinition = field.data.fieldId && find(fieldDefinitions, { id: Number(field.data.fieldId) });
            return Boolean(fieldDefinition) && fieldDefinition.fieldOption === RX_RECORD_DEFINITION.fieldOptions.required;
        }));
    }
    getPropertiesByName(properties) {
        return pick(properties, ['disabled', 'hidden', 'styles', RX_AVAILABLE_ON_DEVICES_PROP_NAME]);
    }
    validate(componentProperties, fieldProperties) {
        const validationErrorMessages = [];
        if (isEmpty(fieldProperties)) {
            validationErrorMessages.push('Field set cannot be empty.');
        }
        else {
            const fieldsWithLabel = filter$1(fieldProperties, (model) => model.label);
            if (fieldsWithLabel.length !== fieldProperties.length) {
                validationErrorMessages.push('Display label cannot be blank.');
            }
            if (uniqBy(fieldsWithLabel, 'label').length !== fieldsWithLabel.length) {
                validationErrorMessages.push('Display labels must be unique.');
            }
            if (reject(fieldProperties, (model) => model.namedListDefinitionName).length) {
                validationErrorMessages.push('Named list for options cannot be blank.');
            }
            if (reject(fieldProperties, (model) => model.fieldId).length) {
                validationErrorMessages.push('Field for storing selected option value cannot be blank.');
            }
        }
        const validationIssues = validationErrorMessages
            .map((message) => this.sandbox.createError(message))
            .concat(validateStandardProps(componentProperties));
        return of(validationIssues);
    }
    getFieldComponentPayloads(fieldProperties) {
        return map$1(fieldProperties, (model) => ({
            type: RxViewComponentType.SelectGroupField,
            guid: model.guid,
            data: omit(model, 'guid')
        }));
    }
    getBaseInspectorConfig(targetFieldOptions, recordDefinitionName, recordEditorGuid) {
        const generalGroup = {
            label: 'General',
            controls: []
        };
        if (recordDefinitionName) {
            generalGroup.controls = [getDisabledFieldInspectorConfig(), ...getStandardPropsInspectorConfigs()];
        }
        else {
            generalGroup.controls = [
                {
                    component: ValidationFormControlComponent,
                    options: {
                        text: 'You must select a Record definition before editing field component.',
                        propertyName: 'recordDefinitionName',
                        componentGuid: recordEditorGuid
                    }
                }
            ];
        }
        return {
            inspectorSectionConfigs: recordDefinitionName
                ? [
                    generalGroup,
                    {
                        label: 'Field set',
                        controls: [
                            {
                                component: FieldSetFormControlComponent,
                                options: {
                                    targetFieldOptions: targetFieldOptions
                                }
                            }
                        ]
                    }
                ]
                : [generalGroup]
        };
    }
}

class SelectGroupDesignComponent {
    trackByFn(index, item) {
        return item.data.guid;
    }
}
SelectGroupDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SelectGroupDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: SelectGroupDesignComponent, selector: "rx-select-group-design", inputs: { model: "model" }, ngImport: i0, template: "<ng-template [ngIf]=\"(model.fieldsDesignData$ | async).length\" [ngIfElse]=\"placeholderTemplate\">\n  <adapt-rx-textfield\n    *ngFor=\"let field of model.fieldsDesignData$ | async; trackBy: trackByFn\"\n    [label]=\"field.data.label || '<No Label>'\"\n    [required]=\"model.isFieldRequired(field) | async\"\n    [disabled]=\"true\"\n    ngModel\n    rx-id=\"select-group-field\"\n    class=\"form-group d-block\"\n  ></adapt-rx-textfield>\n</ng-template>\n\n<ng-template #placeholderTemplate>\n  <adapt-empty-state type=\"objects\" label=\"Add dependent fields in the Properties panel.\"></adapt-empty-state>\n</ng-template>\n", components: [{ type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-select-group-design',
                    templateUrl: './select-group-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class SelectGroupDesignModule {
}
SelectGroupDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SelectGroupDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupDesignModule, declarations: [SelectGroupDesignComponent, FieldSetFormControlComponent, SelectGroupFieldComponent], imports: [FormsModule,
        CommonModule,
        AdaptButtonModule,
        ReactiveFormsModule,
        RxDefinitionPickerModule,
        AdaptRxTextfieldModule,
        AdaptRxSelectModule,
        AdaptEmptyStateModule], exports: [SelectGroupDesignComponent, FieldSetFormControlComponent, SelectGroupFieldComponent] });
SelectGroupDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupDesignModule, imports: [[
            FormsModule,
            CommonModule,
            AdaptButtonModule,
            ReactiveFormsModule,
            RxDefinitionPickerModule,
            AdaptRxTextfieldModule,
            AdaptRxSelectModule,
            AdaptEmptyStateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [SelectGroupDesignComponent, FieldSetFormControlComponent, SelectGroupFieldComponent],
                    imports: [
                        FormsModule,
                        CommonModule,
                        AdaptButtonModule,
                        ReactiveFormsModule,
                        RxDefinitionPickerModule,
                        AdaptRxTextfieldModule,
                        AdaptRxSelectModule,
                        AdaptEmptyStateModule
                    ],
                    exports: [SelectGroupDesignComponent, FieldSetFormControlComponent, SelectGroupFieldComponent],
                    entryComponents: [SelectGroupDesignComponent, FieldSetFormControlComponent, SelectGroupFieldComponent]
                }]
        }] });

class SelectGroupRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.SelectGroup,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(SelectGroupComponent),
            properties: [RX_AVAILABLE_ON_DEVICES_PROP_DESC],
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            name: 'Select group',
            designComponentFactory: componentFactoryResolver.resolveComponentFactory(SelectGroupDesignComponent),
            designComponentModel: SelectGroupDesignModel,
            isContainerComponent: true,
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'field_dropdowns',
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        }, {
            type: RxViewComponentType.SelectGroupField,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(SelectGroupFieldComponent$1),
            properties: RX_BASE_FIELD_PROPERTIES,
            isDataComponent: true
        });
    }
}
SelectGroupRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
SelectGroupRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupRegistrationModule, imports: [SelectGroupModule, SelectGroupDesignModule] });
SelectGroupRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupRegistrationModule, imports: [[SelectGroupModule, SelectGroupDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SelectGroupRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [SelectGroupModule, SelectGroupDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class TextFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor(injector, sandbox) {
        super(injector, sandbox);
        this.injector = injector;
        this.sandbox = sandbox;
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.character];
        this.translateService = this.injector.get(TranslateService);
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign(Object.assign({}, BaseRecordEditorFieldDesign.getInitialProperties()), { enableMultiSelection: null, additionalQueryCriteria: null }), initialProperties);
    }
    getInspectorConfig() {
        return this.selectedFieldDefinition$.pipe(switchMap((fieldDefinition) => super
            .getInspectorConfig()
            .pipe(map((inspectorConfig) => (fieldDefinition === null || fieldDefinition === void 0 ? void 0 : fieldDefinition.namedListDefinition)
            ? this.getNamedListInspectorConfig(inspectorConfig, fieldDefinition)
            : inspectorConfig))));
    }
    getNamedListInspectorConfig(inspectorConfig, fieldDefinition) {
        const namedListFilterExpressionConfigurator = new NamedListFilterExpressionConfigurator(fieldDefinition, this.injector);
        const enableMultiSelectionControl = {
            name: 'enableMultiSelection',
            component: SwitchFormControlComponent,
            options: {
                label: 'Enable multi-selection'
            }
        };
        const additionalQueryCriteriaControls = [
            {
                name: 'namedListDefinitionName',
                component: RxDefinitionPickerComponent,
                isDisabled: true,
                options: {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.definition-type.named-list.label'),
                    definitionType: RX_DEFINITION_PICKER.definitionTypes.namedList.type
                }
            },
            {
                name: 'additionalQueryCriteria',
                component: ExpressionFormControlComponent,
                options: {
                    label: 'Additional named list filter',
                    tooltip: new Tooltip('Build a filter to apply at runtime in addition to the filter, if any, specified in the named list definition.'),
                    dataDictionary$: namedListFilterExpressionConfigurator.getDataDictionary(),
                    operators: namedListFilterExpressionConfigurator.getOperators()
                }
            }
        ];
        inspectorConfig.inspectorSectionConfigs[0].controls.push(enableMultiSelectionControl);
        inspectorConfig.inspectorSectionConfigs[0].controls.push(...additionalQueryCriteriaControls);
        // update the named list name for named list inspector control
        this.sandbox.updateComponentProperties({ namedListDefinitionName: fieldDefinition.namedListDefinition });
        return inspectorConfig;
    }
    getPropertiesByName(properties) {
        return omit(super.getPropertiesByName(properties), 'namedListDefinitionName');
    }
}

class TextFieldDesignComponent {
}
TextFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TextFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: TextFieldDesignComponent, selector: "rx-character-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-textfield\n  class=\"rx-pointer-events-none\"\n  [required]=\"model.isRequired$ | async\"\n  [label]=\"model.label$ | async\"\n  [disabled]=\"true\"\n  ngModel\n></adapt-rx-textfield>\n", components: [{ type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-character-field-design',
                    templateUrl: 'text-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class TextFieldDesignModule {
}
TextFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TextFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldDesignModule, declarations: [TextFieldDesignComponent], imports: [CommonModule, AdaptRxTextfieldModule, FormsModule] });
TextFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldDesignModule, imports: [[CommonModule, AdaptRxTextfieldModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptRxTextfieldModule, FormsModule],
                    declarations: [TextFieldDesignComponent],
                    entryComponents: [TextFieldDesignComponent]
                }]
        }] });

class TextFieldExpressionConfigurator extends RxViewComponentExpressionConfigurator {
    constructor(injector, componentGuid, componentModel) {
        super(injector, componentGuid, componentModel);
        this.injector = injector;
        this.componentGuid = componentGuid;
        this.componentModel = componentModel;
        const dataDictionary$ = this.componentModel.selectedFieldDefinition$.pipe(filter((fieldDefinition) => Boolean(fieldDefinition.namedListDefinition)), switchMap((fieldDefinition) => {
            const namedListFilterExpressionConfigurator = new NamedListFilterExpressionConfigurator(fieldDefinition, this.injector);
            return namedListFilterExpressionConfigurator.getDataDictionary();
        }));
        this.configureForProperty({
            propertyPath: 'additionalQueryCriteria',
            dataDictionary$,
            operators: ExpressionOperatorRowsByGroup.get(ExpressionOperatorGroup.AllServer)
        });
    }
}

var TextFieldMultiSelectionType;
(function (TextFieldMultiSelectionType) {
    TextFieldMultiSelectionType["Enabled"] = "true";
    TextFieldMultiSelectionType["Disabled"] = "false";
})(TextFieldMultiSelectionType || (TextFieldMultiSelectionType = {}));

class TextFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector, fieldDefinitionService, rxNamedListDefinitionService, rxNamedListService) {
        super(injector);
        this.fieldDefinitionService = fieldDefinitionService;
        this.rxNamedListDefinitionService = rxNamedListDefinitionService;
        this.rxNamedListService = rxNamedListService;
        this.optionLoaderFunc = this.getNamedListOptionPage.bind(this);
        this.viewToModelValueAdapterFunc = this.viewToModelValueAdapter.bind(this);
        this.modelToViewValueAdapterFunc = this.modelToViewValueAdapter.bind(this);
        this.selectedOptions = [];
        this.multiSelectDelimiter = ';';
        this.isDropdownOpen = false;
    }
    onConfigInitialized(config) {
        super.onConfigInitialized(config);
        this.isPasswordField =
            includes(RX_RECORD_DEFINITION.passwordFieldIds, this.fieldId) || this.fieldDefinition.shouldPersistHashed;
        this.namedListDefinitionName = this.fieldDefinition.namedListDefinition;
        this.isNamedListAttached = Boolean(this.namedListDefinitionName);
        this.isMultipleSelectionEnabled = config.enableMultiSelection === TextFieldMultiSelectionType.Enabled;
        if (this.fieldDefinition.maxLength && !this.fieldDefinitionService.isSystemField(this.fieldDefinition)) {
            this.maxLength = this.fieldDefinition.maxLength;
        }
        if (this.isNamedListAttached) {
            const namedListDefinition$ = this.rxNamedListDefinitionService
                .get(this.namedListDefinitionName)
                .pipe(shareReplay(1), take(1));
            const valueChanges$ = this.formControl.valueChanges.pipe(distinctUntilChanged(isEqual), startWith(this.formControl.value), filter(() => !this.isDropdownOpen), takeUntil(this.destroyed$));
            this.config
                .pipe(debounceTime(250), pluck('additionalQueryCriteria'), distinctUntilChanged(), takeUntil(this.destroyed$))
                .subscribe((additionalQueryCriteria) => {
                if (!isNil(this.additionalQueryCriteria)) {
                    this.selectWithPaginationComponent.resetLoadedOptions();
                    this.setFieldValue(null);
                }
                this.additionalQueryCriteria = additionalQueryCriteria;
            });
            combineLatest([namedListDefinition$, valueChanges$]).subscribe(([namedListDefinition]) => {
                this.namedListDefinition = namedListDefinition;
                this.updateSelection();
            });
        }
    }
    getDisplayValue() {
        let displayValue = super.getDisplayValue();
        if (this.isPasswordField) {
            displayValue = '********';
        }
        else if (this.isNamedListAttached) {
            displayValue = this.namedListFormattedValue;
        }
        return displayValue;
    }
    getNamedListOptionPage(startIndex, pageSize, searchQuery) {
        return this.rxNamedListService.getOptionPage(this.namedListDefinition, searchQuery, this.additionalQueryCriteria, startIndex, pageSize);
    }
    // [{displayValue: 'FOO', value: 'foo'}, {displayValue: 'BAR', value: 'bar'}] -> 'foo;bar'
    viewToModelValueAdapter(selectedOptions) {
        this.selectedOptions = selectedOptions;
        this.updateNamedListFormattedValue();
        return selectedOptions.map((option) => option.value).join(this.multiSelectDelimiter);
    }
    // 'foo;bar' -> [{displayValue: 'FOO', value: 'foo'}, {displayValue: 'BAR', value: 'bar'}]
    modelToViewValueAdapter(modelValue) {
        return modelValue ? this.selectedOptions : [];
    }
    onToggleDropdown(isOpen) {
        this.isDropdownOpen = isOpen;
    }
    getOptionValues(modelValue) {
        return modelValue ? compact(modelValue.split(this.multiSelectDelimiter)) : [];
    }
    // Update selection by form control value.
    // Usually, this needs to be done when form control value changes programmatically, e.g:
    // - in initialization text field component phase
    // - by set property action
    // - after record editor record instance id change
    updateSelection() {
        this.showDefaultTitle = false;
        const selectedOptionValues = this.getOptionValues(this.formControl.value);
        if (!this.isMultipleSelectionEnabled && selectedOptionValues.length > 1) {
            // If the field instance contains multiple values but the component doesn't have multiple selection enabled
            // e.g. when field was edited in the data editor, the display value will be blank (null).
            this.selectedOptions = [
                {
                    displayValue: null,
                    value: this.formControl.value
                }
            ];
            this.triggerModelToViewValueUpdate();
            this.updateNamedListFormattedValue();
        }
        else {
            // Select with pagination component is not available in the record editor READ mode.
            const loadedOptions = get(this.selectWithPaginationComponent, 'options', []);
            // Check if all options for selected values are already loaded.
            (selectedOptionValues.every((selectedValue) => loadedOptions.find((option) => option.value === selectedValue))
                ? of(loadedOptions)
                : this.rxNamedListService.getOptionsForValues(this.namedListDefinition, selectedOptionValues)).subscribe((options) => {
                this.showDefaultTitle = true;
                if (!this.isMultipleSelectionEnabled && selectedOptionValues.length > 1) {
                    // If the field instance contains multiple values but the component doesn't have multiple selection
                    // enabled e.g. when field was edited in the data editor, the display value will be blank (null).
                    this.selectedOptions = [
                        {
                            displayValue: null,
                            value: this.formControl.value
                        }
                    ];
                }
                else {
                    // If the record instance with a given value is not found e.g. referenced record
                    // was deleted, the display value for such record instance will be blank (null).
                    this.selectedOptions = selectedOptionValues.map((optionValue) => find(options, { value: optionValue }) || {
                        displayValue: null,
                        value: optionValue
                    });
                }
                if (this.formControl.dirty) {
                    this.formControl.markAsTouched();
                }
                this.triggerModelToViewValueUpdate();
                this.updateNamedListFormattedValue();
            });
        }
    }
    updateNamedListFormattedValue() {
        if (this.isMultipleSelectionEnabled) {
            const visibleOptionsCount = 50;
            this.namedListFormattedValue =
                this.selectedOptions
                    .slice(0, visibleOptionsCount)
                    .map((option) => option.displayValue)
                    .filter(Boolean)
                    .join(', ') || null;
            if (this.selectedOptions.length >= visibleOptionsCount) {
                this.namedListFormattedValue += '...';
            }
        }
        else {
            this.namedListFormattedValue = this.selectedOptions.length ? first$1(this.selectedOptions).displayValue : null;
        }
    }
    triggerModelToViewValueUpdate() {
        // trigger writeValue function in the control value accessor
        this.formControl.setValue(this.formControl.value, { emitEvent: false });
    }
}
TextFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldComponent, deps: [{ token: i0.Injector }, { token: i1$5.RxFieldDefinitionService }, { token: i2$6.RxNamedListDefinitionService }, { token: i2$6.RxNamedListService }], target: i0.ɵɵFactoryTarget.Component });
TextFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: TextFieldComponent, selector: "rx-text-field", viewQueries: [{ propertyName: "selectWithPaginationComponent", first: true, predicate: RxSelectWithPaginationComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-textfield\n    *ngIf=\"!isNamedListAttached\"\n    [label]=\"label\"\n    [isPassword]=\"isPasswordField\"\n    [formControl]=\"formControl\"\n    [maxlength]=\"maxLength\"\n    [required]=\"isRequired\"\n    [readonly]=\"isDisabled\"\n    [disabledStyleForReadonlyState]=\"true\"\n    [autocomplete]=\"!isPasswordField\"\n    [requiredLabel]=\"'com.bmc.arsys.rx.client.common.required-field.label' | translate\"\n  ></adapt-rx-textfield>\n\n  <rx-select-with-pagination\n    *ngIf=\"isNamedListAttached\"\n    [showDefaultTitle]=\"showDefaultTitle\"\n    [label]=\"label\"\n    [formControl]=\"formControl\"\n    [readonly]=\"isDisabled\"\n    [viewToModelValueAdapter]=\"viewToModelValueAdapterFunc\"\n    [modelToViewValueAdapter]=\"modelToViewValueAdapterFunc\"\n    [optionLoader]=\"optionLoaderFunc\"\n    [required]=\"isRequired\"\n    [isMultiSelectionMode]=\"isMultipleSelectionEnabled\"\n    (toggleDropdown)=\"onToggleDropdown($event)\"\n    [template]=\"namedListOptionTemplate\"\n  ></rx-select-with-pagination>\n</ng-template>\n\n<ng-template #namedListOptionTemplate let-option>\n  {{ option.displayValue }}\n  <div *ngIf=\"option.contextualFields\" class=\"text-secondary text-truncate\" [title]=\"option.title\">\n    <span class=\"breadcrumb-item active\" *ngFor=\"let contextualFieldValue of option.contextualFields\">\n      <small> {{ contextualFieldValue }} </small>\n    </span>\n  </div>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: i2$5.RxSelectWithPaginationComponent, selector: "rx-select-with-pagination", inputs: ["label", "required", "isMultiSelectionMode", "optionLoader", "pageSize", "showDefaultTitle", "showUncheckAll", "readonly", "template", "viewToModelValueAdapter", "modelToViewValueAdapter", "optionFormatter"], outputs: ["toggleDropdown", "selectionChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i2$3.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-text-field',
                    templateUrl: './text-field.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$5.RxFieldDefinitionService }, { type: i2$6.RxNamedListDefinitionService }, { type: i2$6.RxNamedListService }]; }, propDecorators: { selectWithPaginationComponent: [{
                type: ViewChild,
                args: [RxSelectWithPaginationComponent]
            }] } });

class TextFieldModule {
}
TextFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TextFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldModule, declarations: [TextFieldComponent], imports: [CommonModule,
        ReadOnlyFieldModule,
        ReactiveFormsModule,
        TranslateModule,
        RxSelectWithPaginationModule,
        AdaptRxTextfieldModule], exports: [TextFieldComponent] });
TextFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldModule, imports: [[
            CommonModule,
            ReadOnlyFieldModule,
            ReactiveFormsModule,
            TranslateModule,
            RxSelectWithPaginationModule,
            AdaptRxTextfieldModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReadOnlyFieldModule,
                        ReactiveFormsModule,
                        TranslateModule,
                        RxSelectWithPaginationModule,
                        AdaptRxTextfieldModule
                    ],
                    declarations: [TextFieldComponent],
                    exports: [TextFieldComponent],
                    entryComponents: [TextFieldComponent]
                }]
        }] });

class TextFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver, rxRecordQueryExpressionEvaluatorService) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxRecordQueryExpressionEvaluatorService = rxRecordQueryExpressionEvaluatorService;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Character,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(TextFieldComponent),
            properties: [
                ...RX_BASE_FIELD_PROPERTIES,
                {
                    name: 'enableMultiSelection',
                    designType: ViewComponentPropertyType.Boolean
                },
                {
                    name: 'namedListDefinitionName',
                    designType: ViewComponentPropertyType.String
                },
                {
                    name: 'additionalQueryCriteria',
                    designType: ViewComponentPropertyType.String,
                    enableExpressionEvaluation: true,
                    evaluatorService: this.rxRecordQueryExpressionEvaluatorService
                }
            ],
            name: 'Text',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'field_text',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(TextFieldDesignComponent),
            designComponentModel: TextFieldDesignModel,
            expressionConfigurator: TextFieldExpressionConfigurator,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
TextFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }, { token: i1$4.RxRecordQueryExpressionEvaluatorService }], target: i0.ɵɵFactoryTarget.NgModule });
TextFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldRegistrationModule, imports: [TextFieldModule, TextFieldDesignModule] });
TextFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldRegistrationModule, imports: [[TextFieldModule, TextFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [TextFieldModule, TextFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }, { type: i1$4.RxRecordQueryExpressionEvaluatorService }]; } });

class TextareaFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.character];
    }
}

class TextareaFieldDesignComponent {
}
TextareaFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TextareaFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: TextareaFieldDesignComponent, selector: "rx-textarea-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-textarea\n  class=\"rx-pointer-events-none\"\n  [label]=\"model.label$ | async\"\n  [required]=\"model.isRequired$ | async\"\n  [disabled]=\"true\"\n  ngModel\n  rows=\"3\"\n></adapt-rx-textarea>\n", components: [{ type: i1.AdaptRxTextareaComponent, selector: "adapt-rx-textarea", inputs: ["rows", "maxRows", "autocomplete", "placeholder", "size", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-textarea-field-design',
                    templateUrl: './textarea-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class TextareaFieldDesignModule {
}
TextareaFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TextareaFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldDesignModule, declarations: [TextareaFieldDesignComponent], imports: [CommonModule, AdaptRxTextareaModule, FormsModule] });
TextareaFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldDesignModule, imports: [[CommonModule, AdaptRxTextareaModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptRxTextareaModule, FormsModule],
                    declarations: [TextareaFieldDesignComponent],
                    entryComponents: [TextareaFieldDesignComponent]
                }]
        }] });

class TextareaFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector, rxFieldDefinitionService) {
        super(injector);
        this.rxFieldDefinitionService = rxFieldDefinitionService;
    }
    onConfigInitialized(config) {
        super.onConfigInitialized(config);
        if (this.fieldDefinition.maxLength && !this.rxFieldDefinitionService.isSystemField(this.fieldDefinition)) {
            this.maxLength = this.fieldDefinition.maxLength;
        }
    }
}
TextareaFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldComponent, deps: [{ token: i0.Injector }, { token: i1$5.RxFieldDefinitionService }], target: i0.ɵɵFactoryTarget.Component });
TextareaFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: TextareaFieldComponent, selector: "rx-textarea-field", usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-textarea\n    [formControl]=\"formControl\"\n    [required]=\"isRequired\"\n    [maxlength]=\"maxLength\"\n    [rows]=\"3\"\n    [readonly]=\"isDisabled\"\n    [disabledStyleForReadonlyState]=\"true\"\n    [label]=\"label\"\n    [requiredLabel]=\"'com.bmc.arsys.rx.client.common.required-field.label' | translate\"\n  >\n  </adapt-rx-textarea>\n</ng-template>\n", styles: [":host ::ng-deep textarea{resize:none}:host ::ng-deep rx-read-only-field .read-only-content{max-height:6em;overflow-y:auto;word-break:break-all;white-space:pre-wrap}\n"], components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxTextareaComponent, selector: "adapt-rx-textarea", inputs: ["rows", "maxRows", "autocomplete", "placeholder", "size", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-textarea-field',
                    templateUrl: './textarea-field.component.html',
                    styleUrls: ['./textarea-field.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$5.RxFieldDefinitionService }]; } });

class TextareaFieldModule {
}
TextareaFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TextareaFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldModule, declarations: [TextareaFieldComponent], imports: [CommonModule, ReactiveFormsModule, ReadOnlyFieldModule, TranslateModule, AdaptRxTextareaModule] });
TextareaFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldModule, imports: [[CommonModule, ReactiveFormsModule, ReadOnlyFieldModule, TranslateModule, AdaptRxTextareaModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ReactiveFormsModule, ReadOnlyFieldModule, TranslateModule, AdaptRxTextareaModule],
                    declarations: [TextareaFieldComponent],
                    entryComponents: [TextareaFieldComponent]
                }]
        }] });

class TextareaFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Textarea,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(TextareaFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Textarea',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'area_text',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(TextareaFieldDesignComponent),
            designComponentModel: TextareaFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
TextareaFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
TextareaFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldRegistrationModule, imports: [TextareaFieldModule, TextareaFieldDesignModule] });
TextareaFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldRegistrationModule, imports: [[TextareaFieldModule, TextareaFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TextareaFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [TextareaFieldModule, TextareaFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class TimeFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.timeOnly];
    }
}

class TimeFieldDesignComponent {
    constructor() {
        this.pickerMode = RxDatetimePickerMode.Time;
    }
}
TimeFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TimeFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: TimeFieldDesignComponent, selector: "rx-time-field-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-rx-datetime\n  class=\"rx-pointer-events-none\"\n  [(ngModel)]=\"timeValue\"\n  [required]=\"model.isRequired$ | async\"\n  [disabled]=\"true\"\n  [mode]=\"pickerMode\"\n  [label]=\"model.label$ | async\"\n></adapt-rx-datetime>\n", components: [{ type: i1.AdaptRxDatetimeComponent, selector: "adapt-rx-datetime", inputs: ["placeholder", "inline", "placement", "appendToBody", "inlineLight", "inlineCompact", "dayFilter", "disableWizard", "mode", "hasSeconds", "use12HoursTime", "firstDayOfWeek", "initialDatetime", "defaultDatetime", "disabledStyleForReadonlyState", "popupClass", "texts", "inputFormat"], outputs: ["onPopupOpenChange", "onDatetimeChange"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-time-field-design',
                    templateUrl: './time-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class TimeFieldDesignModule {
}
TimeFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TimeFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldDesignModule, declarations: [TimeFieldDesignComponent], imports: [AdaptRxDatetimeModule, CommonModule, FormsModule] });
TimeFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldDesignModule, imports: [[AdaptRxDatetimeModule, CommonModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [AdaptRxDatetimeModule, CommonModule, FormsModule],
                    declarations: [TimeFieldDesignComponent],
                    entryComponents: [TimeFieldDesignComponent]
                }]
        }] });

class TimeAdapter extends AdaptRxDatetimeAdapter {
    constructor() {
        super(...arguments);
        this.storeTimeFormat = 'HH:mm:ss';
    }
    fromModel(dateString) {
        let adaptedValue = null;
        const date = moment(dateString, 'LTS');
        if (date && date.isValid()) {
            adaptedValue = {
                year: date.year(),
                month: date.month(),
                date: date.date(),
                hours: date.hours(),
                minutes: date.minutes(),
                seconds: date.seconds()
            };
        }
        return adaptedValue;
    }
    toModel(date) {
        return date
            ? date.parseError
                ? moment.invalid().toString()
                : moment({
                    hour: date.hours || 0,
                    minute: date.minutes || 0,
                    seconds: date.seconds || 0
                }).format(this.storeTimeFormat)
            : null;
    }
}
TimeAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
TimeAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeAdapter, decorators: [{
            type: Injectable
        }] });

class TimeFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector, datePipe) {
        super(injector);
        this.datePipe = datePipe;
        this.pickerMode = RxDatetimePickerMode.Time;
    }
    getDisplayValue() {
        var _a;
        const displayValue = super.getDisplayValue();
        if (!displayValue) {
            return '-';
        }
        else {
            const readOnlyTimeValue = moment(displayValue, 'LTS').toDate();
            return (_a = this.datePipe.transform(readOnlyTimeValue, 'mediumTime')) !== null && _a !== void 0 ? _a : '-';
        }
    }
    getFieldValidators() {
        const validatorFn = (control) => {
            const date = control.value ? moment(control.value, 'LTS') : null;
            return control.value && date && !date.isValid()
                ? { rxDatetimeFormat: { mode: this.pickerMode, hasSeconds: true } }
                : null;
        };
        return [validatorFn];
    }
}
TimeFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldComponent, deps: [{ token: i0.Injector }, { token: i3.DatePipe }], target: i0.ɵɵFactoryTarget.Component });
TimeFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: TimeFieldComponent, selector: "rx-time-field", providers: [{ provide: AdaptRxDatetimeAdapter, useClass: TimeAdapter }], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <adapt-rx-datetime\n    [label]=\"label\"\n    [required]=\"isRequired\"\n    [formControl]=\"formControl\"\n    [readonly]=\"isDisabled\"\n    [disabledStyleForReadonlyState]=\"true\"\n    [mode]=\"pickerMode\"\n    hasSeconds=\"true\"\n  ></adapt-rx-datetime>\n</ng-template>\n", components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxDatetimeComponent, selector: "adapt-rx-datetime", inputs: ["placeholder", "inline", "placement", "appendToBody", "inlineLight", "inlineCompact", "dayFilter", "disableWizard", "mode", "hasSeconds", "use12HoursTime", "firstDayOfWeek", "initialDatetime", "defaultDatetime", "disabledStyleForReadonlyState", "popupClass", "texts", "inputFormat"], outputs: ["onPopupOpenChange", "onDatetimeChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-time-field',
                    templateUrl: './time-field.component.html',
                    providers: [{ provide: AdaptRxDatetimeAdapter, useClass: TimeAdapter }]
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i3.DatePipe }]; } });

class TimeFieldModule {
}
TimeFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TimeFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldModule, declarations: [TimeFieldComponent], imports: [AdaptRxDatetimeModule, CommonModule, ReadOnlyFieldModule, TranslateModule, ReactiveFormsModule] });
TimeFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldModule, providers: [DatePipe], imports: [[AdaptRxDatetimeModule, CommonModule, ReadOnlyFieldModule, TranslateModule, ReactiveFormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [AdaptRxDatetimeModule, CommonModule, ReadOnlyFieldModule, TranslateModule, ReactiveFormsModule],
                    declarations: [TimeFieldComponent],
                    providers: [DatePipe],
                    entryComponents: [TimeFieldComponent]
                }]
        }] });

class TimeFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Time,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(TimeFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Time',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'clock_o',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(TimeFieldDesignComponent),
            designComponentModel: TimeFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
TimeFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
TimeFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldRegistrationModule, imports: [TimeFieldModule, TimeFieldDesignModule] });
TimeFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldRegistrationModule, imports: [[TimeFieldModule, TimeFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TimeFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [TimeFieldModule, TimeFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class RxExtensionContainerComponent extends BaseViewComponent {
    constructor(rxRecordDefinitionCacheService, rxRecordDefinitionService) {
        super();
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.rxRecordDefinitionService = rxRecordDefinitionService;
        this.recordDefinitions = {};
    }
    ngOnInit() {
        super.ngOnInit();
        this.config.pipe(takeUntil(this.destroyed$)).subscribe((config) => {
            this.state = config;
        });
    }
    loadRecordDefinition(name) {
        this.rxRecordDefinitionCacheService.getRecordDefinition(name).subscribe((recordDefinition) => {
            recordDefinition.fieldDefinitionsById =
                this.rxRecordDefinitionService.buildFieldDefinitionsByIdMap(recordDefinition);
            this.recordDefinitions[name] = recordDefinition;
            this.notifyPropertyChanged('recordDefinitions', this.recordDefinitions);
        });
    }
}
RxExtensionContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerComponent, deps: [{ token: i1$5.RxRecordDefinitionCacheService }, { token: i1$5.RxRecordDefinitionService }], target: i0.ɵɵFactoryTarget.Component });
RxExtensionContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxExtensionContainerComponent, selector: "rx-extension-container", usesInheritance: true, ngImport: i0, template: "<rx-runtime-view-canvas-outlet [hidden]=\"state.hidden\"></rx-runtime-view-canvas-outlet>\n", components: [{ type: i1$2.RuntimeViewCanvasOutletComponent, selector: "rx-runtime-view-canvas-outlet", inputs: ["name"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-extension-container',
                    templateUrl: './extension-container.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i1$5.RxRecordDefinitionCacheService }, { type: i1$5.RxRecordDefinitionService }]; } });

class RxExtensionContainerHelperService {
    // generate unique expression for 'selectionFieldOptionNamesById' property depending on extension Record editor guid
    getSelectionFieldOptionNamesByIdExpression(guid) {
        return `${guid}:selectionFieldOptionNamesById`;
    }
}
RxExtensionContainerHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerHelperService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
RxExtensionContainerHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerHelperService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerHelperService, decorators: [{
            type: Injectable
        }] });

class ExtensionContainerSectionComponent extends BaseViewComponent {
    constructor(rxExtensionContainerComponent, rxRecordInstanceService, rxRecordEditorUtilsService, rxExtensionContainerHelperService, recordEditorComponent) {
        super();
        this.rxExtensionContainerComponent = rxExtensionContainerComponent;
        this.rxRecordInstanceService = rxRecordInstanceService;
        this.rxRecordEditorUtilsService = rxRecordEditorUtilsService;
        this.rxExtensionContainerHelperService = rxExtensionContainerHelperService;
        this.recordEditorComponent = recordEditorComponent;
        this.isInitialized = false;
        this.selectionFieldOptionNamesById = null;
    }
    ngOnInit() {
        super.ngOnInit();
        // will close once officially fixed : https://github.com/ReactiveX/rxjs/issues/4772
        combineLatest([this.config, this.recordEditorComponent.recordInstanceChanged$.pipe(startWith(null))])
            .pipe(takeUntil(this.destroyed$))
            .subscribe(([config, recordInstanceUpdated]) => {
            if (config.recordDefinitionName) {
                this.rxExtensionContainerComponent.loadRecordDefinition(config.recordDefinitionName);
            }
            if (!config.associationDefinitionName) {
                return (this.isInitialized = true);
            }
            if (config.api) {
                let associatedRecordInstanceId = null;
                if (this.recordEditorComponent.state.mode === RecordEditorMode.Edit) {
                    associatedRecordInstanceId = this.recordEditorComponent.state.recordInstance.id;
                }
                const associationManager = config.api.getAssociationManager({
                    associationDefinitionName: config.associationDefinitionName,
                    associatedRecordNodeSide: RX_ASSOCIATION_DEFINITION.roles.second.value,
                    associatedRecordInstanceId: associatedRecordInstanceId,
                    recordDefinitionName: config.recordDefinitionName,
                    allFieldIds: true,
                    associatedRecordPath: config.associatedRecordPath
                });
                let initialize$;
                if (this.recordEditorComponent.state.mode === RecordEditorMode.Edit) {
                    initialize$ = associationManager.loadExtensions().pipe(switchMap((recordInstance) => {
                        if (isEmpty(associationManager.extensions)) {
                            return this.addNewRecordInstanceToExtension(associationManager);
                        }
                        else {
                            return of(recordInstance);
                        }
                    }));
                }
                else if (this.recordEditorComponent.state.mode === RecordEditorMode.Create ||
                    this.recordEditorComponent.state.mode === RecordEditorMode.Temporary) {
                    initialize$ = forkJoin([
                        associationManager.initialize(),
                        this.addNewRecordInstanceToExtension(associationManager)
                    ]);
                }
                initialize$
                    .pipe(tap(() => {
                    this.isInitialized = true;
                }), switchMap(() => {
                    const recordInstance$ = associationManager.extensions$.pipe(map((arr) => arr[0]), tap((recordInstance) => this.updateSelectionFieldOptionNames(recordInstance)), shareReplay(1));
                    return recordInstance$.pipe(switchMap((inst) => inst.fieldValueChanged$), withLatestFrom(recordInstance$));
                }), takeUntil(this.destroyed$))
                    .subscribe(([change, recordInstance]) => {
                    this.updateSelectionFieldOptionNames(recordInstance);
                });
            }
        });
    }
    addNewRecordInstanceToExtension(associationManager) {
        return this.rxRecordInstanceService.getNew(associationManager.options.recordDefinitionName).pipe(tap((recordInstance) => {
            recordInstance.isNewInstance = true;
            associationManager.addExtension(recordInstance);
        }));
    }
    updateSelectionFieldOptionNames(recordInstance) {
        if (get(recordInstance, 'recordDefinition.fieldDefinitions')) {
            const newSelectionFieldOptionNames = this.rxRecordEditorUtilsService.getSelectionFieldOptionNames(recordInstance.recordDefinition, recordInstance);
            if (!isEqual(this.selectionFieldOptionNamesById, newSelectionFieldOptionNames)) {
                const propName = this.rxExtensionContainerHelperService.getSelectionFieldOptionNamesByIdExpression(this.guid);
                this.rxExtensionContainerComponent.notifyPropertyChanged(propName, newSelectionFieldOptionNames);
            }
        }
    }
}
ExtensionContainerSectionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerSectionComponent, deps: [{ token: RxExtensionContainerComponent }, { token: i1$5.RxRecordInstanceService }, { token: RxRecordEditorUtilsService }, { token: RxExtensionContainerHelperService }, { token: RecordEditorComponent }], target: i0.ɵɵFactoryTarget.Component });
ExtensionContainerSectionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ExtensionContainerSectionComponent, selector: "rx-extension-container-section", usesInheritance: true, ngImport: i0, template: "<h5>{{ (config | async)?.label }}</h5>\n<rx-runtime-view-canvas-outlet *ngIf=\"isInitialized\"></rx-runtime-view-canvas-outlet>\n", components: [{ type: i1$2.RuntimeViewCanvasOutletComponent, selector: "rx-runtime-view-canvas-outlet", inputs: ["name"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerSectionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-extension-container-section',
                    templateUrl: './extension-container-section.component.html'
                }]
        }], ctorParameters: function () { return [{ type: RxExtensionContainerComponent }, { type: i1$5.RxRecordInstanceService }, { type: RxRecordEditorUtilsService }, { type: RxExtensionContainerHelperService }, { type: RecordEditorComponent }]; } });

const RX_EXTENSION_CONTAINER = {
    type: RxViewComponentType.ExtensionContainer,
    recordDefinitionsReferencingExpression: 'recordDefinitions',
    extensionContainerSectionComponent: 'rx-extension-container-section'
};

class RxExtensionContainerDefinitionAdapterService {
    constructor(rxViewDefinitionParserService, rxViewDefinitionDataPageService, rxGlobalCacheService, rxDefinitionNameService, rxTreeService, rxExtensionContainerHelperService, rxNotificationService, rxRuntimeViewUtilsService, rxViewDefinitionLocalizationService, translateService) {
        this.rxViewDefinitionParserService = rxViewDefinitionParserService;
        this.rxViewDefinitionDataPageService = rxViewDefinitionDataPageService;
        this.rxGlobalCacheService = rxGlobalCacheService;
        this.rxDefinitionNameService = rxDefinitionNameService;
        this.rxTreeService = rxTreeService;
        this.rxExtensionContainerHelperService = rxExtensionContainerHelperService;
        this.rxNotificationService = rxNotificationService;
        this.rxRuntimeViewUtilsService = rxRuntimeViewUtilsService;
        this.rxViewDefinitionLocalizationService = rxViewDefinitionLocalizationService;
        this.translateService = translateService;
    }
    adaptDefinition(extensionContainerComponentDefinition, viewDefinition) {
        const targetRecordEditorComponentDefinition = this.getTargetRecordEditorComponentDefinition(viewDefinition, extensionContainerComponentDefinition);
        extensionContainerComponentDefinition.propertiesByName.mode =
            targetRecordEditorComponentDefinition.propertiesByName.mode;
        return this.getExtensionViewDefinitions(extensionContainerComponentDefinition.guid).pipe(map(this.getViewDefinitionMap.bind(this)), map(this.filterDuplicatedRecordEditorComponentDefinitions.bind(this)), map((viewDefinitionMaps) => this.filterIncompatibleRecordEditorComponentDefinitions(viewDefinitionMaps, targetRecordEditorComponentDefinition)), switchMap(this.setRecordEditorLabels.bind(this)), map(this.getExtensionRecordEditorComponentDefinitions.bind(this)), switchMap((extensionRecordEditorComponentDefinitions) => {
            const processAndAddChildrenToExtensionContainer = () => {
                extensionContainerComponentDefinition.componentDefinitions = [];
                extensionContainerComponentDefinition.resourceType =
                    RX_VIEW_DEFINITION.resourceTypes.containerViewComponent;
                forEach(extensionRecordEditorComponentDefinitions, (extensionRecordEditorComponentDefinition) => {
                    // re-assign expression for child Record editor component definitions
                    this.processRecordEditorComponentDefinition(extensionRecordEditorComponentDefinition, targetRecordEditorComponentDefinition, extensionContainerComponentDefinition);
                    extensionContainerComponentDefinition.componentDefinitions.push(this.getExtensionContainerSectionViewComponentDefinition(extensionRecordEditorComponentDefinition, targetRecordEditorComponentDefinition));
                });
                const children = extensionContainerComponentDefinition.componentDefinitions.map((component) => component.guid);
                extensionContainerComponentDefinition.layout = JSON.stringify({
                    outlets: [
                        {
                            name: RX_VIEW_DEFINITION.defaultOutletName,
                            columns: [
                                {
                                    children
                                }
                            ]
                        }
                    ]
                });
                return extensionRecordEditorComponentDefinitions;
            };
            // run adapters for all Record editors and it's children
            const adapters$ = extensionRecordEditorComponentDefinitions.map((recordEditorComponent) => {
                return combineLatest([
                    ...this.rxRuntimeViewUtilsService.runAdaptersForComponents(viewDefinition, recordEditorComponent)
                ]);
            });
            return combineLatest(adapters$).pipe(tap({
                complete: () => processAndAddChildrenToExtensionContainer()
            }));
        }));
    }
    getExtensionViewDefinitions(extensionContainerGuid) {
        return this.rxViewDefinitionDataPageService
            .get({
            params: {
                propertySelection: [
                    'name',
                    'targetExtensionContainerGuid',
                    'targetViewDefinitionName',
                    'componentDefinitions',
                    'localizableStringsByComponentId',
                    'lastUpdateTime'
                ],
                viewType: ViewDefinitionType.Regular,
                targetExtensionContainerGuid: extensionContainerGuid,
                excludeExtensionViews: false
            },
            headers: {
                'default-bundle-scope': ''
            }
        })
            .pipe(map((response) => {
            const associationsInExtensionContainer = [];
            forEach(response.data, (viewDefinition) => {
                var _a;
                this.rxViewDefinitionLocalizationService.applyLocalization(viewDefinition);
                const associationDefinitionName = (_a = viewDefinition.componentDefinitions[0]) === null || _a === void 0 ? void 0 : _a.propertiesByName.associationDefinitionName;
                if (isString(associationDefinitionName)) {
                    if (associationsInExtensionContainer.includes(associationDefinitionName)) {
                        this.rxNotificationService.addWarningMessage(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-editor.extension-container.duplicate-extensions.warning'));
                    }
                    else {
                        associationsInExtensionContainer.push(associationDefinitionName);
                    }
                }
            });
            return response.data;
        }));
    }
    getTargetRecordEditorComponentDefinition(viewDefinition, extensionContainerComponentDefinition) {
        return this.rxViewDefinitionParserService.findParentComponentDefinition(viewDefinition, extensionContainerComponentDefinition, (parentComponentDefinition) => parentComponentDefinition.type === RxViewComponentType.RecordEditor);
    }
    getViewDefinitionMap(viewDefinitions) {
        return reduce(viewDefinitions, (result, viewDefinition) => {
            const recordEditorComponentDefinition = viewDefinition.componentDefinitions[0];
            // View may not contain Record editor component definition because of permission restrictions
            if (recordEditorComponentDefinition) {
                result.push({
                    viewDefinition,
                    recordEditorComponentDefinition
                });
            }
            return result;
        }, []);
    }
    filterDuplicatedRecordEditorComponentDefinitions(viewDefinitionMaps) {
        return values(reduce(viewDefinitionMaps, (result, viewDefinitionMap) => {
            // Allow multiple record editors to be displayed in the extension container if they are bound
            // to the same parent record instance. In this case they have no associationDefinitionName.
            if (!viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.associationDefinitionName) {
                result[viewDefinitionMap.recordEditorComponentDefinition.guid] = viewDefinitionMap;
                return result;
            }
            const key = [
                viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.recordDefinitionName,
                viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.associationDefinitionName
            ].join('');
            if (!result[key]) {
                result[key] = viewDefinitionMap;
            }
            else if (moment(viewDefinitionMap.viewDefinition.lastUpdateTime) < moment(result[key].viewDefinition.lastUpdateTime)) {
                result[key] = viewDefinitionMap;
            }
            return result;
        }, {}));
    }
    filterIncompatibleRecordEditorComponentDefinitions(viewDefinitionMaps, targetRecordEditorComponentDefinition) {
        return filter$1(viewDefinitionMaps, (viewDefinitionMap) => {
            const hasSameMode = viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.mode ===
                targetRecordEditorComponentDefinition.propertiesByName.mode;
            const hasSameRecordDefinitionName = targetRecordEditorComponentDefinition.propertiesByName.recordDefinitionName ===
                viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.recordDefinitionName;
            const hasAssociation = viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.associationDefinitionName;
            const validExtensionWithoutAssociation = hasSameRecordDefinitionName && !hasAssociation && hasSameMode;
            const validExtensionWithAssociation = hasAssociation && hasSameMode;
            return validExtensionWithoutAssociation || validExtensionWithAssociation;
        });
    }
    setRecordEditorLabels(viewDefinitionMaps) {
        return forkJoin([
            ...viewDefinitionMaps.map((viewDefinitionMap) => {
                let label$;
                if (viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.label) {
                    label$ = of(viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.label);
                }
                else {
                    label$ = this.rxGlobalCacheService.getBundleFriendlyName(this.rxDefinitionNameService.getBundleId(viewDefinitionMap.viewDefinition.name));
                }
                return label$.pipe(map((label) => {
                    viewDefinitionMap.recordEditorComponentDefinition.propertiesByName.label = label;
                    return viewDefinitionMap;
                }));
            })
        ]);
    }
    getExtensionRecordEditorComponentDefinitions(viewDefinitionMaps) {
        return map$1(viewDefinitionMaps, 'recordEditorComponentDefinition');
    }
    processRecordEditorComponentDefinition(extensionRecordEditorComponentDefinition, targetRecordEditorComponentDefinition, extensionContainerComponentDefinition) {
        this.rxTreeService
            .flattenTree(extensionRecordEditorComponentDefinition, 'componentDefinitions')
            .forEach((componentDefinition) => {
            this.patchFieldComponentExpressions(componentDefinition, extensionRecordEditorComponentDefinition, targetRecordEditorComponentDefinition, extensionContainerComponentDefinition);
        });
        return extensionRecordEditorComponentDefinition;
    }
    // re-assign all expressions from extension Record editor to target Record editor
    // old path: ${view.components.<extension-record-editor-guid>.recordInstance}
    // new path: ${view.components.<target-record-editor-guid>.recordInstance.associationInstances[<association-definition-name>].extensions[0]}
    patchFieldComponentExpressions(componentDefinition, extensionRecordEditorComponentDefinition, targetRecordEditorComponentDefinition, targetExtensionContainerComponentDefinition) {
        // ${view.components.<target-record-editor-guid>.recordInstance.associationInstances[<association-definition-name>].extensions[0]}
        const recordInstanceReferencingExpression = extensionRecordEditorComponentDefinition.propertiesByName
            .associationDefinitionName
            ? [
                targetRecordEditorComponentDefinition.guid,
                '.',
                "recordInstance.associationInstances['",
                extensionRecordEditorComponentDefinition.propertiesByName.associationDefinitionName,
                "'].",
                RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value,
                '.extensions[0]'
            ].join('')
            : [targetRecordEditorComponentDefinition.guid, '.recordInstance'].join('');
        // ${view.components.<target-record-editor-guid>.recordInstance.associationInstances[<association-definition-name>].extensions[0].recordDefinitionName}
        const recordDefinitionNameReferencingExpression = [
            recordInstanceReferencingExpression,
            '.recordDefinitionName'
        ].join('');
        // ${view.components.<target-extension-container-guid>.recordDefinitions.<extension-record-definition-name>}
        const recordDefinitionReferencingExpression = extensionRecordEditorComponentDefinition.propertiesByName
            .associationDefinitionName
            ? [
                targetExtensionContainerComponentDefinition.guid,
                '.',
                RX_EXTENSION_CONTAINER.recordDefinitionsReferencingExpression,
                "['",
                extensionRecordEditorComponentDefinition.propertiesByName.recordDefinitionName,
                "']"
            ].join('')
            : [targetRecordEditorComponentDefinition.guid, '.recordDefinition'].join('');
        // ${view.components.<target-record-editor-guid>.recordInstance.associationInstances[<association-definition-name>].extensions[0].id}
        const recordInstanceIdReferencingExpression = [recordInstanceReferencingExpression, '.id'].join('');
        let selectionFieldOptionNamesByIdReferencingExpression;
        if (extensionRecordEditorComponentDefinition.propertiesByName.associationDefinitionName) {
            // ${view.components.<target-extension-container-guid>.<extension-record-editor-guid>:selectionFieldOptionNamesById}
            selectionFieldOptionNamesByIdReferencingExpression = [
                targetExtensionContainerComponentDefinition.guid,
                '.',
                this.rxExtensionContainerHelperService.getSelectionFieldOptionNamesByIdExpression(extensionRecordEditorComponentDefinition.guid)
            ].join('');
        }
        else {
            // ${view.components.<targetRecordEditorComponentDefinition>.selectionFieldOptionNamesById}
            selectionFieldOptionNamesByIdReferencingExpression = `${targetRecordEditorComponentDefinition.guid}.selectionFieldOptionNamesById`;
        }
        /*
         * {
         *   regExp - determines the part of the old expression
         *   expression - determines new value which should replace <regExp> match
         * }
         * */
        const expressionMap = [
            // patch record instance id expression
            {
                regExp: new RegExp(extensionRecordEditorComponentDefinition.guid + '.recordInstanceId', 'g'),
                expression: recordInstanceIdReferencingExpression
            },
            // patch record instance expression
            {
                regExp: new RegExp(extensionRecordEditorComponentDefinition.guid + '.recordInstance', 'g'),
                expression: recordInstanceReferencingExpression
            },
            // patch record definition name expression
            {
                regExp: new RegExp(extensionRecordEditorComponentDefinition.guid + '.recordDefinitionName', 'g'),
                expression: recordDefinitionNameReferencingExpression
            },
            // patch record definition name expression
            {
                regExp: new RegExp(extensionRecordEditorComponentDefinition.guid + '.recordDefinition', 'g'),
                expression: recordDefinitionReferencingExpression
            },
            // patch selection field option names by id expression
            {
                regExp: new RegExp(extensionRecordEditorComponentDefinition.guid + '.selectionFieldOptionNamesById', 'g'),
                expression: selectionFieldOptionNamesByIdReferencingExpression
            },
            // patch record editor properties like 'canSave', 'inReadState', 'isValid', 'isDirty'
            // ${view.components.<target-record-editor-guid>.canSave}
            // ${view.components.<target-record-editor-guid>.inReadState} ...
            {
                regExp: new RegExp(`${extensionRecordEditorComponentDefinition.guid}\\.(\\w+)}`, 'g'),
                expression: `${targetRecordEditorComponentDefinition.guid}.$1}`
            }
        ];
        const propertiesToPatch = ['disabled', 'hidden', 'value', 'html'];
        propertiesToPatch
            .filter((propertyName) => isString(componentDefinition.propertiesByName[propertyName]))
            .forEach((propertyName) => {
            forEach(expressionMap, (expressionConfig) => {
                componentDefinition.propertiesByName[propertyName] = componentDefinition.propertiesByName[propertyName].replace(expressionConfig.regExp, expressionConfig.expression);
            });
        });
        componentDefinition.propertiesByName.api = `\${view.components.${targetRecordEditorComponentDefinition.guid}.api}`;
        componentDefinition.propertiesByName.inReadState = `\${view.components.${targetRecordEditorComponentDefinition.guid}.inReadState}`;
        if (extensionRecordEditorComponentDefinition.propertiesByName.associationDefinitionName) {
            componentDefinition.propertiesByName.associatedRecordPath = [
                extensionRecordEditorComponentDefinition.propertiesByName.associationDefinitionName,
                RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value,
                'extensions',
                0
            ];
        }
        if (componentDefinition.propertiesByName.recordInstance) {
            componentDefinition.propertiesByName.recordInstance = [
                '${view.components.',
                recordInstanceReferencingExpression,
                '}'
            ].join('');
        }
        if (componentDefinition.propertiesByName.recordDefinition) {
            componentDefinition.propertiesByName.recordDefinition = [
                '${view.components.',
                recordDefinitionReferencingExpression,
                '}'
            ].join('');
        }
    }
    getExtensionContainerSectionViewComponentDefinition(recordEditorComponentDefinition, targetRecordEditorComponentDefinition) {
        return {
            guid: recordEditorComponentDefinition.guid,
            type: RX_EXTENSION_CONTAINER.extensionContainerSectionComponent,
            layout: recordEditorComponentDefinition.layout,
            resourceType: RX_VIEW_DEFINITION.resourceTypes.containerViewComponent,
            componentDefinitions: recordEditorComponentDefinition.componentDefinitions,
            propertiesByName: {
                label: recordEditorComponentDefinition.propertiesByName.label,
                styles: recordEditorComponentDefinition.propertiesByName.styles,
                recordDefinitionName: recordEditorComponentDefinition.propertiesByName.recordDefinitionName,
                associationDefinitionName: recordEditorComponentDefinition.propertiesByName.associationDefinitionName,
                [RX_AVAILABLE_ON_DEVICES_PROP_NAME]: recordEditorComponentDefinition.propertiesByName[RX_AVAILABLE_ON_DEVICES_PROP_NAME],
                api: `\${view.components.${targetRecordEditorComponentDefinition.guid}.api}`,
                associatedRecordPath: [
                    recordEditorComponentDefinition.propertiesByName.associationDefinitionName,
                    RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value,
                    'extensions',
                    0
                ]
            }
        };
    }
}
RxExtensionContainerDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerDefinitionAdapterService, deps: [{ token: i1$4.RxViewDefinitionParserService }, { token: i1$4.RxViewDefinitionDataPageService }, { token: i1$1.RxGlobalCacheService }, { token: i1$1.RxDefinitionNameService }, { token: i2$1.RxTreeService }, { token: RxExtensionContainerHelperService }, { token: i1$1.RxNotificationService }, { token: i1$2.RxRuntimeViewUtilsService }, { token: i1$4.RxViewDefinitionLocalizationService }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Injectable });
RxExtensionContainerDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerDefinitionAdapterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$4.RxViewDefinitionParserService }, { type: i1$4.RxViewDefinitionDataPageService }, { type: i1$1.RxGlobalCacheService }, { type: i1$1.RxDefinitionNameService }, { type: i2$1.RxTreeService }, { type: RxExtensionContainerHelperService }, { type: i1$1.RxNotificationService }, { type: i1$2.RxRuntimeViewUtilsService }, { type: i1$4.RxViewDefinitionLocalizationService }, { type: i2.TranslateService }]; } });

class RxExtensionContainerModule {
    constructor(rxDefinitionAdapterRegistryService, rxExtensionContainerDefinitionAdapterService) {
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.rxExtensionContainerDefinitionAdapterService = rxExtensionContainerDefinitionAdapterService;
        rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RX_EXTENSION_CONTAINER.type, this.rxExtensionContainerDefinitionAdapterService);
    }
}
RxExtensionContainerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: RxExtensionContainerDefinitionAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
RxExtensionContainerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerModule, declarations: [RxExtensionContainerComponent, ExtensionContainerSectionComponent], imports: [CommonModule, RuntimeViewCanvasModule], exports: [RxExtensionContainerComponent] });
RxExtensionContainerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerModule, providers: [RxExtensionContainerDefinitionAdapterService, RxExtensionContainerHelperService], imports: [[CommonModule, RuntimeViewCanvasModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExtensionContainerModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [RxExtensionContainerDefinitionAdapterService, RxExtensionContainerHelperService],
                    declarations: [RxExtensionContainerComponent, ExtensionContainerSectionComponent],
                    exports: [RxExtensionContainerComponent],
                    entryComponents: [RxExtensionContainerComponent, ExtensionContainerSectionComponent],
                    imports: [CommonModule, RuntimeViewCanvasModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: RxExtensionContainerDefinitionAdapterService }]; } });

class ExtensionContainerDesignModel extends ViewDesignerComponentModel {
    constructor(injector, sandbox) {
        super(injector, sandbox);
        this.injector = injector;
        this.sandbox = sandbox;
        this.componentProperties$ = this.sandbox.componentProperties$;
        this.parentGuid$ = this.sandbox.getParentComponentGuid(RxViewComponentType.RecordEditor).pipe(take(1));
        this.initialProperties = Object.assign({ name: '', recordDefinition: '', recordInstance: '' }, RX_STANDARD_PROPS_DEFAULT_VALUES);
        combineLatest([this.parentGuid$, this.componentProperties$])
            .pipe(first())
            .subscribe(([parentGuid, componentProperties]) => {
            const properties = Object.assign(Object.assign(Object.assign({}, this.initialProperties), componentProperties), { recordInstance: `\${view.components.${parentGuid}.recordInstance}`, recordDefinition: `\${view.components.${parentGuid}.recordDefinition}` });
            this.sandbox.updateComponentProperties(properties);
            this.sandbox.updateInspectorConfig(this.getInspectorConfig());
        });
        combineLatest([
            this.sandbox.getComponentPropertyValue('name').pipe(map((value) => {
                if (isEmpty(value)) {
                    return this.sandbox.createError('Name cannot be blank.', 'name');
                }
            })),
            this.sandbox.getComponentPropertyValue('styles').pipe(map(validateCssClassNames)),
            this.sandbox
                .getComponentPropertyValue(RX_AVAILABLE_ON_DEVICES_PROP_NAME)
                .pipe(map(validateAvailableOnDevicesProp))
        ])
            .pipe(map(flatten), map(compact), takeUntil(this.sandbox.destroyed$))
            .subscribe((validationIssues) => this.sandbox.setValidationIssues(validationIssues));
    }
    getInspectorConfig() {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'name',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Name',
                                required: true,
                                tooltip: new Tooltip('Enter a name to uniquely identify the Extension container')
                            }
                        },
                        ...getStandardPropsInspectorConfigs()
                    ]
                }
            ]
        };
    }
}

class ExtensionContainerDesignComponent {
}
ExtensionContainerDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ExtensionContainerDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ExtensionContainerDesignComponent, selector: "rx-extension-container-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-empty-state type=\"objects\" label=\"Contains fields from extensions of the record definition.\"></adapt-empty-state>\n", components: [{ type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-extension-container-design',
                    templateUrl: './extension-container-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class ExtensionContainerDesignModule {
}
ExtensionContainerDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ExtensionContainerDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerDesignModule, declarations: [ExtensionContainerDesignComponent], imports: [CommonModule, AdaptEmptyStateModule] });
ExtensionContainerDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerDesignModule, imports: [[CommonModule, AdaptEmptyStateModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptEmptyStateModule],
                    declarations: [ExtensionContainerDesignComponent],
                    entryComponents: [ExtensionContainerDesignComponent]
                }]
        }] });

class ExtensionContainerRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService.register({
            type: RX_EXTENSION_CONTAINER.type,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(RxExtensionContainerComponent),
            properties: RX_STANDARD_PROPS_DESC,
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            name: 'Extension container',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            icon: 'widget',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(ExtensionContainerDesignComponent),
            designComponentModel: ExtensionContainerDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        }, {
            type: RX_EXTENSION_CONTAINER.extensionContainerSectionComponent,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(ExtensionContainerSectionComponent),
            properties: [
                {
                    name: 'api',
                    enableExpressionEvaluation: true
                }
            ],
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ]
        });
    }
}
ExtensionContainerRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
ExtensionContainerRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerRegistrationModule, imports: [RxExtensionContainerModule, ExtensionContainerDesignModule] });
ExtensionContainerRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerRegistrationModule, imports: [[RxExtensionContainerModule, ExtensionContainerDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ExtensionContainerRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RxExtensionContainerModule, ExtensionContainerDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class RichTextareaFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.character];
    }
    getInspectorConfig() {
        return super.getInspectorConfig().pipe(withLatestFrom(this.availableFieldDefinitions$), map(([inspectorConfig, recordFieldsSelectItems]) => {
            const availableFields = recordFieldsSelectItems
                .filter((field) => !field.maxLength)
                .map((field) => ({
                id: String(field.id),
                name: field.name
            }));
            const newInspectorConfig = cloneDeep(inspectorConfig);
            newInspectorConfig.inspectorSectionConfigs[0].controls[0].options.options = [...availableFields];
            return newInspectorConfig;
        }));
    }
}

class RichTextareaFieldDesignComponent {
    constructor(rxCkEditorConfiguratorService) {
        this.rxCkEditorConfiguratorService = rxCkEditorConfiguratorService;
        this.ckEditorType = "divarea" /* DIVAREA */;
        this.ckEditorConfig = this.rxCkEditorConfiguratorService.getCKEditorConfig();
    }
}
RichTextareaFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldDesignComponent, deps: [{ token: i1$4.RxCkEditorConfiguratorService }], target: i0.ɵɵFactoryTarget.Component });
RichTextareaFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RichTextareaFieldDesignComponent, selector: "rx-rich-textarea-field-design", inputs: { model: "model" }, ngImport: i0, template: "<div>\n  <strong>\n    {{ model.label$ | async }}\n    <span *ngIf=\"model.isRequired$ | async\" class=\"form-control-required\">(required)</span>\n  </strong>\n</div>\n\n<div class=\"mt-1\">\n  <ckeditor [type]=\"ckEditorType\" [config]=\"ckEditorConfig\" [readOnly]=\"true\"></ckeditor>\n</div>\n", styles: ["ckeditor ::ng-deep .cke_inner{box-shadow:none}\n"], components: [{ type: i2$7.CKEditorComponent, selector: "ckeditor", inputs: ["tagName", "type", "editorUrl", "data", "readOnly", "config"], outputs: ["ready", "dataReady", "change", "dataChange", "dragStart", "dragEnd", "drop", "fileUploadResponse", "fileUploadRequest", "focus", "paste", "afterPaste", "blur"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-rich-textarea-field-design',
                    templateUrl: './rich-textarea-field-design.component.html',
                    styleUrls: ['./rich-textarea-field-design.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxCkEditorConfiguratorService }]; }, propDecorators: { model: [{
                type: Input
            }] } });

class RichTextareaFieldDesignModule {
}
RichTextareaFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RichTextareaFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldDesignModule, declarations: [RichTextareaFieldDesignComponent], imports: [CommonModule, CKEditorModule] });
RichTextareaFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldDesignModule, imports: [[CommonModule, CKEditorModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, CKEditorModule],
                    declarations: [RichTextareaFieldDesignComponent],
                    entryComponents: [RichTextareaFieldDesignComponent]
                }]
        }] });

class RichTextareaFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector, rxCkEditorConfiguratorService) {
        super(injector);
        this.rxCkEditorConfiguratorService = rxCkEditorConfiguratorService;
        this.ckEditorType = "divarea" /* DIVAREA */;
        this.ckEditorConfig = this.rxCkEditorConfiguratorService.getCKEditorConfig();
    }
    setFieldValue(value, options = {}) {
        // When pressing a toolbar button, e.g. Bold, while the field is blank, ckeditor triggers
        // a `dataChange` event with an empty string as data. If we allow this value to be set,
        // it will be converted back to null and result in all toolbar buttons being reset,
        // e.g. the Bold button will be unpressed.
        // As a workaround, we do not accept empty string if the current field value is null.
        if (!(this.formControl.value === null && value === '')) {
            super.setFieldValue(value);
        }
    }
    onBlur() {
        this.formControl.markAsTouched();
    }
}
RichTextareaFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldComponent, deps: [{ token: i0.Injector }, { token: i1$4.RxCkEditorConfiguratorService }], target: i0.ɵɵFactoryTarget.Component });
RichTextareaFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RichTextareaFieldComponent, selector: "rx-rich-textarea-field", usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <div class=\"read-only-content-wrapper focusable\" *ngIf=\"inReadState; else editStateElementRef\" tabindex=\"0\">\n    <label>{{ label }}</label>\n\n    <ckeditor\n      [config]=\"ckEditorConfig\"\n      [type]=\"ckEditorType\"\n      [readOnly]=\"true\"\n      [ngModel]=\"getDisplayValue()\"\n    ></ckeditor>\n  </div>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <div [class.has-danger]=\"adaptRxFeedbackRef.hasUIErrorState\">\n    <adapt-rx-control-label [label]=\"label\" [showRequiredLabel]=\"isRequired\"></adapt-rx-control-label>\n\n    <ckeditor\n      (dataChange)=\"setFieldValue($event)\"\n      [data]=\"formControl.value\"\n      [config]=\"ckEditorConfig\"\n      [type]=\"ckEditorType\"\n      [readOnly]=\"isDisabled\"\n      (blur)=\"onBlur()\"\n    ></ckeditor>\n\n    <adapt-rx-feedback\n      #adaptRxFeedbackRef\n      [errors]=\"formControl.errors\"\n      [controlTouched]=\"formControl.touched\"\n    ></adapt-rx-feedback>\n  </div>\n</ng-template>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}ckeditor ::ng-deep .cke_inner{box-shadow:none}.read-only-content-wrapper ckeditor ::ng-deep .cke{border:none}.read-only-content-wrapper ckeditor ::ng-deep .cke_top{display:none}.read-only-content-wrapper ckeditor ::ng-deep .cke_editable{padding:0}.has-danger ::ng-deep .cke{border-color:#f83200}\n"], components: [{ type: i2$7.CKEditorComponent, selector: "ckeditor", inputs: ["tagName", "type", "editorUrl", "data", "readOnly", "config"], outputs: ["ready", "dataReady", "change", "dataChange", "dragStart", "dragEnd", "drop", "fileUploadResponse", "fileUploadRequest", "focus", "paste", "afterPaste", "blur"] }, { type: i1.AdaptRxControlLabelComponent, selector: "adapt-rx-control-label", inputs: ["for", "id", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"] }, { type: i1.AdaptRxFeedbackComponent, selector: "adapt-rx-feedback", inputs: ["ariaErrorMessage", "errors", "controlTouched", "successMessage", "warningMessage", "alertFeedbackStyle", "alertFeedbackTruncation"], outputs: ["messageAppeared"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-rich-textarea-field',
                    templateUrl: './rich-textarea-field.component.html',
                    styleUrls: ['./rich-textarea-field.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$4.RxCkEditorConfiguratorService }]; } });

class RichTextareaFieldModule {
}
RichTextareaFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RichTextareaFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldModule, declarations: [RichTextareaFieldComponent], imports: [CommonModule, FormsModule, AdaptRxFormControlModule, TranslateModule, ReactiveFormsModule, CKEditorModule] });
RichTextareaFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldModule, imports: [[CommonModule, FormsModule, AdaptRxFormControlModule, TranslateModule, ReactiveFormsModule, CKEditorModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, FormsModule, AdaptRxFormControlModule, TranslateModule, ReactiveFormsModule, CKEditorModule],
                    declarations: [RichTextareaFieldComponent],
                    entryComponents: [RichTextareaFieldComponent]
                }]
        }] });

class RichTextareaFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.RichTextarea,
            properties: RX_BASE_FIELD_PROPERTIES,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(RichTextareaFieldComponent),
            name: 'Rich text area',
            icon: 'text_colorpicker_adapt',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(RichTextareaFieldDesignComponent),
            designComponentModel: RichTextareaFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
RichTextareaFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
RichTextareaFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldRegistrationModule, imports: [RichTextareaFieldDesignModule, RichTextareaFieldModule] });
RichTextareaFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldRegistrationModule, imports: [[RichTextareaFieldDesignModule, RichTextareaFieldModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextareaFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RichTextareaFieldDesignModule, RichTextareaFieldModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class LocalizedCharacterFieldComponent extends BaseRecordEditorFieldComponent {
    constructor(injector, rxModalService, rxLocalizationService) {
        super(injector);
        this.rxModalService = rxModalService;
        this.rxLocalizationService = rxLocalizationService;
    }
    onConfigUpdated(config) {
        super.onConfigUpdated(config);
        const fieldValue = this.getFieldValue();
        this.hideCurrentLocale = this.getFieldInstanceProp('hideCurrentLocale');
        if (config.value === fieldValue) {
            const valueByLocale = this.getFieldInstanceProp('valueByLocale');
            valueByLocale[this.rxLocalizationService.currentLocale] = fieldValue;
            this.setFieldInstanceProp('valueByLocale', valueByLocale);
        }
    }
    shouldShowValidationError() {
        return this.isRequired && !this.formControl.value && (this.formControl.touched || this.formControl.dirty);
    }
    selectLocalizedValue() {
        const valueByLocale = this.getFieldInstanceProp('valueByLocale');
        this.rxModalService
            .openModal({
            title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.localized-character-field.dialog.title'),
            data: {
                fieldDefinition: this.fieldDefinition,
                valueByLocale: cloneDeep(valueByLocale),
                hideCurrentLocale: this.hideCurrentLocale
            },
            size: 'sm',
            content: LocalizedCharacterFieldValueModalComponent
        })
            .then((data) => {
            if (data) {
                this.setLocalizedFieldValue(data.valueByLocale, data.currentLocaleValue);
            }
        })
            .catch(noop);
    }
    setLocalizedFieldValue(valueByLocale, currentLocaleValue) {
        const currentLocaleCode = this.rxLocalizationService.currentLocale;
        const defaultLocaleCode = 'en-US';
        const fieldValue = currentLocaleValue || valueByLocale[currentLocaleCode] || valueByLocale[defaultLocaleCode];
        const currentValueByLocale = this.getFieldInstanceProp('valueByLocale');
        if (!isEqual(valueByLocale, currentValueByLocale)) {
            this.setFieldInstanceProp('valueByLocale', valueByLocale);
            this.formControl.markAsDirty();
            this.recordEditorApi.markAsDirty();
        }
        this.setFieldValue(fieldValue);
    }
}
LocalizedCharacterFieldComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: LocalizedCharacterFieldComponent, deps: [{ token: i0.Injector }, { token: i1$6.RxModalService }, { token: i1$1.RxLocalizationService }], target: i0.ɵɵFactoryTarget.Component });
LocalizedCharacterFieldComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: LocalizedCharacterFieldComponent, selector: "rx-localized-character-field", usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHidden\">\n  <rx-read-only-field\n    *ngIf=\"inReadState; else editStateElementRef\"\n    [label]=\"label\"\n    [value]=\"getDisplayValue()\"\n  ></rx-read-only-field>\n</ng-container>\n\n<ng-template #editStateElementRef>\n  <span class=\"d-flex justify-content-between\" [class.has-danger]=\"formControl.errors && formControl.touched\">\n    <adapt-rx-control-label [label]=\"label\" [id]=\"guid\" [showRequiredLabel]=\"isRequired\"></adapt-rx-control-label>\n\n    <button\n      type=\"button\"\n      class=\"localize-button btn btn-link focusable d-icon-left-pencil p-0\"\n      [disabled]=\"isDisabled\"\n      [attr.aria-describedby]=\"guid\"\n      (click)=\"selectLocalizedValue()\"\n    >\n      {{ 'com.bmc.arsys.rx.client.view-components.localized-character-field.button.localize.label' | translate }}\n    </button>\n  </span>\n\n  <adapt-rx-textfield\n    class=\"mb-0\"\n    [readonly]=\"true\"\n    [formControl]=\"formControl\"\n    [disabledStyleForReadonlyState]=\"true\"\n    [required]=\"isRequired\"\n    [attr.aria-describedby]=\"guid\"\n  >\n  </adapt-rx-textfield>\n</ng-template>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.localize-button:hover{text-decoration:underline}:host ::ng-deep .form-control-feedback{color:#f83200}:host ::ng-deep .has-danger .form-control{border-color:#f83200!important}\n"], components: [{ type: i1$6.ReadOnlyFieldComponent, selector: "rx-read-only-field", inputs: ["label", "value"] }, { type: i1.AdaptRxControlLabelComponent, selector: "adapt-rx-control-label", inputs: ["for", "id", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: LocalizedCharacterFieldComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-localized-character-field',
                    templateUrl: './localized-character-field.component.html',
                    styleUrls: ['./localized-character-field.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$6.RxModalService }, { type: i1$1.RxLocalizationService }]; } });

class RxLocalizedCharacterFieldModule {
}
RxLocalizedCharacterFieldModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxLocalizedCharacterFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxLocalizedCharacterFieldModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxLocalizedCharacterFieldModule, declarations: [LocalizedCharacterFieldComponent], imports: [CommonModule,
        FormsModule,
        AdaptRxFormControlModule,
        ReadOnlyFieldModule,
        AdaptTooltipModule,
        AdaptButtonModule,
        TranslateModule, i1.AdaptBusyModule, RxBusyIndicatorModule,
        AdaptRxTextfieldModule,
        ReactiveFormsModule] });
RxLocalizedCharacterFieldModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxLocalizedCharacterFieldModule, imports: [[
            CommonModule,
            FormsModule,
            AdaptRxFormControlModule,
            ReadOnlyFieldModule,
            AdaptTooltipModule,
            AdaptButtonModule,
            TranslateModule,
            AdaptBusyModule.forRoot(),
            RxBusyIndicatorModule,
            AdaptRxTextfieldModule,
            ReactiveFormsModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxLocalizedCharacterFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        AdaptRxFormControlModule,
                        ReadOnlyFieldModule,
                        AdaptTooltipModule,
                        AdaptButtonModule,
                        TranslateModule,
                        AdaptBusyModule.forRoot(),
                        RxBusyIndicatorModule,
                        AdaptRxTextfieldModule,
                        ReactiveFormsModule
                    ],
                    declarations: [LocalizedCharacterFieldComponent],
                    entryComponents: [LocalizedCharacterFieldComponent]
                }]
        }] });

class LocalizedCharacterFieldDesignModel extends BaseRecordEditorFieldDesign {
    constructor() {
        super(...arguments);
        this.fieldResourceTypes = [RX_RECORD_DEFINITION.resourceTypes.localizedCharacter];
    }
}

class LocalizedCharacterFieldDesignComponent {
}
LocalizedCharacterFieldDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: LocalizedCharacterFieldDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
LocalizedCharacterFieldDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: LocalizedCharacterFieldDesignComponent, selector: "rx-localized-character-field-design", inputs: { model: "model" }, ngImport: i0, template: "<button type=\"button\" class=\"btn float-end p-0 btn-link d-icon-left-pencil\">Localize</button>\n\n<adapt-rx-textfield\n  class=\"rx-pointer-events-none\"\n  [label]=\"model.label$ | async\"\n  [required]=\"model.isRequired$ | async\"\n  [disabled]=\"true\"\n  ngModel\n>\n</adapt-rx-textfield>\n", components: [{ type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: LocalizedCharacterFieldDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-localized-character-field-design',
                    templateUrl: './localized-character-field-design.component.html'
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class RxLocalizedCharacterFieldDesignModule {
}
RxLocalizedCharacterFieldDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxLocalizedCharacterFieldDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxLocalizedCharacterFieldDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxLocalizedCharacterFieldDesignModule, declarations: [LocalizedCharacterFieldDesignComponent], imports: [CommonModule, AdaptRxTextfieldModule, FormsModule] });
RxLocalizedCharacterFieldDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxLocalizedCharacterFieldDesignModule, imports: [[CommonModule, AdaptRxTextfieldModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxLocalizedCharacterFieldDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [LocalizedCharacterFieldDesignComponent],
                    entryComponents: [LocalizedCharacterFieldDesignComponent],
                    imports: [CommonModule, AdaptRxTextfieldModule, FormsModule]
                }]
        }] });

class LocalizedCharacterFieldRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.LocalizedCharacter,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(LocalizedCharacterFieldComponent),
            properties: RX_BASE_FIELD_PROPERTIES,
            name: 'Localized text',
            icon: 'field_text_mapmarker',
            group: RX_FIELD_COMPONENTS.stencilGroupName,
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(LocalizedCharacterFieldDesignComponent),
            designComponentModel: LocalizedCharacterFieldDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
LocalizedCharacterFieldRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: LocalizedCharacterFieldRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
LocalizedCharacterFieldRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: LocalizedCharacterFieldRegistrationModule, imports: [RxLocalizedCharacterFieldModule, RxLocalizedCharacterFieldDesignModule] });
LocalizedCharacterFieldRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: LocalizedCharacterFieldRegistrationModule, imports: [[RxLocalizedCharacterFieldModule, RxLocalizedCharacterFieldDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: LocalizedCharacterFieldRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RxLocalizedCharacterFieldModule, RxLocalizedCharacterFieldDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class FieldComponentsModule {
}
FieldComponentsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldComponentsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FieldComponentsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldComponentsModule, imports: [AssociationRegistrationModule,
        AttachmentFieldRegistrationModule,
        BooleanFieldRegistrationModule,
        DateFieldRegistrationModule,
        DateTimeFieldRegistrationModule,
        DecimalFieldRegistrationModule,
        IntegerFieldRegistrationModule,
        SelectionFieldRegistrationModule,
        TextareaFieldRegistrationModule,
        SelectGroupRegistrationModule,
        TextFieldRegistrationModule,
        TimeFieldRegistrationModule,
        ExtensionContainerRegistrationModule,
        LocalizedCharacterFieldRegistrationModule,
        RichTextareaFieldRegistrationModule], exports: [AssociationRegistrationModule,
        AttachmentFieldRegistrationModule,
        BooleanFieldRegistrationModule,
        DateFieldRegistrationModule,
        DateTimeFieldRegistrationModule,
        DecimalFieldRegistrationModule,
        IntegerFieldRegistrationModule,
        SelectionFieldRegistrationModule,
        TextareaFieldRegistrationModule,
        SelectGroupRegistrationModule,
        TextFieldRegistrationModule,
        TimeFieldRegistrationModule,
        ExtensionContainerRegistrationModule,
        LocalizedCharacterFieldRegistrationModule,
        RichTextareaFieldRegistrationModule] });
FieldComponentsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldComponentsModule, imports: [[
            AssociationRegistrationModule,
            AttachmentFieldRegistrationModule,
            BooleanFieldRegistrationModule,
            DateFieldRegistrationModule,
            DateTimeFieldRegistrationModule,
            DecimalFieldRegistrationModule,
            IntegerFieldRegistrationModule,
            SelectionFieldRegistrationModule,
            TextareaFieldRegistrationModule,
            SelectGroupRegistrationModule,
            TextFieldRegistrationModule,
            TimeFieldRegistrationModule,
            ExtensionContainerRegistrationModule,
            LocalizedCharacterFieldRegistrationModule,
            RichTextareaFieldRegistrationModule
        ], AssociationRegistrationModule,
        AttachmentFieldRegistrationModule,
        BooleanFieldRegistrationModule,
        DateFieldRegistrationModule,
        DateTimeFieldRegistrationModule,
        DecimalFieldRegistrationModule,
        IntegerFieldRegistrationModule,
        SelectionFieldRegistrationModule,
        TextareaFieldRegistrationModule,
        SelectGroupRegistrationModule,
        TextFieldRegistrationModule,
        TimeFieldRegistrationModule,
        ExtensionContainerRegistrationModule,
        LocalizedCharacterFieldRegistrationModule,
        RichTextareaFieldRegistrationModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FieldComponentsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AssociationRegistrationModule,
                        AttachmentFieldRegistrationModule,
                        BooleanFieldRegistrationModule,
                        DateFieldRegistrationModule,
                        DateTimeFieldRegistrationModule,
                        DecimalFieldRegistrationModule,
                        IntegerFieldRegistrationModule,
                        SelectionFieldRegistrationModule,
                        TextareaFieldRegistrationModule,
                        SelectGroupRegistrationModule,
                        TextFieldRegistrationModule,
                        TimeFieldRegistrationModule,
                        ExtensionContainerRegistrationModule,
                        LocalizedCharacterFieldRegistrationModule,
                        RichTextareaFieldRegistrationModule
                    ],
                    exports: [
                        AssociationRegistrationModule,
                        AttachmentFieldRegistrationModule,
                        BooleanFieldRegistrationModule,
                        DateFieldRegistrationModule,
                        DateTimeFieldRegistrationModule,
                        DecimalFieldRegistrationModule,
                        IntegerFieldRegistrationModule,
                        SelectionFieldRegistrationModule,
                        TextareaFieldRegistrationModule,
                        SelectGroupRegistrationModule,
                        TextFieldRegistrationModule,
                        TimeFieldRegistrationModule,
                        ExtensionContainerRegistrationModule,
                        LocalizedCharacterFieldRegistrationModule,
                        RichTextareaFieldRegistrationModule
                    ]
                }]
        }] });

var GridCardLayoutWidth;
(function (GridCardLayoutWidth) {
    GridCardLayoutWidth["Xsmall"] = "450";
    GridCardLayoutWidth["Small"] = "650";
    GridCardLayoutWidth["Medium"] = "800";
    GridCardLayoutWidth["Large"] = "1024";
    GridCardLayoutWidth["Xlarge"] = "1200";
    GridCardLayoutWidth["Xxlarge"] = "1600";
})(GridCardLayoutWidth || (GridCardLayoutWidth = {}));

var RecordGridColumnAlignment;
(function (RecordGridColumnAlignment) {
    RecordGridColumnAlignment["Default"] = "false";
    RecordGridColumnAlignment["Left"] = "Left";
    RecordGridColumnAlignment["Right"] = "Right";
    RecordGridColumnAlignment["Center"] = "Center";
})(RecordGridColumnAlignment || (RecordGridColumnAlignment = {}));

const defaultTypeaheadKeystrokeCount = 1;
const columnProperties = [
    {
        name: 'visible',
        defaultValue: true,
        label: 'Visible'
    },
    {
        name: 'sortable',
        defaultValue: true,
        label: 'Sortable',
        tooltip: new Tooltip('Sorting will be disabled for character fields longer than 4000 characters.')
    },
    {
        name: 'filterable',
        defaultValue: true,
        label: 'Filterable'
    },
    {
        name: 'searchable',
        label: 'Searchable',
        defaultValue: true
    },
    {
        name: 'width',
        label: '',
        defaultValue: null,
        options: {
            label: 'Width',
            defaultUnit: 'px',
            units: [
                {
                    name: 'pixels',
                    id: 'px'
                },
                {
                    name: 'percent',
                    id: '%'
                }
            ],
            stepperOptionByUnits: {
                px: {
                    minValue: 1
                },
                '%': {
                    minValue: 1,
                    maxValue: 100
                }
            }
        }
    },
    {
        name: 'wrapText',
        defaultValue: false,
        label: 'Wrap text'
    },
    {
        name: 'alignment',
        defaultValue: false,
        label: 'Alignment',
        selectionValues: [
            {
                name: 'Align left',
                value: RecordGridColumnAlignment.Left,
                icon: 'd-icon-align_left_adapt'
            },
            {
                name: 'Center',
                value: RecordGridColumnAlignment.Center,
                icon: 'd-icon-align_center_adapt'
            },
            {
                name: 'Align right',
                value: RecordGridColumnAlignment.Right,
                icon: 'd-icon-align_right_adapt'
            }
        ]
    },
    {
        name: 'typeaheadKeystrokeCount',
        label: '',
        defaultValue: defaultTypeaheadKeystrokeCount,
        options: {
            label: 'Typeahead keystroke count',
            options: [
                {
                    id: 0,
                    name: '0'
                },
                {
                    id: 1,
                    name: '1'
                },
                {
                    id: 2,
                    name: '2'
                },
                {
                    id: 3,
                    name: '3'
                },
                {
                    id: 4,
                    name: '4'
                },
                {
                    id: 5,
                    name: '5'
                }
            ],
            emptyOption: false
        }
    }
];
const RX_RECORD_GRID = {
    type: 'rx-record-grid',
    version: '1.0',
    defaultColumnMinWidth: 45,
    defaultRowHeight: 37,
    components: {
        filter: 'rx-record-grid-filter',
        column: 'rx-record-grid-column',
        filterPreset: 'rx-record-grid-filter-preset',
        viewPreset: 'rx-record-grid-view-preset',
        columnViewPreset: 'rx-record-grid-column-view-preset'
    },
    columnAlignment: {
        left: 'Left',
        right: 'Right',
        center: 'Center'
    },
    selectionTypes: {
        multiple: 'multiple',
        single: 'single'
    },
    userPreferences: {
        filters: 'filters',
        columns: 'columns'
    },
    cardLayoutWidthOptions: [
        {
            id: GridCardLayoutWidth.Xsmall,
            name: 'Extra Small (450px)'
        },
        {
            id: GridCardLayoutWidth.Small,
            name: 'Small (650px)'
        },
        {
            id: GridCardLayoutWidth.Medium,
            name: 'Medium (800px)'
        },
        {
            id: GridCardLayoutWidth.Large,
            name: 'Large (1024px)'
        },
        {
            id: GridCardLayoutWidth.Xlarge,
            name: 'Extra Large (1200px)'
        },
        {
            id: GridCardLayoutWidth.Xxlarge,
            name: 'Extra Extra Large (1600px)'
        }
    ],
    actionsColumnProperties: [
        {
            name: 'visible',
            defaultValue: true,
            label: 'Visible'
        }
    ],
    columnProperties,
    sharedFilterPresets: {
        recordDefinitionName: 'Record Grid Filter Presets',
        fields: {
            recordGridGuid: 300000001,
            name: 300000002,
            filterExpression: 300000003,
            sortOrder: 300000004,
            isDefault: 300000005
        }
    },
    defaultFilter: '{}',
    associatedFieldIdPrefixPattern: RX_EXPRESSION_EVALUATOR.associatedFieldIdPrefixPattern,
    defaultPageSize: 50,
    rowActionsOutletName: 'ROW_ACTIONS',
    actionsColumnFieldDefinition: {
        name: 'Actions',
        id: '$ACTIONS$'
    },
    numberOfFiltersOptions: [
        {
            id: 0,
            name: 'None'
        },
        {
            id: 1,
            name: '1'
        },
        {
            id: 2,
            name: '2'
        },
        {
            id: 3,
            name: '3'
        },
        {
            id: 4,
            name: '4'
        },
        {
            id: 5,
            name: '5'
        }
    ],
    defaultTypeaheadKeystrokeCount,
    externalPresetFilterOptionId: '$EXTERNAL_PRESET$'
};

class RxRecordGridUtilsService {
    constructor(rxLogService, rxRecordDefinitionCacheService, stringService, rxDefinitionNameService, rxFieldDefinitionService) {
        this.rxLogService = rxLogService;
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.stringService = stringService;
        this.rxDefinitionNameService = rxDefinitionNameService;
        this.rxFieldDefinitionService = rxFieldDefinitionService;
    }
    getColumnDescriptors(recordDefinitionName, source) {
        return this.rxRecordDefinitionCacheService
            .getRecordDefinition(recordDefinitionName)
            .toPromise()
            .then((recordDefinition) => {
            if (isFunction(source.getColumns)) {
                const columns = source
                    .getColumns()
                    .map((column, index) => ({
                    fieldId: column.field,
                    index,
                    title: column.header,
                    fieldDefinition: column.fieldDefinition
                }));
                return Promise.all(columns
                    .filter((column) => this.isAssociatedRecordFieldId(column.fieldId))
                    .map((column) => this.getAssociationDescriptor(column.fieldId, recordDefinition)
                    .toPromise()
                    .then((associationDescriptor) => {
                    column.associationDescriptor = associationDescriptor;
                }))).then(constant(columns));
            }
            else {
                return recordDefinition.fieldDefinitions.map((fieldDefinition, index) => ({
                    fieldId: fieldDefinition.id,
                    index,
                    title: fieldDefinition.name,
                    fieldDefinition: fieldDefinition
                }));
            }
        });
    }
    getAssociationDescriptors(recordDefinitionName) {
        return forkJoin([
            this.rxRecordDefinitionCacheService.getRecordAssociationDefinitions(recordDefinitionName),
            this.rxRecordDefinitionCacheService.getRecordDefinition(recordDefinitionName)
        ]).pipe(map(([associations, recordDefinition]) => {
            const associationDescriptors = [];
            forEach(associations[recordDefinitionName], (associationDefinition) => {
                const isOneToMany = associationDefinition.cardinality === RX_ASSOCIATION_DEFINITION.cardinality.oneToMany.value;
                const isManyToManyAssociation = associationDefinition.cardinality === RX_ASSOCIATION_DEFINITION.cardinality.manyToMany.value;
                if (!isManyToManyAssociation) {
                    if (this.isNeedSide(associationDefinition.nodeBId, recordDefinitionName, recordDefinition)) {
                        associationDescriptors.push({
                            associationDefinition: associationDefinition,
                            recordDefinitionName: associationDefinition.nodeAId,
                            nodeSide: RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA.value,
                            label: this.getAssociationLabel(associationDefinition, RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA)
                        });
                    }
                    if (this.isNeedSide(associationDefinition.nodeAId, recordDefinitionName, recordDefinition) &&
                        !isOneToMany) {
                        associationDescriptors.push({
                            associationDefinition: associationDefinition,
                            recordDefinitionName: associationDefinition.nodeBId,
                            nodeSide: RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value,
                            label: this.getAssociationLabel(associationDefinition, RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB)
                        });
                    }
                }
            });
            return sortBy(associationDescriptors, 'label');
        }));
    }
    getFieldDefinition(gridColumnFieldId, primaryRecordDefinition) {
        const locator = this.getFieldLocator(gridColumnFieldId);
        const fieldDefinition$ = new AsyncSubject();
        let recordDefinitionPromise;
        if (locator.fieldId === RX_RECORD_GRID.actionsColumnFieldDefinition.id) {
            return of(RX_RECORD_GRID.actionsColumnFieldDefinition);
        }
        else {
            if (locator.associationGuid) {
                recordDefinitionPromise = this.getAssociationDescriptors(primaryRecordDefinition.name)
                    .pipe(map((associationDescriptors) => this.findAssociationDescriptor(associationDescriptors, locator)), filter((associationDescriptor) => Boolean(associationDescriptor)), map((associationDescriptor) => associationDescriptor.associationDefinition[RX_ASSOCIATED_RECORD_NODE_SIDES[associationDescriptor.nodeSide].recordDefinitionNameKey]), switchMap((recordDefinitionName) => {
                    return this.rxRecordDefinitionCacheService.getRecordDefinition(recordDefinitionName);
                }))
                    .toPromise();
            }
            else {
                recordDefinitionPromise = Promise.resolve(primaryRecordDefinition);
            }
            recordDefinitionPromise.then((recordDefinition) => {
                let fieldDefinition;
                if (recordDefinition) {
                    fieldDefinition = find(recordDefinition.fieldDefinitions, {
                        id: Number(locator.fieldId) || locator.fieldId
                    });
                }
                fieldDefinition$.next(fieldDefinition);
                fieldDefinition$.complete();
            });
            return fieldDefinition$;
        }
    }
    isAssociatedRecordFieldId(fieldId) {
        return !some(this.getFieldLocator(fieldId), isUndefined);
    }
    getFieldIdForGridColumn(fieldId, associationDescriptor) {
        return associationDescriptor
            ? `recordContext._associations.${associationDescriptor.associationDefinition.guid}.${associationDescriptor.nodeSide}[0].${fieldId}`
            : String(fieldId);
    }
    getAssociationDescriptor(gridColumnFieldId, primaryRecordDefinition) {
        const locator = this.getFieldLocator(gridColumnFieldId);
        let associationDescriptor = of(null);
        if (locator.associationGuid) {
            associationDescriptor = this.getAssociationDescriptors(primaryRecordDefinition.name).pipe(map((associationDescriptors) => this.findAssociationDescriptor(associationDescriptors, locator)));
        }
        return associationDescriptor;
    }
    getDisplayFieldDescriptor(fieldId, primaryRecordDefinition, associatedRecordDefinitionName) {
        const fieldLocator = this.getFieldLocator(fieldId);
        const fieldDefinition$ = this.isAssociatedRecordFieldId(fieldId)
            ? this.rxRecordDefinitionCacheService.getRecordDefinition(associatedRecordDefinitionName).pipe(map((associatedRecordDefinition) => {
                const isCoreIdField = fieldLocator.fieldId === String(RX_RECORD_DEFINITION.coreFieldIds.id);
                const displayFieldId = String((isCoreIdField && associatedRecordDefinition.displayFieldIdInAssociation) || fieldLocator.fieldId);
                return find(associatedRecordDefinition.fieldDefinitions, (fieldDefinition) => String(fieldDefinition.id) === displayFieldId);
            }))
            : of(find(primaryRecordDefinition.fieldDefinitions, (fieldDefinition) => String(fieldDefinition.id) === fieldId));
        return fieldDefinition$;
    }
    getColumnLabel(fieldDefinition, associationDescriptor) {
        return associationDescriptor ? `${associationDescriptor.label} > ${fieldDefinition.name}` : fieldDefinition.name;
    }
    findAssociationDescriptor(associationDescriptors, locator) {
        return find(associationDescriptors, (associationDescriptor) => {
            return (associationDescriptor.associationDefinition.guid === locator.associationGuid &&
                associationDescriptor.nodeSide === locator.associationNodeSide);
        });
    }
    getFieldLocator(gridColumnFieldId) {
        const match = new RegExp('(?:' + RX_RECORD_GRID.associatedFieldIdPrefixPattern + ')?(.+)').exec(gridColumnFieldId);
        return {
            associationGuid: match[1],
            associationNodeSide: match[2],
            fieldId: match[3]
        };
    }
    isNeedSide(sideName, recordDefinitionName, recordDefinition) {
        return includes([recordDefinitionName, get(recordDefinition, 'inheritanceDescriptor.inheritingFrom')], sideName);
    }
    getAssociationLabel(associationDefinition, nodeSide) {
        let nodeSideName;
        let label = this.rxDefinitionNameService.getDisplayName(associationDefinition.name);
        if (associationDefinition.nodeAId === associationDefinition.nodeBId) {
            if (nodeSide === RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA) {
                nodeSideName = associationDefinition.nodeAName;
            }
            if (nodeSide === RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB) {
                nodeSideName = associationDefinition.nodeBName;
            }
            nodeSideName = nodeSideName || nodeSide.defaultName;
            label += ' (' + nodeSideName + ')';
        }
        return label;
    }
    isSharedFilterPresetTag(tag) {
        return tag.data.isSharedFilterPreset;
    }
    getTestIdForGridColumn(fieldId) {
        if (this.isAssociatedRecordFieldId(fieldId)) {
            const fieldLocator = this.getFieldLocator(fieldId);
            return `field-id-${fieldLocator.associationGuid}-${fieldLocator.fieldId}`;
        }
        else {
            return `field-id-${fieldId}`;
        }
    }
    isSearchable(fieldDefinition, recordDefinition) {
        return (includes([
            RX_RECORD_DEFINITION.dataTypes.character.resourceType,
            RX_RECORD_DEFINITION.dataTypes.localizedCharacter.resourceType,
            RX_RECORD_DEFINITION.dataTypes.integer.resourceType,
            RX_RECORD_DEFINITION.dataTypes.decimal.resourceType,
            RX_RECORD_DEFINITION.dataTypes.real.resourceType
        ], fieldDefinition.resourceType) &&
            !this.rxFieldDefinitionService.isPassword(fieldDefinition) &&
            !this.rxFieldDefinitionService.isSecured(fieldDefinition) &&
            !this.rxFieldDefinitionService.isDataProviderIdField(fieldDefinition, recordDefinition));
    }
}
RxRecordGridUtilsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridUtilsService, deps: [{ token: i1$1.RxLogService }, { token: i1$5.RxRecordDefinitionCacheService }, { token: i2$1.RxStringService }, { token: i1$1.RxDefinitionNameService }, { token: i1$5.RxFieldDefinitionService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridUtilsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridUtilsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridUtilsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxLogService }, { type: i1$5.RxRecordDefinitionCacheService }, { type: i2$1.RxStringService }, { type: i1$1.RxDefinitionNameService }, { type: i1$5.RxFieldDefinitionService }]; } });

var ColumnSortDirection;
(function (ColumnSortDirection) {
    ColumnSortDirection["Asc"] = "asc";
    ColumnSortDirection["Desc"] = "desc";
})(ColumnSortDirection || (ColumnSortDirection = {}));

class RxRecordGridConfigUtilsService {
    constructor(rxJsonParserService) {
        this.rxJsonParserService = rxJsonParserService;
    }
    parseConfigString(str) {
        if (!str) {
            return false;
        }
        if (includes(['1', 'true'], str)) {
            return true;
        }
        if (includes(['0', 'false'], str)) {
            return false;
        }
        if (isString(str)) {
            return this.rxJsonParserService.tryParseJson(str, false);
        }
        if (isObject(str)) {
            return str;
        }
        return isBoolean(str) ? str : false;
    }
    getBooleanValue(str) {
        return this.parseConfigString(str);
    }
    getColumnSortOrder(direction) {
        return direction === ColumnSortDirection.Asc ? SortOrder.Asc : SortOrder.Desc;
    }
    getColumnSortDirection(sortOrder) {
        return sortOrder === SortOrder.Asc ? ColumnSortDirection.Asc : ColumnSortDirection.Desc;
    }
    configDeepClone(configuration) {
        const configClone = cloneDeep(omit(configuration, ['columns']));
        const columns = this.columnsDeepClone(configuration.columns);
        return assign(configClone, { columns });
    }
    columnsDeepClone(columns) {
        return map$1(columns, this.columnDeepClone);
    }
    columnDeepClone(column) {
        const columnClone = cloneDeep(omit(column, ['cellTemplate']));
        return assign(columnClone, { cellTemplate: column.cellTemplate });
    }
}
RxRecordGridConfigUtilsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridConfigUtilsService, deps: [{ token: i2$1.RxJsonParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridConfigUtilsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridConfigUtilsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridConfigUtilsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2$1.RxJsonParserService }]; } });

class ColumnEditorAlignmentComponent {
    trackByForAlignmentOptions(index, alignment) {
        return alignment || index;
    }
}
ColumnEditorAlignmentComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ColumnEditorAlignmentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ColumnEditorAlignmentComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ColumnEditorAlignmentComponent, selector: "rx-column-editor-alignment", inputs: { column: "column", isReadOnly: "isReadOnly", columnProperty: "columnProperty" }, ngImport: i0, template: "<div class=\"btn-group py-2 btn-group-toggle\" data-toggle=\"buttons\">\n  <label\n    class=\"btn btn-sm rounded btn-secondary {{ selectionValue.icon }}\"\n    *ngFor=\"let selectionValue of columnProperty.selectionValues; trackBy: trackByForAlignmentOptions\"\n    [class.active]=\"column.alignment === selectionValue.value\"\n    [class.disabled]=\"isReadOnly\"\n    [adaptTooltip]=\"selectionValue.name\"\n    [attr.rx-id]=\"selectionValue.name\"\n  >\n    <input\n      size=\"small\"\n      type=\"radio\"\n      name=\"selectionValue.name\"\n      [attr.rx-id]=\"selectionValue.value\"\n      [value]=\"selectionValue.value\"\n      [(ngModel)]=\"column.alignment\"\n      [disabled]=\"isReadOnly\"\n    />\n  </label>\n</div>\n", styles: [".alignment-field{min-width:140px}\n"], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.AdaptTooltipDirective, selector: "[adaptTooltip]", inputs: ["popupDelay", "placement", "width", "minWidth", "useWidthFitting", "adaptRadarDisableEventSending", "adaptTooltip", "manual"], outputs: ["shown", "hidden"], exportAs: ["tooltip"] }, { type: i2$3.RadioControlValueAccessor, selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]", inputs: ["name", "formControlName", "value"] }, { type: i2$3.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ColumnEditorAlignmentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-column-editor-alignment',
                    templateUrl: './column-editor-alignment.component.html',
                    styleUrls: ['./column-editor-alignment.component.scss']
                }]
        }], propDecorators: { column: [{
                type: Input
            }], isReadOnly: [{
                type: Input
            }], columnProperty: [{
                type: Input
            }] } });

var RxGridCellFontSize;
(function (RxGridCellFontSize) {
    RxGridCellFontSize["Small"] = "small";
    RxGridCellFontSize["Large"] = "large";
})(RxGridCellFontSize || (RxGridCellFontSize = {}));
var RxGridCellColor;
(function (RxGridCellColor) {
    RxGridCellColor["Primary"] = "primary";
    RxGridCellColor["Secondary"] = "secondary";
    RxGridCellColor["Light"] = "light";
    RxGridCellColor["Active"] = "active";
    RxGridCellColor["Info"] = "info";
    RxGridCellColor["Success"] = "success";
    RxGridCellColor["Warning"] = "warning";
    RxGridCellColor["Danger"] = "danger";
})(RxGridCellColor || (RxGridCellColor = {}));
var RxGridCellIconPosition;
(function (RxGridCellIconPosition) {
    RxGridCellIconPosition["Left"] = "left";
    RxGridCellIconPosition["Right"] = "right";
    RxGridCellIconPosition["ReplaceText"] = "replaceText";
})(RxGridCellIconPosition || (RxGridCellIconPosition = {}));
const RxGridCellFontColorCssMap = {
    [RxGridCellColor.Primary]: 'text-primary',
    [RxGridCellColor.Secondary]: 'text-secondary',
    [RxGridCellColor.Light]: 'text-white',
    [RxGridCellColor.Active]: 'text-active',
    [RxGridCellColor.Info]: 'text-info',
    [RxGridCellColor.Success]: 'text-success',
    [RxGridCellColor.Warning]: 'text-warning',
    [RxGridCellColor.Danger]: 'text-danger'
};
const RxGridCellBgColorCssMap = {
    [RxGridCellColor.Primary]: 'bg-primary',
    [RxGridCellColor.Secondary]: 'bg-secondary',
    [RxGridCellColor.Active]: 'bg-active',
    [RxGridCellColor.Info]: 'bg-info',
    [RxGridCellColor.Success]: 'bg-success',
    [RxGridCellColor.Warning]: 'bg-warning',
    [RxGridCellColor.Danger]: 'bg-danger'
};
const RX_CELL_PROPERTIES = {
    colorsList: [
        {
            label: 'Default',
            value: null
        },
        {
            label: 'Primary',
            value: RxGridCellColor.Primary
        },
        {
            label: 'Secondary',
            value: RxGridCellColor.Secondary
        },
        {
            label: 'Light',
            value: RxGridCellColor.Light
        },
        {
            label: 'Active',
            value: RxGridCellColor.Active
        },
        {
            label: 'Information',
            value: RxGridCellColor.Info
        },
        {
            label: 'Success',
            value: RxGridCellColor.Success
        },
        {
            label: 'Warning',
            value: RxGridCellColor.Warning
        },
        {
            label: 'Danger',
            value: RxGridCellColor.Danger
        }
    ],
    iconPositions: [
        {
            label: 'Left',
            value: RxGridCellIconPosition.Left
        },
        {
            label: 'Right',
            value: RxGridCellIconPosition.Right
        },
        {
            label: 'Replace text',
            value: RxGridCellIconPosition.ReplaceText
        }
    ],
    fontSizes: [
        {
            label: 'Default',
            value: null
        },
        {
            label: 'Small',
            value: RxGridCellFontSize.Small
        },
        {
            label: 'Large',
            value: RxGridCellFontSize.Large
        }
    ]
};

class RecordGridCellDisplayPropertiesExpressionConfigurator extends RxExpressionConfigurator {
    cellDisplayExpressionDataDictionary(columns) {
        if (columns.length) {
            return of(columns.map((column) => ({
                label: column.label,
                icon: 'd-icon-field_text',
                expression: `\${view.components.grid.clickableRow.${column.fieldId}}`,
                resourceType: column.fieldDefinition.resourceType
            })));
        }
        else {
            return of([]);
        }
    }
}

class RecordGridCellDisplayPropertiesEditorComponent extends RxModalClass {
    constructor(activeModalRef, rxExpressionEditorService, formBuilder, translateService, injector) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.rxExpressionEditorService = rxExpressionEditorService;
        this.formBuilder = formBuilder;
        this.translateService = translateService;
        this.injector = injector;
        this.destroyed$ = new ReplaySubject(1);
        this.config = this.activeModalRef.getData();
        this.propsFormArray = this.formBuilder.array([]);
        this.iconPositions = RX_CELL_PROPERTIES.iconPositions;
        this.textColors = RX_CELL_PROPERTIES.colorsList;
        this.fontSizes = RX_CELL_PROPERTIES.fontSizes;
        this.colorsList = RxGridCellBgColorCssMap;
        this.backgroundColors = RX_CELL_PROPERTIES.colorsList.filter((color) => color.value !== RxGridCellColor.Light);
        this.badgeColors = RX_CELL_PROPERTIES.colorsList.filter((color) => ![RxGridCellColor.Light, RxGridCellColor.Active, null].includes(color.value));
        this.iconPickerOptions = {
            label: 'Icon',
            appendToBody: true,
            required: false
        };
    }
    ngOnInit() {
        super.ngOnInit();
        this.expressionConfigurator = new RecordGridCellDisplayPropertiesExpressionConfigurator();
        this.expressionConfigurator.configureForProperty({
            propertyPath: 'cellDisplayProperties',
            dataDictionary$: this.expressionConfigurator.cellDisplayExpressionDataDictionary(this.config.columns),
            operators: this.expressionConfigurator.getOperatorRowsByGroup(ExpressionOperatorGroup.AllClient)
        });
        this.queryExpressionOptions = {
            label: 'Field value condition',
            dataDictionary$: this.expressionConfigurator.getDataDictionary('cellDisplayProperties'),
            operators: this.expressionConfigurator.getOperators('cellDisplayProperties'),
            isRequired: true
        };
        forEach(this.config.cellDisplayProperties, (props) => this.propsFormArray.push(this.getFormGroup(props)));
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
    addCellProperties() {
        this.markAsDirty();
        this.propsFormArray.push(this.getFormGroup({
            fieldValueCondition: '',
            displayAsBadge: false,
            badgeColor: null,
            icon: null,
            iconPosition: null,
            textColor: null,
            backgroundColor: null,
            fontSize: null,
            bold: false,
            italic: false,
            isOpen: true
        }));
        setTimeout(() => {
            this.accordionTabEls.last.nativeElement.scrollIntoView({
                block: 'nearest'
            });
        });
    }
    removeCellProperties(index) {
        this.propsFormArray.removeAt(index);
        this.markAsDirty();
    }
    optionFormatter(selectOption) {
        return selectOption.label;
    }
    getFormGroup(properties) {
        var _a;
        const formGroup = this.formBuilder.group({
            fieldValueCondition: [properties.fieldValueCondition, Validators.required],
            displayAsBadge: [properties.displayAsBadge],
            badgeColor: {
                value: this.getSelectValue(this.badgeColors, 'value', properties.badgeColor),
                disabled: !properties.displayAsBadge
            },
            icon: {
                value: properties.icon,
                disabled: properties.displayAsBadge
            },
            iconPosition: {
                value: this.getSelectValue(this.iconPositions, 'value', properties.iconPosition),
                disabled: !properties.icon
            },
            textColor: {
                value: this.getSelectValue(this.textColors, 'value', properties.textColor),
                disabled: properties.displayAsBadge
            },
            backgroundColor: {
                value: this.getSelectValue(this.backgroundColors, 'value', properties.backgroundColor),
                disabled: properties.displayAsBadge
            },
            fontSize: {
                value: this.getSelectValue(this.fontSizes, 'value', properties.fontSize),
                disabled: properties.displayAsBadge
            },
            bold: [properties.bold],
            italic: [properties.italic],
            isOpen: [(_a = properties.isOpen) !== null && _a !== void 0 ? _a : false]
        });
        formGroup.controls.displayAsBadge.valueChanges
            .pipe(takeUntil(this.destroyed$))
            .subscribe((displayAsBadge) => {
            if (displayAsBadge && formGroup.controls.badgeColor.disabled) {
                formGroup.controls.badgeColor.reset({ value: [this.badgeColors[0]], disabled: false });
            }
            if (!displayAsBadge && formGroup.controls.badgeColor.enabled) {
                formGroup.controls.badgeColor.reset({ value: [], disabled: true });
            }
        });
        formGroup.controls.icon.valueChanges.pipe(takeUntil(this.destroyed$)).subscribe((iconName) => {
            if (iconName && formGroup.controls.iconPosition.disabled) {
                formGroup.controls.iconPosition.reset({ value: [this.iconPositions[0]], disabled: false });
            }
            if (!iconName && formGroup.controls.iconPosition.enabled) {
                formGroup.controls.iconPosition.reset({ value: [], disabled: true });
            }
        });
        return formGroup;
    }
    getSelectValue(optionsList, key, value) {
        const item = optionsList.find((option) => option[key] === value);
        return item ? [item] : [];
    }
    openExpressionEditor(control) {
        this.rxExpressionEditorService
            .openEditor({
            property: {
                path: 'cellDisplayProperties',
                value: control.value,
                label: 'Cell display properties'
            },
            isReadOnly: false,
            expressionConfigurator: this.expressionConfigurator,
            legend: [
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.column.label'),
                    icon: 'd-icon-field_text'
                }
            ]
        })
            .subscribe((expression) => {
            control.setValue(expression.value);
            this.markAsDirty();
        });
    }
    moveCellProperties(fromIndex, toIndex) {
        moveItemInArray(this.propsFormArray.controls, fromIndex, toIndex);
        this.markAsDirty();
    }
    onSelectedCellPropertyDrop(event) {
        moveItemInArray(this.propsFormArray.controls, event.previousIndex, event.currentIndex);
        this.markAsDirty();
    }
    toggleProp(control) {
        control.setValue(!control.value);
        this.markAsDirty();
    }
    toggleOpen(expandAll) {
        this.propsFormArray.controls.forEach((control) => {
            control.get('isOpen').setValue(expandAll);
        });
    }
    resetIconAndTextProps(props) {
        const isDisplayAsBadge = props.get('displayAsBadge').value;
        props.get('icon').reset({ value: null, disabled: isDisplayAsBadge });
        props.get('textColor').reset({ value: [this.textColors[0]], disabled: isDisplayAsBadge });
        props.get('backgroundColor').reset({ value: [this.backgroundColors[0]], disabled: isDisplayAsBadge });
        props.get('fontSize').reset({ value: [this.fontSizes[0]], disabled: isDisplayAsBadge });
        props.get('bold').reset({ value: false, disabled: isDisplayAsBadge });
        props.get('italic').reset({ value: false, disabled: isDisplayAsBadge });
    }
    onSave() {
        const formValues = this.propsFormArray.getRawValue().map((value) => (Object.assign(Object.assign({}, value), { icon: get(value, 'icon', null), badgeColor: get(value, 'badgeColor[0].value', null), iconPosition: get(value, 'iconPosition[0].value', null), textColor: get(value, 'textColor[0].value', null), backgroundColor: get(value, 'backgroundColor[0].value', null), fontSize: get(value, 'fontSize[0].value', null) })));
        const cellProps = formValues.map((value) => (Object.assign({}, omit(value, 'isOpen'))));
        this.activeModalRef.close(cellProps);
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
}
RecordGridCellDisplayPropertiesEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridCellDisplayPropertiesEditorComponent, deps: [{ token: i1.ActiveModalRef }, { token: i2$5.RxExpressionEditorService }, { token: i2$3.FormBuilder }, { token: i2.TranslateService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
RecordGridCellDisplayPropertiesEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridCellDisplayPropertiesEditorComponent, selector: "rx-cell-display-properties-editor", viewQueries: [{ propertyName: "accordionTabEls", predicate: AdaptAccordionTabComponent, descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<div class=\"designer-modal-body modal-body d-flex mh-100\">\n  <div class=\"row flex-grow-1 w-100\">\n    <div class=\"d-flex flex-column mh-100 col\">\n      <div class=\"d-flex align-items-start justify-content-between\">\n        <div>\n          <button\n            *ngIf=\"!config.isReadOnly\"\n            class=\"pl-0 pr-0\"\n            rx-id=\"add-button\"\n            adapt-button\n            type=\"button\"\n            btn-type=\"tertiary\"\n            (click)=\"addCellProperties()\"\n          >\n            <span class=\"d-icon-left-plus_circle\"></span>\n\n            {{ 'com.bmc.arsys.rx.client.view-components.cell-display-properties.add-cell-display-property.button.label' | translate }}\n          </button>\n\n          <span\n            class=\"d-icon-right-question_circle_o ml-1 mt-1\"\n            adaptPopover=\"Cell display properties will be applied based on the first field value condition evaluating to true.\"\n            placement=\"bottom\"\n            appendToBody=\"true\"\n          ></span>\n        </div>\n\n        <div *ngIf=\"propsFormArray.controls.length\" class=\"btn-group\">\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"expand-all-button\"\n            (click)=\"toggleOpen(true)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.expand-all.label' | translate }}\n          </button>\n\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"collapse-all-button\"\n            (click)=\"toggleOpen(false)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.collapse-all.label' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <div\n        *ngIf=\"propsFormArray.controls.length\"\n        id=\"selected-cell-property\"\n        class=\"designer-modal-accordion-wrapper\"\n        cdkDropList\n        (cdkDropListDropped)=\"onSelectedCellPropertyDrop($event)\"\n      >\n        <adapt-accordion [multiselect]=\"true\">\n          <div\n            *ngFor=\"\n              let props of propsFormArray.controls;\n              let index = index;\n              let first = first;\n              let last = last;\n            \"\n            class=\"designer-modal-accordion-content\"\n            cdkDrag\n            cdkDragLockAxis=\"y\"\n            [cdkDragData]=\"props\"\n            [cdkDragDisabled]=\"config.isReadOnly\"\n          >\n            <div *ngIf=\"!config.isReadOnly\" class=\"designer-modal-drag-handle d-icon-left-dots\" cdkDragHandle></div>\n\n            <adapt-accordion-tab\n              class=\"d-block\"\n              [formGroup]=\"props\"\n              [isOpen]=\"props.get('isOpen').value\"\n              (open)=\"props.get('isOpen').setValue(true)\"\n              (close)=\"props.get('isOpen').setValue(false)\"\n            >\n              <div class=\"card-title-text w-100\">\n                <div class=\"designer-modal-card-title-content\">\n                  <div class=\"left-header-block\" [class.pl-0]=\"config.isReadOnly\">\n                    <div class=\"rx-ellipsis\" [title]=\"'Cell display properties ' + (index + 1)\" rx-id=\"card-title\">\n                      Cell display properties {{ index + 1 }}\n                    </div>\n                  </div>\n\n                  <div *ngIf=\"!config.isReadOnly\" class=\"right-header-block\">\n                    <div class=\"designer-modal-card-title-index-buttons\">\n                      <button\n                        class=\"d-icon-left-triangle_down rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"last\"\n                        (click)=\"$event.stopPropagation(); moveCellProperties(index, index + 1)\"\n                        rx-id=\"move-down-button\"\n                      ></button>\n\n                      <button\n                        class=\"d-icon-left-triangle_up rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"first\"\n                        (click)=\"$event.stopPropagation(); moveCellProperties(index, index - 1)\"\n                        rx-id=\"move-up-button\"\n                      ></button>\n                    </div>\n\n                    <button\n                      class=\"d-icon-left-cross_adapt p-1 pr-4 ml-3\"\n                      adapt-button\n                      size=\"small\"\n                      type=\"button\"\n                      (click)=\"$event.stopPropagation(); removeCellProperties(index)\"\n                      rx-id=\"remove-button\"\n                    >\n                      {{ 'com.bmc.arsys.rx.client.common.remove.label' | translate }}\n                    </button>\n                  </div>\n                </div>\n              </div>\n\n              <div class=\"row\">\n                <rx-expression-form-control\n                  formControlName=\"fieldValueCondition\"\n                  class=\"form-group d-block col-12\"\n                  rx-id=\"query-expression-field\"\n                  [options]=\"queryExpressionOptions\"\n                  (events)=\"openExpressionEditor(props.get('fieldValueCondition'))\"\n                ></rx-expression-form-control>\n              </div>\n\n              <div class=\"row form-group\">\n                <div class=\"col-3\">\n                  <adapt-rx-control-label\n                    label=\"{{ 'com.bmc.arsys.rx.client.view-components.cell-display-properties.display-as-badge-field.label' | translate }}\"\n                  ></adapt-rx-control-label>\n\n                  <adapt-rx-switch\n                    [disabled]=\"config.isReadOnly\"\n                    formControlName=\"displayAsBadge\"\n                    (ngModelChange)=\"markAsDirty(); resetIconAndTextProps(props)\"\n                  ></adapt-rx-switch>\n                </div>\n\n                <adapt-rx-select\n                  class=\"d-block col-3\"\n                  label=\"{{ 'com.bmc.arsys.rx.client.view-components.cell-display-properties.badge-color-field.label' | translate }}\"\n                  formControlName=\"badgeColor\"\n                  [disabled]=\"config.isReadOnly\"\n                  [options]=\"badgeColors\"\n                  [optionFormatter]=\"optionFormatter\"\n                  [optionContentTemplate]=\"optionTemplate\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></adapt-rx-select>\n\n                <rx-icon-picker-form-control\n                  class=\"d-block col-3\"\n                  [disabled]=\"config.isReadOnly\"\n                  [options]=\"iconPickerOptions\"\n                  formControlName=\"icon\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></rx-icon-picker-form-control>\n\n                <adapt-rx-select\n                  class=\"d-block col-3\"\n                  label=\"{{ 'com.bmc.arsys.rx.client.view-components.cell-display-properties.icon-position-field.label' | translate }}\"\n                  formControlName=\"iconPosition\"\n                  [disabled]=\"config.isReadOnly\"\n                  [options]=\"iconPositions\"\n                  [optionFormatter]=\"optionFormatter\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></adapt-rx-select>\n              </div>\n\n              <div class=\"row\">\n                <adapt-rx-select\n                  class=\"d-block col-3\"\n                  label=\"{{ 'com.bmc.arsys.rx.client.view-components.cell-display-properties.text-color-field.label' | translate }}\"\n                  formControlName=\"textColor\"\n                  [disabled]=\"config.isReadOnly\"\n                  [options]=\"textColors\"\n                  [optionFormatter]=\"optionFormatter\"\n                  [optionContentTemplate]=\"optionTemplate\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></adapt-rx-select>\n\n                <adapt-rx-select\n                  class=\"d-block col-3\"\n                  label=\"{{ 'com.bmc.arsys.rx.client.view-components.cell-display-properties.background-color-field.label' | translate }}\"\n                  formControlName=\"backgroundColor\"\n                  [disabled]=\"config.isReadOnly\"\n                  [options]=\"backgroundColors\"\n                  [optionFormatter]=\"optionFormatter\"\n                  [optionContentTemplate]=\"optionTemplate\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></adapt-rx-select>\n\n                <adapt-rx-select\n                  class=\"d-block col-3\"\n                  label=\"{{ 'com.bmc.arsys.rx.client.view-components.cell-display-properties.font-size-field.label' | translate }}\"\n                  formControlName=\"fontSize\"\n                  [disabled]=\"config.isReadOnly\"\n                  [options]=\"fontSizes\"\n                  [optionFormatter]=\"optionFormatter\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></adapt-rx-select>\n\n                <div class=\"col-3 pt-4 d-flex align-item-center\">\n                  <div class=\"btn-group btn-group-toggle\" data-toggle=\"buttons\">\n                    <label\n                      class=\"btn btn-secondary d-icon-bold_adapt\"\n                      [ngClass]=\"{\n                        active: props.get('bold').value,\n                        'disabled not-allowed': (props.get('displayAsBadge').value || config.isReadOnly)\n                      }\"\n                    >\n                      <input\n                        (click)=\"toggleProp(props.get('bold'))\"\n                        type=\"checkbox\"\n                        name=\"fontStyle\"\n                        [disabled]=\"props.get('displayAsBadge').value || config.isReadOnly\"\n                      />\n                    </label>\n\n                    <label\n                      class=\"btn btn-secondary ml-2 d-icon-italic_adapt\"\n                      [ngClass]=\"{\n                        active: props.get('italic').value,\n                        'disabled not-allowed': (props.get('displayAsBadge').value || config.isReadOnly)\n                      }\"\n                    >\n                      <input\n                        (click)=\"toggleProp(props.get('italic'))\"\n                        type=\"checkbox\"\n                        name=\"fontStyle\"\n                        [disabled]=\"props.get('displayAsBadge').value || config.isReadOnly\"\n                      />\n                    </label>\n                  </div>\n                </div>\n              </div>\n            </adapt-accordion-tab>\n          </div>\n        </adapt-accordion>\n      </div>\n\n      <div *ngIf=\"!propsFormArray.controls.length\" class=\"d-flex justify-content-center h-100 align-items-center mt-2\">\n        <adapt-empty-state\n          class=\"w-100\"\n          label=\"{{ 'com.bmc.arsys.rx.client.view-components.cell-display-properties.empty-state.message' | translate }}\"\n          type=\"grid\"\n        ></adapt-empty-state>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    *ngIf=\"!config.isReadOnly\"\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"propsFormArray.invalid || !isDirty()\"\n    (click)=\"onSave()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{ config.isReadOnly ? ('com.bmc.arsys.rx.client.common.close.label' | translate) : ('com.bmc.arsys.rx.client.common.cancel.label' | translate) }}\n  </button>\n</div>\n\n<ng-template #optionTemplate let-option>\n  <div class=\"d-flex align-items-center\">\n    <div [ngClass]=\"option.value ? 'color-option-box rounded mr-2 ' + colorsList[option.value] : ''\"></div>\n    {{ option.label }}\n  </div>\n</ng-template>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.designer-modal-body{height:645px;min-height:calc(100% - 61px)!important}.designer-modal-accordion-wrapper{display:flex;flex-direction:column;height:100%;overflow:auto;padding-top:10px}.designer-modal-accordion-content{position:relative}.designer-modal-accordion-content.cdk-drag-preview{z-index:1200!important}.designer-modal-drag-handle{cursor:move;position:absolute;top:0;left:0;height:46px;padding:14px 10px 14px 14px;z-index:1}.designer-modal-card-title-content{width:100%;display:flex}.designer-modal-card-title-content .left-header-block,.designer-modal-card-title-content .right-header-block{display:flex;align-items:center}.designer-modal-card-title-content .left-header-block{flex-grow:1;min-width:0;font-size:14px;padding-left:22px}.designer-modal-card-sub-title{color:#7c7f81;font-weight:normal}.designer-modal-card-title-index-buttons{display:flex;font-size:19px}.rx-card{overflow:auto}.rx-tree-draggable-node{cursor:pointer}.rx-tree-draggable-node.cdk-drag-preview{z-index:1200!important}.rx-tree-draggable-node.cdk-drag{opacity:1}.rx-tree-node-label{word-break:break-all}rx-form-builder{max-width:400px}.color-option-box{display:inline-block;width:20px;height:20px}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i2$5.ExpressionFormControlComponent, selector: "rx-expression-form-control", inputs: ["options", "isDisabled", "propertyPath"], outputs: ["events"] }, { type: i1.AdaptRxControlLabelComponent, selector: "adapt-rx-control-label", inputs: ["for", "id", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"] }, { type: i1.AdaptRxSwitchComponent, selector: "adapt-rx-switch", inputs: ["value", "size", "isLabelBefore", "checked"] }, { type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }, { type: i2$5.IconPickerFormControlComponent, selector: "rx-icon-picker-form-control", inputs: ["options"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.AdaptPopoverDirective, selector: "[adaptPopover]", inputs: ["adaptPopover", "popoverTitle", "placement", "fallbackPlacement", "triggers", "container", "appendToBody", "closeBtn", "popupDelay", "disablePopover", "popoverClass", "autoClose", "closeOnOutOfView", "maxWidth", "minWidth"], outputs: ["shown", "hidden"], exportAs: ["adaptPopover"] }, { type: i8.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "id", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListAutoScrollDisabled", "cdkDropListOrientation", "cdkDropListLockAxis", "cdkDropListData", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragDisabled", "cdkDragStartDelay", "cdkDragLockAxis", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragBoundary", "cdkDragRootElement", "cdkDragPreviewContainer", "cdkDragData", "cdkDragFreeDragPosition"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i8.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { type: i2$3.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i2$3.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridCellDisplayPropertiesEditorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-cell-display-properties-editor',
                    templateUrl: './cell-display-properties-editor.component.html',
                    styleUrls: ['./cell-display-properties-editor.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i2$5.RxExpressionEditorService }, { type: i2$3.FormBuilder }, { type: i2.TranslateService }, { type: i0.Injector }]; }, propDecorators: { accordionTabEls: [{
                type: ViewChildren,
                args: [AdaptAccordionTabComponent, { read: ElementRef }]
            }] } });

class RecordGridCellDisplayPropertiesComponent extends ValueAccessor {
    constructor(rxModalService) {
        super();
        this.rxModalService = rxModalService;
    }
    openPropertiesEditor() {
        this.rxModalService
            .openModal({
            title: `Edit cell display properties for ${this.columnName}`,
            data: {
                cellDisplayProperties: this.value ? cloneDeep(this.value) : [],
                isReadOnly: this.isDisabled,
                columns: this.columns
            },
            content: RecordGridCellDisplayPropertiesEditorComponent,
            size: OpenViewActionModalSize.Large,
            testID: 'edit-cell-display-properties'
        })
            .then((properties) => {
            this.value = properties;
        })
            .catch(noop);
    }
}
RecordGridCellDisplayPropertiesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridCellDisplayPropertiesComponent, deps: [{ token: i1$6.RxModalService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridCellDisplayPropertiesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridCellDisplayPropertiesComponent, selector: "rx-cell-display-properties", inputs: { columnName: "columnName", columns: "columns" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: RecordGridCellDisplayPropertiesComponent,
            multi: true
        }
    ], usesInheritance: true, ngImport: i0, template: "<adapt-button rx-id=\"open-modal-button\" btn-type=\"tertiary\" class=\"px-0 py-0\" (click)=\"openPropertiesEditor()\">\n  <adapt-icon name=\"plus_circle\" class=\"mr-1\"></adapt-icon>\n  Edit cell display properties\n</adapt-button>\n\n<div rx-id=\"columns\">\n  <span *ngIf=\"!value?.length\" class=\"text-tertiary\">No cell display properties added.</span>\n  <span *ngIf=\"value?.length > 0\" class=\"text-tertiary\">Cell display properties added.</span>\n</div>\n", components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptIconComponent, selector: "adapt-icon", inputs: ["name", "classList", "description", "testID"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridCellDisplayPropertiesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-cell-display-properties',
                    templateUrl: './cell-display-properties.component.html',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: RecordGridCellDisplayPropertiesComponent,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i1$6.RxModalService }]; }, propDecorators: { columnName: [{
                type: Input
            }], columns: [{
                type: Input
            }] } });

const RX_RECORD_GRID_DESIGN = {
    keywords: {
        label: 'Keywords',
        children: [
            {
                label: 'Current user',
                icon: 'd-icon-dollar',
                expression: '$USER$'
            },
            {
                label: 'Current date',
                icon: 'd-icon-dollar',
                expression: '$DATE$'
            },
            {
                label: 'Current time',
                icon: 'd-icon-dollar',
                expression: '$TIME$'
            },
            {
                label: 'Current date and time',
                icon: 'd-icon-dollar',
                expression: '$TIMESTAMP$'
            },
            {
                label: 'Current week day',
                icon: 'd-icon-dollar',
                expression: '$WEEKDAY$'
            },
            {
                label: 'Current groups',
                icon: 'd-icon-dollar',
                expression: '$GROUPS$'
            },
            {
                label: 'Current group IDs',
                icon: 'd-icon-dollar',
                expression: '$GROUPIDS$'
            },
            {
                label: 'Current roles',
                icon: 'd-icon-dollar',
                expression: '$ROLES$'
            },
            {
                label: 'Current user locale',
                icon: 'd-icon-dollar',
                expression: '$LOCALE$'
            },
            {
                label: 'Current server URL',
                icon: 'd-icon-dollar',
                expression: '$SERVERURL$'
            },
            {
                label: 'NULL',
                icon: 'd-icon-dollar',
                expression: '$NULL$',
                hidden: true
            }
        ]
    }
};

class NamedFilterOptionExpressionConfigurator extends RxViewExpressionConfigurator {
    constructor(injector, activeModalRef, rxViewDataDictionaryService, rxDefaultExpressionEvaluatorService) {
        super(injector);
        this.injector = injector;
        this.activeModalRef = activeModalRef;
        this.rxViewDataDictionaryService = rxViewDataDictionaryService;
        this.rxDefaultExpressionEvaluatorService = rxDefaultExpressionEvaluatorService;
        this.commonDataDictionary$ = this.rxViewDataDictionaryService.commonDataDictionary$.pipe(map((dataDictionary) => [
            {
                expression: `'${this.activeModalRef.getData().column.fieldId}'`,
                icon: 'd-icon-file_o_gear',
                label: this.activeModalRef.getData().column.title
            },
            RX_RECORD_GRID_DESIGN.keywords,
            // removing 'General' and 'Functions' groups from data dictionary.
            ...dataDictionary.slice(2)
        ]));
    }
    getExpressionEvaluator() {
        return this.rxDefaultExpressionEvaluatorService;
    }
}
NamedFilterOptionExpressionConfigurator.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: NamedFilterOptionExpressionConfigurator, deps: [{ token: i0.Injector }, { token: i1.ActiveModalRef }, { token: i1$3.RxViewDataDictionaryService }, { token: i1$4.RxDefaultExpressionEvaluatorService }], target: i0.ɵɵFactoryTarget.Injectable });
NamedFilterOptionExpressionConfigurator.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: NamedFilterOptionExpressionConfigurator });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: NamedFilterOptionExpressionConfigurator, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.ActiveModalRef }, { type: i1$3.RxViewDataDictionaryService }, { type: i1$4.RxDefaultExpressionEvaluatorService }]; } });

class RecordGridNamedFilterOptionsEditorModalComponent extends RxModalClass {
    constructor(activeModalRef, rxGuidService, rxExpressionEditorService, formBuilder, translateService, expressionConfigurator, injector) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.rxGuidService = rxGuidService;
        this.rxExpressionEditorService = rxExpressionEditorService;
        this.formBuilder = formBuilder;
        this.translateService = translateService;
        this.expressionConfigurator = expressionConfigurator;
        this.config = this.activeModalRef.getData();
        this.namedFilterOptionsFormArray = this.formBuilder.array([]);
        this.accordionTabs = {};
    }
    ngOnInit() {
        super.ngOnInit();
        this.expressionConfigurator.configureForProperty({
            propertyPath: 'namedFilterOptions',
            operators: ExpressionOperatorRowsByGroup.get(ExpressionOperatorGroup.All)
        });
        this.queryExpressionOptions = {
            label: 'Filter',
            dataDictionary$: this.expressionConfigurator.getDataDictionary('namedFilterOptions'),
            operators: this.expressionConfigurator.getOperators('namedFilterOptions'),
            isRequired: true
        };
        forEach(this.config.namedFilterOptions, (props, index) => {
            this.accordionTabs[props.guid] = index === this.config.activeIndex;
            this.namedFilterOptionsFormArray.push(this.getFormGroup(props));
        });
        if (this.config.isReadOnly) {
            this.namedFilterOptionsFormArray.disable();
        }
    }
    ngAfterViewInit() {
        if (this.config.activeIndex) {
            this.accordionTabEls.toArray()[this.config.activeIndex].nativeElement.scrollIntoView({
                block: 'nearest'
            });
        }
    }
    addNamedFilterOption() {
        this.markAsDirty();
        const guid = this.rxGuidService.generate();
        this.accordionTabs[guid] = true;
        let title = 'New filter option';
        let counter = 0;
        let titleAlreadyExists = false;
        const titles = map$1(this.namedFilterOptionsFormArray.getRawValue(), 'title');
        do {
            title = counter === 0 ? title : `New filter option ${counter}`;
            counter++;
            titleAlreadyExists = includes(titles, title);
        } while (titleAlreadyExists);
        this.namedFilterOptionsFormArray.push(this.getFormGroup({
            data: {
                title,
                filterExpression: '',
                index: this.namedFilterOptionsFormArray.length
            },
            guid
        }));
        setTimeout(() => {
            this.accordionTabEls.last.nativeElement.scrollIntoView({
                block: 'nearest'
            });
        });
    }
    removeNamedFilterOption(index) {
        this.namedFilterOptionsFormArray.removeAt(index);
        this.markAsDirty();
    }
    openExpressionEditor(title, filterExpression) {
        this.rxExpressionEditorService
            .openEditor({
            property: {
                path: 'namedFilterOptions',
                value: filterExpression.value,
                label: title.value
            },
            isReadOnly: false,
            expressionConfigurator: this.expressionConfigurator,
            legend: [
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.keyword.label'),
                    icon: 'd-icon-dollar'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.view-component-property.label'),
                    icon: 'd-icon-file_o_gear'
                }
            ]
        })
            .subscribe((expression) => {
            filterExpression.setValue(expression.value);
            this.markAsDirty();
        });
    }
    moveNamedFilterOption(fromIndex, toIndex) {
        moveItemInArray(this.namedFilterOptionsFormArray.controls, fromIndex, toIndex);
        this.markAsDirty();
    }
    onSelectedNamedFilterOptionDrop(event) {
        moveItemInArray(this.namedFilterOptionsFormArray.controls, event.previousIndex, event.currentIndex);
        this.markAsDirty();
    }
    onSave() {
        const formValues = this.namedFilterOptionsFormArray.getRawValue();
        const namedFilterOptions = formValues.map(({ guid, title, filterExpression }, index) => ({
            guid,
            data: {
                title,
                filterExpression,
                index
            }
        }));
        this.activeModalRef.close(namedFilterOptions);
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
    toggleOpen(expandAll) {
        forEach(this.accordionTabs, (val, key) => {
            this.accordionTabs[key] = expandAll;
        });
    }
    getCheckTitleDuplicateValidator(currentNamedFilterOption) {
        return (control) => {
            const title = control.value;
            if (title &&
                this.namedFilterOptionsFormArray.controls.some((namedFilterOption) => namedFilterOption.value.title === title && namedFilterOption.value.guid !== currentNamedFilterOption.guid)) {
                return { duplicateFilterOptionName: { message: 'Filter option with this name already exists.' } };
            }
            return null;
        };
    }
    getFormGroup(properties) {
        return this.formBuilder.group({
            guid: properties.guid,
            title: [
                properties.data.title,
                [
                    Validators.required,
                    this.getCheckTitleDuplicateValidator(properties).bind(this),
                    (control) => {
                        var _a;
                        return ((_a = control === null || control === void 0 ? void 0 : control.value) === null || _a === void 0 ? void 0 : _a.includes(';'))
                            ? { invalidName: { message: 'A filter option name cannot contain any of the following characters: ;' } }
                            : null;
                    }
                ]
            ],
            filterExpression: [properties.data.filterExpression, Validators.required]
        });
    }
}
RecordGridNamedFilterOptionsEditorModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridNamedFilterOptionsEditorModalComponent, deps: [{ token: i1.ActiveModalRef }, { token: i2$1.RxGuidService }, { token: i2$5.RxExpressionEditorService }, { token: i2$3.FormBuilder }, { token: i2.TranslateService }, { token: NamedFilterOptionExpressionConfigurator }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
RecordGridNamedFilterOptionsEditorModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridNamedFilterOptionsEditorModalComponent, selector: "rx-named-filter-options-editor-modal", providers: [NamedFilterOptionExpressionConfigurator], viewQueries: [{ propertyName: "accordionTabEls", predicate: AdaptAccordionTabComponent, descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<div class=\"designer-modal-body modal-body d-flex mh-100\">\n  <div class=\"row flex-grow-1 w-100\">\n    <div class=\"d-flex flex-column mh-100 col\">\n      <div class=\"d-flex align-items-start justify-content-between\">\n        <button\n          *ngIf=\"!config.isReadOnly\"\n          class=\"mt-2 p-0\"\n          rx-id=\"add-button\"\n          adapt-button\n          type=\"button\"\n          btn-type=\"tertiary\"\n          (click)=\"addNamedFilterOption()\"\n        >\n          <span class=\"d-icon-left-plus_circle\"></span>\n\n          {{\n            'com.bmc.arsys.rx.client.view-components.named-filter-options.add-named-filter-option.button.label'\n              | translate\n          }}\n        </button>\n\n        <div *ngIf=\"namedFilterOptionsFormArray.controls.length\" class=\"btn-group\">\n          <button adapt-button btn-type=\"tertiary\" type=\"button\" rx-id=\"expand-all-button\" (click)=\"toggleOpen(true)\">\n            {{ 'com.bmc.arsys.rx.client.common.expand-all.label' | translate }}\n          </button>\n\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"collapse-all-button\"\n            (click)=\"toggleOpen(false)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.collapse-all.label' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <div\n        *ngIf=\"namedFilterOptionsFormArray.controls.length\"\n        class=\"designer-modal-accordion-wrapper\"\n        cdkDropList\n        (cdkDropListDropped)=\"onSelectedNamedFilterOptionDrop($event)\"\n      >\n        <adapt-accordion [multiselect]=\"true\">\n          <div\n            *ngFor=\"\n              let namedFilterOption of namedFilterOptionsFormArray.controls;\n              let index = index;\n              let first = first;\n              let last = last\n            \"\n            class=\"designer-modal-accordion-content\"\n            cdkDrag\n            cdkDragLockAxis=\"y\"\n            [cdkDragData]=\"namedFilterOption\"\n            [cdkDragDisabled]=\"config.isReadOnly\"\n          >\n            <div *ngIf=\"!config.isReadOnly\" class=\"designer-modal-drag-handle d-icon-left-dots\" cdkDragHandle></div>\n\n            <adapt-accordion-tab\n              class=\"d-block\"\n              [formGroup]=\"namedFilterOption\"\n              [isOpen]=\"accordionTabs[namedFilterOption.get('guid').value]\"\n            >\n              <div class=\"card-title-text w-100\">\n                <div class=\"designer-modal-card-title-content\">\n                  <div class=\"left-header-block\" [class.pl-0]=\"config.isReadOnly\">\n                    <div class=\"rx-ellipsis\" [title]=\"namedFilterOption.get('title').value\" rx-id=\"card-title\">\n                      {{ namedFilterOption.get('title').value }}\n                    </div>\n                  </div>\n\n                  <div *ngIf=\"!config.isReadOnly\" class=\"right-header-block\">\n                    <div class=\"designer-modal-card-title-index-buttons\">\n                      <button\n                        class=\"d-icon-left-triangle_down rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"last\"\n                        (click)=\"$event.stopPropagation(); moveNamedFilterOption(index, index + 1)\"\n                        rx-id=\"move-down-button\"\n                      ></button>\n\n                      <button\n                        class=\"d-icon-left-triangle_up rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"first\"\n                        (click)=\"$event.stopPropagation(); moveNamedFilterOption(index, index - 1)\"\n                        rx-id=\"move-up-button\"\n                      ></button>\n                    </div>\n\n                    <button\n                      class=\"d-icon-left-cross_adapt p-1 pr-4 ml-3\"\n                      adapt-button\n                      size=\"small\"\n                      type=\"button\"\n                      (click)=\"$event.stopPropagation(); removeNamedFilterOption(index)\"\n                      rx-id=\"remove-button\"\n                    >\n                      {{ 'com.bmc.arsys.rx.client.common.remove.label' | translate }}\n                    </button>\n                  </div>\n                </div>\n              </div>\n\n              <adapt-rx-textfield\n                class=\"form-group d-block\"\n                rx-id=\"filter-option-name-field\"\n                label=\"{{\n                  'com.bmc.arsys.rx.client.view-components.named-filter-options.name-field.label' | translate\n                }}\"\n                formControlName=\"title\"\n                [required]=\"true\"\n                (ngModelChange)=\"markAsDirty()\"\n                rxNoWhitespace\n              ></adapt-rx-textfield>\n\n              <rx-expression-form-control\n                formControlName=\"filterExpression\"\n                rx-id=\"query-expression-field\"\n                [options]=\"queryExpressionOptions\"\n                (events)=\"\n                  openExpressionEditor(namedFilterOption.get('title'), namedFilterOption.get('filterExpression'))\n                \"\n                [required]=\"true\"\n                (ngModelChange)=\"markAsDirty()\"\n              ></rx-expression-form-control>\n            </adapt-accordion-tab>\n          </div>\n        </adapt-accordion>\n      </div>\n\n      <div\n        *ngIf=\"!namedFilterOptionsFormArray.controls.length\"\n        class=\"d-flex justify-content-center h-100 align-items-center mt-2\"\n      >\n        <adapt-empty-state\n          class=\"w-100\"\n          label=\"{{ 'com.bmc.arsys.rx.client.view-components.named-filter-options.empty-state.message' | translate }}\"\n          type=\"search\"\n        ></adapt-empty-state>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    *ngIf=\"!config.isReadOnly\"\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"this.namedFilterOptionsFormArray.invalid || !isDirty()\"\n    (click)=\"onSave()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{\n      config.isReadOnly\n        ? ('com.bmc.arsys.rx.client.common.close.label' | translate)\n        : ('com.bmc.arsys.rx.client.common.cancel.label' | translate)\n    }}\n  </button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.designer-modal-body{height:645px;min-height:calc(100% - 61px)!important}.designer-modal-accordion-wrapper{display:flex;flex-direction:column;height:100%;overflow:auto;padding-top:10px}.designer-modal-accordion-content{position:relative}.designer-modal-accordion-content.cdk-drag-preview{z-index:1200!important}.designer-modal-drag-handle{cursor:move;position:absolute;top:0;left:0;height:46px;padding:14px 10px 14px 14px;z-index:1}.designer-modal-card-title-content{width:100%;display:flex}.designer-modal-card-title-content .left-header-block,.designer-modal-card-title-content .right-header-block{display:flex;align-items:center}.designer-modal-card-title-content .left-header-block{flex-grow:1;min-width:0;font-size:14px;padding-left:22px}.designer-modal-card-sub-title{color:#7c7f81;font-weight:normal}.designer-modal-card-title-index-buttons{display:flex;font-size:19px}.rx-card{overflow:auto}.rx-tree-draggable-node{cursor:pointer}.rx-tree-draggable-node.cdk-drag-preview{z-index:1200!important}.rx-tree-draggable-node.cdk-drag{opacity:1}.rx-tree-node-label{word-break:break-all}rx-form-builder{max-width:400px}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: i2$5.ExpressionFormControlComponent, selector: "rx-expression-form-control", inputs: ["options", "isDisabled", "propertyPath"], outputs: ["events"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "id", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListAutoScrollDisabled", "cdkDropListOrientation", "cdkDropListLockAxis", "cdkDropListData", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragDisabled", "cdkDragStartDelay", "cdkDragLockAxis", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragBoundary", "cdkDragRootElement", "cdkDragPreviewContainer", "cdkDragData", "cdkDragFreeDragPosition"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i8.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { type: i2$3.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i2$3.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i2$1.RxNoWhitespaceValidator, selector: "[rxNoWhitespace]", inputs: ["rxNoWhitespace"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridNamedFilterOptionsEditorModalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-named-filter-options-editor-modal',
                    templateUrl: './named-filter-options-editor-modal.component.html',
                    styleUrls: ['./named-filter-options-editor-modal.component.scss'],
                    providers: [NamedFilterOptionExpressionConfigurator]
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i2$1.RxGuidService }, { type: i2$5.RxExpressionEditorService }, { type: i2$3.FormBuilder }, { type: i2.TranslateService }, { type: NamedFilterOptionExpressionConfigurator }, { type: i0.Injector }]; }, propDecorators: { accordionTabEls: [{
                type: ViewChildren,
                args: [AdaptAccordionTabComponent, { read: ElementRef }]
            }] } });

class RecordGridNamedFilterOptionsComponent extends ValueAccessor {
    constructor(rxModalService) {
        super();
        this.rxModalService = rxModalService;
    }
    openNamedFilterOptions(activeIndex) {
        this.rxModalService
            .openModal({
            title: `Edit named filter options for ${this.column.title}`,
            data: {
                namedFilterOptions: this.value ? cloneDeep(this.value) : [],
                isReadOnly: this.isDisabled,
                activeIndex,
                column: this.column
            },
            content: RecordGridNamedFilterOptionsEditorModalComponent,
            size: OpenViewActionModalSize.Large,
            testID: 'edit-named-filter-options'
        })
            .then((namedFilterOptions) => {
            this.value = namedFilterOptions;
        })
            .catch(noop);
    }
    editNamedFilterOption(activeIndex) {
        this.openNamedFilterOptions(activeIndex);
    }
    removeFilterOption(namedFilterOption) {
        this.value = without(this.value, namedFilterOption);
    }
}
RecordGridNamedFilterOptionsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridNamedFilterOptionsComponent, deps: [{ token: i1$6.RxModalService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridNamedFilterOptionsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridNamedFilterOptionsComponent, selector: "rx-named-filter-options", inputs: { column: "column", tooltip: "tooltip" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: RecordGridNamedFilterOptionsComponent,
            multi: true
        }
    ], usesInheritance: true, ngImport: i0, template: "<adapt-button rx-id=\"open-modal-button\" btn-type=\"tertiary\" class=\"px-0 py-0 pb-1\" (click)=\"openNamedFilterOptions()\">\n  <adapt-icon name=\"plus_circle\" class=\"mr-1\"></adapt-icon>\n  Edit named filter options\n</adapt-button>\n\n<span *ngIf=\"tooltip\" class=\"align-middle\">\n  <span class=\"letter-space\"></span>\n  <adapt-icon [name]=\"'question_circle_o'\" [adaptPopover]=\"tooltip\" appendToBody=\"true\"></adapt-icon>\n</span>\n\n<div rx-id=\"named-filter-options\">\n  <div *ngIf=\"!value?.length\" class=\"text-tertiary\">No named filter options added.</div>\n  <ul class=\"list-unstyled mb-0\" *ngIf=\"value?.length > 0\">\n    <li class=\"border px-2 py-1 mb-1 d-flex align-items-center\" *ngFor=\"let option of value; let index = index\">\n      <strong class=\"mr-auto text-break\">{{ option.data.title }}</strong>\n\n      <button\n        class=\"d-icon-left-pencil p-1\"\n        adapt-button\n        btn-type=\"tertiary\"\n        size=\"small\"\n        type=\"button\"\n        (click)=\"editNamedFilterOption(index)\"\n        rx-id=\"edit-button\"\n      ></button>\n\n      <button\n        class=\"d-icon-left-cross_adapt p-1\"\n        adapt-button\n        btn-type=\"tertiary\"\n        size=\"small\"\n        type=\"button\"\n        *ngIf=\"!isDisabled\"\n        (click)=\"removeFilterOption(option)\"\n        rx-id=\"remove-button\"\n      ></button>\n    </li>\n  </ul>\n</div>\n", components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptIconComponent, selector: "adapt-icon", inputs: ["name", "classList", "description", "testID"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.AdaptPopoverDirective, selector: "[adaptPopover]", inputs: ["adaptPopover", "popoverTitle", "placement", "fallbackPlacement", "triggers", "container", "appendToBody", "closeBtn", "popupDelay", "disablePopover", "popoverClass", "autoClose", "closeOnOutOfView", "maxWidth", "minWidth"], outputs: ["shown", "hidden"], exportAs: ["adaptPopover"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridNamedFilterOptionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-named-filter-options',
                    templateUrl: './named-filter-options.component.html',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: RecordGridNamedFilterOptionsComponent,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i1$6.RxModalService }]; }, propDecorators: { column: [{
                type: Input
            }], tooltip: [{
                type: Input
            }] } });

class RecordGridColumnEditorModalComponent extends RxModalClass {
    constructor(activeModalRef, rxModalService, definitionNameService, rxRecordGridUtilsService, rxFieldDefinitionService, rxRecordDefinitionCacheService, rxGuidService, ngZone, injector, translateService, rxExpressionEditorService) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.rxModalService = rxModalService;
        this.definitionNameService = definitionNameService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxFieldDefinitionService = rxFieldDefinitionService;
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.rxGuidService = rxGuidService;
        this.ngZone = ngZone;
        this.injector = injector;
        this.translateService = translateService;
        this.rxExpressionEditorService = rxExpressionEditorService;
        this.columnProperties = RX_RECORD_GRID.columnProperties;
        this.actionsColumnProperties = RX_RECORD_GRID.actionsColumnProperties;
        this.filteredColumns = [];
        this.availableColumnsTree = [];
        this.startedLoadingAssociationDescriptors = false;
        this.treeWrap = TreeWrap.WrapAll;
        this.columnWidthPropertyOptions = this.columnProperties.find(({ name }) => name === 'width').options;
        this.typeaheadKeystrokeCountOptions = Object.assign(Object.assign({}, this.columnProperties.find(({ name }) => name === 'typeaheadKeystrokeCount').options), { tooltip: new Tooltip(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-column.keystroke-count.tooltip')) });
        const params = this.activeModalRef.getData().columnParams;
        this.activeColumn = params.activeColumn;
        this.activeActionIndex = params.activeActionIndex;
        this.recordDefinition = params.recordDefinition;
        this.isReadOnly = params.isReadOnly;
        this.columns = params.columns
            .map((column) => {
            const additionalQueryCriteriaExpressionOptions = column.fieldDefinition.namedListDefinition
                ? this.getAdditionalQueryCriteriaExpressionOptions(column)
                : null;
            return Object.assign(Object.assign({}, column), { isOpen: column === this.activeColumn, label: this.rxRecordGridUtilsService.getColumnLabel(column.fieldDefinition, column.associationDescriptor), clickable: !isEmpty(column.actions), additionalQueryCriteriaExpressionOptions });
        })
            .sort((a, b) => a.index - b.index);
        this.getAvailableColumnsTree();
    }
    ngAfterViewInit() {
        this.updateSelectedColumnsDropList();
        this.openActiveAction();
        const openGridColumnIndex = findIndex(this.columns, 'isOpen');
        if (openGridColumnIndex !== -1) {
            this.accordionTabEls.toArray()[openGridColumnIndex].nativeElement.scrollIntoView({
                block: 'nearest'
            });
        }
    }
    isActionsColumn(fieldId) {
        return fieldId === RX_RECORD_GRID.actionsColumnFieldDefinition.id;
    }
    updateSelectedColumnsDropList() {
        this.updateColumnsDropList(this.draggableSelectedColumns, this.selectedColumnsDropList);
    }
    updateAssociatedAvailableColumnsDropList() {
        this.updateColumnsDropList(this.draggableAssociatedAvailableColumns, this.associatedAvailableColumnsDropList);
    }
    updateColumnsDropList(draggableColumnsList, dropList) {
        // Workaround: update due to injection bug with the adapt-accordion and adapt-tree
        const draggableColumns = draggableColumnsList.toArray();
        const columns = this.columns;
        draggableColumns.sort((column1, column2) => {
            return columns.indexOf(column1.data) - columns.indexOf(column2.data);
        });
        dropList._dropListRef.withItems(draggableColumns.map((drag) => {
            const dragRef = drag._dragRef;
            if (!dragRef._initialContainer) {
                dragRef._initialContainer = dropList._dropListRef;
            }
            return drag._dragRef;
        }));
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
    onDropInSelectedColumnsContainer(event) {
        if (event.previousContainer !== event.container && this.isColumnEditorAvailableColumn(event.item.data)) {
            this.addColumn(event.item.data, event.currentIndex);
        }
        else if (event.previousIndex !== event.currentIndex) {
            this.moveColumn(event.previousIndex, event.currentIndex);
        }
    }
    onColumnCheckboxPropertyChange(value, column, columnProperty) {
        if (columnProperty.name === 'filterable' && column.fieldDefinition.namedListDefinition) {
            if (value) {
                column.typeaheadKeystrokeCount = RX_RECORD_GRID.defaultTypeaheadKeystrokeCount;
            }
            else {
                column.typeaheadKeystrokeCount = null;
                column.additionalQueryCriteria = null;
            }
        }
        this.markAsDirty();
    }
    onColumnDragStarted() {
        this.updateSelectedColumnsDropList();
    }
    onAssociatedAvailableColumnsDragStarted() {
        this.onColumnDragStarted();
        this.updateAssociatedAvailableColumnsDropList();
    }
    isColumnEditorAvailableColumn(column) {
        return Boolean(column.fieldDefinitionName);
    }
    moveColumn(fromIndex, toIndex) {
        this.markAsDirty();
        moveItemInArray(this.columns, fromIndex, toIndex);
        this.updateColumnIndexes();
    }
    removeColumn(index) {
        this.markAsDirty();
        const column = this.columns[index];
        this.columns.splice(index, 1);
        const associatedAvailableColumnsNode = column.associationDescriptor
            ? this.getAssociatedAvailableColumnsNode(column.associationDescriptor.label)
            : this.availableColumnsTree[0];
        // variable can be null when we want remove column, but associations are not loaded yet
        if (associatedAvailableColumnsNode && associatedAvailableColumnsNode.data.allAvailableColumns) {
            associatedAvailableColumnsNode.data.allAvailableColumns.push(this.getColumnMetadata(column.fieldDefinition, column.associationDescriptor));
            this.updateAvailableColumnsTree();
        }
    }
    getAssociatedAvailableColumnsNode(associationDescriptorLabel) {
        return this.availableColumnsTree.find((associatedAvailableColumn) => associatedAvailableColumn.data.associationDescriptor &&
            associatedAvailableColumn.data.associationDescriptor.label === associationDescriptorLabel);
    }
    getAvailableColumnsTree() {
        const recordNode = {
            children: null,
            leaf: false,
            expanded: true,
            expandedIcon: 'd-icon-file_text',
            collapsedIcon: 'd-icon-file_text',
            label: this.definitionNameService.getDisplayName(this.recordDefinition.name),
            key: this.definitionNameService.getDisplayName(this.recordDefinition.name),
            data: {
                allAvailableColumns: null
            }
        };
        if (!this.startedLoadingAssociationDescriptors) {
            this.startedLoadingAssociationDescriptors = true;
            this.rxRecordGridUtilsService
                .getAssociationDescriptors(this.recordDefinition.name)
                .subscribe((associationDescriptors) => {
                associationDescriptors = associationDescriptors.slice();
                associationDescriptors.sort((descriptor1, descriptor2) => descriptor1.label.localeCompare(descriptor2.label));
                this.availableColumnsTree = associationDescriptors.map((associationDescriptor) => {
                    return {
                        children: null,
                        leaf: false,
                        expandedIcon: 'd-icon-arrow_schema',
                        collapsedIcon: 'd-icon-arrow_schema',
                        label: associationDescriptor.label,
                        key: associationDescriptor.associationDefinition.name,
                        data: {
                            associationDescriptor,
                            allAvailableColumns: null
                        }
                    };
                });
                this.availableColumnsTree.unshift(recordNode);
                this.availableColumnsTree.forEach((node) => {
                    this.onNodeExpand({ node });
                });
            });
        }
    }
    updateAvailableColumnsTree() {
        this.availableColumnsTree.forEach((node) => {
            const allAvailableColumns = node.data.allAvailableColumns;
            if (allAvailableColumns) {
                const availableColumns = this.sortAvailableColumns(allAvailableColumns);
                const definitionName = node.data.associationDescriptor
                    ? node.data.associationDescriptor.associationDefinition.name
                    : this.recordDefinition.name;
                node.children = availableColumns.map((availableColumn) => {
                    return {
                        children: null,
                        leaf: true,
                        label: availableColumn.fieldDefinitionName,
                        key: `${definitionName}-${availableColumn.fieldDefinition.id}`,
                        data: {
                            availableColumn
                        }
                    };
                });
            }
        });
    }
    onNodeExpand({ node }) {
        const associationDescriptor = node.data.associationDescriptor;
        if (associationDescriptor && !node.data.allAvailableColumns) {
            node.data.allAvailableColumns = [];
            this.rxRecordDefinitionCacheService
                .getRecordDefinition(associationDescriptor.recordDefinitionName)
                .subscribe((recordDefinition) => {
                node.data.allAvailableColumns = this.getAvailableColumns(recordDefinition, associationDescriptor);
                this.updateAvailableColumnsTree();
            });
        }
        else if (!associationDescriptor) {
            node.data.allAvailableColumns = this.getAvailableColumns(this.recordDefinition);
            this.updateAvailableColumnsTree();
        }
    }
    addColumn(availableColumn, insertIndex) {
        this.markAsDirty();
        if (!find(this.columns, (column) => column.fieldId === availableColumn.fieldId)) {
            const additionalQueryCriteriaExpressionOptions = availableColumn.fieldDefinition.namedListDefinition
                ? this.getAdditionalQueryCriteriaExpressionOptions(availableColumn)
                : null;
            const newColumn = Object.assign(Object.assign({}, this.getColumnEditorColumnData(availableColumn)), { additionalQueryCriteriaExpressionOptions });
            if (isNil(insertIndex)) {
                this.columns.push(newColumn);
            }
            else {
                this.columns.splice(insertIndex, 0, newColumn);
            }
            this.updateColumnIndexes();
            this.removeFromAvailableColumns(availableColumn);
            setTimeout(() => {
                this.accordionTabEls.toArray()[insertIndex !== null && insertIndex !== void 0 ? insertIndex : this.columns.length - 1].nativeElement.scrollIntoView();
            });
        }
    }
    getColumnEditorColumnData(availableColumn) {
        const column = {
            guid: this.rxGuidService.generate(),
            label: availableColumn.label,
            fieldId: availableColumn.fieldId,
            associationDescriptor: availableColumn.associationDescriptor,
            fieldDefinition: availableColumn.fieldDefinition,
            actions: [],
            title: availableColumn.fieldDefinitionName,
            isOpen: true
        };
        forEach(RX_RECORD_GRID.columnProperties, (columnProperty) => {
            if (columnProperty.name === 'sortable') {
                column.sortable = availableColumn.isSortable;
            }
            else if (columnProperty.name === 'searchable') {
                column.searchable = this.rxRecordGridUtilsService.isSearchable(availableColumn.fieldDefinition, this.recordDefinition);
            }
            else {
                column[columnProperty.name] = columnProperty.defaultValue;
            }
        });
        return column;
    }
    removeFromAvailableColumns(column) {
        if (column.associationDescriptor) {
            const associatedAvailableColumnsNode = this.getAssociatedAvailableColumnsNode(column.associationDescriptor.label);
            remove(associatedAvailableColumnsNode.data.allAvailableColumns, column);
        }
        else {
            remove(this.availableColumnsTree[0].data.allAvailableColumns, column);
        }
        this.updateAvailableColumnsTree();
    }
    sortAvailableColumns(availableColumns) {
        this.filteredColumns = availableColumns.sort((column1, column2) => column1.fieldDefinitionName.localeCompare(column2.fieldDefinitionName));
        return this.filteredColumns;
    }
    getAvailableColumns(recordDefinition, associationDescriptor) {
        return recordDefinition.fieldDefinitions
            .map((fieldDefinition) => this.getColumnMetadata(fieldDefinition, associationDescriptor))
            .filter((availableColumn) => !find(this.columns, (column) => column.fieldId === availableColumn.fieldId));
    }
    getColumnMetadata(fieldDefinition, associationDescriptor) {
        return {
            fieldDefinitionName: fieldDefinition.name,
            label: this.rxRecordGridUtilsService.getColumnLabel(fieldDefinition, associationDescriptor),
            fieldId: this.rxRecordGridUtilsService.getFieldIdForGridColumn(fieldDefinition.id, associationDescriptor),
            isSortable: this.rxFieldDefinitionService.isSortable(fieldDefinition),
            associationDescriptor,
            fieldDefinition
        };
    }
    saveChanges() {
        const result = {
            columns: this.columns.map((column) => {
                const isFilterableColumnWithNamedList = column.filterable && column.fieldDefinition.namedListDefinition;
                return {
                    actions: column.actions,
                    alignment: column.alignment,
                    fieldId: column.fieldId,
                    filterable: column.filterable,
                    filterType: column.filterType,
                    guid: column.guid,
                    index: column.index,
                    sortable: column.sortable,
                    searchable: column.searchable,
                    title: column.title,
                    visible: column.visible,
                    associationDescriptor: column.associationDescriptor,
                    fieldDefinition: column.fieldDefinition,
                    cellDisplayProperties: column.cellDisplayProperties,
                    namedFilterOptions: column.namedFilterOptions,
                    width: column.width,
                    wrapText: column.wrapText,
                    typeaheadKeystrokeCount: isFilterableColumnWithNamedList ? column.typeaheadKeystrokeCount : null,
                    additionalQueryCriteria: isFilterableColumnWithNamedList ? column.additionalQueryCriteria : null
                };
            })
        };
        this.activeModalRef.close(result);
    }
    trackByForColumns(index, column) {
        return column.fieldId;
    }
    trackByForColumnProperties(index, columnProperty) {
        return columnProperty.name;
    }
    isPropertyEditable(column, propertyName) {
        if (propertyName === 'searchable') {
            return (!this.isReadOnly && this.rxRecordGridUtilsService.isSearchable(column.fieldDefinition, this.recordDefinition));
        }
        else {
            return !this.isReadOnly;
        }
    }
    updateColumnIndexes() {
        this.columns.forEach((column, index) => {
            column.index = index;
        });
    }
    openActiveAction() {
        if (this.activeColumn && this.activeActionIndex >= 0) {
            this.ngZone.runOutsideAngular(() => {
                // timeout is required to let control set initial value
                setTimeout(() => {
                    const listControl = this.actionListControlComponents.find((control) => control.value === this.activeColumn.actions);
                    if (listControl) {
                        listControl.focus({ actionIndex: this.activeActionIndex });
                    }
                });
            });
        }
    }
    isTreeEmpty() {
        return every(this.availableColumnsTree, (node) => node.data.allAvailableColumns.length === 0);
    }
    openAdditionalQueryCriteriaExpressionEditor(column, control) {
        const namedListFilterExpressionConfigurator = new NamedListFilterExpressionConfigurator(column.fieldDefinition, this.injector);
        this.rxExpressionEditorService
            .openEditor({
            property: {
                path: 'additionalQueryCriteria',
                value: column.additionalQueryCriteria,
                label: 'Additional named list filter'
            },
            isReadOnly: this.isReadOnly,
            expressionConfigurator: namedListFilterExpressionConfigurator,
            legend: [
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.function.label'),
                    icon: 'd-icon-mathematical_function'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.keyword.label'),
                    icon: 'd-icon-dollar'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.view-component.label'),
                    icon: 'd-icon-file_o'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.view-component-property.label'),
                    icon: 'd-icon-file_o_gear'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.view-input-parameter.label'),
                    icon: 'd-icon-arrow_right_square_input'
                }
            ]
        })
            .subscribe((expression) => {
            column.additionalQueryCriteria = expression.value;
            control.value = expression.value;
            control.onWriteValue(expression.value);
            this.markAsDirty();
        });
    }
    getAdditionalQueryCriteriaExpressionOptions(column) {
        const namedListFilterExpressionConfigurator = new NamedListFilterExpressionConfigurator(column.fieldDefinition, this.injector);
        return {
            label: 'Additional named list filter',
            tooltip: new Tooltip('Build a filter to apply at runtime in addition to the filter, if any, specified in the named list definition.'),
            dataDictionary$: namedListFilterExpressionConfigurator.getDataDictionary(),
            operators: namedListFilterExpressionConfigurator.getOperators()
        };
    }
}
RecordGridColumnEditorModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridColumnEditorModalComponent, deps: [{ token: i1.ActiveModalRef }, { token: i1$6.RxModalService }, { token: i1$1.RxDefinitionNameService }, { token: RxRecordGridUtilsService }, { token: i1$5.RxFieldDefinitionService }, { token: i1$5.RxRecordDefinitionCacheService }, { token: i2$1.RxGuidService }, { token: i0.NgZone }, { token: i0.Injector }, { token: i2.TranslateService }, { token: i2$5.RxExpressionEditorService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridColumnEditorModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridColumnEditorModalComponent, selector: "ng-component", viewQueries: [{ propertyName: "selectedColumnsDropList", first: true, predicate: ["selectedColumnsDropList"], descendants: true, read: CdkDropList }, { propertyName: "associatedAvailableColumnsDropList", first: true, predicate: ["associatedAvailableColumnsDropList"], descendants: true, read: CdkDropList }, { propertyName: "draggableSelectedColumns", predicate: ["draggableSelectedColumn"], descendants: true, read: CdkDrag }, { propertyName: "draggableAssociatedAvailableColumns", predicate: ["draggableAssociatedAvailableColumn"], descendants: true, read: CdkDrag }, { propertyName: "actionListControlComponents", predicate: ActionListControlComponent, descendants: true }, { propertyName: "accordionTabEls", predicate: AdaptAccordionTabComponent, descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<div class=\"designer-modal-body modal-body d-flex mh-100\">\n  <div class=\"row flex-grow-1 w-100\">\n    <div *ngIf=\"!isReadOnly\" class=\"col-4 border-right d-flex flex-column mh-100\">\n      <div class=\"d-flex align-items-start justify-content-between\">\n        <h4 class=\"mt-2\">\n          {{ 'com.bmc.arsys.rx.client.view-components.record-grid-column.available-columns.title' | translate }}\n        </h4>\n      </div>\n\n      <div class=\"rx-card card flex-grow-1 mt-2\">\n        <div class=\"card-block d-flex flex-column\">\n          <div\n            *ngIf=\"!isTreeEmpty()\"\n            #associatedAvailableColumnsDropList=\"cdkDropList\"\n            cdkDropList\n            [cdkDropListData]=\"filteredColumns\"\n            cdkDropListSortingDisabled\n            [cdkDropListConnectedTo]=\"['selectedColumnsDropList']\"\n          >\n            <adapt-tree\n              [value]=\"availableColumnsTree\"\n              (onNodeExpand)=\"onNodeExpand($event)\"\n              filter=\"true\"\n              [wrap]=\"treeWrap\"\n            >\n              <ng-template let-node adaptTreeNodeTemplate>\n                <span *ngIf=\"!node.data.availableColumn\" [title]=\"node.label\">\n                  {{ node.label }}\n                </span>\n\n                <div\n                  *ngIf=\"node.data.availableColumn\"\n                  class=\"rx-tree-draggable-node\"\n                  #draggableAssociatedAvailableColumn\n                  cdkDrag\n                  [cdkDragData]=\"node.data.availableColumn\"\n                  (cdkDragStarted)=\"onAssociatedAvailableColumnsDragStarted()\"\n                >\n                  <div (dblclick)=\"addColumn(node.data.availableColumn)\">\n                    <button\n                      type=\"button\"\n                      class=\"rx-button-unstyled d-icon-plus_circle\"\n                      (click)=\"addColumn(node.data.availableColumn)\"\n                    ></button>\n\n                    <span class=\"rx-tree-node-label ml-3\">{{ node.label }}</span>\n                  </div>\n                </div>\n              </ng-template>\n            </adapt-tree>\n          </div>\n\n          <div *ngIf=\"isTreeEmpty()\" class=\"d-flex justify-content-center h-100 align-items-center mt-2\">\n            <adapt-empty-state\n              class=\"w-100\"\n              label=\"{{\n                'com.bmc.arsys.rx.client.view-components.record-grid-column.available-columns.empty-state.message'\n                  | translate\n              }}\"\n              type=\"search\"\n            ></adapt-empty-state>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"d-flex flex-column mh-100 {{ isReadOnly ? 'col' : 'col-8' }}\">\n      <div class=\"d-flex align-items-start justify-content-between\">\n        <h4 class=\"mt-2\">\n          {{ 'com.bmc.arsys.rx.client.view-components.record-grid-column.selected-columns.title' | translate }}\n        </h4>\n      </div>\n\n      <div\n        id=\"selectedColumnsDropList\"\n        class=\"designer-modal-accordion-wrapper\"\n        cdkDropList\n        [cdkDropListData]=\"columns\"\n        (cdkDropListDropped)=\"onDropInSelectedColumnsContainer($event)\"\n        #selectedColumnsDropList=\"cdkDropList\"\n      >\n        <adapt-accordion [multiselect]=\"false\" *ngIf=\"columns.length\">\n          <div\n            *ngFor=\"\n              let column of columns;\n              let index = index;\n              let first = first;\n              let last = last;\n              trackBy: trackByForColumns\n            \"\n            class=\"designer-modal-accordion-content\"\n            cdkDrag\n            cdkDragLockAxis=\"y\"\n            [cdkDragData]=\"column\"\n            [cdkDragDisabled]=\"isReadOnly\"\n            (cdkDragStarted)=\"onColumnDragStarted()\"\n            #draggableSelectedColumn\n          >\n            <div *ngIf=\"!isReadOnly\" class=\"designer-modal-drag-handle d-icon-left-dots\" cdkDragHandle></div>\n\n            <adapt-accordion-tab\n              class=\"d-block\"\n              [isOpen]=\"column.isOpen\"\n              (open)=\"column.isOpen = true\"\n              (close)=\"column.isOpen = false\"\n            >\n              <div class=\"card-title-text w-100\">\n                <div class=\"designer-modal-card-title-content\">\n                  <div class=\"left-header-block\" [class.pl-0]=\"isReadOnly\">\n                    <div class=\"rx-ellipsis\" [title]=\"column.label\" rx-id=\"card-title\">\n                      {{ column.label }}\n                    </div>\n                  </div>\n\n                  <div *ngIf=\"!isReadOnly\" class=\"right-header-block\">\n                    <div class=\"designer-modal-card-title-index-buttons\">\n                      <button\n                        class=\"d-icon-left-triangle_down rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"last\"\n                        (click)=\"$event.stopPropagation(); moveColumn(index, index + 1)\"\n                        rx-id=\"move-down-button\"\n                      ></button>\n\n                      <button\n                        class=\"d-icon-left-triangle_up rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"first\"\n                        (click)=\"$event.stopPropagation(); moveColumn(index, index - 1)\"\n                        rx-id=\"move-up-button\"\n                      ></button>\n                    </div>\n\n                    <button\n                      *ngIf=\"!isActionsColumn(column.fieldId)\"\n                      class=\"d-icon-left-cross_adapt p-1 pr-4 ml-3\"\n                      adapt-button\n                      size=\"small\"\n                      type=\"button\"\n                      (click)=\"$event.stopPropagation(); removeColumn(index)\"\n                      rx-id=\"remove-button\"\n                    >\n                      {{ 'com.bmc.arsys.rx.client.common.remove.label' | translate }}\n                    </button>\n                  </div>\n                </div>\n              </div>\n\n              <ng-container *ngIf=\"column.isOpen\">\n                <div\n                  *ngIf=\"\n                    isActionsColumn(column.fieldId);\n                    then actionsColumnEditorTemplate;\n                    else dataColumnEditorTemplate\n                  \"\n                ></div>\n              </ng-container>\n\n              <ng-template #dataColumnEditorTemplate>\n                <adapt-rx-textfield\n                  class=\"rx-record-grid-column-editor-text-field\"\n                  label=\"{{\n                    'com.bmc.arsys.rx.client.view-components.record-grid-column.column-header-field.label' | translate\n                  }}\"\n                  [disabled]=\"isReadOnly\"\n                  [(ngModel)]=\"column.title\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></adapt-rx-textfield>\n\n                <div class=\"d-flex flex-wrap\">\n                  <ng-container *ngFor=\"let columnProperty of columnProperties; trackBy: trackByForColumnProperties\">\n                    <div\n                      class=\"checkbox rx-record-grid-column-editor__checkbox-field\"\n                      *ngIf=\"\n                        ['visible', 'sortable', 'filterable', 'searchable', 'wrapText'].includes(columnProperty.name)\n                      \"\n                    >\n                      <label>\n                        <input\n                          type=\"checkbox\"\n                          [(ngModel)]=\"column[columnProperty.name]\"\n                          (ngModelChange)=\"onColumnCheckboxPropertyChange($event, column, columnProperty)\"\n                          [disabled]=\"!isPropertyEditable(column, columnProperty.name)\"\n                        />\n\n                        <span class=\"checkbox__item\">{{ columnProperty.label }}</span>\n                      </label>\n\n                      <span class=\"ml-1\" *ngIf=\"columnProperty.tooltip\">\n                        <span class=\"letter-space\"></span>\n                        <adapt-icon\n                          [name]=\"'question_circle_o'\"\n                          [adaptPopover]=\"columnProperty.tooltip.content\"\n                          appendToBody=\"true\"\n                        >\n                        </adapt-icon>\n                      </span>\n                    </div>\n                    <rx-column-editor-alignment\n                      *ngIf=\"columnProperty.name === 'alignment'\"\n                      [isReadOnly]=\"isReadOnly\"\n                      [column]=\"column\"\n                      [columnProperty]=\"columnProperty\"\n                      class=\"flex-fill\"\n                      [ngModel]=\"column.alignment\"\n                      (ngModelChange)=\"markAsDirty()\"\n                      ngDefaultControl\n                    ></rx-column-editor-alignment>\n                  </ng-container>\n                </div>\n\n                <div class=\"d-flex flex-row\">\n                  <rx-stepper-with-units-form-control\n                    class=\"d-block col-5 p-0\"\n                    [options]=\"columnWidthPropertyOptions\"\n                    [(ngModel)]=\"column.width\"\n                    (ngModelChange)=\"markAsDirty()\"\n                  ></rx-stepper-with-units-form-control>\n\n                  <rx-select-form-control\n                    *ngIf=\"column.filterable && column.fieldDefinition.namedListDefinition\"\n                    class=\"d-block col-5 p-0 pb-2 pl-5\"\n                    [options]=\"typeaheadKeystrokeCountOptions\"\n                    [(ngModel)]=\"column.typeaheadKeystrokeCount\"\n                    (ngModelChange)=\"markAsDirty()\"\n                    [disabled]=\"isReadOnly\"\n                  ></rx-select-form-control>\n                </div>\n\n                <rx-expression-form-control\n                  #additionalQueryCriteriaExpression\n                  *ngIf=\"column.filterable && column.fieldDefinition.namedListDefinition\"\n                  rx-id=\"additional-query-criteria-expression\"\n                  class=\"d-block p-0 pb-2\"\n                  [options]=\"column.additionalQueryCriteriaExpressionOptions\"\n                  [(ngModel)]=\"column.additionalQueryCriteria\"\n                  (events)=\"openAdditionalQueryCriteriaExpressionEditor(column, additionalQueryCriteriaExpression)\"\n                  [disabled]=\"isReadOnly\"\n                ></rx-expression-form-control>\n\n                <rx-cell-display-properties\n                  class=\"d-block pb-2\"\n                  [columns]=\"columns\"\n                  [columnName]=\"column.title\"\n                  [disabled]=\"isReadOnly\"\n                  [(ngModel)]=\"column.cellDisplayProperties\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></rx-cell-display-properties>\n\n                <rx-named-filter-options\n                  class=\"d-block pb-2\"\n                  [column]=\"column\"\n                  [disabled]=\"isReadOnly\"\n                  [(ngModel)]=\"column.namedFilterOptions\"\n                  (ngModelChange)=\"markAsDirty()\"\n                  tooltip=\"{{\n                    'com.bmc.arsys.rx.client.view-components.record-grid-column.named-filter-options-field.tooltip'\n                      | translate\n                  }}\"\n                ></rx-named-filter-options>\n\n                <rx-action-list-control\n                  class=\"d-block\"\n                  [disabled]=\"isReadOnly\"\n                  [(ngModel)]=\"column.actions\"\n                  (ngModelChange)=\"markAsDirty()\"\n                  tooltip=\"{{\n                    'com.bmc.arsys.rx.client.view-components.record-grid-column.column-actions-field.tooltip'\n                      | translate\n                  }}\"\n                ></rx-action-list-control>\n              </ng-template>\n\n              <ng-template #actionsColumnEditorTemplate>\n                <adapt-rx-textfield\n                  class=\"rx-record-grid-column-editor-text-field d-block form-group\"\n                  label=\"{{\n                    'com.bmc.arsys.rx.client.view-components.record-grid-column.column-header-field.label' | translate\n                  }}\"\n                  [disabled]=\"isReadOnly\"\n                  [(ngModel)]=\"column.title\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></adapt-rx-textfield>\n\n                <rx-stepper-with-units-form-control\n                  class=\"d-block col-5 p-0\"\n                  [options]=\"columnWidthPropertyOptions\"\n                  [(ngModel)]=\"column.width\"\n                  (ngModelChange)=\"markAsDirty()\"\n                ></rx-stepper-with-units-form-control>\n\n                <div class=\"d-flex flex-wrap\">\n                  <div\n                    class=\"checkbox rx-record-grid-column-editor__checkbox-field\"\n                    *ngFor=\"let actionsColumnProperty of actionsColumnProperties; trackBy: trackByForColumnProperties\"\n                  >\n                    <label>\n                      <input\n                        type=\"checkbox\"\n                        [(ngModel)]=\"column[actionsColumnProperty.name]\"\n                        (ngModelChange)=\"markAsDirty()\"\n                        [disabled]=\"!isPropertyEditable(column, actionsColumnProperty.name)\"\n                      />\n\n                      <span class=\"checkbox__item\">{{ actionsColumnProperty.label }}</span>\n                    </label>\n                  </div>\n                </div>\n              </ng-template>\n            </adapt-accordion-tab>\n          </div>\n        </adapt-accordion>\n      </div>\n\n      <div *ngIf=\"!columns.length\" class=\"d-flex justify-content-center h-100 align-items-center mt-2\">\n        <adapt-empty-state\n          class=\"w-100\"\n          label=\"{{\n            'com.bmc.arsys.rx.client.view-components.record-grid-column.selected-columns.empty-state.message'\n              | translate\n          }}\"\n          type=\"grid\"\n        ></adapt-empty-state>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    *ngIf=\"!isReadOnly\"\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"!isDirty()\"\n    (click)=\"saveChanges()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{\n      isReadOnly\n        ? ('com.bmc.arsys.rx.client.common.close.label' | translate)\n        : ('com.bmc.arsys.rx.client.common.cancel.label' | translate)\n    }}\n  </button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.designer-modal-body{height:645px;min-height:calc(100% - 61px)!important}.designer-modal-accordion-wrapper{display:flex;flex-direction:column;height:100%;overflow:auto;padding-top:10px}.designer-modal-accordion-content{position:relative}.designer-modal-accordion-content.cdk-drag-preview{z-index:1200!important}.designer-modal-drag-handle{cursor:move;position:absolute;top:0;left:0;height:46px;padding:14px 10px 14px 14px;z-index:1}.designer-modal-card-title-content{width:100%;display:flex}.designer-modal-card-title-content .left-header-block,.designer-modal-card-title-content .right-header-block{display:flex;align-items:center}.designer-modal-card-title-content .left-header-block{flex-grow:1;min-width:0;font-size:14px;padding-left:22px}.designer-modal-card-sub-title{color:#7c7f81;font-weight:normal}.designer-modal-card-title-index-buttons{display:flex;font-size:19px}.rx-card{overflow:auto}.rx-tree-draggable-node{cursor:pointer}.rx-tree-draggable-node.cdk-drag-preview{z-index:1200!important}.rx-tree-draggable-node.cdk-drag{opacity:1}.rx-tree-node-label{word-break:break-all}rx-form-builder{max-width:400px}.rx-record-grid-column-editor__checkbox-field{flex-basis:20%;min-width:140px}.rx-record-grid-column-editor__checkbox-field+.rx-record-grid-column-editor__checkbox-field{margin-top:calc(.5rem + 1px)!important}\n"], components: [{ type: i1.AdaptTreeComponent, selector: "adapt-tree", inputs: ["value", "filter", "texts", "filterBtnClearText", "filterPlaceholder", "testID", "lazy", "lazyLoading", "trim", "wrap", "selectAllButton", "deselectAllButton", "treeScrollHeight", "adaptRadarDisableEventSending", "draggableScope", "droppableScope", "draggableNodes", "droppableNodes", "validateDrop"], outputs: ["onNodeDrop", "lazyLoad"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: i1.AdaptIconComponent, selector: "adapt-icon", inputs: ["name", "classList", "description", "testID"] }, { type: ColumnEditorAlignmentComponent, selector: "rx-column-editor-alignment", inputs: ["column", "isReadOnly", "columnProperty"] }, { type: i2$5.StepperWithUnitsFormControlComponent, selector: "rx-stepper-with-units-form-control", inputs: ["options"] }, { type: i2$5.SelectFormControlComponent, selector: "rx-select-form-control", inputs: ["options", "appendToBody", "formControl"] }, { type: i2$5.ExpressionFormControlComponent, selector: "rx-expression-form-control", inputs: ["options", "isDisabled", "propertyPath"], outputs: ["events"] }, { type: RecordGridCellDisplayPropertiesComponent, selector: "rx-cell-display-properties", inputs: ["columnName", "columns"] }, { type: RecordGridNamedFilterOptionsComponent, selector: "rx-named-filter-options", inputs: ["column", "tooltip"] }, { type: i1$3.ActionListControlComponent, selector: "rx-action-list-control", inputs: ["options", "tooltip"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "id", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListAutoScrollDisabled", "cdkDropListOrientation", "cdkDropListLockAxis", "cdkDropListData", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i1.AdaptTreeNodeTemplateDirective, selector: "[adaptTreeNodeTemplate]", inputs: ["adaptTreeNodeTemplate"] }, { type: i8.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragDisabled", "cdkDragStartDelay", "cdkDragLockAxis", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragBoundary", "cdkDragRootElement", "cdkDragPreviewContainer", "cdkDragData", "cdkDragFreeDragPosition"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { type: i1.AdaptPopoverDirective, selector: "[adaptPopover]", inputs: ["adaptPopover", "popoverTitle", "placement", "fallbackPlacement", "triggers", "container", "appendToBody", "closeBtn", "popupDelay", "disablePopover", "popoverClass", "autoClose", "closeOnOutOfView", "maxWidth", "minWidth"], outputs: ["shown", "hidden"], exportAs: ["adaptPopover"] }, { type: i2$3.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }], pipes: { "translate": i2.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridColumnEditorModalComponent, decorators: [{
            type: Component,
            args: [{
                    templateUrl: './record-grid-column-editor-modal.component.html',
                    styleUrls: ['./record-grid-column-editor-modal.component.scss'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i1$6.RxModalService }, { type: i1$1.RxDefinitionNameService }, { type: RxRecordGridUtilsService }, { type: i1$5.RxFieldDefinitionService }, { type: i1$5.RxRecordDefinitionCacheService }, { type: i2$1.RxGuidService }, { type: i0.NgZone }, { type: i0.Injector }, { type: i2.TranslateService }, { type: i2$5.RxExpressionEditorService }]; }, propDecorators: { draggableSelectedColumns: [{
                type: ViewChildren,
                args: ['draggableSelectedColumn', { read: CdkDrag }]
            }], selectedColumnsDropList: [{
                type: ViewChild,
                args: ['selectedColumnsDropList', { read: CdkDropList }]
            }], draggableAssociatedAvailableColumns: [{
                type: ViewChildren,
                args: ['draggableAssociatedAvailableColumn', { read: CdkDrag }]
            }], actionListControlComponents: [{
                type: ViewChildren,
                args: [ActionListControlComponent]
            }], associatedAvailableColumnsDropList: [{
                type: ViewChild,
                args: ['associatedAvailableColumnsDropList', { read: CdkDropList }]
            }], accordionTabEls: [{
                type: ViewChildren,
                args: [AdaptAccordionTabComponent, { read: ElementRef }]
            }] } });

class RecordGridColumnEditorControlComponent extends ValueAccessor {
    constructor(rxModalService, rxFieldDefinitionService, rxRecordGridConfigUtilsService, rxRecordGridUtilsService) {
        super();
        this.rxModalService = rxModalService;
        this.rxFieldDefinitionService = rxFieldDefinitionService;
        this.rxRecordGridConfigUtilsService = rxRecordGridConfigUtilsService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.updateColumnsSubject = new BehaviorSubject([]);
        this.columns$ = this.updateColumnsSubject.pipe(switchMap((inspectorColumns) => forkJoin(inspectorColumns.map((inspectorColumn) => forkJoin([
            this.rxRecordGridUtilsService.getAssociationDescriptor(inspectorColumn.fieldId, this.options.recordDefinition),
            this.rxRecordGridUtilsService.getFieldDefinition(inspectorColumn.fieldId, this.options.recordDefinition)
        ]).pipe(map(([associationDescriptor, fieldDefinition]) => ({
            associationDescriptor,
            fieldDefinition,
            inspectorColumn
        }))))).pipe(defaultIfEmpty([]), map((columnsData) => columnsData.map((columnData) => {
            var _a;
            return Object.assign(Object.assign({}, columnData.inspectorColumn), { fieldDefinition: columnData.fieldDefinition, associationDescriptor: columnData.associationDescriptor, title: (_a = columnData.inspectorColumn.title) === null || _a === void 0 ? void 0 : _a.trim(), searchable: has(columnData.inspectorColumn, 'searchable')
                    ? this.rxRecordGridConfigUtilsService.getBooleanValue(columnData.inspectorColumn.searchable)
                    : columnData.inspectorColumn.filterable &&
                        this.rxRecordGridUtilsService.isSearchable(columnData.fieldDefinition, this.options.recordDefinition), fallbackTitle: `[${columnData.fieldDefinition.name}]` });
        })), shareReplay(1))));
    }
    ngOnChanges(changes) {
        var _a;
        if (((_a = changes.options) === null || _a === void 0 ? void 0 : _a.previousValue) &&
            changes.options.currentValue.recordDefinition.name !==
                changes.options.previousValue.recordDefinition.name) {
            this.updateColumnsSubject.next(this.value);
        }
    }
    onWriteValue(inspectorColumns) {
        this.updateColumnsSubject.next(inspectorColumns);
    }
    removeColumn(columnData) {
        this.updateValue(this.value.filter((column) => column.fieldId !== columnData.fieldId));
    }
    updateValue(columns) {
        this.value = columns;
        this.onWriteValue(columns);
    }
    openEditor(columnGuid, activeActionIndex) {
        this.columns$.pipe(take(1)).subscribe((columns) => {
            const data = {
                isReadOnly: this.isDisabled,
                columns,
                activeColumn: columns.find((item) => item.guid === columnGuid),
                recordDefinition: this.options.recordDefinition,
                activeActionIndex
            };
            this.rxModalService
                .openModal({
                title: 'Edit grid columns',
                content: RecordGridColumnEditorModalComponent,
                data: {
                    columnParams: data
                },
                size: OpenViewActionModalSize.Large,
                testID: 'edit-grid-columns'
            })
                .then((result) => {
                if (result && result.columns) {
                    this.updateValue(result.columns);
                }
            })
                .catch(noop);
        });
    }
    focus(data) {
        this.openEditor(data === null || data === void 0 ? void 0 : data.columnGuid, data === null || data === void 0 ? void 0 : data.actionIndex);
    }
    getColumnResourceTypeName(column) {
        const resourceType = RX_RECORD_DEFINITION.resourceTypesByFullName[column.fieldDefinition.resourceType];
        return get(RX_RECORD_DEFINITION.dataTypes[resourceType], 'displayName', '');
    }
    getSortedColumns(columns) {
        return columns.sort((column1, column2) => column1.index - column2.index);
    }
    trackByForColumns(index, column) {
        return column.fieldId;
    }
    isActionsColumn(fieldId) {
        return fieldId === RX_RECORD_GRID.actionsColumnFieldDefinition.id;
    }
    ngOnDestroy() {
        this.updateColumnsSubject.complete();
    }
}
RecordGridColumnEditorControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridColumnEditorControlComponent, deps: [{ token: i1$6.RxModalService }, { token: i1$5.RxFieldDefinitionService }, { token: RxRecordGridConfigUtilsService }, { token: RxRecordGridUtilsService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridColumnEditorControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridColumnEditorControlComponent, selector: "rx-record-grid-column-editor", inputs: { options: "options" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: RecordGridColumnEditorControlComponent,
            multi: true
        }
    ], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<adapt-button btn-type=\"tertiary\" rx-id=\"open-modal-button\" class=\"p-0 pb-1\" (click)=\"openEditor()\">\n  <span class=\"d-icon-plus_circle\"></span>\n  Edit grid columns\n</adapt-button>\n\n<div *ngIf=\"columns$ | async as columns\">\n  <div rx-id=\"columns\">\n    <span *ngIf=\"columns.length === 0\" class=\"text-tertiary\"> No grid columns added. </span>\n  </div>\n\n  <div class=\"rx-selected-column\" *ngFor=\"let column of getSortedColumns(columns); trackBy: trackByForColumns\">\n    <div class=\"rx-selected-column__header-container\">\n      <span\n        class=\"rx-selected-column__header-title\"\n        rx-id=\"card-title\"\n        [ngClass]=\"{ 'd-icon-left-arrow_schema': column.associationDescriptor }\"\n        [title]=\"column.title\"\n      >\n        {{ column.title || column.fallbackTitle }}\n      </span>\n\n      <button\n        type=\"button\"\n        class=\"rx-button-unstyled d-icon-left-pencil btn-link\"\n        rx-id=\"open-editor\"\n        (click)=\"openEditor(column.guid)\"\n        *ngIf=\"!isDisabled\"\n      ></button>\n      <button\n        type=\"button\"\n        class=\"rx-button-unstyled d-icon-cross btn-link\"\n        rx-id=\"remove-column\"\n        (click)=\"removeColumn(column)\"\n        *ngIf=\"!isActionsColumn(column.fieldId) && !isDisabled\"\n      ></button>\n    </div>\n\n    <div class=\"rx-column-type\" rx-id=\"column-type\">\n      {{ getColumnResourceTypeName(column) }}\n      <span *ngIf=\"column.associationDescriptor\">\u2013 {{ column.associationDescriptor.label }}</span>\n    </div>\n  </div>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.rx-selected-column{margin-bottom:5px;border:1px solid #d6d7d8;border-radius:2px;padding:5px 10px;word-break:break-all;font-weight:var(--font-weight-bold)}.rx-selected-column__header-container{display:flex;margin-bottom:5px}.rx-selected-column__header-title{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;font-size:14px}.rx-column-type{color:#959899;font-size:10px;overflow:hidden;text-overflow:ellipsis}.d-icon-cross,.d-icon-left-pencil{cursor:pointer}.d-icon-cross:not(:hover),.d-icon-left-pencil:not(:hover){color:#313538}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridColumnEditorControlComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-column-editor',
                    templateUrl: './record-grid-column-editor-control.component.html',
                    styleUrls: ['./record-grid-column-editor-control.component.scss'],
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: RecordGridColumnEditorControlComponent,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i1$6.RxModalService }, { type: i1$5.RxFieldDefinitionService }, { type: RxRecordGridConfigUtilsService }, { type: RxRecordGridUtilsService }]; }, propDecorators: { options: [{
                type: Input
            }] } });

var QueryFiltersLogic;
(function (QueryFiltersLogic) {
    QueryFiltersLogic["And"] = "AND";
    QueryFiltersLogic["Or"] = "OR";
})(QueryFiltersLogic || (QueryFiltersLogic = {}));

class RxRecordGridAdvancedFilterValue {
    constructor(value, namedOptions = []) {
        this.namedOptions = [];
        this.filterValue = value;
        if (Array.isArray(namedOptions)) {
            this.namedOptions = namedOptions;
        }
    }
    get length() {
        return ((Array.isArray(this.filterValue) ? this.filterValue.length : isNil(this.filterValue) ? 0 : 1) +
            this.namedOptions.length);
    }
    static isEmpty(item) {
        return item instanceof RxRecordGridAdvancedFilterValue && !item.length;
    }
    static isEmptyWithRange(item) {
        return (item instanceof RxRecordGridAdvancedFilterValue &&
            !item.namedOptions.length &&
            AdvancedFilterDataTypesConfigsService.isEmptyOnEmptyValues(item.filterValue));
    }
}

class RxRecordGridAdvancedFilteringService {
    constructor(rxRecordDefinitionService, rxObjectUtilsService, rxRecordGridUtilsService, rxNamedListService, advancedFilterDataTypesConfigsService, adaptTranslateService) {
        this.rxRecordDefinitionService = rxRecordDefinitionService;
        this.rxObjectUtilsService = rxObjectUtilsService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxNamedListService = rxNamedListService;
        this.advancedFilterDataTypesConfigsService = advancedFilterDataTypesConfigsService;
        this.adaptTranslateService = adaptTranslateService;
        this.translation = this.adaptTranslateService.getCurrentLanguage();
        this.adaptTexts = {
            fromLabel: this.translation['adapt.advancedFilter.configsTexts.fromLabel'],
            toLabel: this.translation['adapt.advancedFilter.configsTexts.toLabel'],
            trueLabel: this.translation['adapt.advancedFilter.configsTexts.trueLabel'],
            falseLabel: this.translation['adapt.advancedFilter.configsTexts.falseLabel'],
            blankLabel: this.translation['adapt.advancedFilter.configsTexts.blankLabel'],
            validationErrors: {
                invalidRangeName: this.translation['adapt.advancedFilter.validationErrors.invalidRangeName'],
                invalidRangeText: this.translation['adapt.advancedFilter.validationErrors.invalidRangeText'],
                numberTypeTexts: {
                    fromValueMustBeNumber: this.translation['adapt.advancedFilter.validationErrors.numberTypeTexts.fromValueMustBeNumber'],
                    toValueMustBeNumber: this.translation['adapt.advancedFilter.validationErrors.numberTypeTexts.toValueMustBeNumber'],
                    invalidBetweenMinAndMax: this.translation['adapt.advancedFilter.validationErrors.numberTypeTexts.invalidBetweenMinAndMax'],
                    invalidMinValue: this.translation['adapt.advancedFilter.validationErrors.numberTypeTexts.invalidMinValue'],
                    invalidMaxValue: this.translation['adapt.advancedFilter.validationErrors.numberTypeTexts.invalidMaxValue']
                }
            }
        };
        this.defaultConfig = this.advancedFilterDataTypesConfigsService.getConfigs(this.adaptTexts);
    }
    addAssociationFieldsToFieldDefinitionsById(fieldDefinitionsById, associationDescriptors, associatedRecordDefinitions) {
        associationDescriptors.forEach((associationDescriptor) => {
            const associatedRecordDefinition = associatedRecordDefinitions.find((recordDefinition) => recordDefinition.name === associationDescriptor.recordDefinitionName);
            associatedRecordDefinition.fieldDefinitions.forEach((fieldDefinition) => {
                const field = this.rxRecordGridUtilsService.getFieldIdForGridColumn(fieldDefinition.id, associationDescriptor);
                if (!fieldDefinitionsById[field]) {
                    this.rxRecordDefinitionService.addFieldDefinitionToMap(fieldDefinition, fieldDefinitionsById, field);
                }
            });
        });
        fieldDefinitionsById = Object.assign(Object.assign({}, fieldDefinitionsById), this.rxObjectUtilsService.expandProperties(fieldDefinitionsById));
        return fieldDefinitionsById;
    }
    getAdvancedFilterOption(fieldId, header, fieldDefinition, filterConfig, isHidden, customFilterTemplates, prefixLabel, namedFilterOptions, typeaheadKeystrokeCount, additionalQueryCriteria) {
        const config = {
            id: fieldId,
            label: header,
            dataType: filterConfig.filterOptionDataType,
            isHidden,
            data: isFunction(filterConfig.getDataForAdvancedFilter)
                ? filterConfig.getDataForAdvancedFilter(fieldDefinition, fieldId)
                : null
        };
        namedFilterOptions = namedFilterOptions !== null && namedFilterOptions !== void 0 ? namedFilterOptions : [];
        if (filterConfig.filterOptionDataType === AdvancedFilterOptionDataType.boolean) {
            config.inputsTemplate =
                fieldDefinition.fieldOption !== RecordFieldOption.Required
                    ? customFilterTemplates.optionalBooleanFilter
                    : customFilterTemplates.requiredBooleanFilter;
            config.customConfig = {
                getExpressionFieldTips: (filterOption) => {
                    const data = filterOption.data;
                    const selectOptions = (data === null || data === void 0 ? void 0 : data.selectOptions) || [];
                    const namedFilterOptionTips = this.getNamedFilterOptionTips(namedFilterOptions, filterOption, config.customConfig);
                    return namedFilterOptionTips.concat(selectOptions.map((selectOption) => {
                        return AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag(new RxRecordGridAdvancedFilterValue([selectOption.id]), filterOption, config.customConfig, false, formatAdvancedFilterTagText(filterOption, selectOption.name));
                    }));
                },
                formatValueForTag: (value, option) => {
                    const data = option.data;
                    const selectOptions = (data === null || data === void 0 ? void 0 : data.selectOptions) || [];
                    const filterValueLabels = value.filterValue.map((id) => selectOptions.find((selectOption) => selectOption.id === id).name);
                    return this.buildTagLabel(filterValueLabels, this.getNamedOptionTitles(value, namedFilterOptions));
                },
                needRemoveTagValue: (value) => RxRecordGridAdvancedFilterValue.isEmpty(value),
                updateFilterValue: (newValue, oldValue, filterOption) => this.updateFilterValue(oldValue, newValue, filterOption.data.isRequired),
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    const rawValues = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm);
                    const value = this.getFilterValueFromString(namedFilterOptions, rawValues);
                    const data = filterOption.data;
                    const selectOptions = (data === null || data === void 0 ? void 0 : data.selectOptions) || [];
                    value.filterValue =
                        value.filterValue
                            .map((optionLabel) => {
                            var _a;
                            optionLabel = optionLabel.trim().toLowerCase();
                            const selectOption = selectOptions.find((option) => option.name.toLowerCase() === optionLabel);
                            return (_a = selectOption === null || selectOption === void 0 ? void 0 : selectOption.id) !== null && _a !== void 0 ? _a : null;
                        })
                            .filter((val) => !isNil(val)) || [];
                    return value.length ? { value } : null;
                }
            };
        }
        if (filterConfig.filterOptionDataType === AdvancedFilterOptionDataType.string) {
            if (fieldDefinition.namedListDefinition) {
                config.inputsTemplate = customFilterTemplates.inputsForStringWithTypeAheadTemplate;
                config.data = Object.assign(Object.assign({}, config.data), { typeaheadKeystrokeCount, additionalQueryCriteria });
            }
            else {
                config.inputsTemplate = customFilterTemplates.inputsForStringTypeTemplate;
            }
            config.customConfig = {
                needRemoveTagValue(value) {
                    return RxRecordGridAdvancedFilterValue.isEmpty(value);
                },
                formatValueForTag: (value, filterOption) => this.buildTagLabel(value.filterValue, this.getNamedOptionTitles(value, namedFilterOptions)),
                getExpressionFieldTips: (option, searchTerm) => {
                    return [
                        ...this.getNamedFilterOptionTips(namedFilterOptions, option, config.customConfig),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag(new RxRecordGridAdvancedFilterValue(), option, config.customConfig, true, formatAdvancedFilterTagText(option, ''))
                    ];
                },
                updateFilterValue: (newValue, oldValue, filterOption) => this.updateFilterValue(oldValue, newValue),
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    return this.parseStringTagFieldExpression(filterOption, searchTerm, namedFilterOptions);
                }
            };
        }
        if (filterConfig.filterOptionDataType === AdvancedFilterOptionDataType.selection) {
            config.inputsTemplate = customFilterTemplates.inputsForSelectionTypeTemplate;
            config.customConfig = {
                needRemoveTagValue(value) {
                    return RxRecordGridAdvancedFilterValue.isEmpty(value);
                },
                formatValueForTag: (value, option) => {
                    const filterValueLabels = this.defaultConfig[filterConfig.filterOptionDataType].formatValueForTag(value.filterValue, option);
                    return this.buildTagLabel(filterValueLabels, this.getNamedOptionTitles(value, namedFilterOptions));
                },
                getExpressionFieldTips: (filterOption, searchTerm) => {
                    const data = filterOption.data;
                    const selectOptions = (data && data.selectOptions) || [];
                    return this.getNamedFilterOptionTips(namedFilterOptions, filterOption, config.customConfig).concat(selectOptions.map((selectOption) => {
                        return AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag(new RxRecordGridAdvancedFilterValue([selectOption.id]), filterOption, config.customConfig, false, formatAdvancedFilterTagText(filterOption, selectOption.name));
                    }));
                },
                updateFilterValue: (newValue, oldValue, filterOption) => this.updateFilterValue(oldValue, newValue),
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    return this.parseStringTagFieldExpression(filterOption, searchTerm, namedFilterOptions);
                }
            };
        }
        if (filterConfig.filterOptionDataType === AdvancedFilterOptionDataType.datetime) {
            config.inputsTemplate = customFilterTemplates.inputsForDatetimeTypeTemplate;
            config.customConfig = this.getDatetimeCustomConfig(namedFilterOptions, config, AdvancedFilterOptionDataType.datetime, 'll LTS');
        }
        if (filterConfig.filterOptionDataType === AdvancedFilterOptionDataType.date) {
            config.inputsTemplate = customFilterTemplates.inputsForDateTypeTemplate;
            config.customConfig = this.getDatetimeCustomConfig(namedFilterOptions, config, AdvancedFilterOptionDataType.date, 'll');
        }
        if (filterConfig.filterOptionDataType === AdvancedFilterOptionDataType.time) {
            config.inputsTemplate = customFilterTemplates.inputsForTimeTypeTemplate;
            config.customConfig = this.getDatetimeCustomConfig(namedFilterOptions, config, AdvancedFilterOptionDataType.time, 'LTS');
        }
        if (filterConfig.filterOptionDataType === AdvancedFilterOptionDataType.number) {
            config.inputsTemplate = customFilterTemplates.inputsForNumberTypeTemplate;
            config.customConfig = {
                needRemoveTagValue(value) {
                    return RxRecordGridAdvancedFilterValue.isEmptyWithRange(value);
                },
                getExpressionFieldTips: (option, searchTerm) => {
                    return this.getNamedFilterOptionTips(namedFilterOptions, option, config.customConfig, [null, null]).concat(this.defaultConfig[filterConfig.filterOptionDataType].getExpressionFieldTips(option, searchTerm));
                },
                updateFilterValue: (newValue, oldValue, filterOption) => {
                    newValue.filterValue = this.defaultConfig[filterConfig.filterOptionDataType].updateFilterValue(newValue.filterValue, oldValue.filterValue, filterOption);
                    newValue.namedOptions = uniq(oldValue.namedOptions.concat(newValue.namedOptions));
                    return newValue;
                },
                formatValueForTag: (value) => {
                    const formattedValue = value.filterValue.filter((val) => val != null).join(' - ');
                    return this.buildTagLabel(formattedValue, this.getNamedOptionTitles(value, namedFilterOptions));
                },
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    var _a, _b;
                    const { value: valuesStr, label } = this.getExpressionRawValues(filterOption, searchTerm);
                    if (!valuesStr) {
                        return null;
                    }
                    const value = this.getFilterValueFromString(namedFilterOptions, valuesStr);
                    value.filterValue =
                        (_b = (_a = this.defaultConfig[filterConfig.filterOptionDataType].parseTagFieldExpression(filterOption, `${label} ${value.filterValue[0]}`)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : [];
                    return value.length ? { value } : null;
                },
                validateValue: (value, filterOption) => this.defaultConfig[filterConfig.filterOptionDataType].validateValue(value.filterValue, filterOption)
            };
        }
        if (prefixLabel) {
            const prefixConfig = {
                getTagText(value, option, formattedValue) {
                    return `${prefixLabel}: ${formattedValue}`;
                }
            };
            config.customConfig = Object.assign(Object.assign({}, config.customConfig), prefixConfig);
        }
        return config;
    }
    parseStringTagFieldExpression(filterOption, searchTerm, namedFilterOptions) {
        const valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm);
        if (!valuesStr) {
            return null;
        }
        const value = this.getFilterValueFromString(namedFilterOptions, valuesStr);
        return value.length ? { value } : null;
    }
    updateFilterValue(oldValue, newValue, replaceFilterValue = false) {
        if (!replaceFilterValue) {
            newValue.filterValue = uniq(oldValue.filterValue.concat(newValue.filterValue));
        }
        newValue.namedOptions = uniq(oldValue.namedOptions.concat(newValue.namedOptions));
        return newValue;
    }
    buildTagLabel(filterValueLabels, namedOptionTitles, filterValueSeparator = ', ', namedOptionsSeparator = '; ') {
        return [
            isString(filterValueLabels)
                ? filterValueLabels
                : isArray(filterValueLabels) && !isEmpty(filterValueLabels)
                    ? this.rxNamedListService.isNamedListOption(filterValueLabels[0])
                        ? filterValueLabels.map((value) => { var _a; return (_a = value.displayValue) !== null && _a !== void 0 ? _a : value.value; }).join(filterValueSeparator)
                        : filterValueLabels.join(filterValueSeparator)
                    : '',
            ...namedOptionTitles
        ]
            .filter(Boolean)
            .join(namedOptionsSeparator);
    }
    getNamedOptionTitles(value, options) {
        const optionGuids = options.map((option) => option.guid);
        return value.namedOptions
            .sort((option1, option2) => optionGuids.indexOf(option1) - optionGuids.indexOf(option2))
            .map((guid) => { var _a; return (_a = options.find((option) => option.guid === guid)) === null || _a === void 0 ? void 0 : _a.title; });
    }
    getDatetimeCustomConfig(namedFilterOptions, config, fieldType, tagValueFormat) {
        return {
            getExpressionFieldTips: (option, searchTerm) => {
                return this.getNamedFilterOptionTips(namedFilterOptions, option, config.customConfig).concat(this.defaultConfig[fieldType].getExpressionFieldTips(option, searchTerm));
            },
            needRemoveTagValue(value) {
                return RxRecordGridAdvancedFilterValue.isEmptyWithRange(value);
            },
            formatValueForTag: (value) => {
                const formattedValue = value.filterValue
                    .filter((val) => val)
                    .map((date) => moment(date).format(tagValueFormat))
                    .join(' - ');
                return this.buildTagLabel(formattedValue, this.getNamedOptionTitles(value, namedFilterOptions));
            },
            updateFilterValue: (newValue, oldValue, filterOption) => {
                newValue.filterValue = this.defaultConfig[fieldType].updateFilterValue(newValue.filterValue, oldValue.filterValue, filterOption);
                newValue.namedOptions = uniq(oldValue.namedOptions.concat(newValue.namedOptions));
                return newValue;
            },
            parseTagFieldExpression: (filterOption, searchTerm) => {
                var _a, _b;
                const { value: valuesStr } = this.getExpressionRawValues(filterOption, searchTerm);
                if (!valuesStr) {
                    return null;
                }
                const value = this.getFilterValueFromString(namedFilterOptions, valuesStr);
                const [dateStr] = searchTerm.split('; ');
                value.filterValue = (_b = (_a = this.defaultConfig[fieldType].parseTagFieldExpression(filterOption, dateStr)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : [];
                return value.length ? { value } : null;
            },
            validateValue: (value, filterOption) => this.defaultConfig[fieldType].validateValue(value.filterValue, filterOption)
        };
    }
    getExpressionRawValues(filterOption, searchTerm) {
        return [
            `${filterOption.label}:`,
            `${filterOption.label} ${this.adaptTexts.fromLabel}`,
            `${filterOption.label} ${this.adaptTexts.toLabel}`
        ].reduce((result, mask) => {
            if (searchTerm.startsWith(mask)) {
                result.label = mask;
                result.value = searchTerm.replace(mask, '').trim();
            }
            return result;
        }, { label: null, value: null });
    }
    getFilterValueFromString(namedFilterOptions, valuesStr) {
        const values = (valuesStr !== null && valuesStr !== void 0 ? valuesStr : '')
            .trim()
            .split(';')
            .filter((str) => !isEmptyOrWhitespace(str))
            .map((str) => str.trim());
        const value = new RxRecordGridAdvancedFilterValue([]);
        values.forEach((val) => {
            var _a;
            const namedOptionGuid = (_a = namedFilterOptions.find((item) => item.title === val)) === null || _a === void 0 ? void 0 : _a.guid;
            if (namedOptionGuid) {
                value.namedOptions.push(namedOptionGuid);
            }
            else {
                value.filterValue.push(...val
                    .split(',')
                    .map((str) => str.trim())
                    .filter(Boolean));
            }
        });
        value.namedOptions = uniq(value.namedOptions);
        return value;
    }
    getNamedFilterOptionTips(namedFilterOptions, option, filterOptionConfig, value = []) {
        return (namedFilterOptions !== null && namedFilterOptions !== void 0 ? namedFilterOptions : []).map((item) => AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag(new RxRecordGridAdvancedFilterValue(value, [item.guid]), option, filterOptionConfig, false, formatAdvancedFilterTagText(option, item.title)));
    }
}
RxRecordGridAdvancedFilteringService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridAdvancedFilteringService, deps: [{ token: i1$5.RxRecordDefinitionService }, { token: i2$1.RxObjectUtilsService }, { token: RxRecordGridUtilsService }, { token: i2$6.RxNamedListService }, { token: i1.AdvancedFilterDataTypesConfigsService }, { token: i1.AdaptTranslateService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridAdvancedFilteringService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridAdvancedFilteringService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridAdvancedFilteringService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$5.RxRecordDefinitionService }, { type: i2$1.RxObjectUtilsService }, { type: RxRecordGridUtilsService }, { type: i2$6.RxNamedListService }, { type: i1.AdvancedFilterDataTypesConfigsService }, { type: i1.AdaptTranslateService }]; } });

class RxRecordGridFilterHelperService {
    constructor(rxJsonParserService) {
        this.rxJsonParserService = rxJsonParserService;
        this.filtersKeywords = ['$NULL$', '$TIME$', '$DATE$', '$TIMESTAMP$', '$USER$'];
    }
    // Convert predefined filter data from:
    // "{
    //   and: [
    //     "or": [
    //       {
    //         "eq": "36dfbd6f-7a19-4b4a-81bf-431fe41f6862"
    //       }
    //     ]
    //   ]
    // }"
    //
    //
    // to:
    // {
    //   and: [
    //     "or": [
    //       {
    //         "eq": {
    //           "1": "bar"
    //         }
    //       }
    //     ]
    //   ]
    // }
    //
    getRecordGridFilterDataFromPredefinedFilter(filterJson, recordGridFilters) {
        if (!isEmpty(recordGridFilters) && filterJson) {
            filterJson = this.normalizeFilterString(filterJson, recordGridFilters);
        }
        return this.clearFilterData(this.rxJsonParserService.tryParseJson(filterJson));
    }
    // Convert predefined filter string from:
    // "{
    //   and: [
    //     "or": [
    //       {
    //         "eq": "36dfbd6f-7a19-4b4a-81bf-431fe41f6862"
    //       }
    //     ]
    //   ]
    // }"
    //
    // to:
    // "{
    //   and: [
    //     "or": [
    //       {
    //         "eq": {
    //           "1": "bar"
    //         }
    //       }
    //     ]
    //   ]
    // }"
    //
    normalizeFilterString(filterString, filterComponents) {
        forEach(filterComponents, (filterComponent) => {
            const filterExpression = Object.assign({ [filterComponent.fieldId]: filterComponent.value }, (filterComponent.$DISPLAYVALUE$ && { $DISPLAYVALUE$: filterComponent.$DISPLAYVALUE$ }));
            filterString = filterString.replace(`"${filterComponent.guid}"`, JSON.stringify(filterExpression));
        });
        return filterString;
    }
    // Convert predefined filter string from:
    // "{
    //   and: [
    //     "or": [
    //       {
    //         "eq": {
    //           "1": "bar"
    //         }
    //       }
    //     ]
    //   ]
    // }"
    //
    //
    // to:
    // "{
    //   and: [
    //     "or": [
    //       {
    //         "eq": "36dfbd6f-7a19-4b4a-81bf-431fe41f6862"
    //       }
    //     ]
    //   ]
    // }"
    //
    denormalizeFilterString(filterString, filterComponents) {
        forEach(filterComponents, (filterComponent) => {
            const filterExpression = Object.assign({ [filterComponent.fieldId]: filterComponent.value }, (filterComponent.$DISPLAYVALUE$ && { $DISPLAYVALUE$: filterComponent.$DISPLAYVALUE$ }));
            if (filterExpression.$DISPLAYVALUE$) {
                filterString = JSON.stringify(JSON.parse(filterString), this.replacer(this.denormalize(filterComponent.guid, filterExpression)));
            }
            else {
                filterString = filterString.replace(JSON.stringify(filterExpression), `"${filterComponent.guid}"`);
            }
        });
        return filterString;
    }
    // e.g.
    // fn = denormalize(guid, {"536870913":"AGGADG1AAXPMRARKA0FGRKA0FG6I01","$DISPLAYVALUE$":"foo"});
    //
    // var filterExpression = {
    //   "and": [
    //     {
    //       "or": [
    //         {
    //           "eq": {
    //             "536870913": "AGGADG1AAXPMRARKA0FGRKA0FG6I01",
    //             "$DISPLAYVALUE$": "foo"
    //           }
    //         }
    //       ]
    //     }
    //   ]
    // };
    //
    // JSON.stringify(filterExpression,replacer(fn));
    // Here the filterExpression's keys are "add", “0”, “or”, “0”, “eq”
    //
    replacer(fn) {
        return (key, value) => (typeof key === 'string' && fn[key] ? fn[key](value) : value);
    }
    // This method declares, how object's value of an operator key should denormalize.
    //
    // Converts the Enum RecordGridFilterOperator
    // to
    // "
    // {
    //   "eq": fn(),
    //   "gte": fn(),
    //   "lte": fn(),
    //   "like": fn(),
    //   "ne": fn(),
    //   "lt": fn(),
    //   "gt": fn(),
    //   "in": fn()
    // }
    // "
    //  Note : fn() defines, how the value should be updated.
    //
    // e.g.
    // Converts predefined filter string from:
    //  {"and":[{"or":[{"eq":{"Foo":"Bar","$DISPLAYVALUE$":"Baz"}}]}]}
    // to:
    //  {“and":[{"or":[{"eq":"aa88747c-8b8e-4dee-abf2-556b84b7d28e"}]}]}
    denormalize(guid, filterExpression) {
        return reduce(RecordGridFilterOperator, (result, operator) => {
            result[operator] = (value) => (isEqual(value, filterExpression) ? guid : value);
            return result;
        }, {});
    }
    clearFilterData(node) {
        const nodeKeys = keys(node);
        let result = node;
        if (!isEmpty(nodeKeys)) {
            const operator = nodeKeys[0];
            switch (true) {
                case includes(['or', 'and'], operator): {
                    const children = node[operator].map(this.clearFilterData.bind(this)).filter((child) => Boolean(child));
                    if (!isEmpty(children)) {
                        node[operator] = children;
                    }
                    else {
                        result = null;
                    }
                    break;
                }
                case isString(node[operator]): {
                    result = null;
                    break;
                }
            }
        }
        return result;
    }
    replaceKeywords(query) {
        const singleQuoteRegexTemplate = '([^|^"])"(' + this.filtersKeywords.join('|').replace(/\$/g, '\\$') + ')"(?!")';
        const tripleQuoteRegexTemplate = '([^|^"])"""(' + this.filtersKeywords.join('|').replace(/\$/g, '\\$') + ')"""(?!")';
        const singleQuoteRegex = new RegExp(singleQuoteRegexTemplate, 'g');
        const tripleQuoteRegex = new RegExp(tripleQuoteRegexTemplate, 'g');
        return query.replace(singleQuoteRegex, '$1$2').replace(tripleQuoteRegex, '$1"$2"');
    }
}
RxRecordGridFilterHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterHelperService, deps: [{ token: i2$1.RxJsonParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridFilterHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterHelperService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterHelperService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2$1.RxJsonParserService }]; } });

class RxRecordGridFilterService {
    constructor(rxStringService, rxRecordGridUtilsService, rxJsonParserService, rxRecordGridAdvancedFilteringService, rxRecordDefinitionService, rxObjectUtilsService, rxRecordGridFilterHelperService) {
        this.rxStringService = rxStringService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxJsonParserService = rxJsonParserService;
        this.rxRecordGridAdvancedFilteringService = rxRecordGridAdvancedFilteringService;
        this.rxRecordDefinitionService = rxRecordDefinitionService;
        this.rxObjectUtilsService = rxObjectUtilsService;
        this.rxRecordGridFilterHelperService = rxRecordGridFilterHelperService;
        this.filtersKeywords = ['$NULL$', '$TIME$', '$DATE$', '$TIMESTAMP$', '$USER$'];
    }
    clearFilterData(node) {
        const nodeKeys = keys(node);
        let result = node;
        if (!isEmpty(nodeKeys)) {
            const operator = nodeKeys[0];
            switch (true) {
                case includes(['or', 'and'], operator): {
                    const children = node[operator].map(this.clearFilterData.bind(this)).filter((child) => Boolean(child));
                    if (!isEmpty(children)) {
                        node[operator] = children;
                    }
                    else {
                        result = null;
                    }
                    break;
                }
                case isString(node[operator]): {
                    result = null;
                    break;
                }
            }
        }
        return result;
    }
    getFilterForAvailableColumns(node, filterableColumns) {
        const nodeKeys = keys(node);
        let result = node;
        if (!isEmpty(nodeKeys)) {
            const operator = nodeKeys[0];
            const fieldId = Object.keys(node[operator])[0];
            switch (true) {
                case includes(['or', 'and'], operator): {
                    const children = node[operator]
                        .map((nodeChild) => this.getFilterForAvailableColumns(nodeChild, filterableColumns))
                        .filter((child) => Boolean(child));
                    if (!isEmpty(children)) {
                        node[operator] = children;
                    }
                    else {
                        result = null;
                    }
                    break;
                }
                case !some(filterableColumns, { fieldId }): {
                    result = null;
                    break;
                }
                case includes(['eq'], operator): {
                    const fieldDefinition = find(filterableColumns, { fieldId }).fieldDefinition;
                    // remove selection field filter option that is not available
                    if (fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.selection &&
                        !has(fieldDefinition.optionNamesById, node[operator][fieldId])) {
                        result = null;
                    }
                    break;
                }
            }
        }
        return result;
    }
    replaceKeywords(query) {
        const singleQuoteRegexTemplate = '([^|^"])"(' + this.filtersKeywords.join('|').replace(/\$/g, '\\$') + ')"(?!")';
        const tripleQuoteRegexTemplate = '([^|^"])"""(' + this.filtersKeywords.join('|').replace(/\$/g, '\\$') + ')"""(?!")';
        const singleQuoteRegex = new RegExp(singleQuoteRegexTemplate, 'g');
        const tripleQuoteRegex = new RegExp(tripleQuoteRegexTemplate, 'g');
        return query.replace(singleQuoteRegex, '$1$2').replace(tripleQuoteRegex, '$1"$2"');
    }
    generateTextFilterQuery(text, columns) {
        let filterQuery = null;
        if (text) {
            const query = columns
                .filter((column) => !column.hidden && column.searchable)
                .map((column) => {
                const fieldId = this.getQueryFilterField(column.field);
                let queryString = '';
                if (column.filterType === RX_RECORD_DEFINITION.dataTypes.character.shortName ||
                    column.filterType === RX_RECORD_DEFINITION.dataTypes.localizedCharacter.shortName) {
                    queryString = `${fieldId} LIKE "%${this.escapeDoubleQuotes(text).replace(/[%_]/g, '\\$&')}%"`;
                }
                else {
                    if (!isNaN(text)) {
                        queryString = `${fieldId} = "${this.escapeDoubleQuotes(text)}"`;
                    }
                }
                return queryString;
            })
                .filter(Boolean)
                .join(' OR ');
            filterQuery = query ? `(${query})` : '';
        }
        return filterQuery;
    }
    addQueries(...queries) {
        return filter$1(queries, Boolean).join(' AND ');
    }
    joinQueryFilters(queries, logic) {
        const query = queries.join(logic === QueryFiltersLogic.And ? ' AND ' : ' OR ');
        return query ? `(${query})` : '';
    }
    /**
     * Convert saved filter preset data from:
     * {
     *   and: {
     *     "or": [
     *       {
     *         "eq": {
     *           "1": "bar"
     *         }
     *       },
     *       {
     *         "eq": {
     *           "1": "foo"
     *         }
     *       }
     *     ]
     *   }
     * }
     *
     *
     * to:
     * [{
     *   filterOptionId: '1',
     *   value: ['bar', 'foo']
     * }]
     */
    getAdvancedFilterData(filterData, fieldDefinitionsById, recordGridFilterConfigs, primaryRecordDefinition, filterOptions, associationDescriptors) {
        return forkJoin(filterData && filterData.and
            ? filterData.and.map((gridFilterData) => {
                const filterLogic = Object.keys(gridFilterData)[0];
                const filterOperators = gridFilterData[filterLogic];
                const firstFilterOperator = values(filterOperators[0])[0];
                const columnField = String(Object.keys(firstFilterOperator)[0]);
                let fieldDefinition = fieldDefinitionsById[columnField];
                const fieldDefinition$ = fieldDefinition
                    ? of(fieldDefinition)
                    : this.rxRecordGridUtilsService.getFieldDefinition(columnField, primaryRecordDefinition);
                return fieldDefinition$.pipe(filter(Boolean), map((newFieldDefinition) => {
                    fieldDefinition = newFieldDefinition;
                    const filterConfig = recordGridFilterConfigs[fieldDefinition.resourceType];
                    if (!fieldDefinitionsById[columnField]) {
                        this.rxRecordDefinitionService.addFieldDefinitionToMap(fieldDefinition, fieldDefinitionsById, columnField);
                        fieldDefinitionsById = primaryRecordDefinition.fieldDefinitionsById = Object.assign(Object.assign({}, fieldDefinitionsById), this.rxObjectUtilsService.expandProperties(fieldDefinitionsById));
                        const associationDescriptor = this.rxRecordGridUtilsService.findAssociationDescriptor(associationDescriptors, this.rxRecordGridUtilsService.getFieldLocator(columnField));
                        filterOptions.push(this.rxRecordGridAdvancedFilteringService.getAdvancedFilterOption(columnField, this.rxRecordGridUtilsService.getColumnLabel(fieldDefinition, associationDescriptor), fieldDefinition, filterConfig, true));
                    }
                    return filterConfig.getSelectedAdvancedFilterData(filterLogic, filterOperators, fieldDefinition, columnField);
                }));
            })
            : []).pipe(defaultIfEmpty([]), map((advancedFiltersData) => advancedFiltersData.filter(Boolean)));
    }
    getQueryFromRecordGridFilterData(filterData, fieldDefinitionsById) {
        const primitiveOperators = [
            RecordGridFilterOperator.Eq,
            RecordGridFilterOperator.Like,
            RecordGridFilterOperator.Ne,
            RecordGridFilterOperator.Lt,
            RecordGridFilterOperator.Lte,
            RecordGridFilterOperator.Gt,
            RecordGridFilterOperator.Gte,
            RecordGridFilterOperator.In,
            'regex'
        ];
        const isPrimitive = (expression) => {
            return intersection(primitiveOperators.slice(), keys(expression)).length > 0;
        };
        const evaluatePrimitive = (expression) => {
            return reduce(expression, (operatorsResult, condition, operator) => {
                return (operatorsResult +
                    reduce(condition, (operatorValuesResult, conditionValue, conditionId) => {
                        const fieldDefinition = fieldDefinitionsById[conditionId];
                        let filterOperator = operator;
                        let value = conditionValue;
                        const isTextField = !!fieldDefinition &&
                            includes([
                                RX_RECORD_DEFINITION.dataTypes.character.resourceType,
                                RX_RECORD_DEFINITION.dataTypes.localizedCharacter.resourceType
                            ], fieldDefinition.resourceType);
                        if (isTextField) {
                            const { isLikeOperation, filterValue } = this.getStringDataTypeFilterData(conditionValue, fieldDefinition);
                            filterOperator = isLikeOperation ? RecordGridFilterOperator.Like : filterOperator;
                            value = filterValue;
                        }
                        // following code removes the $DISPLAYVALUE$ from the filter expression
                        // e.g.  {"and":[{"or":[{"eq":{"536870913":"AGGADG1AAXPMRARKA0FGRKA0FG6I01","$DISPLAYVALUE$":"Alex"}}]}]}
                        if (conditionId === '$DISPLAYVALUE$') {
                            return operatorValuesResult;
                        }
                        return operatorValuesResult + this.getQueryExpression(value, conditionId, filterOperator);
                    }, ''));
            }, '');
        };
        let evaluateExpression = (expression) => {
            if (isPrimitive(expression)) {
                return evaluatePrimitive(expression);
            }
            return reduce(expression, (result, childExpression, operator) => {
                const childExpressionResult = map$1(childExpression, evaluateExpression);
                switch (operator) {
                    case RecordGridFilterDataLogic.And:
                        return result + `(${childExpressionResult.join(' AND ')})`;
                    case RecordGridFilterDataLogic.Or:
                        return result + `(${childExpressionResult.join(' OR ')})`;
                    default:
                        return result + `(${childExpressionResult.join(' AND ')})`;
                }
            }, '');
        };
        evaluateExpression = evaluateExpression.bind(this);
        return evaluateExpression(filterData);
    }
    getSelectedFiltersFromPredefinedFilter(filters, recordGridFilters, fieldDefinitionsById, recordGridFilterConfigs, primaryRecordDefinition, filterOptions, associationDescriptors) {
        const recordGridFilterData = this.rxRecordGridFilterHelperService.getRecordGridFilterDataFromPredefinedFilter(filters, this.deserializeNamedOptions(recordGridFilters));
        const selectedFilters$ = this.getAdvancedFilterData(recordGridFilterData, fieldDefinitionsById, recordGridFilterConfigs, primaryRecordDefinition, filterOptions, associationDescriptors);
        return selectedFilters$;
    }
    getRecordGridFilterDataFromAdvancedFilter(filters, fieldDefinitionsById, recordGridFilterConfigs, namedFilterOptions) {
        const mappedFilters = filters.map((filterData) => {
            let mappedFilter = null;
            const fieldId = String(filterData.filterOptionId);
            const fieldDefinition = fieldDefinitionsById[fieldId];
            if (fieldDefinition) {
                const filterConfig = recordGridFilterConfigs[fieldDefinition.resourceType];
                mappedFilter = filterConfig.getRecordGridFilterData(filterData.value, fieldDefinition, fieldId, namedFilterOptions && namedFilterOptions[fieldId]);
            }
            return mappedFilter;
        });
        return mappedFilters.length
            ? {
                and: mappedFilters
            }
            : {};
    }
    getQueryFilterField(fieldId) {
        if (this.rxRecordGridUtilsService.isAssociatedRecordFieldId(fieldId)) {
            return `\${${fieldId}}`;
        }
        else {
            return `'${fieldId}'`;
        }
    }
    buildQueryFilter(fieldId, operator, value) {
        const needQuotes = isString(value) && !this.filtersKeywords.includes(value);
        const result = isString(value) ? (needQuotes ? `"${this.escapeDoubleQuotes(value)}"` : value) : String(value);
        return `${this.getQueryFilterField(fieldId)} ${operator} ${result}`;
    }
    filterRows(rows, filters, recordDefinition, filterConfigs) {
        const filterData = this.getRecordGridFilterDataFromAdvancedFilter(filters, recordDefinition.fieldDefinitionsById, filterConfigs);
        return rows.filter((row) => {
            if (row.groupField) {
                row.items = this.getFilteredItems(row.items, filterData, recordDefinition);
                return row.items.length;
            }
            else {
                return every(filterData.and, (filterExpression) => this.matchRow(row, filterExpression, recordDefinition));
            }
        });
    }
    getFilteredItems(rowDataItems, filterData, recordDefinition) {
        return reduce(rowDataItems, (filteredItems, itemsRow) => {
            let { items = [] } = itemsRow;
            if (!itemsRow.items &&
                every(filterData.and, (filterExpression) => this.matchRow(itemsRow, filterExpression, recordDefinition))) {
                filteredItems.push(itemsRow);
            }
            else {
                items = this.getFilteredItems(items, filterData, recordDefinition);
                if (items.length) {
                    filteredItems.push(Object.assign(Object.assign({}, itemsRow), { items }));
                }
            }
            return filteredItems;
        }, []);
    }
    matchRow(row, filterExpression, recordDefinition) {
        const operator = findKey(filterExpression);
        switch (operator) {
            case 'and':
                return every(filterExpression[operator], (childExpression) => this.checkCondition(row, childExpression, recordDefinition));
            case 'or':
                return some(filterExpression[operator], (childExpression) => this.checkCondition(row, childExpression, recordDefinition));
            default:
                return false;
        }
    }
    checkCondition(row, childExpression, recordDefinition) {
        const operator = findKey(childExpression);
        const fieldId = findKey(childExpression[operator]);
        const filterValue = childExpression[operator][fieldId];
        const rowValue = row[fieldId];
        if (recordDefinition.fieldDefinitionsById[fieldId].resourceType ===
            RX_RECORD_DEFINITION.dataTypes.dateTime.resourceType) {
            switch (operator) {
                case 'eq':
                    return moment(rowValue).isSame(filterValue);
                case 'lte':
                    return moment(rowValue).isSameOrBefore(filterValue);
                case 'lt':
                    return moment(rowValue).isBefore(filterValue);
                case 'gte':
                    return moment(rowValue).isSameOrAfter(filterValue);
                case 'gt':
                    return moment(rowValue).isAfter(filterValue);
                default:
                    return false;
            }
        }
        else {
            return operator === 'eq' ? this.rxStringService.caseInsensitiveIsEqual(rowValue, filterValue) : false;
        }
    }
    escapeDoubleQuotes(text) {
        return text.replace(/"/g, '""');
    }
    getQueryExpression(conditionValue, conditionId, operator) {
        const value = isString(conditionValue) ? '"' + conditionValue + '"' : conditionValue;
        conditionId = this.getQueryFilterField(conditionId);
        switch (operator) {
            case RecordGridFilterOperator.Eq:
                return conditionId + '=' + value;
            case RecordGridFilterOperator.Like:
                return conditionId + ' LIKE ' + value;
            case RecordGridFilterOperator.Ne:
                return conditionId + '!=' + value;
            case RecordGridFilterOperator.Lt:
                return conditionId + '<' + value;
            case RecordGridFilterOperator.Lte:
                return conditionId + '<=' + value;
            case RecordGridFilterOperator.Gt:
                return conditionId + '>' + value;
            case RecordGridFilterOperator.Gte:
                return conditionId + '>=' + value;
            case RecordGridFilterOperator.In:
                return conditionId + ' IN ' + value;
            default:
                return conditionId + '=' + value;
        }
    }
    getStringDataTypeFilterData(filterValue, fieldDefinition) {
        let isLikeOperation = false;
        if (!get(fieldDefinition.searchDefinition, 'enableFTSSearch')) {
            if (includes(filterValue, '%')) {
                const filterValueSplitData = filterValue.split(/\\\\/);
                isLikeOperation = some(filterValueSplitData, (value) => value.replace(/\\%/g, '').match('%'));
                if (!isLikeOperation) {
                    filterValue = map$1(filterValueSplitData, (value) => value.replace(/\\%/g, '%')).join('\\');
                }
            }
            else {
                filterValue = filterValue.replace('\\\\', '\\');
            }
        }
        return { isLikeOperation, filterValue };
    }
    clearRemovedNamedFilterOptions(selectedFilters, namedFilterOptions) {
        return selectedFilters.reduce((result, filter) => {
            var _a, _b;
            const namedFilterOptionsGuids = (_b = (_a = namedFilterOptions[filter.filterOptionId]) === null || _a === void 0 ? void 0 : _a.map((option) => option.guid)) !== null && _b !== void 0 ? _b : [];
            filter.value.namedOptions = filter.value.namedOptions.filter((option) => namedFilterOptionsGuids.includes(option));
            if (!RxRecordGridAdvancedFilterValue.isEmptyWithRange(filter.value)) {
                result.push(filter);
            }
            return result;
        }, []);
    }
    deserializeNamedOptions(recordGridFilters) {
        return recordGridFilters.map((filter) => {
            const value = this.rxJsonParserService.tryParseJson(filter.value);
            if (value && value[RecordGridNamedFilterOptionKey]) {
                return Object.assign(Object.assign({}, filter), { value });
            }
            return filter;
        });
    }
}
RxRecordGridFilterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterService, deps: [{ token: i2$1.RxStringService }, { token: RxRecordGridUtilsService }, { token: i2$1.RxJsonParserService }, { token: RxRecordGridAdvancedFilteringService }, { token: i1$5.RxRecordDefinitionService }, { token: i2$1.RxObjectUtilsService }, { token: RxRecordGridFilterHelperService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridFilterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i2$1.RxStringService }, { type: RxRecordGridUtilsService }, { type: i2$1.RxJsonParserService }, { type: RxRecordGridAdvancedFilteringService }, { type: i1$5.RxRecordDefinitionService }, { type: i2$1.RxObjectUtilsService }, { type: RxRecordGridFilterHelperService }]; } });

class RxRecordGridFilterConfigService {
    constructor(rxRecordGridFilterService, rxNumberUtilsService, rxNamedListService, translateService, rxRecordInstanceUtilsService, rxRecordGridUtilsService, rxDefinitionNameService) {
        this.rxRecordGridFilterService = rxRecordGridFilterService;
        this.rxNumberUtilsService = rxNumberUtilsService;
        this.rxNamedListService = rxNamedListService;
        this.translateService = translateService;
        this.rxRecordInstanceUtilsService = rxRecordInstanceUtilsService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxDefinitionNameService = rxDefinitionNameService;
        this.associatedFieldIdPatternRegExp = new RegExp(`'(${RX_RECORD_GRID.associatedFieldIdPrefixPattern}\\d+)'`, 'g');
    }
    getConfigs() {
        const textColumnFilterConfig = {
            filterOptionDataType: AdvancedFilterOptionDataType.string,
            getQueryFilter: (filterTag, fieldDefinition, fieldId, namedFilterOptions) => {
                const selectedNamedOptionExpressions = this.getSelectedNamedOptionExpressions(namedFilterOptions, filterTag);
                const builtQuery = chain(filterTag.value.filterValue)
                    .filter(Boolean)
                    .map((optionValue) => {
                    const { isLikeOperation, filterValue } = this.rxRecordGridFilterService.getStringDataTypeFilterData(get(optionValue, 'value', optionValue), fieldDefinition);
                    return this.rxRecordGridFilterService.buildQueryFilter(fieldId, isLikeOperation ? 'like' : '=', filterValue.trim());
                })
                    .concat(selectedNamedOptionExpressions)
                    .value();
                return this.rxRecordGridFilterService.joinQueryFilters(builtQuery, QueryFiltersLogic.Or);
            },
            getRecordGridFilterData: (value, fieldDefinition, fieldId, namedFilterOptions) => {
                const namedFilterOptionOperators = this.getNamedFilterOptionsOperators(value, fieldId);
                const filterOperators = value.filterValue.map((filterValue) => {
                    const operators = this.getRecordGridFilterOperator(RecordGridFilterOperator.Eq, fieldId, get(filterValue, 'value', filterValue).trim());
                    const displayValue = get(filterValue, 'displayValue');
                    if (fieldDefinition.namedListDefinition && displayValue) {
                        operators.eq['$DISPLAYVALUE$'] = displayValue;
                    }
                    return operators;
                });
                return {
                    or: filterOperators.concat(namedFilterOptionOperators)
                };
            },
            getSelectedAdvancedFilterData: (filterLogic, filterOperators, fieldDefinition, fieldId) => {
                const filterValues = [];
                const namedListFilterValues = [];
                const namedFilterOptionsGuids = [];
                if (filterLogic === RecordGridFilterDataLogic.Or) {
                    filterOperators.forEach((filterOperator) => {
                        const operator = Object.keys(filterOperator)[0];
                        const value = filterOperator[operator][fieldId];
                        if (isString(value)) {
                            if (fieldDefinition.namedListDefinition) {
                                const displayValue = filterOperator[operator]['$DISPLAYVALUE$'];
                                namedListFilterValues.push({ displayValue, value, title: '', contextualFields: [] });
                            }
                            else {
                                filterValues.push(value);
                            }
                        }
                        else if (value[RecordGridNamedFilterOptionKey]) {
                            namedFilterOptionsGuids.push(value[RecordGridNamedFilterOptionKey]);
                        }
                    });
                }
                const rxRecordGridAdvancedFilterValue = isEmpty(namedListFilterValues)
                    ? new RxRecordGridAdvancedFilterValue(filterValues, namedFilterOptionsGuids)
                    : new RxRecordGridAdvancedFilterValue(namedListFilterValues, namedFilterOptionsGuids);
                return {
                    filterOptionId: fieldId,
                    value: rxRecordGridAdvancedFilterValue
                };
            },
            getToolbarTagInfo: ({ primaryRecordDefinition, value, tag, fieldId, namedFilterOptions }) => {
                const fieldLocator = this.rxRecordGridUtilsService.getFieldLocator(fieldId);
                let associationDescriptor;
                return this.rxRecordGridUtilsService.getAssociationDescriptor(fieldId, primaryRecordDefinition).pipe(mergeMap((loadedAssociationDescriptor) => {
                    associationDescriptor = loadedAssociationDescriptor;
                    return this.rxRecordGridUtilsService.getDisplayFieldDescriptor(fieldId, primaryRecordDefinition, associationDescriptor && associationDescriptor.recordDefinitionName);
                }), mergeMap((displayFieldDefinition) => {
                    const isRecordDisplayField = fieldLocator.fieldId !== String(displayFieldDefinition.id);
                    let displayValuesData$;
                    if (isRecordDisplayField) {
                        const filterValues = this.rxNamedListService.getNamesFromTypeAheadOptions(value.filterValue);
                        displayValuesData$ = this.rxRecordInstanceUtilsService
                            .getFieldValues(associationDescriptor.recordDefinitionName, filterValues, [
                            String(RX_RECORD_DEFINITION.coreFieldIds.id),
                            String(displayFieldDefinition.id)
                        ])
                            .pipe(map((displayValueRows) => {
                            const nameWithAssociationLabel = compact([
                                this.rxDefinitionNameService.getDisplayName(associationDescriptor.associationDefinition.name),
                                displayFieldDefinition.name
                            ]).join(' > ');
                            const displayValues = value.filterValue.map((strFilterValue) => {
                                const row = find(displayValueRows, (displayValueRow) => displayValueRow[RX_RECORD_DEFINITION.coreFieldIds.id] === strFilterValue);
                                return row ? row[displayFieldDefinition.id] : strFilterValue;
                            });
                            return {
                                displayValues: new RxRecordGridAdvancedFilterValue(displayValues),
                                label: nameWithAssociationLabel
                            };
                        }));
                    }
                    else {
                        displayValuesData$ = of({ displayValues: value, label: tag.data.filterOption.label });
                    }
                    return displayValuesData$.pipe(map(({ displayValues, label }) => {
                        const displayTagValue = displayValues.filterValue
                            .map((filterValue) => {
                            var _a, _b;
                            const filterValueExpression = get(filterValue, 'value', filterValue);
                            const filterDisplayText = (_a = get(filterValue, 'displayValue')) !== null && _a !== void 0 ? _a : get(filterValue, 'value', filterValue);
                            const text = filterValueExpression === '$USER$'
                                ? this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.filters.me.label')
                                : filterDisplayText;
                            const tooltip = (filterValue === null || filterValue === void 0 ? void 0 : filterValue.displayValue)
                                ? `${filterValue.displayValue} (${filterValue.value})`
                                : (_b = filterValue === null || filterValue === void 0 ? void 0 : filterValue.value) !== null && _b !== void 0 ? _b : filterValue;
                            return { tooltip, text };
                        })
                            .concat(displayValues.namedOptions.map((namedOption) => {
                            var _a;
                            const namedFilterOption = ((_a = namedFilterOptions.find((option) => option.guid === namedOption)) === null || _a === void 0 ? void 0 : _a.title) || namedOption;
                            return { text: namedFilterOption, tooltip: namedFilterOption };
                        }));
                        const displayText = displayTagValue.map((tagInfo) => tagInfo.text).join(', ');
                        const tooltip = displayTagValue.map((tagInfo) => tagInfo.tooltip).join(', ');
                        return {
                            text: `${label}: ${displayText}`,
                            tooltip: `${label}: ${tooltip}`
                        };
                    }));
                }));
            },
            getDataForAdvancedFilter: (fieldDefinition) => fieldDefinition
        };
        const numericColumnFilterConfig = {
            filterOptionDataType: AdvancedFilterOptionDataType.number,
            getQueryFilter: (filterTag, fieldDefinition, fieldId, namedFilterOptions) => {
                const selectedNamedOptionExpressions = this.getSelectedNamedOptionExpressions(namedFilterOptions, filterTag);
                const [fromValue, toValue] = filterTag.value.filterValue;
                const queries = [];
                if (this.rxNumberUtilsService.isFiniteOrNumberString(fromValue)) {
                    queries.push(this.rxRecordGridFilterService.buildQueryFilter(fieldId, '>=', String(fromValue)));
                }
                if (this.rxNumberUtilsService.isFiniteOrNumberString(toValue)) {
                    queries.push(this.rxRecordGridFilterService.buildQueryFilter(fieldId, '<=', String(toValue)));
                }
                const valueQuery = this.rxRecordGridFilterService.joinQueryFilters(queries, QueryFiltersLogic.And);
                return this.rxRecordGridFilterService.joinQueryFilters(valueQuery ? [valueQuery, ...selectedNamedOptionExpressions] : selectedNamedOptionExpressions, QueryFiltersLogic.Or);
            },
            getRecordGridFilterData: (value, fieldDefinition, fieldId) => {
                const [fromValue, toValue] = value.filterValue;
                const queries = [];
                if (this.rxNumberUtilsService.isFiniteOrNumberString(fromValue)) {
                    queries.push(this.getRecordGridFilterOperator(RecordGridFilterOperator.Gte, fieldId, String(fromValue)));
                }
                if (this.rxNumberUtilsService.isFiniteOrNumberString(toValue)) {
                    queries.push(this.getRecordGridFilterOperator(RecordGridFilterOperator.Lte, fieldId, String(toValue)));
                }
                return this.getFilterRangeDataOperator(queries, this.getNamedFilterOptionsOperators(value, fieldId));
            },
            getDataForAdvancedFilter: (fieldDefinition) => {
                return {
                    minValue: fieldDefinition.minValue,
                    maxValue: fieldDefinition.maxValue
                };
            },
            getSelectedAdvancedFilterData: (filterLogic, filterOperators, fieldDefinition, fieldId) => {
                /**
                 * Convert from:
                 *
                 *  "and": [
                 *    {
                 *      "gte": {
                 *        "536870917": -5
                 *      }
                 *    },
                 *    {
                 *      "lte": {
                 *        "536870917": -1 // or "-1"
                 *      }
                 *    }
                 *  ]
                 *
                 * to:
                 *
                 * {
                 *   filterOptionId: '536870917',
                 *   value: [-5, -1]
                 * }
                 *
                 */
                let filterValue = [null, null];
                const processRange = (operators) => {
                    const gteOperator = find(operators, (filterOperator) => filterOperator[RecordGridFilterOperator.Gte]);
                    if (gteOperator) {
                        const fromValue = parseFloat(gteOperator[RecordGridFilterOperator.Gte][fieldId]);
                        if (this.rxNumberUtilsService.isFiniteOrNumberString(fromValue)) {
                            filterValue[0] = fromValue;
                        }
                    }
                    const lteOperator = find(operators, (filterOperator) => filterOperator[RecordGridFilterOperator.Lte]);
                    if (lteOperator) {
                        const toValue = parseFloat(lteOperator[RecordGridFilterOperator.Lte][fieldId]);
                        if (this.rxNumberUtilsService.isFiniteOrNumberString(toValue)) {
                            filterValue[1] = toValue;
                        }
                    }
                };
                if (filterLogic === RecordGridFilterDataLogic.And) {
                    processRange(filterOperators);
                }
                else if (filterLogic === RecordGridFilterDataLogic.Or) {
                    const andOperator = find(filterOperators, (filterOperator) => filterOperator[RecordGridFilterDataLogic.And]);
                    if (andOperator) {
                        processRange(andOperator[RecordGridFilterDataLogic.And]);
                    }
                    else if (filterOperators.length === 1) {
                        let eqValue = filterOperators[0][RecordGridFilterOperator.Eq][fieldId];
                        if (eqValue !== '$NULL$' && !eqValue[RecordGridNamedFilterOptionKey]) {
                            eqValue = parseFloat(eqValue);
                            filterValue = [eqValue, eqValue];
                        }
                    }
                }
                const namedFilterOptionGuids = this.getNamedFilterOptionGuids(filterOperators, fieldId);
                return {
                    filterOptionId: fieldId,
                    value: new RxRecordGridAdvancedFilterValue(filterValue, namedFilterOptionGuids)
                };
            }
        };
        return {
            [RX_RECORD_DEFINITION.resourceTypes.character]: textColumnFilterConfig,
            [RX_RECORD_DEFINITION.resourceTypes.localizedCharacter]: textColumnFilterConfig,
            [RX_RECORD_DEFINITION.resourceTypes.attachment]: textColumnFilterConfig,
            [RX_RECORD_DEFINITION.resourceTypes.integer]: numericColumnFilterConfig,
            [RX_RECORD_DEFINITION.resourceTypes.decimal]: numericColumnFilterConfig,
            [RX_RECORD_DEFINITION.resourceTypes.real]: numericColumnFilterConfig,
            [RX_RECORD_DEFINITION.resourceTypes.selection]: {
                filterOptionDataType: AdvancedFilterOptionDataType.selection,
                getQueryFilter: (filterTag, fieldDefinition, fieldId, namedFilterOptions) => {
                    const selectedNamedOptionExpressions = this.getSelectedNamedOptionExpressions(namedFilterOptions, filterTag);
                    return this.rxRecordGridFilterService.joinQueryFilters(filterTag.value.filterValue
                        .map((filterValue) => this.rxRecordGridFilterService.buildQueryFilter(fieldId, '=', filterValue))
                        .concat(selectedNamedOptionExpressions), QueryFiltersLogic.Or);
                },
                getDataForAdvancedFilter: (fieldDefinition) => {
                    const selectOptions = map$1(fieldDefinition.optionLabelsById, (label, optionId) => ({
                        id: optionId,
                        name: label
                    }));
                    if (fieldDefinition.fieldOption === RX_RECORD_DEFINITION.fieldOptions.optional) {
                        selectOptions.unshift({
                            id: '$NULL$',
                            name: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.filters.blank.label')
                        });
                    }
                    return {
                        selectOptions,
                        selectTexts: null
                    };
                },
                getRecordGridFilterData: (value, fieldDefinition, fieldId) => {
                    const namedFilterOptionOperators = this.getNamedFilterOptionsOperators(value, fieldId);
                    return {
                        or: value.filterValue
                            .map((optionId) => {
                            return this.getRecordGridFilterOperator(RecordGridFilterOperator.Eq, fieldId, optionId);
                        })
                            .concat(namedFilterOptionOperators)
                    };
                },
                getSelectedAdvancedFilterData: (filterLogic, filterOperators, fieldDefinition, fieldId) => {
                    const filterValue = [];
                    const namedFilterOptionsGuids = [];
                    if (filterLogic === RecordGridFilterDataLogic.Or) {
                        filterOperators.forEach((filterOperator) => {
                            const operator = Object.keys(filterOperator)[0];
                            if (operator === RecordGridFilterOperator.Eq) {
                                const value = filterOperator[operator][fieldId];
                                if (isString(value)) {
                                    filterValue.push(value);
                                }
                                else if (value[RecordGridNamedFilterOptionKey]) {
                                    namedFilterOptionsGuids.push(value[RecordGridNamedFilterOptionKey]);
                                }
                            }
                        });
                    }
                    return {
                        filterOptionId: fieldId,
                        value: new RxRecordGridAdvancedFilterValue(filterValue, namedFilterOptionsGuids)
                    };
                }
            },
            [RX_RECORD_DEFINITION.resourceTypes.timeOnly]: {
                filterOptionDataType: AdvancedFilterOptionDataType.time,
                getQueryFilter: (filterTag, fieldDefinition, fieldId, namedFilterOptions) => {
                    const selectedNamedOptionExpressions = this.getSelectedNamedOptionExpressions(namedFilterOptions, filterTag);
                    const [fromValue, toValue] = filterTag.value.filterValue.map((value) => moment(value));
                    const queries = [];
                    if (fromValue && fromValue.isValid()) {
                        queries.push(this.rxRecordGridFilterService.buildQueryFilter(fieldId, '>=', fromValue.format('HH:mm:ss')));
                    }
                    if (toValue && toValue.isValid()) {
                        queries.push(this.rxRecordGridFilterService.buildQueryFilter(fieldId, '<=', toValue.format('HH:mm:ss')));
                    }
                    const valueQuery = this.rxRecordGridFilterService.joinQueryFilters(queries, QueryFiltersLogic.And);
                    return this.rxRecordGridFilterService.joinQueryFilters(valueQuery ? [valueQuery, ...selectedNamedOptionExpressions] : selectedNamedOptionExpressions, QueryFiltersLogic.Or);
                },
                getRecordGridFilterData: (value, fieldDefinition, fieldId) => {
                    const [fromValue, toValue] = value.filterValue.map((value) => moment(value));
                    const queries = [];
                    if (fromValue) {
                        queries.push(this.getRecordGridFilterOperator(RecordGridFilterOperator.Gte, fieldId, fromValue && fromValue.isValid() ? fromValue.format('HH:mm:ss') : ''));
                    }
                    if (toValue) {
                        queries.push(this.getRecordGridFilterOperator(RecordGridFilterOperator.Lte, fieldId, toValue && toValue.isValid() ? toValue.format('HH:mm:ss') : ''));
                    }
                    return this.getFilterRangeDataOperator(queries, this.getNamedFilterOptionsOperators(value, fieldId));
                },
                getSelectedAdvancedFilterData: (filterLogic, filterOperators, fieldDefinition, fieldId) => {
                    let filterValue = [null, null];
                    const processRange = (operators) => {
                        const gteOperator = find(operators, (filterOperator) => filterOperator[RecordGridFilterOperator.Gte]);
                        if (gteOperator) {
                            const fromValue = moment(gteOperator[RecordGridFilterOperator.Gte][fieldId], 'LTS');
                            if (fromValue.isValid()) {
                                filterValue[0] = fromValue;
                            }
                        }
                        const lteOperator = find(operators, (filterOperator) => filterOperator[RecordGridFilterOperator.Lte]);
                        if (lteOperator) {
                            const toValue = moment(lteOperator[RecordGridFilterOperator.Lte][fieldId], 'LTS');
                            if (toValue.isValid()) {
                                filterValue[1] = toValue;
                            }
                        }
                    };
                    if (filterLogic === RecordGridFilterDataLogic.And) {
                        processRange(filterOperators);
                    }
                    else if (filterLogic === RecordGridFilterDataLogic.Or) {
                        const andOperator = find(filterOperators, (filterOperator) => filterOperator[RecordGridFilterDataLogic.And]);
                        if (andOperator) {
                            processRange(andOperator[RecordGridFilterDataLogic.And]);
                        }
                        else if (filterOperators.length === 1) {
                            let eqValue = filterOperators[0][RecordGridFilterOperator.Eq][fieldId];
                            if (eqValue !== '$NULL$' && !eqValue[RecordGridNamedFilterOptionKey]) {
                                eqValue = moment(eqValue, 'LTS');
                                filterValue = [eqValue, eqValue];
                            }
                        }
                    }
                    const namedFilterOptionGuids = this.getNamedFilterOptionGuids(filterOperators, fieldId);
                    return {
                        filterOptionId: fieldId,
                        value: new RxRecordGridAdvancedFilterValue(filterValue, namedFilterOptionGuids)
                    };
                }
            },
            [RX_RECORD_DEFINITION.resourceTypes.dateOnly]: {
                filterOptionDataType: AdvancedFilterOptionDataType.date,
                getQueryFilter: (filterTag, fieldDefinition, fieldId, namedFilterOptions) => {
                    const selectedNamedOptionExpressions = this.getSelectedNamedOptionExpressions(namedFilterOptions, filterTag);
                    const [fromValue, toValue] = filterTag.value.filterValue.map((value) => moment(value));
                    const queries = [];
                    if (fromValue && fromValue.isValid()) {
                        queries.push(this.rxRecordGridFilterService.buildQueryFilter(fieldId, '>=', fromValue.format('YYYY-MM-DD')));
                    }
                    if (toValue && toValue.isValid()) {
                        queries.push(this.rxRecordGridFilterService.buildQueryFilter(fieldId, '<=', toValue.format('YYYY-MM-DD')));
                    }
                    const valueQuery = this.rxRecordGridFilterService.joinQueryFilters(queries, QueryFiltersLogic.And);
                    return this.rxRecordGridFilterService.joinQueryFilters(valueQuery ? [valueQuery, ...selectedNamedOptionExpressions] : selectedNamedOptionExpressions, QueryFiltersLogic.Or);
                },
                getRecordGridFilterData: (value, fieldDefinition, fieldId) => {
                    const [fromValue, toValue] = value.filterValue.map((value) => moment(value));
                    const queries = [];
                    if (fromValue) {
                        queries.push(this.getRecordGridFilterOperator(RecordGridFilterOperator.Gte, fieldId, fromValue && fromValue.isValid() ? fromValue.format('YYYY-MM-DD') : ''));
                    }
                    if (toValue) {
                        queries.push(this.getRecordGridFilterOperator(RecordGridFilterOperator.Lte, fieldId, toValue && toValue.isValid() ? toValue.format('YYYY-MM-DD') : ''));
                    }
                    return this.getFilterRangeDataOperator(queries, this.getNamedFilterOptionsOperators(value, fieldId));
                },
                getSelectedAdvancedFilterData: (filterLogic, filterOperators, fieldDefinition, fieldId) => {
                    return this.getDateSelectedAdvancedFilterData(fieldId, filterLogic, filterOperators);
                }
            },
            [RX_RECORD_DEFINITION.resourceTypes.dateTime]: {
                filterOptionDataType: AdvancedFilterOptionDataType.datetime,
                getQueryFilter: (filterTag, fieldDefinition, fieldId, namedFilterOptions) => {
                    const selectedNamedOptionExpressions = this.getSelectedNamedOptionExpressions(namedFilterOptions, filterTag);
                    const [fromValue, toValue] = filterTag.value.filterValue.map((value) => moment(value));
                    const queries = [];
                    if (fromValue === null || fromValue === void 0 ? void 0 : fromValue.isValid()) {
                        queries.push(this.rxRecordGridFilterService.buildQueryFilter(fieldId, '>=', fromValue.toISOString()));
                    }
                    if (toValue === null || toValue === void 0 ? void 0 : toValue.isValid()) {
                        queries.push(this.rxRecordGridFilterService.buildQueryFilter(fieldId, '<=', toValue.toISOString()));
                    }
                    const valueQuery = this.rxRecordGridFilterService.joinQueryFilters(queries, QueryFiltersLogic.And);
                    return this.rxRecordGridFilterService.joinQueryFilters(valueQuery ? [valueQuery, ...selectedNamedOptionExpressions] : selectedNamedOptionExpressions, QueryFiltersLogic.Or);
                },
                getRecordGridFilterData: (value, fieldDefinition, fieldId) => {
                    const [fromValue, toValue] = value.filterValue.map((value) => moment(value));
                    const queries = [];
                    if (fromValue === null || fromValue === void 0 ? void 0 : fromValue.isValid()) {
                        queries.push(this.getRecordGridFilterOperator(RecordGridFilterOperator.Gte, fieldId, fromValue.toISOString()));
                    }
                    if (toValue === null || toValue === void 0 ? void 0 : toValue.isValid()) {
                        queries.push(this.getRecordGridFilterOperator(RecordGridFilterOperator.Lte, fieldId, toValue.toISOString()));
                    }
                    return this.getFilterRangeDataOperator(queries, this.getNamedFilterOptionsOperators(value, fieldId));
                },
                getSelectedAdvancedFilterData: (filterLogic, filterOperators, fieldDefinition, fieldId) => {
                    return this.getDateSelectedAdvancedFilterData(fieldId, filterLogic, filterOperators);
                }
            },
            [RX_RECORD_DEFINITION.resourceTypes.boolean]: {
                filterOptionDataType: AdvancedFilterOptionDataType.boolean,
                getQueryFilter: (filterTag, fieldDefinition, fieldId, namedFilterOptions) => {
                    const selectedNamedOptionExpressions = this.getSelectedNamedOptionExpressions(namedFilterOptions, filterTag);
                    return this.rxRecordGridFilterService.joinQueryFilters(castArray(filterTag.value.filterValue)
                        .map((filterValue) => this.rxRecordGridFilterService.buildQueryFilter(fieldId, '=', this.getBooleanFilterValue(filterValue)))
                        .concat(selectedNamedOptionExpressions), QueryFiltersLogic.Or);
                },
                getRecordGridFilterData: (value, fieldDefinition, fieldId) => {
                    return {
                        or: castArray(value.filterValue)
                            .map((filterValue) => this.getRecordGridFilterOperator(RecordGridFilterOperator.Eq, fieldId, this.getBooleanFilterValue(filterValue)))
                            .concat(this.getNamedFilterOptionsOperators(value, fieldId))
                    };
                },
                getDataForAdvancedFilter: (fieldDefinition) => {
                    return {
                        selectOptions: [
                            {
                                name: this.translateService.instant('com.bmc.arsys.rx.client.common.true'),
                                id: true
                            },
                            {
                                name: this.translateService.instant('com.bmc.arsys.rx.client.common.false'),
                                id: false
                            },
                            {
                                name: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.filters.blank.label'),
                                id: 'blank'
                            }
                        ],
                        isRequired: fieldDefinition.fieldOption === RecordFieldOption.Required
                    };
                },
                getSelectedAdvancedFilterData: (filterLogic, filterOperators, fieldDefinition, fieldId) => {
                    let filterValue;
                    if (fieldDefinition.fieldOption === RecordFieldOption.Required) {
                        if (filterOperators.length === 1) {
                            const eqOperator = find(filterOperators, (filterOperator) => filterOperator[RecordGridFilterOperator.Eq]);
                            if (eqOperator) {
                                const savedFilterValue = eqOperator[RecordGridFilterOperator.Eq][fieldId];
                                if (savedFilterValue === '$NULL$') {
                                    filterValue = null;
                                }
                                else {
                                    filterValue = [savedFilterValue === 'true'];
                                }
                            }
                        }
                        else {
                            filterValue = null;
                        }
                    }
                    else {
                        filterValue = [];
                        if (filterLogic === RecordGridFilterDataLogic.Or) {
                            filterOperators.forEach((filterOperator) => {
                                const operator = Object.keys(filterOperator)[0];
                                if (operator === RecordGridFilterOperator.Eq) {
                                    const value = filterOperator[operator][fieldId];
                                    if (!value[RecordGridNamedFilterOptionKey]) {
                                        switch (value) {
                                            case 'true':
                                                filterValue.push(true);
                                                break;
                                            case '$NULL$':
                                                filterValue.push(booleanDataTypeBlankValue);
                                                break;
                                            default:
                                                filterValue.push(false);
                                                break;
                                        }
                                    }
                                }
                            });
                        }
                    }
                    const namedFilterOptionGuids = this.getNamedFilterOptionGuids(filterOperators, fieldId);
                    return filterValue
                        ? {
                            filterOptionId: fieldId,
                            value: new RxRecordGridAdvancedFilterValue(filterValue, namedFilterOptionGuids)
                        }
                        : null;
                }
            },
            [RX_RECORD_DEFINITION.resourceTypes.recordInstance]: null,
            [RX_RECORD_DEFINITION.resourceTypes.object]: null,
            [RX_RECORD_DEFINITION.resourceTypes.recordInstanceProcessVariable]: null,
            [RX_RECORD_DEFINITION.resourceTypes.localizedFieldInstance]: null
        };
    }
    getDateSelectedAdvancedFilterData(fieldId, filterLogic, filterOperators) {
        let filterValue = [null, null];
        const processRange = (operators) => {
            const gteOperator = find(operators, (filterOperator) => filterOperator[RecordGridFilterOperator.Gte]);
            if (gteOperator) {
                const fromValue = moment(gteOperator[RecordGridFilterOperator.Gte][fieldId]);
                if (fromValue.isValid()) {
                    filterValue[0] = fromValue;
                }
            }
            const lteOperator = find(operators, (filterOperator) => filterOperator[RecordGridFilterOperator.Lte]);
            if (lteOperator) {
                const toValue = moment(lteOperator[RecordGridFilterOperator.Lte][fieldId]);
                if (toValue.isValid()) {
                    filterValue[1] = toValue;
                }
            }
        };
        if (filterLogic === RecordGridFilterDataLogic.And) {
            processRange(filterOperators);
        }
        else if (filterLogic === RecordGridFilterDataLogic.Or) {
            const andOperator = find(filterOperators, (filterOperator) => filterOperator[RecordGridFilterDataLogic.And]);
            if (andOperator) {
                processRange(andOperator[RecordGridFilterDataLogic.And]);
            }
            else if (filterOperators.length === 1) {
                let eqValue = filterOperators[0][RecordGridFilterOperator.Eq][fieldId];
                if (eqValue !== '$NULL$' && !eqValue[RecordGridNamedFilterOptionKey]) {
                    eqValue = moment(eqValue);
                    filterValue = [eqValue, eqValue];
                }
            }
        }
        return {
            filterOptionId: fieldId,
            value: new RxRecordGridAdvancedFilterValue(filterValue, this.getNamedFilterOptionGuids(filterOperators, fieldId))
        };
    }
    getFilterRangeDataOperator(queries, namedFilterOptionOperators) {
        const andOperator = {
            and: queries
        };
        if (namedFilterOptionOperators.length) {
            return {
                or: queries.length ? namedFilterOptionOperators.concat(andOperator) : namedFilterOptionOperators
            };
        }
        else {
            return andOperator;
        }
    }
    getNamedFilterOptionGuids(filterOperators, fieldId) {
        return filterOperators
            .filter((filterOperator) => filterOperator[RecordGridFilterOperator.Eq])
            .map((operator) => {
            const operatorElementElement = operator[RecordGridFilterOperator.Eq][fieldId];
            return operatorElementElement ? operatorElementElement[RecordGridNamedFilterOptionKey] : null;
        })
            .filter((guid) => Boolean(guid));
    }
    getSelectedNamedOptionExpressions(namedFilterOptions, filterTag) {
        return namedFilterOptions
            .filter((option) => filterTag.value.namedOptions.includes(option.guid))
            .map((option) => option.filterExpression.replace(this.associatedFieldIdPatternRegExp, '${$1}'));
    }
    getNamedFilterOptionsOperators(value, fieldId) {
        return value.namedOptions.map((guid) => this.getRecordGridFilterOperator(RecordGridFilterOperator.Eq, fieldId, {
            [RecordGridNamedFilterOptionKey]: guid
        }));
    }
    getRecordGridFilterOperator(operator, fieldId, value) {
        return { [operator]: { [fieldId]: value } };
    }
    getBooleanFilterValue(filterValue) {
        return filterValue ? (filterValue === booleanDataTypeBlankValue ? '$NULL$' : 'true') : 'false';
    }
}
RxRecordGridFilterConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterConfigService, deps: [{ token: RxRecordGridFilterService }, { token: i2$1.RxNumberUtilsService }, { token: i2$6.RxNamedListService }, { token: i2.TranslateService }, { token: i1$5.RxRecordInstanceUtilsService }, { token: RxRecordGridUtilsService }, { token: i1$1.RxDefinitionNameService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridFilterConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterConfigService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterConfigService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: RxRecordGridFilterService }, { type: i2$1.RxNumberUtilsService }, { type: i2$6.RxNamedListService }, { type: i2.TranslateService }, { type: i1$5.RxRecordInstanceUtilsService }, { type: RxRecordGridUtilsService }, { type: i1$1.RxDefinitionNameService }]; } });

class RxNamedFilterOptionsListComponent {
    constructor() {
        this.defaultFilterValue = [];
        this.namedFilterOptionsChange = new EventEmitter();
        this.namedFilterOptionsModel = {};
    }
    set filterValue(values) {
        const ids = values === null || values === void 0 ? void 0 : values.namedOptions;
        this._filterValue = values;
        Object.keys(this.namedFilterOptionsModel).forEach((key) => (this.namedFilterOptionsModel[key] = false));
        ids === null || ids === void 0 ? void 0 : ids.forEach((id) => (this.namedFilterOptionsModel[id] = true));
    }
    get filterValue() {
        return this._filterValue;
    }
    trackByOptionGuid(index, option) {
        return option['guid'];
    }
    onNamedFilterOptionChange() {
        var _a, _b;
        const selectedGuids = this.getSelectedNamedOptionsIds();
        this.namedFilterOptionsChange.emit(selectedGuids);
        const value = new RxRecordGridAdvancedFilterValue((_b = (_a = this.filterValue) === null || _a === void 0 ? void 0 : _a.filterValue) !== null && _b !== void 0 ? _b : this.defaultFilterValue, selectedGuids);
        this.filterControlsComponent.onFilterOptionModelChange(value);
    }
    getSelectedNamedOptionsIds() {
        return reduce(this.namedFilterOptionsModel, (result, value, id) => {
            if (value) {
                result.push(id);
            }
            return result;
        }, []);
    }
}
RxNamedFilterOptionsListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNamedFilterOptionsListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxNamedFilterOptionsListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxNamedFilterOptionsListComponent, selector: "rx-named-filter-options-list", inputs: { namedFilterOptions: "namedFilterOptions", filterOption: "filterOption", filterValue: "filterValue", filterControlsComponent: "filterControlsComponent", defaultFilterValue: "defaultFilterValue" }, outputs: { namedFilterOptionsChange: "namedFilterOptionsChange" }, ngImport: i0, template: "<div class=\"options-wrapper\" *ngIf=\"namedFilterOptions?.length\">\n  <adapt-rx-checkbox\n    class=\"dropdown-item p-0 text-break\"\n    *ngFor=\"let option of namedFilterOptions; trackBy: trackByOptionGuid\"\n    [label]=\"option.title\"\n    [(ngModel)]=\"namedFilterOptionsModel[option.guid]\"\n    (ngModelChange)=\"onNamedFilterOptionChange()\"\n  ></adapt-rx-checkbox>\n</div>\n", styles: [".options-wrapper{margin-top:-1.5rem;margin-bottom:-2px}adapt-rx-checkbox:not(:last-child){margin-bottom:14px}.dropdown-item{white-space:normal}\n"], components: [{ type: i1.AdaptRxCheckboxComponent, selector: "adapt-rx-checkbox", inputs: ["value", "checked", "indeterminate"], outputs: ["indeterminateChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNamedFilterOptionsListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-named-filter-options-list',
                    templateUrl: './named-filter-options-list.component.html',
                    styleUrls: ['./named-filter-options-list.component.scss']
                }]
        }], propDecorators: { namedFilterOptions: [{
                type: Input
            }], filterOption: [{
                type: Input
            }], filterValue: [{
                type: Input
            }], filterControlsComponent: [{
                type: Input
            }], defaultFilterValue: [{
                type: Input
            }], namedFilterOptionsChange: [{
                type: Output
            }] } });

class RxBooleanFilterComponent {
    constructor() {
        this.namedFilterOptions = [];
        this.isRequired = false;
    }
    set filterValue(values) {
        const selectOptions = this.getSelectOptions();
        this._filterValue = values;
        this.selectedValues = (values === null || values === void 0 ? void 0 : values.filterValue)
            ? values.filterValue.map((value) => find(selectOptions, { id: value }))
            : [];
    }
    get filterValue() {
        return this._filterValue;
    }
    selectOptionFormatter(option) {
        return option.name;
    }
    onValueChange(values) {
        var _a;
        const filterValue = values.map((value) => value.id);
        this.filterControlsComponent.onFilterOptionModelChange(new RxRecordGridAdvancedFilterValue(filterValue, (_a = this.filterValue) === null || _a === void 0 ? void 0 : _a.namedOptions));
    }
    getSelectOptions() {
        var _a;
        return ((_a = this.filterOption.data) === null || _a === void 0 ? void 0 : _a.selectOptions) || [];
    }
    onValueChangeRequired(model) {
        var _a, _b, _c;
        const oldModelValue = Array.isArray((_a = this.filterValue) === null || _a === void 0 ? void 0 : _a.filterValue)
            ? this.filterValue.filterValue[0]
            : (_b = this.filterValue) === null || _b === void 0 ? void 0 : _b.filterValue;
        this.filterControlsComponent.onFilterOptionModelChange(new RxRecordGridAdvancedFilterValue(model === oldModelValue ? null : [model], (_c = this.filterValue) === null || _c === void 0 ? void 0 : _c.namedOptions));
    }
}
RxBooleanFilterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxBooleanFilterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxBooleanFilterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxBooleanFilterComponent, selector: "rx-boolean-filter", inputs: { filterOption: "filterOption", filterValue: "filterValue", filterControlsComponent: "filterControlsComponent", namedFilterOptions: "namedFilterOptions", isRequired: "isRequired" }, ngImport: i0, template: "<rx-named-filter-options-list\n  *ngIf=\"namedFilterOptions?.length\"\n  [namedFilterOptions]=\"namedFilterOptions\"\n  [filterOption]=\"filterOption\"\n  [filterValue]=\"filterValue\"\n  [filterControlsComponent]=\"filterControlsComponent\"\n></rx-named-filter-options-list>\n\n<adapt-rx-select\n  *ngIf=\"!isRequired; else inputsForBooleanTypeTemplate\"\n  class=\"advanced-filter__rx-select advanced-filter__rx-select_simple\"\n  [inline]=\"true\"\n  [multiple]=\"true\"\n  [optionFormatter]=\"selectOptionFormatter\"\n  [options]=\"getSelectOptions()\"\n  [popupMaxHeight]=\"null\"\n  [ngModel]=\"selectedValues\"\n  (ngModelChange)=\"onValueChange($event)\"\n>\n</adapt-rx-select>\n\n<ng-template #inputsForBooleanTypeTemplate>\n  <adapt-rx-radiobutton-group\n    class=\"advanced-filter__radiobutton-group\"\n    [ngModel]=\"filterValue ? filterValue.filterValue[0] : null\"\n    (ngModelChange)=\"onValueChangeRequired($event)\"\n  >\n    <adapt-rx-radiobutton\n      name=\"booleanTypeGroup\"\n      class=\"advanced-filter__radiobutton\"\n      [value]=\"false\"\n      [label]=\"filterControlsComponent.texts.configsTexts.falseLabel\"\n      [testID]=\"filterControlsComponent.testID + '_radio_false'\"\n      [disabled]=\"filterControlsComponent.isInputDisabled(false)\"\n    >\n    </adapt-rx-radiobutton>\n    <adapt-rx-radiobutton\n      name=\"booleanTypeGroup\"\n      class=\"advanced-filter__radiobutton\"\n      [value]=\"true\"\n      [label]=\"filterControlsComponent.texts.configsTexts.trueLabel\"\n      [testID]=\"filterControlsComponent.testID + '_radio_true'\"\n      [disabled]=\"filterControlsComponent.isInputDisabled(true)\"\n    >\n    </adapt-rx-radiobutton>\n    <adapt-rx-radiobutton\n      *ngIf=\"filterControlsComponent.getBooleanTypeOptionParams().hasBlankValue\"\n      name=\"booleanTypeGroup\"\n      class=\"advanced-filter__radiobutton\"\n      [value]=\"filterControlsComponent.getBooleanTypeBlankValue()\"\n      [label]=\"filterControlsComponent.texts.configsTexts.blankLabel\"\n      [testID]=\"filterControlsComponent.testID + '_radio_blank'\"\n      [disabled]=\"filterControlsComponent.isInputDisabled(filterControlsComponent.getBooleanTypeBlankValue())\"\n    >\n    </adapt-rx-radiobutton>\n  </adapt-rx-radiobutton-group>\n</ng-template>\n", components: [{ type: RxNamedFilterOptionsListComponent, selector: "rx-named-filter-options-list", inputs: ["namedFilterOptions", "filterOption", "filterValue", "filterControlsComponent", "defaultFilterValue"], outputs: ["namedFilterOptionsChange"] }, { type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }, { type: i1.AdaptRxRadiobuttonGroupComponent, selector: "adapt-rx-radiobutton-group", inputs: ["formControlName"] }, { type: i1.AdaptRxRadiobuttonComponent, selector: "adapt-rx-radiobutton", inputs: ["name", "label", "id", "value", "checked", "disabled", "ariaLabel", "ariaLabeledBy", "ariaDescribedBy", "testID", "tabIndex"], outputs: ["onFocus", "onBlur", "checkedChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxBooleanFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-boolean-filter',
                    templateUrl: './boolean-filter.component.html'
                }]
        }], propDecorators: { filterOption: [{
                type: Input
            }], filterValue: [{
                type: Input
            }], filterControlsComponent: [{
                type: Input
            }], namedFilterOptions: [{
                type: Input
            }], isRequired: [{
                type: Input
            }] } });

class RxStringWithTypeAheadFilterComponent {
    constructor(rxNamedListService, rxNamedListDefinitionService, rxFeatureService) {
        this.rxNamedListService = rxNamedListService;
        this.rxNamedListDefinitionService = rxNamedListDefinitionService;
        this.rxFeatureService = rxFeatureService;
        this.namedFilterOptions = [];
        this.selectedValues = [];
        this.isSearchInProgress = false;
        this.search = (text$) => text$.pipe(debounceTime(250), distinctUntilChanged(), tap(() => {
            this.isSearchInProgress = true;
        }), switchMap((term) => this.getSelectOptions(term)), finalize(() => {
            this.isSearchInProgress = false;
        }));
    }
    set filterValue(values) {
        this._filterValue = values;
        this.selectedValues = (values === null || values === void 0 ? void 0 : values.filterValue) || [];
    }
    get filterValue() {
        return this._filterValue;
    }
    ngOnInit() {
        var _a;
        this.namedListDefinition$ = this.rxNamedListDefinitionService
            .get(this.filterOption.data.namedListDefinition)
            .pipe(shareReplay(1));
        this.typeaheadKeystrokeCount =
            (_a = this.filterOption.data.typeaheadKeystrokeCount) !== null && _a !== void 0 ? _a : RX_RECORD_GRID.defaultTypeaheadKeystrokeCount;
    }
    onValueChange(selectedValues) {
        var _a;
        this.filterControlsComponent.onFilterOptionModelChange(new RxRecordGridAdvancedFilterValue(selectedValues.map((selectedValue) => this.rxNamedListService.isNamedListOption(selectedValue)
            ? selectedValue
            : { displayValue: undefined, value: selectedValue, title: '', contextualFields: [] }), (_a = this.filterValue) === null || _a === void 0 ? void 0 : _a.namedOptions));
    }
    getSelectOptions(term) {
        return term.length >= this.typeaheadKeystrokeCount
            ? this.namedListDefinition$.pipe(switchMap((namedListDefinition) => this.rxNamedListService
                .getOptionPageByLabelOrValue(namedListDefinition, term, this.filterOption.data.additionalQueryCriteria)
                .pipe(map((optionPage) => optionPage.options))))
            : of([]);
    }
}
RxStringWithTypeAheadFilterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringWithTypeAheadFilterComponent, deps: [{ token: i2$6.RxNamedListService }, { token: i2$6.RxNamedListDefinitionService }, { token: i1$1.RxFeatureService }], target: i0.ɵɵFactoryTarget.Component });
RxStringWithTypeAheadFilterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxStringWithTypeAheadFilterComponent, selector: "rx-string-with-type-ahead-filter", inputs: { filterOption: "filterOption", filterControlsComponent: "filterControlsComponent", filterValue: "filterValue", namedFilterOptions: "namedFilterOptions" }, ngImport: i0, template: "<rx-named-filter-options-list\n  *ngIf=\"namedFilterOptions?.length\"\n  [namedFilterOptions]=\"namedFilterOptions\"\n  [filterOption]=\"filterOption\"\n  [filterValue]=\"filterValue\"\n  [filterControlsComponent]=\"filterControlsComponent\"\n></rx-named-filter-options-list>\n\n<div style=\"position: relative\">\n  <adapt-tag-field\n    [search]=\"search\"\n    [ngModel]=\"selectedValues\"\n    (ngModelChange)=\"onValueChange($event)\"\n    [replaceModelOnWrite]=\"true\"\n    [selectItemTemplate]=\"selectItemTemplate\"\n    [tagTemplate]=\"tagTemplate\"\n    [openDropdownOnFocus]=\"typeaheadKeystrokeCount === 0\"\n    [placeholder]=\"'com.bmc.arsys.rx.client.view-components.record-grid.filters.typeahead.placeholder' | translate\"\n  ></adapt-tag-field>\n  <div *ngIf=\"isSearchInProgress\" class=\"position-absolute text-info inline-loader\">\n    <div class=\"d-icon-circle_75_o animated infinite spin-360 transition-out slow\"></div>\n  </div>\n</div>\n\n<ng-template #tagTemplate let-tag=\"tag\">\n  {{ tag.displayValue ?? tag.value }}\n</ng-template>\n\n<ng-template #selectItemTemplate let-result=\"result\">\n  {{ result.displayValue ?? result.value }}\n\n  <div\n    *ngIf=\"result.contextualFields\"\n    class=\"text-secondary selection-item-contextual-fields text-truncate\"\n    [title]=\"result.title\"\n  >\n    <span class=\"breadcrumb-item active\" *ngFor=\"let contextualFieldValue of result.contextualFields\">\n      <small> {{ contextualFieldValue }} </small>\n    </span>\n  </div>\n</ng-template>\n", styles: [".inline-loader{z-index:10;right:15px;top:8px}.selection-item-contextual-fields{max-width:300px}\n"], components: [{ type: RxNamedFilterOptionsListComponent, selector: "rx-named-filter-options-list", inputs: ["namedFilterOptions", "filterOption", "filterValue", "filterControlsComponent", "defaultFilterValue"], outputs: ["namedFilterOptionsChange"] }, { type: i1.AdaptMetatagComponent, selector: "adapt-metatag, adapt-tag-field", inputs: ["prefix", "suffix", "maxTagLength", "truncateConfig", "id", "testID", "name", "ariaLabel", "search", "maxHeight", "suppressManual", "label", "placeholder", "mainErrorText", "warningStateText", "width", "errorCheck", "warningCheck", "selectItemTemplate", "tagTemplate", "replaceModelOnWrite", "delimiterSymbol", "popupClass", "disabledInput", "openDropdownOnFocus", "selectItemFormatter", "fullWidthEdit", "tagStyleFormatter"], outputs: ["focus", "blur", "removeTag", "addTag", "initTagEditing"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringWithTypeAheadFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-string-with-type-ahead-filter',
                    templateUrl: './string-with-type-ahead-filter.component.html',
                    styleUrls: ['./string-with-type-ahead-filter.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i2$6.RxNamedListService }, { type: i2$6.RxNamedListDefinitionService }, { type: i1$1.RxFeatureService }]; }, propDecorators: { filterOption: [{
                type: Input
            }], filterControlsComponent: [{
                type: Input
            }], filterValue: [{
                type: Input
            }], namedFilterOptions: [{
                type: Input
            }] } });

class RxStringFilterComponent {
    constructor() {
        this.namedFilterOptions = [];
    }
    onStringTypeFilterOptionModelChange(model, tagField) {
        var _a, _b;
        const newModel = model.filter((tag) => !isEmptyOrWhitespace(getTagText(tag)));
        if (newModel.length < model.length && isEqual(newModel, ((_a = this.filterValue) === null || _a === void 0 ? void 0 : _a.filterValue) || [])) {
            tagField.writeValue(newModel);
        }
        else {
            this.filterControlsComponent.onFilterOptionModelChange(new RxRecordGridAdvancedFilterValue(newModel, (_b = this.filterValue) === null || _b === void 0 ? void 0 : _b.namedOptions));
        }
    }
}
RxStringFilterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringFilterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxStringFilterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxStringFilterComponent, selector: "rx-string-filter", inputs: { filterOption: "filterOption", filterValue: "filterValue", filterControlsComponent: "filterControlsComponent", namedFilterOptions: "namedFilterOptions" }, ngImport: i0, template: "<rx-named-filter-options-list\n  *ngIf=\"namedFilterOptions?.length\"\n  [namedFilterOptions]=\"namedFilterOptions\"\n  [filterOption]=\"filterOption\"\n  [filterValue]=\"filterValue\"\n  [filterControlsComponent]=\"filterControlsComponent\"\n></rx-named-filter-options-list>\n\n<adapt-tag-field\n  #stringDataTypeTagField\n  mainCls=\"advanced-filter__string-tag-field\"\n  [ngModel]=\"filterValue?.filterValue || []\"\n  popupClass=\"advanced-filter__typeahead-window\"\n  [testID]=\"filterControlsComponent.testID\"\n  (ngModelChange)=\"onStringTypeFilterOptionModelChange($event, stringDataTypeTagField)\"\n  [delimiterSymbol]=\"null\"\n  [placeholder]=\"filterControlsComponent.texts.stringTypeTagFieldPlaceholder\"\n  [replaceModelOnWrite]=\"true\"\n  [disabled]=\"filterControlsComponent.isInputDisabled()\"\n  [hideLabel]=\"true\"\n>\n</adapt-tag-field>\n", components: [{ type: RxNamedFilterOptionsListComponent, selector: "rx-named-filter-options-list", inputs: ["namedFilterOptions", "filterOption", "filterValue", "filterControlsComponent", "defaultFilterValue"], outputs: ["namedFilterOptionsChange"] }, { type: i1.AdaptMetatagComponent, selector: "adapt-metatag, adapt-tag-field", inputs: ["prefix", "suffix", "maxTagLength", "truncateConfig", "id", "testID", "name", "ariaLabel", "search", "maxHeight", "suppressManual", "label", "placeholder", "mainErrorText", "warningStateText", "width", "errorCheck", "warningCheck", "selectItemTemplate", "tagTemplate", "replaceModelOnWrite", "delimiterSymbol", "popupClass", "disabledInput", "openDropdownOnFocus", "selectItemFormatter", "fullWidthEdit", "tagStyleFormatter"], outputs: ["focus", "blur", "removeTag", "addTag", "initTagEditing"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-string-filter',
                    templateUrl: './string-filter.component.html'
                }]
        }], propDecorators: { filterOption: [{
                type: Input
            }], filterValue: [{
                type: Input
            }], filterControlsComponent: [{
                type: Input
            }], namedFilterOptions: [{
                type: Input
            }] } });

class RxNumberFilterComponent {
    getNumberDataTypeModel(value, indexOfCounter) {
        return value && value.filterValue ? value.filterValue[indexOfCounter] : null;
    }
    onNumberTypeFilterOptionModelChange(filterValue, controlComponent, newValue) {
        controlComponent.onFilterOptionModelChange(new RxRecordGridAdvancedFilterValue(newValue, filterValue === null || filterValue === void 0 ? void 0 : filterValue.namedOptions));
    }
}
RxNumberFilterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNumberFilterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxNumberFilterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxNumberFilterComponent, selector: "rx-number-filter", inputs: { filterOption: "filterOption", filterControlsComponent: "filterControlsComponent", filterValue: "filterValue", namedFilterOptions: "namedFilterOptions" }, ngImport: i0, template: "<rx-named-filter-options-list\n  *ngIf=\"namedFilterOptions?.length\"\n  [namedFilterOptions]=\"namedFilterOptions\"\n  [filterOption]=\"filterOption\"\n  [filterValue]=\"filterValue\"\n  [filterControlsComponent]=\"filterControlsComponent\"\n></rx-named-filter-options-list>\n\n<div class=\"d-flex\" [class.has-danger]=\"filterControlsComponent.hasValidationErrors\">\n  <div class=\"advanced-filter__counter-from-wrap\">\n    <adapt-rx-counter\n      #counterFrom\n      class=\"advanced-filter__counter-from\"\n      [label]=\"filterControlsComponent.texts.counterFromLabel\"\n      [ngModel]=\"getNumberDataTypeModel(filterValue, 0)\"\n      (ngModelChange)=\"\n        onNumberTypeFilterOptionModelChange(filterValue, filterControlsComponent, [\n          $event,\n          counterTo ? getNumberDataTypeModel(filterValue, 1) : null\n        ])\n      \"\n      [min]=\"filterControlsComponent.getNumberDataTypeMinAllowedValue()\"\n      [max]=\"filterControlsComponent.getNumberDataTypeMaxAllowedValue()\"\n      [disabled]=\"filterControlsComponent.isInputDisabled()\"\n      [testID]=\"filterControlsComponent.testID + '_from'\"\n    >\n    </adapt-rx-counter>\n  </div>\n  <div class=\"advanced-filter__counter-to-wrap\">\n    <adapt-rx-counter\n      #counterTo\n      class=\"advanced-filter__counter-to\"\n      [label]=\"filterControlsComponent.texts.counterToLabel\"\n      [ngModel]=\"getNumberDataTypeModel(filterValue, 1)\"\n      (ngModelChange)=\"\n        onNumberTypeFilterOptionModelChange(filterValue, filterControlsComponent, [\n          counterFrom ? getNumberDataTypeModel(filterValue, 0) : null,\n          $event\n        ])\n      \"\n      [min]=\"filterControlsComponent.getNumberDataTypeMinAllowedValue()\"\n      [max]=\"filterControlsComponent.getNumberDataTypeMaxAllowedValue()\"\n      [disabled]=\"filterControlsComponent.isInputDisabled()\"\n      [testID]=\"filterControlsComponent.testID + '_to'\"\n    >\n    </adapt-rx-counter>\n  </div>\n</div>\n", components: [{ type: RxNamedFilterOptionsListComponent, selector: "rx-named-filter-options-list", inputs: ["namedFilterOptions", "filterOption", "filterValue", "filterControlsComponent", "defaultFilterValue"], outputs: ["namedFilterOptionsChange"] }, { type: i1.AdaptRxCounterComponent, selector: "adapt-rx-counter", inputs: ["prefix", "suffix", "max", "min", "step", "size", "placeholder", "disabledStyleForReadonlyState"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNumberFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-number-filter',
                    templateUrl: './number-filter.component.html'
                }]
        }], propDecorators: { filterOption: [{
                type: Input
            }], filterControlsComponent: [{
                type: Input
            }], filterValue: [{
                type: Input
            }], namedFilterOptions: [{
                type: Input
            }] } });

// Adapt dropped moment and changed the signature of AdvancedFilterTimeDataType from [moment.Moment, moment.Moment] to [RxDatetimeStruct, RxDatetimeStruct].
// We need to extend the AdaptRxDatetimeAdapter class to implement the missing moment methods that we rely on.
class RxAdaptDatetimeMomentAdapter extends AdaptRxDatetimeAdapter {
    /**
     * Converts moment.Moment => RxDatetimeStruct
     */
    fromModel(dateValue) {
        let adaptedValue = null;
        const date = moment(dateValue);
        if (date && date.isValid()) {
            adaptedValue = {
                year: date.year(),
                month: date.month(),
                date: date.date(),
                hours: date.hours(),
                minutes: date.minutes(),
                seconds: date.seconds()
            };
        }
        return adaptedValue;
    }
    /**
     * Converts RxDatetimeStruct => moment.Moment
     */
    toModel(date) {
        var _a, _b, _c, _d, _e, _f;
        let adaptedValue = null;
        if (date) {
            const currentDateTime = moment();
            adaptedValue = date.parseError
                ? moment.invalid({
                    invalidFormat: true,
                    parsedDateParts: [date.parseError.query],
                    meridiem: date.parseError.use12HoursTime ? '12' : '24'
                })
                : moment([
                    (_a = date.year) !== null && _a !== void 0 ? _a : currentDateTime.year(),
                    (_b = date.month) !== null && _b !== void 0 ? _b : currentDateTime.month(),
                    (_c = date.date) !== null && _c !== void 0 ? _c : currentDateTime.date(),
                    (_d = date.hours) !== null && _d !== void 0 ? _d : 0,
                    (_e = date.minutes) !== null && _e !== void 0 ? _e : 0,
                    (_f = date.seconds) !== null && _f !== void 0 ? _f : 0
                ]);
        }
        return adaptedValue;
    }
}
RxAdaptDatetimeMomentAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdaptDatetimeMomentAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
RxAdaptDatetimeMomentAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdaptDatetimeMomentAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdaptDatetimeMomentAdapter, decorators: [{
            type: Injectable
        }] });

class RxDateTimeRangeFilterComponent {
    constructor() {
        this.rxDatetimePickerMode = RxDatetimePickerMode;
    }
    onTimeTypeFilterOptionModelChange(model) {
        this.onDateTimeTypeFilterOptionModelChange(model);
    }
    onDateTypeFilterOptionModelChange(model) {
        if (model[0] && model[0].isValid()) {
            model[0] = model[0].startOf('day');
        }
        if (model[1] && model[1].isValid()) {
            model[1] = model[1].startOf('day');
        }
        this.onDateTimeTypeFilterOptionModelChange(model);
    }
    onDateTimeTypeFilterOptionModelChange(newValue) {
        var _a;
        this.filterControlsComponent.onFilterOptionModelChange(new RxRecordGridAdvancedFilterValue(newValue, (_a = this.filterValue) === null || _a === void 0 ? void 0 : _a.namedOptions));
    }
}
RxDateTimeRangeFilterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDateTimeRangeFilterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxDateTimeRangeFilterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxDateTimeRangeFilterComponent, selector: "rx-date-time-range-filter", inputs: { filterOption: "filterOption", filterControlsComponent: "filterControlsComponent", filterValue: "filterValue", namedFilterOptions: "namedFilterOptions", mode: "mode" }, providers: [{ provide: AdaptRxDatetimeAdapter, useClass: RxAdaptDatetimeMomentAdapter }], ngImport: i0, template: "<rx-named-filter-options-list\n  *ngIf=\"namedFilterOptions?.length\"\n  [namedFilterOptions]=\"namedFilterOptions\"\n  [filterOption]=\"filterOption\"\n  [filterValue]=\"filterValue\"\n  [filterControlsComponent]=\"filterControlsComponent\"\n></rx-named-filter-options-list>\n\n<ng-container [ngSwitch]=\"mode\">\n  <ng-container *ngSwitchCase=\"rxDatetimePickerMode.Time\" [ngTemplateOutlet]=\"inputsForTimeTypeTemplate\"></ng-container>\n  <ng-container *ngSwitchCase=\"rxDatetimePickerMode.Date\" [ngTemplateOutlet]=\"inputsForDateTypeTemplate\"></ng-container>\n  <ng-container\n    *ngSwitchCase=\"rxDatetimePickerMode.DateTime\"\n    [ngTemplateOutlet]=\"inputsForDatetimeTypeTemplate\"\n  ></ng-container>\n</ng-container>\n\n<ng-template #inputsForTimeTypeTemplate>\n  <adapt-rx-datetime-range\n    class=\"advanced-filter__datetime\"\n    [ngModel]=\"filterValue?.filterValue\"\n    (ngModelChange)=\"onTimeTypeFilterOptionModelChange($event)\"\n    [testID]=\"filterControlsComponent.testID\"\n    [mode]=\"mode\"\n    [hasSeconds]=\"true\"\n    [inline]=\"true\"\n    [inlineLight]=\"true\"\n    [texts]=\"filterControlsComponent.texts.datetimeTexts\"\n    [disabled]=\"filterControlsComponent.isInputDisabled()\"\n  >\n  </adapt-rx-datetime-range>\n</ng-template>\n\n<ng-template #inputsForDateTypeTemplate>\n  <adapt-rx-datetime-range\n    class=\"advanced-filter__datetime\"\n    [ngModel]=\"filterValue?.filterValue\"\n    (ngModelChange)=\"onDateTypeFilterOptionModelChange($event)\"\n    [testID]=\"filterControlsComponent.testID\"\n    [mode]=\"mode\"\n    [inline]=\"true\"\n    [inlineLight]=\"true\"\n    [texts]=\"filterControlsComponent.texts.datetimeTexts\"\n    [disabled]=\"filterControlsComponent.isInputDisabled()\"\n  >\n  </adapt-rx-datetime-range>\n</ng-template>\n\n<ng-template #inputsForDatetimeTypeTemplate>\n  <adapt-rx-datetime-range\n    class=\"advanced-filter__datetime\"\n    [ngModel]=\"filterValue?.filterValue\"\n    (ngModelChange)=\"onDateTimeTypeFilterOptionModelChange($event)\"\n    [testID]=\"filterControlsComponent.testID\"\n    [mode]=\"mode\"\n    [hasSeconds]=\"true\"\n    [inline]=\"true\"\n    [inlineLight]=\"true\"\n    [texts]=\"filterControlsComponent.texts.datetimeTexts\"\n    [disabled]=\"filterControlsComponent.isInputDisabled()\"\n  >\n  </adapt-rx-datetime-range>\n</ng-template>\n", components: [{ type: RxNamedFilterOptionsListComponent, selector: "rx-named-filter-options-list", inputs: ["namedFilterOptions", "filterOption", "filterValue", "filterControlsComponent", "defaultFilterValue"], outputs: ["namedFilterOptionsChange"] }, { type: i1.AdaptRxDatetimeRangeComponent, selector: "adapt-rx-datetime-range", inputs: ["placeholder", "inline", "placement", "appendToBody", "inlineLight", "inlineCompact", "dayFilter", "disableWizard", "mode", "hasSeconds", "use12HoursTime", "firstDayOfWeek", "initialDatetime", "defaultDatetime", "disabledStyleForReadonlyState", "popupClass", "texts", "inputFormat"], outputs: ["onPopupOpenChange", "onDatetimeChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i3.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDateTimeRangeFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-date-time-range-filter',
                    templateUrl: './date-time-range-filter.component.html',
                    providers: [{ provide: AdaptRxDatetimeAdapter, useClass: RxAdaptDatetimeMomentAdapter }]
                }]
        }], propDecorators: { filterOption: [{
                type: Input
            }], filterControlsComponent: [{
                type: Input
            }], filterValue: [{
                type: Input
            }], namedFilterOptions: [{
                type: Input
            }], mode: [{
                type: Input
            }] } });

class RxSelectionFilterComponent {
    set filterValue(values) {
        this._filterValue = values;
        const options = this.getSelectionTypeOptions();
        this.selectionTypeModel =
            options.length && (values === null || values === void 0 ? void 0 : values.filterValue)
                ? values.filterValue.map((id) => options.find((option) => option.id === id))
                : null;
    }
    get filterValue() {
        return this._filterValue;
    }
    getSelectionTypeOptions() {
        var _a;
        const data = this.filterOption.data;
        return (_a = data === null || data === void 0 ? void 0 : data.selectOptions) !== null && _a !== void 0 ? _a : [];
    }
    onSelectionTypeFilterOptionModelChange(value) {
        var _a;
        this.filterControlsComponent.onFilterOptionModelChange(new RxRecordGridAdvancedFilterValue(value.map((val) => val.id), (_a = this.filterValue) === null || _a === void 0 ? void 0 : _a.namedOptions));
    }
}
RxSelectionFilterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxSelectionFilterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxSelectionFilterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxSelectionFilterComponent, selector: "rx-selection-filter", inputs: { filterOption: "filterOption", filterControlsComponent: "filterControlsComponent", filterValue: "filterValue", namedFilterOptions: "namedFilterOptions" }, ngImport: i0, template: "<rx-named-filter-options-list\n  *ngIf=\"namedFilterOptions?.length\"\n  [namedFilterOptions]=\"namedFilterOptions\"\n  [filterOption]=\"filterOption\"\n  [filterValue]=\"filterValue\"\n  [filterControlsComponent]=\"filterControlsComponent\"\n></rx-named-filter-options-list>\n\n<adapt-rx-select\n  class=\"advanced-filter__rx-select\"\n  [class.advanced-filter__rx-select_simple]=\"filterControlsComponent.canShowSimpleInlineSelect()\"\n  [inline]=\"true\"\n  [multiple]=\"true\"\n  [selectAllButton]=\"true\"\n  [deselectAllButton]=\"true\"\n  [enableFilter]=\"!filterControlsComponent.canShowSimpleInlineSelect()\"\n  [optionFormatter]=\"filterControlsComponent.selectOptionFormatter\"\n  [options]=\"filterControlsComponent.getSelectionTypeOptions()\"\n  [texts]=\"filterControlsComponent.getSelectionTypeTexts()\"\n  [popupMaxHeight]=\"null\"\n  [ngModel]=\"selectionTypeModel\"\n  (ngModelChange)=\"onSelectionTypeFilterOptionModelChange($event)\"\n  [disabledOptionResolver]=\"filterControlsComponent.disabledSelectInputResolverBind\"\n>\n</adapt-rx-select>\n", components: [{ type: RxNamedFilterOptionsListComponent, selector: "rx-named-filter-options-list", inputs: ["namedFilterOptions", "filterOption", "filterValue", "filterControlsComponent", "defaultFilterValue"], outputs: ["namedFilterOptionsChange"] }, { type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxSelectionFilterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-selection-filter',
                    templateUrl: './selection-filter.component.html'
                }]
        }], propDecorators: { filterOption: [{
                type: Input
            }], filterControlsComponent: [{
                type: Input
            }], filterValue: [{
                type: Input
            }], namedFilterOptions: [{
                type: Input
            }] } });

class RxAdvancedFilteringFieldsProviderComponent {
    constructor() {
        this.rxDatetimePickerMode = RxDatetimePickerMode;
        this.namedFilterOptionsGetter = (filterOptionConfig) => [];
    }
}
RxAdvancedFilteringFieldsProviderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdvancedFilteringFieldsProviderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RxAdvancedFilteringFieldsProviderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxAdvancedFilteringFieldsProviderComponent, selector: "rx-advanced-filtering-fields-provider", inputs: { namedFilterOptionsGetter: "namedFilterOptionsGetter" }, viewQueries: [{ propertyName: "optionalBooleanFilter", first: true, predicate: ["optionalBooleanFilter"], descendants: true, static: true }, { propertyName: "requiredBooleanFilter", first: true, predicate: ["requiredBooleanFilter"], descendants: true, static: true }, { propertyName: "inputsForStringWithTypeAheadTemplate", first: true, predicate: ["inputsForStringWithTypeAheadTemplate"], descendants: true, static: true }, { propertyName: "inputsForStringTypeTemplate", first: true, predicate: ["inputsForStringTypeTemplate"], descendants: true, static: true }, { propertyName: "inputsForNumberTypeTemplate", first: true, predicate: ["inputsForNumberTypeTemplate"], descendants: true, static: true }, { propertyName: "inputsForTimeTypeTemplate", first: true, predicate: ["inputsForTimeTypeTemplate"], descendants: true, static: true }, { propertyName: "inputsForDateTypeTemplate", first: true, predicate: ["inputsForDateTypeTemplate"], descendants: true, static: true }, { propertyName: "inputsForDatetimeTypeTemplate", first: true, predicate: ["inputsForDatetimeTypeTemplate"], descendants: true, static: true }, { propertyName: "inputsForSelectionTypeTemplate", first: true, predicate: ["inputsForSelectionTypeTemplate"], descendants: true, static: true }], ngImport: i0, template: "<ng-template\n  #optionalBooleanFilter\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-boolean-filter\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [isRequired]=\"false\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-boolean-filter>\n</ng-template>\n\n<ng-template\n  #requiredBooleanFilter\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-boolean-filter\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [isRequired]=\"true\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-boolean-filter>\n</ng-template>\n\n<ng-template\n  #inputsForStringWithTypeAheadTemplate\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-string-with-type-ahead-filter\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-string-with-type-ahead-filter>\n</ng-template>\n\n<ng-template\n  #inputsForStringTypeTemplate\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-string-filter\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-string-filter>\n</ng-template>\n\n<ng-template\n  #inputsForNumberTypeTemplate\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-number-filter\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-number-filter>\n</ng-template>\n\n<ng-template\n  #inputsForTimeTypeTemplate\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-date-time-range-filter\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [mode]=\"rxDatetimePickerMode.Time\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-date-time-range-filter>\n</ng-template>\n\n<ng-template\n  #inputsForDateTypeTemplate\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-date-time-range-filter\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [mode]=\"rxDatetimePickerMode.Date\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-date-time-range-filter>\n</ng-template>\n\n<ng-template\n  #inputsForDatetimeTypeTemplate\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-date-time-range-filter\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [mode]=\"rxDatetimePickerMode.DateTime\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-date-time-range-filter>\n</ng-template>\n\n<ng-template\n  #inputsForSelectionTypeTemplate\n  let-filterOption=\"filterOption\"\n  let-filterValue=\"value\"\n  let-filterControlsComponent=\"filterControlsComponent\"\n>\n  <rx-selection-filter\n    [filterOption]=\"filterOption\"\n    [filterValue]=\"filterValue\"\n    [filterControlsComponent]=\"filterControlsComponent\"\n    [namedFilterOptions]=\"namedFilterOptionsGetter(filterOption)\"\n  ></rx-selection-filter>\n</ng-template>\n", components: [{ type: RxBooleanFilterComponent, selector: "rx-boolean-filter", inputs: ["filterOption", "filterValue", "filterControlsComponent", "namedFilterOptions", "isRequired"] }, { type: RxStringWithTypeAheadFilterComponent, selector: "rx-string-with-type-ahead-filter", inputs: ["filterOption", "filterControlsComponent", "filterValue", "namedFilterOptions"] }, { type: RxStringFilterComponent, selector: "rx-string-filter", inputs: ["filterOption", "filterValue", "filterControlsComponent", "namedFilterOptions"] }, { type: RxNumberFilterComponent, selector: "rx-number-filter", inputs: ["filterOption", "filterControlsComponent", "filterValue", "namedFilterOptions"] }, { type: RxDateTimeRangeFilterComponent, selector: "rx-date-time-range-filter", inputs: ["filterOption", "filterControlsComponent", "filterValue", "namedFilterOptions", "mode"] }, { type: RxSelectionFilterComponent, selector: "rx-selection-filter", inputs: ["filterOption", "filterControlsComponent", "filterValue", "namedFilterOptions"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdvancedFilteringFieldsProviderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-advanced-filtering-fields-provider',
                    templateUrl: './advanced-filtering-fields-provider.component.html'
                }]
        }], propDecorators: { optionalBooleanFilter: [{
                type: ViewChild,
                args: ['optionalBooleanFilter', { static: true }]
            }], requiredBooleanFilter: [{
                type: ViewChild,
                args: ['requiredBooleanFilter', { static: true }]
            }], inputsForStringWithTypeAheadTemplate: [{
                type: ViewChild,
                args: ['inputsForStringWithTypeAheadTemplate', { static: true }]
            }], inputsForStringTypeTemplate: [{
                type: ViewChild,
                args: ['inputsForStringTypeTemplate', { static: true }]
            }], inputsForNumberTypeTemplate: [{
                type: ViewChild,
                args: ['inputsForNumberTypeTemplate', { static: true }]
            }], inputsForTimeTypeTemplate: [{
                type: ViewChild,
                args: ['inputsForTimeTypeTemplate', { static: true }]
            }], inputsForDateTypeTemplate: [{
                type: ViewChild,
                args: ['inputsForDateTypeTemplate', { static: true }]
            }], inputsForDatetimeTypeTemplate: [{
                type: ViewChild,
                args: ['inputsForDatetimeTypeTemplate', { static: true }]
            }], inputsForSelectionTypeTemplate: [{
                type: ViewChild,
                args: ['inputsForSelectionTypeTemplate', { static: true }]
            }], namedFilterOptionsGetter: [{
                type: Input
            }] } });

class FilterTagsComponent {
    constructor(rxRecordGridUtilsService) {
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.restTagsDropdownPlacement = ['bottom', 'bottom-right', 'auto'];
        this.removeTag = new EventEmitter();
        this.trackByForFilterTags = this.trackByForFilterTags.bind(this);
    }
    getTranslateParams() {
        return { count: this.getRestTagsCount() };
    }
    getRestTagsCount() {
        return this.tagsLimit && this.tags ? this.tags.length - this.tagsLimit : 0;
    }
    onRemoveFilterTag(tag) {
        const filterOption = tag.data.filterOption;
        const tags = clone(this.tags);
        let index;
        if (isNull(filterOption)) {
            index = findIndex(tags, (toolbarTag) => this.rxRecordGridUtilsService.isSharedFilterPresetTag(toolbarTag));
        }
        else {
            const filterOptionId = tag.data.filterOption.id;
            index = findIndex(tags, (toolbarTag) => get(toolbarTag.data.filterOption, 'id') === filterOptionId);
        }
        if (index > -1) {
            tags.splice(index, 1);
        }
        this.removeTag.emit({ removedTag: tag, newTags: tags });
    }
    trackByForFilterTags(index, tag) {
        return this.rxRecordGridUtilsService.isSharedFilterPresetTag(tag) ? index : tag.data.filterOption.id || index;
    }
}
FilterTagsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FilterTagsComponent, deps: [{ token: RxRecordGridUtilsService }], target: i0.ɵɵFactoryTarget.Component });
FilterTagsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: FilterTagsComponent, selector: "rx-filter-tags", inputs: { tags: "tags", isDisabled: "isDisabled", tagsLimit: "tagsLimit", restTagsDropdownPlacement: "restTagsDropdownPlacement" }, outputs: { removeTag: "removeTag" }, ngImport: i0, template: "<div>\n  <adapt-tag\n    class=\"mr-1\"\n    [removable]=\"!isDisabled\"\n    [disabled]=\"isDisabled\"\n    *ngFor=\"\n      let tag of tags | slice: 0:(tagsLimit ? tagsLimit : tags?.length);\n      let index = index;\n      trackBy: trackByForFilterTags\n    \"\n    type=\"active\"\n    (remove)=\"onRemoveFilterTag(tag)\"\n  >\n    <span class=\"filter-tags__tag-text\" [title]=\"tag.data.value?.title ?? tag.text\">{{ tag.text }}</span>\n  </adapt-tag>\n\n  <span adaptDropdown *ngIf=\"getRestTagsCount() > 0\" [appendToBody]=\"true\" [placement]=\"restTagsDropdownPlacement\">\n    <button adaptDropdownToggle type=\"button\" class=\"filter-tags__dropdown-toggle btn btn-link p-0 ml-1\">\n      {{\n        'com.bmc.arsys.rx.client.view-components.record-grid.filters.show-more-filters.label'\n          | translate: getTranslateParams()\n      }}\n    </button>\n\n    <div adaptDropdownMenu class=\"dropdown-menu filter-tags__dropdown-menu p-2\">\n      <div *ngFor=\"let tag of tags | slice: -getRestTagsCount(); let index = index; trackBy: trackByForFilterTags\">\n        <adapt-tag type=\"active\" [removable]=\"!isDisabled\" (remove)=\"onRemoveFilterTag(tag)\">\n          <span class=\"filter-tags__tag-text\" [title]=\"tag.data.value?.title ?? tag.text\">{{ tag.text }}</span>\n        </adapt-tag>\n      </div>\n    </div>\n  </span>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.filter-tags__dropdown-toggle:after{border:0!important}.filter-tags__tag-text{display:table-cell;max-width:190px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.filter-tags__dropdown-menu .filter-tags__tag-text{max-width:350px}\n"], components: [{ type: i1.AdaptTagComponent, selector: "adapt-tag", inputs: ["type", "removable", "disabled"], outputs: ["remove"] }, { type: i1.AdaptDropdownDirective, selector: "adapt-dropdown, [adaptDropdown]", inputs: ["autoClose", "customClass", "closeOnEscape", "placement", "animationPlacement", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "focusNextElementAfterClose", "appendToBody", "appendTo", "positionTo", "anchorPositionTrackingIntervalMs", "enableAnchorPositionTracking", "recalculatePositionOnElementResize", "setMobileState", "mobileView"], outputs: ["onOpen", "onClose", "anchorPositionChange", "popupAnimationDone"], exportAs: ["adaptDropdown"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.AdaptDropdownToggleDirective, selector: "[adaptDropdownToggle]", inputs: ["showCaret", "dropdownTogglerType"] }, { type: i1.AdaptDropdownMenuDirective, selector: "[adaptDropdownMenu]" }], pipes: { "slice": i3.SlicePipe, "translate": i2.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: FilterTagsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-filter-tags',
                    templateUrl: './filter-tags.component.html',
                    styleUrls: ['./filter-tags.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: RxRecordGridUtilsService }]; }, propDecorators: { tags: [{
                type: Input
            }], isDisabled: [{
                type: Input
            }], tagsLimit: [{
                type: Input
            }], restTagsDropdownPlacement: [{
                type: Input
            }], removeTag: [{
                type: Output
            }] } });

class RecordGridFilterSelectControlComponent extends ValueAccessor {
    constructor(injector, rxModalService, rxRecordGridUtilsService, rxRecordGridFilterConfigService, rxRecordDefinitionCacheService, rxRecordGridFilterService, rxRecordGridFilterHelperService, rxRecordDefinitionService, rxGuidService, rxRecordGridAdvancedFilteringService, rxGlobalCacheService, rxDefinitionNameService) {
        super();
        this.injector = injector;
        this.rxModalService = rxModalService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxRecordGridFilterConfigService = rxRecordGridFilterConfigService;
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.rxRecordGridFilterService = rxRecordGridFilterService;
        this.rxRecordGridFilterHelperService = rxRecordGridFilterHelperService;
        this.rxRecordDefinitionService = rxRecordDefinitionService;
        this.rxGuidService = rxGuidService;
        this.rxRecordGridAdvancedFilteringService = rxRecordGridAdvancedFilteringService;
        this.rxGlobalCacheService = rxGlobalCacheService;
        this.rxDefinitionNameService = rxDefinitionNameService;
        this.advancedFilterData = {
            filterOptions: [],
            selectedFilters: [],
            filterTexts: {
                initialDropdownAnchorLabel: 'Filter'
            },
            recordGridFilterConfigs: null,
            fieldDefinitionsById: {},
            fieldDefinitionsInitialized$: new Subject(),
            filterValueInitialized$: new Subject(),
            associationDescriptors: []
        };
        this.subscription = new Subscription();
        this.getNamedFilterOptions = this.getNamedFilterOptions.bind(this);
        this.initEmptyValue();
        this.advancedFilterData.recordGridFilterConfigs = this.rxRecordGridFilterConfigService.getConfigs();
        this.subscription.add(combineLatest([
            this.advancedFilterData.filterValueInitialized$,
            this.advancedFilterData.fieldDefinitionsInitialized$
        ]).subscribe(() => {
            this.initSelectedAdvancedFilters(this.value);
        }));
    }
    getGroupFilterName(model) {
        var _a;
        return (_a = this.groupFilterItems.find((item) => item.value === model)) === null || _a === void 0 ? void 0 : _a.name;
    }
    onGroupFilterValueModelChange(model) {
        this.groupFilterValue = model;
    }
    ngOnInit() {
        this.initFilterOptions();
    }
    initEmptyValue() {
        this.innerValue = {
            basicFilters: null,
            filtersJson: null
        };
    }
    ngOnChanges(changes) {
        var _a, _b;
        if (changes.options &&
            changes.options.previousValue &&
            ((_a = changes.options.currentValue.primaryRecordDefinition) === null || _a === void 0 ? void 0 : _a.name) !==
                ((_b = changes.options.previousValue.primaryRecordDefinition) === null || _b === void 0 ? void 0 : _b.name)) {
            this.initEmptyValue();
            this.advancedFilterData.selectedFilters = [];
            this.advancedFilterData.filterOptions = [];
            this.initFilterOptions();
        }
    }
    initFilterOptions() {
        this.groupFilterItems = [];
        if (this.options.primaryRecordDefinition) {
            this.rxRecordGridUtilsService
                .getAssociationDescriptors(this.options.primaryRecordDefinition.name)
                .pipe(switchMap((associationDescriptors) => {
                this.advancedFilterData.associationDescriptors = associationDescriptors;
                const recordDefinitionNames = uniq(associationDescriptors.map((associationDescriptor) => associationDescriptor.recordDefinitionName));
                const recordDefinitions$ = recordDefinitionNames.length
                    ? forkJoin(recordDefinitionNames.map((name) => this.rxRecordDefinitionCacheService.getRecordDefinition(name)))
                    : of([]);
                return recordDefinitions$.pipe(map((recordDefinitions) => ({ recordDefinitions, associationDescriptors })));
            }), take(1))
                .subscribe(({ recordDefinitions, associationDescriptors }) => {
                const primaryRecordDefinition = cloneDeep(this.options.primaryRecordDefinition);
                [primaryRecordDefinition, ...recordDefinitions].forEach((recordDefinition) => {
                    if (!recordDefinition.fieldDefinitionsById) {
                        recordDefinition.fieldDefinitionsById =
                            this.rxRecordDefinitionService.buildFieldDefinitionsByIdMap(recordDefinition);
                    }
                });
                this.groupFilterValue = primaryRecordDefinition.name;
                this.advancedFilterData.fieldDefinitionsById =
                    this.rxRecordGridAdvancedFilteringService.addAssociationFieldsToFieldDefinitionsById(primaryRecordDefinition.fieldDefinitionsById, associationDescriptors, recordDefinitions);
                associationDescriptors.forEach((associationDescriptor) => {
                    const currentRecordDefinition = find(recordDefinitions, (recordDefinition) => recordDefinition.name === associationDescriptor.recordDefinitionName);
                    this.groupFilterItems.push({
                        name: associationDescriptor.label,
                        value: associationDescriptor.label
                    });
                    this.advancedFilterData.filterOptions.push(...this.getFilterOptions(currentRecordDefinition, associationDescriptor, associationDescriptor.label));
                });
                this.groupFilterItems = this.groupFilterItems.sort((gropFilter, gropFilterToCompare) => gropFilter.name.localeCompare(gropFilterToCompare.name));
                const mainRecordDefinitionName = this.rxDefinitionNameService.getDisplayName(primaryRecordDefinition.name);
                this.advancedFilterData.filterOptions.push(...this.getFilterOptions(primaryRecordDefinition, null, null));
                this.groupFilterItems.unshift({
                    name: mainRecordDefinitionName,
                    value: primaryRecordDefinition.name
                });
                this.advancedFilterData.fieldDefinitionsInitialized$.next();
            });
        }
    }
    onRemoveFilterTag(event) {
        const selectedFilters = this.advancedFilterData.selectedFilters.slice();
        const filterOptionId = event.removedTag.data.filterOption.id;
        const index = findIndex(selectedFilters, (selectedFilter) => selectedFilter.filterOptionId === filterOptionId);
        selectedFilters.splice(index, 1);
        this.onAdvancedFiltersChange(selectedFilters);
    }
    getFilterOptions(recordDefinition, associationDescriptor, prefix) {
        const fieldDefinitions = recordDefinition.fieldDefinitions;
        return fieldDefinitions
            .map((fieldDefinition) => {
            const filterConfig = this.advancedFilterData.recordGridFilterConfigs[fieldDefinition.resourceType];
            const label = this.rxRecordGridUtilsService.getColumnLabel(fieldDefinition, null);
            const fieldId = this.rxRecordGridUtilsService.getFieldIdForGridColumn(fieldDefinition.id, associationDescriptor);
            const filterOption = this.rxRecordGridAdvancedFilteringService.getAdvancedFilterOption(fieldId, label, fieldDefinition, filterConfig, false, {
                optionalBooleanFilter: this.fieldsProvider.optionalBooleanFilter,
                requiredBooleanFilter: this.fieldsProvider.requiredBooleanFilter,
                inputsForStringWithTypeAheadTemplate: this.fieldsProvider.inputsForStringWithTypeAheadTemplate,
                inputsForStringTypeTemplate: this.fieldsProvider.inputsForStringTypeTemplate,
                inputsForNumberTypeTemplate: this.fieldsProvider.inputsForNumberTypeTemplate,
                inputsForTimeTypeTemplate: this.fieldsProvider.inputsForTimeTypeTemplate,
                inputsForDateTypeTemplate: this.fieldsProvider.inputsForDateTypeTemplate,
                inputsForDatetimeTypeTemplate: this.fieldsProvider.inputsForDatetimeTypeTemplate,
                inputsForSelectionTypeTemplate: this.fieldsProvider.inputsForSelectionTypeTemplate
            }, prefix ? `${prefix} > ${label}` : null, this.options.namedFilterOptions ? this.options.namedFilterOptions[fieldId] : []);
            const recordDefinitionName = associationDescriptor
                ? associationDescriptor.label
                : this.options.primaryRecordDefinition.name;
            filterOption.isHidden = () => { var _a; return this.groupFilterValue !== recordDefinitionName || ((_a = this.options.selectedFieldIds) === null || _a === void 0 ? void 0 : _a.includes(fieldId)) === false; };
            return filterOption;
        })
            .sort((filterOption1, filterOption2) => filterOption1.label.localeCompare(filterOption2.label));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    onAdvancedFiltersChange(selectedFilters) {
        this.advancedFilterData.selectedFilters = selectedFilters;
        const oldBasicFilters = this.value.basicFilters || [];
        const basicFilters = reduce(selectedFilters, (recordGridFilters, selectedFilter) => {
            const fieldId = selectedFilter.filterOptionId;
            const fieldDefinition = this.advancedFilterData.fieldDefinitionsById[fieldId];
            const filterConfig = this.advancedFilterData.recordGridFilterConfigs[fieldDefinition.resourceType];
            const columnRecordGridFilterData = filterConfig.getRecordGridFilterData(selectedFilter.value, fieldDefinition, fieldId);
            (columnRecordGridFilterData.or || columnRecordGridFilterData.and).forEach((recordGridFilterOperator) => {
                const gridFilterValue = values(recordGridFilterOperator)[0][fieldId];
                const gridFilterDisplayValue = values(recordGridFilterOperator)[0]['$DISPLAYVALUE$'];
                const columnOldBasicFilter = find(oldBasicFilters, (oldBasicFilter) => oldBasicFilter.fieldId === fieldId &&
                    oldBasicFilter.value === gridFilterValue &&
                    every(recordGridFilters, (gridFilter) => gridFilter.guid !== oldBasicFilter.guid));
                const recordGridFilter = {
                    fieldId,
                    value: gridFilterValue,
                    $DISPLAYVALUE$: gridFilterDisplayValue,
                    guid: (columnOldBasicFilter && columnOldBasicFilter.guid) || this.rxGuidService.generate()
                };
                recordGridFilters.push(recordGridFilter);
            });
            return recordGridFilters;
        }, []);
        const recordGridFilterData = this.rxRecordGridFilterService.getRecordGridFilterDataFromAdvancedFilter(selectedFilters, this.advancedFilterData.fieldDefinitionsById, this.advancedFilterData.recordGridFilterConfigs);
        let filtersJson = isEmpty(recordGridFilterData) ? null : JSON.stringify(recordGridFilterData);
        if (filtersJson) {
            filtersJson = this.rxRecordGridFilterHelperService.denormalizeFilterString(filtersJson, basicFilters);
        }
        this.filtersModel = {
            basicFilters,
            filtersJson
        };
        this.value = {
            basicFilters,
            filtersJson
        };
    }
    onWriteValue(value) {
        if (!isEqual(this.filtersModel, value)) {
            this.advancedFilterData.filterValueInitialized$.next();
        }
    }
    initSelectedAdvancedFilters(value) {
        if ((value === null || value === void 0 ? void 0 : value.filtersJson) && !isEmpty(value.basicFilters)) {
            this.rxRecordGridFilterService
                .getSelectedFiltersFromPredefinedFilter(value.filtersJson, value.basicFilters, this.advancedFilterData.fieldDefinitionsById, this.advancedFilterData.recordGridFilterConfigs, this.options.primaryRecordDefinition, this.advancedFilterData.filterOptions, this.advancedFilterData.associationDescriptors)
                .pipe(map((selectedFilters) => this.options.namedFilterOptions
                ? this.rxRecordGridFilterService.clearRemovedNamedFilterOptions(selectedFilters, this.options.namedFilterOptions)
                : selectedFilters))
                .subscribe((selectedFilters) => {
                this.advancedFilterData.selectedFilters = selectedFilters;
            });
        }
    }
    getNamedFilterOptions(filterOptionConfig) {
        return this.options.namedFilterOptions ? this.options.namedFilterOptions[filterOptionConfig.id] : [];
    }
    getTags(filtersExpressionsTags) {
        var _a;
        const tags = (_a = filtersExpressionsTags === null || filtersExpressionsTags === void 0 ? void 0 : filtersExpressionsTags.filter((filterTag) => isEmpty(filterTag.data.validationErrors))) !== null && _a !== void 0 ? _a : [];
        const tags$ = tags.map((tag) => {
            var _a, _b;
            if (tag.data.filterOption) {
                const fieldId = tag.data.filterOption.id;
                const fieldDefinition = tag.data.filterOption.data;
                const filterConfig = this.advancedFilterData.recordGridFilterConfigs[fieldDefinition === null || fieldDefinition === void 0 ? void 0 : fieldDefinition.resourceType];
                if (isFunction(filterConfig === null || filterConfig === void 0 ? void 0 : filterConfig.getToolbarTagInfo)) {
                    return filterConfig
                        .getToolbarTagInfo({
                        primaryRecordDefinition: this.options.primaryRecordDefinition,
                        fieldDefinition,
                        value: tag.data.value,
                        tag,
                        fieldId,
                        namedFilterOptions: (_b = (_a = this.options.namedFilterOptions) === null || _a === void 0 ? void 0 : _a[fieldId]) !== null && _b !== void 0 ? _b : []
                    })
                        .pipe(tap((tagInfo) => (tag.data.value.title = tagInfo.tooltip)), map((tagInfo) => (Object.assign(Object.assign({}, tag), { text: tagInfo.text }))));
                }
            }
            return of(Object.assign({}, tag));
        });
        return tags$.length ? forkJoin(tags$) : of([]);
    }
}
RecordGridFilterSelectControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterSelectControlComponent, deps: [{ token: i0.Injector }, { token: i1$6.RxModalService }, { token: RxRecordGridUtilsService }, { token: RxRecordGridFilterConfigService }, { token: i1$5.RxRecordDefinitionCacheService }, { token: RxRecordGridFilterService }, { token: RxRecordGridFilterHelperService }, { token: i1$5.RxRecordDefinitionService }, { token: i2$1.RxGuidService }, { token: RxRecordGridAdvancedFilteringService }, { token: i1$1.RxGlobalCacheService }, { token: i1$1.RxDefinitionNameService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridFilterSelectControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridFilterSelectControlComponent, selector: "rx-record-grid-filter-select-control", inputs: { options: "options" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: RecordGridFilterSelectControlComponent,
            multi: true
        }
    ], viewQueries: [{ propertyName: "fieldsProvider", first: true, predicate: RxAdvancedFilteringFieldsProviderComponent, descendants: true, static: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<ng-container *ngIf=\"advancedFilterData.filterOptions\">\n  <adapt-advanced-filter\n    #advancedFilter\n    [hidden]=\"isDisabled\"\n    [appendDropdownToBody]=\"true\"\n    [enableSavedFilters]=\"false\"\n    [filterOptions]=\"advancedFilterData.filterOptions\"\n    (selectedFiltersChange)=\"onAdvancedFiltersChange($event)\"\n    [selectedFilters]=\"advancedFilterData.selectedFilters\"\n    [texts]=\"advancedFilterData.filterTexts\"\n    [applyFiltersByUserAction]=\"true\"\n    [filterOptionsCustomAreaTemplate]=\"filterOptionsCustomAreaTemplate\"\n    [selectedFiltersIndicationStyle]=\"'mark'\"\n    [anchorDisabled]=\"options.anchorDisabled\"\n  ></adapt-advanced-filter>\n\n  <rx-filter-tags\n    [isDisabled]=\"isDisabled\"\n    [tags]=\"getTags(advancedFilter.filtersExpressionsTags) | async\"\n    [tagsLimit]=\"options.tagsLimit\"\n    (removeTag)=\"onRemoveFilterTag($event)\"\n    [restTagsDropdownPlacement]=\"['right', 'bottom', 'bottom-right', 'auto']\"\n  ></rx-filter-tags>\n</ng-container>\n\n<ng-template #filterOptionsCustomAreaTemplate>\n  <div class=\"p-3 pt-4 pb-4\" *ngIf=\"this.groupFilterItems.length > 1\">\n    <adapt-accordion>\n      <adapt-accordion-tab [title]=\"'Show filters for: ' + getGroupFilterName(groupFilterValue)\" [multiline]=\"true\">\n        <adapt-rx-radiobutton-group\n          class=\"advanced-filter__radiobutton-group\"\n          [ngModel]=\"groupFilterValue\"\n          (ngModelChange)=\"onGroupFilterValueModelChange($event)\"\n        >\n          <adapt-rx-radiobutton\n            name=\"booleanTypeGroup\"\n            class=\"advanced-filter__radiobutton\"\n            *ngFor=\"let groupItem of groupFilterItems\"\n            [value]=\"groupItem.value\"\n            [label]=\"groupItem.name\"\n          >\n          </adapt-rx-radiobutton>\n        </adapt-rx-radiobutton-group>\n      </adapt-accordion-tab>\n    </adapt-accordion>\n  </div>\n</ng-template>\n\n<rx-advanced-filtering-fields-provider\n  [namedFilterOptionsGetter]=\"getNamedFilterOptions\"\n></rx-advanced-filtering-fields-provider>\n", styles: [":host ::ng-deep .filter-tags__tag-text{max-width:185px!important}\n"], components: [{ type: i1.AdaptAdvancedFilterComponent, selector: "adapt-advanced-filter", inputs: ["filterOptions", "savedFilters", "enableDefaultSavedFilter", "defaultSavedFilterId", "busyConfig", "activeSavedFilter", "disableExpressionEditing", "showAnchorButtonLabel", "getCustomExpressionTagFieldModel", "enableSavedFilters", "applyFiltersByUserAction", "canCloseDropdownResolver", "showTabToolbar", "disabledTabResolver", "disabledInputResolver", "showSelectedFiltersCount", "selectedFiltersIndicationStyle", "filterOptionsCustomAreaTemplate", "showTags", "anchorDisabled", "fullWidthEdit", "translateFilterEditingTitleXPixels", "selectedFilters", "isLoading"], outputs: ["selectedFiltersChange", "filterSelectionChange", "deleteSavedFilter", "createNewFilter", "updateSavedFilter", "beforeActiveSavedFilterChange", "activeSavedFilterChange", "removeTag", "filtersCleared", "saveNewFilterClick", "filtersSelectionCanceled", "editSavedFilterClick", "markDefaultSavedFilterClick", "editingSavedFilterCanceled", "filterExpressionTagsChanged"] }, { type: FilterTagsComponent, selector: "rx-filter-tags", inputs: ["tags", "isDisabled", "tagsLimit", "restTagsDropdownPlacement"], outputs: ["removeTag"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i1.AdaptRxRadiobuttonGroupComponent, selector: "adapt-rx-radiobutton-group", inputs: ["formControlName"] }, { type: i1.AdaptRxRadiobuttonComponent, selector: "adapt-rx-radiobutton", inputs: ["name", "label", "id", "value", "checked", "disabled", "ariaLabel", "ariaLabeledBy", "ariaDescribedBy", "testID", "tabIndex"], outputs: ["onFocus", "onBlur", "checkedChange"] }, { type: RxAdvancedFilteringFieldsProviderComponent, selector: "rx-advanced-filtering-fields-provider", inputs: ["namedFilterOptionsGetter"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterSelectControlComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-filter-select-control',
                    templateUrl: './record-grid-filter-select-control.component.html',
                    styleUrls: ['./record-grid-filter-select-control.component.scss'],
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: RecordGridFilterSelectControlComponent,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$6.RxModalService }, { type: RxRecordGridUtilsService }, { type: RxRecordGridFilterConfigService }, { type: i1$5.RxRecordDefinitionCacheService }, { type: RxRecordGridFilterService }, { type: RxRecordGridFilterHelperService }, { type: i1$5.RxRecordDefinitionService }, { type: i2$1.RxGuidService }, { type: RxRecordGridAdvancedFilteringService }, { type: i1$1.RxGlobalCacheService }, { type: i1$1.RxDefinitionNameService }]; }, propDecorators: { options: [{
                type: Input
            }], fieldsProvider: [{
                type: ViewChild,
                args: [RxAdvancedFilteringFieldsProviderComponent, { static: true }]
            }] } });

var RecordGridFilterMode;
(function (RecordGridFilterMode) {
    RecordGridFilterMode["Basic"] = "basic";
    RecordGridFilterMode["Expression"] = "expression";
})(RecordGridFilterMode || (RecordGridFilterMode = {}));

class RxFilterTagsModule {
}
RxFilterTagsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxFilterTagsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxFilterTagsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxFilterTagsModule, declarations: [FilterTagsComponent], imports: [CommonModule, AdaptTagModule, AdaptDropdownModule, TranslateModule], exports: [FilterTagsComponent] });
RxFilterTagsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxFilterTagsModule, imports: [[CommonModule, AdaptTagModule, AdaptDropdownModule, TranslateModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxFilterTagsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptTagModule, AdaptDropdownModule, TranslateModule],
                    declarations: [FilterTagsComponent],
                    exports: [FilterTagsComponent]
                }]
        }] });

class RxNamedFilterOptionsListModule {
}
RxNamedFilterOptionsListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNamedFilterOptionsListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxNamedFilterOptionsListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNamedFilterOptionsListModule, declarations: [RxNamedFilterOptionsListComponent], imports: [CommonModule, AdaptRxCheckboxModule, FormsModule], exports: [RxNamedFilterOptionsListComponent] });
RxNamedFilterOptionsListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNamedFilterOptionsListModule, imports: [[CommonModule, AdaptRxCheckboxModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNamedFilterOptionsListModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxNamedFilterOptionsListComponent],
                    exports: [RxNamedFilterOptionsListComponent],
                    imports: [CommonModule, AdaptRxCheckboxModule, FormsModule]
                }]
        }] });

class RecordGridCommonModule {
}
RecordGridCommonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridCommonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridCommonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridCommonModule, imports: [CommonModule,
        AdaptRxRadiobuttonModule,
        AdaptRxSelectModule,
        TranslateModule,
        AdaptTagModule,
        FormsModule, i1.AdaptDropdownModule, AdaptMetatagModule,
        RxNamedFilterOptionsListModule,
        RxFilterTagsModule], exports: [RxFilterTagsModule, RxNamedFilterOptionsListModule] });
RecordGridCommonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridCommonModule, imports: [[
            CommonModule,
            AdaptRxRadiobuttonModule,
            AdaptRxSelectModule,
            TranslateModule,
            AdaptTagModule,
            FormsModule,
            AdaptDropdownModule.forRoot(),
            AdaptMetatagModule,
            RxNamedFilterOptionsListModule,
            RxFilterTagsModule
        ], RxFilterTagsModule, RxNamedFilterOptionsListModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridCommonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        AdaptRxRadiobuttonModule,
                        AdaptRxSelectModule,
                        TranslateModule,
                        AdaptTagModule,
                        FormsModule,
                        AdaptDropdownModule.forRoot(),
                        AdaptMetatagModule,
                        RxNamedFilterOptionsListModule,
                        RxFilterTagsModule
                    ],
                    exports: [RxFilterTagsModule, RxNamedFilterOptionsListModule]
                }]
        }] });

class RxStringFilterModule {
}
RxStringFilterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringFilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxStringFilterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringFilterModule, declarations: [RxStringFilterComponent], imports: [CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptMetatagModule], exports: [RxStringFilterComponent] });
RxStringFilterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringFilterModule, imports: [[CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptMetatagModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringFilterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxStringFilterComponent],
                    exports: [RxStringFilterComponent],
                    imports: [CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptMetatagModule]
                }]
        }] });

class RxNumberFilterModule {
}
RxNumberFilterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNumberFilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxNumberFilterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNumberFilterModule, declarations: [RxNumberFilterComponent], imports: [CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxCounterModule], exports: [RxNumberFilterComponent] });
RxNumberFilterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNumberFilterModule, imports: [[CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxCounterModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxNumberFilterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxNumberFilterComponent],
                    exports: [RxNumberFilterComponent],
                    imports: [CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxCounterModule]
                }]
        }] });

class RxDateTimeRangeFilterModule {
}
RxDateTimeRangeFilterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDateTimeRangeFilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxDateTimeRangeFilterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDateTimeRangeFilterModule, declarations: [RxDateTimeRangeFilterComponent], imports: [CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxDatetimeModule], exports: [RxDateTimeRangeFilterComponent] });
RxDateTimeRangeFilterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDateTimeRangeFilterModule, imports: [[CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxDatetimeModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxDateTimeRangeFilterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxDateTimeRangeFilterComponent],
                    exports: [RxDateTimeRangeFilterComponent],
                    imports: [CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxDatetimeModule]
                }]
        }] });

class RxSelectionFilterModule {
}
RxSelectionFilterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxSelectionFilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxSelectionFilterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxSelectionFilterModule, declarations: [RxSelectionFilterComponent], imports: [CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxSelectModule], exports: [RxSelectionFilterComponent] });
RxSelectionFilterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxSelectionFilterModule, imports: [[CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxSelectModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxSelectionFilterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxSelectionFilterComponent],
                    exports: [RxSelectionFilterComponent],
                    imports: [CommonModule, FormsModule, RxNamedFilterOptionsListModule, AdaptRxSelectModule]
                }]
        }] });

class RxBooleanFilterModule {
}
RxBooleanFilterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxBooleanFilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxBooleanFilterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxBooleanFilterModule, declarations: [RxBooleanFilterComponent], imports: [CommonModule, RxNamedFilterOptionsListModule, AdaptRxRadiobuttonModule, AdaptRxSelectModule, FormsModule], exports: [RxBooleanFilterComponent] });
RxBooleanFilterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxBooleanFilterModule, imports: [[CommonModule, RxNamedFilterOptionsListModule, AdaptRxRadiobuttonModule, AdaptRxSelectModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxBooleanFilterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxBooleanFilterComponent],
                    exports: [RxBooleanFilterComponent],
                    imports: [CommonModule, RxNamedFilterOptionsListModule, AdaptRxRadiobuttonModule, AdaptRxSelectModule, FormsModule]
                }]
        }] });

class RxStringWithTypeAheadFilterModule {
}
RxStringWithTypeAheadFilterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringWithTypeAheadFilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxStringWithTypeAheadFilterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringWithTypeAheadFilterModule, declarations: [RxStringWithTypeAheadFilterComponent], imports: [CommonModule, RxNamedFilterOptionsListModule, AdaptMetatagModule, FormsModule, TranslateModule], exports: [RxStringWithTypeAheadFilterComponent] });
RxStringWithTypeAheadFilterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringWithTypeAheadFilterModule, imports: [[CommonModule, RxNamedFilterOptionsListModule, AdaptMetatagModule, FormsModule, TranslateModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxStringWithTypeAheadFilterModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxStringWithTypeAheadFilterComponent],
                    exports: [RxStringWithTypeAheadFilterComponent],
                    imports: [CommonModule, RxNamedFilterOptionsListModule, AdaptMetatagModule, FormsModule, TranslateModule]
                }]
        }] });

class RxAdvancedFilteringFieldsProviderModule {
}
RxAdvancedFilteringFieldsProviderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdvancedFilteringFieldsProviderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RxAdvancedFilteringFieldsProviderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdvancedFilteringFieldsProviderModule, declarations: [RxAdvancedFilteringFieldsProviderComponent], imports: [CommonModule,
        RxStringFilterModule,
        RxNumberFilterModule,
        RxDateTimeRangeFilterModule,
        RxSelectionFilterModule,
        RxBooleanFilterModule,
        RxStringWithTypeAheadFilterModule], exports: [RxAdvancedFilteringFieldsProviderComponent] });
RxAdvancedFilteringFieldsProviderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdvancedFilteringFieldsProviderModule, imports: [[
            CommonModule,
            RxStringFilterModule,
            RxNumberFilterModule,
            RxDateTimeRangeFilterModule,
            RxSelectionFilterModule,
            RxBooleanFilterModule,
            RxStringWithTypeAheadFilterModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxAdvancedFilteringFieldsProviderModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxAdvancedFilteringFieldsProviderComponent],
                    exports: [RxAdvancedFilteringFieldsProviderComponent],
                    imports: [
                        CommonModule,
                        RxStringFilterModule,
                        RxNumberFilterModule,
                        RxDateTimeRangeFilterModule,
                        RxSelectionFilterModule,
                        RxBooleanFilterModule,
                        RxStringWithTypeAheadFilterModule
                    ]
                }]
        }] });

class RecordGridFilterSelectControlModule {
}
RecordGridFilterSelectControlModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterSelectControlModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridFilterSelectControlModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterSelectControlModule, declarations: [RecordGridFilterSelectControlComponent], imports: [CommonModule,
        AdaptAdvancedFilteringModule,
        RecordGridCommonModule,
        AdaptAccordionModule,
        AdaptRxRadiobuttonModule,
        FormsModule,
        RxAdvancedFilteringFieldsProviderModule], exports: [RecordGridFilterSelectControlComponent] });
RecordGridFilterSelectControlModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterSelectControlModule, imports: [[
            CommonModule,
            AdaptAdvancedFilteringModule,
            RecordGridCommonModule,
            AdaptAccordionModule,
            AdaptRxRadiobuttonModule,
            FormsModule,
            RxAdvancedFilteringFieldsProviderModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterSelectControlModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RecordGridFilterSelectControlComponent],
                    exports: [RecordGridFilterSelectControlComponent],
                    entryComponents: [RecordGridFilterSelectControlComponent],
                    imports: [
                        CommonModule,
                        AdaptAdvancedFilteringModule,
                        RecordGridCommonModule,
                        AdaptAccordionModule,
                        AdaptRxRadiobuttonModule,
                        FormsModule,
                        RxAdvancedFilteringFieldsProviderModule
                    ]
                }]
        }] });

class RxRecordGridFilterSelectHelperService {
    getNamedFilterOptionsFromColumns(columns) {
        return columns.reduce((result, col) => {
            var _a;
            if ((_a = col.namedFilterOptions) === null || _a === void 0 ? void 0 : _a.length) {
                result[col.fieldId] = col.namedFilterOptions
                    .map((column) => (Object.assign(Object.assign({ guid: column.guid }, column.data), { index: toNumber(column.data.index) })))
                    .sort((a, b) => a.index - b.index);
            }
            return result;
        }, {});
    }
}
RxRecordGridFilterSelectHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterSelectHelperService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridFilterSelectHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterSelectHelperService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridFilterSelectHelperService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class RecordGridFilterPresetEditorModalComponent extends RxModalClass {
    constructor(activeModalRef, rxModalService, rxGuidService, injector) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.rxModalService = rxModalService;
        this.rxGuidService = rxGuidService;
        this.injector = injector;
        this.filterPresets = [];
        this.params = this.activeModalRef.getData();
        const activeFilterPreset = this.params.activeFilterPreset;
        this.recordDefinition = this.params.primaryRecordDefinition;
        this.selectedFieldIds = this.params.selectedFieldIds;
        this.isReadOnly = this.params.isReadOnly;
        this.filterPresets = map$1(this.params.filterPresets, (filterPreset) => this.createFilterPresetEditorData(filterPreset, filterPreset === activeFilterPreset));
    }
    ngAfterViewInit() {
        const openFilterPresetIndex = findIndex(this.filterPresets, 'isOpen');
        if (openFilterPresetIndex !== -1) {
            this.accordionTabEls.toArray()[openFilterPresetIndex].nativeElement.scrollIntoView({
                block: 'nearest'
            });
        }
    }
    addFilterPreset() {
        this.markAsDirty();
        this.filterPresets.push(this.createFilterPresetEditorData({
            guid: this.rxGuidService.generate(),
            title: 'New preset' + (this.filterPresets.length === 0 ? '' : ' ' + this.filterPresets.length),
            filters: '',
            recordGridFilters: []
        }, true));
        setTimeout(() => {
            this.accordionTabEls.last.nativeElement.scrollIntoView({
                block: 'nearest'
            });
        });
    }
    removeFilterPreset(index) {
        this.markAsDirty();
        this.filterPresets.splice(index, 1);
    }
    createFilterPresetEditorData(filterPreset, isOpen) {
        return Object.assign(Object.assign({}, filterPreset), { isOpen, filterSelectOptions: {
                primaryRecordDefinition: this.recordDefinition,
                tagsLimit: 2,
                namedFilterOptions: this.params.namedFilterOptions,
                selectedFieldIds: this.selectedFieldIds
            }, filterSelect: {
                basicFilters: filterPreset.recordGridFilters,
                filtersJson: filterPreset.filters
            } });
    }
    getCheckPresetTitleDuplicateValidator(currentFilterPreset) {
        return (control) => {
            const title = control.value;
            if (title &&
                this.filterPresets.some((filterPreset) => filterPreset.title === title && filterPreset.guid !== currentFilterPreset.guid)) {
                return { duplicatePresetName: { message: 'Duplicate Name' } };
            }
            return null;
        };
    }
    trackByForFilterPresets(index, filterPreset) {
        return filterPreset.guid;
    }
    toggleOpen(expandAll) {
        this.filterPresets.forEach((action) => (action.isOpen = expandAll));
    }
    onSaveChangesClick() {
        const result = {
            filterPresets: this.filterPresets.map((filterPreset) => ({
                filters: filterPreset.filterSelect.filtersJson,
                recordGridFilters: filterPreset.filterSelect.basicFilters,
                guid: filterPreset.guid,
                title: filterPreset.title
            }))
        };
        const hasEmptyFilterPreset = some(result.filterPresets, (filterPreset) => isEmpty(filterPreset.recordGridFilters));
        if (hasEmptyFilterPreset) {
            this.rxModalService
                .confirm({
                title: 'Warning',
                modalStyle: RX_MODAL.modalStyles.warning,
                message: 'The filter preset will not filter records because no filters have been specified. Do you want to continue?'
            })
                .then((confirmResult) => {
                if (confirmResult) {
                    this.activeModalRef.close(result);
                }
            });
        }
        else {
            this.activeModalRef.close(result);
        }
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
}
RecordGridFilterPresetEditorModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterPresetEditorModalComponent, deps: [{ token: i1.ActiveModalRef }, { token: i1$6.RxModalService }, { token: i2$1.RxGuidService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
RecordGridFilterPresetEditorModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridFilterPresetEditorModalComponent, selector: "rx-record-grid-filter-preset-editor-modal", viewQueries: [{ propertyName: "filterPresetsForm", first: true, predicate: ["filterPresetsForm"], descendants: true, read: NgForm, static: true }, { propertyName: "accordionTabEls", predicate: AdaptAccordionTabComponent, descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<div class=\"designer-modal-body modal-body d-flex mh-100\">\n  <div class=\"row flex-grow-1 w-100\">\n    <div class=\"d-flex flex-column mh-100 col\">\n      <div class=\"d-flex align-items-start justify-content-between\">\n        <button\n          *ngIf=\"!isReadOnly\"\n          class=\"mt-2 p-0\"\n          rx-id=\"add-button\"\n          adapt-button\n          type=\"button\"\n          btn-type=\"tertiary\"\n          (click)=\"addFilterPreset()\"\n        >\n          <span class=\"d-icon-left-plus_circle\"></span>\n\n          {{\n            'com.bmc.arsys.rx.client.view-components.record-grid-filter-preset.add-filter-preset.button.label'\n              | translate\n          }}\n        </button>\n\n        <div *ngIf=\"filterPresets.length\" class=\"btn-group\">\n          <button adapt-button btn-type=\"tertiary\" type=\"button\" rx-id=\"expand-all-button\" (click)=\"toggleOpen(true)\">\n            {{ 'com.bmc.arsys.rx.client.common.expand-all.label' | translate }}\n          </button>\n\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"collapse-all-button\"\n            (click)=\"toggleOpen(false)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.collapse-all.label' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"designer-modal-accordion-wrapper\">\n        <adapt-accordion [multiselect]=\"true\">\n          <form #filterPresetsForm=\"ngForm\">\n            <div\n              *ngFor=\"let filterPreset of filterPresets; let index = index; trackBy: trackByForFilterPresets\"\n              class=\"designer-modal-accordion-content\"\n            >\n              <adapt-accordion-tab\n                class=\"d-block\"\n                [isOpen]=\"filterPreset.isOpen\"\n                (open)=\"filterPreset.isOpen = true\"\n                (close)=\"filterPreset.isOpen = false\"\n                #accordionTab\n              >\n                <div class=\"card-title-text w-100\">\n                  <div class=\"designer-modal-card-title-content\">\n                    <div class=\"left-header-block pl-0\">\n                      <div class=\"rx-ellipsis\" [title]=\"filterPreset.title\" rx-id=\"card-title\">\n                        {{ filterPreset.title }}\n                      </div>\n                    </div>\n\n                    <div *ngIf=\"!isReadOnly\" class=\"right-header-block\">\n                      <button\n                        class=\"d-icon-left-cross_adapt p-1 pr-4 ml-3\"\n                        adapt-button\n                        size=\"small\"\n                        type=\"button\"\n                        (click)=\"$event.stopPropagation(); removeFilterPreset(index)\"\n                        rx-id=\"remove-button\"\n                      >\n                        {{ 'com.bmc.arsys.rx.client.common.remove.label' | translate }}\n                      </button>\n                    </div>\n                  </div>\n                </div>\n\n                <adapt-rx-textfield\n                  label=\"{{\n                    'com.bmc.arsys.rx.client.view-components.record-grid-filter-preset.name-field.label' | translate\n                  }}\"\n                  [name]=\"'filterPresetTitle-' + filterPreset.guid\"\n                  [required]=\"true\"\n                  [disabled]=\"isReadOnly\"\n                  [rxCustomValidators]=\"getCheckPresetTitleDuplicateValidator(filterPreset)\"\n                  (ngModelChange)=\"markAsDirty()\"\n                  [(ngModel)]=\"filterPreset.title\"\n                  rxNoWhitespace\n                ></adapt-rx-textfield>\n\n                <div *ngIf=\"accordionTab.isOpenOrCloseAnimationProcessing\">\n                  <rx-record-grid-filter-select-control\n                    [name]=\"'filterPresetFilterSelect-' + filterPreset.guid\"\n                    [disabled]=\"isReadOnly\"\n                    [options]=\"filterPreset.filterSelectOptions\"\n                    (ngModelChange)=\"markAsDirty()\"\n                    [(ngModel)]=\"filterPreset.filterSelect\"\n                  ></rx-record-grid-filter-select-control>\n                </div>\n              </adapt-accordion-tab>\n            </div>\n          </form>\n        </adapt-accordion>\n      </div>\n\n      <div *ngIf=\"!filterPresets.length\" class=\"d-flex justify-content-center h-100 align-items-center mt-2\">\n        <adapt-empty-state\n          class=\"w-100\"\n          label=\"{{\n            'com.bmc.arsys.rx.client.view-components.record-grid-filter-preset.empty-state.message' | translate\n          }}\"\n          type=\"search\"\n        ></adapt-empty-state>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    *ngIf=\"!isReadOnly\"\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"filterPresetsForm.form.invalid || !isDirty()\"\n    (click)=\"onSaveChangesClick()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{\n      isReadOnly\n        ? ('com.bmc.arsys.rx.client.common.close.label' | translate)\n        : ('com.bmc.arsys.rx.client.common.cancel.label' | translate)\n    }}\n  </button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.designer-modal-body{height:645px;min-height:calc(100% - 61px)!important}.designer-modal-accordion-wrapper{display:flex;flex-direction:column;height:100%;overflow:auto;padding-top:10px}.designer-modal-accordion-content{position:relative}.designer-modal-accordion-content.cdk-drag-preview{z-index:1200!important}.designer-modal-drag-handle{cursor:move;position:absolute;top:0;left:0;height:46px;padding:14px 10px 14px 14px;z-index:1}.designer-modal-card-title-content{width:100%;display:flex}.designer-modal-card-title-content .left-header-block,.designer-modal-card-title-content .right-header-block{display:flex;align-items:center}.designer-modal-card-title-content .left-header-block{flex-grow:1;min-width:0;font-size:14px;padding-left:22px}.designer-modal-card-sub-title{color:#7c7f81;font-weight:normal}.designer-modal-card-title-index-buttons{display:flex;font-size:19px}.rx-card{overflow:auto}.rx-tree-draggable-node{cursor:pointer}.rx-tree-draggable-node.cdk-drag-preview{z-index:1200!important}.rx-tree-draggable-node.cdk-drag{opacity:1}.rx-tree-node-label{word-break:break-all}rx-form-builder{max-width:400px}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: RecordGridFilterSelectControlComponent, selector: "rx-record-grid-filter-select-control", inputs: ["options"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i2$3.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i2$3.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2$1.RxNoWhitespaceValidator, selector: "[rxNoWhitespace]", inputs: ["rxNoWhitespace"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i1$6.RxCustomValidatorsDirective, selector: "[rxCustomValidators][ngModel],[rxCustomValidators][formControl]", inputs: ["rxCustomValidators"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "translate": i2.TranslatePipe }, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterPresetEditorModalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-filter-preset-editor-modal',
                    templateUrl: './record-grid-filter-preset-editor-modal.component.html',
                    styleUrls: ['./record-grid-filter-preset-editor-modal.component.scss'],
                    encapsulation: ViewEncapsulation.None
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i1$6.RxModalService }, { type: i2$1.RxGuidService }, { type: i0.Injector }]; }, propDecorators: { accordionTabEls: [{
                type: ViewChildren,
                args: [AdaptAccordionTabComponent, { read: ElementRef }]
            }], filterPresetsForm: [{
                type: ViewChild,
                args: ['filterPresetsForm', { read: NgForm, static: true }]
            }] } });

class RecordGridFilterPresetEditorControlComponent extends ValueAccessor {
    constructor(rxModalService, rxRecordGridFilterSelectHelperService) {
        super();
        this.rxModalService = rxModalService;
        this.rxRecordGridFilterSelectHelperService = rxRecordGridFilterSelectHelperService;
        this.filterPresets = [];
    }
    onWriteValue(filterPresets) {
        this.filterPresets = filterPresets.slice();
        this.filterPresets.sort((filterPreset1, filterPreset2) => filterPreset1.title.localeCompare(filterPreset2.title));
    }
    removeFilterPreset(filterPresetToRemove) {
        this.updateValue(this.filterPresets.filter((filterPreset) => filterPreset.guid !== filterPresetToRemove.guid));
    }
    updateValue(filterPresets) {
        this.value = filterPresets;
        this.onWriteValue(filterPresets);
    }
    openEditor(filterPreset) {
        const selectedFieldIds = this.options.columns.map((column) => column.fieldId);
        const selectedFieldDefinitions = this.options.primaryRecordDefinition.fieldDefinitions.filter((fieldDefinition) => selectedFieldIds.includes(fieldDefinition.id.toString()));
        const namedFilterOptions = this.rxRecordGridFilterSelectHelperService.getNamedFilterOptionsFromColumns(this.options.columns);
        const data = {
            filterPresets: this.filterPresets,
            activeFilterPreset: filterPreset,
            isReadOnly: this.isDisabled,
            namedFilterOptions,
            primaryRecordDefinition: cloneDeep(Object.assign(Object.assign({}, this.options.primaryRecordDefinition), { fieldDefinitions: selectedFieldDefinitions })),
            selectedFieldIds
        };
        this.rxModalService
            .openModal({
            title: 'Edit filter presets',
            content: RecordGridFilterPresetEditorModalComponent,
            size: OpenViewActionModalSize.Large,
            testID: 'edit-filter-presets',
            data
        })
            .then((result) => {
            if (result && result.filterPresets) {
                this.updateValue(result.filterPresets);
            }
        })
            .catch(noop);
    }
    trackByForFilterPresets(index, filterPreset) {
        return filterPreset.guid;
    }
}
RecordGridFilterPresetEditorControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterPresetEditorControlComponent, deps: [{ token: i1$6.RxModalService }, { token: RxRecordGridFilterSelectHelperService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridFilterPresetEditorControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridFilterPresetEditorControlComponent, selector: "rx-record-grid-filter-preset-editor", inputs: { options: "options" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: RecordGridFilterPresetEditorControlComponent,
            multi: true
        }
    ], usesInheritance: true, ngImport: i0, template: "<adapt-rx-control-label *ngIf=\"options.label\" [label]=\"options.label\" [tooltip]=\"options?.tooltip\">\n</adapt-rx-control-label>\n\n<adapt-button *ngIf=\"!isDisabled\" btn-type=\"tertiary\" rx-id=\"open-modal-button\" class=\"p-0 pb-1\" (click)=\"openEditor()\">\n  <span class=\"d-icon-plus_circle\"></span>\n  Edit filter presets\n</adapt-button>\n\n<div>\n  <div class=\"rx-selected-filter-preset\" *ngFor=\"let filterPreset of filterPresets; trackBy: trackByForFilterPresets\">\n    <div class=\"rx-selected-filter-preset__header-container\">\n      <span class=\"rx-selected-filter-preset__header-title\" rx-id=\"card-title\" [title]=\"filterPreset.title\">\n        {{ filterPreset.title }}\n      </span>\n\n      <button\n        type=\"button\"\n        class=\"rx-button-unstyled d-icon-left-pencil btn-link\"\n        rx-id=\"open-editor\"\n        *ngIf=\"!isDisabled\"\n        (click)=\"openEditor(filterPreset)\"\n      ></button>\n      <button\n        type=\"button\"\n        class=\"rx-button-unstyled d-icon-cross btn-link\"\n        rx-id=\"remove-filter-preset\"\n        *ngIf=\"!isDisabled\"\n        (click)=\"removeFilterPreset(filterPreset)\"\n      ></button>\n    </div>\n\n    <div rx-id=\"filter-count\" class=\"rx-filter-count\">Filters: {{ filterPreset.recordGridFilters.length }}</div>\n  </div>\n  <span class=\"text-tertiary\" *ngIf=\"filterPresets.length === 0\"> No filter presets added. </span>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.rx-selected-filter-preset{margin-bottom:5px;border:1px solid #d6d7d8;border-radius:2px;padding:5px 10px;word-break:break-all;font-weight:var(--font-weight-bold)}.rx-selected-filter-preset__header-container{display:flex;margin-bottom:5px}.rx-selected-filter-preset__header-title{flex:1 1 auto;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-size:.875rem}.rx-filter-count{font-size:.625rem;color:#959899}.d-icon-cross,.d-icon-left-pencil{cursor:pointer}.d-icon-cross:not(:hover),.d-icon-left-pencil:not(:hover){color:#313538}\n"], components: [{ type: i1.AdaptRxControlLabelComponent, selector: "adapt-rx-control-label", inputs: ["for", "id", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridFilterPresetEditorControlComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-filter-preset-editor',
                    templateUrl: './record-grid-filter-preset-editor-control.component.html',
                    styleUrls: ['./record-grid-filter-preset-editor-control.component.scss'],
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: RecordGridFilterPresetEditorControlComponent,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i1$6.RxModalService }, { type: RxRecordGridFilterSelectHelperService }]; }, propDecorators: { options: [{
                type: Input
            }] } });

class RecordGridRowActionEditorModalComponent extends RxModalClass {
    constructor(context, adaptModalService, rxExpressionEditorService, translateService, rxRecordDefinitionCacheService, ngZone, rxGuidService, injector) {
        super(context, injector);
        this.context = context;
        this.adaptModalService = adaptModalService;
        this.rxExpressionEditorService = rxExpressionEditorService;
        this.translateService = translateService;
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.ngZone = ngZone;
        this.rxGuidService = rxGuidService;
        this.injector = injector;
        this.rowActions = [];
        this.selectFormControlOptions = {
            label: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-row-actions.field-name.label'),
            tooltip: new Tooltip(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-row-actions.field-name.tooltip')),
            options: [],
            emptyOption: true
        };
        this.availableOnDevicesFormControlOptions = getAvailableOnDevicesInspectorConfig().options;
        this.recordDefinitionPickerOptions = {
            label: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-row-actions.security-definition-name.label'),
            tooltip: new Tooltip(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-row-actions.security-definition-name.tooltip')),
            definitionType: RxDefinitionPickerType.StandardDataRecord,
            required: false
        };
        this.iconPickerOptions = {
            label: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-row-actions.icon.label'),
            appendToBody: true,
            required: false
        };
    }
    ngOnInit() {
        super.ngOnInit();
        const params = this.context.getData();
        this.expressionConfigurator = params.expressionConfigurator;
        this.rowActionIndex = params.rowActionIndex;
        this.activeActionIndex = params.activeActionIndex;
        this.isReadOnly = params.isReadOnly;
        this.rowActions = cloneDeep(params.rowActions).map((rowAction, index) => {
            this.setSecurityFieldDefinitions(rowAction);
            return Object.assign(Object.assign({}, rowAction), { isOpen: index === this.rowActionIndex });
        });
    }
    ngAfterViewInit() {
        this.openActiveAction();
        if (this.rowActionIndex) {
            this.accordionTabEls.toArray()[this.rowActionIndex].nativeElement.scrollIntoView({
                block: 'nearest'
            });
        }
    }
    cancel() {
        this.context.dismiss(DismissReasons.CLOSE_BTN);
    }
    trackByGuid(index, rowAction) {
        return rowAction.guid;
    }
    addRowAction() {
        this.markAsDirty();
        this.rowActions.push(Object.assign({ guid: this.rxGuidService.generate(), label: 'New row action' + (this.rowActions.length === 0 ? '' : ' ' + this.rowActions.length), icon: '', recordDefinitionName: null, fieldId: null, recordInstance: null, disabled: null, hidden: null, actions: [], isOpen: true, securityFieldDefinitions$: of(this.getSelectFormControlOptions()) }, RX_AVAILABLE_ON_DEVICES_DEFAULT_VALUE));
        setTimeout(() => {
            this.accordionTabEls.last.nativeElement.scrollIntoView({
                block: 'nearest'
            });
        });
    }
    removeRowAction(index, $event) {
        $event.stopPropagation();
        this.markAsDirty();
        this.rowActions.splice(index, 1);
    }
    openExpressionEditor(event, rowAction, propertyPath) {
        this.rxExpressionEditorService
            .openEditor({
            property: {
                path: propertyPath,
                value: rowAction[propertyPath],
                label: this.getRowActionLabel(propertyPath)
            },
            isReadOnly: false,
            expressionConfigurator: this.expressionConfigurator,
            legend: [
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.function.label'),
                    icon: 'd-icon-mathematical_function'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.keyword.label'),
                    icon: 'd-icon-dollar'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.view-component.label'),
                    icon: 'd-icon-file_o'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.view-component-property.label'),
                    icon: 'd-icon-file_o_gear'
                },
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.expression-editor.legend.view-input-parameter.label'),
                    icon: 'd-icon-arrow_right_square_input'
                }
            ]
        })
            .subscribe((expression) => {
            this.markAsDirty();
            rowAction[propertyPath] = expression.value;
        });
    }
    getExpressionFormControlOptions(propertyPath) {
        return {
            label: this.getRowActionLabel(propertyPath),
            tooltip: propertyPath === 'recordInstance'
                ? new Tooltip(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-row-actions.recordInstance.tooltip'))
                : null,
            dataDictionary$: this.context.getData().expressionConfigurator.getDataDictionary(propertyPath),
            operators: this.context.getData().expressionConfigurator.getOperators(propertyPath)
        };
    }
    saveActions() {
        const rowActions = this.rowActions.map((rowAction) => (Object.assign(Object.assign({}, omit(rowAction, ['isOpen', 'securityFieldDefinitions$'])), { action: 'rowAction' })));
        this.context.close(rowActions);
    }
    moveRowAction(fromIndex, toIndex) {
        moveItemInArray(this.rowActions, fromIndex, toIndex);
        this.markAsDirty();
    }
    onDropInSelectedRowActionsContainer($event) {
        moveItemInArray(this.rowActions, $event.previousIndex, $event.currentIndex);
        this.markAsDirty();
    }
    onRecordDefinitionChange(rowAction) {
        this.markAsDirty();
        rowAction.fieldId = null;
        this.setSecurityFieldDefinitions(rowAction);
    }
    setSecurityFieldDefinitions(rowAction) {
        rowAction.securityFieldDefinitions$ = rowAction.recordDefinitionName
            ? this.rxRecordDefinitionCacheService
                .getRecordDefinition(rowAction.recordDefinitionName)
                .pipe(map((recordDefinition) => this.getSelectFormControlOptions(recordDefinition)))
            : of(this.getSelectFormControlOptions());
    }
    getRowActionLabel(key) {
        let rowActionLabel;
        switch (key) {
            case 'disabled':
                rowActionLabel = 'com.bmc.arsys.rx.client.view-components.record-grid-row-actions.disabled.label';
                break;
            case 'hidden':
                rowActionLabel = 'com.bmc.arsys.rx.client.view-components.record-grid-row-actions.hidden.label';
                break;
            case 'recordInstance':
                rowActionLabel = 'com.bmc.arsys.rx.client.view-components.record-grid-row-actions.recordInstance.label';
                break;
        }
        return this.translateService.instant(rowActionLabel);
    }
    getSelectFormControlOptions(recordDefinition = null) {
        return Object.assign(Object.assign({}, this.selectFormControlOptions), { options: recordDefinition
                ? recordDefinition.fieldDefinitions.map((definition) => ({
                    name: definition.name,
                    id: String(definition.id)
                }))
                : [] });
    }
    openActiveAction() {
        if (this.activeActionIndex >= 0 && this.rowActionIndex >= 0) {
            this.ngZone.runOutsideAngular(() => {
                // timeout is required to let control set initial value
                setTimeout(() => {
                    const listControl = this.actionListControlComponents.find((control) => { var _a; return isEqual(control.value, (_a = this.rowActions[this.rowActionIndex]) === null || _a === void 0 ? void 0 : _a.actions); });
                    if (listControl) {
                        listControl.focus({ actionIndex: this.activeActionIndex });
                    }
                });
            });
        }
    }
    toggleOpen(expandAll) {
        this.rowActions.forEach((action) => (action.isOpen = expandAll));
    }
}
RecordGridRowActionEditorModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridRowActionEditorModalComponent, deps: [{ token: i1.ActiveModalRef }, { token: i1.AdaptModalService }, { token: i2$5.RxExpressionEditorService }, { token: i2.TranslateService }, { token: i1$5.RxRecordDefinitionCacheService }, { token: i0.NgZone }, { token: i2$1.RxGuidService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
RecordGridRowActionEditorModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridRowActionEditorModalComponent, selector: "rx-record-grid-row-action-editor-modal", viewQueries: [{ propertyName: "rowActionsForm", first: true, predicate: ["rowActionsForm"], descendants: true, read: NgForm, static: true }, { propertyName: "selectedRowActionsDropList", first: true, predicate: ["selectedRowActionsDropList"], descendants: true, read: CdkDropList }, { propertyName: "accordionTabEls", predicate: AdaptAccordionTabComponent, descendants: true, read: ElementRef }, { propertyName: "draggableSelectedRowAction", predicate: ["draggableSelectedRowAction"], descendants: true, read: CdkDrag }, { propertyName: "actionListControlComponents", predicate: ActionListControlComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"designer-modal-body modal-body d-flex mh-100\">\n  <div class=\"row flex-grow-1 w-100\">\n    <div class=\"d-flex flex-column mh-100 col\">\n      <div class=\"d-flex align-items-start justify-content-between\">\n        <button\n          *ngIf=\"!isReadOnly\"\n          class=\"mt-2 p-0\"\n          rx-id=\"add-button\"\n          adapt-button\n          type=\"button\"\n          btn-type=\"tertiary\"\n          (click)=\"addRowAction()\"\n        >\n          <span class=\"d-icon-left-plus_circle\"></span>\n\n          {{\n            'com.bmc.arsys.rx.client.view-components.record-grid-row-actions.add-row-action.button.label' | translate\n          }}\n        </button>\n\n        <div *ngIf=\"rowActions.length\" class=\"btn-group\">\n          <button adapt-button btn-type=\"tertiary\" type=\"button\" rx-id=\"expand-all-button\" (click)=\"toggleOpen(true)\">\n            {{ 'com.bmc.arsys.rx.client.common.expand-all.label' | translate }}\n          </button>\n\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"collapse-all-button\"\n            (click)=\"toggleOpen(false)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.collapse-all.label' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <div\n        id=\"selectedRowActionsDropList\"\n        class=\"designer-modal-accordion-wrapper\"\n        cdkDropList\n        [cdkDropListData]=\"rowActions\"\n        (cdkDropListDropped)=\"onDropInSelectedRowActionsContainer($event)\"\n        #selectedRowActionsDropList=\"cdkDropList\"\n      >\n        <adapt-accordion [multiselect]=\"true\">\n          <form #rowActionsForm=\"ngForm\">\n            <div\n              *ngFor=\"\n                let rowAction of rowActions;\n                let index = index;\n                let first = first;\n                let last = last;\n                trackBy: trackByGuid\n              \"\n              class=\"designer-modal-accordion-content\"\n              cdkDrag\n              cdkDragLockAxis=\"y\"\n              [cdkDragData]=\"rowAction\"\n              [cdkDragDisabled]=\"isReadOnly\"\n              #draggableSelectedRowAction\n            >\n              <div *ngIf=\"!isReadOnly\" class=\"designer-modal-drag-handle d-icon-left-dots\" cdkDragHandle></div>\n\n              <adapt-accordion-tab\n                class=\"d-block\"\n                [isOpen]=\"rowAction.isOpen\"\n                (open)=\"rowAction.isOpen = true\"\n                (close)=\"rowAction.isOpen = false\"\n              >\n                <div class=\"card-title-text w-100\">\n                  <div class=\"designer-modal-card-title-content\">\n                    <div class=\"left-header-block\" [class.pl-0]=\"isReadOnly\">\n                      <div class=\"rx-ellipsis\" [title]=\"rowAction.label\" rx-id=\"card-title\">\n                        {{ rowAction.label }}\n                      </div>\n                    </div>\n\n                    <div *ngIf=\"!isReadOnly\" class=\"right-header-block\">\n                      <div class=\"designer-modal-card-title-index-buttons\">\n                        <button\n                          class=\"d-icon-left-triangle_down rx-button-unstyled\"\n                          type=\"button\"\n                          [disabled]=\"last\"\n                          (click)=\"$event.stopPropagation(); moveRowAction(index, index + 1)\"\n                          rx-id=\"move-down-button\"\n                        ></button>\n\n                        <button\n                          class=\"d-icon-left-triangle_up rx-button-unstyled\"\n                          type=\"button\"\n                          [disabled]=\"first\"\n                          (click)=\"$event.stopPropagation(); moveRowAction(index, index - 1)\"\n                          rx-id=\"move-up-button\"\n                        ></button>\n                      </div>\n\n                      <button\n                        class=\"d-icon-left-cross_adapt p-1 pr-4 ml-3\"\n                        adapt-button\n                        size=\"small\"\n                        type=\"button\"\n                        (click)=\"removeRowAction(index, $event)\"\n                        rx-id=\"remove-button\"\n                      >\n                        {{ 'com.bmc.arsys.rx.client.common.remove.label' | translate }}\n                      </button>\n                    </div>\n                  </div>\n                </div>\n\n                <div class=\"d-flex row\">\n                  <adapt-rx-textfield\n                    class=\"form-group d-block col-4\"\n                    label=\"{{\n                      'com.bmc.arsys.rx.client.view-components.record-grid-row-actions.label-field.label' | translate\n                    }}\"\n                    [disabled]=\"isReadOnly\"\n                    [required]=\"true\"\n                    [name]=\"'label_' + rowAction.guid\"\n                    rx-id=\"label\"\n                    [(ngModel)]=\"rowAction.label\"\n                    (ngModelChange)=\"markAsDirty()\"\n                    rxNoWhitespace\n                  >\n                  </adapt-rx-textfield>\n\n                  <rx-icon-picker-form-control\n                    [disabled]=\"isReadOnly\"\n                    class=\"form-group d-block col-4 px-2\"\n                    [options]=\"iconPickerOptions\"\n                    [name]=\"'icon_' + rowAction.guid\"\n                    rx-id=\"icon\"\n                    [(ngModel)]=\"rowAction.icon\"\n                    (ngModelChange)=\"markAsDirty()\"\n                  ></rx-icon-picker-form-control>\n                </div>\n\n                <div class=\"d-flex row\">\n                  <rx-definition-picker\n                    [isDisabled]=\"isReadOnly\"\n                    [options]=\"recordDefinitionPickerOptions\"\n                    [(ngModel)]=\"rowAction.recordDefinitionName\"\n                    [name]=\"'recordDefinition_' + rowAction.guid\"\n                    rx-id=\"recordDefinition\"\n                    (ngModelChange)=\"onRecordDefinitionChange(rowAction)\"\n                    class=\"form-group d-block col-4\"\n                  >\n                  </rx-definition-picker>\n\n                  <rx-select-form-control\n                    [options]=\"(rowAction.securityFieldDefinitions$ | async) || selectFormControlOptions\"\n                    [(ngModel)]=\"rowAction.fieldId\"\n                    [name]=\"'fieldId_' + rowAction.guid\"\n                    rx-id=\"fieldId\"\n                    [disabled]=\"!rowAction.recordDefinitionName || isReadOnly\"\n                    [appendToBody]=\"true\"\n                    class=\"col-4 px-2\"\n                    (ngModelChange)=\"markAsDirty()\"\n                  >\n                  </rx-select-form-control>\n\n                  <rx-expression-form-control\n                    [disabled]=\"!rowAction.recordDefinitionName || isReadOnly\"\n                    [options]=\"getExpressionFormControlOptions('recordInstance')\"\n                    propertyPath=\"recordInstance\"\n                    [ngModel]=\"rowAction.recordInstance\"\n                    (events)=\"openExpressionEditor($event, rowAction, 'recordInstance')\"\n                    [name]=\"'recordInstance_' + rowAction.guid\"\n                    rx-id=\"recordInstance\"\n                    class=\"col-4\"\n                  >\n                  </rx-expression-form-control>\n                </div>\n\n                <div class=\"d-flex row\">\n                  <rx-expression-form-control\n                    [disabled]=\"isReadOnly\"\n                    [options]=\"getExpressionFormControlOptions('disabled')\"\n                    propertyPath=\"disabled\"\n                    [ngModel]=\"rowAction.disabled\"\n                    (events)=\"openExpressionEditor($event, rowAction, 'disabled')\"\n                    [name]=\"'disabled_' + rowAction.guid\"\n                    rx-id=\"disabled\"\n                    class=\"col-4\"\n                  >\n                  </rx-expression-form-control>\n\n                  <rx-expression-form-control\n                    [disabled]=\"isReadOnly\"\n                    [options]=\"getExpressionFormControlOptions('hidden')\"\n                    propertyPath=\"hidden\"\n                    [ngModel]=\"rowAction.hidden\"\n                    (events)=\"openExpressionEditor($event, rowAction, 'hidden')\"\n                    [name]=\"'hidden_' + rowAction.guid\"\n                    rx-id=\"hidden\"\n                    class=\"col-4\"\n                  >\n                  </rx-expression-form-control>\n\n                  <rx-select-form-control\n                    [options]=\"availableOnDevicesFormControlOptions\"\n                    [(ngModel)]=\"rowAction.availableOnDevices\"\n                    [name]=\"'availableOnDevices_' + rowAction.guid\"\n                    rx-id=\"availableOnDevices\"\n                    [disabled]=\"isReadOnly\"\n                    [appendToBody]=\"true\"\n                    class=\"col-4 px-2\"\n                    (ngModelChange)=\"markAsDirty()\"\n                    required\n                  >\n                  </rx-select-form-control>\n                </div>\n\n                <div class=\"d-flex row\">\n                  <rx-action-list-control\n                    class=\"d-inline-block col-4 mt-2\"\n                    [(ngModel)]=\"rowAction.actions\"\n                    (ngModelChange)=\"markAsDirty()\"\n                    [name]=\"'action_' + rowAction.guid\"\n                  ></rx-action-list-control>\n                </div>\n              </adapt-accordion-tab>\n            </div>\n          </form>\n        </adapt-accordion>\n      </div>\n\n      <div *ngIf=\"!rowActions.length\" class=\"d-flex justify-content-center h-100 align-items-center mt-2\">\n        <adapt-empty-state\n          class=\"w-100\"\n          label=\"{{\n            'com.bmc.arsys.rx.client.view-components.record-grid-row-actions.empty-state.message' | translate\n          }}\"\n          type=\"config\"\n        ></adapt-empty-state>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    *ngIf=\"!isReadOnly\"\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"rowActionsForm.invalid || !isDirty()\"\n    (click)=\"saveActions()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{\n      isReadOnly\n        ? ('com.bmc.arsys.rx.client.common.close.label' | translate)\n        : ('com.bmc.arsys.rx.client.common.cancel.label' | translate)\n    }}\n  </button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.designer-modal-body{height:645px;min-height:calc(100% - 61px)!important}.designer-modal-accordion-wrapper{display:flex;flex-direction:column;height:100%;overflow:auto;padding-top:10px}.designer-modal-accordion-content{position:relative}.designer-modal-accordion-content.cdk-drag-preview{z-index:1200!important}.designer-modal-drag-handle{cursor:move;position:absolute;top:0;left:0;height:46px;padding:14px 10px 14px 14px;z-index:1}.designer-modal-card-title-content{width:100%;display:flex}.designer-modal-card-title-content .left-header-block,.designer-modal-card-title-content .right-header-block{display:flex;align-items:center}.designer-modal-card-title-content .left-header-block{flex-grow:1;min-width:0;font-size:14px;padding-left:22px}.designer-modal-card-sub-title{color:#7c7f81;font-weight:normal}.designer-modal-card-title-index-buttons{display:flex;font-size:19px}.rx-card{overflow:auto}.rx-tree-draggable-node{cursor:pointer}.rx-tree-draggable-node.cdk-drag-preview{z-index:1200!important}.rx-tree-draggable-node.cdk-drag{opacity:1}.rx-tree-node-label{word-break:break-all}rx-form-builder{max-width:400px}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: i2$5.IconPickerFormControlComponent, selector: "rx-icon-picker-form-control", inputs: ["options"] }, { type: i2$5.RxDefinitionPickerComponent, selector: "rx-definition-picker", inputs: ["options", "isDisabled"] }, { type: i2$5.SelectFormControlComponent, selector: "rx-select-form-control", inputs: ["options", "appendToBody", "formControl"] }, { type: i2$5.ExpressionFormControlComponent, selector: "rx-expression-form-control", inputs: ["options", "isDisabled", "propertyPath"], outputs: ["events"] }, { type: i1$3.ActionListControlComponent, selector: "rx-action-list-control", inputs: ["options", "tooltip"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "id", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListAutoScrollDisabled", "cdkDropListOrientation", "cdkDropListLockAxis", "cdkDropListData", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i2$3.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i2$3.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i2$3.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragDisabled", "cdkDragStartDelay", "cdkDragLockAxis", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragBoundary", "cdkDragRootElement", "cdkDragPreviewContainer", "cdkDragData", "cdkDragFreeDragPosition"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i8.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { type: i2$1.RxNoWhitespaceValidator, selector: "[rxNoWhitespace]", inputs: ["rxNoWhitespace"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "translate": i2.TranslatePipe, "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridRowActionEditorModalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-row-action-editor-modal',
                    templateUrl: './record-grid-row-action-editor-modal.component.html',
                    styleUrls: ['./record-grid-row-action-editor-modal.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i1.AdaptModalService }, { type: i2$5.RxExpressionEditorService }, { type: i2.TranslateService }, { type: i1$5.RxRecordDefinitionCacheService }, { type: i0.NgZone }, { type: i2$1.RxGuidService }, { type: i0.Injector }]; }, propDecorators: { accordionTabEls: [{
                type: ViewChildren,
                args: [AdaptAccordionTabComponent, { read: ElementRef }]
            }], rowActionsForm: [{
                type: ViewChild,
                args: ['rowActionsForm', { static: true, read: NgForm }]
            }], draggableSelectedRowAction: [{
                type: ViewChildren,
                args: ['draggableSelectedRowAction', { read: CdkDrag }]
            }], selectedRowActionsDropList: [{
                type: ViewChild,
                args: ['selectedRowActionsDropList', { read: CdkDropList }]
            }], actionListControlComponents: [{
                type: ViewChildren,
                args: [ActionListControlComponent]
            }] } });

class RxRecordGridRowActionEditorWidgetComponent extends InspectorWidgetBase {
    constructor(injector, rxModalService, translateService) {
        super(injector);
        this.injector = injector;
        this.rxModalService = rxModalService;
        this.translateService = translateService;
        this.rowActions$ = this.designerItemModel.rowActionButtonComponents$.pipe(map((rowActionButtons) => {
            return rowActionButtons.map((rowActionButtonComponent) => {
                const actions = rowActionButtonComponent.children.map((action) => omit(action, 'type', 'children'));
                return Object.assign(Object.assign({}, pick(rowActionButtonComponent.data, [
                    'recordDefinitionName',
                    'recordInstance',
                    'fieldId',
                    'icon',
                    'disabled',
                    'hidden',
                    'label',
                    RX_AVAILABLE_ON_DEVICES_PROP_NAME
                ])), { guid: rowActionButtonComponent.guid, actions });
            });
        }), shareReplay(1));
    }
    openEditor(rowActionIndex, activeActionIndex) {
        this.rowActions$
            .pipe(take(1), switchMap((rowActions) => from(this.rxModalService.openModal({
            content: RecordGridRowActionEditorModalComponent,
            title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-row-actions.modal.title'),
            size: OpenViewActionModalSize.Large,
            testID: 'edit-row-actions',
            data: {
                expressionConfigurator: this.designerItemModel.expressionConfigurator,
                isReadOnly: this.isDisabled,
                rowActionIndex,
                rowActions,
                activeActionIndex
            }
        }))))
            .subscribe({
            next: (newRowActions) => this.designerItemModel.setRowActions(newRowActions),
            error: noop
        });
    }
    trackByForRowActions(index, rowAction) {
        return rowAction.label;
    }
    removeRowAction(index, rowActions) {
        this.rxModalService
            .confirm({
            title: this.translateService.instant('com.bmc.arsys.rx.client.common.warning.label'),
            modalStyle: RX_MODAL.modalStyles.warning,
            message: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid-row-actions.row-action-delete.warning', { name: rowActions[index].label })
        })
            .then((response) => {
            if (response) {
                rowActions.splice(index, 1);
                this.designerItemModel.setRowActions(rowActions);
            }
        });
    }
    focus(data) {
        this.openEditor(data.rowActionIndex, data.actionIndex);
    }
}
RxRecordGridRowActionEditorWidgetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridRowActionEditorWidgetComponent, deps: [{ token: i0.Injector }, { token: i1$6.RxModalService }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
RxRecordGridRowActionEditorWidgetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxRecordGridRowActionEditorWidgetComponent, selector: "rx-record-grid-row-action-editor-widget", usesInheritance: true, ngImport: i0, template: "<adapt-button btn-type=\"tertiary\" rx-id=\"open-row-action-editor-modal-button\" class=\"p-0 pb-1\" (click)=\"openEditor()\">\n  <span class=\"d-icon-plus_circle\"></span>\n  Edit row actions\n</adapt-button>\n\n<div *ngIf=\"rowActions$ | async as rowActions\">\n  <span rx-id=\"no-row-actions\" *ngIf=\"rowActions.length === 0\" class=\"text-tertiary\"> No row actions added. </span>\n  <div\n    rx-id=\"row-actions-list\"\n    class=\"rx-selected-row-action\"\n    *ngFor=\"let rowAction of rowActions; let index = index; trackBy: trackByForRowActions\"\n  >\n    <div class=\"rx-selected-row-action__header-container\">\n      <span rx-id=\"row-action\" class=\"rx-selected-row-action__header-title\" [title]=\"rowAction.label\">\n        {{ rowAction.label }}\n      </span>\n\n      <button\n        type=\"button\"\n        class=\"rx-button-unstyled d-icon-left-pencil btn-link\"\n        rx-id=\"edit-button\"\n        (click)=\"openEditor(index)\"\n      ></button>\n      <button\n        type=\"button\"\n        class=\"rx-button-unstyled d-icon-cross btn-link\"\n        rx-id=\"remove-button\"\n        (click)=\"removeRowAction(index, rowActions)\"\n      ></button>\n    </div>\n  </div>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.rx-selected-row-action{margin-bottom:5px;border:1px solid #d6d7d8;border-radius:2px;padding:5px 10px;word-break:break-all;font-weight:var(--font-weight-bold)}.rx-selected-row-action__header-container{display:flex}.rx-selected-row-action__header-title{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;font-size:14px}.d-icon-cross,.d-icon-left-pencil{cursor:pointer}.d-icon-cross:not(:hover),.d-icon-left-pencil:not(:hover){color:#313538}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridRowActionEditorWidgetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-row-action-editor-widget',
                    templateUrl: './record-grid-row-action-editor-widget.component.html',
                    styleUrls: ['./record-grid-row-action-editor-widget.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$6.RxModalService }, { type: i2.TranslateService }]; } });

class RecordGridSortEditorControlComponent extends ValueAccessor {
    constructor(renderer, rxRecordGridUtilsService, rxStringService) {
        super();
        this.renderer = renderer;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxStringService = rxStringService;
        this.ColumnSortDirection = ColumnSortDirection;
        this.updateOptionsSubject = new BehaviorSubject(null);
        this.columnOptions$ = this.updateOptionsSubject.pipe(switchMap(() => this.options.gridColumns && this.options.recordDefinition
            ? forkJoin(this.options.gridColumns
                .filter((gridColumn) => gridColumn.sortable)
                .map((gridColumn) => {
                if (this.rxStringService.isEmptySafe(gridColumn.title)) {
                    return this.rxRecordGridUtilsService
                        .getFieldDefinition(gridColumn.fieldId, this.options.recordDefinition)
                        .pipe(map((fieldDefinition) => ({ id: gridColumn.fieldId, name: `[${fieldDefinition.name}]` })));
                }
                return of({ id: gridColumn.fieldId, name: gridColumn.title });
            })).pipe(defaultIfEmpty([]))
            : of([])));
        this.selectedColumnOption = [];
    }
    get selectedSortDirection() {
        return this.value ? this.value.direction : null;
    }
    ngOnChanges(changes) {
        var _a, _b, _c;
        if (((_a = changes.options) === null || _a === void 0 ? void 0 : _a.previousValue) &&
            (!isEqual(changes.options.currentValue.gridColumns, changes.options.previousValue.gridColumns) ||
                ((_b = changes.options.currentValue.recordDefinition) === null || _b === void 0 ? void 0 : _b.name) !==
                    ((_c = changes.options.previousValue.recordDefinition) === null || _c === void 0 ? void 0 : _c.name))) {
            this.updateOptionsSubject.next();
        }
    }
    onWriteValue(value) {
        this.columnOptions$.pipe(take(1)).subscribe((columnOptions) => {
            this.selectedColumnOption = value ? [columnOptions.find((option) => option.id === value.fieldId)] : [];
        });
    }
    focus() {
        this.renderer.selectRootElement(this.adaptRxSelect.selectButtonRef.nativeElement, true).focus();
    }
    onSelectModelChange(value) {
        this.selectedColumnOption = value;
        this.value = isEmpty(value) ? null : { fieldId: head(value).id, direction: ColumnSortDirection.Asc };
    }
    setSortDirection(sortDirection) {
        this.value = Object.assign(Object.assign({}, this.value), { direction: sortDirection });
    }
    optionFormatter(option) {
        return option.name;
    }
    ngOnDestroy() {
        this.updateOptionsSubject.complete();
    }
}
RecordGridSortEditorControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridSortEditorControlComponent, deps: [{ token: i0.Renderer2 }, { token: RxRecordGridUtilsService }, { token: i2$1.RxStringService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridSortEditorControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridSortEditorControlComponent, selector: "rx-record-grid-sort-editor-control", inputs: { options: "options" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: RecordGridSortEditorControlComponent,
            multi: true
        }
    ], viewQueries: [{ propertyName: "adaptRxSelect", first: true, predicate: ["adaptRxSelect"], descendants: true, static: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div class=\"form-group\" [ngClass]=\"{ 'is-required': options.required }\">\n  <label class=\"form-control-label\" *ngIf=\"options.label\">{{ options.label }}</label>\n\n  <div class=\"d-flex\">\n    <adapt-rx-select\n      #adaptRxSelect\n      class=\"pr-1 w-100\"\n      *ngIf=\"columnOptions$ | async as columnOptions\"\n      [options]=\"columnOptions\"\n      [required]=\"options.required\"\n      [disabled]=\"isDisabled\"\n      [ngModel]=\"selectedColumnOption\"\n      (ngModelChange)=\"onSelectModelChange($event)\"\n      [optionFormatter]=\"optionFormatter\"\n      [emptyOption]=\"true\"\n    ></adapt-rx-select>\n\n    <div class=\"btn-group\" data-toggle=\"buttons\" *ngIf=\"selectedColumnOption.length\">\n      <button\n        adapt-button\n        btn-type=\"secondary\"\n        type=\"button\"\n        class=\"pl-2 pr-2 d-icon-arrow_up\"\n        (click)=\"setSortDirection(ColumnSortDirection.Asc)\"\n        [class.active]=\"selectedSortDirection === ColumnSortDirection.Asc\"\n      ></button>\n      <button\n        adapt-button\n        btn-type=\"secondary\"\n        type=\"button\"\n        class=\"pl-2 pr-2 d-icon-arrow_down\"\n        (click)=\"setSortDirection(ColumnSortDirection.Desc)\"\n        [class.active]=\"selectedSortDirection === ColumnSortDirection.Desc\"\n      ></button>\n    </div>\n  </div>\n</div>\n", components: [{ type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridSortEditorControlComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-sort-editor-control',
                    templateUrl: './record-grid-sort-editor-control.component.html',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: RecordGridSortEditorControlComponent,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: RxRecordGridUtilsService }, { type: i2$1.RxStringService }]; }, propDecorators: { options: [{
                type: Input
            }], adaptRxSelect: [{
                type: ViewChild,
                args: ['adaptRxSelect', { static: true }]
            }] } });

var RecordGridDesignDefinitionMode;
(function (RecordGridDesignDefinitionMode) {
    RecordGridDesignDefinitionMode["Record"] = "record";
    RecordGridDesignDefinitionMode["Association"] = "association";
})(RecordGridDesignDefinitionMode || (RecordGridDesignDefinitionMode = {}));

class RecordGridViewPresetColumnsModalComponent extends RxModalClass {
    constructor(activeModalRef, injector) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.injector = injector;
        this.params = this.activeModalRef.getData();
        this.presetColumns = this.params.presetColumns.map((column, index) => {
            const gridColumn = this.params.gridColumns.find((col) => col.fieldId === column.data.fieldId);
            return Object.assign(Object.assign({}, cloneDeep(column)), { isOpen: index === 0, title: gridColumn.title, fallbackTitle: gridColumn.fallbackTitle });
        });
        this.isReadOnly = this.params.isReadOnly;
        this.columnWidthPropertyOptions = RX_RECORD_GRID.columnProperties.find(({ name }) => name === 'width').options;
        this.presetColumns.sort((a, b) => a.data.index - b.data.index);
    }
    expandAllColumns(event) {
        event.stopPropagation();
        this.presetColumns.forEach((column) => (column.isOpen = true));
    }
    collapseAllColumns(event) {
        event.stopPropagation();
        this.presetColumns.forEach((column) => (column.isOpen = false));
    }
    saveChanges() {
        this.activeModalRef.close({
            presetColumns: this.presetColumns.map((column) => omit(column, ['isOpen', 'title']))
        });
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
    moveColumn(fromIndex, toIndex) {
        this.markAsDirty();
        moveItemInArray(this.presetColumns, fromIndex, toIndex);
        this.updateColumnIndexes();
    }
    onDropInSelectedColumnsContainer(event) {
        this.moveColumn(event.previousIndex, event.currentIndex);
    }
    trackByGuid(index, column) {
        return column.guid;
    }
    updateColumnIndexes() {
        this.presetColumns.forEach((column, index) => {
            column.data.index = index;
        });
    }
}
RecordGridViewPresetColumnsModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetColumnsModalComponent, deps: [{ token: i1.ActiveModalRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
RecordGridViewPresetColumnsModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridViewPresetColumnsModalComponent, selector: "rx-record-grid-view-preset-columns-modal", usesInheritance: true, ngImport: i0, template: "<div class=\"designer-modal-body modal-body d-flex mh-100\">\n  <div class=\"row flex-grow-1 w-100\">\n    <div class=\"d-flex flex-column mh-100 col\">\n      <div class=\"d-flex justify-content-end\">\n        <div class=\"btn-group\">\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"expand-all-button\"\n            (click)=\"expandAllColumns($event)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.expand-all.label' | translate }}\n          </button>\n\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"collapse-all-button\"\n            (click)=\"collapseAllColumns($event)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.collapse-all.label' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <div\n        class=\"designer-modal-accordion-wrapper\"\n        cdkDropList\n        [cdkDropListData]=\"presetColumns\"\n        (cdkDropListDropped)=\"onDropInSelectedColumnsContainer($event)\"\n      >\n        <adapt-accordion [multiselect]=\"true\">\n          <div\n            *ngFor=\"\n              let column of presetColumns;\n              let index = index;\n              let first = first;\n              let last = last;\n              trackBy: trackByGuid\n            \"\n            class=\"designer-modal-accordion-content\"\n            cdkDrag\n            [cdkDragDisabled]=\"isReadOnly\"\n            [cdkDragData]=\"column\"\n            cdkDragLockAxis=\"y\"\n          >\n            <div *ngIf=\"!isReadOnly\" class=\"designer-modal-drag-handle d-icon-left-dots\" cdkDragHandle></div>\n\n            <adapt-accordion-tab\n              class=\"d-block\"\n              [isOpen]=\"column.isOpen\"\n              (open)=\"column.isOpen = true\"\n              (close)=\"column.isOpen = false\"\n            >\n              <div class=\"card-title-text w-100\">\n                <div class=\"designer-modal-card-title-content\">\n                  <div class=\"left-header-block\" [class.pl-0]=\"isReadOnly\">\n                    <div class=\"rx-ellipsis\" [title]=\"column.title\">\n                      {{ column.title || column.fallbackTitle }}\n                    </div>\n\n                    <div *ngIf=\"column.data.visible\" class=\"designer-modal-card-sub-title ml-2\" [title]=\"column.title\">\n                      visible\n                    </div>\n                  </div>\n\n                  <div *ngIf=\"!isReadOnly\" class=\"right-header-block\">\n                    <div class=\"designer-modal-card-title-index-buttons\">\n                      <button\n                        class=\"d-icon-left-triangle_down rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"last\"\n                        (click)=\"$event.stopPropagation(); moveColumn(index, index + 1)\"\n                        rx-id=\"move-down-button\"\n                      ></button>\n\n                      <button\n                        class=\"d-icon-left-triangle_up rx-button-unstyled\"\n                        type=\"button\"\n                        [disabled]=\"first\"\n                        (click)=\"$event.stopPropagation(); moveColumn(index, index - 1)\"\n                        rx-id=\"move-up-button\"\n                      ></button>\n                    </div>\n                  </div>\n                </div>\n              </div>\n\n              <adapt-rx-textfield\n                label=\"Column header\"\n                [disabled]=\"true\"\n                [(ngModel)]=\"column.title\"\n              ></adapt-rx-textfield>\n\n              <adapt-rx-checkbox\n                label=\"Visible\"\n                [(ngModel)]=\"column.data.visible\"\n                [disabled]=\"isReadOnly\"\n                (ngModelChange)=\"markAsDirty()\"\n              ></adapt-rx-checkbox>\n\n              <rx-stepper-with-units-form-control\n                class=\"d-block col-5 p-0\"\n                [options]=\"columnWidthPropertyOptions\"\n                [(ngModel)]=\"column.data.width\"\n                (ngModelChange)=\"markAsDirty()\"\n              ></rx-stepper-with-units-form-control>\n            </adapt-accordion-tab>\n          </div>\n        </adapt-accordion>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    *ngIf=\"!isReadOnly\"\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"!isDirty()\"\n    (click)=\"saveChanges()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{\n      isReadOnly\n        ? ('com.bmc.arsys.rx.client.common.close.label' | translate)\n        : ('com.bmc.arsys.rx.client.common.cancel.label' | translate)\n    }}\n  </button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.designer-modal-body{height:645px;min-height:calc(100% - 61px)!important}.designer-modal-accordion-wrapper{display:flex;flex-direction:column;height:100%;overflow:auto;padding-top:10px}.designer-modal-accordion-content{position:relative}.designer-modal-accordion-content.cdk-drag-preview{z-index:1200!important}.designer-modal-drag-handle{cursor:move;position:absolute;top:0;left:0;height:46px;padding:14px 10px 14px 14px;z-index:1}.designer-modal-card-title-content{width:100%;display:flex}.designer-modal-card-title-content .left-header-block,.designer-modal-card-title-content .right-header-block{display:flex;align-items:center}.designer-modal-card-title-content .left-header-block{flex-grow:1;min-width:0;font-size:14px;padding-left:22px}.designer-modal-card-sub-title{color:#7c7f81;font-weight:normal}.designer-modal-card-title-index-buttons{display:flex;font-size:19px}.rx-card{overflow:auto}.rx-tree-draggable-node{cursor:pointer}.rx-tree-draggable-node.cdk-drag-preview{z-index:1200!important}.rx-tree-draggable-node.cdk-drag{opacity:1}.rx-tree-node-label{word-break:break-all}rx-form-builder{max-width:400px}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: i1.AdaptRxCheckboxComponent, selector: "adapt-rx-checkbox", inputs: ["value", "checked", "indeterminate"], outputs: ["indeterminateChange"] }, { type: i2$5.StepperWithUnitsFormControlComponent, selector: "rx-stepper-with-units-form-control", inputs: ["options"] }], directives: [{ type: i8.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "id", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListAutoScrollDisabled", "cdkDropListOrientation", "cdkDropListLockAxis", "cdkDropListData", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragDisabled", "cdkDragStartDelay", "cdkDragLockAxis", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragBoundary", "cdkDragRootElement", "cdkDragPreviewContainer", "cdkDragData", "cdkDragFreeDragPosition"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetColumnsModalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-view-preset-columns-modal',
                    templateUrl: './record-grid-view-preset-columns-modal.component.html',
                    styleUrls: ['./record-grid-view-preset-columns-modal.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i0.Injector }]; } });

class RecordGridEditViewPresetsModalComponent extends RxModalClass {
    constructor(activeModalRef, injector, rxModalService, rxRecordGridDesignUtilsService, rxRecordGridFilterSelectHelperService, rxRecordGridUtilsService, rxStringService) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.injector = injector;
        this.rxModalService = rxModalService;
        this.rxRecordGridDesignUtilsService = rxRecordGridDesignUtilsService;
        this.rxRecordGridFilterSelectHelperService = rxRecordGridFilterSelectHelperService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxStringService = rxStringService;
        this.params = this.activeModalRef.getData();
        this.presets = [];
        this.isReadOnly = this.params.isReadOnly;
        this.gridColumns$ = this.params.gridColumns && this.params.recordDefinition
            ? forkJoin(this.params.gridColumns.map((gridColumn) => {
                if (this.rxStringService.isEmptySafe(gridColumn.title)) {
                    return this.rxRecordGridUtilsService
                        .getFieldDefinition(gridColumn.fieldId, this.params.recordDefinition)
                        .pipe(map((fieldDefinition) => (Object.assign(Object.assign({}, gridColumn), { fallbackTitle: `[${fieldDefinition.name}]` }))));
                }
                return of(Object.assign(Object.assign({}, gridColumn), { fallbackTitle: `[${gridColumn.title}]` }));
            })).pipe(defaultIfEmpty([]))
            : of([]);
    }
    ngOnInit() {
        super.ngOnInit();
        this.gridColumns$.pipe(take(1)).subscribe((gridColumns) => {
            this.namedFilterOptions =
                this.rxRecordGridFilterSelectHelperService.getNamedFilterOptionsFromColumns(gridColumns);
            this.presets = this.params.presetsList.map(({ guid, name }, index) => {
                const presetComponent = this.params.viewPresets.find(({ data }) => data.viewPresetGuid === guid);
                const gridColumnsIds = gridColumns.filter((col) => col.filterable).map((col) => col.fieldId);
                const viewPresetGuid = presetComponent.data.viewPresetGuid;
                const presetColumns = cloneDeep(presetComponent.children.filter((col) => col.type === RX_RECORD_GRID.components.columnViewPreset));
                const sortedColumn = presetColumns.find((col) => isObject(col.data.sortable));
                const sortModel = sortedColumn
                    ? {
                        fieldId: sortedColumn.data.fieldId,
                        direction: sortedColumn.data.sortable.direction
                    }
                    : null;
                return {
                    presetName: name,
                    gridColumns,
                    presetColumns,
                    guid: viewPresetGuid,
                    tags: this.getTags(presetColumns, gridColumns),
                    isOpen: this.params.activePreset ? this.params.activePreset === viewPresetGuid : index === 0,
                    sortModel,
                    filters: {
                        basicFilters: this.rxRecordGridDesignUtilsService.getBasicRecordGridFiltersFromChildData(presetComponent.children),
                        filtersJson: presetComponent.data.filters
                    },
                    filterSelectControlOptions: {
                        primaryRecordDefinition: Object.assign(Object.assign({}, this.params.recordDefinition), { fieldDefinitions: this.params.recordDefinition.fieldDefinitions.filter((definition) => gridColumnsIds.includes(String(definition.id))) }),
                        selectedFieldIds: gridColumns.map((column) => column.fieldId),
                        namedFilterOptions: this.namedFilterOptions
                    },
                    sortEditorControlOptions: {
                        label: 'Initial column sort',
                        gridColumns: sortBy(gridColumns, 'title'),
                        recordDefinition: this.params.recordDefinition
                    }
                };
            });
        });
    }
    saveChanges() {
        this.activeModalRef.close({
            presets: this.presets
        });
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
    expandAll(event) {
        event.stopPropagation();
        this.presets.forEach((preset) => (preset.isOpen = true));
    }
    collapseAll(event) {
        event.stopPropagation();
        this.presets.forEach((preset) => (preset.isOpen = false));
    }
    openPresetColumnsModal(preset) {
        this.rxModalService
            .openModal({
            title: `Edit grid columns for ${preset.presetName}`,
            content: RecordGridViewPresetColumnsModalComponent,
            size: OpenViewActionModalSize.Large,
            data: {
                gridColumns: preset.gridColumns,
                presetColumns: preset.presetColumns,
                isReadOnly: this.isReadOnly
            },
            testID: 'edit-grid-columns-for-view-preset'
        })
            .then((result) => {
            if (result === null || result === void 0 ? void 0 : result.presetColumns) {
                preset.presetColumns = result.presetColumns;
                preset.tags = this.getTags(preset.presetColumns, preset.gridColumns);
                this.markAsDirty();
            }
        })
            .catch(noop);
    }
    trackByPreset(index, item) {
        return item.guid;
    }
    getTags(presetColumns, gridColumns) {
        const allColumnTitles = presetColumns
            .filter((column) => column.data.visible)
            .map((column) => {
            const gridColumn = gridColumns.find((col) => col.fieldId === column.data.fieldId);
            return gridColumn.title || gridColumn.fallbackTitle;
        });
        const displayedColumnTitles = allColumnTitles.slice(0, 5);
        return {
            items: displayedColumnTitles,
            restCount: allColumnTitles.length - displayedColumnTitles.length
        };
    }
    onSortChange(sortModel, preset) {
        preset.presetColumns.forEach((column) => {
            column.data.sortable = column.data.fieldId === (sortModel === null || sortModel === void 0 ? void 0 : sortModel.fieldId) ? pick(sortModel, 'direction') : null;
        });
        this.markAsDirty();
    }
}
RecordGridEditViewPresetsModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridEditViewPresetsModalComponent, deps: [{ token: i1.ActiveModalRef }, { token: i0.Injector }, { token: i1$6.RxModalService }, { token: RxRecordGridDesignUtilsService }, { token: RxRecordGridFilterSelectHelperService }, { token: RxRecordGridUtilsService }, { token: i2$1.RxStringService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridEditViewPresetsModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridEditViewPresetsModalComponent, selector: "rx-record-grid-edit-view-presets-modal", usesInheritance: true, ngImport: i0, template: "<div class=\"designer-modal-body modal-body d-flex mh-100\">\n  <div class=\"row flex-grow-1 w-100\">\n    <div class=\"d-flex flex-column mh-100 col\">\n      <div class=\"d-flex justify-content-end\">\n        <div class=\"btn-group\">\n          <button adapt-button btn-type=\"tertiary\" type=\"button\" rx-id=\"expand-all-button\" (click)=\"expandAll($event)\">\n            {{ 'com.bmc.arsys.rx.client.common.expand-all.label' | translate }}\n          </button>\n\n          <button\n            adapt-button\n            btn-type=\"tertiary\"\n            type=\"button\"\n            rx-id=\"collapse-all-button\"\n            (click)=\"collapseAll($event)\"\n          >\n            {{ 'com.bmc.arsys.rx.client.common.collapse-all.label' | translate }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"designer-modal-accordion-wrapper\">\n        <adapt-accordion [multiselect]=\"true\">\n          <div\n            *ngFor=\"let preset of presets; let index = index; trackBy: trackByPreset\"\n            class=\"designer-modal-accordion-content\"\n          >\n            <adapt-accordion-tab\n              class=\"d-block\"\n              [isOpen]=\"preset.isOpen\"\n              (open)=\"preset.isOpen = true\"\n              (close)=\"preset.isOpen = false\"\n            >\n              <div class=\"card-title-text w-100\">\n                <div class=\"designer-modal-card-title-content\">\n                  <div class=\"left-header-block pl-0\">\n                    <div class=\"rx-ellipsis\" [title]=\"preset.presetName\" rx-id=\"card-title\">\n                      {{ preset.presetName }}\n                    </div>\n                  </div>\n                </div>\n              </div>\n\n              <adapt-button\n                btn-type=\"tertiary\"\n                rx-id=\"open-grid-preset-columns-modal-button\"\n                class=\"p-0 pb-1\"\n                (click)=\"openPresetColumnsModal(preset)\"\n              >\n                <span class=\"d-icon-plus_circle\"></span>\n\n                Edit grid columns\n              </adapt-button>\n\n              <div class=\"mb-3\">\n                <adapt-tag type=\"active\" *ngFor=\"let tag of preset.tags.items\">{{ tag }}</adapt-tag>\n\n                <button\n                  *ngIf=\"preset.tags.restCount\"\n                  class=\"btn-link rx-button-unstyled ml-1\"\n                  type=\"button\"\n                  (click)=\"openPresetColumnsModal(preset)\"\n                >\n                  +{{ preset.tags.restCount }} more\n                </button>\n              </div>\n\n              <rx-record-grid-sort-editor-control\n                class=\"d-block w-50\"\n                [options]=\"preset.sortEditorControlOptions\"\n                [disabled]=\"isReadOnly\"\n                [(ngModel)]=\"preset.sortModel\"\n                (ngModelChange)=\"onSortChange($event, preset)\"\n              ></rx-record-grid-sort-editor-control>\n\n              <rx-record-grid-filter-select-control\n                [options]=\"preset.filterSelectControlOptions\"\n                [disabled]=\"isReadOnly\"\n                [(ngModel)]=\"preset.filters\"\n                (ngModelChange)=\"markAsDirty()\"\n              ></rx-record-grid-filter-select-control>\n            </adapt-accordion-tab>\n          </div>\n        </adapt-accordion>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    *ngIf=\"!isReadOnly\"\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"!isDirty()\"\n    (click)=\"saveChanges()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{\n      isReadOnly\n        ? ('com.bmc.arsys.rx.client.common.close.label' | translate)\n        : ('com.bmc.arsys.rx.client.common.cancel.label' | translate)\n    }}\n  </button>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.designer-modal-body{height:645px;min-height:calc(100% - 61px)!important}.designer-modal-accordion-wrapper{display:flex;flex-direction:column;height:100%;overflow:auto;padding-top:10px}.designer-modal-accordion-content{position:relative}.designer-modal-accordion-content.cdk-drag-preview{z-index:1200!important}.designer-modal-drag-handle{cursor:move;position:absolute;top:0;left:0;height:46px;padding:14px 10px 14px 14px;z-index:1}.designer-modal-card-title-content{width:100%;display:flex}.designer-modal-card-title-content .left-header-block,.designer-modal-card-title-content .right-header-block{display:flex;align-items:center}.designer-modal-card-title-content .left-header-block{flex-grow:1;min-width:0;font-size:14px;padding-left:22px}.designer-modal-card-sub-title{color:#7c7f81;font-weight:normal}.designer-modal-card-title-index-buttons{display:flex;font-size:19px}.rx-card{overflow:auto}.rx-tree-draggable-node{cursor:pointer}.rx-tree-draggable-node.cdk-drag-preview{z-index:1200!important}.rx-tree-draggable-node.cdk-drag{opacity:1}.rx-tree-node-label{word-break:break-all}rx-form-builder{max-width:400px}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptAccordionComponent, selector: "adapt-accordion", inputs: ["config", "multiselect", "bordered"], outputs: ["openTab", "closeTab"] }, { type: i1.AdaptAccordionTabComponent, selector: "adapt-accordion-tab", inputs: ["title", "renderContentWhenClosed", "customClass", "multiline", "icon", "disabled", "isOpen"], outputs: ["open", "close"] }, { type: i1.AdaptTagComponent, selector: "adapt-tag", inputs: ["type", "removable", "disabled"], outputs: ["remove"] }, { type: RecordGridSortEditorControlComponent, selector: "rx-record-grid-sort-editor-control", inputs: ["options"] }, { type: RecordGridFilterSelectControlComponent, selector: "rx-record-grid-filter-select-control", inputs: ["options"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridEditViewPresetsModalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-edit-view-presets-modal',
                    templateUrl: './record-grid-edit-view-presets-modal.component.html',
                    styleUrls: ['./record-grid-edit-view-presets-modal.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i0.Injector }, { type: i1$6.RxModalService }, { type: RxRecordGridDesignUtilsService }, { type: RxRecordGridFilterSelectHelperService }, { type: RxRecordGridUtilsService }, { type: i2$1.RxStringService }]; } });

class RecordGridViewPresetsWidgetComponent extends InspectorWidgetBase {
    constructor(injector, rxModalService, viewDesignerFacade, rxGuidService, rxRecordGridDesignUtilsService, rxRecordGridFilterHelperService, rxJsonParserService) {
        super(injector);
        this.injector = injector;
        this.rxModalService = rxModalService;
        this.viewDesignerFacade = viewDesignerFacade;
        this.rxGuidService = rxGuidService;
        this.rxRecordGridDesignUtilsService = rxRecordGridDesignUtilsService;
        this.rxRecordGridFilterHelperService = rxRecordGridFilterHelperService;
        this.rxJsonParserService = rxJsonParserService;
        this.currentPresetSelectorGuid$ = new ReplaySubject(1);
        this.presetSelectors$ = this.viewDesignerFacade.getComponentsByType(RxViewComponentType.ViewPresetSelector);
        this.presetSelectorOptions$ = this.presetSelectors$.pipe(map((items) => items.map(({ guid, data }) => ({ id: guid, name: data.name }))));
        this.destroyed$ = new ReplaySubject(1);
        this.selectedPresetsList$ = this.currentPresetSelectorGuid$.pipe(tap((guid) => this.updateViewPresetSelectorProp(guid)), switchMap((guid) => this.rxRecordGridDesignUtilsService.getPresetsList(guid)), shareReplay({ refCount: true, bufferSize: 1 }), takeUntil(this.destroyed$));
        this.viewPresetSelectorProp$ = this.designerItemModel.sandbox.getComponentPropertyValue('viewPresetSelector');
        this.gridColumnGuids$ = this.designerItemModel.sandbox.getChildComponentGuids((component) => component.type === RX_RECORD_GRID.components.column);
        this.selectOptions = {
            options: [],
            emptyOption: true,
            label: 'View preset selector',
            beforeValueChange: (oldValue, newValue) => {
                if (oldValue && oldValue !== newValue) {
                    return this.rxModalService.confirm({
                        title: 'Warning',
                        modalStyle: RX_MODAL.modalStyles.warning,
                        message: 'All record grid view presets will be cleared. Do you want to continue?'
                    });
                }
                else {
                    return Promise.resolve(true);
                }
            }
        };
    }
    ngOnChanges(changes) {
        var _a, _b;
        if (((_a = changes.options.currentValue.recordDefinition) === null || _a === void 0 ? void 0 : _a.name) !== ((_b = changes.options.previousValue.recordDefinition) === null || _b === void 0 ? void 0 : _b.name)) {
            this.currentPresetSelectorGuid = null;
            this.currentPresetSelectorGuid$.next(null);
        }
    }
    ngOnInit() {
        this.presetSelectorOptions$.pipe(takeUntil(this.destroyed$)).subscribe((options) => {
            this.selectOptions.options = options;
        });
        // select current preset selector item
        this.viewPresetSelectorProp$
            .pipe(first(), map((val) => this.designerItemModel.extractViewPresetSelectorGuid(val)), withLatestFrom(this.presetSelectorOptions$), takeUntil(this.destroyed$))
            .subscribe(([guid, presetSelectorOptions]) => {
            var _a;
            const selectedOption = (_a = presetSelectorOptions.find((item) => item.id === guid)) === null || _a === void 0 ? void 0 : _a.id;
            if (selectedOption) {
                this.currentPresetSelectorGuid = selectedOption;
                this.currentPresetSelectorGuid$.next(this.currentPresetSelectorGuid);
            }
        });
        this.gridColumnGuids$
            .pipe(filter(() => !!this.currentPresetSelectorGuid), switchMap((guids) => combineLatest(guids.map((guid) => combineLatest([
            this.designerItemModel.sandbox.getComponentPropertyValue('sortable', guid),
            this.designerItemModel.sandbox.getComponentPropertyValue('filterable', guid),
            this.viewDesignerFacade.getChildComponents(guid, (c) => c.type === RX_RECORD_GRID.components.filterPreset)
        ])))), distinctUntilChanged(isEqual), 
        // in case of removing and adding columns at a same time from columns modal
        // stream updated several times with according to adding/removing columns
        // we need it to be stabilized to proceed with column presets updating
        debounceTime(100), switchMap(() => this.designerItemModel.columns$.pipe(first())), withLatestFrom(this.designerItemModel.childComponentsTree$.pipe(map((components) => cloneDeep(components)))), skip(1), takeUntil(this.destroyed$))
            .subscribe(([gridColumns, allComponents]) => {
            this.updateColumnPresets(allComponents, gridColumns);
        });
    }
    updateColumnPresets(allComponents, gridColumns) {
        const viewPresetsPayload = allComponents
            .filter((component) => component.type === RX_RECORD_GRID.components.viewPreset)
            .map((component) => {
            const presetColumnComponents = component.children.filter((item) => item.type === RX_RECORD_GRID.components.columnViewPreset);
            const presetFilterComponents = this.getPresetFilterComponentsForColumns(component, gridColumns);
            const updatedPresetColumns = gridColumns
                .map((gridColumn) => {
                const existingPresetColumn = presetColumnComponents.find((presetColumn) => presetColumn.data.fieldId === gridColumn.fieldId);
                if (existingPresetColumn) {
                    if (!gridColumn.sortable) {
                        existingPresetColumn.data.sortable = null;
                    }
                    return existingPresetColumn;
                }
                else {
                    const columnPresetPayload = this.rxRecordGridDesignUtilsService.getColumnPresetPayload(gridColumn);
                    columnPresetPayload.data.visible = false;
                    columnPresetPayload.data.index = null;
                    columnPresetPayload.data.width = null;
                    return columnPresetPayload;
                }
            })
                .map((presetCol, i, array) => {
                if (presetCol.data.index === null) {
                    presetCol.data.index = Math.max(...array.map((col) => col.data.index)) + 1;
                }
                return presetCol;
            });
            component.children = [...updatedPresetColumns, ...presetFilterComponents];
            return component;
        });
        this.designerItemModel.sandbox.setChildrenByType(viewPresetsPayload, [RX_RECORD_GRID.components.viewPreset]);
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
    getPresetFilterComponentsForColumns(presetComponent, gridColumns) {
        const gridColumnsIds = gridColumns.filter((col) => col.filterable).map((col) => col.fieldId);
        const presetFilterComponents = presetComponent.children.filter((item) => item.type !== RX_RECORD_GRID.components.columnViewPreset);
        // removing filter presets for removed columns or ones that have removed named filter option reference
        const filteredPresetFilterComponents = presetFilterComponents.reduce((result, presetFilterComponent) => {
            var _a, _b, _c;
            // checking if column still can be used for filtering
            if (gridColumnsIds.includes(presetFilterComponent.data.fieldId)) {
                const namedFilterOptions = (_b = (_a = gridColumns.find((col) => col.fieldId === presetFilterComponent.data.fieldId)) === null || _a === void 0 ? void 0 : _a.namedFilterOptions) !== null && _b !== void 0 ? _b : [];
                const namedFilterOptionsGuids = namedFilterOptions.map((option) => option.guid);
                let presetFiltersObj = this.rxRecordGridDesignUtilsService.getBasicRecordGridFiltersFromChildData([
                    presetFilterComponent
                ]);
                presetFiltersObj = this.deserializeNamedOptions(presetFiltersObj);
                const namedFilterOptionGuid = (_c = presetFiltersObj[0].value) === null || _c === void 0 ? void 0 : _c[RecordGridNamedFilterOptionKey];
                // if named filter option selected then check if it's still available
                if (namedFilterOptionGuid) {
                    if (namedFilterOptionsGuids.includes(namedFilterOptionGuid)) {
                        result.push(presetFilterComponent);
                    }
                }
                else {
                    result.push(presetFilterComponent);
                }
            }
            return result;
        }, []);
        if (presetFilterComponents.length) {
            if (filteredPresetFilterComponents.length < presetFilterComponents.length) {
                const presetFilters = this.rxRecordGridDesignUtilsService.getBasicRecordGridFiltersFromChildData(filteredPresetFilterComponents);
                const newFilterData = this.rxRecordGridFilterHelperService.getRecordGridFilterDataFromPredefinedFilter(presetComponent.data.filters, presetFilters);
                // updating filters JSON after column remove
                presetComponent.data.filters = newFilterData
                    ? this.rxRecordGridFilterHelperService.denormalizeFilterString(JSON.stringify(newFilterData), presetFilters)
                    : null;
            }
            return filteredPresetFilterComponents;
        }
        return presetFilterComponents;
    }
    deserializeNamedOptions(recordGridFilters) {
        return recordGridFilters.map((filter) => {
            const value = this.rxJsonParserService.tryParseJson(filter.value);
            if (value && value[RecordGridNamedFilterOptionKey]) {
                return Object.assign(Object.assign({}, filter), { value });
            }
            return filter;
        });
    }
    openEditor(preset) {
        combineLatest([
            this.designerItemModel.gridViewPresets$,
            this.selectedPresetsList$,
            this.designerItemModel.columns$,
            this.designerItemModel.recordDefinition$
        ])
            .pipe(first(), takeUntil(this.destroyed$))
            .subscribe(([viewPresets, presetsList, columns, recordDefinition]) => {
            this.rxModalService
                .openModal({
                title: 'Edit view presets',
                content: RecordGridEditViewPresetsModalComponent,
                size: OpenViewActionModalSize.Large,
                data: {
                    viewPresets,
                    presetsList,
                    gridColumns: columns,
                    recordDefinition,
                    activePreset: preset === null || preset === void 0 ? void 0 : preset.guid,
                    isReadOnly: this.isDisabled
                }
            })
                .then((result) => {
                this.onPresetModalClose(result);
            })
                .catch(noop);
        });
    }
    trackByGuid(index, item) {
        return item.name;
    }
    onPresetModalClose(result) {
        if (result && result.presets) {
            this.designerItemModel.childComponentsTree$
                .pipe(first(), map((components) => cloneDeep(components)), takeUntil(this.destroyed$))
                .subscribe((components) => {
                result.presets.forEach((preset) => {
                    const presetComponent = components.find((c) => c.type === RX_RECORD_GRID.components.viewPreset && c.data.viewPresetGuid === preset.guid);
                    if (presetComponent) {
                        const columnPayloads = preset.presetColumns.map((column) => this.rxRecordGridDesignUtilsService.getColumnPresetPayload(column.data));
                        const filterPayloads = this.rxRecordGridDesignUtilsService.getGridFilterComponentPayloads(preset.filters.basicFilters);
                        presetComponent.data = {
                            viewPresetGuid: preset.guid,
                            filters: preset.filters.filtersJson
                        };
                        presetComponent.children = [...columnPayloads, ...filterPayloads];
                    }
                });
                this.designerItemModel.sandbox.setChildren(components);
            });
        }
    }
    updateViewPresetSelectorProp(guid) {
        this.designerItemModel.sandbox.updateComponentProperties({
            viewPresetSelector: guid ? `\${view.components.${guid}.api}` : null
        });
    }
}
RecordGridViewPresetsWidgetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetsWidgetComponent, deps: [{ token: i0.Injector }, { token: i1$6.RxModalService }, { token: i1$3.ViewDesignerFacade }, { token: i2$1.RxGuidService }, { token: RxRecordGridDesignUtilsService }, { token: RxRecordGridFilterHelperService }, { token: i2$1.RxJsonParserService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridViewPresetsWidgetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridViewPresetsWidgetComponent, selector: "rx-record-grid-view-presets-widget", inputs: { options: "options" }, usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<rx-select-form-control\n  class=\"d-block mb-3\"\n  rx-id=\"preset-selector\"\n  [options]=\"selectOptions\"\n  [(ngModel)]=\"currentPresetSelectorGuid\"\n  (ngModelChange)=\"currentPresetSelectorGuid$.next($event)\"\n  [disabled]=\"isDisabled\"\n>\n</rx-select-form-control>\n\n<div [hidden]=\"!options.recordDefinition\" *ngIf=\"selectedPresetsList$ | async as presetsList\">\n  <adapt-button\n    *ngIf=\"presetsList.length\"\n    btn-type=\"tertiary\"\n    rx-id=\"edit-view-presets-button\"\n    class=\"p-0 pb-1\"\n    (click)=\"openEditor()\"\n  >\n    <span class=\"d-icon-left-plus_circle\"></span>\n    Edit view presets\n  </adapt-button>\n\n  <span rx-id=\"no-presets\" *ngIf=\"currentPresetSelectorGuid && presetsList.length === 0\" class=\"text-tertiary\">\n    No presets added.\n  </span>\n\n  <div rx-id=\"presets-list\">\n    <div\n      class=\"border mb-1 pr-2 d-flex justify-content-between text-break\"\n      *ngFor=\"let preset of presetsList; let index = index; trackBy: trackByGuid\"\n    >\n      <strong class=\"preset-name\" rx-id=\"preset-name\" [title]=\"preset.name\">\n        {{ preset.name }}\n      </strong>\n\n      <button\n        type=\"button\"\n        class=\"rx-button-unstyled d-icon-pencil btn-link\"\n        rx-id=\"edit-button\"\n        (click)=\"openEditor(preset)\"\n      ></button>\n    </div>\n  </div>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.preset-name{padding:5px 10px;font-size:14px}.d-icon-pencil{cursor:pointer}.d-icon-pencil:not(:hover){color:#313538}\n"], components: [{ type: i2$5.SelectFormControlComponent, selector: "rx-select-form-control", inputs: ["options", "appendToBody", "formControl"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetsWidgetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-view-presets-widget',
                    templateUrl: './record-grid-view-presets-widget.component.html',
                    styleUrls: ['./record-grid-view-presets-widget.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$6.RxModalService }, { type: i1$3.ViewDesignerFacade }, { type: i2$1.RxGuidService }, { type: RxRecordGridDesignUtilsService }, { type: RxRecordGridFilterHelperService }, { type: i2$1.RxJsonParserService }]; }, propDecorators: { options: [{
                type: Input
            }] } });

class RxRecordGridDesignUtilsService {
    constructor(rxGuidService, rxRecordGridConfigUtilsService, rxDefinitionNameService, rxFeatureService, rxModalService, rxRecordGridUtilsService, rxRecordGridFilterHelperService, translateService, viewDesignerFacade, rxJsonParserService) {
        this.rxGuidService = rxGuidService;
        this.rxRecordGridConfigUtilsService = rxRecordGridConfigUtilsService;
        this.rxDefinitionNameService = rxDefinitionNameService;
        this.rxFeatureService = rxFeatureService;
        this.rxModalService = rxModalService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxRecordGridFilterHelperService = rxRecordGridFilterHelperService;
        this.translateService = translateService;
        this.viewDesignerFacade = viewDesignerFacade;
        this.rxJsonParserService = rxJsonParserService;
    }
    getColumnActionComponentPayloads(actions) {
        return map$1(actions, (action) => (Object.assign(Object.assign({}, action), { type: RxViewComponentType.Action })));
    }
    getNamedFilterOptionPayloads(namedFilterOptions) {
        return map$1(namedFilterOptions, (namedFilterOption) => (Object.assign(Object.assign({}, namedFilterOption), { type: RX_RECORD_GRID.components.filterPreset })));
    }
    getGridFilterComponentPayloads(gridFilters) {
        return map$1(gridFilters, (gridFilter) => ({
            guid: gridFilter.guid,
            type: RX_RECORD_GRID.components.filter,
            data: Object.assign({ fieldId: gridFilter.fieldId, value: gridFilter.value }, (gridFilter.$DISPLAYVALUE$ && { $DISPLAYVALUE$: gridFilter.$DISPLAYVALUE$ }))
        }));
    }
    getColumnComponentPayloads(columns, initialSortColumn) {
        return map$1(columns, (inspectorColumn, index) => {
            let sortable = 'false';
            if ((initialSortColumn === null || initialSortColumn === void 0 ? void 0 : initialSortColumn.fieldId) === inspectorColumn.fieldId && inspectorColumn.sortable !== false) {
                sortable = JSON.stringify({
                    direction: initialSortColumn.direction
                });
            }
            else if (isObject(inspectorColumn.sortable) || inspectorColumn.sortable === true) {
                sortable = 'true';
            }
            const columnDesignModel = {
                alignment: inspectorColumn.alignment,
                fieldId: inspectorColumn.fieldId,
                filterable: inspectorColumn.filterable,
                filterType: inspectorColumn.filterType,
                index: String(inspectorColumn.index),
                sortable,
                title: inspectorColumn.title,
                searchable: inspectorColumn.searchable,
                visible: inspectorColumn.visible,
                cellDisplayProperties: inspectorColumn.cellDisplayProperties,
                width: inspectorColumn.width,
                wrapText: inspectorColumn.wrapText,
                typeaheadKeystrokeCount: inspectorColumn.typeaheadKeystrokeCount,
                additionalQueryCriteria: inspectorColumn.additionalQueryCriteria
            };
            return {
                type: RX_RECORD_GRID.components.column,
                guid: inspectorColumn.guid,
                insertIndex: index,
                outletName: RX_VIEW_DEFINITION.defaultOutletName,
                data: columnDesignModel,
                children: [
                    ...this.getColumnActionComponentPayloads(inspectorColumn.actions),
                    ...this.getNamedFilterOptionPayloads(inspectorColumn.namedFilterOptions)
                ]
            };
        });
    }
    getGridFilterPresetComponentPayloads(filterPresets, columns) {
        const namedFilterGuids = columns.reduce((result, column) => result.concat(...column.namedFilterOptions.map((namedFilter) => namedFilter.guid)), []);
        const selectedFieldIds = columns.map((column) => column.fieldId);
        return map$1(filterPresets, (filterPreset) => {
            const newRecordGridFilters = filterPreset.recordGridFilters
                .filter((filter) => selectedFieldIds.includes(filter.fieldId))
                .filter((filter) => {
                const value = isObject(filter.value) ? filter.value : this.rxJsonParserService.tryParseJson(filter.value);
                return (!(value === null || value === void 0 ? void 0 : value[RecordGridNamedFilterOptionKey]) ||
                    namedFilterGuids.includes(value[RecordGridNamedFilterOptionKey]));
            });
            const newFilterData = this.rxRecordGridFilterHelperService.getRecordGridFilterDataFromPredefinedFilter(filterPreset.filters, newRecordGridFilters);
            return {
                guid: filterPreset.guid,
                type: RX_RECORD_GRID.components.filterPreset,
                data: {
                    title: filterPreset.title,
                    filters: newFilterData
                        ? this.rxRecordGridFilterHelperService.denormalizeFilterString(JSON.stringify(newFilterData), newRecordGridFilters)
                        : null
                },
                children: map$1(newRecordGridFilters, (recordGridFilter) => ({
                    guid: recordGridFilter.guid,
                    type: RX_RECORD_GRID.components.filter,
                    data: Object.assign({ fieldId: recordGridFilter.fieldId, value: recordGridFilter.value }, (recordGridFilter.$DISPLAYVALUE$ && { $DISPLAYVALUE$: recordGridFilter.$DISPLAYVALUE$ }))
                }))
            };
        });
    }
    getFilterPresetDescriptorsFromChildData(definitions) {
        return map$1(definitions.filter((definition) => definition.type === RX_RECORD_GRID.components.filterPreset), (filterPresetsDescriptor) => ({
            filters: filterPresetsDescriptor.data.filters,
            recordGridFilters: map$1(filter$1(filterPresetsDescriptor.children, (definition) => definition.type === RX_RECORD_GRID.components.filter), (presetFilter) => ({
                fieldId: presetFilter.data.fieldId,
                value: presetFilter.data.value,
                guid: presetFilter.guid,
                $DISPLAYVALUE$: presetFilter.data.$DISPLAYVALUE$
            })),
            title: filterPresetsDescriptor.data.title,
            guid: filterPresetsDescriptor.guid
        })).filter((filterPreset) => { var _a; return ((_a = filterPreset.recordGridFilters) === null || _a === void 0 ? void 0 : _a.length) > 0; });
    }
    getActionsFromComponent(componentDesignData) {
        return map$1(filter$1(componentDesignData.children, (definition) => definition.type === RxViewComponentType.Action), (columnAction) => (Object.assign(Object.assign({}, columnAction), { data: Object.assign({}, columnAction.data) })));
    }
    getNamedFilterOptionsFromComponent(componentDesignData) {
        return componentDesignData.children
            .filter((definition) => definition.type === RX_RECORD_GRID.components.filterPreset)
            .map((namedFilterOptionData) => (Object.assign(Object.assign({}, namedFilterOptionData), { data: Object.assign({}, namedFilterOptionData.data) })));
    }
    getDefaultColumns(recordDefinition) {
        let columns = [];
        if (recordDefinition) {
            const fieldDefinitions = recordDefinition.fieldDefinitions;
            const coreFieldIds = RX_RECORD_DEFINITION.coreFieldIds;
            columns = [
                {
                    title: find(fieldDefinitions, (fieldDefinition) => fieldDefinition.id === coreFieldIds.displayId).name,
                    fieldId: String(coreFieldIds.displayId),
                    searchable: true
                }
            ];
            if (recordDefinition.resourceType === RX_RECORD_DEFINITION.recordDefinitionTypes.regular.recordDefinitionType) {
                columns.push({
                    title: find(fieldDefinitions, (fieldDefinition) => fieldDefinition.id === coreFieldIds.modifiedDate).name,
                    fieldId: String(coreFieldIds.modifiedDate),
                    searchable: false
                });
                columns.push({
                    title: find(fieldDefinitions, (fieldDefinition) => fieldDefinition.id === coreFieldIds.description).name,
                    fieldId: String(coreFieldIds.description),
                    searchable: true
                });
            }
            const defaultValues = reduce(RX_RECORD_GRID.columnProperties, (result, columnProperty) => {
                result[columnProperty.name] = columnProperty.defaultValue;
                return result;
            }, {});
            forEach(columns, (column, index) => defaults(column, defaultValues, {
                index,
                guid: this.rxGuidService.generate()
            }));
        }
        return columns;
    }
    getInitialSortColumnModel(columns) {
        const selectedSortColumn = find(columns, (column) => isObject(column.sortable));
        return selectedSortColumn
            ? {
                direction: selectedSortColumn.sortable.direction,
                fieldId: selectedSortColumn.fieldId
            }
            : null;
    }
    getInspectorColumnsFromDesignData(columnsDesignModel) {
        return columnsDesignModel.map((columnDescriptor) => {
            const column = columnDescriptor.data;
            return Object.assign(Object.assign({}, pick(column, [
                'alignment',
                'fieldId',
                'filterType',
                'searchable',
                'title',
                'cellDisplayProperties',
                'width',
                'typeaheadKeystrokeCount',
                'additionalQueryCriteria'
            ])), { actions: this.getActionsFromComponent(columnDescriptor), namedFilterOptions: this.getNamedFilterOptionsFromComponent(columnDescriptor), guid: columnDescriptor.guid, filterable: this.rxRecordGridConfigUtilsService.getBooleanValue(column.filterable) || isUndefined(column.filterable), sortable: this.rxRecordGridConfigUtilsService.parseConfigString(column.sortable) ||
                    isUndefined(column.sortable), visible: this.rxRecordGridConfigUtilsService.getBooleanValue(column.visible) || isUndefined(column.visible), wrapText: this.rxRecordGridConfigUtilsService.getBooleanValue(column.wrapText), index: Number(column.index) });
        });
    }
    getComponentProperties(componentDesignProperties) {
        var _a, _b, _c;
        return {
            bordered: (_a = componentDesignProperties.bordered) !== null && _a !== void 0 ? _a : true,
            expandable: componentDesignProperties.expandable,
            name: componentDesignProperties.name,
            recordDefinitionName: componentDesignProperties.recordDefinitionName,
            showDataForAllLocales: componentDesignProperties.showDataForAllLocales,
            associationDefinitionName: componentDesignProperties.associationDefinitionName,
            associatedRecordNodeSide: componentDesignProperties.associatedRecordNodeSide,
            associatedRecordId: componentDesignProperties.associatedRecordId,
            associatedRoleName: componentDesignProperties.associatedRoleName,
            filterExpression: componentDesignProperties.filterExpression,
            filters: isObject(componentDesignProperties.filters)
                ? componentDesignProperties.filters.filtersJson
                : componentDesignProperties.filters,
            defaultFilterPreset: this.getDefaultFilterPreset(componentDesignProperties),
            cardLayoutWidth: componentDesignProperties.cardLayoutWidth,
            enableFiltering: componentDesignProperties.enableFiltering,
            requiredFilters: (_b = componentDesignProperties.requiredFilters) !== null && _b !== void 0 ? _b : 0,
            getDataForHiddenColumns: (_c = componentDesignProperties.getDataForHiddenColumns) !== null && _c !== void 0 ? _c : true,
            enableFilterPresets: componentDesignProperties.enableFilterPresets,
            enableRowSelection: componentDesignProperties.enableRowSelection,
            styles: componentDesignProperties.styles,
            striped: !!componentDesignProperties.striped,
            viewPresetSelector: componentDesignProperties.viewPresetSelector,
            [RX_AVAILABLE_ON_DEVICES_PROP_NAME]: componentDesignProperties[RX_AVAILABLE_ON_DEVICES_PROP_NAME]
        };
    }
    getDefaultFilterPreset(componentDesignProperties) {
        if (componentDesignProperties.defaultFilterPreset && componentDesignProperties.filterPresets) {
            return componentDesignProperties.filterPresets.some((filterPreset) => filterPreset.guid === componentDesignProperties.defaultFilterPreset)
                ? componentDesignProperties.defaultFilterPreset
                : null;
        }
        else if (componentDesignProperties.defaultFilterPreset && !componentDesignProperties.filterPresets) {
            return componentDesignProperties.defaultFilterPreset;
        }
        return null;
    }
    getComponentDesignProperties(componentProperties, initialComponentProperties, columnsDesignModel, basicRecordGridFilters, filterPresets) {
        const columns = this.getInspectorColumnsFromDesignData(columnsDesignModel);
        componentProperties = Object.assign(Object.assign({}, initialComponentProperties), componentProperties);
        return Object.assign(Object.assign({}, componentProperties), { mode: componentProperties.associationDefinitionName
                ? RecordGridDesignDefinitionMode.Association
                : RecordGridDesignDefinitionMode.Record, filters: {
                basicFilters: basicRecordGridFilters,
                filtersJson: componentProperties.filters
            }, filterMode: componentProperties.filterExpression ? RecordGridFilterMode.Expression : RecordGridFilterMode.Basic, filterPresets, initialSortColumn: this.getInitialSortColumnModel(columns), columns });
    }
    getActionButtonDescriptorsFromChildData(definitions) {
        return definitions.filter((definition) => definition.type === RxViewComponentType.ActionButton);
    }
    getGridViewPresetsFromChildData(definitions) {
        return definitions.filter((definition) => definition.type === RX_RECORD_GRID.components.viewPreset);
    }
    getBasicRecordGridFiltersFromChildData(definitions) {
        return map$1(definitions.filter((definition) => definition.type === RX_RECORD_GRID.components.filter), (basicFilterDescriptor) => ({
            fieldId: basicFilterDescriptor.data.fieldId,
            value: basicFilterDescriptor.data.value,
            guid: basicFilterDescriptor.guid,
            $DISPLAYVALUE$: basicFilterDescriptor.data.$DISPLAYVALUE$
        }));
    }
    getRowActionButtonPayloads(rowActions) {
        return rowActions.map((rowAction) => ({
            type: RxViewComponentType.ActionButton,
            guid: rowAction.guid,
            data: omit(rowAction, 'actions', 'guid'),
            outletName: RX_RECORD_GRID.rowActionsOutletName,
            children: this.getColumnActionComponentPayloads(rowAction.actions)
        }));
    }
    getInspector(model, recordDefinition, recordAssociationDefinitions) {
        const hasRecordDefinition = Boolean(model.recordDefinitionName && recordDefinition);
        const generalControls = [
            {
                name: 'name',
                component: TextFormControlComponent,
                options: {
                    label: 'Name',
                    tooltip: new Tooltip('Enter a name to uniquely identify the Record grid.')
                }
            },
            {
                name: 'mode',
                component: GroupButtonFormControlComponent,
                options: {
                    required: false,
                    label: 'Mode',
                    items: [
                        {
                            value: RecordGridDesignDefinitionMode.Record,
                            name: 'Record'
                        },
                        {
                            value: RecordGridDesignDefinitionMode.Association,
                            name: 'Association'
                        }
                    ]
                }
            },
            {
                name: 'recordDefinitionName',
                component: RxDefinitionPickerComponent,
                options: {
                    label: model.mode === RecordGridDesignDefinitionMode.Association
                        ? 'Record definition to show'
                        : 'Record definition name',
                    definitionType: model.mode === RecordGridDesignDefinitionMode.Association
                        ? RxDefinitionPickerType.RegularDataRecord
                        : RxDefinitionPickerType.Record,
                    required: true,
                    beforeValueChange: (oldValue, newValue) => {
                        if (!isEmpty(model.columns) && Boolean(oldValue)) {
                            return this.rxModalService.confirm({
                                title: 'Warning',
                                modalStyle: RX_MODAL.modalStyles.warning,
                                message: 'Initial column sort, initial filters, and added grid columns will be cleared. Do you want to continue?'
                            });
                        }
                        else {
                            return Promise.resolve(true);
                        }
                    }
                }
            }
        ];
        const presentationControls = [
            {
                name: 'cardLayoutWidth',
                component: SelectFormControlComponent,
                options: {
                    label: 'Card layout width',
                    sortAlphabetically: false,
                    options: RX_RECORD_GRID.cardLayoutWidthOptions,
                    emptyOption: true,
                    tooltip: new Tooltip('The width of the Record grid view component at which it will switch to card layout.')
                }
            },
            {
                name: 'initialSortColumn',
                component: RecordGridSortEditorControlComponent,
                options: {
                    label: 'Initial column sort',
                    gridColumns: sortBy(model.columns, 'title'),
                    recordDefinition
                }
            },
            {
                name: 'enableRowSelection',
                component: OptionalSelectFormControlComponent,
                options: {
                    label: 'Enable row selection',
                    options: [
                        {
                            id: RX_RECORD_GRID.selectionTypes.multiple,
                            name: 'Multiple rows'
                        },
                        {
                            id: RX_RECORD_GRID.selectionTypes.single,
                            name: 'Single row'
                        }
                    ]
                }
            },
            {
                name: 'expandable',
                component: SwitchFormControlComponent,
                hidden: !this.rxFeatureService.isFeatureEnabled('DRD21-44922'),
                options: {
                    label: 'Enable grid width expansion',
                    tooltip: new Tooltip('If enabled, the grid will expand in width to accommodate wider columns. If one or more columns extend beyond the right border of the grid, a horizontal scroll bar will appear.<br>Column width will be converted to pixels if grid width expansion mode is enabled.')
                }
            },
            {
                name: 'bordered',
                component: SwitchFormControlComponent,
                options: {
                    label: 'Show border lines'
                }
            },
            {
                name: 'striped',
                component: SwitchFormControlComponent,
                options: {
                    label: 'Show striped rows'
                }
            },
            {
                name: 'showDataForAllLocales',
                component: SwitchFormControlComponent,
                options: {
                    label: 'Show data for all locales',
                    tooltip: new Tooltip('If enabled, data for all locales will be displayed in the grid at runtime. If disabled, only data for current locale will be displayed.')
                }
            },
            getAvailableOnDevicesInspectorConfig(),
            getStylesFieldInspectorConfig()
        ];
        if (model.mode === RecordGridDesignDefinitionMode.Association) {
            if (hasRecordDefinition) {
                generalControls.push({
                    name: 'associationDefinitionName',
                    component: SelectFormControlComponent,
                    options: {
                        required: true,
                        label: 'Association to use',
                        options: map$1(recordAssociationDefinitions, (associationDescriptor) => ({
                            id: associationDescriptor.name,
                            name: this.rxDefinitionNameService.getDisplayName(associationDescriptor.name)
                        })),
                        emptyOption: true
                    }
                });
            }
            const selectedAssociationDefinition = find(recordAssociationDefinitions, (definition) => definition.name === model.associationDefinitionName);
            if (selectedAssociationDefinition &&
                selectedAssociationDefinition.nodeAId === selectedAssociationDefinition.nodeBId) {
                generalControls.push({
                    name: 'associatedRecordNodeSide',
                    component: SelectFormControlComponent,
                    options: {
                        required: true,
                        label: 'Associated record node side',
                        options: [
                            {
                                id: RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA.value,
                                name: selectedAssociationDefinition.nodeAName || RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA.defaultName
                            },
                            {
                                id: RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value,
                                name: selectedAssociationDefinition.nodeBName || RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.defaultName
                            }
                        ],
                        emptyOption: true
                    }
                });
            }
            generalControls.push({
                name: 'associatedRecordId',
                component: ExpressionInspectorControlComponent,
                options: {
                    label: 'Associated record ID',
                    isRequired: true
                }
            });
            if (selectedAssociationDefinition &&
                selectedAssociationDefinition.cardinality === RX_ASSOCIATION_DEFINITION.cardinality.manyToMany.value) {
                generalControls.push({
                    name: 'associatedRoleName',
                    component: ExpressionInspectorControlComponent,
                    options: {
                        label: 'Associated role name'
                    }
                });
            }
        }
        if (hasRecordDefinition) {
            generalControls.push({
                name: 'columns',
                component: RecordGridColumnEditorControlComponent,
                options: {
                    recordDefinition
                }
            });
            generalControls.push({
                name: 'getDataForHiddenColumns',
                component: SwitchFormControlComponent,
                options: {
                    label: 'Get data for hidden columns',
                    tooltip: new Tooltip(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.get-data-for-hidden-columns.tooltip'))
                }
            });
            generalControls.push({
                widgetName: 'rowActions',
                component: RxRecordGridRowActionEditorWidgetComponent
            });
        }
        const filtersControls = [
            {
                name: 'enableFiltering',
                component: SwitchFormControlComponent,
                options: {
                    label: 'Enable filtering'
                }
            },
            {
                name: 'requiredFilters',
                component: SelectFormControlComponent,
                isDisabled: !model.enableFiltering,
                options: {
                    label: 'Required number of filters',
                    sortAlphabetically: false,
                    options: RX_RECORD_GRID.numberOfFiltersOptions,
                    emptyOption: false,
                    tooltip: new Tooltip('Data will be displayed in the grid only if a) the number of applied filters is greater than or equal to the required number of filters, or b) a search is performed.')
                }
            }
        ];
        if (hasRecordDefinition) {
            filtersControls.push({
                name: 'filterMode',
                component: GroupButtonFormControlComponent,
                options: {
                    label: 'Initial filters',
                    items: [
                        {
                            name: 'Basic',
                            value: RecordGridFilterMode.Basic
                        },
                        {
                            name: 'Expression',
                            value: RecordGridFilterMode.Expression
                        }
                    ],
                    tooltip: new Tooltip('Select the records that should be displayed on the deployed application UI. Application users can add filters in the deployed application.'),
                    beforeValueChange: (oldValue, newValue) => {
                        if ((newValue === RecordGridFilterMode.Expression && model.filters.filtersJson) ||
                            (newValue === RecordGridFilterMode.Basic && model.filterExpression)) {
                            return this.rxModalService.confirm({
                                title: 'Change filter type',
                                modalStyle: RX_MODAL.modalStyles.warning,
                                message: 'Current filter will be cleared. Do you want to continue?'
                            });
                        }
                        else {
                            return Promise.resolve(true);
                        }
                    }
                }
            });
            if (model.filterMode === RecordGridFilterMode.Basic) {
                filtersControls.push({
                    name: 'filters',
                    component: RecordGridFilterSelectControlComponent,
                    options: {
                        primaryRecordDefinition: recordDefinition
                    }
                });
            }
            else {
                filtersControls.push({
                    name: 'filterExpression',
                    component: ExpressionInspectorControlComponent,
                    options: {
                        label: 'Initial filters',
                        isLabelHidden: true
                    }
                });
            }
            filtersControls.push({
                name: 'enableFilterPresets',
                component: SwitchFormControlComponent,
                isDisabled: !model.enableFiltering,
                options: {
                    label: 'Enable filter presets'
                }
            });
            filtersControls.push({
                name: 'filterPresets',
                component: RecordGridFilterPresetEditorControlComponent,
                options: {
                    label: 'Filter presets',
                    tooltip: new Tooltip('Predefine sets of record grid filters users can apply.'),
                    primaryRecordDefinition: recordDefinition,
                    columns: model.columns.filter((column) => column.filterable)
                }
            });
        }
        if (!isEmpty(model.filterPresets)) {
            filtersControls.push({
                name: 'defaultFilterPreset',
                component: SelectFormControlComponent,
                options: {
                    label: 'Default filter preset',
                    tooltip: new Tooltip('Select a filter preset to be applied when a user opens this view for the first time.'),
                    options: map$1(model.filterPresets, (filterPreset) => ({ id: filterPreset.guid, name: filterPreset.title })),
                    emptyOption: true
                }
            });
        }
        const inspectorSectionConfigs = [
            {
                label: 'General',
                controls: generalControls
            },
            {
                label: 'Filters',
                controls: filtersControls
            },
            {
                label: 'Presentation',
                controls: presentationControls
            },
            {
                label: 'View presets',
                controls: [
                    {
                        component: RecordGridViewPresetsWidgetComponent,
                        options: {
                            recordDefinition: recordDefinition
                        }
                    }
                ]
            }
        ];
        return { inspectorSectionConfigs };
    }
    getColumnDataDictionaryBranch(recordGridGuid, componentDescriptorName, componentName$, columnComponents$, recordDefinition$, associationDefinitionDisplayName$) {
        const columnDataDictionaryBranch$ = combineLatest([columnComponents$, recordDefinition$]).pipe(switchMap(([columnComponents, recordDefinition]) => recordDefinition
            ? this.getColumnsDataDictionaryBuilder(recordGridGuid, columnComponents, recordDefinition).pipe(map((buildColumnDataDictionary) => ({
                label: this.rxDefinitionNameService.getDisplayName(recordDefinition.name),
                expression: `\${view.components.${recordGridGuid}.api}`,
                children: [
                    {
                        label: 'First selected row',
                        expression: `\${view.components.${recordGridGuid}.firstSelectedRow}`,
                        children: buildColumnDataDictionary('firstSelectedRow')
                    },
                    {
                        label: 'Is user allowed to delete records',
                        expression: `\${view.components.${recordGridGuid}.isUserAllowedToDeleteRecords}`
                    },
                    {
                        label: 'Last action row',
                        expression: `\${view.components.${recordGridGuid}.clickableRow}`,
                        children: buildColumnDataDictionary('clickableRow')
                    },
                    {
                        label: 'Selected rows',
                        expression: `\${view.components.${recordGridGuid}.selectedRows}`,
                        children: buildColumnDataDictionary('fieldValuesByFieldId')
                    },
                    {
                        label: 'Selected row count',
                        expression: `\${view.components.${recordGridGuid}.selectedRowCount}`
                    },
                    {
                        label: 'Total row count',
                        expression: `\${view.components.${recordGridGuid}.totalRowCount}`
                    },
                    {
                        label: 'Query expression',
                        expression: `\${view.components.${recordGridGuid}.queryExpression}`
                    },
                    {
                        label: 'Last refresh time',
                        expression: `\${view.components.${recordGridGuid}.lastRefreshTime}`
                    }
                ]
            })), take(1))
            : of(null)));
        return combineLatest([componentName$, columnDataDictionaryBranch$, associationDefinitionDisplayName$]).pipe(map(([label, dataDictionaryBranch, associationDefinitionDisplayName]) => dataDictionaryBranch
            ? Object.assign(Object.assign({}, dataDictionaryBranch), { label: this.getComponentName(componentDescriptorName, dataDictionaryBranch.label, associationDefinitionDisplayName, label) })
            : null));
    }
    getColumnsDataDictionaryBuilder(recordGridGuid, columnComponents, recordDefinition) {
        return (columnComponents.length
            ? forkJoin(columnComponents.map((component) => this.rxRecordGridUtilsService.getFieldDefinition(component.data.fieldId, recordDefinition).pipe(filter((fieldDefinition) => !!fieldDefinition), map((fieldDefinition) => this.getColumnDataDictionaryBranchBuilder(recordGridGuid, component, fieldDefinition)))))
            : of([])).pipe(map((builders) => (gridPropertyName) => builders.map((buildColumnDataDictionaryBranch) => buildColumnDataDictionaryBranch.call(this, gridPropertyName))));
    }
    getColumnDataDictionaryBranchBuilder(recordGridGuid, columnComponent, fieldDefinition) {
        const selectionList = fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.selection
            ? map$1(fieldDefinition.optionNamesById, (optionName, optionValue) => ({
                label: optionName,
                expression: `\${view.components.${recordGridGuid}.recordDefinition.fieldDefinitionsById[${columnComponent.data.fieldId}].optionsById[${optionValue}].id}`
            }))
            : undefined;
        return (propertyName) => {
            var _a;
            return ({
                label: ((_a = columnComponent.data.title) === null || _a === void 0 ? void 0 : _a.trim()) || `[${fieldDefinition.name}]`,
                expression: `\${view.components.${recordGridGuid}.${propertyName}.${columnComponent.data.fieldId}}`,
                autocompleteOptions: selectionList,
                children: fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.selection
                    ? [
                        {
                            label: `${columnComponent.data.title} (Option name)`,
                            expression: `\${view.components.${recordGridGuid}.${propertyName}.selectionFieldOptionNamesById.${columnComponent.data.fieldId}}`
                        },
                        {
                            label: 'Options',
                            children: selectionList
                        }
                    ]
                    : null
            });
        };
    }
    getComponentName(componentDescriptorName, recordDefinitionDisplayName, associationDefinitionDisplayName, name) {
        const additionalLabels = [recordDefinitionDisplayName, associationDefinitionDisplayName, name].filter(Boolean);
        return additionalLabels.length
            ? `${componentDescriptorName} (${additionalLabels.join(': ')})`
            : componentDescriptorName;
    }
    getGridViewPresetPayload(viewPresetGuid, columns) {
        return {
            type: RX_RECORD_GRID.components.viewPreset,
            guid: this.rxGuidService.generate(),
            data: {
                viewPresetGuid,
                filters: null
            },
            children: columns.map((column) => this.getColumnPresetPayload(column))
        };
    }
    getColumnPresetPayload(column) {
        return {
            type: RX_RECORD_GRID.components.columnViewPreset,
            data: {
                fieldId: column.fieldId,
                index: column.index,
                visible: column.visible,
                sortable: isObject(column.sortable) ? column.sortable : null,
                width: column.width
            }
        };
    }
    getPresetsList(guid) {
        return guid
            ? this.viewDesignerFacade.getChildComponents(guid).pipe(map((res) => res.sort((a, b) => a.data.index - b.data.index)), map((res) => res.map((item) => ({ guid: item.guid, name: item.data.label }))), debounceTime(50) // used to let store be `stabilized` when indexes are updating for each preset
            )
            : of([]);
    }
}
RxRecordGridDesignUtilsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDesignUtilsService, deps: [{ token: i2$1.RxGuidService }, { token: RxRecordGridConfigUtilsService }, { token: i1$1.RxDefinitionNameService }, { token: i1$1.RxFeatureService }, { token: i1$6.RxModalService }, { token: RxRecordGridUtilsService }, { token: RxRecordGridFilterHelperService }, { token: i2.TranslateService }, { token: i1$3.ViewDesignerFacade }, { token: i2$1.RxJsonParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridDesignUtilsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDesignUtilsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDesignUtilsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2$1.RxGuidService }, { type: RxRecordGridConfigUtilsService }, { type: i1$1.RxDefinitionNameService }, { type: i1$1.RxFeatureService }, { type: i1$6.RxModalService }, { type: RxRecordGridUtilsService }, { type: RxRecordGridFilterHelperService }, { type: i2.TranslateService }, { type: i1$3.ViewDesignerFacade }, { type: i2$1.RxJsonParserService }]; } });

class RecordGridDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.rxRecordDefinitionCacheService = this.injector.get(RxRecordDefinitionCacheService);
        this.rxViewActionValidatorService = this.injector.get(RxViewActionValidatorService);
        this.rxRecordGridDesignUtilsService = this.injector.get(RxRecordGridDesignUtilsService);
        this.rxGuidService = this.injector.get(RxGuidService);
        this.rxDefinitionNameService = this.injector.get(RxDefinitionNameService);
        this.preservedRecordDefinition = null;
        this.preservedRecordAssociationDefinitions = [];
        this.currentGridDesignProperties = null;
        this.componentPropertiesChangeFromCanvas$ = new Subject();
        this.columns$ = this.sandbox.getComponentPropertyValue('columns');
        this.enableFiltering$ = this.sandbox.getComponentPropertyValue('enableFiltering');
        this.recordDefinitionName$ = this.sandbox.getComponentPropertyValue('recordDefinitionName');
        this.associationDefinitionName$ = this.sandbox.getComponentPropertyValue('associationDefinitionName');
        this.associatedRecordNodeSide$ = this.sandbox.getComponentPropertyValue('associatedRecordNodeSide');
        this.childComponentsTree$ = this.sandbox.getChildComponentsTree();
        this.viewPresetSelectors$ = this.sandbox.getComponentsByType(RxViewComponentType.ViewPresetSelector);
        this.gridViewPresets$ = this.childComponentsTree$.pipe(map((components) => this.rxRecordGridDesignUtilsService.getGridViewPresetsFromChildData(components)));
        this.viewPresetSelectorGuid$ = this.sandbox.getComponentPropertyValue('viewPresetSelector').pipe(map((val) => this.extractViewPresetSelectorGuid(val)), shareReplay({ refCount: true, bufferSize: 1 }));
        this.selectedPresetsList$ = this.viewPresetSelectorGuid$.pipe(switchMap((guid) => this.rxRecordGridDesignUtilsService.getPresetsList(guid)), distinctUntilChanged(isEqual), takeUntil(this.sandbox.destroyed$));
        this.rowActionButtonGuids$ = this.sandbox.getLayout(this.sandbox.guid).pipe(filter(Boolean), map((layout) => {
            const rowActionsOutlet = find(layout.outlets, { name: RX_RECORD_GRID.rowActionsOutletName });
            return head(rowActionsOutlet.columns).children;
        }), shareReplay(1));
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({}, RX_AVAILABLE_ON_DEVICES_DEFAULT_VALUE), initialProperties);
    }
    rxInit() {
        const initialProps = Object.assign({ bordered: true, expandable: false, name: null, mode: RecordGridDesignDefinitionMode.Record, recordDefinitionName: null, showDataForAllLocales: false, associationDefinitionName: null, associatedRecordId: null, associatedRoleName: null, enableRowSelection: RX_RECORD_GRID.selectionTypes.multiple, styles: null, cardLayoutWidth: null, enableFiltering: true, getDataForHiddenColumns: true, requiredFilters: 0, enableFilterPresets: true, defaultFilterPreset: null, initialSortColumn: null, columns: [], filterMode: RecordGridFilterMode.Basic, filters: { basicFilters: [], filtersJson: null }, filterExpression: null, filterPresets: [], striped: false }, RX_AVAILABLE_ON_DEVICES_DEFAULT_VALUE);
        this.recordDefinition$ = this.recordDefinitionName$.pipe(switchMap((recordDefinitionName) => this.getRecordDefinition(recordDefinitionName)), shareReplay(1));
        this.recordAssociationDefinitions$ = this.recordDefinitionName$.pipe(mergeMap((recordDefinitionName) => this.getRecordAssociationDefinitions(recordDefinitionName)), shareReplay(1));
        const columnComponents$ = this.childComponentsTree$.pipe(map((components) => components.filter((component) => component.type === RX_RECORD_GRID.components.column)), 
        // ignore child action button component updates
        distinctUntilChanged(isEqual));
        const basicRecordGridFilters$ = this.childComponentsTree$.pipe(map((components) => this.rxRecordGridDesignUtilsService.getBasicRecordGridFiltersFromChildData(components)), distinctUntilChanged(isEqual));
        const filterPresets$ = this.childComponentsTree$.pipe(map((components) => this.rxRecordGridDesignUtilsService.getFilterPresetDescriptorsFromChildData(components)), distinctUntilChanged(isEqual));
        this.actionButtonComponents$ = this.childComponentsTree$.pipe(withLatestFrom(this.rowActionButtonGuids$), map(([definitions, rowActionButtonGuids]) => this.rxRecordGridDesignUtilsService
            .getActionButtonDescriptorsFromChildData(definitions)
            .filter((definition) => !includes(rowActionButtonGuids, definition.guid))));
        this.rowActionButtonComponents$ = this.childComponentsTree$.pipe(withLatestFrom(this.rowActionButtonGuids$), map(([definitions, rowActionButtonGuids]) => this.rxRecordGridDesignUtilsService
            .getActionButtonDescriptorsFromChildData(definitions)
            .filter((definition) => includes(rowActionButtonGuids, definition.guid))));
        // remove grid view presets in case if bound preset selector is removed
        this.viewPresetSelectors$
            .pipe(map((viewPresetSelectors) => viewPresetSelectors.map((selector) => selector.guid).sort()), distinctUntilChanged(isEqual), withLatestFrom(this.viewPresetSelectorGuid$), filter(([viewPresetSelectors, viewPresetSelectorGuid]) => viewPresetSelectorGuid && !viewPresetSelectors.includes(viewPresetSelectorGuid)), switchMap(() => this.childComponentsTree$.pipe(take(1))), map((components) => components.filter((comp) => comp.type !== RX_RECORD_GRID.components.viewPreset)), takeUntil(this.sandbox.destroyed$))
            .subscribe((components) => {
            this.sandbox.setChildren(components);
            this.sandbox.updateComponentProperties({ viewPresetSelector: null });
        });
        this.sandbox.viewModelsInitialized$
            .pipe(withLatestFrom(this.rowActionButtonComponents$), map(([viewModelsInitialized, rowActionButtons]) => rowActionButtons), filter((rowActionButtons) => !!rowActionButtons.length))
            .subscribe((rowActionButtons) => {
            rowActionButtons.forEach((rowActionButton) => {
                const model = this.sandbox.getComponentModel(rowActionButton.guid);
                model.setValidationIssues([]);
            });
        });
        merge(this.sandbox.componentProperties$.pipe(skip(1)), this.componentPropertiesChangeFromCanvas$)
            .pipe(distinctUntilChanged((oldValue, newValue) => isEqual(this.currentGridDesignProperties, newValue)), mergeMap((componentDesignProperties) => {
            const previousComponentDesignProperties = this.currentGridDesignProperties;
            if (previousComponentDesignProperties.recordDefinitionName !== componentDesignProperties.recordDefinitionName) {
                return zip(this.getRecordDefinition(componentDesignProperties.recordDefinitionName), this.getRecordAssociationDefinitions(componentDesignProperties.recordDefinitionName)).pipe(map(() => [previousComponentDesignProperties, componentDesignProperties]));
            }
            else {
                return of([previousComponentDesignProperties, componentDesignProperties]);
            }
        }), withLatestFrom(this.actionButtonComponents$, this.rowActionButtonComponents$, this.gridViewPresets$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([[previousComponentDesignProperties, componentDesignProperties], actionButtonComponents, rowActionButtonComponents, gridViewPresets]) => {
            const recordDefinition = this.preservedRecordDefinition;
            const recordAssociationDefinitions = this.preservedRecordAssociationDefinitions;
            let propertiesToUpdate;
            if (!componentDesignProperties.enableFiltering) {
                propertiesToUpdate = {
                    enableFilterPresets: false
                };
            }
            else if (!previousComponentDesignProperties.enableFiltering && componentDesignProperties.enableFiltering) {
                propertiesToUpdate = {
                    enableFilterPresets: true
                };
            }
            if (previousComponentDesignProperties.recordDefinitionName !== componentDesignProperties.recordDefinitionName) {
                propertiesToUpdate = {
                    filterPresets: [],
                    filters: { basicFilters: [], filtersJson: null },
                    initialSortColumn: null,
                    associationDefinitionName: null,
                    filterExpression: null
                };
                if (recordDefinition) {
                    const columns = this.rxRecordGridDesignUtilsService.getDefaultColumns(recordDefinition);
                    const payloads = this.rxRecordGridDesignUtilsService.getColumnComponentPayloads(columns, null);
                    payloads.push(...actionButtonComponents);
                    this.sandbox.setChildren(payloads);
                    propertiesToUpdate.columns = columns;
                }
                else {
                    this.sandbox.setChildren(actionButtonComponents);
                    propertiesToUpdate.columns = [];
                }
            }
            else {
                const childrenModels = pick(componentDesignProperties, 'columns', 'initialSortColumn', 'filters', 'filterPresets');
                const previousChildrenModels = pick(previousComponentDesignProperties, 'columns', 'initialSortColumn', 'filters', 'filterPresets');
                if (!isEqual(previousChildrenModels, childrenModels)) {
                    const payloads = this.rxRecordGridDesignUtilsService.getColumnComponentPayloads(childrenModels.columns, childrenModels.initialSortColumn);
                    const newInspectorColumns = this.rxRecordGridDesignUtilsService.getInspectorColumnsFromDesignData(payloads);
                    payloads.push(...this.rxRecordGridDesignUtilsService.getGridFilterComponentPayloads(childrenModels.filters.basicFilters || []));
                    const filterPresetComponentPayloads = this.rxRecordGridDesignUtilsService.getGridFilterPresetComponentPayloads(childrenModels.filterPresets, newInspectorColumns.filter((column) => column.filterable));
                    payloads.push(...filterPresetComponentPayloads);
                    childrenModels.filterPresets =
                        this.rxRecordGridDesignUtilsService.getFilterPresetDescriptorsFromChildData(filterPresetComponentPayloads);
                    payloads.push(...actionButtonComponents, ...rowActionButtonComponents, ...gridViewPresets);
                    this.sandbox.setChildren(payloads);
                    propertiesToUpdate = {
                        columns: newInspectorColumns,
                        initialSortColumn: this.rxRecordGridDesignUtilsService.getInitialSortColumnModel(newInspectorColumns),
                        filterPresets: childrenModels.filterPresets
                    };
                }
            }
            if (previousComponentDesignProperties.filterMode !== componentDesignProperties.filterMode) {
                if (componentDesignProperties.filterMode === RecordGridFilterMode.Basic) {
                    propertiesToUpdate = {
                        filterExpression: null
                    };
                }
                else {
                    propertiesToUpdate = {
                        filters: { basicFilters: [], filtersJson: null }
                    };
                }
            }
            if (previousComponentDesignProperties.associationDefinitionName !==
                componentDesignProperties.associationDefinitionName) {
                propertiesToUpdate = Object.assign(Object.assign({}, (propertiesToUpdate || {})), { associatedRecordNodeSide: this.getAssociatedRecordNodeSide(componentDesignProperties, recordAssociationDefinitions) });
            }
            if (previousComponentDesignProperties.mode !== componentDesignProperties.mode) {
                propertiesToUpdate = {
                    associationDefinitionName: null,
                    associatedRecordId: null,
                    associatedRoleName: null,
                    associatedRecordNodeSide: null
                };
            }
            componentDesignProperties = Object.assign(Object.assign({}, componentDesignProperties), propertiesToUpdate);
            if (previousComponentDesignProperties.enableFiltering && !componentDesignProperties.enableFiltering) {
                propertiesToUpdate = Object.assign(Object.assign({}, propertiesToUpdate), { requiredFilters: 0 });
            }
            this.updateComponentPropertiesAndConfig(componentDesignProperties, propertiesToUpdate, recordDefinition, recordAssociationDefinitions);
        });
        combineLatest([
            this.recordDefinitionName$.pipe(map((recordDefinitionName) => recordDefinitionName
                ? null
                : this.sandbox.createError('Record definition name cannot be blank.', 'recordDefinitionName'))),
            columnComponents$.pipe(switchMap((columns) => this.validateColumns(columns))),
            this.sandbox.getComponentPropertyValue('styles').pipe(map(validateCssClassNames)),
            this.sandbox
                .getComponentPropertyValue('mode')
                .pipe(switchMap((mode) => mode === RecordGridDesignDefinitionMode.Association
                ? this.validateAssociationModeProps()
                : this.actionButtonComponents$.pipe(switchMap((components) => this.validateActionButtons(components))))),
            this.rowActionButtonComponents$.pipe(switchMap((rowActionButtons) => this.validateRowActions(rowActionButtons))),
            this.sandbox
                .getComponentPropertyValue(RX_AVAILABLE_ON_DEVICES_PROP_NAME)
                .pipe(map(validateAvailableOnDevicesProp))
        ])
            .pipe(map(compact), map(flatten), takeUntil(this.sandbox.destroyed$))
            .subscribe((issues) => {
            this.sandbox.setValidationIssues(issues);
        });
        // set initial properties and inspector config
        combineLatest([
            this.sandbox.componentProperties$,
            this.recordDefinition$,
            this.recordAssociationDefinitions$,
            columnComponents$,
            basicRecordGridFilters$,
            filterPresets$
        ])
            .pipe(take(1), takeUntil(this.sandbox.destroyed$))
            .subscribe(([componentProperties, recordDefinition, recordAssociationDefinitions, columnComponents, basicRecordGridFilters, filterPresets]) => {
            const componentDesignProperties = this.rxRecordGridDesignUtilsService.getComponentDesignProperties(componentProperties, initialProps, columnComponents, basicRecordGridFilters, filterPresets);
            this.updateComponentPropertiesAndConfig(componentDesignProperties, componentDesignProperties, recordDefinition, recordAssociationDefinitions);
        });
        const name$ = this.sandbox
            .getComponentPropertyValue('name')
            .pipe(shareReplay(1), takeUntil(this.sandbox.destroyed$));
        const associationDefinitionDisplayName$ = this.associationDefinitionName$.pipe(map((name) => this.rxDefinitionNameService.getDisplayName(name)), shareReplay(1), takeUntil(this.sandbox.destroyed$));
        this.rxRecordGridDesignUtilsService
            .getColumnDataDictionaryBranch(this.sandbox.guid, this.sandbox.descriptor.name, name$, columnComponents$, this.recordDefinition$, associationDefinitionDisplayName$)
            .pipe(skipWhile(isEmpty), takeUntil(this.sandbox.destroyed$))
            .subscribe((dataDictionaryBranch) => {
            this.sandbox.setCommonDataDictionary(dataDictionaryBranch);
        });
        combineLatest([
            this.recordDefinitionName$.pipe(map((name) => this.rxDefinitionNameService.getDisplayName(name))),
            associationDefinitionDisplayName$,
            name$
        ])
            .pipe(map((names) => this.rxRecordGridDesignUtilsService.getComponentName(this.sandbox.descriptor.name, ...names)), takeUntil(this.sandbox.destroyed$))
            .subscribe((name) => {
            // Set name to be used in the data dictionary for set property action if record grid will have child action buttons.
            this.sandbox.setSettablePropertiesDataDictionary(name, []);
        });
        // updates grid view presets when view preset changes
        this.selectedPresetsList$
            .pipe(skip(1), withLatestFrom(this.childComponentsTree$, this.columns$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([selectedPresetsList, childComponents, columns]) => {
            this.updatePresetViewComponents(childComponents, selectedPresetsList, columns);
        });
    }
    updatePresetViewComponents(childComponents, selectedPresetsList, columns) {
        const gridViewPresetComponents = childComponents.filter((c) => c.type === RX_RECORD_GRID.components.viewPreset);
        const gridViewPresetPayloads = selectedPresetsList.map(({ guid }) => {
            const existing = gridViewPresetComponents.find((c) => c.data.viewPresetGuid === guid);
            return existing !== null && existing !== void 0 ? existing : this.rxRecordGridDesignUtilsService.getGridViewPresetPayload(guid, columns);
        });
        this.sandbox.setChildrenByType(gridViewPresetPayloads, [RX_RECORD_GRID.components.viewPreset]);
    }
    getAssociatedRecordNodeSide(componentDesignProperties, recordAssociationDefinitions) {
        const selectedAssociationDefinition = componentDesignProperties.associationDefinitionName
            ? recordAssociationDefinitions.find(({ name }) => name === componentDesignProperties.associationDefinitionName)
            : null;
        return selectedAssociationDefinition
            ? selectedAssociationDefinition.nodeAId === componentDesignProperties.recordDefinitionName
                ? RX_ASSOCIATED_RECORD_NODE_SIDES.nodeA.value
                : RX_ASSOCIATED_RECORD_NODE_SIDES.nodeB.value
            : null;
    }
    actionButtonDropPredicate(data) {
        return data.draggedViewComponentDescriptor.type === RxViewComponentType.ActionButton;
    }
    getPropertiesByName(properties) {
        return this.rxRecordGridDesignUtilsService.getComponentProperties(properties);
    }
    setRowActions(rowActions) {
        this.rowActionButtonGuids$
            .pipe(take(1), withLatestFrom(this.childComponentsTree$))
            .subscribe(([rowActionButtonGuids, childComponentsTree]) => {
            const childComponentPayloads = childComponentsTree.filter((childComponent) => !includes(rowActionButtonGuids, childComponent.guid));
            childComponentPayloads.push(...this.rxRecordGridDesignUtilsService.getRowActionButtonPayloads(rowActions));
            this.sandbox.setChildren(childComponentPayloads);
            this.toggleActionsColumn(rowActions.length > 0);
        });
    }
    extractViewPresetSelectorGuid(val) {
        var _a;
        const matches = val === null || val === void 0 ? void 0 : val.match(/^\${view\.components\.([0-9a-z-]+)\.api}$/);
        return (_a = (matches && matches[1])) !== null && _a !== void 0 ? _a : null;
    }
    toggleActionsColumn(showActionsColumn) {
        this.sandbox.componentProperties$.pipe(take(1)).subscribe((componentProperties) => {
            const columns = cloneDeep(componentProperties.columns);
            const actionsColumn = find(columns, { fieldId: RX_RECORD_GRID.actionsColumnFieldDefinition.id });
            if (showActionsColumn && !actionsColumn) {
                columns.push({
                    fieldId: RX_RECORD_GRID.actionsColumnFieldDefinition.id,
                    guid: this.rxGuidService.generate(),
                    title: RX_RECORD_GRID.actionsColumnFieldDefinition.name,
                    visible: true,
                    index: columns.length,
                    filterable: false,
                    sortable: false,
                    searchable: false
                });
            }
            else if (!showActionsColumn) {
                pull(columns, actionsColumn);
                columns.forEach((column, index) => {
                    column.index = index;
                });
            }
            this.updateComponentPropertiesAndConfig(componentProperties, {
                columns
            }, this.preservedRecordDefinition, this.preservedRecordAssociationDefinitions);
        });
    }
    updateComponentPropertiesAndConfig(componentDesignProperties, propertiesToUpdate, recordDefinition, recordAssociationDefinitions) {
        this.currentGridDesignProperties = componentDesignProperties;
        if (propertiesToUpdate) {
            this.sandbox.updateComponentProperties(propertiesToUpdate);
        }
        this.sandbox.updateInspectorConfig(this.rxRecordGridDesignUtilsService.getInspector(componentDesignProperties, recordDefinition, recordAssociationDefinitions));
    }
    getRecordDefinition(recordDefinitionName) {
        if (recordDefinitionName) {
            return this.rxRecordDefinitionCacheService.getRecordDefinition(recordDefinitionName).pipe(catchError((error) => of(null)), tap((recordDefinition) => (this.preservedRecordDefinition = recordDefinition)));
        }
        else {
            this.preservedRecordDefinition = null;
            return of(null);
        }
    }
    getRecordAssociationDefinitions(recordDefinitionName) {
        if (recordDefinitionName) {
            return this.rxRecordDefinitionCacheService.getRecordAssociationDefinitions(recordDefinitionName).pipe(map((result) => result[recordDefinitionName] || []), catchError((error) => of([])), tap((recordAssociationDefinitions) => (this.preservedRecordAssociationDefinitions = recordAssociationDefinitions)));
        }
        else {
            this.preservedRecordAssociationDefinitions = [];
            return of([]);
        }
    }
    validateColumns(columns) {
        return columns.length
            ? this.validateColumnActions(columns)
            : of([this.sandbox.createError('Record grid must have at least one column.', 'columns')]);
    }
    validateColumnActions(columns) {
        return combineLatest(columns.map((column) => {
            const actionViewComponents = filter$1(column.children, { type: RxViewComponentType.Action });
            return this.rxViewActionValidatorService.validate(actionViewComponents, 'columns').pipe(map((issues) => issues.map((issue) => (Object.assign(Object.assign({}, issue), { data: Object.assign(Object.assign({}, issue.data), { columnGuid: column.guid }) })))));
        })).pipe(map(flatten));
    }
    validateRowActions(rowActionButtons) {
        return rowActionButtons.length
            ? combineLatest(rowActionButtons.map((rowActionButton, index) => this.rxViewActionValidatorService.validate(rowActionButton.children, 'rowActions').pipe(map((issues) => issues.map((issue) => (Object.assign(Object.assign({}, issue), { data: Object.assign(Object.assign({}, issue.data), { rowActionIndex: index }) }))))))).pipe(map(flatten))
            : of([]);
    }
    validateAssociationModeProps() {
        return combineLatest([
            combineLatest([this.associationDefinitionName$, this.associatedRecordNodeSide$]).pipe(map(([associationDefinitionName, associatedRecordNodeSide]) => {
                if (associationDefinitionName) {
                    return associatedRecordNodeSide
                        ? null
                        : this.sandbox.createError('Associated record node side cannot be blank.', 'associatedRecordNodeSide');
                }
                else {
                    return this.sandbox.createError('Association definition name cannot be blank.', 'associationDefinitionName');
                }
            })),
            this.sandbox
                .getComponentPropertyValue('associatedRecordId')
                .pipe(map((associatedRecordId) => associatedRecordId
                ? null
                : this.sandbox.createError('Associated record ID cannot be blank.', 'associatedRecordId')))
        ]).pipe(map(compact));
    }
    validateActionButtons(components) {
        const deleteActions = flatten(components.map((component) => component.children)).filter(({ data }) => data.name === 'rxDeleteRecordsAction' && data.recordDefinitionName);
        return deleteActions.length
            ? combineLatest(deleteActions.map(({ data }) => this.rxRecordDefinitionCacheService
                .getRecordDefinition(data.recordDefinitionName)
                .pipe(map(({ resourceType }) => resourceType === RX_RECORD_DEFINITION.recordDefinitionTypes.join.recordDefinitionType
                ? this.sandbox.createWarning('You have configured a Record grid action to delete Join records. Please ensure that one or more processes or rules have been defined to perform the deletion of the selected Join record instances.')
                : null)))).pipe(map(compact))
            : of([]);
    }
}

class RecordGridDesignComponent {
    constructor(rxRecordGridConfigUtilsService, rxRecordGridUtilsService) {
        this.rxRecordGridConfigUtilsService = rxRecordGridConfigUtilsService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
    }
    ngOnInit() {
        this.adaptTableConfig$ = this.model.columns$.pipe(map((columns) => {
            const gridColumns = sortBy(columns, (column) => column.index);
            const initialSortGridColumn = gridColumns.find((gridColumn) => isObject(gridColumn.sortable));
            let sortMeta = {
                field: null,
                order: null
            };
            if (initialSortGridColumn) {
                const gridSortableObject = initialSortGridColumn.sortable;
                sortMeta = {
                    field: String(initialSortGridColumn.fieldId),
                    order: this.rxRecordGridConfigUtilsService.getColumnSortOrder(gridSortableObject.direction)
                };
            }
            return {
                columns: gridColumns.map((gridColumn) => ({
                    field: gridColumn.fieldId,
                    header: gridColumn.title,
                    sortable: Boolean(gridColumn.sortable),
                    hidden: !gridColumn.visible,
                    testId: this.rxRecordGridUtilsService.getTestIdForGridColumn(gridColumn.fieldId)
                })),
                sortMeta,
                toolbarConfig: {
                    counter: false,
                    quickFilter: true,
                    filter: true,
                    filterTemplate: this.filterTemplate,
                    filterResults: false,
                    visibleColumnsMenu: true,
                    visibleColumnsMenuTemplate: this.visibleColumnsMenuTemplate,
                    quickFilterTriggerable: true
                }
            };
        }), shareReplay(1));
        this.hasRecordDefinitionName$ = this.model.recordDefinition$.pipe(map(Boolean), shareReplay(1));
    }
    onSort(event) {
        this.adaptTableConfig$.pipe(take(1)).subscribe((adaptTableConfig) => {
            if (!isEqual(event, adaptTableConfig.sortMeta)) {
                let initialSortColumn;
                const column = this.model.currentGridDesignProperties.columns.find((gridColumn) => gridColumn.fieldId === event.field);
                if (isObject(column.sortable)) {
                    if (column.sortable.direction === ColumnSortDirection.Desc) {
                        initialSortColumn = null;
                    }
                    else {
                        initialSortColumn = { fieldId: column.fieldId, direction: ColumnSortDirection.Desc };
                    }
                }
                else {
                    initialSortColumn = { fieldId: column.fieldId, direction: ColumnSortDirection.Asc };
                }
                this.model.componentPropertiesChangeFromCanvas$.next(Object.assign(Object.assign({}, this.model.currentGridDesignProperties), { initialSortColumn }));
            }
        });
    }
    onBeforeViewComponentDrop(data) {
        if (data.draggedViewComponentDescriptor.type === RxViewComponentType.ActionButton &&
            !data.draggedViewComponentGuid) {
            data.initialPropertiesByName = Object.assign(Object.assign({}, data.initialPropertiesByName), { style: ActionButtonStyle.Tertiary });
        }
    }
}
RecordGridDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridDesignComponent, deps: [{ token: RxRecordGridConfigUtilsService }, { token: RxRecordGridUtilsService }], target: i0.ɵɵFactoryTarget.Component });
RecordGridDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridDesignComponent, selector: "rx-record-grid-design", inputs: { model: "model", isReadOnly: "isReadOnly" }, viewQueries: [{ propertyName: "filterTemplate", first: true, predicate: ["filterTemplate"], descendants: true, static: true }, { propertyName: "visibleColumnsMenuTemplate", first: true, predicate: ["visibleColumnsMenuTemplate"], descendants: true, static: true }], ngImport: i0, template: "<div class=\"rx-record-grid-design\" [class.border]=\"!(hasRecordDefinitionName$ | async)\">\n  <adapt-empty-state\n    *ngIf=\"!(hasRecordDefinitionName$ | async); else gridTemplate\"\n    type=\"objects\"\n    label=\"Select a record definition and edit grid columns in the Properties panel.\"\n  ></adapt-empty-state>\n\n  <ng-template #gridTemplate>\n    <rx-canvas-outlet\n      [dropListOrientation]=\"'horizontal'\"\n      class=\"rx-record-grid-design__action-buttons-canvas\"\n      (beforeViewComponentDrop)=\"onBeforeViewComponentDrop($event)\"\n      [dropPredicate]=\"model.actionButtonDropPredicate\"\n    ></rx-canvas-outlet>\n\n    <adapt-table\n      #adaptTable\n      class=\"rx-record-grid-design__table\"\n      [columns]=\"(adaptTableConfig$ | async).columns\"\n      [sortable]=\"!isReadOnly\"\n      [scrollable]=\"true\"\n      [scrollHeight]=\"'80px'\"\n      [rowExpandMode]=\"\"\n      [sortMode]=\"'single'\"\n      [toolbarConfig]=\"(adaptTableConfig$ | async).toolbarConfig\"\n      [filterable]=\"false\"\n      [sortField]=\"(adaptTableConfig$ | async).sortMeta.field\"\n      [sortOrder]=\"(adaptTableConfig$ | async).sortMeta.order\"\n      [bordered]=\"true\"\n      [totalRecords]=\"0\"\n      (onSort)=\"onSort($event)\"\n      [hasEmptyState]=\"false\"\n      [dontEmitLazyLoadOnInputChange]=\"false\"\n    ></adapt-table>\n  </ng-template>\n</div>\n\n<ng-template #filterTemplate let-context>\n  <span class=\"rx-record-grid-design__toolbar-item btn-link d-icon-refresh grid-toolbar-icon mx-2 p-1\"></span>\n  <div class=\"btn-link px-0 d-icon-left-filter d-icon-right-triangle_down\" *ngIf=\"model.enableFiltering$ | async\">\n    Filter\n  </div>\n</ng-template>\n\n<ng-template #visibleColumnsMenuTemplate></ng-template>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.rx-record-grid-design__action-buttons-canvas ::ng-deep rx-canvas-item-container{min-width:100%}.rx-record-grid-design__action-buttons-canvas ::ng-deep .cdk-drop-list{background-color:#f0f1f1;border:1px solid #d6d7d8;border-bottom:0;min-height:48px;display:flex;flex-flow:row wrap}.rx-record-grid-design__action-buttons-canvas ::ng-deep .cdk-drop-list:empty:after{content:\"Drop Action buttons here\";display:block;text-align:center;width:100%;line-height:48px;color:#959899;font-size:.875rem}.rx-record-grid-design__toolbar-item{font-size:.9375rem}.rx-record-grid-design__table ::ng-deep .adapt-table-toolbar{pointer-events:none}\n"], components: [{ type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }, { type: i1$3.CanvasOutletComponent, selector: "rx-canvas-outlet", inputs: ["name", "skipParentPredicate", "containerComponent", "dropListOrientation", "dropPredicate"], outputs: ["beforeViewComponentDrop"] }, { type: i1$7.AdaptTableComponent, selector: "adapt-table", inputs: ["sortable", "filterable", "triggerableFilters", "explicitSearchBtn", "enableReorderableRows", "suppressTooltip", "toolbarConfig", "dataColumnsColsTemplate", "dataColumnsHeaderTemplate", "dataColumnsDataCellsTemplate", "headerGroupsTemplate", "alwaysShowHeaderTooltip", "alwaysShowCellTooltip", "expandedCellClass", "expandedGroupsKeys", "nestedGroupPadding", "expandindCellInitialPadding", "groupValueDataCellTemplate", "tooltipInitialDelayMs", "tooltipClass", "rowsCustomClass", "paginatorAlign", "hasEmptyState", "enableInfiniteScrolling", "updateFirstColumnWidth", "busyConfig", "defaultFiltersMatchMode", "wrapCellText", "minBufferPx", "maxBufferPx", "testID", "headerSelectionMode", "disabledSelectedRowsCount", "disabledNotSelectedRowsCount", "disabledSelectedFilteredRowsCount", "disabledNotSelectedFilteredRowsCount", "selectedFilteredRowsCount", "totalRecordsInGroup", "disableRowSelection", "nestingStructureData", "nestingKey", "enableRowEditing", "autoScrollToTop", "paginationTexts", "toolbarTexts", "tableTexts", "filtersTexts", "headerCellMenuTexts", "texts", "loadingMore", "mergeColumns", "disabledRowSelectionResolver", "allowColumnReorderingResolver", "disableRowExpandingResolver", "rowAriaDataResolver", "tableWidthConfig", "expandedRowTemplate", "isRefreshingRowData", "value", "bordered", "paginator", "striped", "loading"], outputs: ["onLazyLoad", "rowDataRefresh", "savedRowEditing", "canceledRowEditing", "groupSelection", "allGroupedRowsSelection", "groupExpansion", "columnsVisibilityChange", "rowDragStart", "rowDragRelease", "rowDragEnd", "rowDragDrop", "export", "toolbarPopupAnimationDone"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid-design',
                    templateUrl: './record-grid-design.component.html',
                    styleUrls: ['./record-grid-design.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: RxRecordGridConfigUtilsService }, { type: RxRecordGridUtilsService }]; }, propDecorators: { model: [{
                type: Input
            }], filterTemplate: [{
                type: ViewChild,
                args: ['filterTemplate', { static: true }]
            }], visibleColumnsMenuTemplate: [{
                type: ViewChild,
                args: ['visibleColumnsMenuTemplate', { static: true }]
            }], isReadOnly: [{
                type: Input
            }] } });

class RxRecordGridDesignAdapterService {
    constructor(rxJsonParserService, rxViewDefinitionParserService) {
        this.rxJsonParserService = rxJsonParserService;
        this.rxViewDefinitionParserService = rxViewDefinitionParserService;
    }
    adaptDefinition(elementDefinition) {
        var _a, _b, _c, _d, _e;
        const layout = this.rxJsonParserService.tryParseJson(elementDefinition.layout);
        const rowActionsOutlet = find(layout.outlets, { name: RX_RECORD_GRID.rowActionsOutletName });
        elementDefinition.propertiesByName.enableFilterPresets =
            (_a = elementDefinition.propertiesByName.enableFilterPresets) !== null && _a !== void 0 ? _a : 'true';
        if (!rowActionsOutlet) {
            layout.outlets.push(RxViewLayout.getOutlet(RX_RECORD_GRID.rowActionsOutletName));
        }
        else {
            // move row actions to the end to make sure they are in the same order as in layout outlet
            forEach((_b = rowActionsOutlet.columns[0]) === null || _b === void 0 ? void 0 : _b.children, (rowActionGuid) => {
                const rowAction = find(elementDefinition.componentDefinitions, { guid: rowActionGuid });
                pull(elementDefinition.componentDefinitions, rowAction).push(rowAction);
            });
        }
        elementDefinition.layout = JSON.stringify(layout);
        Object.assign(elementDefinition.propertiesByName, {
            expandable: (_c = elementDefinition.propertiesByName.expandable) !== null && _c !== void 0 ? _c : false,
            showDataForAllLocales: (_d = elementDefinition.propertiesByName.showDataForAllLocales) !== null && _d !== void 0 ? _d : false,
            requiredFilters: (_e = elementDefinition.propertiesByName.requiredFilters) !== null && _e !== void 0 ? _e : (elementDefinition.propertiesByName.requireFiltering === 'true' ? 1 : 0)
        });
        delete elementDefinition.propertiesByName.requireFiltering;
        this.rxViewDefinitionParserService
            .getComponents(elementDefinition)
            .map((componentDefinition) => componentDefinition.componentDefinition)
            .forEach((componentDefinition) => {
            var _a, _b;
            if (componentDefinition.type === RX_RECORD_GRID.components.column) {
                Object.assign(componentDefinition.propertiesByName, {
                    wrapText: (_a = componentDefinition.propertiesByName.wrapText) !== null && _a !== void 0 ? _a : false,
                    typeaheadKeystrokeCount: Number((_b = componentDefinition.propertiesByName.typeaheadKeystrokeCount) !== null && _b !== void 0 ? _b : RX_RECORD_GRID.defaultTypeaheadKeystrokeCount)
                });
            }
        });
    }
}
RxRecordGridDesignAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDesignAdapterService, deps: [{ token: i2$1.RxJsonParserService }, { token: i1$4.RxViewDefinitionParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridDesignAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDesignAdapterService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDesignAdapterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2$1.RxJsonParserService }, { type: i1$4.RxViewDefinitionParserService }]; } });

class RecordGridSortEditorControlModule {
}
RecordGridSortEditorControlModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridSortEditorControlModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridSortEditorControlModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridSortEditorControlModule, declarations: [RecordGridSortEditorControlComponent], imports: [CommonModule, FormsModule, AdaptButtonModule, AdaptRxSelectModule], exports: [RecordGridSortEditorControlComponent] });
RecordGridSortEditorControlModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridSortEditorControlModule, imports: [[CommonModule, FormsModule, AdaptButtonModule, AdaptRxSelectModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridSortEditorControlModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RecordGridSortEditorControlComponent],
                    exports: [RecordGridSortEditorControlComponent],
                    entryComponents: [RecordGridSortEditorControlComponent],
                    imports: [CommonModule, FormsModule, AdaptButtonModule, AdaptRxSelectModule]
                }]
        }] });

class RecordGridViewPresetColumnsModalModule {
}
RecordGridViewPresetColumnsModalModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetColumnsModalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridViewPresetColumnsModalModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetColumnsModalModule, declarations: [RecordGridViewPresetColumnsModalComponent], imports: [AdaptAccordionModule,
        AdaptButtonModule,
        AdaptRxCheckboxModule,
        AdaptRxTextfieldModule,
        CommonModule,
        DragDropModule,
        FormsModule,
        StepperWithUnitsFormControlModule,
        TranslateModule], exports: [RecordGridViewPresetColumnsModalComponent] });
RecordGridViewPresetColumnsModalModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetColumnsModalModule, imports: [[
            AdaptAccordionModule,
            AdaptButtonModule,
            AdaptRxCheckboxModule,
            AdaptRxTextfieldModule,
            CommonModule,
            DragDropModule,
            FormsModule,
            StepperWithUnitsFormControlModule,
            TranslateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetColumnsModalModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RecordGridViewPresetColumnsModalComponent],
                    exports: [RecordGridViewPresetColumnsModalComponent],
                    imports: [
                        AdaptAccordionModule,
                        AdaptButtonModule,
                        AdaptRxCheckboxModule,
                        AdaptRxTextfieldModule,
                        CommonModule,
                        DragDropModule,
                        FormsModule,
                        StepperWithUnitsFormControlModule,
                        TranslateModule
                    ]
                }]
        }] });

class RecordGridEditViewPresetsModalModule {
}
RecordGridEditViewPresetsModalModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridEditViewPresetsModalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridEditViewPresetsModalModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridEditViewPresetsModalModule, declarations: [RecordGridEditViewPresetsModalComponent], imports: [AdaptAccordionModule,
        AdaptButtonModule,
        AdaptTagModule,
        CommonModule,
        FormsModule,
        RecordGridFilterSelectControlModule,
        RecordGridSortEditorControlModule,
        RecordGridViewPresetColumnsModalModule,
        TranslateModule], exports: [RecordGridEditViewPresetsModalComponent] });
RecordGridEditViewPresetsModalModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridEditViewPresetsModalModule, imports: [[
            AdaptAccordionModule,
            AdaptButtonModule,
            AdaptTagModule,
            CommonModule,
            FormsModule,
            RecordGridFilterSelectControlModule,
            RecordGridSortEditorControlModule,
            RecordGridViewPresetColumnsModalModule,
            TranslateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridEditViewPresetsModalModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RecordGridEditViewPresetsModalComponent],
                    exports: [RecordGridEditViewPresetsModalComponent],
                    imports: [
                        AdaptAccordionModule,
                        AdaptButtonModule,
                        AdaptTagModule,
                        CommonModule,
                        FormsModule,
                        RecordGridFilterSelectControlModule,
                        RecordGridSortEditorControlModule,
                        RecordGridViewPresetColumnsModalModule,
                        TranslateModule
                    ]
                }]
        }] });

class RecordGridViewPresetsWidgetModule {
}
RecordGridViewPresetsWidgetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetsWidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridViewPresetsWidgetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetsWidgetModule, declarations: [RecordGridViewPresetsWidgetComponent], imports: [CommonModule, AdaptButtonModule, FormsModule, RecordGridEditViewPresetsModalModule, SelectFormControlModule], exports: [RecordGridViewPresetsWidgetComponent] });
RecordGridViewPresetsWidgetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetsWidgetModule, imports: [[CommonModule, AdaptButtonModule, FormsModule, RecordGridEditViewPresetsModalModule, SelectFormControlModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridViewPresetsWidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RecordGridViewPresetsWidgetComponent],
                    exports: [RecordGridViewPresetsWidgetComponent],
                    imports: [CommonModule, AdaptButtonModule, FormsModule, RecordGridEditViewPresetsModalModule, SelectFormControlModule]
                }]
        }] });

class RecordGridDesignModule {
    constructor(rxDefinitionAdapterRegistryService, rxRecordGridDesignAdapterService) {
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.rxRecordGridDesignAdapterService = rxRecordGridDesignAdapterService;
        this.rxDefinitionAdapterRegistryService.registerDesignAdapter(RX_RECORD_GRID.type, this.rxRecordGridDesignAdapterService);
    }
}
RecordGridDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridDesignModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: RxRecordGridDesignAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridDesignModule, declarations: [RecordGridDesignComponent,
        RecordGridColumnEditorControlComponent,
        RecordGridColumnEditorModalComponent,
        ColumnEditorAlignmentComponent,
        RecordGridFilterPresetEditorControlComponent,
        RecordGridFilterPresetEditorModalComponent,
        RxRecordGridRowActionEditorWidgetComponent,
        RecordGridRowActionEditorModalComponent,
        RecordGridCellDisplayPropertiesComponent,
        RecordGridCellDisplayPropertiesEditorComponent,
        RecordGridNamedFilterOptionsComponent,
        RecordGridNamedFilterOptionsEditorModalComponent], imports: [CommonModule,
        FormsModule,
        ReactiveFormsModule,
        RecordGridSortEditorControlModule,
        AdaptButtonModule,
        AdaptTooltipModule,
        AdaptAccordionModule,
        AdaptTextFieldModule,
        AdaptRxSearchModule,
        AdaptTreeModule,
        AdaptRxCheckboxModule,
        AdaptRxRadiobuttonModule,
        ActionListControlModule,
        GroupButtonFormControlModule,
        DragDropModule,
        ExpressionEditorModule,
        AdaptAdvancedFilteringModule,
        AdaptRxTextfieldModule,
        RxDirectivesModule,
        AdaptRxLabelModule,
        RecordGridCommonModule,
        ViewDesignerCanvasModule,
        AdaptTableModule,
        AdaptEmptyStateModule,
        RxDefinitionModule,
        AdaptRxSelectModule,
        RxDefinitionPickerModule,
        ExpressionFormControlModule,
        AdaptIconModule,
        TranslateModule,
        SelectFormControlModule,
        RxUniqueValidatorModule,
        AdaptRxSwitchModule,
        IconPickerFormControlModule,
        AdaptPopoverModule,
        RxAdvancedFilteringFieldsProviderModule,
        RecordGridViewPresetsWidgetModule,
        RecordGridFilterSelectControlModule,
        StepperWithUnitsFormControlModule,
        RxNoWhitespaceValidatorModule] });
RecordGridDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridDesignModule, imports: [[
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            RecordGridSortEditorControlModule,
            AdaptButtonModule,
            AdaptTooltipModule,
            AdaptAccordionModule,
            AdaptTextFieldModule,
            AdaptRxSearchModule,
            AdaptTreeModule,
            AdaptRxCheckboxModule,
            AdaptRxRadiobuttonModule,
            ActionListControlModule,
            GroupButtonFormControlModule,
            DragDropModule,
            ExpressionEditorModule,
            AdaptAdvancedFilteringModule,
            AdaptRxTextfieldModule,
            RxDirectivesModule,
            AdaptRxLabelModule,
            RecordGridCommonModule,
            ViewDesignerCanvasModule,
            AdaptTableModule,
            AdaptEmptyStateModule,
            RxDefinitionModule,
            AdaptRxSelectModule,
            RxDefinitionPickerModule,
            ExpressionFormControlModule,
            AdaptIconModule,
            TranslateModule,
            SelectFormControlModule,
            RxUniqueValidatorModule,
            AdaptRxSwitchModule,
            IconPickerFormControlModule,
            AdaptPopoverModule,
            RxAdvancedFilteringFieldsProviderModule,
            RecordGridViewPresetsWidgetModule,
            RecordGridFilterSelectControlModule,
            StepperWithUnitsFormControlModule,
            RxNoWhitespaceValidatorModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        RecordGridSortEditorControlModule,
                        AdaptButtonModule,
                        AdaptTooltipModule,
                        AdaptAccordionModule,
                        AdaptTextFieldModule,
                        AdaptRxSearchModule,
                        AdaptTreeModule,
                        AdaptRxCheckboxModule,
                        AdaptRxRadiobuttonModule,
                        ActionListControlModule,
                        GroupButtonFormControlModule,
                        DragDropModule,
                        ExpressionEditorModule,
                        AdaptAdvancedFilteringModule,
                        AdaptRxTextfieldModule,
                        RxDirectivesModule,
                        AdaptRxLabelModule,
                        RecordGridCommonModule,
                        ViewDesignerCanvasModule,
                        AdaptTableModule,
                        AdaptEmptyStateModule,
                        RxDefinitionModule,
                        AdaptRxSelectModule,
                        RxDefinitionPickerModule,
                        ExpressionFormControlModule,
                        AdaptIconModule,
                        TranslateModule,
                        SelectFormControlModule,
                        RxUniqueValidatorModule,
                        AdaptRxSwitchModule,
                        IconPickerFormControlModule,
                        AdaptPopoverModule,
                        RxAdvancedFilteringFieldsProviderModule,
                        RecordGridViewPresetsWidgetModule,
                        RecordGridFilterSelectControlModule,
                        StepperWithUnitsFormControlModule,
                        RxNoWhitespaceValidatorModule
                    ],
                    declarations: [
                        RecordGridDesignComponent,
                        RecordGridColumnEditorControlComponent,
                        RecordGridColumnEditorModalComponent,
                        ColumnEditorAlignmentComponent,
                        RecordGridFilterPresetEditorControlComponent,
                        RecordGridFilterPresetEditorModalComponent,
                        RxRecordGridRowActionEditorWidgetComponent,
                        RecordGridRowActionEditorModalComponent,
                        RecordGridCellDisplayPropertiesComponent,
                        RecordGridCellDisplayPropertiesEditorComponent,
                        RecordGridNamedFilterOptionsComponent,
                        RecordGridNamedFilterOptionsEditorModalComponent
                    ],
                    entryComponents: [
                        RecordGridDesignComponent,
                        RecordGridColumnEditorControlComponent,
                        RecordGridColumnEditorModalComponent,
                        RecordGridFilterPresetEditorControlComponent,
                        RecordGridFilterPresetEditorModalComponent
                    ]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: RxRecordGridDesignAdapterService }]; } });

class PageComponent extends BaseViewComponent {
    constructor() {
        super();
    }
}
PageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
PageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: PageComponent, selector: "rx-page", usesInheritance: true, ngImport: i0, template: "<rx-runtime-view-canvas-outlet></rx-runtime-view-canvas-outlet>\n", components: [{ type: i1$2.RuntimeViewCanvasOutletComponent, selector: "rx-runtime-view-canvas-outlet", inputs: ["name"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-page',
                    templateUrl: './page.component.html'
                }]
        }], ctorParameters: function () { return []; } });

class RxFilterByCardSelectionDialogComponent {
    constructor(context, translateService) {
        this.context = context;
        this.translateService = translateService;
        this.alertConfig = {
            content: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.cards.filter-by-selection.dialog.info.message'),
            type: 'section',
            dismissible: false,
            variant: 'info',
            icon: true
        };
        this.options = this.context.getData().filterableFields;
    }
    optionFormatter(option) {
        return option.name;
    }
    apply() {
        this.context.close(this.field[0].id);
    }
}
RxFilterByCardSelectionDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxFilterByCardSelectionDialogComponent, deps: [{ token: i1.ActiveModalRef }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
RxFilterByCardSelectionDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxFilterByCardSelectionDialogComponent, selector: "rx-filter-by-card-selection", ngImport: i0, template: "<adapt-alert [config]=\"alertConfig\"></adapt-alert>\n\n<div class=\"modal-body pt-0\">\n  <adapt-rx-select\n    [label]=\"\n      'com.bmc.arsys.rx.client.view-components.record-grid.cards.filter-by-selection.dialog.field.label' | translate\n    \"\n    [options]=\"options\"\n    [(ngModel)]=\"field\"\n    [required]=\"true\"\n    [optionFormatter]=\"optionFormatter\"\n    [popupClass]=\"'rx-filter-by-card-selection-field-dropdown'\"\n  >\n  </adapt-rx-select>\n</div>\n\n<div class=\"modal-footer\">\n  <button adapt-button type=\"button\" btn-type=\"primary\" rx-id=\"apply-button\" [disabled]=\"!field\" (click)=\"apply()\">\n    {{ 'com.bmc.arsys.rx.client.common.apply.label' | translate }}\n  </button>\n\n  <button adapt-button type=\"button\" btn-type=\"secondary\" rx-id=\"cancel-button\" (click)=\"context.dismiss()\">\n    {{ 'com.bmc.arsys.rx.client.common.cancel.label' | translate }}\n  </button>\n</div>\n", components: [{ type: i1.AdaptAlertComponent, selector: "adapt-alert", inputs: ["config"], outputs: ["onClose"] }, { type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxFilterByCardSelectionDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-filter-by-card-selection',
                    templateUrl: './filter-by-card-selection-dialog.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i2.TranslateService }]; } });

class RxRecordGridConfiguratorService {
    constructor(rxGuidService, rxFieldDefinitionService, rxRecordGridConfigUtilsService, rxRecordGridUtilsService, translateService) {
        this.rxGuidService = rxGuidService;
        this.rxFieldDefinitionService = rxFieldDefinitionService;
        this.rxRecordGridConfigUtilsService = rxRecordGridConfigUtilsService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.translateService = translateService;
    }
    getGridConfig(rxConfiguration) {
        const config = defaults(this.rxRecordGridConfigUtilsService.configDeepClone(rxConfiguration), {
            associatedRecordId: null,
            associatedRoleName: null,
            enableColumnSelection: true,
            enableFiltering: true,
            expandable: false,
            useExternalFiltering: true,
            enableRowSelection: RX_RECORD_GRID.selectionTypes.multiple,
            filterExpression: null,
            filters: RX_RECORD_GRID.defaultFilter,
            filterTagsLimit: 3,
            recordIdField: RX_RECORD_DEFINITION.coreFieldIds.id.toString(),
            emptyStateLabelText: this.translateService.instant('com.bmc.arsys.rx.client.empty-state.no-items-to-display.label'),
            emptyStateWithFilterLabelText: this.translateService.instant('com.bmc.arsys.rx.client.empty-state.no-items-to-display.label'),
            searchFieldPlaceholderText: this.translateService.instant('com.bmc.arsys.rx.client.common.search.label'),
            styles: ''
        });
        if (!config.recordDefinitionName) {
            if (!rxConfiguration.getRecordDefinition) {
                throwError(new RxError('getRecordDefinition function must be defined if recordDefinitionName is not set.'));
            }
            if (!rxConfiguration.getData) {
                throwError(new RxError('getData function must be defined if recordDefinitionName is not set.'));
            }
        }
        config.enableFiltering = Boolean(config.enableFiltering);
        config.cardLayoutWidth = parseFloat(config.cardLayoutWidth) || null;
        return config;
    }
    getColumnsWithMetadata(recordGridGuid, columns, recordDefinition) {
        const columnsClone = this.rxRecordGridConfigUtilsService.columnsDeepClone(columns);
        this.allowedOpenViewActionExpressionsForHrefRegex = new RegExp(`^\\$\\{view\\.components\\.${recordGridGuid}\\.(clickableRow|recordDefinition)\\.|^\\$\\{view\\.inputParams\\.`);
        const columnsDefinitions$ = columnsClone.map((column) => {
            return this.rxRecordGridUtilsService.getFieldDefinition(column.fieldId, recordDefinition).pipe(map((fieldDefinition) => {
                var _a;
                let filterType = fieldDefinition.resourceType
                    ? this.getFieldDefinitionResourceTypeShortName(fieldDefinition.resourceType)
                    : null;
                if (filterType === RX_RECORD_DEFINITION.dataTypes.attachment.shortName) {
                    filterType = RX_RECORD_DEFINITION.dataTypes.character.shortName;
                }
                const filterable = this.rxRecordGridConfigUtilsService.getBooleanValue(column.filterable) || isUndefined(column.filterable);
                const searchable = has(column, 'searchable')
                    ? this.rxRecordGridConfigUtilsService.getBooleanValue(column.searchable)
                    : filterable && this.rxRecordGridUtilsService.isSearchable(fieldDefinition, recordDefinition);
                const columnWithMetadata = Object.assign(Object.assign({}, column), { clickable: this.rxRecordGridConfigUtilsService.getBooleanValue(column.clickable), filterable, sortable: this.rxRecordGridConfigUtilsService.parseConfigString(column.sortable) ||
                        isUndefined(column.sortable), visible: this.rxRecordGridConfigUtilsService.getBooleanValue(column.visible) || isUndefined(column.visible), searchable,
                    fieldDefinition,
                    filterType, clickableWithHref: this.isColumnClickableWithHref(column), title: (_a = column.title) === null || _a === void 0 ? void 0 : _a.trim(), fallbackTitle: `[${fieldDefinition.name}]` });
                return columnWithMetadata;
            }));
        });
        return forkJoin(columnsDefinitions$);
    }
    getSelectionFieldOptionLabelsByFieldId(columns, recordDefinition) {
        return reduce(columns, (result, column) => {
            const fieldDefinition = recordDefinition.fieldDefinitionsById[column.fieldId];
            if (fieldDefinition.resourceType === RX_RECORD_DEFINITION.dataTypes.selection.resourceType) {
                result[column.fieldId] = fieldDefinition.optionLabelsById;
            }
            return result;
        }, {});
    }
    getFieldDefinitionResourceTypeShortName(resourceType) {
        return resourceType
            .split('.')
            .pop()
            .replace(/fieldDefinition/i, '');
    }
    isColumnClickableWithHref(column) {
        let clickableWithHref = false;
        if (this.rxRecordGridConfigUtilsService.getBooleanValue(column.clickable)) {
            clickableWithHref = column.actions.every((action) => {
                return ((action.name === RX_VIEW_ACTION.viewActionNames.launchUrl ||
                    (action.name === RX_VIEW_ACTION.viewActionNames.openView &&
                        action.presentation.launchBehavior === OpenViewActionLaunchBehavior.SameWindow &&
                        action.presentation.type === OpenViewActionType.FullWidth &&
                        this.canViewParamsBeEvaluatedForHref(action.viewParams))) &&
                    this.canExpressionBeEvaluatedForHref(action.$condition$));
            });
        }
        return clickableWithHref;
    }
    canViewParamsBeEvaluatedForHref(viewParams) {
        return every(viewParams, (viewParamValue) => this.canExpressionBeEvaluatedForHref(viewParamValue));
    }
    canExpressionBeEvaluatedForHref(expression) {
        return every(expression === null || expression === void 0 ? void 0 : expression.match(/\$\{[^{]*\}/g), (expressionToken) => this.allowedOpenViewActionExpressionsForHrefRegex.test(expressionToken));
    }
}
RxRecordGridConfiguratorService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridConfiguratorService, deps: [{ token: i2$1.RxGuidService }, { token: i1$5.RxFieldDefinitionService }, { token: RxRecordGridConfigUtilsService }, { token: RxRecordGridUtilsService }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridConfiguratorService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridConfiguratorService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridConfiguratorService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2$1.RxGuidService }, { type: i1$5.RxFieldDefinitionService }, { type: RxRecordGridConfigUtilsService }, { type: RxRecordGridUtilsService }, { type: i2.TranslateService }]; } });

class RxRecordGridSharedFilterPresetsCacheService {
    constructor(rxRecordInstanceDataPageService) {
        this.rxRecordInstanceDataPageService = rxRecordInstanceDataPageService;
        this.cache = {};
    }
    // return preset from "Record Grid Filter Presets"
    getSharedFilterPresets(recordGridGuid) {
        if (!this.cache[recordGridGuid]) {
            const params = this.getQueryParams(recordGridGuid);
            return this.rxRecordInstanceDataPageService.post({ params }).pipe(map((sharedFilterPresets) => {
                return (this.cache[recordGridGuid] = map$1(sharedFilterPresets.data, (sharedFilterPreset) => ({
                    id: sharedFilterPreset[RX_RECORD_DEFINITION.coreFieldIds.id],
                    name: sharedFilterPreset[RX_RECORD_GRID.sharedFilterPresets.fields.name],
                    filters: [
                        {
                            filterOptionId: RX_RECORD_GRID.externalPresetFilterOptionId,
                            value: sharedFilterPreset[RX_RECORD_DEFINITION.coreFieldIds.id]
                        }
                    ],
                    isCreatedByOtherUsers: true,
                    filterExpression: sharedFilterPreset[RX_RECORD_GRID.sharedFilterPresets.fields.filterExpression],
                    isDefault: sharedFilterPreset[RX_RECORD_GRID.sharedFilterPresets.fields.isDefault]
                })));
            }));
        }
        return of(this.cache[recordGridGuid]);
    }
    getQueryParams(recordGridGuid) {
        const queryExpression = `('${RX_RECORD_GRID.sharedFilterPresets.fields.recordGridGuid}'="${recordGridGuid}")`;
        const propertySelection = [
            RX_RECORD_DEFINITION.coreFieldIds.id,
            RX_RECORD_GRID.sharedFilterPresets.fields.name,
            RX_RECORD_GRID.sharedFilterPresets.fields.filterExpression,
            RX_RECORD_GRID.sharedFilterPresets.fields.isDefault
        ].join(',');
        const sortBy = [
            RX_RECORD_GRID.sharedFilterPresets.fields.sortOrder,
            RX_RECORD_GRID.sharedFilterPresets.fields.name
        ].join(',');
        return {
            pageSize: -1,
            startIndex: 0,
            queryExpression: queryExpression,
            propertySelection: propertySelection,
            shouldIncludeTotalSize: false,
            recorddefinition: RX_RECORD_GRID.sharedFilterPresets.recordDefinitionName,
            sortBy
        };
    }
}
RxRecordGridSharedFilterPresetsCacheService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridSharedFilterPresetsCacheService, deps: [{ token: i1$5.RxRecordInstanceDataPageService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridSharedFilterPresetsCacheService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridSharedFilterPresetsCacheService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridSharedFilterPresetsCacheService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$5.RxRecordInstanceDataPageService }]; } });

class RxRecordGridUserPreferencesService {
    constructor(recordGridConfigUtilsService, rxUserPreferencesService, rxRecordGridFilterService, rxRecordGridFilterHelperService, rxObjectUtilsService) {
        this.recordGridConfigUtilsService = recordGridConfigUtilsService;
        this.rxUserPreferencesService = rxUserPreferencesService;
        this.rxRecordGridFilterService = rxRecordGridFilterService;
        this.rxRecordGridFilterHelperService = rxRecordGridFilterHelperService;
        this.rxObjectUtilsService = rxObjectUtilsService;
        this.initialPreferences = {
            columns: [],
            filterPresets: [],
            filters: null,
            visibleCardFieldIds: [],
            appliedExternalFilterPresetGuid: null,
            viewPresets: {}
        };
        this.preferences = Object.assign({}, this.initialPreferences);
    }
    saveUserPreferences(guid, adaptTableConfig, state) {
        if (adaptTableConfig.cardLayoutColumns) {
            this.preferences.visibleCardFieldIds = this.getVisibleCardFieldIds(adaptTableConfig);
        }
        else {
            this.preferences.columns = this.getColumnsPreferences(adaptTableConfig);
        }
        this.preferences.filterPresets = state.advancedFiltering.savedFilters
            .filter((savedFilter) => !savedFilter.isCreatedByOtherUsers)
            .map((savedFilter) => this.getPreferencesFilterPresets(savedFilter, state.recordDefinition.fieldDefinitionsById, state.advancedFiltering.recordGridFilterConfigs));
        const currentFilters = this.rxRecordGridFilterService.getRecordGridFilterDataFromAdvancedFilter(state.advancedFiltering.selectedFilters, state.recordDefinition.fieldDefinitionsById, state.advancedFiltering.recordGridFilterConfigs);
        this.preferences.filters = currentFilters;
        const appliedSharedFilterPreset = state.advancedFiltering.appliedSharedFilterPreset;
        this.preferences.appliedExternalFilterPresetGuid = appliedSharedFilterPreset && appliedSharedFilterPreset.id;
        if (this.selectedViewPresetGuid) {
            const selectedPreset = this.preferences.viewPresets[this.selectedViewPresetGuid];
            const newPreset = {
                viewPresetGuid: this.selectedViewPresetGuid,
                columns: this.getColumnsPreferences(adaptTableConfig),
                filters: isEmpty(currentFilters) ? null : currentFilters
            };
            if (isEqual(selectedPreset.initial, newPreset)) {
                this.discardViewPresetChanges(this.selectedViewPresetGuid);
            }
            else {
                selectedPreset.edited = newPreset;
            }
        }
        this.save(guid, this.preferences);
    }
    get(guid) {
        this.preferences = Object.assign({}, this.initialPreferences);
        return this.rxUserPreferencesService
            .getUiComponentPreferences(guid)
            .pipe(map((preferences) => assign(this.preferences, preferences)));
    }
    getAppliedSharedFilterPresetGuid() {
        return this.preferences.appliedExternalFilterPresetGuid;
    }
    applyUserPreferencesForColumns(adaptTableConfig, columnsWithMetadata, gridGuid) {
        const isColumnPreferencesUpdated = this.reviseColumnPreferences(this.preferences.columns, adaptTableConfig);
        if (isColumnPreferencesUpdated) {
            this.save(gridGuid, this.preferences);
        }
        let columnSortMeta = this.getColumnSortMeta(this.preferences.columns);
        this.sortColumnsConfigs(adaptTableConfig.columns);
        this.setColumnsWidths(adaptTableConfig.columns, this.preferences.columns, adaptTableConfig.columnResizeMode);
        columnSortMeta = filter$1(columnSortMeta, (sortMeta) => some(adaptTableConfig.columns, (tableColumn) => tableColumn.field === sortMeta.field));
        if (this.preferences.columns.length) {
            adaptTableConfig.multiSortMeta = columnSortMeta;
        }
        if (adaptTableConfig.cardLayoutColumns) {
            this.setCardFieldsVisibility(adaptTableConfig.columns);
        }
        else {
            this.setColumnsVisibility(adaptTableConfig.columns, columnsWithMetadata);
        }
    }
    reviseColumnPreferences(columnPreferences, { columns }) {
        let isColumnPreferencesChanged = false;
        if (columnPreferences.length) {
            const existingAdaptColumnIds = map$1(columns, 'field');
            const removedReferences = remove(columnPreferences, ({ fieldId }) => !existingAdaptColumnIds.includes(fieldId));
            let isSortingPreferencesChanged = removedReferences.some(({ sort }) => Boolean(sort));
            const preferencesSize = columnPreferences.length;
            const sortableColumnPreferences = [];
            columns.forEach((tableColumn, index) => {
                var _a;
                const columnPreference = find(columnPreferences, { fieldId: tableColumn.field });
                if (columnPreference) {
                    // Nullish width can be saved to preferences for column without width customization or without resizing.
                    // Non-empty value appearing means the width is customized after previous preferences saving.
                    (_a = columnPreference.width) !== null && _a !== void 0 ? _a : (columnPreference.width = tableColumn.width);
                    if (tableColumn.sortable) {
                        sortableColumnPreferences.push(columnPreference);
                    }
                    else if (columnPreference.sort) {
                        isSortingPreferencesChanged = true;
                    }
                }
                else {
                    columnPreferences.splice(index, 0, {
                        fieldId: tableColumn.field,
                        index: index,
                        visible: !tableColumn.hidden,
                        width: tableColumn.width
                    });
                }
            });
            if (isSortingPreferencesChanged) {
                const sortMetaForSortableColumns = this.getColumnSortMeta(sortableColumnPreferences);
                this.updateColumnSortPreferences(columnPreferences, sortMetaForSortableColumns);
            }
            isColumnPreferencesChanged =
                !isEmpty(removedReferences) || preferencesSize < columnPreferences.length || isSortingPreferencesChanged;
        }
        return isColumnPreferencesChanged;
    }
    applyUserPreferences(adaptTableConfig, columnsWithMetadata, state, sharedFilterPresets) {
        var _a, _b, _c, _d;
        if (!state.viewPresetSelector) {
            this.applyUserPreferencesForColumns(adaptTableConfig, columnsWithMetadata, state.guid);
        }
        let observable$;
        if (state === null || state === void 0 ? void 0 : state.enableFiltering) {
            let isFilterPresetDataChanged = false;
            // Remove filter presets that do not have any filters left.
            // These filters could have been removed as a result of removing a column,
            // used by the filter, from the grid.
            this.preferences.filterPresets.forEach((filterPreset) => {
                var _a, _b, _c, _d;
                const prevFilterDataLength = (_b = (_a = filterPreset.filterData) === null || _a === void 0 ? void 0 : _a.and) === null || _b === void 0 ? void 0 : _b.length;
                filterPreset.filterData = this.rxRecordGridFilterService.getFilterForAvailableColumns(filterPreset.filterData, columnsWithMetadata.filter((column) => column.filterable));
                if (prevFilterDataLength !== ((_d = (_c = filterPreset.filterData) === null || _c === void 0 ? void 0 : _c.and) === null || _d === void 0 ? void 0 : _d.length)) {
                    isFilterPresetDataChanged = true;
                }
            });
            this.preferences.filterPresets = this.preferences.filterPresets.filter((filterPreset) => !isEmpty(filterPreset.filterData));
            const prevFilters = cloneDeep((_a = this.preferences.filters) === null || _a === void 0 ? void 0 : _a.and);
            this.preferences.filters = this.rxRecordGridFilterService.getFilterForAvailableColumns(this.preferences.filters, columnsWithMetadata.filter((column) => column.filterable));
            if (isFilterPresetDataChanged ||
                ((_c = (_b = this.preferences.filters) === null || _b === void 0 ? void 0 : _b.and) === null || _c === void 0 ? void 0 : _c.length) !== (prevFilters === null || prevFilters === void 0 ? void 0 : prevFilters.length) ||
                !isEqual(prevFilters, (_d = this.preferences.filters) === null || _d === void 0 ? void 0 : _d.and)) {
                this.save(state.guid, this.preferences);
            }
            state.advancedFiltering.savedFilters = this.getAdvancedFilterPresets(this.preferences.filterPresets, false);
            state.predefinedFilterPresets = state.predefinedFilterPresets.filter((filterPreset) => !isNull(filterPreset.filters));
            const predefinedFilterPresets = state.predefinedFilterPresets
                .map((predefinedFilterPreset) => {
                var _a;
                return ({
                    title: predefinedFilterPreset.title,
                    guid: predefinedFilterPreset.guid,
                    filterData: this.rxRecordGridFilterHelperService.getRecordGridFilterDataFromPredefinedFilter(predefinedFilterPreset.filters, this.rxRecordGridFilterService.deserializeNamedOptions((_a = predefinedFilterPreset.recordGridFilters) !== null && _a !== void 0 ? _a : []))
                });
            })
                .filter((preset) => preset.filterData);
            const builtInPresets = this.getAdvancedFilterPresets(predefinedFilterPresets, true);
            state.advancedFiltering.savedFilters.push(...builtInPresets);
            if (sharedFilterPresets) {
                if (this.getAppliedSharedFilterPresetGuid()) {
                    const appliedSharedFilterPreset = find(sharedFilterPresets, { id: this.getAppliedSharedFilterPresetGuid() });
                    state.advancedFiltering.appliedSharedFilterPreset = appliedSharedFilterPreset;
                    state.advancedFiltering.activeSavedFilter = appliedSharedFilterPreset;
                }
                state.advancedFiltering.savedFilters.push(...sharedFilterPresets);
            }
            const defaultBuiltInFilterPreset = isString(state.defaultFilterPreset)
                ? find(builtInPresets, (builtInPreset) => builtInPreset.id === state.defaultFilterPreset)
                : state.defaultFilterPreset;
            const defaultSharedFilterPreset = find(sharedFilterPresets, (sharedFilterPreset) => sharedFilterPreset.isDefault);
            if (!isEmpty(this.preferences.filters)) {
                observable$ = this.rxRecordGridFilterService
                    .getAdvancedFilterData(this.preferences.filters, state.recordDefinition.fieldDefinitionsById, state.advancedFiltering.recordGridFilterConfigs, state.recordDefinition, state.advancedFiltering.filterOptions, state.associationDescriptors)
                    .pipe(tap((selectedAdvancedFilters) => {
                    // Remove named filter options that do not have any filters left.
                    // These filters could have been removed as a result of removing named filter option,
                    // used by the filter, from the grid.
                    const newSelectedAdvancedFilters = this.getFilterForAvailableNamedFilterOptions(selectedAdvancedFilters, state.namedFilterOptions);
                    state.advancedFiltering.selectedFilters = this.getFiltersForSelectedColumns(newSelectedAdvancedFilters, adaptTableConfig.columns.filter((column) => column.filterable));
                    this.preferences.filters = this.rxRecordGridFilterService.getRecordGridFilterDataFromAdvancedFilter(state.advancedFiltering.selectedFilters, state.recordDefinition.fieldDefinitionsById, state.advancedFiltering.recordGridFilterConfigs);
                    if (state.advancedFiltering.appliedSharedFilterPreset) {
                        this.addExternalPresetToSelectedFilters(state);
                    }
                }));
            }
            else if (this.rxObjectUtilsService.isEmptyObject(this.preferences.filters) &&
                !state.advancedFiltering.appliedSharedFilterPreset) {
                if (defaultSharedFilterPreset && !defaultBuiltInFilterPreset) {
                    state.advancedFiltering.appliedSharedFilterPreset = defaultSharedFilterPreset;
                    state.advancedFiltering.activeSavedFilter = defaultSharedFilterPreset;
                }
            }
            else if (isNull(this.preferences.filters) && !state.advancedFiltering.appliedSharedFilterPreset) {
                if (defaultBuiltInFilterPreset) {
                    const defaultBuildInPresetFilterData = isString(state.defaultFilterPreset)
                        ? defaultBuiltInFilterPreset.filterData
                        : defaultBuiltInFilterPreset;
                    observable$ = this.rxRecordGridFilterService
                        .getAdvancedFilterData(defaultBuildInPresetFilterData, state.recordDefinition.fieldDefinitionsById, state.advancedFiltering.recordGridFilterConfigs, state.recordDefinition, state.advancedFiltering.filterOptions, state.associationDescriptors)
                        .pipe(tap((selectedAdvancedFilters) => {
                        state.advancedFiltering.selectedFilters = this.getFiltersForSelectedColumns(selectedAdvancedFilters, adaptTableConfig.columns);
                        if (isString(state.defaultFilterPreset)) {
                            defaultBuiltInFilterPreset.filters =
                                state.advancedFiltering.selectedFilters;
                            state.advancedFiltering.activeSavedFilter =
                                defaultBuiltInFilterPreset;
                        }
                    }));
                }
                else if (defaultSharedFilterPreset) {
                    state.advancedFiltering.appliedSharedFilterPreset = defaultSharedFilterPreset;
                    state.advancedFiltering.activeSavedFilter = defaultSharedFilterPreset;
                }
            }
            if (state.advancedFiltering.appliedSharedFilterPreset) {
                this.addExternalPresetToSelectedFilters(state);
            }
        }
        return observable$ || of(null);
    }
    applySharedViewPreset(gridState, adaptTableConfig, viewPresetGuid, viewPresetData) {
        if (!this.preferences.viewPresets[viewPresetGuid]) {
            this.preferences.viewPresets[viewPresetGuid] = {
                initial: Object.assign(Object.assign({}, viewPresetData), { viewPresetGuid })
            };
        }
        else {
            // updating initial and keeping user changes
            this.preferences.viewPresets[viewPresetGuid].initial = Object.assign(Object.assign({}, viewPresetData), { viewPresetGuid });
        }
        return this.applyViewPresetInner(viewPresetGuid, adaptTableConfig, gridState);
    }
    applyViewPreset(gridState, adaptTableConfig, viewPresetGuid) {
        const systemViewPreset = gridState.viewPresets.find((preset) => preset.viewPresetGuid === viewPresetGuid);
        if (systemViewPreset && !has(this.preferences.viewPresets, [viewPresetGuid, 'edited'])) {
            // create/update the initial system view preset preferences
            const newViewPresetPreferences = this.createSystemViewPresetPreferences(systemViewPreset, gridState.columnsWithMetadata);
            this.preferences.viewPresets[viewPresetGuid] = { initial: newViewPresetPreferences };
        }
        else if (!this.preferences.viewPresets[viewPresetGuid] && this.selectedViewPresetGuid) {
            // save existing view preset preferences as new custom view preset preferences
            const selectedViewPreset = this.preferences.viewPresets[this.selectedViewPresetGuid];
            this.preferences.viewPresets[viewPresetGuid] = {
                initial: Object.assign(Object.assign({}, cloneDeep(selectedViewPreset.edited || selectedViewPreset.initial)), { viewPresetGuid })
            };
        }
        return this.applyViewPresetInner(viewPresetGuid, adaptTableConfig, gridState);
    }
    applyViewPresetInner(viewPresetGuid, adaptTableConfig, gridState) {
        const viewPresetPreferences = this.preferences.viewPresets[viewPresetGuid];
        const presetToApply = (viewPresetPreferences === null || viewPresetPreferences === void 0 ? void 0 : viewPresetPreferences.edited) || (viewPresetPreferences === null || viewPresetPreferences === void 0 ? void 0 : viewPresetPreferences.initial);
        let observable$ = of(null);
        if (presetToApply) {
            this.selectedViewPresetGuid = presetToApply.viewPresetGuid;
            this.updateColumnsOrder(adaptTableConfig.columns, presetToApply.columns);
            this.updateColumnsVisibility(adaptTableConfig.columns, presetToApply.columns);
            this.setColumnsWidths(adaptTableConfig.columns, presetToApply.columns, adaptTableConfig.columnResizeMode);
            this.updateGridSorting(presetToApply, adaptTableConfig);
            observable$ = this.rxRecordGridFilterService
                .getAdvancedFilterData(presetToApply.filters, gridState.recordDefinition.fieldDefinitionsById, gridState.advancedFiltering.recordGridFilterConfigs, gridState.recordDefinition, gridState.advancedFiltering.filterOptions, gridState.associationDescriptors)
                .pipe(tap((selectedAdvancedFilters) => {
                const newSelectedAdvancedFilters = this.getFilterForAvailableNamedFilterOptions(selectedAdvancedFilters, gridState.namedFilterOptions);
                gridState.advancedFiltering.selectedFilters = this.getFiltersForSelectedColumns(newSelectedAdvancedFilters, adaptTableConfig.columns.filter((column) => column.filterable));
            }));
        }
        return observable$;
    }
    isCurrentViewPresetEdited() {
        var _a;
        return Boolean((_a = this.preferences.viewPresets[this.selectedViewPresetGuid]) === null || _a === void 0 ? void 0 : _a.edited);
    }
    addExternalPresetToSelectedFilters(state) {
        const selectedFilter = cloneDeep(state.advancedFiltering.selectedFilters);
        selectedFilter.push({
            filterOptionId: RX_RECORD_GRID.externalPresetFilterOptionId,
            value: state.advancedFiltering.appliedSharedFilterPreset.id
        });
        state.advancedFiltering.selectedFilters = selectedFilter;
    }
    createSystemViewPresetPreferences(sharedViewPreset, columnsWithMetadata) {
        const recordGridFilterData = this.rxRecordGridFilterHelperService.getRecordGridFilterDataFromPredefinedFilter(sharedViewPreset.filters, sharedViewPreset.recordGridFilters
            ? this.rxRecordGridFilterService.deserializeNamedOptions(sharedViewPreset.recordGridFilters)
            : []);
        const columns = sharedViewPreset.columnViewPresets
            .sort((a, b) => a.index - b.index)
            .map((columnViewPreset, index) => {
            var _a, _b;
            const width = has(columnViewPreset, 'width')
                ? columnViewPreset.width
                : (_b = (_a = find(columnsWithMetadata, { fieldId: columnViewPreset.fieldId })) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : null;
            const result = Object.assign(Object.assign({}, omit(columnViewPreset, 'sortable')), { index,
                width });
            if (columnViewPreset.sortable) {
                result.sort = {
                    priority: 0,
                    direction: columnViewPreset.sortable.direction
                };
            }
            return result;
        });
        return cloneDeep({
            columns,
            filters: recordGridFilterData,
            viewPresetGuid: sharedViewPreset.viewPresetGuid
        });
    }
    deleteViewPreset(viewPresetGuid) {
        delete this.preferences.viewPresets[viewPresetGuid];
    }
    isExistingViewPreset(viewPresetGuid) {
        return has(this.preferences.viewPresets, viewPresetGuid);
    }
    discardViewPresetChanges(viewPresetGuid) {
        var _a;
        (_a = this.preferences.viewPresets[viewPresetGuid]) === null || _a === void 0 ? true : delete _a.edited;
    }
    updateGridSorting(presetPreferences, adaptTableConfig) {
        let columnSortMeta = this.getColumnSortMeta(presetPreferences.columns);
        columnSortMeta = filter$1(columnSortMeta, (sortMeta) => some(adaptTableConfig.columns, (tableColumn) => tableColumn.sortable && tableColumn.field === sortMeta.field));
        adaptTableConfig.multiSortMeta = columnSortMeta;
    }
    getAdvancedFilterPresets(filterPresets, isCreatedByOtherUsers) {
        return filterPresets
            .map((filterPreset) => {
            const advancedFilterPreset = {
                id: filterPreset.guid,
                name: filterPreset.title,
                filters: null,
                filterData: filterPreset.filterData,
                isCreatedByOtherUsers
            };
            if (filterPreset.appliedSharedFilterPresetGuid) {
                advancedFilterPreset.appliedSharedFilterPresetGuid = filterPreset.appliedSharedFilterPresetGuid;
                advancedFilterPreset.filters = [
                    {
                        filterOptionId: RX_RECORD_GRID.externalPresetFilterOptionId,
                        value: filterPreset.appliedSharedFilterPresetGuid
                    }
                ];
            }
            return advancedFilterPreset;
        })
            .sort((savedFilter1, savedFilter2) => savedFilter1.name.localeCompare(savedFilter2.name));
    }
    getColumnsPreferences({ columns, multiSortMeta }) {
        const columnPreferences = columns.map(({ field, hidden, width }, index) => {
            const column = {
                fieldId: field,
                index,
                visible: !hidden,
                width
            };
            return column;
        });
        this.updateColumnSortPreferences(columnPreferences, multiSortMeta);
        return columnPreferences;
    }
    getPreferencesFilterPresets(savedFilter, fieldDefinitionsById, recordGridFilterConfigs) {
        const filterPreset = {
            guid: savedFilter.id,
            title: savedFilter.name,
            filterData: savedFilter.filters
                ? this.rxRecordGridFilterService.getRecordGridFilterDataFromAdvancedFilter(savedFilter.filters, fieldDefinitionsById, recordGridFilterConfigs)
                : savedFilter.filterData
        };
        if (savedFilter.appliedSharedFilterPresetGuid) {
            filterPreset.appliedSharedFilterPresetGuid = savedFilter.appliedSharedFilterPresetGuid;
        }
        return filterPreset;
    }
    getVisibleCardFieldIds({ columns, multiSortMeta }) {
        this.updateColumnSortPreferences(this.preferences.columns, multiSortMeta);
        return columns.filter((column) => !column.hidden).map((column) => parseInt(column.field, 10) || column.field);
    }
    updateColumnSortPreferences(columns, sortMeta) {
        if (sortMeta) {
            columns.forEach((column) => {
                delete column.sort;
            });
            sortMeta.forEach(({ field, order }, index) => {
                const sortedColumn = columns.find((column) => column.fieldId === field);
                if (sortedColumn) {
                    sortedColumn.sort = {
                        priority: index,
                        direction: this.recordGridConfigUtilsService.getColumnSortDirection(order)
                    };
                }
            });
        }
    }
    save(guid, preferences) {
        if (guid) {
            const data = {
                preferences: JSON.stringify(preferences),
                componentTypeName: RX_RECORD_GRID.type,
                version: RX_RECORD_GRID.version,
                componentId: guid
            };
            this.rxUserPreferencesService.setUiComponentPreferences(data, guid).subscribe();
        }
    }
    sortColumnsConfigs(gridColumns) {
        this.updateColumnsOrder(gridColumns, this.preferences.columns);
    }
    updateColumnsOrder(gridColumns, columnsPreferences) {
        const columnIndexesMap = reduce(gridColumns, (result, column, columnIndex) => {
            const columnSavedPreferences = find(columnsPreferences, (columnPreferences) => columnPreferences.fieldId === column.field);
            if (columnSavedPreferences) {
                result[column.field] = columnSavedPreferences.index;
            }
            else {
                result[column.field] = columnIndex;
            }
            return result;
        }, {});
        gridColumns.sort((column1, column2) => columnIndexesMap[column1.field] - columnIndexesMap[column2.field]);
    }
    setColumnsVisibility(gridColumns, columnsWithMetadata) {
        const columnsPreferences = this.preferences.columns;
        if (isEmpty(columnsPreferences)) {
            gridColumns.forEach((gridColumn) => {
                const columnWithMetadata = find(columnsWithMetadata, (column) => column.fieldId === gridColumn.field);
                gridColumn.hidden = columnWithMetadata ? !columnWithMetadata.visible : false;
            });
        }
        else {
            this.updateColumnsVisibility(gridColumns, columnsPreferences);
        }
    }
    updateColumnsVisibility(gridColumns, columnsPreferences) {
        gridColumns.forEach((column) => {
            const preferences = find(columnsPreferences, (columnPreferences) => columnPreferences.fieldId === column.field);
            if (preferences) {
                column.hidden = !preferences.visible;
            }
        });
    }
    setColumnsWidths(gridColumns, columnsPreferences, columnResizeMode) {
        if (columnsPreferences.length) {
            gridColumns.forEach((column) => {
                const preferences = find(columnsPreferences, { fieldId: column.field });
                // Default measure unit of native html table is px, but outdated user preferences use %.
                // Only px units are supported in Expand mode.
                if (preferences) {
                    const isColumnWidthInPixels = endsWith(preferences.width, 'px');
                    if (columnResizeMode === ResizeMode.Expand && !isColumnWidthInPixels) {
                        column.width = null;
                        column.minWidth = null;
                    }
                    else {
                        column.width = /[0-9]+$/.test(preferences.width) ? `${preferences.width}%` : preferences.width;
                        if (isColumnWidthInPixels && parseInt(column.width) < 45) {
                            column.minWidth = column.width;
                        }
                    }
                }
            });
        }
    }
    setCardFieldsVisibility(gridColumns) {
        const visibleCardFieldIds = this.preferences.visibleCardFieldIds;
        if (isEmpty(visibleCardFieldIds)) {
            const defaultVisibleColumnsCount = 5;
            let visibleColumnsCount = 0;
            gridColumns.forEach((column) => {
                if (visibleColumnsCount >= defaultVisibleColumnsCount) {
                    column.hidden = true;
                    return;
                }
                if (!column.hidden) {
                    visibleColumnsCount++;
                }
            });
        }
        else {
            gridColumns.forEach((column) => (column.hidden = !some(visibleCardFieldIds, (field) => String(field) === column.field)));
        }
    }
    getColumnSortMeta(columnPreferences) {
        return flow((columns) => filter$1(columns, 'sort'), (columns) => sortBy(columns, 'sort.priority'), (columns) => map$1(columns, (column) => ({
            field: column.fieldId,
            order: this.recordGridConfigUtilsService.getColumnSortOrder(column.sort.direction)
        })))(columnPreferences);
    }
    getFiltersForSelectedColumns(advancedFilters, gridColumns) {
        return advancedFilters.filter((advancedFilter) => some(gridColumns, { field: advancedFilter.filterOptionId }));
    }
    getFilterForAvailableNamedFilterOptions(advancedFilters, availableNamedFilters) {
        return advancedFilters
            .map((advancedFilter) => {
            advancedFilter.value.namedOptions = !isEmpty(availableNamedFilters)
                ? advancedFilter.value.namedOptions.filter((namedFilterOptionGuid) => some(availableNamedFilters[Number(advancedFilter.filterOptionId)], { guid: namedFilterOptionGuid }))
                : [];
            return advancedFilter;
        })
            .filter((advancedFilter) => !RxRecordGridAdvancedFilterValue.isEmptyWithRange(advancedFilter.value));
    }
    saveViewPreset(viewPresetGuid) {
        const preset = this.preferences.viewPresets[viewPresetGuid];
        if (preset === null || preset === void 0 ? void 0 : preset.edited) {
            preset.initial = cloneDeep(preset.edited);
            delete preset.edited;
        }
    }
    getSharedViewPresetData() {
        const selectedViewPreset = this.preferences.viewPresets[this.selectedViewPresetGuid];
        const presetData = selectedViewPreset.edited || selectedViewPreset.initial;
        return {
            columns: presetData.columns,
            filters: presetData.filters
        };
    }
}
RxRecordGridUserPreferencesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridUserPreferencesService, deps: [{ token: RxRecordGridConfigUtilsService }, { token: i1$1.RxUserPreferencesService }, { token: RxRecordGridFilterService }, { token: RxRecordGridFilterHelperService }, { token: i2$1.RxObjectUtilsService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridUserPreferencesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridUserPreferencesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridUserPreferencesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: RxRecordGridConfigUtilsService }, { type: i1$1.RxUserPreferencesService }, { type: RxRecordGridFilterService }, { type: RxRecordGridFilterHelperService }, { type: i2$1.RxObjectUtilsService }]; } });

var RowSelectionMode;
(function (RowSelectionMode) {
    RowSelectionMode["Multiple"] = "multiple";
    RowSelectionMode["Single"] = "single";
})(RowSelectionMode || (RowSelectionMode = {}));

class CardLayoutCellHeaderComponent {
    constructor(modalService, translateService) {
        this.modalService = modalService;
        this.translateService = translateService;
        this.sort = new EventEmitter();
    }
    onSortMenuItemClick() {
        this.multiSortMeta = this.adaptTable.multiSortMeta || [];
        this.openDialog({
            title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.cards.sort-by.dialog.title'),
            content: this.cardLayoutSortModalTemplate
        }).catch(() => { });
    }
    getSortableColumns() {
        return this.columns
            .filter((column) => this.adaptTable.isSortableColumn(column))
            .sort((column1, column2) => column1.header.localeCompare(column2.header));
    }
    onSortAscClick(column) {
        this.changeSort(column, SortOrder.Asc);
    }
    onSortDescClick(column) {
        this.changeSort(column, SortOrder.Desc);
    }
    changeSort(column, order) {
        const sortIndex = this.getColumnSortIndex(column);
        const sort = this.multiSortMeta[sortIndex];
        if (sort) {
            if (sort.order === order) {
                this.multiSortMeta.splice(sortIndex, 1);
            }
            else {
                sort.order = order;
            }
        }
        else {
            this.multiSortMeta.push({
                field: column.field,
                order
            });
        }
    }
    getColumnSort(column) {
        return this.multiSortMeta[this.getColumnSortIndex(column)];
    }
    getColumnSortIndex(column) {
        return this.multiSortMeta.findIndex((sort) => sort.field === column.field);
    }
    hasColumnSortOrder(column, order) {
        const sort = this.getColumnSort(column);
        return sort ? sort.order === order : false;
    }
    getSortAscBtnClass(column) {
        return this.getSortBtnClass(column, SortOrder.Asc);
    }
    getSortDescBtnClass(column) {
        return this.getSortBtnClass(column, SortOrder.Desc);
    }
    getSortBtnClass(column, order) {
        const isActiveSortDesc = this.hasColumnSortOrder(column, order);
        return { 'btn-success': isActiveSortDesc, 'btn-secondary': !isActiveSortDesc };
    }
    clearAllSorting() {
        this.multiSortMeta = [];
    }
    applySorting() {
        this.sort.emit(this.multiSortMeta);
    }
    getCurrentSortingSummary() {
        const ordersTitles = {
            [SortOrder.Asc]: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.cards.sort-by.sort.ascending'),
            [SortOrder.Desc]: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.cards.sort-by.sort.descending')
        };
        return this.multiSortMeta
            .map((sortMeta, index) => {
            const column = this.columns.find((c) => c.field === sortMeta.field);
            return `${index + 1}. ${column.header} (${ordersTitles[sortMeta.order]})`;
        })
            .join('\n');
    }
}
CardLayoutCellHeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: CardLayoutCellHeaderComponent, deps: [{ token: i1.AdaptModalService }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
CardLayoutCellHeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: CardLayoutCellHeaderComponent, selector: "rx-card-layout-cell-header", inputs: { title: "title", columns: "columns", adaptTable: "adaptTable", openDialog: "openDialog" }, outputs: { sort: "sort" }, viewQueries: [{ propertyName: "cardLayoutSortModalTemplate", first: true, predicate: ["cardLayoutSortModalTemplate"], descendants: true }], ngImport: i0, template: "{{ title }}\n\n<div class=\"dropdown header-cell-menu-btn\" adaptDropdown [appendToBody]=\"true\" [restoreFocusAfterClose]=\"true\">\n  <button\n    id=\"card-column-menu-dropdown-toggle\"\n    class=\"d-icon-ellipsis adapt-table-sort-menu__kebab py-2 btn btn-link\"\n    type=\"button\"\n    adaptDropdownToggle\n    [showCaret]=\"false\"\n  ></button>\n\n  <div class=\"dropdown-menu\" aria-labelledby=\"card-column-menu-dropdown-toggle\" adaptDropdownMenu tabindex=\"0\">\n    <button class=\"dropdown-item\" type=\"button\" (click)=\"onSortMenuItemClick()\">\n      {{ 'com.bmc.arsys.rx.client.view-components.record-grid.card-column-menu.items.sort-by.label' | translate }}\n    </button>\n  </div>\n</div>\n\n<ng-template #cardLayoutSortModalTemplate let-close=\"close\" let-getData=\"getData\">\n  <div class=\"modal-body rx-record-grid-sort-by-dialog\">\n    <div class=\"rx-card-fields\">\n      <div class=\"rx-card-fields__headers\">\n        <div class=\"rx-card-fields__headers-field\">\n          {{\n            'com.bmc.arsys.rx.client.view-components.record-grid.cards.sort-by.dialog.field.column.title' | translate\n          }}\n        </div>\n        <div class=\"rx-card-fields__headers-order\">\n          {{\n            'com.bmc.arsys.rx.client.view-components.record-grid.cards.sort-by.dialog.order.column.title' | translate\n          }}\n        </div>\n      </div>\n      <div class=\"rx-card-field\" *ngFor=\"let column of getSortableColumns()\">\n        <div class=\"rx-card-field__name\">{{ column.header }}</div>\n        <div class=\"rx-card-field__order\">\n          <div class=\"btn-group\">\n            <button class=\"btn btn-xs\" [ngClass]=\"getSortDescBtnClass(column)\" (click)=\"onSortDescClick(column)\">\n              <span class=\"d-icon-arrow_down\"></span>\n            </button>\n            <button class=\"btn btn-xs\" [ngClass]=\"getSortAscBtnClass(column)\" (click)=\"onSortAscClick(column)\">\n              <span class=\"d-icon-arrow_up\"></span>\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div>\n      <textarea\n        rows=\"4\"\n        disabled\n        class=\"form-control rx-sort-summary\"\n        title=\"summary\"\n        [value]=\"getCurrentSortingSummary()\"\n        [placeholder]=\"\n          'com.bmc.arsys.rx.client.view-components.record-grid.cards.sort-by.dialog.field.summary.empty.title'\n            | translate\n        \"\n      ></textarea>\n    </div>\n  </div>\n  <div class=\"modal-footer\">\n    <button class=\"btn btn-secondary btn-sm\" (click)=\"clearAllSorting()\">\n      {{\n        'com.bmc.arsys.rx.client.view-components.record-grid.cards.sort-by.dialog.clear-all.button.label' | translate\n      }}\n    </button>\n    <button class=\"btn btn-primary btn-sm\" (click)=\"applySorting(); close()\">\n      {{ 'com.bmc.arsys.rx.client.common.apply.label' | translate }}\n    </button>\n    <button class=\"btn btn-secondary btn-sm\" (click)=\"close()\">\n      {{ 'com.bmc.arsys.rx.client.common.cancel.label' | translate }}\n    </button>\n  </div>\n</ng-template>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.header-cell-menu-btn{position:absolute;right:0;top:0}.rx-record-grid-sort-by-dialog .rx-card-fields{border:1px solid #d6d7d8;display:flex;flex-direction:column;height:370px;overflow-y:auto}.rx-record-grid-sort-by-dialog .rx-card-fields__headers{font-weight:var(--font-weight-bold);display:flex;height:35px;align-items:center;border-bottom:1px solid #d6d7d8;color:#666;flex-shrink:0}.rx-record-grid-sort-by-dialog .rx-card-field{display:flex;border-bottom:1px solid #d6d7d8;align-items:center;height:35px;flex-shrink:0}.rx-record-grid-sort-by-dialog .rx-card-field:last-child{border-bottom:none}.rx-record-grid-sort-by-dialog .rx-card-field__name{flex:3;padding-left:10px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.rx-record-grid-sort-by-dialog .rx-card-field__order{flex:1;padding-left:5px}.rx-record-grid-sort-by-dialog .rx-card-fields__headers-field{flex:3;padding-left:10px}.rx-record-grid-sort-by-dialog .rx-card-fields__headers-order{flex:1;padding-left:5px}.rx-record-grid-sort-by-dialog .rx-sort-summary{margin-top:15px;resize:none}\n"], components: [{ type: i1.AdaptDropdownDirective, selector: "adapt-dropdown, [adaptDropdown]", inputs: ["autoClose", "customClass", "closeOnEscape", "placement", "animationPlacement", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "focusNextElementAfterClose", "appendToBody", "appendTo", "positionTo", "anchorPositionTrackingIntervalMs", "enableAnchorPositionTracking", "recalculatePositionOnElementResize", "setMobileState", "mobileView"], outputs: ["onOpen", "onClose", "anchorPositionChange", "popupAnimationDone"], exportAs: ["adaptDropdown"] }], directives: [{ type: i1.AdaptDropdownToggleDirective, selector: "[adaptDropdownToggle]", inputs: ["showCaret", "dropdownTogglerType"] }, { type: i1.AdaptDropdownMenuDirective, selector: "[adaptDropdownMenu]" }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: CardLayoutCellHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-card-layout-cell-header',
                    templateUrl: './card-layout-cell-header.component.html',
                    styleUrls: ['card-layout-cell-header.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.AdaptModalService }, { type: i2.TranslateService }]; }, propDecorators: { title: [{
                type: Input
            }], columns: [{
                type: Input
            }], adaptTable: [{
                type: Input
            }], openDialog: [{
                type: Input
            }], sort: [{
                type: Output
            }], cardLayoutSortModalTemplate: [{
                type: ViewChild,
                args: ['cardLayoutSortModalTemplate']
            }] } });

class GridCardLayoutDirective {
    constructor(adaptTable, ngZone, renderer) {
        this.adaptTable = adaptTable;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.changedCardLayout = new EventEmitter();
        this.hasCardLayout = false;
        this._hasViewInitialized = false;
    }
    set cardLayoutWidth(value) {
        this._cardLayoutWidth = value;
        if (this._hasViewInitialized) {
            const { offsetWidth } = this.renderer.selectRootElement(this.adaptTable.el.nativeElement, true);
            this.changeTableCardLayout(offsetWidth);
        }
    }
    get cardLayoutWidth() {
        return this._cardLayoutWidth;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            const recordGrid = this.renderer.selectRootElement(this.recordGridElementRef.nativeElement, true);
            this.changeTableCardLayout(recordGrid.offsetWidth);
        });
        this.ngZone.runOutsideAngular(() => {
            this.resizeSensor = new ResizeSensor(this.recordGridElementRef.nativeElement, (size) => {
                this.ngZone.run(() => {
                    this.changeTableCardLayout(size.width);
                });
            });
        });
        this._hasViewInitialized = true;
    }
    changeTableCardLayout(gridWidth) {
        const hasCardLayout = gridWidth <= this.cardLayoutWidth;
        if (this.hasCardLayout === hasCardLayout || !gridWidth) {
            return;
        }
        this.hasCardLayout = hasCardLayout;
        const adaptTable = this.adaptTable;
        this.scrollToFirstVisibleRow();
        if (hasCardLayout) {
            this.renderer.addClass(adaptTable.el.nativeElement, 'rx-table-card-layout');
        }
        else {
            this.renderer.removeClass(adaptTable.el.nativeElement, 'rx-table-card-layout');
        }
        // fix for updating margin in header. Just primeng flaw
        adaptTable.tableService.onValueChange(adaptTable.value);
        this.changedCardLayout.emit({
            cardLayoutColumns: hasCardLayout ? this.getCardLayoutColumns() : null
        });
    }
    getCardLayoutColumns() {
        return [
            {
                field: 'fields',
                header: 'Fields',
                filterable: false,
                sortable: false,
                headerTitleTemplate: this.cardLayoutFieldsHeaderTemplate,
                width: '35%',
                dataCellClass: this.getDataCellClass.bind(this),
                cellTemplate: this.cardLayoutFieldsDataCellTemplate,
                testId: 'fields-column'
            },
            {
                field: 'fields',
                header: 'Values',
                filterable: false,
                sortable: false,
                headerTitleTemplate: this.cardLayoutValuesHeaderTemplate,
                width: '65%',
                dataCellClass: this.getDataCellClass.bind(this),
                cellTemplate: this.cardLayoutValuesDataCellTemplate,
                testId: 'values-column'
            }
        ];
    }
    getDataCellClass() {
        return `${this.recordGridGetDataCellClass()} rx-card-layout-data-cell`;
    }
    scrollToFirstVisibleRow() {
        const adaptTable = this.adaptTable;
        if (adaptTable.scrollable) {
            const scrollableBody = this.renderer
                .selectRootElement(adaptTable.el.nativeElement, true)
                .querySelector('.ui-table-scrollable-body');
            const scrollableBodyScrollTop = scrollableBody && scrollableBody.scrollTop;
            if (scrollableBodyScrollTop) {
                const firstVisibleRow = adaptTable.dataRows.find((dataRow) => {
                    const rowEl = dataRow.element.nativeElement;
                    return rowEl.offsetTop + rowEl.offsetHeight >= scrollableBodyScrollTop;
                });
                if (firstVisibleRow) {
                    let rowEl = firstVisibleRow.element.nativeElement;
                    const scrollRowProportion = (scrollableBodyScrollTop - rowEl.offsetTop) / rowEl.offsetHeight;
                    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
                        rowEl = firstVisibleRow.element.nativeElement;
                        scrollableBody.scrollTop = rowEl.offsetTop + rowEl.offsetHeight * scrollRowProportion;
                    });
                }
            }
        }
    }
    ngOnDestroy() {
        this.resizeSensor.detach();
    }
}
GridCardLayoutDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: GridCardLayoutDirective, deps: [{ token: i1$7.AdaptTableComponent, host: true }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
GridCardLayoutDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.1.3", type: GridCardLayoutDirective, selector: "[rxCardLayout]", inputs: { cardLayoutFieldsHeaderTemplate: "cardLayoutFieldsHeaderTemplate", cardLayoutValuesHeaderTemplate: "cardLayoutValuesHeaderTemplate", cardLayoutFieldsDataCellTemplate: "cardLayoutFieldsDataCellTemplate", cardLayoutValuesDataCellTemplate: "cardLayoutValuesDataCellTemplate", recordGridGetDataCellClass: ["cardLayoutGetDataCellClass", "recordGridGetDataCellClass"], recordGridElementRef: ["cardLayoutRecordGridElementRef", "recordGridElementRef"], cardLayoutWidth: "cardLayoutWidth" }, outputs: { changedCardLayout: "changedCardLayout" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: GridCardLayoutDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rxCardLayout]'
                }]
        }], ctorParameters: function () { return [{ type: i1$7.AdaptTableComponent, decorators: [{
                    type: Host
                }] }, { type: i0.NgZone }, { type: i0.Renderer2 }]; }, propDecorators: { cardLayoutFieldsHeaderTemplate: [{
                type: Input
            }], cardLayoutValuesHeaderTemplate: [{
                type: Input
            }], cardLayoutFieldsDataCellTemplate: [{
                type: Input
            }], cardLayoutValuesDataCellTemplate: [{
                type: Input
            }], recordGridGetDataCellClass: [{
                type: Input,
                args: ['cardLayoutGetDataCellClass']
            }], recordGridElementRef: [{
                type: Input,
                args: ['cardLayoutRecordGridElementRef']
            }], cardLayoutWidth: [{
                type: Input
            }], changedCardLayout: [{
                type: Output
            }] } });

class CellDisplayPropertiesDirective {
    constructor(rxExpressionEvaluatorService, rxObjectUtilsService) {
        this.rxExpressionEvaluatorService = rxExpressionEvaluatorService;
        this.rxObjectUtilsService = rxObjectUtilsService;
        this.evaluationData = {};
    }
    ngOnInit() {
        this.updateCellClasses();
    }
    ngOnChanges(changes) {
        if (!changes.rxCellDisplayPropsDataItem.firstChange &&
            changes.rxCellDisplayPropsDataItem.currentValue !== changes.rxCellDisplayPropsDataItem.previousValue) {
            this.updateCellClasses();
        }
    }
    getActiveProps(items) {
        return (items.find((props) => this.rxExpressionEvaluatorService.tryEvaluate(props.fieldValueCondition, this.evaluationData)) || null);
    }
    getCellCssClasses(props) {
        const result = [];
        if (!props.displayAsBadge) {
            if (props.bold) {
                result.push('font-weight-bold');
            }
            if (props.italic) {
                result.push('font-italic');
            }
            if (props.fontSize === RxGridCellFontSize.Small) {
                result.push('small');
            }
            else if (props.fontSize === RxGridCellFontSize.Large) {
                result.push('large');
            }
            if (props.textColor) {
                result.push(RxGridCellFontColorCssMap[props.textColor]);
            }
            if (props.backgroundColor) {
                result.push(RxGridCellBgColorCssMap[props.backgroundColor]);
            }
            if (props.icon) {
                if (props.iconPosition === RxGridCellIconPosition.ReplaceText) {
                    result.push(`d-icon-${props.icon}`);
                }
                else {
                    result.push(`d-icon-${props.iconPosition}-${props.icon}`);
                }
            }
        }
        return result;
    }
    getSpanCssClasses(props) {
        if (props.displayAsBadge) {
            return ['badge', `badge-${props.badgeColor}`];
        }
        else if (props.iconPosition === RxGridCellIconPosition.ReplaceText) {
            return ['hidden'];
        }
        else {
            return [];
        }
    }
    updateCellClasses() {
        var _a;
        if ((_a = this.rxCellDisplayProps) === null || _a === void 0 ? void 0 : _a.length) {
            let cssClasses = '';
            const expandedRxCellDisplayPropsDataItem = Object.assign(Object.assign({}, this.rxCellDisplayPropsDataItem), this.rxObjectUtilsService.expandProperties(this.rxCellDisplayPropsDataItem));
            set(this.evaluationData, `view.components.grid.clickableRow`, expandedRxCellDisplayPropsDataItem);
            const activeProps = this.getActiveProps(this.rxCellDisplayProps);
            if (activeProps) {
                const cellClasses = this.getCellCssClasses(activeProps);
                cssClasses = cellClasses.join(' ');
            }
            if (this.rxCellDisplayPropsBadgeElem) {
                const spanClasses = activeProps ? this.getSpanCssClasses(activeProps) : [];
                this.rxCellDisplayPropsBadgeElem.classList.value = '';
                this.rxCellDisplayPropsBadgeElem.classList.add(...spanClasses);
            }
            this.cssClasses = cssClasses;
        }
    }
}
CellDisplayPropertiesDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: CellDisplayPropertiesDirective, deps: [{ token: i1$4.RxExpressionEvaluatorService }, { token: i2$1.RxObjectUtilsService }], target: i0.ɵɵFactoryTarget.Directive });
CellDisplayPropertiesDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.1.3", type: CellDisplayPropertiesDirective, selector: "[rxCellDisplayProps]", inputs: { rxCellDisplayProps: "rxCellDisplayProps", rxCellDisplayPropsBadgeElem: "rxCellDisplayPropsBadgeElem", rxCellDisplayPropsDataItem: "rxCellDisplayPropsDataItem" }, host: { properties: { "class": "this.cssClasses" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: CellDisplayPropertiesDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rxCellDisplayProps]'
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxExpressionEvaluatorService }, { type: i2$1.RxObjectUtilsService }]; }, propDecorators: { rxCellDisplayProps: [{
                type: Input
            }], rxCellDisplayPropsBadgeElem: [{
                type: Input
            }], rxCellDisplayPropsDataItem: [{
                type: Input
            }], cssClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });

class RecordGridComponent extends BaseViewComponent {
    constructor(adaptDeviceDetectionService, adaptModalService, changeDetector, datePipe, decimalPipe, ngZone, rxAssociationInstanceDataPageService, rxBooleanPipe, rxCurrentUserService, rxExpressionEvaluatorService, rxFieldDefinitionService, rxGridConfiguratorService, rxGuidService, rxLogService, rxNotificationService, rxObjectUtilsService, rxRecordDefinitionCacheService, rxRecordDefinitionService, rxRecordGridAdvancedFilteringService, rxRecordGridConfigUtilsService, rxRecordGridFilterConfigService, rxRecordGridFilterService, rxRecordGridFilterHelperService, rxRecordGridSharedFilterPresetsCacheService, rxRecordGridUserPreferencesService, rxRecordGridUtilsService, rxRecordInstanceDataPageService, rxRecordInstanceService, rxViewActionService, rxViewActionUtilsService, translateService, elementRef, rxStringService, rxGlobalEventsService, pageComponent, runtimeViewCanvasItemComponent) {
        super();
        this.adaptDeviceDetectionService = adaptDeviceDetectionService;
        this.adaptModalService = adaptModalService;
        this.changeDetector = changeDetector;
        this.datePipe = datePipe;
        this.decimalPipe = decimalPipe;
        this.ngZone = ngZone;
        this.rxAssociationInstanceDataPageService = rxAssociationInstanceDataPageService;
        this.rxBooleanPipe = rxBooleanPipe;
        this.rxCurrentUserService = rxCurrentUserService;
        this.rxExpressionEvaluatorService = rxExpressionEvaluatorService;
        this.rxFieldDefinitionService = rxFieldDefinitionService;
        this.rxGridConfiguratorService = rxGridConfiguratorService;
        this.rxGuidService = rxGuidService;
        this.rxLogService = rxLogService;
        this.rxNotificationService = rxNotificationService;
        this.rxObjectUtilsService = rxObjectUtilsService;
        this.rxRecordDefinitionCacheService = rxRecordDefinitionCacheService;
        this.rxRecordDefinitionService = rxRecordDefinitionService;
        this.rxRecordGridAdvancedFilteringService = rxRecordGridAdvancedFilteringService;
        this.rxRecordGridConfigUtilsService = rxRecordGridConfigUtilsService;
        this.rxRecordGridFilterConfigService = rxRecordGridFilterConfigService;
        this.rxRecordGridFilterService = rxRecordGridFilterService;
        this.rxRecordGridFilterHelperService = rxRecordGridFilterHelperService;
        this.rxRecordGridSharedFilterPresetsCacheService = rxRecordGridSharedFilterPresetsCacheService;
        this.rxRecordGridUserPreferencesService = rxRecordGridUserPreferencesService;
        this.rxRecordGridUtilsService = rxRecordGridUtilsService;
        this.rxRecordInstanceDataPageService = rxRecordInstanceDataPageService;
        this.rxRecordInstanceService = rxRecordInstanceService;
        this.rxViewActionService = rxViewActionService;
        this.rxViewActionUtilsService = rxViewActionUtilsService;
        this.translateService = translateService;
        this.elementRef = elementRef;
        this.rxStringService = rxStringService;
        this.rxGlobalEventsService = rxGlobalEventsService;
        this.pageComponent = pageComponent;
        this.runtimeViewCanvasItemComponent = runtimeViewCanvasItemComponent;
        this.dataLoaded = new EventEmitter();
        this.isExportInProgress = false;
        this.lastPropertySelection = [];
        this.adaptTableConfig = {
            data: [],
            columns: [],
            columnResizeMode: ResizeMode.Fit,
            cardLayoutColumns: null,
            bordered: true,
            scrollable: true,
            striped: false,
            toolbarConfig: {
                counter: false,
                quickFilter: true,
                leftCustomSection: true,
                leftCustomSectionTemplate: null,
                filter: true,
                filterTemplate: null,
                filterResults: false,
                filterResultsTemplate: null,
                rightCustomSection: false,
                rightCustomSectionTemplate: null,
                visibleColumnsMenu: true,
                visibleColumnsMenuTemplate: null,
                quickFilterTriggerable: true,
                export: {
                    exportTypes: [{ type: ExportType.CSV }],
                    showExportForSelected: true
                }
            },
            filterable: false,
            selectedItems: [],
            filters: {},
            rows: 50,
            first: 0,
            multiSortMeta: null,
            rowSelectionMode: null,
            isLoadingData: false,
            totalRecords: null,
            primaryKey: null,
            isLoadingMoreData: false,
            texts: null,
            expandedGroupsKeys: {},
            virtualScroll: true,
            virtualRowHeight: RX_RECORD_GRID.defaultRowHeight
        };
        this.actionButtons = null;
        this.adaptTableHeaderSelectionMode = AdaptTableHeaderSelectionMode.Chunk;
        this.api = {
            applyViewPreset: this.applyViewPreset.bind(this),
            shareViewPreset: this.shareViewPreset.bind(this),
            refresh: this.refresh.bind(this),
            setFilter: this.setFilter.bind(this),
            deleteViewPreset: this.deleteViewPreset.bind(this),
            discardViewPresetChanges: this.discardViewPresetChanges.bind(this),
            getColumns: this.getColumns.bind(this),
            getRecordDefinitionName: this.getRecordDefinitionName.bind(this),
            getSelectedRows: this.getSelectedRows.bind(this),
            getFirstSelectedRow: this.getFirstSelectedRow.bind(this),
            getSelectedRowCount: this.getSelectedRowCount.bind(this),
            setSelectedRows: this.onRowsSelectionChange.bind(this),
            getVisibleRows: this.getVisibleRows.bind(this),
            saveViewPreset: this.saveViewPreset.bind(this),
            applyFilters: this.applyFilters.bind(this)
        };
        this.filteredVisibleColumns = [];
        this.getDataCellClassBind = this.getDataCellClass.bind(this);
        this.gridEvents = {
            cellClick: (gridRow, columnId) => {
                const columnWithActions = this.state.columnsWithMetadata.find((column) => column.fieldId === columnId);
                this.addSelectionFieldOptionNames(gridRow);
                gridRow = this.expandRowProperties(gridRow);
                this.state.lastActionRow = gridRow;
                this.notifyPropertyChanged('clickableRow', gridRow, null);
                this.executeViewActions(columnWithActions.guid, get(columnWithActions, 'actions'), gridRow).catch(noop);
            },
            cellKeyDown: (event, gridRow, columnId) => {
                if (includes(['Space', 'Enter'], event.code)) {
                    this.gridEvents.cellClick(gridRow, columnId);
                    event.preventDefault();
                }
            }
        };
        this.isFilterBySelectionButtonVisible = false;
        this.isUserAllowedToDeleteRecords = false;
        this.openSortByDialog = this.openSortByDialogFn.bind(this);
        this.rowActionButtons = null;
        this.rowSelectionChanged = new BehaviorSubject([]);
        this.selectedFilteredRowsCount = 0;
        this.shouldDisplayActionButtons = false;
        this.showCellTooltip = false;
        this.sortedColumnsByTitle = [];
        this.state = {
            actionButtons: [],
            rowActionButtons: [],
            lastActionRow: null,
            associatedRecordId: null,
            associatedRoleName: null,
            associatedRecordNodeSide: null,
            associationDefinitionName: null,
            bordered: true,
            cardLayoutWidth: null,
            columns: [],
            columnsWithMetadata: [],
            defaultFilterPreset: null,
            enableFiltering: false,
            requiredFilters: 0,
            getDataForHiddenColumns: true,
            enableFilterPresets: true,
            enableRowSelection: RowSelectionMode.Multiple,
            expandable: false,
            filterExpression: null,
            filters: null,
            filterTagsLimit: null,
            getData: null,
            recordDefinition: null,
            associationDescriptors: [],
            recordDefinitionName: null,
            recordGridFilters: [],
            recordIdField: null,
            showDataForAllLocales: null,
            striped: false,
            styles: null,
            initialFilters: null,
            expandGroups: false,
            advancedFiltering: {
                activeSavedFilter: null,
                savedFilters: [],
                filterOptions: [],
                selectedFilters: [],
                recordGridFilterConfigs: null,
                filterTexts: null,
                hasLoadedSharedFilterPresets: false,
                isLoading: false,
                appliedSharedFilterPreset: null,
                toolbarTags: [],
                pendingSelectedFilters: [],
                selectedCardValues: {}
            },
            emptyStateLabelText: this.translateService.instant('com.bmc.arsys.rx.client.empty-state.no-items-to-display.label'),
            emptyStateWithFilterLabelText: this.translateService.instant('com.bmc.arsys.rx.client.empty-state.no-items-to-display.label'),
            searchFieldPlaceholderText: this.translateService.instant('com.bmc.arsys.rx.client.common.search.label'),
            enableColumnSelection: true,
            namedFilterOptions: null,
            predefinedFilterPresets: [],
            viewPresetSelector: null,
            virtualScroll: true
        };
        this.visibleColumns = [];
        this.cellValueFormatters = {};
        this.clickableWithHrefColumnActions = {};
        this.dataLoadContextSubject = new Subject();
        this.popovers = [];
        this.userPreferencesChanged$ = new Subject();
        this.exportSelectedRowText = this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.export-selected-row.label');
        this.exportSelectedRowsText = this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.export-selected-rows.label');
        this.pendingFiltersToApply = null;
        this.getNamedFilterOptions = this.getNamedFilterOptions.bind(this);
        this.rxRecordDefinitionCacheService.registerConsumer(this.destroyed$);
    }
    // Check if user clicked on a cell, filter popover,
    // filter by selection dialog, or filter by selection dropdown.
    // If not, then clear the selected cell.
    onClickOutside(event) {
        const isClickOutside = !(event.target.closest('.ui-table-tbody') ||
            event.target.closest('.popover.table-filtering') ||
            event.target.closest('.rx-filter-by-card-selection-dialog') ||
            event.target.closest('.rx-filter-by-card-selection-field-dropdown'));
        if (isClickOutside) {
            this.clearSelectedCells();
        }
    }
    get isTotalRecordCountKnown() {
        return !isNull(this.adaptTableConfig.totalRecords);
    }
    ngOnInit() {
        super.ngOnInit();
        this.isProgrammaticUse = Boolean(this.pageComponent) || !this.runtimeViewCanvasItemComponent;
        if (this.isProgrammaticUse) {
            this.adaptTableConfig.toolbarConfig.export = null;
        }
        this.notifyPropertyChanged('api', this.api);
        this.initializationCompleted$ = this.config.pipe(take(1), map((rxGridConfiguration) => this.rxGridConfiguratorService.getGridConfig(rxGridConfiguration)), tap((gridConfig) => {
            Object.assign(this.state, gridConfig);
        }), switchMap(() => {
            if (this.state.guid) {
                this.guid = this.state.guid;
            }
            const requests$ = [this.initRecordDefinitions()];
            if (this.guid) {
                this.userPreferencesChanged$.pipe(debounceTime(1000), takeUntil(this.destroyed$)).subscribe(() => {
                    this.rxRecordGridUserPreferencesService.saveUserPreferences(this.guid, this.adaptTableConfig, this.state);
                    this.checkIfViewPresetEdited();
                });
                requests$.push(this.rxRecordGridUserPreferencesService.get(this.guid));
            }
            return forkJoin(requests$);
        }), switchMap(() => this.initGrid()), shareReplay(1));
        this.initializationCompleted$.subscribe();
        const configChanged$ = combineLatest([
            this.initializationCompleted$,
            this.dataLoaded,
            this.config.pipe(skip(1), debounceTime(250), map((rxGridConfiguration) => this.rxGridConfiguratorService.getGridConfig(rxGridConfiguration)), takeUntil(this.destroyed$))
        ]).pipe(map(([initializationCompleted, dataLoaded, configChanged]) => configChanged));
        // updates named list column filter options after additional query expression evaluation
        configChanged$
            .pipe(map((config) => differenceBy(config.columns, this.state.columns, 'additionalQueryCriteria')), filter((changedColumns) => changedColumns.length > 0), takeUntil(this.destroyed$))
            .subscribe((namedListColumns) => {
            namedListColumns.forEach((column) => {
                const namedListColumnFilterOption = this.state.advancedFiltering.filterOptions.find((filterOption) => filterOption.id === column.fieldId);
                namedListColumnFilterOption.data.additionalQueryCriteria = column.additionalQueryCriteria;
                const existingColumnIndex = this.state.columns.findIndex((existingColumn) => existingColumn.fieldId === column.fieldId);
                this.state.columns[existingColumnIndex].additionalQueryCriteria = column.additionalQueryCriteria;
            });
        });
        const namedFilterOptionCache = new Map();
        // updates namedFilterOptions after expression evaluation and triggers data load if expression value is changed
        configChanged$
            .pipe(
        // cut additional configChanged$ emissions that can happen in a moment after first dataLoadContextSubject emission
        debounceTime(10), map((config) => this.getNamedFilterOptionsState(config.columns)), withLatestFrom(this.dataLoadContextSubject), filter(([namedFilterOptionsMap, dataLoadContext]) => !isEqual(namedFilterOptionsMap, dataLoadContext.namedFilterOptions)), tap(([namedFilterOptionsMap]) => {
            this.state.namedFilterOptions = namedFilterOptionsMap;
        }), map(([namedFilterOptionsMap]) => Object.values(namedFilterOptionsMap).reduce((res, options) => res.concat(options), [])), map((namedFilterOptionsList) => {
            const selectedNamedFilterOptionsGuids = this.state.advancedFiltering.selectedFilters.reduce((res, filterValue) => res.concat(filterValue.value.namedOptions), []);
            return namedFilterOptionsList.some((option) => {
                const isOptionCached = Boolean(namedFilterOptionCache.get(option.guid));
                if (!isOptionCached) {
                    namedFilterOptionCache.set(option.guid, option);
                }
                const isFilterValueChanged = option.filterExpression !== namedFilterOptionCache.get(option.guid).filterExpression;
                const shouldLoadData = selectedNamedFilterOptionsGuids.includes(option.guid) && (isFilterValueChanged || !isOptionCached);
                if (isFilterValueChanged) {
                    namedFilterOptionCache.set(option.guid, option);
                }
                return shouldLoadData;
            });
        }), filter((v) => v), takeUntil(this.destroyed$))
            .subscribe(() => {
            this.loadRowData();
        });
        configChanged$
            .pipe(
        // cut additional configChanged$ emissions that can happen in a moment after first dataLoadContextSubject emission
        debounceTime(10), withLatestFrom(this.dataLoadContextSubject), filter(([config, dataLoadContext]) => config.associatedRecordId !== dataLoadContext.associatedRecordId ||
            config.associatedRoleName !== dataLoadContext.associatedRoleName ||
            config.filterExpression !== dataLoadContext.filterExpression), tap(([config]) => {
            Object.assign(this.state, config);
        }))
            .subscribe(() => {
            this.loadRowData();
        });
        this.config
            .pipe(map((cfg) => cfg.viewPresetSelector), distinctUntilChanged(), takeUntil(this.destroyed$))
            .subscribe((viewPresetSelector) => {
            this.state.viewPresetSelector = viewPresetSelector;
        });
        if (this.isProgrammaticUse) {
            configChanged$
                .pipe(map((config) => ({
                actionButtons: config.actionButtons,
                rowActionButtons: config.rowActionButtons
            })), distinctUntilChanged(isEqual))
                .subscribe(({ actionButtons, rowActionButtons }) => {
                this.state.actionButtons = actionButtons;
                this.actionButtons = this.getProgrammaticActionButtons(this.state.actionButtons);
                this.state.rowActionButtons = rowActionButtons;
                this.rowActionButtons = this.getProgrammaticActionButtons(this.state.rowActionButtons);
            });
            configChanged$
                .pipe(distinctUntilChanged(isEqual), map((rxGridConfiguration) => this.rxGridConfiguratorService.getGridConfig(rxGridConfiguration)), tap((gridConfig) => {
                Object.assign(this.state, gridConfig);
                this.state.advancedFiltering.selectedFilters = [];
                this.adaptTableConfig.multiSortMeta = [];
            }), switchMap(() => {
                if (this.state.guid) {
                    this.guid = this.state.guid;
                }
                const requests$ = [this.initRecordDefinitions()];
                if (this.guid) {
                    requests$.push(this.rxRecordGridUserPreferencesService.get(this.guid));
                }
                return forkJoin(requests$);
            }), switchMap(() => this.initGrid()))
                .subscribe();
        }
        this.adaptTableConfig.virtualScroll = this.state.virtualScroll;
        const toolbarConfig = this.adaptTableConfig.toolbarConfig;
        toolbarConfig.visibleColumnsMenu = this.state.enableColumnSelection;
        toolbarConfig.visibleColumnsMenuTemplate = this.visibleColumnsMenuTemplate;
        toolbarConfig.rightCustomSectionTemplate = this.rightCustomSectionTemplate;
        toolbarConfig.leftCustomSectionTemplate = this.leftCustomSectionTemplate;
        toolbarConfig.filterTemplate = this.filterTemplate;
        this.notifyPropertyChanged('totalRowCount', 0);
        this.notifyPropertyChanged('selectedRows', []);
        this.notifyPropertyChanged('selectedRowCount', 0);
        this.notifyPropertyChanged('fieldValuesByFieldId', {});
        this.notifyPropertyChanged('firstSelectedRow', null);
        this.notifyPropertyChanged('queryExpression', '');
        this.notifyPropertyChanged('lastRefreshTime', '');
        this.initAdvancedFilterTexts();
        this.initCustomTexts();
        this.rxGlobalEventsService.viewActionsCompleted$.pipe(takeUntil(this.destroyed$)).subscribe(() => {
            if (!isEmpty(this.pendingFiltersToApply)) {
                this.onAdvancedFiltersChange(this.pendingFiltersToApply);
            }
            this.pendingFiltersToApply = null;
        });
    }
    ngAfterViewInit() {
        // The action buttons are rendered by the record grid component,
        // hence we have to handle their property changes here.
        this.actionButtonComponents.changes
            .pipe(switchMap((buttons) => merge(
        // Emit "api" change because native action button's property change happens later and we cannot catch it.
        ...buttons.map((button) => of({
            guid: button.guid,
            propertyName: 'api',
            newValue: button.api,
            oldValue: null
        })), 
        // Handle other property changes, e.g "hidden", or "disabled".
        ...buttons.map((button) => button.propertyChanged.asObservable()))))
            .subscribe((event) => this.propertyChanged.emit(event));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.dataLoadContextSubject.complete();
        this.userPreferencesChanged$.complete();
    }
    applyFilterBySelection() {
        if (isEmpty(this.state.advancedFiltering.selectedCardValues)) {
            this.applyPendingSelectedFilters();
        }
        else {
            this.cardLayoutOpenedModal = this.adaptModalService.open({
                title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.filter-by-selection.title'),
                content: RxFilterByCardSelectionDialogComponent,
                data: {
                    filterableFields: this.visibleColumns
                        .filter((column) => {
                        if (column.filterable) {
                            const fieldDefinition = this.state.recordDefinition.fieldDefinitionsById[column.field];
                            const isRequiredBooleanFilter = fieldDefinition.resourceType === RX_RECORD_DEFINITION.dataTypes.boolean.resourceType &&
                                this.rxFieldDefinitionService.isRequiredField(fieldDefinition);
                            return !isRequiredBooleanFilter;
                        }
                        else {
                            return false;
                        }
                    })
                        .map((column) => ({
                        id: column.field,
                        name: column.header || column.fallbackTitle
                    }))
                },
                customClass: 'rx-filter-by-card-selection-dialog'
            });
            this.cardLayoutOpenedModal
                .then((fieldId) => {
                this.state.advancedFiltering.pendingSelectedFilters = [
                    {
                        filterOptionId: fieldId,
                        value: this.state.advancedFiltering.selectedCardValues[fieldId]
                    }
                ];
                this.applyPendingSelectedFilters();
            })
                .catch(noop);
        }
    }
    buildQueryByAdvancedFilters(advancedFilters) {
        const queryFilters = advancedFilters.map((filter) => {
            var _a;
            let queryFilter = null;
            const fieldId = filter.filterOptionId;
            const fieldDefinition = this.state.recordDefinition.fieldDefinitionsById[fieldId];
            if (fieldDefinition) {
                const filterConfig = this.state.advancedFiltering.recordGridFilterConfigs[fieldDefinition.resourceType];
                queryFilter = filterConfig.getQueryFilter(filter, fieldDefinition, fieldId, (_a = this.state.namedFilterOptions[fieldId]) !== null && _a !== void 0 ? _a : []);
            }
            return queryFilter;
        });
        return this.rxRecordGridFilterService.addQueries(...queryFilters);
    }
    downloadAttachment(row, col, fileName, event) {
        if (event && !includes(['Space', 'Enter'], event.code)) {
            return;
        }
        if (this.rxRecordGridUtilsService.isAssociatedRecordFieldId(col.field)) {
            const fieldLocator = this.rxRecordGridUtilsService.getFieldLocator(col.field);
            const associationDescriptor = find(this.state.associationDescriptors, {
                associationDefinition: { guid: fieldLocator.associationGuid }
            });
            this.rxAssociationInstanceDataPageService
                .post({
                params: {
                    pageSize: 1,
                    startIndex: 0,
                    associationDefinition: associationDescriptor.associationDefinition.name,
                    nodeToQuery: fieldLocator.associationNodeSide,
                    associatedRecordInstanceId: row[RX_RECORD_DEFINITION.coreFieldIds.id],
                    propertySelection: RX_RECORD_DEFINITION.coreFieldIds.id
                }
            })
                .pipe(take(1))
                .subscribe((dataPageResult) => {
                const recordInstanceId = dataPageResult.data[0][RX_RECORD_DEFINITION.coreFieldIds.id];
                this.rxRecordInstanceService.downloadAttachment(associationDescriptor.recordDefinitionName, Number(fieldLocator.fieldId), recordInstanceId, fileName);
            });
        }
        else {
            this.rxRecordInstanceService.downloadAttachment(this.state.recordDefinitionName, Number(col.field), row[RX_RECORD_DEFINITION.coreFieldIds.id], fileName);
        }
    }
    executeViewActions(guid, actions, lastActionRow) {
        if (this.isProgrammaticUse) {
            const sortedActions = sortBy(actions, 'index');
            return sortedActions.reduce((promise, action) => {
                return isFunction(action.name)
                    ? promise.then((result) => action.name(result, lastActionRow))
                    : isString(action.name)
                        ? promise.then((result) => (() => {
                            this.rxViewActionService.execute(action.name.toString(), action.params).subscribe();
                        })(result, lastActionRow))
                        : promise;
            }, Promise.resolve());
        }
        return this.runtimeViewModelApi.triggerViewActions(guid, VIEW_COMPONENT_DEFAULT_EVENT_NAME);
    }
    getActionButtonConfig(isHidden, actionButtonConfig) {
        return isHidden
            ? actionButtonConfig.pipe(map((config) => (Object.assign(Object.assign({}, config), { cls: 'dropdown-item' }))))
            : actionButtonConfig;
    }
    getCellValue(row, col) {
        const cellValueFormatter = this.cellValueFormatters[col.field];
        return cellValueFormatter(row[col.field]);
    }
    getDataCellClass() {
        return this.popovers.length ? 'rx-cell-selection-mode' : '';
    }
    getLoadRecordCountLinkText() {
        return `${this.adaptTableConfig.data.length}+`;
    }
    getMultipleRowsSelectedText() {
        return this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.multiple-rows-selected.label', {
            count: this.adaptTableConfig.selectedItems.length,
            total: this.isTotalRecordCountKnown ? this.adaptTableConfig.totalRecords : this.getLoadRecordCountLinkText()
        });
    }
    getMultipleRowsSelectedTextFirstPart() {
        const text = this.getMultipleRowsSelectedText();
        return text.substring(0, text.indexOf(this.getLoadRecordCountLinkText()));
    }
    getMultipleRowsSelectedTextSecondPart() {
        const text = this.getMultipleRowsSelectedText();
        const totalParameterForTranslate = this.getLoadRecordCountLinkText();
        return text.substring(text.indexOf(totalParameterForTranslate) + totalParameterForTranslate.length);
    }
    getNamedFilterOptions(filterOptionConfig) {
        return this.state.namedFilterOptions[filterOptionConfig.id];
    }
    getSharedFilterPresets() {
        this.state.advancedFiltering.isLoading = true;
        const onLoadingEnd = () => {
            this.state.advancedFiltering.isLoading = false;
            this.state.advancedFiltering.hasLoadedSharedFilterPresets = true;
        };
        return this.rxRecordGridSharedFilterPresetsCacheService.getSharedFilterPresets(this.guid).pipe(catchError((err) => {
            onLoadingEnd();
            return throwError(err);
        }), tap(() => {
            onLoadingEnd();
        }));
    }
    getSortedColumnsByTitle() {
        return this.adaptTableConfig.columns
            .slice()
            .sort((column1, column2) => column1.header.localeCompare(column2.header));
    }
    getToolbarTags(filterTags) {
        const toolbarTags$ = (filterTags || []).map((tag) => {
            if (tag.data.filterOption && tag.data.filterOption.id !== RX_RECORD_GRID.externalPresetFilterOptionId) {
                const fieldId = tag.data.filterOption.id;
                const fieldDefinition = this.state.recordDefinition.fieldDefinitionsById[fieldId];
                const filterConfig = this.state.advancedFiltering.recordGridFilterConfigs[fieldDefinition.resourceType];
                if (isFunction(filterConfig.getToolbarTagInfo)) {
                    return filterConfig
                        .getToolbarTagInfo({
                        primaryRecordDefinition: this.state.recordDefinition,
                        fieldDefinition,
                        value: tag.data.value,
                        tag,
                        fieldId,
                        namedFilterOptions: this.state.namedFilterOptions[fieldId]
                    })
                        .pipe(tap((tagInfo) => (tag.data.value.title = tagInfo.tooltip)), map((tagInfo) => (Object.assign(Object.assign({}, tag), { text: tagInfo.text }))));
                }
            }
            return of(Object.assign({}, tag));
        });
        return toolbarTags$.length ? forkJoin(toolbarTags$) : of([]);
    }
    getVisibleColumns() {
        return this.adaptTable.getVisibleColumns(this.adaptTableConfig.columns);
    }
    getVisibleRows() {
        return this.adaptTableConfig.data;
    }
    handleHeaderCheckboxToggle(event) {
        this.setSelectedFilteredRowsCount();
    }
    isCellSelected(cellPopover) {
        return some(this.popovers, (popover) => popover === cellPopover);
    }
    loadSavedFilterPresetFilters(savedFilter) {
        this.state.advancedFiltering.isLoading = true;
        return this.rxRecordGridFilterService
            .getAdvancedFilterData(savedFilter.filterData, this.state.recordDefinition.fieldDefinitionsById, this.state.advancedFiltering.recordGridFilterConfigs, this.state.recordDefinition, this.state.advancedFiltering.filterOptions, this.state.associationDescriptors)
            .pipe(tap((filters) => {
            // combined fake preset filters with actual filters.
            savedFilter.filters = (savedFilter.filters || []).concat(filters);
            this.state.advancedFiltering.isLoading = false;
        }));
    }
    loadTotalRowCount() {
        this.getTotalRowCount().subscribe((result) => {
            this.adaptTableConfig.totalRecords = result.totalSize;
        });
    }
    onActiveSavedAdvancedFilterChange(savedFilter) {
        this.state.advancedFiltering.activeSavedFilter = savedFilter;
    }
    onAdvancedFilterExpressionTagsChanged(event) {
        const hasAllValidTags = event.filterExpressionTags.every((filterTag) => isEmpty(filterTag.data.validationErrors));
        if (hasAllValidTags) {
            const oldToolbarTags = this.state.advancedFiltering.toolbarTags;
            this.updateToolbarTags(event.filterExpressionTags);
            // workaround: run changeDetector to avoid the ExpressionChangedAfterItHasBeenCheckedError
            if (oldToolbarTags !== this.state.advancedFiltering.toolbarTags) {
                this.changeDetector.detectChanges();
            }
        }
    }
    onAdvancedFiltersChange(filters) {
        this.state.advancedFiltering.appliedSharedFilterPreset = null;
        const appliedExternalPresetFilter = this.getAppliedExternalPresetFilter(filters);
        if (appliedExternalPresetFilter) {
            const filterPresetData = this.state.advancedFiltering.savedFilters.find((savedFilter) => savedFilter.id === appliedExternalPresetFilter.value);
            if (this.isSharedFilterPreset(filterPresetData)) {
                this.state.advancedFiltering.appliedSharedFilterPreset = filterPresetData;
            }
            else {
                if (filterPresetData.appliedSharedFilterPresetGuid) {
                    const appliedSharedFilterPreset = find(this.state.advancedFiltering.savedFilters, {
                        id: filterPresetData.appliedSharedFilterPresetGuid
                    });
                    this.state.advancedFiltering.appliedSharedFilterPreset = appliedSharedFilterPreset;
                }
            }
        }
        this.adaptTableConfig.first = 0;
        this.state.advancedFiltering.selectedFilters = filters;
        this.adaptTableConfig.isLoadingMoreData = false;
        this.updateAdaptTableFilters();
        this.userPreferencesChanged$.next();
        this.updateToolbarTags(this.state.advancedFiltering.toolbarTags);
        if (this.state.useExternalFiltering) {
            this.loadRowData(false);
        }
        else {
            this.adaptTableConfig.data = this.filterRows(this.adaptTableConfig.originalRows);
        }
    }
    onBeforeActiveSavedFilterChange(event) {
        const savedFilterToSelect = event.savedFilterToSelect;
        if (savedFilterToSelect) {
            if (!savedFilterToSelect.filters || !this.areNonExternalPresetFiltersApplied(savedFilterToSelect.filters)) {
                this.loadSavedFilterPresetFilters(savedFilterToSelect).subscribe();
            }
        }
    }
    onCellClick(event, columns, rowItem, popover, isCardLayout) {
        const isLinkClicked = !!event.target.closest('a');
        if (isLinkClicked) {
            this.clearSelectedCells();
        }
        else {
            if (this.popovers.length) {
                if (!(event.metaKey || event.ctrlKey)) {
                    this.clearSelectedCells();
                }
            }
            if (columns) {
                this.toggleCellSelection(columns.filter((col) => !col.isRowActionsColumn), rowItem, popover, isCardLayout);
            }
        }
    }
    onFilterBySelection(event, columns, rowItem) {
        this.onCellClick(event, columns, rowItem, null, true);
        this.applyFilterBySelection();
    }
    onCellMouseOver($event) {
        const element = $event.currentTarget;
        this.showCellTooltip = element.offsetWidth < element.scrollWidth;
    }
    onChangedCardLayout(event) {
        this.adaptTableConfig.cardLayoutColumns = event.cardLayoutColumns;
        this.clearSelectedCells();
        if (this.cardLayoutOpenedModal) {
            this.cardLayoutOpenedModal.reject();
            this.cardLayoutOpenedModal = null;
        }
        if (this.guid) {
            this.rxRecordGridUserPreferencesService.applyUserPreferencesForColumns(this.adaptTableConfig, this.state.columnsWithMetadata, this.guid);
        }
        this.visibleColumns = this.getVisibleColumns();
        this.adaptTableConfig.virtualRowHeight = this.getVirtualRowHeight();
    }
    onColReorder(colReorderEvent) {
        this.visibleColumns = this.getVisibleColumns();
        this.userPreferencesChanged$.next();
    }
    onColumnResize() {
        const adaptTableRectData = this.adaptTable.el.nativeElement.getBoundingClientRect();
        const tableWidth = adaptTableRectData === null || adaptTableRectData === void 0 ? void 0 : adaptTableRectData.width;
        const availableColumnWidth = this.adaptTable.dataHeaderCells.reduce((accum, cell) => accum + cell.element.nativeElement.offsetWidth, 0);
        const defaultColumnWidth = `${(availableColumnWidth * 100) / (tableWidth * this.getVisibleColumns().length)}%`;
        const visibleColumnWidthMap = reduce(this.adaptTable.dataHeaderCells.toArray(), (result, cell) => {
            const renderingColumnConfig = cell.data.renderingColumn.columnsConfigs[0];
            let width = null;
            if (availableColumnWidth) {
                width =
                    endsWith(renderingColumnConfig.width, 'px') || this.state.expandable
                        ? `${cell.element.nativeElement.offsetWidth}px`
                        : `${round((cell.element.nativeElement.offsetWidth / availableColumnWidth) * 100, 2)}%`;
            }
            result[renderingColumnConfig.field] = width;
            return result;
        }, {});
        this.adaptTableConfig.columns.forEach((column) => {
            var _a;
            if (!column.hidden) {
                column.width = (_a = visibleColumnWidthMap[column.field]) !== null && _a !== void 0 ? _a : defaultColumnWidth;
            }
        });
        this.userPreferencesChanged$.next();
    }
    onColumnVisibilityChange(isVisible, column) {
        if (column.hidden === isVisible) {
            column.hidden = !isVisible;
            this.userPreferencesChanged$.next();
            this.visibleColumns = this.getVisibleColumns();
            this.adaptTableConfig.virtualRowHeight = this.getVirtualRowHeight();
            if (isVisible) {
                if (!this.lastPropertySelection.includes(column.field)) {
                    this.loadRowData();
                }
            }
            else {
                // #ADAPT-8052 workaround.
                this.avoidSystemColumnExpansion();
            }
        }
    }
    onCreateNewFilterPreset(event) {
        const newFilter = {
            filters: event.filters,
            name: event.name,
            id: this.rxGuidService.generate()
        };
        const appliedSharedPreset = this.getAppliedExternalPresetFilter(event.filters);
        if (appliedSharedPreset) {
            newFilter.appliedSharedFilterPresetGuid = appliedSharedPreset.value;
        }
        this.state.advancedFiltering.savedFilters.push(newFilter);
        this.state.advancedFiltering.activeSavedFilter = newFilter;
        this.userPreferencesChanged$.next();
    }
    onDeleteSavedFilterPreset(filterPresetToDelete) {
        remove(this.state.advancedFiltering.savedFilters, (filterPreset) => filterPreset.id === filterPresetToDelete.id);
        this.userPreferencesChanged$.next();
    }
    onEditSavedFilterClick(event) {
        let editCustomTagsFn = null;
        if (event.savedFilter.appliedSharedFilterPresetGuid) {
            editCustomTagsFn = (tags) => tags;
        }
        if (!event.savedFilter.filters || !this.areNonExternalPresetFiltersApplied(event.savedFilter.filters)) {
            event.preventDefault();
            this.loadSavedFilterPresetFilters(event.savedFilter).subscribe(() => {
                event.initSavedFilterEditing(editCustomTagsFn && editCustomTagsFn.bind(this));
            });
        }
        else if (event.savedFilter.appliedSharedFilterPresetGuid) {
            event.preventDefault();
            event.initSavedFilterEditing(editCustomTagsFn.bind(this));
        }
    }
    onExport(options) {
        if (this.isExportInProgress) {
            this.rxNotificationService.addInfoMessage(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.export-in-progress.message'));
            return;
        }
        const visibleColumns = this.getVisibleColumns().filter((column) => !column.isRowActionsColumn);
        if (!visibleColumns.length) {
            this.rxNotificationService.addWarningMessage(this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.no-data-to-export.message'));
            return;
        }
        const columnHeaders = visibleColumns.map((column) => column.header || column.fallbackTitle);
        let rows$;
        if (options.selectionOnly) {
            rows$ = of(intersectionBy(this.adaptTableConfig.data, this.getSelectedRows(), RowDataItemIdFieldName));
        }
        else {
            const headers = this.getHeaders();
            const params = this.prepareQueryParamsAndQueryArgs(false);
            params.pageSize = -1;
            params.propertySelection = visibleColumns.map((column) => column.field);
            delete params.cursor;
            this.isExportInProgress = true;
            rows$ = this.getDataPageService()
                .post({ params, headers })
                .pipe(map((dataPage) => dataPage.data), finalize(() => {
                this.isExportInProgress = false;
            }));
        }
        rows$.subscribe((rows) => {
            const cellValues = this.getCellValues(rows, visibleColumns);
            this.exportDataToCsv(cellValues, columnHeaders);
        });
    }
    onLazyLoad(event) {
        if (this.state.useExternalFiltering) {
            if (event.loadMore || event.eventSource !== AdaptTableEventSource.LoadMore) {
                this.adaptTableConfig.multiSortMeta = event.multiSortMeta;
                this.adaptTableConfig.filters = event.filters;
                this.adaptTableConfig.isLoadingMoreData = event.loadMore;
                this.loadRowData(event.loadMore);
            }
        }
        else {
            if (event.eventSource === AdaptTableEventSource.FilterChange) {
                this.adaptTableConfig.filters = event.filters;
                this.adaptTableConfig.data = this.filterRows(this.adaptTableConfig.originalRows);
            }
        }
    }
    onRefreshClick() {
        if (!this.state.useExternalFiltering) {
            this.loadRowData(false);
        }
        const searchText = this.adaptTable.toolbarComponent.getQuickFilterInputValue();
        // this will trigger onLazyLoad event
        this.adaptTable.setQuickFilter(searchText);
    }
    onRemoveFilterTag(event) {
        this.state.advancedFiltering.activeSavedFilter = null;
        const selectedFilters = this.state.advancedFiltering.selectedFilters.slice();
        const filterOptionId = event.removedTag.data.filterOption.id;
        const index = findIndex(selectedFilters, (selectedFilter) => selectedFilter.filterOptionId === filterOptionId);
        selectedFilters.splice(index, 1);
        this.onAdvancedFiltersChange(selectedFilters);
        this.setToolbarTags(event.newTags);
    }
    onRowsSelectionChange(rowDataItems) {
        const selectedItems = rowDataItems ? castArray(rowDataItems) : [];
        const oldSelectedItems = this.adaptTableConfig.selectedItems;
        this.shouldDisplayActionButtons = !isEmpty(selectedItems) && !isEmpty(this.actionButtons);
        this.expandSelectedRowsProperties(selectedItems);
        this.adaptTableConfig.selectedItems = selectedItems;
        this.adaptTableConfig.toolbarConfig = Object.assign(Object.assign(Object.assign({}, this.adaptTableConfig.toolbarConfig), { quickFilter: !this.shouldDisplayActionButtons, leftCustomSectionFixed: this.shouldDisplayActionButtons, rightCustomSectionFixed: this.shouldDisplayActionButtons, leftCustomSection: this.shouldDisplayActionButtons, filter: !this.shouldDisplayActionButtons }), this.state.toolbarConfig);
        this.adaptTableConfig.texts = Object.assign(Object.assign({}, this.adaptTableConfig.texts), { exportSelected: this.getExportSelectedText(selectedItems) });
        this.addSelectionFieldOptionNames(selectedItems[0]);
        this.notifyPropertyChanged('selectedRows', selectedItems, oldSelectedItems);
        this.notifyPropertyChanged('selectedRowCount', selectedItems.length, oldSelectedItems.length);
        this.notifyPropertyChanged('firstSelectedRow', selectedItems[0], oldSelectedItems[0]);
        this.notifyPropertyChanged('fieldValuesByFieldId', this.prepareFieldsValueByFieldIdData(selectedItems), {});
        this.rowSelectionChanged.next(selectedItems);
    }
    onSearchColumns() {
        this.filteredVisibleColumns = this.sortedColumnsByTitle.filter((column) => this.rxStringService.caseInsensitiveSearch(column.header, this.columnSearchText));
    }
    onSort(sortEvent) {
        this.applySorting(sortEvent.multisortmeta);
    }
    onSortCards(multiSortMeta) {
        this.applySorting(multiSortMeta);
        this.loadRowData();
    }
    onRowActionOpen(row) {
        var _a;
        (_a = last(this.popovers)) === null || _a === void 0 ? void 0 : _a.close();
        this.addSelectionFieldOptionNames(row);
        const gridRow = this.expandRowProperties(row);
        this.state.lastActionRow = gridRow;
        this.notifyPropertyChanged('clickableRow', gridRow, null);
    }
    onUpdateSavedFilterPreset(event) {
        const savedFilter = find(this.state.advancedFiltering.savedFilters, (filterPreset) => filterPreset.id === event.oldSavedFilter.id);
        if (savedFilter) {
            if (savedFilter.appliedSharedFilterPresetGuid &&
                !find(event.newSavedFilter.filters, (filter) => filter.filterOptionId === RX_RECORD_GRID.externalPresetFilterOptionId)) {
                delete savedFilter.appliedSharedFilterPresetGuid;
            }
            Object.assign(savedFilter, event.newSavedFilter);
            this.userPreferencesChanged$.next();
        }
    }
    openRowDetails(columns, rowDataItem) {
        var _a;
        (_a = last(this.popovers)) === null || _a === void 0 ? void 0 : _a.close();
        this.cardLayoutOpenedModal = this.adaptModalService.open({
            title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.cards.record-details.dialog.title'),
            content: this.cardLayoutRowDetailsTemplate,
            data: {
                columns,
                rowDataItem
            }
        });
        this.cardLayoutOpenedModal.catch(noop);
    }
    setToolbarTags(toolbarTags) {
        this.state.advancedFiltering.toolbarTags = toolbarTags;
        this.updateToolbarItems();
    }
    trackByColumnField(index, column) {
        return column.field;
    }
    updateToolbarTags(filterTags) {
        this.getToolbarTags(filterTags).subscribe((toolbarTags) => {
            this.setToolbarTags(toolbarTags);
        });
    }
    addAssociationFieldsToRecordDefinition(columnsWithMetadata) {
        const fieldDefinitionsById = this.state.recordDefinition.fieldDefinitionsById;
        columnsWithMetadata.forEach((columnWithMetadata) => {
            if (!fieldDefinitionsById[columnWithMetadata.fieldId]) {
                this.rxRecordDefinitionService.addFieldDefinitionToMap(columnWithMetadata.fieldDefinition, fieldDefinitionsById, columnWithMetadata.fieldId);
            }
        });
        this.state.recordDefinition.fieldDefinitionsById = Object.assign(Object.assign({}, fieldDefinitionsById), this.rxObjectUtilsService.expandProperties(fieldDefinitionsById));
        this.notifyPropertyChanged('recordDefinition', this.state.recordDefinition);
    }
    areNonExternalPresetFiltersApplied(filters) {
        return filters.some((filter) => filter.filterOptionId !== RX_RECORD_GRID.externalPresetFilterOptionId);
    }
    getAppliedExternalPresetFilter(filters) {
        return filters.find((filter) => filter.filterOptionId === RX_RECORD_GRID.externalPresetFilterOptionId);
    }
    prepareFieldsValueByFieldIdData(selectedData) {
        const columnIds = map$1(this.adaptTableConfig.columns, 'field');
        return reduce(selectedData, (result, row, index) => {
            columnIds.forEach(function (id) {
                result[id] = result[id] || [];
                result[id][index] = row[id];
            });
            return result;
        }, {});
    }
    addSelectionFieldOptionNames(row) {
        if (row) {
            row.selectionFieldOptionNamesById = transform(this.selectionFieldOptionLabelsByFieldId, (result, value, fieldId) => {
                result[fieldId] = value[row[fieldId]];
            }, {});
        }
    }
    applyFilters(filters, mode) {
        this.initializationCompleted$
            .pipe(switchMap(() => this.rxRecordGridFilterService.getAdvancedFilterData(filters, this.state.recordDefinition.fieldDefinitionsById, this.state.advancedFiltering.recordGridFilterConfigs, this.state.recordDefinition, this.state.advancedFiltering.filterOptions, this.state.associationDescriptors)), take(1), takeUntil(this.destroyed$))
            .subscribe((filtersToApply) => {
            let currentFilters = !isEmpty(this.pendingFiltersToApply)
                ? this.pendingFiltersToApply
                : cloneDeep(this.state.advancedFiltering.selectedFilters);
            let resultingFilters;
            switch (mode) {
                case ApplyGridFilterMode.Begin:
                    if (this.pendingFiltersToApply) {
                        resultingFilters = this.pendingFiltersToApply;
                    }
                    else {
                        this.pendingFiltersToApply = [];
                    }
                    break;
                case ApplyGridFilterMode.Append:
                    // filters that will not be affected
                    const remainingFilters = currentFilters.filter((currentFilter) => !filtersToApply.find((filter) => filter.filterOptionId === currentFilter.filterOptionId));
                    resultingFilters = [...remainingFilters, ...filtersToApply];
                    break;
                case ApplyGridFilterMode.Remove:
                    resultingFilters = currentFilters.reduce((result, currentFilter) => {
                        const filterToApply = filtersToApply.find((filter) => filter.filterOptionId === currentFilter.filterOptionId);
                        if (filterToApply) {
                            if (this.isRangeFilter(currentFilter.filterOptionId)) {
                                if (isEqual(currentFilter.value.filterValue, filterToApply.value.filterValue)) {
                                    currentFilter.value.filterValue = [null, null];
                                }
                            }
                            else {
                                currentFilter.value.filterValue = currentFilter.value.filterValue.filter((val) => !filterToApply.value.filterValue.includes(val));
                            }
                            currentFilter.value.namedOptions = currentFilter.value.namedOptions.filter((val) => !filterToApply.value.namedOptions.includes(val));
                            if (!RxRecordGridAdvancedFilterValue.isEmptyWithRange(currentFilter.value)) {
                                result.push(currentFilter);
                            }
                        }
                        else {
                            result.push(currentFilter);
                        }
                        return result;
                    }, []);
                    break;
                case ApplyGridFilterMode.Merge:
                    resultingFilters = [...currentFilters, ...filtersToApply].reduce((result, filter) => {
                        const existingFilter = result.find((f) => f.filterOptionId === filter.filterOptionId);
                        if (!existingFilter) {
                            result.push(filter);
                        }
                        else {
                            if (this.isRangeFilter(filter.filterOptionId)) {
                                existingFilter.value.filterValue = [...filter.value.filterValue];
                            }
                            else {
                                existingFilter.value.filterValue = uniq(existingFilter.value.filterValue.concat(filter.value.filterValue));
                            }
                            existingFilter.value.namedOptions = uniq(existingFilter.value.namedOptions.concat(filter.value.namedOptions));
                        }
                        return result;
                    }, []);
                    break;
                case ApplyGridFilterMode.Overwrite:
                    this.state.advancedFiltering.appliedSharedFilterPreset = null;
                    this.state.advancedFiltering.activeSavedFilter = null;
                    resultingFilters = filtersToApply;
                    break;
                case ApplyGridFilterMode.Clear:
                    this.state.advancedFiltering.appliedSharedFilterPreset = null;
                    this.state.advancedFiltering.activeSavedFilter = null;
                    resultingFilters = [];
                    if (this.pendingFiltersToApply) {
                        this.state.advancedFiltering.selectedFilters = [];
                    }
                    break;
                case ApplyGridFilterMode.End:
                    if (this.pendingFiltersToApply) {
                        resultingFilters = this.pendingFiltersToApply;
                        this.pendingFiltersToApply = null;
                    }
                    break;
            }
            if (this.pendingFiltersToApply) {
                this.pendingFiltersToApply = resultingFilters || [];
            }
            else if (resultingFilters) {
                this.onAdvancedFiltersChange(resultingFilters);
            }
        });
    }
    applyPendingSelectedFilters() {
        const existingFilters = cloneDeep(this.state.advancedFiltering.selectedFilters);
        forEach(this.state.advancedFiltering.pendingSelectedFilters, (pendingSelectedFilter) => {
            const existingFilter = find(existingFilters, { filterOptionId: pendingSelectedFilter.filterOptionId });
            const fieldDefinition = this.state.recordDefinition.fieldDefinitionsById[pendingSelectedFilter.filterOptionId];
            let filterValues = [];
            switch (fieldDefinition.resourceType) {
                case RX_RECORD_DEFINITION.dataTypes.dateOnly.resourceType:
                case RX_RECORD_DEFINITION.dataTypes.dateTime.resourceType: {
                    filterValues = pendingSelectedFilter.value.map((filterValue) => moment(filterValue));
                    filterValues = [moment.min(filterValues), moment.max(filterValues)];
                    break;
                }
                case RX_RECORD_DEFINITION.dataTypes.timeOnly.resourceType: {
                    filterValues = pendingSelectedFilter.value.map((filterValue) => moment(filterValue, 'LTS'));
                    filterValues = [moment.min(filterValues), moment.max(filterValues)];
                    break;
                }
                case RX_RECORD_DEFINITION.dataTypes.integer.resourceType:
                case RX_RECORD_DEFINITION.dataTypes.decimal.resourceType:
                case RX_RECORD_DEFINITION.dataTypes.real.resourceType: {
                    filterValues = [min(pendingSelectedFilter.value), max(pendingSelectedFilter.value)];
                    break;
                }
                case RX_RECORD_DEFINITION.dataTypes.boolean.resourceType: {
                    filterValues = pendingSelectedFilter.value.map((filterValue) => filterValue === '$NULL$' ? 'blank' : filterValue === 1);
                    break;
                }
                default: {
                    filterValues = uniq(pendingSelectedFilter.value.map((filterValue) => String(filterValue)));
                    break;
                }
            }
            if (existingFilter) {
                existingFilter.value.filterValue = filterValues;
            }
            else {
                pendingSelectedFilter.value = new RxRecordGridAdvancedFilterValue(filterValues);
                existingFilters.push(pendingSelectedFilter);
            }
        });
        this.onAdvancedFiltersChange(existingFilters);
        this.clearSelectedCells();
    }
    applySorting(multiSortMeta) {
        this.adaptTableConfig.multiSortMeta = multiSortMeta;
        this.userPreferencesChanged$.next();
        if (!this.state.useExternalFiltering) {
            this.adaptTableConfig.data = this.filterRows(this.adaptTableConfig.data);
        }
    }
    applyViewPreset(viewPresetSelectorGuid, viewPresetGuid, sharedViewPresets) {
        var _a;
        if (viewPresetSelectorGuid === ((_a = this.state.viewPresetSelector) === null || _a === void 0 ? void 0 : _a.getGuid())) {
            return this.applyViewPresetInner(viewPresetGuid, sharedViewPresets);
        }
        return EMPTY;
    }
    shareViewPreset(viewPresetSelectorGuid) {
        var _a;
        if (viewPresetSelectorGuid === ((_a = this.state.viewPresetSelector) === null || _a === void 0 ? void 0 : _a.getGuid())) {
            return of(this.rxRecordGridUserPreferencesService.getSharedViewPresetData());
        }
        return of(null);
    }
    applyViewPresetInner(viewPresetGuid, sharedViewPresets) {
        return this.initializationCompleted$.pipe(switchMap(() => {
            const viewPresetData = sharedViewPresets && sharedViewPresets[this.guid];
            if (viewPresetData) {
                return this.rxRecordGridUserPreferencesService.applySharedViewPreset(this.state, this.adaptTableConfig, viewPresetGuid, viewPresetData);
            }
            else {
                return this.rxRecordGridUserPreferencesService.applyViewPreset(this.state, this.adaptTableConfig, viewPresetGuid);
            }
        }), take(1), tap(() => {
            this.loadRowData();
            this.userPreferencesChanged$.next();
            this.checkIfViewPresetEdited();
        }));
    }
    areUserFiltersApplied() {
        return (this.isSearchApplied() ||
            Boolean(this.state.advancedFiltering.appliedSharedFilterPreset) ||
            !isEmpty(this.state.advancedFiltering.selectedFilters));
    }
    isSearchApplied() {
        const searchText = get(this.adaptTableConfig.filters, 'global.value', '').toString().trim();
        return Boolean(searchText);
    }
    checkIfViewPresetEdited() {
        if (this.state.viewPresetSelector && this.rxRecordGridUserPreferencesService.isCurrentViewPresetEdited()) {
            this.state.viewPresetSelector.markAppliedViewPresetAsEdited();
        }
    }
    clearSelectedCells() {
        var _a;
        (_a = last(this.popovers)) === null || _a === void 0 ? void 0 : _a.close();
        this.popovers = [];
        this.state.advancedFiltering.pendingSelectedFilters = [];
        this.state.advancedFiltering.selectedCardValues = {};
    }
    compareRows(firstRow, secondRow) {
        const sortMetas = this.adaptTableConfig.multiSortMeta;
        return reduce(sortMetas, (sortRank, sortMeta) => {
            let firstValue;
            let secondValue;
            if (firstRow.groupField && secondRow.groupField) {
                firstValue = firstRow.groupField === sortMeta.field ? firstRow.groupValue : null;
                secondValue = secondRow.groupField === sortMeta.field ? secondRow.groupValue : null;
            }
            else {
                firstValue = firstRow[sortMeta.field];
                secondValue = secondRow[sortMeta.field];
            }
            // TODO: this is a naive implementation that needs to be improved to
            // take into account the type of data.
            // For example, this implementation will sort dates as strings.
            if (!isNaN(firstValue) && !isNaN(secondValue)) {
                const firstValueNum = Number(firstValue);
                const secondValueNum = Number(secondValue);
                sortRank =
                    sortRank || sortMeta.order * (firstValueNum < secondValueNum ? -1 : firstValueNum > secondValueNum ? 1 : 0);
            }
            else {
                // toString will convert null to '' to allow comparison with strings using localeCompare
                sortRank = sortRank || sortMeta.order * toString(firstValue).localeCompare(toString(secondValue));
            }
            return sortRank;
        }, 0);
    }
    createCsvExportFile(csvData) {
        const byteOrderMark = '\uFEFF';
        // Prepend byte order mark to indicate that csvData may contain unicode characters
        const file = new Blob([`${byteOrderMark}${csvData}`], { type: 'text/csv;charset=utf-8' });
        this.ngZone.runOutsideAngular(() => {
            saveAs(file, `${this.getExportFileName()}.csv`);
        });
    }
    deleteViewPreset(viewPresetGuid) {
        this.rxRecordGridUserPreferencesService.deleteViewPreset(viewPresetGuid);
        this.userPreferencesChanged$.next();
        return EMPTY;
    }
    discardViewPresetChanges(viewPresetGuid, sharedViewPresets) {
        if (this.rxRecordGridUserPreferencesService.isExistingViewPreset(viewPresetGuid)) {
            this.rxRecordGridUserPreferencesService.discardViewPresetChanges(viewPresetGuid);
            return this.applyViewPresetInner(viewPresetGuid, sharedViewPresets);
        }
        else {
            return EMPTY;
        }
    }
    enrichRowEntity(gridRowDataItem) {
        let hrefParams = {};
        if (!isEmpty(this.clickableWithHrefColumnActions)) {
            this.addSelectionFieldOptionNames(gridRowDataItem);
            const expandedGridRowData = this.expandRowProperties(gridRowDataItem);
            set(this.clickableWithHrefActionExpressionEvaluationData, `view.components.${this.guid}.clickableRow`, expandedGridRowData);
            hrefParams = reduce(this.clickableWithHrefColumnActions, (result, gridActions, columnId) => {
                const gridAction = this.findEnabledGridAction(gridActions);
                if ((gridAction === null || gridAction === void 0 ? void 0 : gridAction.name) === RX_VIEW_ACTION.viewActionNames.openView) {
                    result[`${columnId}$ROUTER_LINK$`] = this.rxViewActionUtilsService.generateViewUrl(gridAction.viewDefinitionName);
                    result[`${columnId}$QUERY_PARAMS$`] = this.evaluateViewInputParameters(gridAction.viewParams);
                }
                else if ((gridAction === null || gridAction === void 0 ? void 0 : gridAction.name) === RX_VIEW_ACTION.viewActionNames.launchUrl) {
                    result[`${columnId}$LAUNCH_URL$`] = this.rxExpressionEvaluatorService.tryEvaluate(gridAction.url, this.clickableWithHrefActionExpressionEvaluationData);
                    result[`${columnId}$TARGET$`] = RX_LAUNCH_BEHAVIOR[gridAction.launchBehavior].target;
                }
                else {
                    result[`${columnId}$LAUNCH_URL$`] = null;
                    result[`${columnId}$ROUTER_LINK$`] = null;
                }
                return result;
            }, {});
        }
        return Object.assign({}, gridRowDataItem, {
            [RowDataItemIdFieldName]: gridRowDataItem[this.adaptTableConfig.primaryKey]
        }, hrefParams);
    }
    expandRowProperties(rowDataItem) {
        return Object.assign(Object.assign({}, rowDataItem), this.rxObjectUtilsService.expandProperties(rowDataItem));
    }
    expandSelectedRowsProperties(rowDataItems) {
        forEach(rowDataItems, (rowDataItem, index) => {
            rowDataItems[index] = this.expandRowProperties(rowDataItem);
        });
    }
    exportDataToCsv(cellValues, columnHeaders) {
        const csvSeparator = '","';
        const newLineSymbol = '\n';
        const columnHeadersString = `"${columnHeaders.join(csvSeparator)}"${newLineSymbol}`;
        const rowsString = cellValues.map((row) => `"${row.join(csvSeparator)}"${newLineSymbol}`).join('');
        const csvData = `${columnHeadersString}${rowsString}`;
        this.createCsvExportFile(csvData);
    }
    evaluateViewInputParameters(viewInputParams) {
        const evaluatedViewInputParams = {};
        forEach(viewInputParams, (expression, parameterName) => {
            const evaluatedExpression = this.rxExpressionEvaluatorService.tryEvaluate(expression, this.clickableWithHrefActionExpressionEvaluationData);
            evaluatedViewInputParams[parameterName] = evaluatedExpression || '';
        });
        return evaluatedViewInputParams;
    }
    filterRows(rows) {
        const searchText = get(this.adaptTableConfig.filters, 'global.value', '').toString().trim();
        let filteredRows = cloneDeep(rows);
        if (searchText) {
            const visibleColumns = this.getVisibleColumns();
            filteredRows = filteredRows.filter((row) => some(visibleColumns, (column) => {
                if (row.groupField) {
                    if (this.rxStringService.caseInsensitiveSearch(row.groupValue, searchText)) {
                        return true;
                    }
                    else {
                        row.items = this.getFilteredItems(row.items, visibleColumns, searchText);
                        return row.items.length;
                    }
                }
                else {
                    return this.rxStringService.caseInsensitiveSearch(this.getCellValue(row, column), searchText);
                }
            }));
        }
        if (!isEmpty(this.state.advancedFiltering.selectedFilters)) {
            filteredRows = this.rxRecordGridFilterService.filterRows(filteredRows, this.state.advancedFiltering.selectedFilters, this.state.recordDefinition, this.state.advancedFiltering.recordGridFilterConfigs);
        }
        if (this.adaptTableConfig.multiSortMeta) {
            if (this.state.expandGroups) {
                this.sortRows(filteredRows);
            }
            else {
                filteredRows.sort((firstRow, secondRow) => this.compareRows(firstRow, secondRow));
            }
        }
        if (this.state.expandGroups) {
            const getGroupItemsCount = (rowsWithGroups) => {
                const groups = rowsWithGroups.filter((row) => row.items);
                let count = rowsWithGroups.length - groups.length;
                groups === null || groups === void 0 ? void 0 : groups.forEach((group) => (count += getGroupItemsCount(group.items)));
                return count;
            };
            this.adaptTableConfig.totalRecords = getGroupItemsCount(filteredRows);
        }
        else {
            this.adaptTableConfig.totalRecords = filteredRows.length;
        }
        return filteredRows;
    }
    findEnabledGridAction(gridActions) {
        return gridActions.find((gridAction) => {
            const conditionExpression = gridAction['$condition$'];
            const condition = this.rxExpressionEvaluatorService.tryEvaluate(conditionExpression, this.clickableWithHrefActionExpressionEvaluationData);
            return condition !== false;
        });
    }
    getAdvancedFilterOptions() {
        return reduce(this.state.recordDefinition.fieldDefinitionsById, (filterOptions, fieldDefinition, field) => {
            var _a;
            // Due to nested structure need to check if it is a fieldDefinition
            if (!isUndefined(fieldDefinition.id)) {
                const gridColumn = this.adaptTableConfig.columns.find((column) => column.field === field);
                const isHidden = !gridColumn || !gridColumn.filterable;
                const filterConfig = this.state.advancedFiltering.recordGridFilterConfigs[fieldDefinition.resourceType];
                const additionalQueryCriteria = gridColumn === null || gridColumn === void 0 ? void 0 : gridColumn.additionalQueryCriteria;
                if (filterConfig) {
                    filterOptions.push(this.rxRecordGridAdvancedFilteringService.getAdvancedFilterOption(field, gridColumn ? gridColumn.header || gridColumn.fallbackTitle : fieldDefinition.name, fieldDefinition, filterConfig, isHidden, {
                        optionalBooleanFilter: this.fieldsProvider.optionalBooleanFilter,
                        requiredBooleanFilter: this.fieldsProvider.requiredBooleanFilter,
                        inputsForStringWithTypeAheadTemplate: this.fieldsProvider.inputsForStringWithTypeAheadTemplate,
                        inputsForStringTypeTemplate: this.fieldsProvider.inputsForStringTypeTemplate,
                        inputsForNumberTypeTemplate: this.fieldsProvider.inputsForNumberTypeTemplate,
                        inputsForTimeTypeTemplate: this.fieldsProvider.inputsForTimeTypeTemplate,
                        inputsForDateTypeTemplate: this.fieldsProvider.inputsForDateTypeTemplate,
                        inputsForDatetimeTypeTemplate: this.fieldsProvider.inputsForDatetimeTypeTemplate,
                        inputsForSelectionTypeTemplate: this.fieldsProvider.inputsForSelectionTypeTemplate
                    }, null, this.state.namedFilterOptions[field], (_a = gridColumn === null || gridColumn === void 0 ? void 0 : gridColumn.typeaheadKeystrokeCount) !== null && _a !== void 0 ? _a : null, (gridColumn === null || gridColumn === void 0 ? void 0 : gridColumn.filterable) ? additionalQueryCriteria : null));
                }
            }
            return filterOptions;
        }, []).sort((filterOption1, filterOption2) => filterOption1.label.localeCompare(filterOption2.label));
    }
    getAssociationDescriptors() {
        const recordDefinitionName = this.getRecordDefinitionName();
        return recordDefinitionName
            ? this.rxRecordGridUtilsService.getAssociationDescriptors(recordDefinitionName)
            : of([]);
    }
    getBaseDataPageParams() {
        const state = this.state;
        const params = {
            recorddefinition: state.recordDefinitionName
        };
        if (Boolean(state.associationDefinitionName)) {
            Object.assign(params, {
                associatedRecordInstanceId: state.associatedRecordId,
                associationDefinition: state.associationDefinitionName,
                nodeToQuery: state.associatedRecordNodeSide,
                recordDefinitionToQuery: state.recordDefinitionName
            });
        }
        if (state.associatedRoleName) {
            params.roleName = state.associatedRoleName;
        }
        return params;
    }
    getCellValueFormatter(column) {
        const fieldDefinition = column.fieldDefinition;
        let cellValueFormatter = (value) => value;
        switch (fieldDefinition.resourceType) {
            case RX_RECORD_DEFINITION.dataTypes.boolean.resourceType: {
                cellValueFormatter = (value) => this.rxBooleanPipe.transform(value);
                break;
            }
            case RX_RECORD_DEFINITION.dataTypes.selection.resourceType: {
                // column.fieldId should be used here because fieldId uniquely identifies the field,
                // while fieldDefinition.id may be the same for core and associated fields
                cellValueFormatter = (value) => this.selectionFieldOptionLabelsByFieldId[column.fieldId][value];
                break;
            }
            case RX_RECORD_DEFINITION.dataTypes.dateTime.resourceType: {
                cellValueFormatter = (value) => this.datePipe.transform(value, 'medium');
                break;
            }
            case RX_RECORD_DEFINITION.dataTypes.dateOnly.resourceType: {
                cellValueFormatter = (value) => this.datePipe.transform(value);
                break;
            }
            case RX_RECORD_DEFINITION.dataTypes.timeOnly.resourceType: {
                cellValueFormatter = (value) => value ? this.datePipe.transform(new Date(`2000-01-01T${value}`), 'mediumTime') : value;
                break;
            }
            case RX_RECORD_DEFINITION.dataTypes.attachment.resourceType: {
                cellValueFormatter = (value) => {
                    const attachmentName = get(value, 'name');
                    return isString(attachmentName) ? attachmentName : value;
                };
                break;
            }
            case RX_RECORD_DEFINITION.dataTypes.decimal.resourceType:
            case RX_RECORD_DEFINITION.dataTypes.real.resourceType: {
                const precision = fieldDefinition.precision;
                const digitsInfo = isNil(precision) || precision === -1 ? null : `1.${precision}-${precision}`;
                cellValueFormatter = (value) => this.decimalPipe.transform(value, digitsInfo);
                break;
            }
            case RX_RECORD_DEFINITION.dataTypes.integer.resourceType: {
                cellValueFormatter = (value) => this.decimalPipe.transform(value);
                break;
            }
        }
        return cellValueFormatter;
    }
    getCellValues(rows, visibleColumns) {
        return rows.map((row) => visibleColumns.map((visibleColumnConfig) => this.getCellValue(row, visibleColumnConfig)));
    }
    getColumns() {
        return this.adaptTableConfig.columns.map((column) => {
            const columnMetadata = find(this.state.columnsWithMetadata, {
                fieldId: column.field
            });
            return {
                field: column.field,
                header: column.header,
                hidden: getValueOrFunc(column.hidden),
                fieldDefinition: columnMetadata.fieldDefinition
            };
        });
    }
    getData(startIndex) {
        return this.getDataBase(startIndex, false).pipe(tap((dataPage) => {
            this.cursor = dataPage.cursor || undefined;
        }));
    }
    getDataBase(startIndex, onlyForTotalCount) {
        var _a, _b;
        let data$;
        const params = this.prepareQueryParamsAndQueryArgs(onlyForTotalCount);
        if ((_a = params.queryExpression) === null || _a === void 0 ? void 0 : _a.includes(RX_EXPRESSION_EVALUATOR.operands.undefined)) {
            this.rxLogService.debug(`Query expression contains undefined operands: ${params.queryExpression}`);
            return this.rxRecordInstanceDataPageService.getEmptyDataPage();
        }
        if (this.state.enableFiltering &&
            !this.isSearchApplied() &&
            this.state.requiredFilters > this.state.advancedFiltering.selectedFilters.length) {
            this.rxNotificationService.addWarningMessage(this.getFiltersRequiredMessage(this.state.requiredFilters), this.translateService.instant('com.bmc.arsys.rx.client.common.alert.label'));
            return this.rxRecordInstanceDataPageService.getEmptyDataPage();
        }
        if (isNumber(startIndex)) {
            params.startIndex = startIndex;
        }
        if (startIndex === 0) {
            delete params.cursor;
        }
        this.lastQueryExpression = (_b = params.queryExpression) !== null && _b !== void 0 ? _b : '';
        if (!onlyForTotalCount) {
            this.lastPropertySelection = params.propertySelection;
        }
        if (this.state.getData) {
            data$ = this.state.getData(Object.assign(Object.assign({}, params), { searchText: get(this.adaptTableConfig.filters, 'global.value', '').toString().trim() }));
        }
        else if (this.hasAssociationAndEmptyRecordId()) {
            data$ = this.rxAssociationInstanceDataPageService.getEmptyDataPage();
        }
        else {
            const dataPageService = this.getDataPageService();
            data$ = dataPageService.post({ params, headers: this.getHeaders() });
        }
        return data$;
    }
    getDataCellStyle(column) {
        let textAlign = '';
        switch (column.alignment) {
            case RX_RECORD_GRID.columnAlignment.left:
                textAlign = 'left';
                break;
            case RX_RECORD_GRID.columnAlignment.right:
                textAlign = 'right';
                break;
            case RX_RECORD_GRID.columnAlignment.center:
                textAlign = 'center';
                break;
            default:
                const rightAlignmentTypes = [
                    RX_RECORD_DEFINITION.dataTypes.integer.resourceType,
                    RX_RECORD_DEFINITION.dataTypes.decimal.resourceType,
                    RX_RECORD_DEFINITION.dataTypes.real.resourceType
                ];
                if (column.fieldDefinition.resourceType.search(rightAlignmentTypes.join('|')) !== -1) {
                    textAlign = 'right';
                }
                break;
        }
        return {
            'text-align': textAlign
        };
    }
    getDataPageService() {
        return Boolean(this.state.associationDefinitionName)
            ? this.rxAssociationInstanceDataPageService
            : this.rxRecordInstanceDataPageService;
    }
    getExportFileName() {
        const date = this.datePipe.transform(new Date(), 'yyyy-MM-dd');
        return `${date} Grid Data`;
    }
    getFilteredItems(items, visibleColumns, searchText) {
        return items.filter((item) => {
            let result;
            if (item.groupField) {
                if (this.rxStringService.caseInsensitiveSearch(item.groupValue, searchText)) {
                    result = true;
                }
                else {
                    item.items = this.getFilteredItems(item.items, visibleColumns, searchText);
                    result = item.items.length;
                }
            }
            else {
                result = some(visibleColumns, (visibleColumn) => this.rxStringService.caseInsensitiveSearch(this.getCellValue(item, visibleColumn), searchText));
            }
            return result;
        });
    }
    getFirstSelectedRow() {
        return get(this.adaptTableConfig.selectedItems, '0', null);
    }
    getGridColumnDefinitions(columnsWithMetadata) {
        const columnsConfig = [];
        columnsWithMetadata
            .slice()
            .sort((a, b) => a.index - b.index)
            .map((column) => {
            let sortable;
            const sortConfig = this.rxRecordGridConfigUtilsService.parseConfigString(column.sortable);
            const testId = this.rxRecordGridUtilsService.getTestIdForGridColumn(column.fieldId);
            if (isObject(sortConfig)) {
                sortable = true;
                if (this.adaptTableConfig.multiSortMeta) {
                    this.adaptTableConfig.multiSortMeta.splice(sortConfig.priority, 0, {
                        field: column.fieldId,
                        order: this.rxRecordGridConfigUtilsService.getColumnSortOrder(sortConfig.direction)
                    });
                }
                else {
                    this.adaptTableConfig.multiSortMeta = [
                        {
                            field: column.fieldId,
                            order: this.rxRecordGridConfigUtilsService.getColumnSortOrder(sortConfig.direction)
                        }
                    ];
                }
            }
            else {
                sortable = sortConfig;
            }
            const isColumnWidthInPixels = endsWith(column.width, 'px');
            const columnWidth = this.adaptTableConfig.columnResizeMode === ResizeMode.Expand && !isColumnWidthInPixels ? null : column.width;
            const columnMinWidth = (isColumnWidthInPixels && parseInt(columnWidth) < RX_RECORD_GRID.defaultColumnMinWidth ? columnWidth : null);
            if (column.fieldId === RX_RECORD_GRID.actionsColumnFieldDefinition.id) {
                columnsConfig.push({
                    field: column.fieldId,
                    header: column.title,
                    fallbackTitle: column.fallbackTitle,
                    width: columnWidth,
                    minWidth: columnMinWidth,
                    hidden: !column.visible,
                    cellTemplate: this.rowActionButtonsTemplate,
                    editTemplate: null,
                    filterTemplate: null,
                    headerTitleTemplate: null,
                    cellTooltip: null,
                    headerTooltip: null,
                    headerClass: null,
                    filterable: column.filterable,
                    searchable: column.searchable,
                    sortable,
                    editable: false,
                    customTemplate: this.rowActionButtonsTemplate,
                    clickable: false,
                    dataCellClass: 'rx-row-action-cell',
                    isRowActionsColumn: true,
                    testId
                });
            }
            else {
                columnsConfig.push({
                    field: column.fieldId,
                    header: column.title,
                    fallbackTitle: column.fallbackTitle,
                    width: columnWidth,
                    minWidth: columnMinWidth,
                    hidden: !column.visible,
                    cellTemplate: this.cellTemplate,
                    editTemplate: null,
                    filterTemplate: null,
                    headerTitleTemplate: null,
                    cellTooltip: (params) => {
                        return (this.showCellTooltip && this.getCellValue(params.dataItem, params.column)) || null;
                    },
                    headerTooltip: column.headerTooltip,
                    dataCellClass: this.getDataCellClass.bind(this),
                    dataCellStyle: this.getDataCellStyle(column),
                    headerClass: null,
                    sortable,
                    editable: null,
                    filterable: column.filterable,
                    searchable: column.searchable,
                    filterName: null,
                    filterParams: null,
                    clickable: column.clickable,
                    filterType: column.filterType,
                    isDownloadableAttachment: this.isDownloadableAttachmentColumn(column),
                    clickableWithHref: column.clickableWithHref,
                    customTemplate: column.cellTemplate,
                    wrapText: column.wrapText,
                    referenced: column.referenced,
                    cellDisplayProperties: column.cellDisplayProperties,
                    typeaheadKeystrokeCount: column.typeaheadKeystrokeCount,
                    additionalQueryCriteria: column.additionalQueryCriteria,
                    testId
                });
                this.cellValueFormatters[column.fieldId] = this.getCellValueFormatter(column);
            }
        });
        return columnsConfig;
    }
    getGridData(loadMore) {
        const onRequestEnd = () => {
            this.adaptTableConfig.isLoadingData = false;
            this.adaptTableConfig.isLoadingMoreData = false;
        };
        this.adaptTableConfig.isLoadingData = true;
        return this.getData(loadMore ? this.adaptTableConfig.data.length : 0).pipe(tap((res) => {
            onRequestEnd();
            const mappedData = res.data.map(this.enrichRowEntity.bind(this));
            if (this.state.useExternalFiltering) {
                if (loadMore) {
                    this.adaptTableConfig.data = this.adaptTableConfig.data.concat(mappedData);
                    if (mappedData.length === 0 || mappedData.length < this.adaptTableConfig.rows) {
                        this.adaptTableConfig.totalRecords = this.adaptTableConfig.data.length;
                    }
                }
                else {
                    this.adaptTableConfig.data = mappedData;
                    if (mappedData.length < this.adaptTableConfig.rows) {
                        this.adaptTableConfig.totalRecords = mappedData.length;
                    }
                    else {
                        this.adaptTableConfig.totalRecords = null;
                    }
                }
            }
            else {
                this.adaptTableConfig.originalRows = mappedData;
                this.adaptTableConfig.data = this.filterRows(this.adaptTableConfig.originalRows);
            }
            if (this.state.expandGroups) {
                this.adaptTableConfig.expandedGroupsKeys = {};
                const expandGroupsDeep = (rows) => {
                    rows.forEach((row) => {
                        if (row.items) {
                            const expandedGroupKey = this.adaptTableConfig.expandedGroupsKeys[row.groupField];
                            if (expandedGroupKey) {
                                expandedGroupKey[row.groupValue] = true;
                            }
                            else {
                                this.adaptTableConfig.expandedGroupsKeys[row.groupField] = { [row.groupValue]: true };
                            }
                            expandGroupsDeep(row.items);
                        }
                    });
                };
                expandGroupsDeep(this.adaptTableConfig.data);
            }
            this.adaptTableConfig.toolbarConfig.rightCustomSection = Boolean(this.state.enableRowSelection && this.adaptTableConfig.data.length);
            this.notifyPropertyChanged('totalRowCount', this.adaptTableConfig.data.length);
            this.notifyPropertyChanged('queryExpression', this.lastQueryExpression);
            this.notifyPropertyChanged('lastRefreshTime', new Date().toISOString());
            if (!loadMore) {
                this.onRowsSelectionChange([]);
                this.scrollToTop();
            }
            this.setSelectedFilteredRowsCount();
            this.dataLoaded.emit();
            this.dataLoadContextSubject.next({
                associatedRecordId: this.state.associatedRecordId,
                associatedRoleName: this.state.associatedRoleName,
                filterExpression: this.state.filterExpression,
                namedFilterOptions: this.state.namedFilterOptions
            });
            this.changeDetector.markForCheck();
        }), catchError((err) => {
            onRequestEnd();
            return throwError(err);
        }));
    }
    getHeaders() {
        return {
            'Should-Query-All-Locales': this.state.showDataForAllLocales ? 'true' : []
        };
    }
    getNamedFilterOptionsState(columns) {
        return columns.reduce((result, col) => {
            if (col.predefinedFilterPresets) {
                result[col.fieldId] = col.predefinedFilterPresets.sort((a, b) => a.index - b.index);
            }
            return result;
        }, {});
    }
    getProgrammaticActionButtons(recordGridActionButtons) {
        return recordGridActionButtons.map((actionButton) => {
            let actionButtonConfig;
            if (isFunction(actionButton.disabled) || isFunction(actionButton.hidden)) {
                actionButtonConfig = this.rowSelectionChanged.pipe(map((selectedItems) => {
                    return Object.assign(Object.assign({}, actionButton), { disabled: isFunction(actionButton.disabled)
                            ? actionButton.disabled(selectedItems)
                            : actionButton.disabled, hidden: isFunction(actionButton.hidden) ? actionButton.hidden(selectedItems) : actionButton.hidden });
                }));
            }
            else {
                actionButtonConfig = of(actionButton);
            }
            return {
                guid: actionButton.guid,
                config: actionButtonConfig,
                runtimeViewModelApi: {
                    triggerViewActions: (guid, viewActionTriggerEventName) => this.executeViewActions(actionButton.guid, get(actionButton, 'actions'), this.state.lastActionRow)
                },
                factory: null,
                outlets: null
            };
        });
    }
    getRecordDefinition() {
        if (this.state.getRecordDefinition) {
            return this.state
                .getRecordDefinition()
                .pipe(tap((recordDefinition) => this.rxRecordDefinitionService.applyLocalization(recordDefinition)));
        }
        return this.rxRecordDefinitionCacheService.getRecordDefinition(this.state.recordDefinitionName);
    }
    getRecordDefinitionName() {
        return this.state.recordDefinitionName;
    }
    getSelectedRowCount() {
        return this.adaptTableConfig.selectedItems.length;
    }
    getSelectedRows(inSortOrder = false) {
        if (inSortOrder) {
            // returns selected rows in order of sorting applied to grid
            return intersectionBy(this.adaptTableConfig.data, this.adaptTableConfig.selectedItems, RowDataItemIdFieldName);
        }
        else {
            // returns selected rows in order of selection
            return this.adaptTableConfig.selectedItems;
        }
    }
    getTotalRowCount() {
        return this.getDataBase(null, true);
    }
    getVirtualRowHeight() {
        var _a;
        if (!((_a = this.adaptTableConfig.cardLayoutColumns) === null || _a === void 0 ? void 0 : _a.length)) {
            return RX_RECORD_GRID.defaultRowHeight;
        }
        const singleRowHeight = 32;
        const padding = 3;
        return singleRowHeight * this.visibleColumns.length + 2 * padding;
    }
    hasAssociationAndEmptyRecordId() {
        return Boolean(this.state.associationDefinitionName) && !this.state.associatedRecordId;
    }
    initActionButtons() {
        if (this.isProgrammaticUse) {
            this.actionButtons = this.getProgrammaticActionButtons(this.state.actionButtons);
        }
        else {
            this.actionButtons = get(this.runtimeViewCanvasItemComponent.getChildren(RX_VIEW_DEFINITION.defaultOutletName), '[0].children');
        }
    }
    initAdvancedFilterTexts() {
        this.state.advancedFiltering.filterTexts = {
            initialDropdownAnchorLabel: this.translateService.instant('com.bmc.arsys.rx.client.common.filter-data.label')
        };
    }
    initCustomTexts() {
        this.adaptTableConfig.texts = {
            searchPlaceholder: this.state.searchFieldPlaceholderText,
            emptyStateLabelText: this.state.emptyStateLabelText,
            emptyStateWithFilterLabelText: this.state.emptyStateWithFilterLabelText,
            exportEntireDocument: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.export-all-rows.label'),
            exportSelected: this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.export-selected-rows.label')
        };
    }
    initGrid() {
        this.state.guid = this.guid;
        return forkJoin([
            this.rxGridConfiguratorService.getColumnsWithMetadata(this.guid, this.state.columns, this.state.recordDefinition),
            this.guid && this.state.enableFiltering ? this.getSharedFilterPresets() : of(null)
        ]).pipe(switchMap(([columnsWithMetadata, sharedFilterPresets]) => {
            this.state.columnsWithMetadata = columnsWithMetadata;
            this.state.namedFilterOptions = this.getNamedFilterOptionsState(columnsWithMetadata);
            this.isUserAllowedToDeleteRecords = this.state.recordDefinition
                ? this.state.recordDefinition.allowNonAdminToDeleteRecordInstances !== false ||
                    this.rxCurrentUserService.isAdministrator()
                : false;
            this.notifyPropertyChanged('isUserAllowedToDeleteRecords', this.isUserAllowedToDeleteRecords);
            this.addAssociationFieldsToRecordDefinition(columnsWithMetadata);
            // this has to be set prior to calling getGridColumnDefinitions
            this.selectionFieldOptionLabelsByFieldId =
                this.rxGridConfiguratorService.getSelectionFieldOptionLabelsByFieldId(this.state.columns, this.state.recordDefinition);
            this.adaptTableConfig.columnResizeMode = this.state.expandable ? ResizeMode.Expand : ResizeMode.Fit;
            this.adaptTableConfig.columns = this.getGridColumnDefinitions(columnsWithMetadata);
            this.state.advancedFiltering.recordGridFilterConfigs = this.rxRecordGridFilterConfigService.getConfigs();
            this.state.advancedFiltering.filterOptions = this.getAdvancedFilterOptions();
            this.state.advancedFiltering.filterOptions.push({
                id: RX_RECORD_GRID.externalPresetFilterOptionId,
                label: RX_RECORD_GRID.externalPresetFilterOptionId,
                dataType: AdvancedFilterOptionDataType.custom,
                isHidden: true,
                customConfig: {
                    getTagText: (value) => { var _a; return (_a = this.state.advancedFiltering.savedFilters.find((savedFilter) => savedFilter.id === value)) === null || _a === void 0 ? void 0 : _a.name; }
                }
            });
            this.adaptTableConfig.rowSelectionMode = this.state.enableRowSelection;
            this.adaptTableConfig.primaryKey = this.state.recordIdField;
            this.adaptTableConfig.bordered = this.state.bordered;
            this.adaptTableConfig.striped = this.state.striped;
            this.adaptTableConfig.toolbarConfig.rightCustomSection = Boolean(this.state.enableRowSelection && this.adaptTableConfig.data.length);
            this.state.initialFilters = this.rxRecordGridFilterHelperService.getRecordGridFilterDataFromPredefinedFilter(this.state.filters, this.state.recordGridFilters);
            this.clickableWithHrefColumnActions = reduce(columnsWithMetadata, (result, column) => {
                if (column.clickableWithHref) {
                    result[column.fieldId] = column.actions;
                }
                return result;
            }, {});
            if (!isEmpty(this.clickableWithHrefColumnActions)) {
                this.clickableWithHrefActionExpressionEvaluationData = {
                    view: {
                        components: {
                            [this.guid]: {
                                recordDefinition: this.state.recordDefinition
                            }
                        },
                        inputParams: this.runtimeViewModelApi.getViewInputParameters()
                    }
                };
            }
            if (this.guid) {
                return this.rxRecordGridUserPreferencesService.applyUserPreferences(this.adaptTableConfig, this.state.columnsWithMetadata, this.state, sharedFilterPresets);
            }
            return of(null);
        }), tap(() => {
            this.sortedColumnsByTitle = this.getSortedColumnsByTitle();
            this.filteredVisibleColumns = this.sortedColumnsByTitle;
            this.visibleColumns = this.getVisibleColumns();
            this.isFilterBySelectionButtonVisible = this.state.enableFiltering && some(this.visibleColumns, 'filterable');
            this.initActionButtons();
            this.initRowActionButtons();
            if (!this.state.viewPresetSelector) {
                // #ADAPT-8052 workaround.
                this.avoidSystemColumnExpansion();
                this.loadRowData();
            }
            this.updateToolbarTags(this.state.advancedFiltering.toolbarTags);
            this.updateAdaptTableFilters();
        }));
    }
    // #ADAPT-8052 workaround. System column width changes when removing a column from the grid.
    // If all columns have custom width in percents, proportionally increase the width of all columns.
    // If all columns have custom width in pixels, change the largest column width property to auto-expandable (width = null).
    // If % and px are both used, change the largest column width in % to auto-expandable (width= null).
    // If Actions column has customized width, avoid width change when possible. Preserving width in pixels is in priority.
    // Note:
    // Those column width modifications applied during initial rendering of the grid are not saved to User preferences,
    // because it is not the user intention but a workaround.
    avoidSystemColumnExpansion() {
        if (this.adaptTableConfig.cardLayoutColumns) {
            this.avoidSystemCardColumnExpansion();
            return;
        }
        const columnsWithWidthInPixels = [];
        const columnsWithWidthInPercent = [];
        const visibleActionsColumn = find(this.adaptTableConfig.columns, {
            field: RX_RECORD_GRID.actionsColumnFieldDefinition.id,
            hidden: false
        });
        let maxWidthInPixels = 0;
        let maxWidthInPercent = 0;
        let totalWidthInPercent = 0;
        const isEveryVisibleColumnWithCustomWidth = this.adaptTableConfig.columns.every((column) => {
            if (!column.hidden) {
                if (isNil(column.width)) {
                    return false;
                }
                const columnWidth = parseFloat(column.width);
                if (column.width.endsWith('px')) {
                    columnsWithWidthInPixels.push(column);
                    if (column !== visibleActionsColumn) {
                        maxWidthInPixels = Math.max(maxWidthInPixels, columnWidth);
                    }
                }
                else {
                    columnsWithWidthInPercent.push(column);
                    totalWidthInPercent += columnWidth;
                    if (column !== visibleActionsColumn) {
                        maxWidthInPercent = Math.max(maxWidthInPercent, columnWidth);
                    }
                }
            }
            return true;
        });
        if (isEveryVisibleColumnWithCustomWidth && totalWidthInPercent < 100) {
            const hasColumnsWithWidthInPercent = Boolean(columnsWithWidthInPercent.length);
            const hasColumnsWithWidthInPixels = Boolean(columnsWithWidthInPixels.length);
            if (hasColumnsWithWidthInPercent && !hasColumnsWithWidthInPixels) {
                columnsWithWidthInPercent.forEach((column) => {
                    column.width = `${((parseFloat(column.width) / totalWidthInPercent) * 100).toFixed(4)}%`;
                });
            }
            if (!hasColumnsWithWidthInPercent && hasColumnsWithWidthInPixels) {
                if (columnsWithWidthInPixels.length === 1 && visibleActionsColumn) {
                    visibleActionsColumn.width = null;
                    visibleActionsColumn.minWidth = null;
                }
                else {
                    findLast(columnsWithWidthInPixels, (column) => {
                        if (parseInt(column.width) === maxWidthInPixels && column !== visibleActionsColumn) {
                            column.width = null;
                            column.minWidth = null;
                            return true;
                        }
                        else {
                            return false;
                        }
                    });
                }
            }
            if (hasColumnsWithWidthInPercent && hasColumnsWithWidthInPixels) {
                if (columnsWithWidthInPercent.length === 1 && visibleActionsColumn) {
                    visibleActionsColumn.width = null;
                    visibleActionsColumn.minWidth = null;
                }
                else {
                    findLast(columnsWithWidthInPercent, (column) => {
                        if (parseFloat(column.width) === maxWidthInPercent && column !== visibleActionsColumn) {
                            column.width = null;
                            return true;
                        }
                        else {
                            return false;
                        }
                    });
                }
            }
        }
    }
    // This is a workaround for Adapt defect on System column (checkbox)
    // when the user is using an Ios device and the grid is in card mode.
    // It seems setting the columns in % does not work correctly, in the case of
    // card display we have only two columns with 35% and 65%, however
    // the Adapt grid tries to display the cards around 50% each.
    // For example for an Iphone 14 Pro on Xcode simulator the grid total size is 359px:
    // -> 96.31px for the system column (instead of 33px),
    // -> 130.34px for the second column,
    // -> 131.34px for the third column,
    // In order to "fix" the issue, the user has to "tap" on the separator
    // between columns 2 and 3, which then seems to "redraw" the grid.
    // Workaround:
    // Setting the values of both columns in px instead of % solves the problem.
    // For now, we only apply this workaround on ios platform.
    avoidSystemCardColumnExpansion() {
        if (!this.adaptDeviceDetectionService.iosPlatform()) {
            return;
        }
        const adaptSystemColumnWidth = 33;
        const availableColumnWidth = this.adaptTable.dataHeaderCells.reduce((accum, cell) => accum + cell.element.nativeElement.offsetWidth, 0) -
            adaptSystemColumnWidth;
        this.adaptTableConfig.cardLayoutColumns.forEach((column) => {
            column.width = `${((parseFloat(column.width) * availableColumnWidth) / 100).toFixed(4)}px`;
        });
    }
    initRecordDefinitions() {
        this.setRecordDefinition(null);
        this.state.associationDescriptors = [];
        const hasAssociatedRecordFieldColumns = some(this.state.columns, (column) => this.rxRecordGridUtilsService.isAssociatedRecordFieldId(column.fieldId));
        return forkJoin([
            this.getRecordDefinition(),
            hasAssociatedRecordFieldColumns ? this.getAssociationDescriptors() : of([])
        ]).pipe(tap(([recordDefinition, associationDescriptors]) => {
            this.setRecordDefinition(recordDefinition);
            this.state.associationDescriptors = associationDescriptors;
        }), map(([recordDefinition]) => recordDefinition));
    }
    initRowActionButtons() {
        if (this.isProgrammaticUse) {
            this.rowActionButtons = this.getProgrammaticActionButtons(this.state.rowActionButtons);
        }
        else {
            this.rowActionButtons = get(this.runtimeViewCanvasItemComponent.getChildren(RX_RECORD_GRID.rowActionsOutletName), '[0].children');
        }
    }
    isDownloadableAttachmentColumn(column) {
        const recordDefinitionType = get(this.state.recordDefinition, 'resourceType');
        const fieldDefinitionType = get(column, 'fieldDefinition.resourceType');
        return (!this.isProgrammaticUse &&
            (recordDefinitionType === RX_RECORD_DEFINITION.recordDefinitionTypes.regular.recordDefinitionType ||
                recordDefinitionType === RX_RECORD_DEFINITION.recordDefinitionTypes.join.recordDefinitionType) &&
            fieldDefinitionType === RX_RECORD_DEFINITION.dataTypes.attachment.resourceType);
    }
    isRangeFilter(fieldId) {
        const rangeFields = [
            RX_RECORD_DEFINITION.dataTypes.dateOnly.resourceType,
            RX_RECORD_DEFINITION.dataTypes.dateTime.resourceType,
            RX_RECORD_DEFINITION.dataTypes.timeOnly.resourceType,
            RX_RECORD_DEFINITION.dataTypes.integer.resourceType,
            RX_RECORD_DEFINITION.dataTypes.decimal.resourceType,
            RX_RECORD_DEFINITION.dataTypes.real.resourceType
        ];
        const fieldDefinition = this.state.recordDefinition.fieldDefinitionsById[fieldId];
        return includes(rangeFields, fieldDefinition.resourceType);
    }
    isSharedFilterPreset(savedFilter) {
        return Boolean(savedFilter.filterExpression);
    }
    loadRowData(loadMore) {
        this.getGridData(loadMore).subscribe();
    }
    openSortByDialogFn(config) {
        this.cardLayoutOpenedModal = this.adaptModalService.open(config);
        return this.cardLayoutOpenedModal;
    }
    prepareQueryParamsAndQueryArgs(onlyForTotalCount) {
        const primaryKey = this.adaptTableConfig.primaryKey;
        const queryParams = Object.assign(Object.assign({}, this.getBaseDataPageParams()), { shouldIncludeTotalSize: onlyForTotalCount, pageSize: onlyForTotalCount ? 0 : this.adaptTableConfig.rows, startIndex: onlyForTotalCount ? 0 : this.adaptTableConfig.first });
        if (this.cursor && !onlyForTotalCount) {
            queryParams.cursor = this.cursor;
        }
        if (!onlyForTotalCount) {
            queryParams.propertySelection = chain(this.adaptTableConfig.columns
                .filter((col) => !col.isRowActionsColumn && (this.state.getDataForHiddenColumns || !col.hidden || col.referenced))
                .map((col) => col.field))
                .union([primaryKey])
                .value();
        }
        const multiSortMeta = this.adaptTableConfig.multiSortMeta;
        if (!onlyForTotalCount && multiSortMeta && multiSortMeta.length) {
            queryParams.sortBy = multiSortMeta.map((metaItem) => metaItem.order === SortOrder.Asc ? `${metaItem.field}` : `-${metaItem.field}`);
        }
        const searchText = get(this.adaptTableConfig.filters, 'global.value', '').toString().trim();
        const textSearchQuery = this.rxRecordGridFilterService.generateTextFilterQuery(searchText, this.adaptTableConfig.columns);
        const appliedSharedFilterPreset = this.state.advancedFiltering.appliedSharedFilterPreset;
        const sharedFilterPresetExpression = appliedSharedFilterPreset && appliedSharedFilterPreset.filterExpression
            ? `(${appliedSharedFilterPreset.filterExpression})`
            : null;
        const resultingQuery = this.rxRecordGridFilterService.addQueries(this.rxRecordGridFilterService.getQueryFromRecordGridFilterData(this.state.initialFilters, this.state.recordDefinition.fieldDefinitionsById), this.buildQueryByAdvancedFilters(this.state.advancedFiltering.selectedFilters), textSearchQuery, this.state.filterExpression, sharedFilterPresetExpression);
        if (resultingQuery) {
            queryParams.queryExpression = resultingQuery;
        }
        return queryParams;
    }
    refresh() {
        return this.initializationCompleted$.pipe(switchMap(() => this.getGridData()), switchMapTo(EMPTY));
    }
    saveViewPreset(viewPresetGuid) {
        this.rxRecordGridUserPreferencesService.saveViewPreset(viewPresetGuid);
        this.userPreferencesChanged$.next();
        return EMPTY;
    }
    scrollToTop() {
        if (this.adaptTable) {
            const scrollableBodyElement = this.adaptTable.getScrollableBodyElement();
            if (scrollableBodyElement) {
                scrollableBodyElement.scrollTop = 0;
            }
        }
    }
    setFilter(newFilter) {
        this.state.advancedFiltering.selectedFilters = newFilter;
    }
    setRecordDefinition(recordDefinition) {
        this.state.recordDefinition = cloneDeep(recordDefinition);
        if (recordDefinition) {
            this.state.recordDefinition.fieldDefinitionsById = this.rxRecordDefinitionService.buildFieldDefinitionsByIdMap(this.state.recordDefinition);
        }
        this.notifyPropertyChanged('recordDefinition', this.state.recordDefinition);
    }
    setSelectedFilteredRowsCount() {
        this.selectedFilteredRowsCount = this.adaptTable.hasFilter() ? this.getSelectedRows().length : 0;
    }
    sortRows(rows) {
        rows.sort((firstRow, secondRow) => this.compareRows(firstRow, secondRow));
        forEach(rows, (row) => {
            var _a;
            if ((_a = row.items) === null || _a === void 0 ? void 0 : _a.length) {
                this.sortRows(row.items);
            }
        });
    }
    toggleCellSelection(columns, rowItem, popover, isCardLayout) {
        if (this.state.enableFiltering) {
            if (!isCardLayout) {
                const column = columns[0];
                if (column.filterable) {
                    const existingPendingFilter = find(this.state.advancedFiltering.pendingSelectedFilters, {
                        filterOptionId: column.field
                    });
                    const filterValue = !rowItem[column.field] && rowItem[column.field] !== 0 ? '$NULL$' : rowItem[column.field];
                    const fieldDefinition = this.state.recordDefinition.fieldDefinitionsById[column.field];
                    const isRangeFilter = this.isRangeFilter(column.field);
                    const isRequiredBooleanFilter = fieldDefinition.resourceType === RX_RECORD_DEFINITION.dataTypes.boolean.resourceType &&
                        this.rxFieldDefinitionService.isRequiredField(fieldDefinition);
                    const isFilterAvailable = !((isRangeFilter && existingPendingFilter && existingPendingFilter.value.length === 2) ||
                        (isRequiredBooleanFilter && existingPendingFilter) ||
                        (filterValue === '$NULL$' && (isRangeFilter || isRequiredBooleanFilter)));
                    if (existingPendingFilter) {
                        if (this.isCellSelected(popover)) {
                            const elementIndex = findIndex(existingPendingFilter.value, filterValue);
                            existingPendingFilter.value.splice(elementIndex, 1);
                            this.trackPopoverAnchor(popover);
                            if (!existingPendingFilter.value.length) {
                                remove(this.state.advancedFiltering.pendingSelectedFilters, existingPendingFilter);
                            }
                        }
                        else if (isFilterAvailable) {
                            existingPendingFilter.value.push(filterValue);
                            this.trackPopoverAnchor(popover);
                        }
                    }
                    else if (isFilterAvailable) {
                        const selectedFilter = {
                            filterOptionId: column.field,
                            value: [filterValue]
                        };
                        this.state.advancedFiltering.pendingSelectedFilters.push(selectedFilter);
                        this.trackPopoverAnchor(popover);
                    }
                }
            }
            else {
                const filterableColumns = columns.filter((column) => {
                    const fieldDefinition = this.state.recordDefinition.fieldDefinitionsById[column.field];
                    const isRequiredBooleanFilter = fieldDefinition.resourceType === RX_RECORD_DEFINITION.dataTypes.boolean.resourceType &&
                        this.rxFieldDefinitionService.isRequiredField(fieldDefinition);
                    return column.filterable && !isRequiredBooleanFilter;
                });
                const isCellSelected = this.isCellSelected(popover);
                forEach(filterableColumns, (column) => {
                    if (column.filterable) {
                        const filterValue = !rowItem[column.field] && rowItem[column.field] !== 0 ? '$NULL$' : rowItem[column.field];
                        if (!this.state.advancedFiltering.selectedCardValues[column.field]) {
                            this.state.advancedFiltering.selectedCardValues[column.field] = [filterValue];
                        }
                        else if (isCellSelected) {
                            remove(this.state.advancedFiltering.selectedCardValues[column.field], filterValue);
                        }
                        else {
                            this.state.advancedFiltering.selectedCardValues[column.field].push(filterValue);
                        }
                    }
                });
            }
        }
    }
    trackPopoverAnchor(cellPopover) {
        var _a, _b;
        if (this.isCellSelected(cellPopover)) {
            const isCurrentPopoverLast = cellPopover === last(this.popovers);
            remove(this.popovers, cellPopover);
            if (isCurrentPopoverLast) {
                cellPopover.close();
                (_a = last(this.popovers)) === null || _a === void 0 ? void 0 : _a.open();
            }
        }
        else {
            (_b = last(this.popovers)) === null || _b === void 0 ? void 0 : _b.close();
            this.popovers.push(cellPopover);
            cellPopover.open();
        }
    }
    updateAdaptTableFilters() {
        const globalFilter = this.adaptTable.filters.global;
        this.adaptTable.filters = this.areUserFiltersApplied() ? { dummyFilter: {} } : {};
        if (globalFilter) {
            this.adaptTable.filters.global = globalFilter;
        }
    }
    updateToolbarItems() {
        if (this.adaptTable) {
            const toolbarComponent = this.adaptTable.toolbarComponent;
            const filterSection = toolbarComponent.toolbarContentItems.find((toolbarContentItem) => toolbarContentItem.adaptToolbarItem === ToolbarItemsByPriority.FILTER);
            setTimeout(() => {
                // don't update toolbar items when filter is hidden
                if (filterSection && !filterSection.itemContext.hidden) {
                    toolbarComponent.updateToolbarItems();
                }
            });
        }
    }
    getExportSelectedText(selectedItems) {
        return selectedItems.length > 1 ? this.exportSelectedRowsText : this.exportSelectedRowText;
    }
    getFiltersRequiredMessage(requiredFiltersCount) {
        return requiredFiltersCount > 1
            ? this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.require-filtering.missing-filters-warning.message', {
                requiredFiltersCount: requiredFiltersCount
            })
            : this.translateService.instant('com.bmc.arsys.rx.client.view-components.record-grid.require-filtering.missing-filter-warning.message');
    }
}
RecordGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridComponent, deps: [{ token: i1.AdaptDeviceDetectionService }, { token: i1.AdaptModalService }, { token: i0.ChangeDetectorRef }, { token: i3.DatePipe }, { token: i3.DecimalPipe }, { token: i0.NgZone }, { token: i2$4.RxAssociationInstanceDataPageService }, { token: i1$1.RxBooleanPipe }, { token: i1$1.RxCurrentUserService }, { token: i1$4.RxExpressionEvaluatorService }, { token: i1$5.RxFieldDefinitionService }, { token: RxRecordGridConfiguratorService }, { token: i2$1.RxGuidService }, { token: i1$1.RxLogService }, { token: i1$1.RxNotificationService }, { token: i2$1.RxObjectUtilsService }, { token: i1$5.RxRecordDefinitionCacheService }, { token: i1$5.RxRecordDefinitionService }, { token: RxRecordGridAdvancedFilteringService }, { token: RxRecordGridConfigUtilsService }, { token: RxRecordGridFilterConfigService }, { token: RxRecordGridFilterService }, { token: RxRecordGridFilterHelperService }, { token: RxRecordGridSharedFilterPresetsCacheService }, { token: RxRecordGridUserPreferencesService }, { token: RxRecordGridUtilsService }, { token: i1$5.RxRecordInstanceDataPageService }, { token: i1$5.RxRecordInstanceService }, { token: i1$4.RxViewActionService }, { token: i1$4.RxViewActionUtilsService }, { token: i2.TranslateService }, { token: i0.ElementRef }, { token: i2$1.RxStringService }, { token: i1$1.RxGlobalEventsService }, { token: PageComponent, optional: true }, { token: i1$2.RuntimeViewCanvasItemComponent, optional: true }], target: i0.ɵɵFactoryTarget.Component });
RecordGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RecordGridComponent, selector: "rx-record-grid", inputs: { config: "config" }, outputs: { dataLoaded: "dataLoaded" }, host: { listeners: { "document:click": "onClickOutside($event)" } }, providers: [RxRecordGridUserPreferencesService], viewQueries: [{ propertyName: "adaptTable", first: true, predicate: ["adaptTable"], descendants: true, static: true }, { propertyName: "adaptAdvancedFilter", first: true, predicate: ["adaptAdvancedFilter"], descendants: true }, { propertyName: "cardLayoutRowDetailsTemplate", first: true, predicate: ["cardLayoutRowDetailsTemplate"], descendants: true, static: true }, { propertyName: "cellTemplate", first: true, predicate: ["cellTemplate"], descendants: true, static: true }, { propertyName: "filterTemplate", first: true, predicate: ["filterTemplate"], descendants: true, static: true }, { propertyName: "leftCustomSectionTemplate", first: true, predicate: ["leftCustomSectionTemplate"], descendants: true, static: true }, { propertyName: "rightCustomSectionTemplate", first: true, predicate: ["rightCustomSectionTemplate"], descendants: true, static: true }, { propertyName: "rowActionButtonsTemplate", first: true, predicate: ["rowActionButtonsTemplate"], descendants: true, static: true }, { propertyName: "visibleColumnsMenuTemplate", first: true, predicate: ["visibleColumnsMenuTemplate"], descendants: true, static: true }, { propertyName: "fieldsProvider", first: true, predicate: RxAdvancedFilteringFieldsProviderComponent, descendants: true, static: true }, { propertyName: "actionButtonComponents", predicate: ActionButtonComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<adapt-table\n  #adaptTable\n  rxCardLayout\n  scrollHeight=\"flex\"\n  (changedCardLayout)=\"onChangedCardLayout($event)\"\n  [cardLayoutWidth]=\"state.cardLayoutWidth\"\n  [cardLayoutFieldsHeaderTemplate]=\"cardLayoutFieldsHeaderTemplate\"\n  [cardLayoutFieldsDataCellTemplate]=\"cardLayoutFieldsDataCellTemplate\"\n  [cardLayoutValuesDataCellTemplate]=\"cardLayoutValuesDataCellTemplate\"\n  [cardLayoutValuesHeaderTemplate]=\"cardLayoutValuesHeaderTemplate\"\n  [cardLayoutRecordGridElementRef]=\"elementRef\"\n  [cardLayoutGetDataCellClass]=\"getDataCellClassBind\"\n  [value]=\"adaptTableConfig.data\"\n  [columns]=\"adaptTableConfig.cardLayoutColumns || adaptTableConfig.columns\"\n  [rows]=\"adaptTableConfig.rows\"\n  [first]=\"adaptTableConfig.first\"\n  [scrollable]=\"adaptTableConfig.scrollable\"\n  [sortable]=\"true\"\n  [rowExpandMode]=\"\"\n  [sortMode]=\"'multiple'\"\n  [resizableColumns]=\"true\"\n  [columnResizeMode]=\"adaptTableConfig.columnResizeMode\"\n  [selectionMode]=\"adaptTableConfig.rowSelectionMode\"\n  [selection]=\"adaptTableConfig.selectedItems\"\n  [toolbarConfig]=\"adaptTableConfig.toolbarConfig\"\n  [filterable]=\"adaptTableConfig.filterable\"\n  [filters]=\"adaptTableConfig.filters\"\n  [multiSortMeta]=\"adaptTableConfig.multiSortMeta\"\n  [dataKey]=\"adaptTableConfig.primaryKey\"\n  [bordered]=\"adaptTableConfig.bordered\"\n  [totalRecords]=\"adaptTableConfig.totalRecords\"\n  [totalRecordsInGroup]=\"state.expandGroups ? adaptTableConfig.totalRecords : 0\"\n  [lazy]=\"true\"\n  [lazyLoadOnInit]=\"false\"\n  [loading]=\"adaptTableConfig.isLoadingData\"\n  [enableInfiniteScrolling]=\"true\"\n  [expandedGroupsKeys]=\"adaptTableConfig.expandedGroupsKeys\"\n  [loadingMore]=\"adaptTableConfig.isLoadingMoreData\"\n  [suppressTooltip]=\"false\"\n  [virtualScroll]=\"adaptTableConfig.virtualScroll\"\n  [virtualRowHeight]=\"adaptTableConfig.virtualRowHeight\"\n  (selectionChange)=\"onRowsSelectionChange($event)\"\n  (onSort)=\"onSort($event)\"\n  (onLazyLoad)=\"onLazyLoad($event)\"\n  (onColReorder)=\"onColReorder($event)\"\n  [striped]=\"adaptTableConfig.striped\"\n  [texts]=\"adaptTableConfig.texts\"\n  (onColResize)=\"onColumnResize()\"\n  (export)=\"onExport($event)\"\n  [selectedFilteredRowsCount]=\"selectedFilteredRowsCount\"\n  [headerSelectionMode]=\"adaptTableHeaderSelectionMode\"\n  (onHeaderCheckboxToggle)=\"handleHeaderCheckboxToggle($event)\"\n></adapt-table>\n\n<ng-template #visibleColumnsMenuTemplate>\n  <adapt-rx-search\n    [(ngModel)]=\"columnSearchText\"\n    [placeholder]=\"\n      'com.bmc.arsys.rx.client.view-components.record-grid.visible-columns-menu.search.placeholder' | translate\n    \"\n    [autofocus]=\"true\"\n    (ngModelChange)=\"onSearchColumns()\"\n  >\n  </adapt-rx-search>\n  <div\n    class=\"dropdown-item visible-columns-item px-3\"\n    *ngFor=\"let column of filteredVisibleColumns; trackBy: trackByColumnField\"\n    (click)=\"$event.stopPropagation()\"\n  >\n    <adapt-rx-checkbox\n      class=\"m-0 adapt-table-toolbar__column-visibility-control\"\n      [label]=\"column.header || column.fallbackTitle\"\n      [ngModel]=\"!column.hidden\"\n      (ngModelChange)=\"onColumnVisibilityChange($event, column)\"\n    ></adapt-rx-checkbox>\n  </div>\n  <adapt-empty-state\n    *ngIf=\"!filteredVisibleColumns.length\"\n    [type]=\"'search'\"\n    [label]=\"'com.bmc.arsys.rx.client.view-components.record-grid.visible-columns-menu.empty.label' | translate\"\n  >\n  </adapt-empty-state>\n</ng-template>\n\n<ng-template #rightCustomSectionTemplate>\n  <div class=\"px-2\" rx-id=\"selected-row-count\">\n    <ng-container *ngIf=\"isTotalRecordCountKnown\">\n      {{ getMultipleRowsSelectedText() }}\n    </ng-container>\n\n    <ng-container *ngIf=\"!isTotalRecordCountKnown\">\n      <div class=\"d-flex align-items-center\">\n        {{ getMultipleRowsSelectedTextFirstPart() }}\n        <button type=\"button\" class=\"btn btn-link p-0 mx-1\" (click)=\"loadTotalRowCount()\">\n          {{ getLoadRecordCountLinkText() }}\n        </button>\n        {{ getMultipleRowsSelectedTextSecondPart() }}\n      </div>\n    </ng-container>\n  </div>\n</ng-template>\n\n<ng-template #leftCustomSectionTemplate>\n  <div [adaptSubnav] *ngIf=\"shouldDisplayActionButtons\" class=\"pl-1 w-100 align-items-center\">\n    <div [adaptSubnavItem]=\"actionButtonTemplate\" *ngFor=\"let actionButton of actionButtons\">\n      <ng-template #actionButtonTemplate let-hidden>\n        <rx-action-button\n          class=\"m-1\"\n          [guid]=\"actionButton.guid\"\n          [config]=\"getActionButtonConfig(hidden, actionButton.config)\"\n          [runtimeViewModelApi]=\"actionButton.runtimeViewModelApi\"\n        ></rx-action-button>\n      </ng-template>\n    </div>\n\n    <div [adaptSubnavDropdown]>\n      <button type=\"button\" class=\"btn btn-secondary btn-xs d-icon-triangle_down ml-1\"></button>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #filterTemplate let-context>\n  <button\n    type=\"button\"\n    class=\"btn btn-link d-icon-refresh grid-toolbar-icon ml-2 p-1\"\n    [ngClass]=\"{ 'd-block': context.hidden }\"\n    rx-id=\"refresh-button\"\n    [attr.aria-label]=\"'com.bmc.arsys.rx.client.common.refresh.label' | translate\"\n    (click)=\"onRefreshClick()\"\n  ></button>\n\n  <adapt-advanced-filter\n    #adaptAdvancedFilter\n    *ngIf=\"state.enableFiltering\"\n    class=\"ml-2\"\n    [ngClass]=\"{ 'd-inline-block': context.hidden, 'd-block': !context.hidden }\"\n    [appendDropdownToBody]=\"true\"\n    [texts]=\"state.advancedFiltering.filterTexts\"\n    [showAnchorButtonLabel]=\"!context.collapsed\"\n    [filterOptions]=\"state.advancedFiltering.filterOptions\"\n    (selectedFiltersChange)=\"onAdvancedFiltersChange($event)\"\n    [selectedFilters]=\"state.advancedFiltering.selectedFilters\"\n    [savedFilters]=\"state.advancedFiltering.savedFilters\"\n    [enableSavedFilters]=\"!!guid && state.enableFilterPresets\"\n    (deleteSavedFilter)=\"onDeleteSavedFilterPreset($event)\"\n    (createNewFilter)=\"onCreateNewFilterPreset($event)\"\n    (updateSavedFilter)=\"onUpdateSavedFilterPreset($event)\"\n    [activeSavedFilter]=\"state.advancedFiltering.activeSavedFilter\"\n    (activeSavedFilterChange)=\"onActiveSavedAdvancedFilterChange($event)\"\n    (beforeActiveSavedFilterChange)=\"onBeforeActiveSavedFilterChange($event)\"\n    (editSavedFilterClick)=\"onEditSavedFilterClick($event)\"\n    [isLoading]=\"state.advancedFiltering.isLoading\"\n    [selectedFiltersIndicationStyle]=\"'mark'\"\n    (filterExpressionTagsChanged)=\"onAdvancedFilterExpressionTagsChanged($event)\"\n    [applyFiltersByUserAction]=\"true\"\n  ></adapt-advanced-filter>\n\n  <span\n    *ngIf=\"(context.collapsed || context.hidden) && state.advancedFiltering.toolbarTags.length\"\n    class=\"btn-link ml-1\"\n    >{{\n      'com.bmc.arsys.rx.client.view-components.record-grid.filters.number-of-active-filters.label'\n        | translate: { count: state.advancedFiltering.toolbarTags.length }\n    }}</span\n  >\n\n  <rx-filter-tags\n    class=\"ml-2\"\n    [hidden]=\"context.collapsed || context.hidden\"\n    [tags]=\"state.advancedFiltering.toolbarTags\"\n    [tagsLimit]=\"state.filterTagsLimit\"\n    (removeTag)=\"onRemoveFilterTag($event)\"\n  ></rx-filter-tags>\n</ng-template>\n\n<ng-template #cellTemplate let-dataItem=\"dataItem\" let-column=\"column\">\n  <div\n    *ngIf=\"column.cellDisplayProperties\"\n    class=\"rx-custom-cell rx-ellipsis\"\n    [rxCellDisplayProps]=\"column.cellDisplayProperties\"\n    [rxCellDisplayPropsBadgeElem]=\"badgeElem\"\n    [rxCellDisplayPropsDataItem]=\"dataItem\"\n    #popoverAnchor=\"adaptPopover\"\n    [adaptPopover]=\"filterButton\"\n    [autoClose]=\"false\"\n    [popoverClass]=\"'table-filtering'\"\n    [triggers]=\"'manual'\"\n    [appendToBody]=\"true\"\n    [placement]=\"'top'\"\n    [class.rx-selected-custom-cell]=\"isCellSelected(popoverAnchor)\"\n    (click)=\"onCellClick($event, [column], dataItem, popoverAnchor)\"\n    (mouseover)=\"onCellMouseOver($event)\"\n  >\n    <span #badgeElem (click)=\"$event.stopPropagation()\" [ngClass]=\"{ 'rx-cell-wrap': column.wrapText }\">\n      <ng-template\n        [ngTemplateOutlet]=\"column.customTemplate || defaultCellTemplate\"\n        [ngTemplateOutletContext]=\"{ column: column, dataItem: dataItem }\"\n      >\n      </ng-template>\n    </span>\n  </div>\n\n  <div\n    *ngIf=\"!column.cellDisplayProperties\"\n    class=\"rx-custom-cell rx-ellipsis\"\n    #popoverAnchor=\"adaptPopover\"\n    [adaptPopover]=\"filterButton\"\n    [autoClose]=\"false\"\n    [popoverClass]=\"'table-filtering'\"\n    [triggers]=\"'manual'\"\n    [appendToBody]=\"true\"\n    [placement]=\"'top'\"\n    [class.rx-selected-custom-cell]=\"isCellSelected(popoverAnchor)\"\n    (click)=\"onCellClick($event, [column], dataItem, popoverAnchor)\"\n    (mouseover)=\"onCellMouseOver($event)\"\n  >\n    <span (click)=\"$event.stopPropagation()\" [ngClass]=\"{ 'rx-cell-wrap': column.wrapText }\">\n      <ng-template\n        [ngTemplateOutlet]=\"column.customTemplate || defaultCellTemplate\"\n        [ngTemplateOutletContext]=\"{ column: column, dataItem: dataItem }\"\n      >\n      </ng-template>\n    </span>\n  </div>\n</ng-template>\n\n<ng-template #defaultCellTemplate let-dataItem=\"dataItem\" let-column=\"column\">\n  <ng-container\n    *ngIf=\"\n      (!column.clickable ||\n        (column.clickableWithHref &&\n          !dataItem[column.field + '$ROUTER_LINK$'] &&\n          !dataItem[column.field + '$LAUNCH_URL$'])) &&\n      !column.isDownloadableAttachment\n    \"\n  >\n    <span [ngClass]=\"{ 'rx-cell-wrap': column.wrapText }\"> {{ getCellValue(dataItem, column) }}</span>\n  </ng-container>\n\n  <a\n    tabindex=\"0\"\n    class=\"attachment-link\"\n    *ngIf=\"!column.clickable && column.isDownloadableAttachment\"\n    (click)=\"downloadAttachment(dataItem, column, getCellValue(dataItem, column))\"\n    (keydown)=\"downloadAttachment(dataItem, column, getCellValue(dataItem, column), $event)\"\n  >\n    <span [ngClass]=\"{ 'rx-cell-wrap': column.wrapText }\">\n      {{ getCellValue(dataItem, column) }}\n    </span>\n  </a>\n\n  <a\n    tabindex=\"0\"\n    class=\"no-href-link\"\n    *ngIf=\"column.clickable && !column.clickableWithHref\"\n    (click)=\"gridEvents.cellClick(dataItem, column.field)\"\n    (keydown)=\"gridEvents.cellKeyDown($event, dataItem, column.field)\"\n  >\n    <span [ngClass]=\"{ 'rx-cell-wrap': column.wrapText }\">\n      {{ getCellValue(dataItem, column) }}\n    </span>\n  </a>\n\n  <a\n    *ngIf=\"column.clickableWithHref && dataItem[column.field + '$ROUTER_LINK$']\"\n    [routerLink]=\"'/' + dataItem[column.field + '$ROUTER_LINK$']\"\n    [queryParams]=\"dataItem[column.field + '$QUERY_PARAMS$']\"\n  >\n    <span [ngClass]=\"{ 'rx-cell-wrap': column.wrapText }\">\n      {{ getCellValue(dataItem, column) }}\n    </span>\n  </a>\n\n  <a\n    *ngIf=\"column.clickableWithHref && dataItem[column.field + '$LAUNCH_URL$']\"\n    [href]=\"dataItem[column.field + '$LAUNCH_URL$']\"\n    [target]=\"dataItem[column.field + '$TARGET$']\"\n  >\n    <span [ngClass]=\"{ 'rx-cell-wrap': column.wrapText }\">\n      {{ getCellValue(dataItem, column) }}\n    </span>\n  </a>\n</ng-template>\n\n<ng-template #cardLayoutFieldsHeaderTemplate let-column=\"column\">\n  <rx-card-layout-cell-header\n    [title]=\"column.header || column.fallbackTitle\"\n    [columns]=\"adaptTableConfig.columns\"\n    [adaptTable]=\"adaptTable\"\n    [openDialog]=\"openSortByDialog\"\n    (sort)=\"onSortCards($event)\"\n  ></rx-card-layout-cell-header>\n</ng-template>\n\n<ng-template #cardLayoutValuesHeaderTemplate let-column=\"column\">\n  <rx-card-layout-cell-header\n    [title]=\"column.header || column.fallbackTitle\"\n    [columns]=\"adaptTableConfig.columns\"\n    [adaptTable]=\"adaptTable\"\n    [openDialog]=\"openSortByDialog\"\n    (sort)=\"onSortCards($event)\"\n  ></rx-card-layout-cell-header>\n</ng-template>\n\n<ng-template #cardLayoutFieldsDataCellTemplate>\n  <div class=\"rx-card-layout-cell\" (click)=\"onCellClick($event)\">\n    <div\n      class=\"rx-card-layout-cell-item\"\n      *ngFor=\"let column of visibleColumns; trackBy: trackByColumnField\"\n      [attr.data-testid]=\"column.testId + '-name'\"\n    >\n      {{ column.header || column.fallbackTitle }}:\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #cardLayoutValuesDataCellTemplate let-dataItem=\"dataItem\">\n  <div class=\"rx-card-layout-cell-values rx-card-layout-cell\">\n    <div\n      *ngFor=\"let column of visibleColumns; trackBy: trackByColumnField\"\n      class=\"rx-card-layout-cell-item\"\n      [attr.data-testid]=\"column.testId + '-value'\"\n    >\n      <div *ngIf=\"column.isRowActionsColumn\">\n        <ng-container\n          [ngTemplateOutlet]=\"cardLayoutRowActionButtonsTemplate\"\n          [ngTemplateOutletContext]=\"{ dataItem: dataItem }\"\n        ></ng-container>\n      </div>\n      <div\n        *ngIf=\"\n          (!column.clickable ||\n            (column.clickableWithHref &&\n              !dataItem[column.field + '$ROUTER_LINK$'] &&\n              !dataItem[column.field + '$LAUNCH_URL$'])) &&\n          !column.isDownloadableAttachment &&\n          !column.isRowActionsColumn\n        \"\n      >\n        {{ getCellValue(dataItem, column) }}\n      </div>\n      <a\n        *ngIf=\"!column.clickable && column.isDownloadableAttachment\"\n        tabindex=\"0\"\n        class=\"attachment-link\"\n        (click)=\"downloadAttachment(dataItem, column, getCellValue(dataItem, column))\"\n        (keydown)=\"downloadAttachment(dataItem, column, getCellValue(dataItem, column), $event)\"\n      >\n        {{ getCellValue(dataItem, column) }}\n      </a>\n\n      <a\n        tabindex=\"0\"\n        *ngIf=\"column.clickable && !column.clickableWithHref\"\n        class=\"no-href-link\"\n        (click)=\"gridEvents.cellClick(dataItem, column.field)\"\n        (keydown)=\"gridEvents.cellKeyDown($event, dataItem, column.field)\"\n      >\n        {{ getCellValue(dataItem, column) }}\n      </a>\n\n      <a\n        *ngIf=\"column.clickableWithHref && dataItem[column.field + '$ROUTER_LINK$']\"\n        [routerLink]=\"'/' + dataItem[column.field + '$ROUTER_LINK$']\"\n        [queryParams]=\"dataItem[column.field + '$QUERY_PARAMS$']\"\n      >\n        {{ getCellValue(dataItem, column) }}\n      </a>\n\n      <a\n        *ngIf=\"column.clickableWithHref && dataItem[column.field + '$LAUNCH_URL$']\"\n        [href]=\"dataItem[column.field + '$LAUNCH_URL$']\"\n        [target]=\"dataItem[column.field + '$TARGET$']\"\n      >\n        {{ getCellValue(dataItem, column) }}\n      </a>\n    </div>\n  </div>\n\n  <button\n    *ngIf=\"isFilterBySelectionButtonVisible\"\n    adapt-button\n    rx-id=\"filter-by-selection-button\"\n    class=\"btn btn-link d-icon-filter_adapt filter-by-selection-icon\"\n    (click)=\"onFilterBySelection($event, visibleColumns, dataItem)\"\n  ></button>\n\n  <button\n    class=\"btn btn-link d-icon-pop_up record-details-icon\"\n    rx-id=\"show-record-details-button\"\n    [attr.aria-label]=\"\n      'com.bmc.arsys.rx.client.view-components.record-grid.cards.record-details.button.label' | translate\n    \"\n    (click)=\"openRowDetails(adaptTableConfig.columns, dataItem)\"\n  ></button>\n</ng-template>\n\n<ng-template #cardLayoutRowDetailsTemplate let-close=\"close\" let-getData=\"getData\">\n  <div class=\"modal-body rx-record-details\">\n    <div class=\"row mb-3\" *ngFor=\"let column of getData().columns\">\n      <div class=\"col-sm-4 font-weight-bold rx-text-break\">{{ column.header || column.fallbackTitle }}:</div>\n\n      <div class=\"col-sm-8 rx-text-break\" *ngIf=\"!column.isDownloadableAttachment && !column.isRowActionsColumn\">\n        {{ getCellValue(getData().rowDataItem, column) }}\n      </div>\n\n      <div class=\"col-sm-8\" *ngIf=\"column.isDownloadableAttachment\">\n        <a\n          tabindex=\"0\"\n          class=\"row-details-attachment-link\"\n          (click)=\"downloadAttachment(getData().rowDataItem, column, getCellValue(getData().rowDataItem, column))\"\n          (keydown)=\"\n            downloadAttachment(getData().rowDataItem, column, getCellValue(getData().rowDataItem, column), $event)\n          \"\n        >\n          {{ getCellValue(getData().rowDataItem, column) }}</a\n        >\n      </div>\n\n      <div class=\"col-sm-8\" *ngIf=\"column.isRowActionsColumn\">\n        <ng-container\n          [ngTemplateOutlet]=\"cardLayoutRowActionButtonsTemplate\"\n          [ngTemplateOutletContext]=\"{ dataItem: getData().rowDataItem }\"\n        ></ng-container>\n      </div>\n    </div>\n  </div>\n  <div class=\"modal-footer\">\n    <button type=\"button\" class=\"btn btn-secondary btn-sm\" (click)=\"close()\">\n      {{ 'com.bmc.arsys.rx.client.common.close.label' | translate }}\n    </button>\n  </div>\n</ng-template>\n\n<ng-template #filterButton>\n  <button\n    adapt-button\n    btn-type=\"tertiary\"\n    size=\"small\"\n    class=\"d-icon-filter_adapt p-0\"\n    (click)=\"applyFilterBySelection()\"\n  ></button>\n</ng-template>\n\n<ng-template #rowActionButtonsTemplate let-dataItem=\"dataItem\">\n  <div class=\"dropdown dropdown-kabob\" adaptDropdown appendToBody=\"true\" (onOpen)=\"onRowActionOpen(dataItem)\">\n    <button id=\"row-actions-dropdown-button\" class=\"dropdown-kabob-btn\" adaptDropdownToggle></button>\n    <div class=\"dropdown-menu\" aria-labelledby=\"row-actions-dropdown-button\" adaptDropdownMenu>\n      <rx-action-button\n        class=\"action-button-list\"\n        *ngFor=\"let rowActionButton of rowActionButtons\"\n        [guid]=\"rowActionButton.guid\"\n        [config]=\"rowActionButton.config\"\n        [runtimeViewModelApi]=\"rowActionButton.runtimeViewModelApi\"\n      ></rx-action-button>\n\n      <div class=\"empty-list-label pl-3\">\n        {{ 'com.bmc.arsys.rx.client.view-components.record-grid-row-actions.no-actions-available.label' | translate }}\n      </div>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #cardLayoutRowActionButtonsTemplate let-dataItem=\"dataItem\">\n  <div\n    class=\"dropdown mb-1\"\n    adaptDropdown\n    appendToBody=\"true\"\n    (click)=\"$event.stopPropagation()\"\n    (onOpen)=\"onRowActionOpen(dataItem)\"\n  >\n    <button id=\"card-layout-dropdown-button\" class=\"btn btn-secondary btn-xs\" size=\"xtra-small\" adaptDropdownToggle>\n      {{ 'com.bmc.arsys.rx.client.view-components.record-grid-row-actions.dropdown.label' | translate }}\n    </button>\n    <div class=\"dropdown-menu\" aria-labelledby=\"card-layout-dropdown-button\" adaptDropdownMenu>\n      <rx-action-button\n        class=\"row-actions-dropdown-item\"\n        *ngFor=\"let rowActionButton of rowActionButtons\"\n        [guid]=\"rowActionButton.guid\"\n        [config]=\"rowActionButton.config\"\n        [runtimeViewModelApi]=\"rowActionButton.runtimeViewModelApi\"\n      ></rx-action-button>\n    </div>\n  </div>\n</ng-template>\n\n<rx-advanced-filtering-fields-provider\n  [namedFilterOptionsGetter]=\"getNamedFilterOptions\"\n></rx-advanced-filtering-fields-provider>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{display:block;height:420px}:host ::ng-deep .rx-table-card-layout .adapt-selection-cell{vertical-align:middle!important}:host ::ng-deep .rx-table-card-layout .c-header-name{width:100%}:host ::ng-deep .rx-card-layout-data-cell{position:relative}:host ::ng-deep .rx-card-layout-cell-item{padding:0;line-height:32px;min-height:32px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}:host ::ng-deep .rx-card-layout-cell-values>div:first-child .rx-card-layout-cell-item{padding-right:20px}:host ::ng-deep .rx-card-layout-cell-icon,:host ::ng-deep .filter-by-selection-icon,:host ::ng-deep .record-details-icon{top:2px;padding:2px;position:absolute}:host ::ng-deep .record-details-icon{right:7px}:host ::ng-deep .filter-by-selection-icon{right:25px}:host ::ng-deep adapt-table td.at-data-cell{padding:0;-moz-user-select:text}:host ::ng-deep adapt-table td.rx-cell-selection-mode:focus{outline:none!important}:host ::ng-deep adapt-table adapt-table-toolbar rx-action-button{margin:5px}:host ::ng-deep adapt-table adapt-table-toolbar rx-action-button .btn-link{padding-right:0;padding-left:0}:host ::ng-deep adapt-table .at-wrap-cell-text .at-data-cell{word-break:break-word}:host ::ng-deep .rx-row-action-cell .dropdown{margin-top:3px}.rx-custom-cell{min-height:36px;padding:.5rem 13px}.rx-custom-cell .rx-cell-wrap{white-space:normal;text-overflow:clip;word-break:break-word}.rx-selected-custom-cell{outline:1px solid #00a79d!important;border-color:transparent!important;outline-offset:-1px}.rx-card-layout-cell{padding:3px 10px}:host ::ng-deep .dropdown-menu rx-action-button button.btn{width:100%;text-align:left;background:none;border:0;font-size:.8125rem}:host ::ng-deep .dropdown-menu rx-action-button button.btn:before{width:18px}:host ::ng-deep .dropdown-menu rx-action-button button.btn>span{margin-left:18px}:host ::ng-deep .dropdown-menu rx-action-button button.btn[class^=d-icon-left]>span{margin-left:0!important}.grid-toolbar-icon{font-size:16px}.no-href-link{cursor:pointer;text-decoration:none}.attachment-link,.row-details-attachment-link{cursor:pointer}::ng-deep .table-filtering.popover.popover-mobile{height:auto;display:block;top:auto!important;bottom:0;width:100vw}::ng-deep .table-filtering.popover.popover-mobile .a-popover-wrap{margin:0}::ng-deep .table-filtering.popover.popover-mobile .close{display:none}::ng-deep .visible-columns-dropdown{padding-top:0;width:14rem}.action-button-list:not(:empty)~.empty-list-label{display:none}.empty-list-label{color:#959899}.visible-columns-item{white-space:normal;word-break:break-word}\n"], components: [{ type: i1$7.AdaptTableComponent, selector: "adapt-table", inputs: ["sortable", "filterable", "triggerableFilters", "explicitSearchBtn", "enableReorderableRows", "suppressTooltip", "toolbarConfig", "dataColumnsColsTemplate", "dataColumnsHeaderTemplate", "dataColumnsDataCellsTemplate", "headerGroupsTemplate", "alwaysShowHeaderTooltip", "alwaysShowCellTooltip", "expandedCellClass", "expandedGroupsKeys", "nestedGroupPadding", "expandindCellInitialPadding", "groupValueDataCellTemplate", "tooltipInitialDelayMs", "tooltipClass", "rowsCustomClass", "paginatorAlign", "hasEmptyState", "enableInfiniteScrolling", "updateFirstColumnWidth", "busyConfig", "defaultFiltersMatchMode", "wrapCellText", "minBufferPx", "maxBufferPx", "testID", "headerSelectionMode", "disabledSelectedRowsCount", "disabledNotSelectedRowsCount", "disabledSelectedFilteredRowsCount", "disabledNotSelectedFilteredRowsCount", "selectedFilteredRowsCount", "totalRecordsInGroup", "disableRowSelection", "nestingStructureData", "nestingKey", "enableRowEditing", "autoScrollToTop", "paginationTexts", "toolbarTexts", "tableTexts", "filtersTexts", "headerCellMenuTexts", "texts", "loadingMore", "mergeColumns", "disabledRowSelectionResolver", "allowColumnReorderingResolver", "disableRowExpandingResolver", "rowAriaDataResolver", "tableWidthConfig", "expandedRowTemplate", "isRefreshingRowData", "value", "bordered", "paginator", "striped", "loading"], outputs: ["onLazyLoad", "rowDataRefresh", "savedRowEditing", "canceledRowEditing", "groupSelection", "allGroupedRowsSelection", "groupExpansion", "columnsVisibilityChange", "rowDragStart", "rowDragRelease", "rowDragEnd", "rowDragDrop", "export", "toolbarPopupAnimationDone"] }, { type: i1.AdaptRxSearchComponent, selector: "adapt-rx-search", inputs: ["mode", "autocomplete", "placeholder", "size", "searchButton", "searchButtonText", "clearButtonText", "debounceTime", "ariaControlsPopupId", "ariaActiveDescendant", "initialAlign"], outputs: ["editModeChange"] }, { type: i1.AdaptRxCheckboxComponent, selector: "adapt-rx-checkbox", inputs: ["value", "checked", "indeterminate"], outputs: ["indeterminateChange"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }, { type: i1.AdaptSubnavComponent, selector: "adapt-subnav, [adaptSubnav]", inputs: ["adaptSubnav", "gutter", "defaultCssClass"], outputs: ["visibilityChanged"] }, { type: i1.AdaptSubnavItemComponent, selector: "adapt-subnav-item, [adaptSubnavItem]", inputs: ["adaptSubnavItem", "defaultCssClass", "preventHiding", "priority"] }, { type: ActionButtonComponent, selector: "rx-action-button", inputs: ["guid", "config", "runtimeViewModelApi"] }, { type: i1.AdaptSubnavDropdownComponent, selector: "adapt-subnav-dropdown, [adaptSubnavDropdown]", inputs: ["adaptSubnavDropdown", "defaultCssClass", "autoClose"] }, { type: i1.AdaptAdvancedFilterComponent, selector: "adapt-advanced-filter", inputs: ["filterOptions", "savedFilters", "enableDefaultSavedFilter", "defaultSavedFilterId", "busyConfig", "activeSavedFilter", "disableExpressionEditing", "showAnchorButtonLabel", "getCustomExpressionTagFieldModel", "enableSavedFilters", "applyFiltersByUserAction", "canCloseDropdownResolver", "showTabToolbar", "disabledTabResolver", "disabledInputResolver", "showSelectedFiltersCount", "selectedFiltersIndicationStyle", "filterOptionsCustomAreaTemplate", "showTags", "anchorDisabled", "fullWidthEdit", "translateFilterEditingTitleXPixels", "selectedFilters", "isLoading"], outputs: ["selectedFiltersChange", "filterSelectionChange", "deleteSavedFilter", "createNewFilter", "updateSavedFilter", "beforeActiveSavedFilterChange", "activeSavedFilterChange", "removeTag", "filtersCleared", "saveNewFilterClick", "filtersSelectionCanceled", "editSavedFilterClick", "markDefaultSavedFilterClick", "editingSavedFilterCanceled", "filterExpressionTagsChanged"] }, { type: FilterTagsComponent, selector: "rx-filter-tags", inputs: ["tags", "isDisabled", "tagsLimit", "restTagsDropdownPlacement"], outputs: ["removeTag"] }, { type: CardLayoutCellHeaderComponent, selector: "rx-card-layout-cell-header", inputs: ["title", "columns", "adaptTable", "openDialog"], outputs: ["sort"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptDropdownDirective, selector: "adapt-dropdown, [adaptDropdown]", inputs: ["autoClose", "customClass", "closeOnEscape", "placement", "animationPlacement", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "focusNextElementAfterClose", "appendToBody", "appendTo", "positionTo", "anchorPositionTrackingIntervalMs", "enableAnchorPositionTracking", "recalculatePositionOnElementResize", "setMobileState", "mobileView"], outputs: ["onOpen", "onClose", "anchorPositionChange", "popupAnimationDone"], exportAs: ["adaptDropdown"] }, { type: RxAdvancedFilteringFieldsProviderComponent, selector: "rx-advanced-filtering-fields-provider", inputs: ["namedFilterOptionsGetter"] }], directives: [{ type: GridCardLayoutDirective, selector: "[rxCardLayout]", inputs: ["cardLayoutFieldsHeaderTemplate", "cardLayoutValuesHeaderTemplate", "cardLayoutFieldsDataCellTemplate", "cardLayoutValuesDataCellTemplate", "cardLayoutGetDataCellClass", "cardLayoutRecordGridElementRef", "cardLayoutWidth"], outputs: ["changedCardLayout"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: CellDisplayPropertiesDirective, selector: "[rxCellDisplayProps]", inputs: ["rxCellDisplayProps", "rxCellDisplayPropsBadgeElem", "rxCellDisplayPropsDataItem"] }, { type: i1.AdaptPopoverDirective, selector: "[adaptPopover]", inputs: ["adaptPopover", "popoverTitle", "placement", "fallbackPlacement", "triggers", "container", "appendToBody", "closeBtn", "popupDelay", "disablePopover", "popoverClass", "autoClose", "closeOnOutOfView", "maxWidth", "minWidth"], outputs: ["shown", "hidden"], exportAs: ["adaptPopover"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i28.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i1.AdaptDropdownToggleDirective, selector: "[adaptDropdownToggle]", inputs: ["showCaret", "dropdownTogglerType"] }, { type: i1.AdaptDropdownMenuDirective, selector: "[adaptDropdownMenu]" }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-record-grid',
                    templateUrl: './record-grid.component.html',
                    styleUrls: ['record-grid.component.scss'],
                    providers: [RxRecordGridUserPreferencesService]
                }]
        }], ctorParameters: function () { return [{ type: i1.AdaptDeviceDetectionService }, { type: i1.AdaptModalService }, { type: i0.ChangeDetectorRef }, { type: i3.DatePipe }, { type: i3.DecimalPipe }, { type: i0.NgZone }, { type: i2$4.RxAssociationInstanceDataPageService }, { type: i1$1.RxBooleanPipe }, { type: i1$1.RxCurrentUserService }, { type: i1$4.RxExpressionEvaluatorService }, { type: i1$5.RxFieldDefinitionService }, { type: RxRecordGridConfiguratorService }, { type: i2$1.RxGuidService }, { type: i1$1.RxLogService }, { type: i1$1.RxNotificationService }, { type: i2$1.RxObjectUtilsService }, { type: i1$5.RxRecordDefinitionCacheService }, { type: i1$5.RxRecordDefinitionService }, { type: RxRecordGridAdvancedFilteringService }, { type: RxRecordGridConfigUtilsService }, { type: RxRecordGridFilterConfigService }, { type: RxRecordGridFilterService }, { type: RxRecordGridFilterHelperService }, { type: RxRecordGridSharedFilterPresetsCacheService }, { type: RxRecordGridUserPreferencesService }, { type: RxRecordGridUtilsService }, { type: i1$5.RxRecordInstanceDataPageService }, { type: i1$5.RxRecordInstanceService }, { type: i1$4.RxViewActionService }, { type: i1$4.RxViewActionUtilsService }, { type: i2.TranslateService }, { type: i0.ElementRef }, { type: i2$1.RxStringService }, { type: i1$1.RxGlobalEventsService }, { type: PageComponent, decorators: [{
                    type: Optional
                }] }, { type: i1$2.RuntimeViewCanvasItemComponent, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { config: [{
                type: Input
            }], dataLoaded: [{
                type: Output
            }], adaptTable: [{
                type: ViewChild,
                args: ['adaptTable', { static: true }]
            }], adaptAdvancedFilter: [{
                type: ViewChild,
                args: ['adaptAdvancedFilter']
            }], cardLayoutRowDetailsTemplate: [{
                type: ViewChild,
                args: ['cardLayoutRowDetailsTemplate', { static: true }]
            }], cellTemplate: [{
                type: ViewChild,
                args: ['cellTemplate', { static: true }]
            }], filterTemplate: [{
                type: ViewChild,
                args: ['filterTemplate', { static: true }]
            }], leftCustomSectionTemplate: [{
                type: ViewChild,
                args: ['leftCustomSectionTemplate', { static: true }]
            }], rightCustomSectionTemplate: [{
                type: ViewChild,
                args: ['rightCustomSectionTemplate', { static: true }]
            }], rowActionButtonsTemplate: [{
                type: ViewChild,
                args: ['rowActionButtonsTemplate', { static: true }]
            }], visibleColumnsMenuTemplate: [{
                type: ViewChild,
                args: ['visibleColumnsMenuTemplate', { static: true }]
            }], fieldsProvider: [{
                type: ViewChild,
                args: [RxAdvancedFilteringFieldsProviderComponent, { static: true }]
            }], actionButtonComponents: [{
                type: ViewChildren,
                args: [ActionButtonComponent]
            }], onClickOutside: [{
                type: HostListener,
                args: ['document:click', ['$event']]
            }] } });

class RxRecordGridDefinitionAdapterService {
    constructor(viewDefinitionParserService, rxJsonParserService, rxRecordGridConfigUtilsService) {
        this.viewDefinitionParserService = viewDefinitionParserService;
        this.rxJsonParserService = rxJsonParserService;
        this.rxRecordGridConfigUtilsService = rxRecordGridConfigUtilsService;
    }
    adaptDefinition(recordGridContainerViewComponentDefinition, viewDefinition) {
        const cellDisplayPropertiesList = recordGridContainerViewComponentDefinition.componentDefinitions
            .filter(({ type }) => type === RX_RECORD_GRID.components.column)
            .map(({ propertiesByName }) => propertiesByName.cellDisplayProperties)
            .filter(Boolean);
        this.viewDefinitionParserService
            .getComponents(recordGridContainerViewComponentDefinition)
            .map((componentDefinition) => componentDefinition.componentDefinition)
            .forEach((componentDefinition) => {
            var _a, _b, _c, _d;
            switch (componentDefinition.type) {
                case RX_RECORD_GRID.type: {
                    componentDefinition.propertiesByName.enableFilterPresets =
                        (_a = componentDefinition.propertiesByName.enableFilterPresets) !== null && _a !== void 0 ? _a : 'true';
                    componentDefinition.propertiesByName.requiredFilters =
                        (_b = componentDefinition.propertiesByName.requiredFilters) !== null && _b !== void 0 ? _b : (componentDefinition.propertiesByName['requireFiltering'] === 'true' ? 1 : 0);
                    const layout = this.rxJsonParserService.tryParseJson(componentDefinition.layout);
                    const actionButtons = filter$1(componentDefinition.componentDefinitions, {
                        type: RxViewComponentType.ActionButton
                    });
                    const rowActionButtons = this.getActionButtonsForOutlet(layout, RX_RECORD_GRID.rowActionsOutletName, actionButtons);
                    rowActionButtons.forEach((action) => {
                        action.propertiesByName = Object.assign(Object.assign({}, action.propertiesByName), { cls: 'dropdown-item', styles: 'p-0' });
                    });
                    without(actionButtons, ...rowActionButtons).forEach((actionButton) => {
                        if ([ActionButtonStyle.Primary, ActionButtonStyle.Secondary].includes(actionButton.propertiesByName.style)) {
                            actionButton.propertiesByName.size = ActionButtonSize.Small;
                        }
                    });
                    break;
                }
                case RX_RECORD_GRID.components.column: {
                    let isReferenced = null;
                    if (!this.rxRecordGridConfigUtilsService.getBooleanValue(recordGridContainerViewComponentDefinition.propertiesByName.getDataForHiddenColumns)) {
                        const recordGridGuid = recordGridContainerViewComponentDefinition.guid;
                        const columnFieldId = componentDefinition.propertiesByName.fieldId;
                        const isReferencedInExpression = viewDefinition.viewComponentExpressions.some((expression) => expression.includes(`\$\{view.components.${recordGridGuid}.firstSelectedRow.${columnFieldId}`) ||
                            expression.includes(`\$\{view.components.${recordGridGuid}.clickableRow.${columnFieldId}`));
                        const isReferencedInCellDisplayProperties = cellDisplayPropertiesList.some((cellDisplayProperties) => cellDisplayProperties.includes(`\$\{view.components.grid.clickableRow.${columnFieldId}`));
                        isReferenced = isReferencedInExpression || isReferencedInCellDisplayProperties;
                    }
                    const adaptedProperties = {
                        actions: [],
                        clickable: false,
                        guid: componentDefinition.guid,
                        wrapText: (_c = componentDefinition.propertiesByName.wrapText) !== null && _c !== void 0 ? _c : false,
                        referenced: isReferenced,
                        typeaheadKeystrokeCount: (_d = componentDefinition.propertiesByName.typeaheadKeystrokeCount) !== null && _d !== void 0 ? _d : RX_RECORD_GRID.defaultTypeaheadKeystrokeCount
                    };
                    const actions = filter$1(componentDefinition.componentDefinitions, {
                        type: 'rx-action'
                    }).map((action) => action.propertiesByName);
                    if (actions.length) {
                        adaptedProperties.clickable = true;
                        adaptedProperties.actions = actions;
                    }
                    Object.assign(componentDefinition.propertiesByName, adaptedProperties);
                    break;
                }
                case RX_RECORD_GRID.components.filterPreset:
                case RX_RECORD_GRID.components.filter: {
                    Object.assign(componentDefinition.propertiesByName, {
                        guid: componentDefinition.guid
                    });
                    break;
                }
            }
        });
    }
    getActionButtonsForOutlet(layout, outletName, actionButtons) {
        const actionButtonsGuids = chain(layout.outlets)
            .filter({
            name: outletName
        })
            .head()
            .get('columns[0].children', [])
            .value();
        return filter$1(actionButtons, (actionButton) => actionButtonsGuids.includes(actionButton.guid));
    }
}
RxRecordGridDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDefinitionAdapterService, deps: [{ token: i1$4.RxViewDefinitionParserService }, { token: i2$1.RxJsonParserService }, { token: RxRecordGridConfigUtilsService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridDefinitionAdapterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$4.RxViewDefinitionParserService }, { type: i2$1.RxJsonParserService }, { type: RxRecordGridConfigUtilsService }]; } });

// @deprecated
class RxRecordGridQueryExpressionEvaluatorService extends RxRecordQueryExpressionEvaluatorService {
}
RxRecordGridQueryExpressionEvaluatorService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridQueryExpressionEvaluatorService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
RxRecordGridQueryExpressionEvaluatorService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridQueryExpressionEvaluatorService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRecordGridQueryExpressionEvaluatorService, decorators: [{
            type: Injectable
        }] });

class RecordGridModule {
    constructor(rxRecordGridDefinitionAdapterService, rxDefinitionAdapterRegistryService) {
        this.rxRecordGridDefinitionAdapterService = rxRecordGridDefinitionAdapterService;
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RX_RECORD_GRID.type, this.rxRecordGridDefinitionAdapterService);
    }
}
RecordGridModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridModule, deps: [{ token: RxRecordGridDefinitionAdapterService }, { token: i1$1.RxDefinitionAdapterRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridModule, declarations: [RecordGridComponent,
        GridCardLayoutDirective,
        CardLayoutCellHeaderComponent,
        RxFilterByCardSelectionDialogComponent,
        CellDisplayPropertiesDirective], imports: [RxDefinitionModule,
        CommonModule,
        RuntimeViewCanvasModule, i1$7.AdaptTableModule, AdaptSelectModule,
        FormsModule,
        AdaptRxCheckboxModule,
        AdaptRxSelectModule, i1.AdaptAlertModule, i1.AdaptPopoverModule, AdaptAccordionModule,
        AdaptButtonModule,
        AdaptDropdownModule,
        TranslateModule,
        ActionButtonModule,
        AdaptSubnavModule,
        AdaptAdvancedFilteringModule,
        RecordGridCommonModule,
        RouterModule,
        RxAdvancedFilteringFieldsProviderModule,
        AdaptRxSearchModule,
        AdaptEmptyStateModule], exports: [RecordGridComponent] });
RecordGridModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridModule, providers: [
        DatePipe,
        DecimalPipe,
        RxBooleanPipe,
        RxRecordGridConfiguratorService,
        RxRecordGridConfigUtilsService,
        RxRecordGridDefinitionAdapterService,
        RxRecordGridFilterService,
        RxRecordGridUtilsService,
        RxRecordGridFilterConfigService,
        RxRecordGridQueryExpressionEvaluatorService,
        RxRecordGridSharedFilterPresetsCacheService,
        RxRecordGridAdvancedFilteringService
    ], imports: [[
            RxDefinitionModule,
            CommonModule,
            RuntimeViewCanvasModule,
            AdaptTableModule.forRoot(),
            AdaptSelectModule,
            FormsModule,
            AdaptRxCheckboxModule,
            AdaptRxSelectModule,
            AdaptAlertModule.forRoot(),
            AdaptPopoverModule.forRoot(),
            AdaptAccordionModule,
            AdaptButtonModule,
            AdaptDropdownModule,
            TranslateModule,
            ActionButtonModule,
            AdaptSubnavModule,
            AdaptAdvancedFilteringModule,
            RecordGridCommonModule,
            RouterModule,
            RxAdvancedFilteringFieldsProviderModule,
            AdaptRxSearchModule,
            AdaptEmptyStateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        RxDefinitionModule,
                        CommonModule,
                        RuntimeViewCanvasModule,
                        AdaptTableModule.forRoot(),
                        AdaptSelectModule,
                        FormsModule,
                        AdaptRxCheckboxModule,
                        AdaptRxSelectModule,
                        AdaptAlertModule.forRoot(),
                        AdaptPopoverModule.forRoot(),
                        AdaptAccordionModule,
                        AdaptButtonModule,
                        AdaptDropdownModule,
                        TranslateModule,
                        ActionButtonModule,
                        AdaptSubnavModule,
                        AdaptAdvancedFilteringModule,
                        RecordGridCommonModule,
                        RouterModule,
                        RxAdvancedFilteringFieldsProviderModule,
                        AdaptRxSearchModule,
                        AdaptEmptyStateModule
                    ],
                    providers: [
                        DatePipe,
                        DecimalPipe,
                        RxBooleanPipe,
                        RxRecordGridConfiguratorService,
                        RxRecordGridConfigUtilsService,
                        RxRecordGridDefinitionAdapterService,
                        RxRecordGridFilterService,
                        RxRecordGridUtilsService,
                        RxRecordGridFilterConfigService,
                        RxRecordGridQueryExpressionEvaluatorService,
                        RxRecordGridSharedFilterPresetsCacheService,
                        RxRecordGridAdvancedFilteringService
                    ],
                    exports: [RecordGridComponent],
                    declarations: [
                        RecordGridComponent,
                        GridCardLayoutDirective,
                        CardLayoutCellHeaderComponent,
                        RxFilterByCardSelectionDialogComponent,
                        CellDisplayPropertiesDirective
                    ],
                    entryComponents: [RecordGridComponent]
                }]
        }], ctorParameters: function () { return [{ type: RxRecordGridDefinitionAdapterService }, { type: i1$1.RxDefinitionAdapterRegistryService }]; } });

class RichTextComponent extends BaseViewComponent {
    constructor(sanitizer, rxCkEditorConfiguratorService) {
        super();
        this.sanitizer = sanitizer;
        this.rxCkEditorConfiguratorService = rxCkEditorConfiguratorService;
        this.filter = new CKEDITOR.filter('');
        this.api = {
            setProperty: this.setProperty.bind(this)
        };
        this.filter.allow(this.rxCkEditorConfiguratorService.getContentRules());
    }
    ngOnInit() {
        super.ngOnInit();
        this.notifyPropertyChanged('api', this.api);
        this.config.pipe(takeUntil(this.destroyed$)).subscribe((config) => {
            this.isHidden = Boolean(config.hidden);
            this.html = this.updateHtml(config.html);
        });
    }
    updateHtml(value) {
        if (value) {
            value = value.replace(/\n/g, '<br>');
            const fragment = CKEDITOR.htmlParser.fragment.fromHtml(value);
            const writer = new CKEDITOR.htmlParser.basicWriter();
            this.filter.applyTo(fragment);
            fragment.writeHtml(writer);
            value = writer.getHtml(true);
        }
        else {
            value = '';
        }
        return this.sanitizer.bypassSecurityTrustHtml(value);
    }
    setProperty(propertyPath, value) {
        if (propertyPath === 'hidden') {
            this.isHidden = value;
            this.notifyPropertyChanged(propertyPath, this.isHidden);
        }
        else {
            return throwError(`Rich text: property ${propertyPath} is not settable.`);
        }
    }
}
RichTextComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextComponent, deps: [{ token: i1$8.DomSanitizer }, { token: i1$4.RxCkEditorConfiguratorService }], target: i0.ɵɵFactoryTarget.Component });
RichTextComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RichTextComponent, selector: "rx-rich-text", inputs: { config: "config" }, usesInheritance: true, ngImport: i0, template: `
    <div
      class="text-container focusable"
      [hidden]="isHidden"
      tabindex="0"
      [innerHTML]="html"
      [attr.aria-hidden]="isHidden"
    ></div>
  `, isInline: true, styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.text-container{white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-rich-text',
                    template: `
    <div
      class="text-container focusable"
      [hidden]="isHidden"
      tabindex="0"
      [innerHTML]="html"
      [attr.aria-hidden]="isHidden"
    ></div>
  `,
                    styleUrls: ['./rich-text.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1$8.DomSanitizer }, { type: i1$4.RxCkEditorConfiguratorService }]; }, propDecorators: { config: [{
                type: Input
            }] } });

class RxRichTextExpressionEvaluatorService {
    constructor(rxDefaultExpressionEvaluatorService) {
        this.rxDefaultExpressionEvaluatorService = rxDefaultExpressionEvaluatorService;
    }
    evaluate(expression, data) {
        const tempElement = document.createElement('div');
        tempElement.innerHTML = expression;
        tempElement.querySelectorAll(`span[${RX_RICH_TEXT.expressionAttributeName}]`).forEach((span) => {
            const evaluatedExpression = this.rxDefaultExpressionEvaluatorService.evaluate(span.getAttribute(RX_RICH_TEXT.expressionAttributeName), data);
            const textNode = document.createTextNode(isNil(evaluatedExpression) ? '' : evaluatedExpression);
            span.parentElement.replaceChild(textNode, span);
        });
        return tempElement.innerHTML;
    }
}
RxRichTextExpressionEvaluatorService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRichTextExpressionEvaluatorService, deps: [{ token: i1$4.RxDefaultExpressionEvaluatorService }], target: i0.ɵɵFactoryTarget.Injectable });
RxRichTextExpressionEvaluatorService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRichTextExpressionEvaluatorService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxRichTextExpressionEvaluatorService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$4.RxDefaultExpressionEvaluatorService }]; } });

class RichTextDefinitionAdapterService {
    constructor(rxCkEditorConfiguratorService) {
        this.rxCkEditorConfiguratorService = rxCkEditorConfiguratorService;
        this.filter = new CKEDITOR.filter('');
        this.filter.allow(this.rxCkEditorConfiguratorService.getContentRules());
    }
    adaptDefinition(definition) {
        if (definition.propertiesByName.html) {
            const initialValue = CKEDITOR.dtd.$removeEmpty['span'];
            // Allow empty span tags, used for holding the expressions in rx-expression attributes,
            // to be parsed by CKEDITOR.htmlParser.fragment.fromHtml
            // https://stackoverflow.com/questions/18250404/ckeditor-strips-i-tag
            // @ts-ignore
            CKEDITOR.dtd.$removeEmpty['span'] = 0;
            const fragment = CKEDITOR.htmlParser.fragment.fromHtml(definition.propertiesByName.html);
            const writer = new CKEDITOR.htmlParser.basicWriter();
            // sanitize HTML
            this.filter.applyTo(fragment);
            fragment.writeHtml(writer);
            definition.propertiesByName.html = writer.getHtml(true);
            CKEDITOR.dtd.$removeEmpty['span'] = initialValue;
        }
    }
}
RichTextDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDefinitionAdapterService, deps: [{ token: i1$4.RxCkEditorConfiguratorService }], target: i0.ɵɵFactoryTarget.Injectable });
RichTextDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDefinitionAdapterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$4.RxCkEditorConfiguratorService }]; } });

class RichTextModule {
    constructor(rxDefinitionAdapterRegistryService, richTextDefinitionAdapterService) {
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.richTextDefinitionAdapterService = richTextDefinitionAdapterService;
        rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.RichText, this.richTextDefinitionAdapterService);
    }
}
RichTextModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: RichTextDefinitionAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
RichTextModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextModule, declarations: [RichTextComponent], imports: [CommonModule, CKEditorModule], exports: [RichTextComponent] });
RichTextModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextModule, providers: [RxRichTextExpressionEvaluatorService], imports: [[CommonModule, CKEditorModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RichTextComponent],
                    imports: [CommonModule, CKEditorModule],
                    exports: [RichTextComponent],
                    entryComponents: [RichTextComponent],
                    providers: [RxRichTextExpressionEvaluatorService]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: RichTextDefinitionAdapterService }]; } });

const RX_CKEDITOR_CONFIG = {
    title: false,
    skin: 'rich-text,skins/rich-text/',
    toolbar: [
        [
            'Bold',
            'Italic',
            'Strike',
            'Underline',
            '-',
            'Link',
            'Unlink',
            '-',
            'NumberedList',
            'BulletedList',
            'Outdent',
            'Indent',
            '-',
            'JustifyLeft',
            'JustifyCenter',
            'JustifyRight',
            '-',
            'ExpressionEditor'
        ],
        '/',
        ['Format', 'Styles', 'Font', 'FontSize', 'TextColor']
    ],
    stylesSet: [
        {
            name: 'Italic Title',
            element: 'h2',
            attributes: {
                class: 'italic-title'
            }
        },
        {
            name: 'Subtitle',
            element: 'h3',
            attributes: {
                class: 'subtitle'
            }
        },
        {
            name: 'Special Container',
            element: 'div',
            attributes: {
                class: 'special-containers'
            }
        },
        {
            name: 'Marker',
            element: 'span',
            attributes: {
                class: 'marker'
            }
        },
        {
            name: 'Small',
            element: 'small'
        },
        {
            name: 'Computer Code',
            element: 'code'
        },
        {
            name: 'Keyboard Phrase',
            element: 'kbd'
        },
        {
            name: 'Sample Text',
            element: 'samp'
        },
        {
            name: 'Variable',
            element: 'var'
        },
        {
            name: 'Deleted Text',
            element: 'del'
        },
        {
            name: 'Inserted Text',
            element: 'ins'
        },
        {
            name: 'Cited Work',
            element: 'cite'
        },
        {
            name: 'Inline Quotation',
            element: 'q'
        },
        {
            name: 'Compact Table',
            element: 'table',
            attributes: {
                cellpadding: '5',
                cellspacing: '0',
                class: 'compact-table'
            }
        },
        {
            name: 'Borderless Table',
            element: 'table',
            attributes: {
                class: 'borderless-table'
            }
        },
        {
            name: 'Square Bulleted List',
            element: 'ul',
            attributes: {
                class: 'square-bulleted-list'
            }
        }
    ],
    format_tags: 'p;h1;h2;h3;pre',
    extraPlugins: 'expression-editor, colordialog',
    extraAllowedContent: 'span [rx-expression, contenteditable, title] (rx-expression)'
};

class RichTextDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.html$ = this.sandbox.getComponentPropertyValue('html');
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({ name: null, html: null }, RX_STANDARD_PROPS_DEFAULT_VALUES), initialProperties);
    }
    rxInit() {
        this.sandbox.componentProperties$.pipe(take(1)).subscribe(() => {
            this.sandbox.updateInspectorConfig(this.getInspector());
        });
        this.sandbox.componentProperties$.subscribe((properties) => {
            const validationIssues = properties.html ? [] : [this.sandbox.createError('Rich text value cannot be blank.')];
            validationIssues.push(...validateStandardProps(properties));
            this.sandbox.setValidationIssues(validationIssues);
        });
        this.sandbox.getComponentPropertyValue('name').subscribe((name) => {
            const componentName = name ? `${this.sandbox.descriptor.name} (${name})` : this.sandbox.descriptor.name;
            this.sandbox.setSettablePropertiesDataDictionary(componentName, [
                {
                    label: 'Hidden',
                    expression: this.getExpressionForProperty('hidden')
                }
            ]);
        });
    }
    getInspector() {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'name',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Name',
                                tooltip: new Tooltip('Enter a name to uniquely identify the Rich text component')
                            }
                        },
                        ...getStandardPropsInspectorConfigs()
                    ]
                }
            ]
        };
    }
    updateComponentProperties(props) {
        this.sandbox.updateComponentProperties(props);
    }
}

class RichTextDesignComponent {
    constructor(rxExpressionEditorService, rxTreeService, rxExpressionParserService, renderer2, document, ngZone) {
        this.rxExpressionEditorService = rxExpressionEditorService;
        this.rxTreeService = rxTreeService;
        this.rxExpressionParserService = rxExpressionParserService;
        this.renderer2 = renderer2;
        this.document = document;
        this.ngZone = ngZone;
        this.type = "inline" /* INLINE */;
        this.ckConfig = RX_CKEDITOR_CONFIG;
        this.formControl = new FormControl(null);
        this.destroyed$ = new ReplaySubject(1);
        // remove inner span with expression title and content value, e.g.:
        // "<p>text<span contenteditable="false" rx-expression="${foo}"><span title="Foo">Foo</span></span></p>" ->
        // "<p>text<span contenteditable="false" rx-expression="${foo}"></span></p>"
        this.removeExpressionLabels = this.setExpressionLabelHtml.bind(this, null);
        // set inner span with expression title and content value, e.g.:
        // "<p>text<span contenteditable="false" rx-expression="${foo}"></span></p>" ->
        // "<p>text<span contenteditable="false" rx-expression="${foo}"><span title="Foo">Foo</span></span></p>"
        this.addExpressionLabels = this.setExpressionLabelHtml.bind(this, this.getExpressionWithLabels.bind(this));
    }
    ngOnInit() {
        const dataDictionary$ = this.model.expressionConfigurator.getDataDictionary();
        dataDictionary$
            .pipe(withLatestFrom(this.model.html$), takeUntil(this.destroyed$))
            .subscribe(([dataDictionary, html]) => {
            this.flatDataDictionary = this.rxTreeService.flatten({
                children: dataDictionary
            });
            this.formControl.setValue(this.addExpressionLabels(html));
        });
        this.formControl.valueChanges
            .pipe(map((value) => this.removeExpressionLabels(value)), distinctUntilChanged(), skip(1), takeUntil(this.destroyed$))
            .subscribe((html) => {
            this.model.updateComponentProperties({ html });
        });
        // set initial value
        this.model.html$.pipe(take(1), takeUntil(this.destroyed$)).subscribe((html) => {
            this.formControl.setValue(this.addExpressionLabels(html));
        });
    }
    onEditorReady(event) {
        if (this.isReadOnly) {
            this.ckConfig.toolbar = [];
            this.document.getElementById(`${event.editor.id}_top`).style.display = 'none';
        }
        this.ckEditor.instance.on('openExpressionEditor', (evt) => {
            const initialValue = evt.data && evt.data.getAttribute(RX_RICH_TEXT.expressionAttributeName);
            this.ngZone.runTask(() => this.rxExpressionEditorService
                .openEditor({
                property: {
                    path: 'html',
                    value: initialValue,
                    label: 'Rich Text'
                },
                expressionConfigurator: this.model.expressionConfigurator
            })
                .pipe(takeUntil(this.destroyed$))
                .subscribe({
                next: ({ path, value }) => {
                    if (value) {
                        const labelHtmlString = this.getExpressionWithLabels(value);
                        if (initialValue) {
                            evt.data.setAttribute(RX_RICH_TEXT.expressionAttributeName, value);
                            evt.data.setHtml(labelHtmlString);
                            // trigger change event in CKEDITOR, ref: https://stackoverflow.com/a/24599219/4449154
                            this.ckEditor.instance.fire('saveSnapshot');
                        }
                        else {
                            this.ckEditor.instance.insertHtml(`<span contenteditable="false" ${RX_RICH_TEXT.expressionAttributeName}="${escape(value)}">${labelHtmlString}</span>`);
                        }
                    }
                    else {
                        evt.data.remove();
                        // trigger change event in CKEDITOR, ref: https://stackoverflow.com/a/24599219/4449154
                        this.ckEditor.instance.fire('saveSnapshot');
                    }
                    this.moveCursorToEnd();
                },
                error: () => {
                    this.moveCursorToEnd();
                }
            }));
        });
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
    getExpressionWithLabels(expressionValue) {
        return this.rxExpressionParserService.parse(expressionValue, (token, expression) => {
            if (token !== ExpressionParserToken.RxStringExpression) {
                const node = this.flatDataDictionary.find((item) => item.expression === expression);
                const label = node && node.label ? escape(node.label) : expression;
                return `<span title="${label}">${label}</span>`;
            }
            return expression;
        });
    }
    moveCursorToEnd() {
        const range = this.ckEditor.instance.createRange();
        range.moveToElementEditEnd(range.root);
        this.ckEditor.instance.getSelection().selectRanges([range]);
    }
    setExpressionLabelHtml(predicate, htmlString) {
        const tempElement = this.renderer2.createElement('div');
        tempElement.innerHTML = htmlString;
        tempElement
            .querySelectorAll(`span[${RX_RICH_TEXT.expressionAttributeName}]`)
            .forEach((el) => (el.innerHTML = predicate ? predicate(el.getAttribute(RX_RICH_TEXT.expressionAttributeName)) : null));
        return tempElement.innerHTML.replace(/<br>/g, '<br />');
    }
}
RichTextDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDesignComponent, deps: [{ token: i2$5.RxExpressionEditorService }, { token: i2$1.RxTreeService }, { token: i1$1.RxExpressionParserService }, { token: i0.Renderer2 }, { token: DOCUMENT }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
RichTextDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RichTextDesignComponent, selector: "rx-rich-text-design", inputs: { model: "model", isReadOnly: "isReadOnly" }, viewQueries: [{ propertyName: "ckEditor", first: true, predicate: CKEditorComponent, descendants: true, static: true }], ngImport: i0, template: "<ckeditor\n  class=\"border\"\n  [class.border-transparent]=\"formControl.value\"\n  [formControl]=\"formControl\"\n  [config]=\"ckConfig\"\n  [type]=\"type\"\n  (ready)=\"onEditorReady($event)\"\n  [readOnly]=\"isReadOnly\"\n></ckeditor>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{display:block}ckeditor{min-height:42px;display:block;border:1px solid #d6d7d8}ckeditor.border-transparent{border-color:transparent!important}ckeditor ::ng-deep [rx-expression]{padding:2px 5px;display:inline-block;color:#7c7f81;background-color:#f0f1f1;border-radius:2px;-webkit-user-select:all;user-select:all}ckeditor ::ng-deep [rx-expression] span{padding:2px 5px;background-color:#d6d7d8;border-radius:2px}ckeditor ::ng-deep .cke_editable{padding:5px;outline:none}\n"], components: [{ type: i2$7.CKEditorComponent, selector: "ckeditor", inputs: ["tagName", "type", "editorUrl", "data", "readOnly", "config"], outputs: ["ready", "dataReady", "change", "dataChange", "dragStart", "dragEnd", "drop", "fileUploadResponse", "fileUploadRequest", "focus", "paste", "afterPaste", "blur"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-rich-text-design',
                    templateUrl: './rich-text-design.component.html',
                    styleUrls: ['./rich-text-design.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i2$5.RxExpressionEditorService }, { type: i2$1.RxTreeService }, { type: i1$1.RxExpressionParserService }, { type: i0.Renderer2 }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.NgZone }]; }, propDecorators: { model: [{
                type: Input
            }], isReadOnly: [{
                type: Input
            }], ckEditor: [{
                type: ViewChild,
                args: [CKEditorComponent, { static: true }]
            }] } });

class RxExpressionEditorPluginService {
    constructor() {
        const me = this;
        CKEDITOR.plugins.add('expression-editor', {
            init(editor) {
                editor.addCommand('insertExpression', {
                    exec() {
                        editor.fire('openExpressionEditor', null);
                        return true;
                    }
                });
                editor.on('doubleclick', (evt) => {
                    const element = me.getSelectedExpressionElement(evt.data.element);
                    if (element) {
                        editor.fire('openExpressionEditor', element);
                    }
                }, null, null, 0);
                editor.ui.addButton('ExpressionEditor', {
                    label: 'Insert Expression',
                    command: 'insertExpression',
                    toolbar: '',
                    icon: CKEDITOR.plugins.getPath('expression-editor') + 'toolbar.png'
                });
            }
        });
    }
    getSelectedExpressionElement(element) {
        if (element.is('span') && element.hasAttribute('rx-expression')) {
            return element;
        }
        else {
            const parentElement = element.getParent();
            if (parentElement.is('span') && parentElement.hasAttribute('rx-expression')) {
                return parentElement;
            }
        }
    }
    clearSelection(editor) {
        const selection = editor.getSelection();
        if (selection) {
            selection.removeAllRanges();
        }
    }
}
RxExpressionEditorPluginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExpressionEditorPluginService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
RxExpressionEditorPluginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExpressionEditorPluginService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxExpressionEditorPluginService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class RichTextDesignModule {
    constructor(rxExpressionEditorPluginService, rxDefinitionAdapterRegistryService, richTextDefinitionAdapterService) {
        this.rxExpressionEditorPluginService = rxExpressionEditorPluginService;
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.richTextDefinitionAdapterService = richTextDefinitionAdapterService;
        rxDefinitionAdapterRegistryService.registerDesignAdapter(RxViewComponentType.RichText, this.richTextDefinitionAdapterService);
    }
}
RichTextDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDesignModule, deps: [{ token: RxExpressionEditorPluginService }, { token: i1$1.RxDefinitionAdapterRegistryService }, { token: RichTextDefinitionAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
RichTextDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDesignModule, declarations: [RichTextDesignComponent], imports: [CommonModule, CKEditorModule, ReactiveFormsModule] });
RichTextDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDesignModule, imports: [[CommonModule, CKEditorModule, ReactiveFormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RichTextDesignComponent],
                    entryComponents: [RichTextDesignComponent],
                    imports: [CommonModule, CKEditorModule, ReactiveFormsModule]
                }]
        }], ctorParameters: function () { return [{ type: RxExpressionEditorPluginService }, { type: i1$1.RxDefinitionAdapterRegistryService }, { type: RichTextDefinitionAdapterService }]; } });

class ServiceListDesignComponent {
}
ServiceListDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ServiceListDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ServiceListDesignComponent, selector: "rx-service-list-design", ngImport: i0, template: "<div class=\"row\">\n  <div class=\"col-md-12\">\n    <adapt-rx-select label=\"Service list\" required=\"true\" disabled=\"true\" ngModel> </adapt-rx-select>\n  </div>\n</div>\n", components: [{ type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }], directives: [{ type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-service-list-design',
                    templateUrl: './service-list-design.component.html'
                }]
        }] });

class ServiceListDesignModule {
}
ServiceListDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ServiceListDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListDesignModule, declarations: [ServiceListDesignComponent], imports: [CommonModule, RxDefinitionPickerModule, FormControlsModule, AdaptRxSelectModule, FormsModule] });
ServiceListDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListDesignModule, imports: [[CommonModule, RxDefinitionPickerModule, FormControlsModule, AdaptRxSelectModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RxDefinitionPickerModule, FormControlsModule, AdaptRxSelectModule, FormsModule],
                    declarations: [ServiceListDesignComponent],
                    entryComponents: [ServiceListDesignComponent]
                }]
        }] });

class ServiceListComponent extends BaseViewComponent {
    constructor(httpClient) {
        super();
        this.httpClient = httpClient;
        this.isDisabled = true;
        this.serviceListOptions = [];
        this.service = {
            id: null,
            name: null,
            guid: null
        };
    }
    ngOnInit() {
        super.ngOnInit();
        const serviceRequestId$ = this.config.pipe(pluck('serviceRequestId'), distinctUntilChanged(), takeUntil(this.destroyed$));
        this.httpClient
            .get('/api/com.bmc.dsm.chatbot/rx/application/chatbot/services')
            .pipe(withLatestFrom(serviceRequestId$), finalize(() => {
            this.isDisabled = false;
        }), takeUntil(this.destroyed$))
            .subscribe(([chatbotServices, serviceRequestId]) => {
            this.serviceListOptions = flow((catalogs) => groupBy(catalogs, 'groupName'), (catalogsByGroup) => map$1(catalogsByGroup, (catalogs, groupName) => ({
                name: groupName,
                children: map$1(catalogs, (catalog) => ({
                    id: catalog.id,
                    name: catalog.name,
                    guid: catalog.guid
                }))
            })))((chatbotServices === null || chatbotServices === void 0 ? void 0 : chatbotServices.catalogDetailsList) || []);
            this.selectServiceRequest(serviceRequestId);
        });
        serviceRequestId$.pipe(takeUntil(this.destroyed$)).subscribe((requestId) => {
            this.selectServiceRequest(requestId);
        });
    }
    selectServiceRequest(serviceRequestId) {
        let service;
        forEach(this.serviceListOptions, (item) => {
            if (service) {
                return false;
            }
            service = find(item.children, {
                id: serviceRequestId
            });
        });
        this.service = service
            ? [
                {
                    id: service.id,
                    name: service.name,
                    guid: service.guid
                }
            ]
            : [];
    }
    onSelectionChange(event) {
        const service = event.options[0];
        this.notifyPropertyChanged('serviceRequestId', service.id);
        this.notifyPropertyChanged('serviceRequestName', service.name);
        this.notifyPropertyChanged('serviceRequestGuid', service.guid);
    }
    optionFormatter(option) {
        return option.name;
    }
}
ServiceListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListComponent, deps: [{ token: i1$9.HttpClient }], target: i0.ɵɵFactoryTarget.Component });
ServiceListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ServiceListComponent, selector: "rx-service-list", inputs: { config: "config" }, usesInheritance: true, ngImport: i0, template: "<adapt-rx-select\n  label=\"Service name\"\n  required=\"true\"\n  [options]=\"serviceListOptions\"\n  [disabled]=\"isDisabled\"\n  (onSelectionChange)=\"onSelectionChange($event)\"\n  [ngModel]=\"service\"\n  [optionFormatter]=\"optionFormatter\"\n  enableFilter=\"true\"\n>\n</adapt-rx-select>\n", components: [{ type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }], directives: [{ type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-service-list',
                    templateUrl: './service-list.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i1$9.HttpClient }]; }, propDecorators: { config: [{
                type: Input
            }] } });

class ServiceListModule {
}
ServiceListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ServiceListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListModule, declarations: [ServiceListComponent], imports: [CommonModule, AdaptRxSelectModule, FormsModule], exports: [ServiceListComponent] });
ServiceListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListModule, imports: [[CommonModule, AdaptRxSelectModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptRxSelectModule, FormsModule],
                    declarations: [ServiceListComponent],
                    entryComponents: [ServiceListComponent],
                    exports: [ServiceListComponent]
                }]
        }] });

class RxTabContainerComponent extends ContainerComponent {
    constructor() {
        super(...arguments);
        this.state = {
            enableLazyLoading: false,
            label: ''
        };
    }
}
RxTabContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabContainerComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
RxTabContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxTabContainerComponent, selector: "rx-tab-container", usesInheritance: true, ngImport: i0, template: "<rx-runtime-view-canvas-outlet *ngIf=\"!state.hidden\"></rx-runtime-view-canvas-outlet>\n", styles: [":host{display:block}\n"], components: [{ type: i1$2.RuntimeViewCanvasOutletComponent, selector: "rx-runtime-view-canvas-outlet", inputs: ["name"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-tab-container',
                    templateUrl: './tab-container.component.html',
                    styleUrls: ['./tab-container.component.scss']
                }]
        }] });

class RxTabPanelComponent extends BaseViewComponent {
    constructor(runtimeCanvasItemComponent) {
        super();
        this.runtimeCanvasItemComponent = runtimeCanvasItemComponent;
        this.childLayouts = [];
        this.state = {
            activeTabIndex: null
        };
        this.api = {
            setProperty: this.setProperty.bind(this)
        };
    }
    ngOnInit() {
        super.ngOnInit();
        this.notifyPropertyChanged('api', this.api);
        this.config.pipe(takeUntil(this.destroyed$)).subscribe((config) => {
            this.state = Object.assign(Object.assign({}, this.state), config);
            this.isHidden = Boolean(this.state.hidden);
        });
        this.childLayouts = get(this.runtimeCanvasItemComponent.getChildren(RX_VIEW_DEFINITION.defaultOutletName), '[0].children');
        this.childLayouts.forEach((childLayout) => {
            childLayout.state = {
                enableLazyLoading: false,
                label: '',
                isRendered: false,
                hidden: 0
            };
            childLayout.config
                .pipe(tap((childLayoutConfig) => {
                childLayout.state = Object.assign(Object.assign({}, childLayout.state), childLayoutConfig);
            }), pluck('hidden'), distinctUntilChanged(), skip(1), takeUntil(this.destroyed$))
                .subscribe(() => {
                this.ensureActiveTabIsSet();
            });
        });
        this.trySetFirstVisibleTab();
    }
    setProperty(propertyPath, propertyValue) {
        if (propertyPath === 'hidden') {
            this.state.hidden = propertyValue;
            this.notifyPropertyChanged(propertyPath, propertyValue);
        }
        else if (propertyPath === 'activeTabIndex') {
            this.setActiveTabIndex(parseInt(propertyValue, 10));
        }
        else {
            return throwError(`Tab panel: property ${propertyPath} is not settable.`);
        }
    }
    trackByForTabs(index, item) {
        return item.guid;
    }
    canRenderContentForTab(tab) {
        return !tab.state.enableLazyLoading || tab.state.isRendered;
    }
    getAllTabsData() {
        let adaptTabsetIndex = 0;
        return this.childLayouts.map((tab) => {
            return {
                adaptTabsetIndex: this.isHiddenTab(tab) ? null : adaptTabsetIndex++,
                tab
            };
        });
    }
    isHiddenTab(tab) {
        return Boolean(tab.state.hidden);
    }
    getActiveTabIndexForAdaptTabset() {
        return isNull(this.state.activeTabIndex) ? 0 : this.getAllTabsData()[this.state.activeTabIndex].adaptTabsetIndex;
    }
    onActiveTabChanged(adaptTabsetIndex) {
        const activeTabIndexForAllTabs = findIndex(this.getAllTabsData(), (tab) => tab.adaptTabsetIndex === adaptTabsetIndex);
        this.activateTab(activeTabIndexForAllTabs);
    }
    setActiveTabIndex(index) {
        const tab = this.childLayouts[index];
        if (tab && !this.isHiddenTab(tab)) {
            this.activateTab(index);
        }
    }
    activateTab(index) {
        this.state.activeTabIndex = index;
        if (!isNil(index)) {
            this.childLayouts[index].state.isRendered = true;
        }
        this.notifyPropertyChanged('activeTabIndex', index);
    }
    ensureActiveTabIsSet() {
        const allTabs = this.childLayouts;
        const isAllTabsHidden = every(allTabs, (tab) => this.isHiddenTab(tab));
        if (isAllTabsHidden) {
            this.activateTab(null);
        }
        else if (!isNull(this.state.activeTabIndex) && this.isHiddenTab(allTabs[this.state.activeTabIndex])) {
            this.trySetFirstVisibleTab();
        }
        else if (isNull(this.state.activeTabIndex)) {
            this.trySetFirstVisibleTab();
        }
    }
    trySetFirstVisibleTab() {
        const firstVisibleTab = findIndex(this.childLayouts, (tab) => !this.isHiddenTab(tab));
        if (firstVisibleTab !== -1) {
            this.activateTab(firstVisibleTab);
        }
    }
}
RxTabPanelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelComponent, deps: [{ token: i1$2.RuntimeViewCanvasItemComponent }], target: i0.ɵɵFactoryTarget.Component });
RxTabPanelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RxTabPanelComponent, selector: "rx-tab-panel", usesInheritance: true, ngImport: i0, template: "<adapt-tabset\n  *ngIf=\"!isHidden\"\n  [fullHeight]=\"true\"\n  (tab-active-changed)=\"onActiveTabChanged($event.index)\"\n  [tab-active]=\"getActiveTabIndexForAdaptTabset()\"\n>\n  <ng-template ngFor let-tab [ngForOf]=\"childLayouts\" [ngForTrackBy]=\"trackByForTabs\" let-index=\"index\">\n    <adapt-tab-panel [adapt-tab-title]=\"tab.state.label\" *ngIf=\"!isHiddenTab(tab)\">\n      <rx-runtime-view-canvas-item *ngIf=\"canRenderContentForTab(tab)\" [layout]=\"tab\"> </rx-runtime-view-canvas-item>\n    </adapt-tab-panel>\n\n    <!-- Hidden tab should have instance for using API  -->\n    <rx-runtime-view-canvas-item *ngIf=\"isHiddenTab(tab) && canRenderContentForTab(tab)\" [layout]=\"tab\">\n    </rx-runtime-view-canvas-item>\n  </ng-template>\n</adapt-tabset>\n", components: [{ type: i1.AdaptTabsComponent, selector: "adapt-tabset", inputs: ["showTabToolbar", "customCssTabContent", "fullHeight", "texts", "enableDnD", "customClassTabList", "allow-tabs-adding", "id", "testID", "dropdown-title", "fadeColor", "carouselMode", "justify", "type", "tab-active"], outputs: ["tab-index-closed", "tab-active-changed", "add-tab-clicked", "tabClicked", "tabDropped"], exportAs: ["adaptTabset"] }, { type: i1.AdaptTabsPanelComponent, selector: "adapt-tab-panel, div[tab-panel]", inputs: ["isActive", "badge-type", "animateBadge", "showBadgeAlert", "badgeAlertVariant", "badgeCustomClass", "adapt-tab-title", "disabled", "isHidden", "icon", "subtext", "icon-right", "icon-close", "aria-label", "aria-labelledby", "kebabMenu", "id", "renderContentWhenInactive", "badge"] }, { type: i1$2.RuntimeViewCanvasItemComponent, selector: "rx-runtime-view-canvas-item", inputs: ["layout"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-tab-panel',
                    templateUrl: './tab-panel.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i1$2.RuntimeViewCanvasItemComponent }]; } });

class RxTabPanelComponentDefinitionAdapterService {
    constructor(viewDefinitionParserService, rxJsonParserService) {
        this.viewDefinitionParserService = viewDefinitionParserService;
        this.rxJsonParserService = rxJsonParserService;
    }
    adaptDefinition(tabPanelViewComponentDefinition) {
        this.viewDefinitionParserService
            .getComponents(tabPanelViewComponentDefinition)
            .filter((componentPair) => componentPair.componentDefinition.type === RxViewComponentType.TabPanel)
            .map((componentPair) => componentPair.componentDefinition)
            .forEach((componentDefinition) => {
            if (componentDefinition.layout) {
                let layout = this.rxJsonParserService.tryParseJson(componentDefinition.layout);
                if (layout && layout.componentDefinitionId) {
                    const columns = layout.columns.map((column) => {
                        return {
                            children: column.children.map((child) => child.columns[0].children[0].componentDefinitionId)
                        };
                    });
                    layout = {
                        outlets: [
                            {
                                name: 'DEFAULT',
                                columns: columns
                            }
                        ]
                    };
                    componentDefinition.layout = JSON.stringify(layout);
                }
            }
        });
    }
}
RxTabPanelComponentDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelComponentDefinitionAdapterService, deps: [{ token: i1$4.RxViewDefinitionParserService }, { token: i2$1.RxJsonParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxTabPanelComponentDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelComponentDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelComponentDefinitionAdapterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$4.RxViewDefinitionParserService }, { type: i2$1.RxJsonParserService }]; } });

class RxTabContainerComponentDefinitionAdapterService extends ContainerComponentDefinitionAdapterService {
    constructor(viewDefinitionParserService, rxJsonParserService) {
        super(viewDefinitionParserService, rxJsonParserService);
        this.componentDefinitionType = RxViewComponentType.TabContainer;
    }
}
RxTabContainerComponentDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabContainerComponentDefinitionAdapterService, deps: [{ token: i1$4.RxViewDefinitionParserService }, { token: i2$1.RxJsonParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxTabContainerComponentDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabContainerComponentDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabContainerComponentDefinitionAdapterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$4.RxViewDefinitionParserService }, { type: i2$1.RxJsonParserService }]; } });

class RxTabPanelModule {
    constructor(rxTabPanelComponentDefinitionAdapterService, rxTabContainerComponentDefinitionAdapterService, rxDefinitionAdapterRegistryService) {
        this.rxTabPanelComponentDefinitionAdapterService = rxTabPanelComponentDefinitionAdapterService;
        this.rxTabContainerComponentDefinitionAdapterService = rxTabContainerComponentDefinitionAdapterService;
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.TabPanel, rxTabPanelComponentDefinitionAdapterService);
        rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.TabContainer, rxTabContainerComponentDefinitionAdapterService);
    }
}
RxTabPanelModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelModule, deps: [{ token: RxTabPanelComponentDefinitionAdapterService }, { token: RxTabContainerComponentDefinitionAdapterService }, { token: i1$1.RxDefinitionAdapterRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
RxTabPanelModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelModule, declarations: [RxTabPanelComponent, RxTabContainerComponent], imports: [CommonModule, RuntimeViewCanvasModule, i1.AdaptTabsModule], exports: [RxTabPanelComponent, RxTabContainerComponent] });
RxTabPanelModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelModule, providers: [RxTabPanelComponentDefinitionAdapterService, RxTabContainerComponentDefinitionAdapterService], imports: [[CommonModule, RuntimeViewCanvasModule, AdaptTabsModule.forRoot()]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxTabPanelModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RxTabPanelComponent, RxTabContainerComponent],
                    exports: [RxTabPanelComponent, RxTabContainerComponent],
                    entryComponents: [RxTabPanelComponent, RxTabContainerComponent],
                    imports: [CommonModule, RuntimeViewCanvasModule, AdaptTabsModule.forRoot()],
                    providers: [RxTabPanelComponentDefinitionAdapterService, RxTabContainerComponentDefinitionAdapterService]
                }]
        }], ctorParameters: function () { return [{ type: RxTabPanelComponentDefinitionAdapterService }, { type: RxTabContainerComponentDefinitionAdapterService }, { type: i1$1.RxDefinitionAdapterRegistryService }]; } });

class TabPanelDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.tabContainerGuids$ = this.sandbox.getChildComponentGuids().pipe(shareReplay(1));
        this.tabContainerComponents$ = this.sandbox
            .getChildComponents((component) => component.type === RxViewComponentType.TabContainer)
            .pipe(shareReplay(1), takeUntil(this.sandbox.destroyed$));
        this.selectedTabGuid$ = new ReplaySubject(null);
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({ name: null }, RX_STANDARD_PROPS_DEFAULT_VALUES), initialProperties);
    }
    rxInit() {
        this.sandbox.componentProperties$.pipe(take(1)).subscribe(() => {
            this.sandbox.updateInspectorConfig(this.getInspector());
        });
        this.sandbox.componentProperties$.subscribe((componentProperties) => this.validate(componentProperties));
        this.tabContainerGuids$
            .pipe(map((guids) => !isEmpty(guids)), take(1))
            .subscribe((hasChildComponents) => {
            if (!hasChildComponents) {
                this.sandbox.setChildren([
                    {
                        type: RxViewComponentType.TabContainer,
                        data: {
                            label: 'Tab 1'
                        }
                    },
                    {
                        type: RxViewComponentType.TabContainer,
                        data: {
                            label: 'Tab 2'
                        }
                    }
                ]);
            }
        });
        this.sandbox.getComponentPropertyValue('name').subscribe((name) => {
            const componentName = name ? `${this.sandbox.descriptor.name} (${name})` : this.sandbox.descriptor.name;
            this.sandbox.setSettablePropertiesDataDictionary(componentName, [
                {
                    label: 'Hidden',
                    expression: this.getExpressionForProperty('hidden')
                },
                {
                    label: 'Active Tab Index',
                    expression: this.getExpressionForProperty('activeTabIndex')
                }
            ]);
        });
    }
    addTab() {
        this.sandbox.addComponent({
            type: RxViewComponentType.TabContainer,
            propertiesByName: {
                label: 'New tab'
            }
        });
    }
    removeTab(guid) {
        this.sandbox.removeComponents([guid]);
        combineLatest([this.selectedTabGuid$, this.tabContainerGuids$])
            .pipe(take(1), takeUntil(this.sandbox.destroyed$))
            .subscribe(([selectedTabGuid, tabContainerGuids]) => {
            if (guid === selectedTabGuid) {
                this.selectTab(tabContainerGuids[0]);
            }
        });
    }
    selectTab(guid, skipSelectComponent = false) {
        this.selectedTabGuid$.next(guid);
        if (!skipSelectComponent) {
            setTimeout(() => {
                this.sandbox.selectComponent(guid);
            });
        }
    }
    dropPredicate() {
        return false;
    }
    moveComponent(guid, insertIndex) {
        this.sandbox.moveComponent(guid, insertIndex, this.sandbox.guid);
    }
    validate(properties) {
        this.sandbox.setValidationIssues(validateStandardProps(properties));
    }
    getInspector() {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'name',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Name',
                                tooltip: new Tooltip('Enter a name to uniquely identify the Tab panel')
                            }
                        },
                        ...getStandardPropsInspectorConfigs()
                    ]
                }
            ]
        };
    }
}

class TabPanelDesignComponent {
    constructor(rxUtilityModalsService) {
        this.rxUtilityModalsService = rxUtilityModalsService;
        this.components = [];
        this.destroyed$ = new ReplaySubject(1);
    }
    ngOnInit() {
        this.model.tabContainerComponents$.pipe(takeUntil(this.destroyed$)).subscribe((components) => {
            this.components = components;
            this.adaptTabset.checkActiveIndex();
        });
        this.model.tabContainerComponents$.pipe(take(1)).subscribe((components) => {
            this.model.selectTab(first$1(components).guid, true);
        });
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
    trackByForTabs(index, item) {
        return item.guid;
    }
    onTabClicked(event) {
        this.activeTabChanged(event);
    }
    onTabAdded(e) {
        e.stopPropagation();
        this.model.addTab();
        setTimeout(() => {
            this.adaptTabset.setActiveTab(this.components.length - 1, true, new MouseEvent('click'));
        });
    }
    activeTabChanged({ index, event }) {
        event.stopPropagation();
        this.model.tabContainerGuids$.pipe(take(1)).subscribe((guids) => {
            this.model.selectTab(guids[index]);
        });
    }
    onTabDropped(tabs) {
        for (let i = 0; i < this.components.length; i++) {
            if (this.components[i].guid !== tabs[i].id) {
                if (this.components[i].guid === tabs[i + 1].id) {
                    this.model.moveComponent(tabs[i].id, i);
                    break;
                }
                else {
                    this.model.moveComponent(this.components[i].guid, findIndex(tabs, { id: this.components[i].guid }));
                    break;
                }
            }
        }
    }
    removeTab({ index }) {
        this.rxUtilityModalsService
            .confirm('Are you sure you want to delete this view component?')
            .then((isConfirmed) => {
            if (isConfirmed) {
                this.model.tabContainerGuids$.pipe(take(1)).subscribe((guids) => {
                    this.model.removeTab(guids[index]);
                });
            }
        });
    }
}
TabPanelDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelDesignComponent, deps: [{ token: i1$6.RxUtilityModalsService }], target: i0.ɵɵFactoryTarget.Component });
TabPanelDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: TabPanelDesignComponent, selector: "rx-tab-panel-design", inputs: { model: "model", isReadOnly: "isReadOnly" }, viewQueries: [{ propertyName: "adaptTabset", first: true, predicate: ["adaptTabset"], descendants: true, static: true }], ngImport: i0, template: "<adapt-tabset\n  #adaptTabset\n  (tab-index-closed)=\"removeTab($event)\"\n  (tab-active-changed)=\"activeTabChanged($event)\"\n  (tabClicked)=\"onTabClicked($event)\"\n  (tabDropped)=\"onTabDropped($event)\"\n  (add-tab-clicked)=\"onTabAdded($event)\"\n  [allow-tabs-adding]=\"!isReadOnly\"\n  [enableDnD]=\"true\"\n>\n  <adapt-tab-panel\n    *ngFor=\"\n      let component of components;\n      let index = index;\n      trackBy: trackByForTabs\n    \"\n    [adapt-tab-title]=\"component.data.label\"\n    [icon-close]=\"!isReadOnly && components.length && components.length > 1\"\n    [id]=\"component.guid\"\n  >\n  </adapt-tab-panel>\n</adapt-tabset>\n\n<rx-canvas-outlet [dropPredicate]=\"model.dropPredicate\"></rx-canvas-outlet>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{display:block;border:1px solid #d6d7d8}:host::ng-deep .adapt-tabset>.tab-container>.tab-content{display:none}:host::ng-deep>rx-canvas-outlet>rx-canvas-item-container>div>div>rx-canvas-item-column>.cdk-drop-list>.cdk-drag>.canvas-item{border-width:0;padding:0}:host::ng-deep>rx-canvas-outlet>rx-canvas-item-container>div>div>rx-canvas-item-column>.cdk-drop-list>.cdk-drag>.canvas-item>.canvas-item-header{display:none}\n"], components: [{ type: i1.AdaptTabsComponent, selector: "adapt-tabset", inputs: ["showTabToolbar", "customCssTabContent", "fullHeight", "texts", "enableDnD", "customClassTabList", "allow-tabs-adding", "id", "testID", "dropdown-title", "fadeColor", "carouselMode", "justify", "type", "tab-active"], outputs: ["tab-index-closed", "tab-active-changed", "add-tab-clicked", "tabClicked", "tabDropped"], exportAs: ["adaptTabset"] }, { type: i1.AdaptTabsPanelComponent, selector: "adapt-tab-panel, div[tab-panel]", inputs: ["isActive", "badge-type", "animateBadge", "showBadgeAlert", "badgeAlertVariant", "badgeCustomClass", "adapt-tab-title", "disabled", "isHidden", "icon", "subtext", "icon-right", "icon-close", "aria-label", "aria-labelledby", "kebabMenu", "id", "renderContentWhenInactive", "badge"] }, { type: i1$3.CanvasOutletComponent, selector: "rx-canvas-outlet", inputs: ["name", "skipParentPredicate", "containerComponent", "dropListOrientation", "dropPredicate"], outputs: ["beforeViewComponentDrop"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-tab-panel-design',
                    templateUrl: './tab-panel-design.component.html',
                    styleUrls: ['./tab-panel-design.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1$6.RxUtilityModalsService }]; }, propDecorators: { model: [{
                type: Input
            }], isReadOnly: [{
                type: Input
            }], adaptTabset: [{
                type: ViewChild,
                args: ['adaptTabset', { static: true }]
            }] } });

class TabContainerDesignComponent extends ContainerDesignComponent {
    constructor(tabPanelDesignComponent) {
        super();
        this.tabPanelDesignComponent = tabPanelDesignComponent;
    }
    ngOnInit() {
        this.tabPanelDesignComponent.model.selectedTabGuid$
            .pipe(takeUntil(this.destroyed$))
            .subscribe(this.model.selectedTabGuid$);
    }
}
TabContainerDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabContainerDesignComponent, deps: [{ token: TabPanelDesignComponent }], target: i0.ɵɵFactoryTarget.Component });
TabContainerDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: TabContainerDesignComponent, selector: "rx-tab-container-design", inputs: { model: "model" }, usesInheritance: true, ngImport: i0, template: "<rx-canvas-outlet [skipParentPredicate]=\"true\" [containerComponent]=\"containerCanvasItemComponent\"></rx-canvas-outlet>\n", components: [{ type: i1$3.CanvasOutletComponent, selector: "rx-canvas-outlet", inputs: ["name", "skipParentPredicate", "containerComponent", "dropListOrientation", "dropPredicate"], outputs: ["beforeViewComponentDrop"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabContainerDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-tab-container-design',
                    templateUrl: './tab-container-design.component.html'
                }]
        }], ctorParameters: function () { return [{ type: TabPanelDesignComponent }]; }, propDecorators: { model: [{
                type: Input
            }] } });

class TabPanelDesignModule {
}
TabPanelDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TabPanelDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelDesignModule, declarations: [TabPanelDesignComponent, TabContainerDesignComponent], imports: [CommonModule, AdaptButtonModule, AdaptTabsModule, ViewDesignerCanvasModule] });
TabPanelDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelDesignModule, imports: [[CommonModule, AdaptButtonModule, AdaptTabsModule, ViewDesignerCanvasModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TabPanelDesignComponent, TabContainerDesignComponent],
                    entryComponents: [TabPanelDesignComponent, TabContainerDesignComponent],
                    imports: [CommonModule, AdaptButtonModule, AdaptTabsModule, ViewDesignerCanvasModule]
                }]
        }] });

class PageDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.rxViewComponentRegistryService = this.injector.get(RxViewComponentRegistryService);
        this.componentName$ = this.sandbox.getChildComponents().pipe(filter((childComponents) => childComponents.length > 0), map((childComponents) => {
            const pageComponentType = childComponents[0].type;
            const descriptor = this.rxViewComponentRegistryService.get(pageComponentType);
            return (descriptor === null || descriptor === void 0 ? void 0 : descriptor.name) || RX_VIEW_DEFINITION.unknownPageComponent.name;
        }));
    }
}

class PageDesignComponent {
}
PageDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
PageDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: PageDesignComponent, selector: "rx-page-design", inputs: { model: "model" }, ngImport: i0, template: "<adapt-empty-state type=\"objects\" [label]=\"model.componentName$ | async\"></adapt-empty-state>\n", components: [{ type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-page-design',
                    templateUrl: './page-design.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class PageDesignModule {
}
PageDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PageDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageDesignModule, declarations: [PageDesignComponent], imports: [CommonModule, AdaptEmptyStateModule] });
PageDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageDesignModule, imports: [[CommonModule, AdaptEmptyStateModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptEmptyStateModule],
                    declarations: [PageDesignComponent],
                    entryComponents: [PageDesignComponent]
                }]
        }] });

class PageComponentDefinitionAdapterService {
    adaptDefinition(componentDefinition) {
        componentDefinition.layout = JSON.stringify({
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName,
                    columns: [
                        {
                            children: componentDefinition.componentDefinitions[0].guid
                        }
                    ]
                }
            ]
        });
    }
}
PageComponentDefinitionAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageComponentDefinitionAdapterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PageComponentDefinitionAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageComponentDefinitionAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageComponentDefinitionAdapterService, decorators: [{
            type: Injectable
        }] });

class PageModule {
    constructor(rxDefinitionAdapterRegistryService, pageComponentDefinitionAdapterService) {
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.pageComponentDefinitionAdapterService = pageComponentDefinitionAdapterService;
        this.rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.Page, this.pageComponentDefinitionAdapterService);
    }
}
PageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: PageComponentDefinitionAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
PageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageModule, declarations: [PageComponent], imports: [CommonModule, RuntimeViewCanvasModule], exports: [PageComponent] });
PageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageModule, providers: [PageComponentDefinitionAdapterService], imports: [[CommonModule, RuntimeViewCanvasModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RuntimeViewCanvasModule],
                    providers: [PageComponentDefinitionAdapterService],
                    declarations: [PageComponent],
                    exports: [PageComponent],
                    entryComponents: [PageComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: PageComponentDefinitionAdapterService }]; } });

class ImageDesignComponent {
}
ImageDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ImageDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ImageDesignComponent, selector: "rx-image-design", ngImport: i0, template: "<div class=\"placeholder d-flex justify-content-center align-items-center\">\n  <span class=\"component-icon d-icon-attachment_image_adapt\"></span>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{display:block;border:1px solid #d6d7d8}.placeholder{height:132px;color:#959899}.component-icon{height:100px;width:100px;font-size:100px;position:relative}.component-icon:before{position:absolute;top:0;bottom:0;right:0;left:0}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-image-design',
                    templateUrl: './image-design.component.html',
                    styleUrls: ['./image-design.component.scss']
                }]
        }] });

class ImageDesignModule {
}
ImageDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ImageDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageDesignModule, declarations: [ImageDesignComponent], imports: [CommonModule, RxDefinitionPickerModule, FormControlsModule] });
ImageDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageDesignModule, imports: [[CommonModule, RxDefinitionPickerModule, FormControlsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, RxDefinitionPickerModule, FormControlsModule],
                    declarations: [ImageDesignComponent],
                    entryComponents: [ImageDesignComponent]
                }]
        }] });

var ImageAlignment;
(function (ImageAlignment) {
    ImageAlignment["Left"] = "left";
    ImageAlignment["Center"] = "center";
    ImageAlignment["Right"] = "right";
})(ImageAlignment || (ImageAlignment = {}));
const RX_IMAGE_ALIGNMENT_OPTIONS = [
    {
        id: ImageAlignment.Left,
        name: 'Left'
    },
    {
        id: ImageAlignment.Center,
        name: 'Center'
    },
    {
        id: ImageAlignment.Right,
        name: 'Right'
    }
];
const RX_IMAGE_ALIGNMENT_STYLES = {
    [ImageAlignment.Left]: 'justify-content-start',
    [ImageAlignment.Center]: 'justify-content-center',
    [ImageAlignment.Right]: 'justify-content-end'
};

class ImageComponent extends BaseViewComponent {
    constructor(rxRecordInstanceService, rxLogService, httpClient, domSanitizer, translateService, rxRecordInstanceUtilsService) {
        super();
        this.rxRecordInstanceService = rxRecordInstanceService;
        this.rxLogService = rxLogService;
        this.httpClient = httpClient;
        this.domSanitizer = domSanitizer;
        this.translateService = translateService;
        this.rxRecordInstanceUtilsService = rxRecordInstanceUtilsService;
        this.state = {
            recordDefinitionName: '',
            recordInstanceId: '',
            fieldId: '',
            maxWidth: '',
            imageUrl: null,
            isImageBroken: false,
            alignmentStyle: '',
            altText: ''
        };
        this.api = {
            setProperty: this.setProperty.bind(this)
        };
        this.fileName = '';
    }
    ngOnInit() {
        super.ngOnInit();
        this.notifyPropertyChanged('api', this.api);
        const config$ = this.config.pipe(distinctUntilChanged(isEqual), tap((config) => {
            const newState = Object.assign({}, config);
            this.isHidden = newState.hidden;
            if (!this.state.alignmentStyle && newState.alignment) {
                newState.alignmentStyle = this.getAlignmentStyle(newState.alignment);
            }
            delete newState.alignment;
            this.state = Object.assign(Object.assign({}, this.state), newState);
        }), shareReplay(1));
        config$
            .pipe(map(() => (this.state.recordInstanceId ? this.state.recordInstanceId : null)), filter((recordInstanceId) => Boolean(recordInstanceId)), distinctUntilChanged(), takeUntil(this.destroyed$))
            .subscribe((recordInstanceId) => {
            const imageUrl = this.rxRecordInstanceService.getAttachmentDownloadUrl(this.state.recordDefinitionName, Number(this.state.fieldId), recordInstanceId);
            this.httpClient.get(imageUrl, { responseType: 'blob', observe: 'response' }).subscribe({
                next: (response) => {
                    const fileStream = response.body;
                    this.fileName = this.rxRecordInstanceUtilsService.tryParseContentDisposition(response.headers.get('content-disposition'));
                    if (fileStream && fileStream.type.split('/')[0] === 'image') {
                        const fileReader = new FileReader();
                        fileReader.onloadend = () => {
                            this.state.imageUrl = this.domSanitizer.bypassSecurityTrustResourceUrl(fileReader.result);
                            this.state.isImageBroken = false;
                            this.state.altText = this.fileName;
                        };
                        fileReader.onerror = this.onImageLoadFailed.bind(this);
                        fileReader.readAsDataURL(fileStream);
                    }
                    else {
                        this.rxLogService.warning(`rx-image: attachment is not a valid image.`);
                        this.onImageLoadFailed();
                    }
                },
                error: (err) => {
                    this.state.imageUrl = null;
                    this.state.isImageBroken = false;
                    this.state.altText = '';
                }
            });
        });
    }
    onImageLoadFailed() {
        this.state.imageUrl = null;
        this.state.isImageBroken = true;
        this.state.altText = this.translateService.instant('com.bmc.arsys.rx.client.view-components.image.invalid-image.label', { imageName: this.fileName });
    }
    getAlignmentStyle(alignment) {
        return RX_IMAGE_ALIGNMENT_STYLES[alignment];
    }
    setProperty(propertyPath, value) {
        if (propertyPath === 'hidden') {
            this.isHidden = value;
            this.notifyPropertyChanged(propertyPath, this.isHidden);
        }
        else {
            return throwError(`Image: property ${propertyPath} is not settable.`);
        }
    }
}
ImageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageComponent, deps: [{ token: i1$5.RxRecordInstanceService }, { token: i1$1.RxLogService }, { token: i1$9.HttpClient }, { token: i1$8.DomSanitizer }, { token: i2.TranslateService }, { token: i1$5.RxRecordInstanceUtilsService }], target: i0.ɵɵFactoryTarget.Component });
ImageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ImageComponent, selector: "rx-image", inputs: { config: "config" }, usesInheritance: true, ngImport: i0, template: "<div *ngIf=\"!isHidden\" class=\"d-flex {{ state.alignmentStyle }} image-container\">\n  <img\n    class=\"image\"\n    *ngIf=\"state.imageUrl\"\n    [src]=\"state.imageUrl\"\n    [attr.alt]=\"state.altText\"\n    [style.max-width]=\"state.maxWidth\"\n  />\n\n  <span\n    *ngIf=\"state.isImageBroken\"\n    role=\"img\"\n    [attr.aria-label]=\"state.altText\"\n    class=\"broken-image d-icon-broken_image\"\n  ></span>\n</div>\n", styles: [".broken-image{font-size:64px}.image{align-self:flex-start}.image-container{width:100%;overflow:hidden}\n"], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-image',
                    templateUrl: './image.component.html',
                    styleUrls: ['./image.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1$5.RxRecordInstanceService }, { type: i1$1.RxLogService }, { type: i1$9.HttpClient }, { type: i1$8.DomSanitizer }, { type: i2.TranslateService }, { type: i1$5.RxRecordInstanceUtilsService }]; }, propDecorators: { config: [{
                type: Input
            }] } });

class ImageModule {
}
ImageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ImageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageModule, declarations: [ImageComponent], imports: [CommonModule], exports: [ImageComponent] });
ImageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ImageComponent],
                    entryComponents: [ImageComponent],
                    exports: [ImageComponent]
                }]
        }] });

class ActionButtonRegistrationModule {
    constructor(componentFactoryResolver, rxViewComponentRegistryService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.ActionButton,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(ActionButtonComponent),
            properties: [
                {
                    name: 'recordDefinitionName'
                },
                {
                    name: 'fieldId'
                },
                {
                    name: 'recordInstance',
                    enableExpressionEvaluation: true
                },
                {
                    name: 'label',
                    localizable: true
                },
                RX_DISABLED_PROP_DESC,
                ...RX_STANDARD_PROPS_DESC
            ],
            name: 'Action button',
            isContainerComponent: true,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            icon: 'action_button_cursor',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(ActionButtonDesignComponent),
            designComponentModel: ActionButtonDesignModel,
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
ActionButtonRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonRegistrationModule, deps: [{ token: i0.ComponentFactoryResolver }, { token: i1$4.RxViewComponentRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
ActionButtonRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonRegistrationModule, imports: [ActionButtonDesignModule, ActionButtonModule] });
ActionButtonRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonRegistrationModule, imports: [[ActionButtonDesignModule, ActionButtonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ActionButtonRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ActionButtonDesignModule, ActionButtonModule]
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i1$4.RxViewComponentRegistryService }]; } });

class ButtonBarRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.ButtonBar,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(ButtonBarComponent),
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            properties: RX_STANDARD_PROPS_DESC,
            name: 'Button bar',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            icon: 'button_panel_o',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(ButtonBarDesignComponent),
            designComponentModel: ButtonBarDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
ButtonBarRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
ButtonBarRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarRegistrationModule, imports: [ButtonBarModule, ButtonBarDesignModule] });
ButtonBarRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarRegistrationModule, imports: [[ButtonBarModule, ButtonBarDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ButtonBarRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ButtonBarModule, ButtonBarDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class ContainerRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Container,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(ContainerComponent),
            properties: RX_STANDARD_PROPS_DESC,
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            name: 'Container',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            icon: 'layout',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(ContainerDesignComponent),
            designComponentModel: ContainerDesignModel,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
ContainerRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
ContainerRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerRegistrationModule, imports: [ContainerModule, ContainerDesignModule] });
ContainerRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerRegistrationModule, imports: [[ContainerModule, ContainerDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ContainerRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ContainerModule, ContainerDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class ImageDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.recordDefinitionName$ = this.sandbox.getComponentPropertyValue('recordDefinitionName');
        this.attachmentFields$ = this.recordDefinitionName$.pipe(switchMap((recordDefinitionName) => recordDefinitionName ? this.getAttachmentFieldsFromRecordDefinition(recordDefinitionName) : of([])));
        this.rxModalService = this.injector.get(RxModalService);
        this.rxRecordDefinitionCacheService = this.injector.get(RxRecordDefinitionCacheService);
        this.maxWidthUnits = [
            {
                name: 'pixels',
                id: 'px'
            },
            {
                name: '%',
                id: '%'
            }
        ];
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({ name: null, recordDefinitionName: null, recordInstanceId: null, fieldId: null, maxWidth: null, alignment: ImageAlignment.Left }, RX_STANDARD_PROPS_DEFAULT_VALUES), initialProperties);
    }
    rxInit() {
        this.sandbox.componentProperties$.pipe(take(1)).subscribe((componentProperties) => {
            this.sandbox.updateInspectorConfig(this.getInspector(componentProperties));
        });
        this.recordDefinitionName$
            .pipe(skip(1), withLatestFrom(this.sandbox.componentProperties$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([recordDefinitionName, properties]) => {
            const newProperties = Object.assign(Object.assign({}, properties), { recordInstanceId: null, fieldId: null });
            this.sandbox.updateComponentProperties(newProperties);
            this.sandbox.updateInspectorConfig(this.getInspector(newProperties));
        });
        this.attachmentFields$
            .pipe(withLatestFrom(this.sandbox.componentProperties$), takeUntil(this.sandbox.destroyed$))
            .subscribe(([attachmentFields, properties]) => {
            this.sandbox.updateInspectorConfig(this.getInspector(properties, attachmentFields));
        });
        combineLatest([
            this.validateEmptyProp('recordDefinitionName', 'Record definition name cannot be blank.'),
            this.validateEmptyProp('recordInstanceId', 'Record instance ID cannot be blank.'),
            this.validateEmptyProp('fieldId', 'Field ID cannot be blank.'),
            this.sandbox.getComponentPropertyValue('maxWidth').pipe(map((value) => this.validateMaxWidth(value))),
            this.sandbox.getComponentPropertyValue('styles').pipe(map(validateCssClassNames)),
            this.sandbox
                .getComponentPropertyValue(RX_AVAILABLE_ON_DEVICES_PROP_NAME)
                .pipe(map(validateAvailableOnDevicesProp))
        ])
            .pipe(map(flatten), map(compact), takeUntil(this.sandbox.destroyed$))
            .subscribe((validationIssues) => this.sandbox.setValidationIssues(validationIssues));
        this.sandbox.getComponentPropertyValue('name').subscribe((name) => {
            const componentName = name ? `${this.sandbox.descriptor.name} (${name})` : this.sandbox.descriptor.name;
            this.sandbox.setSettablePropertiesDataDictionary(componentName, [
                {
                    label: 'Hidden',
                    expression: this.getExpressionForProperty('hidden')
                }
            ]);
        });
    }
    getAttachmentFieldsFromRecordDefinition(recordDefinitionName) {
        return this.rxRecordDefinitionCacheService.getRecordDefinition(recordDefinitionName).pipe(map((recordDefinition) => recordDefinition.fieldDefinitions
            .filter((definition) => definition.resourceType === RX_RECORD_DEFINITION.dataTypes.attachment.resourceType)
            .map(({ id, name }) => ({
            id: id.toString(),
            name
        }))));
    }
    getInspector(props, attachmentFields = []) {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'name',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Name',
                                tooltip: new Tooltip('Enter a name to uniquely identify the Image view component.')
                            }
                        },
                        {
                            name: 'recordDefinitionName',
                            component: RxDefinitionPickerComponent,
                            options: {
                                label: 'Record definition name',
                                definitionType: RxDefinitionPickerType.RegularRecord,
                                beforeValueChange: (oldValue, newValue) => {
                                    if (Boolean(oldValue) && props.recordInstanceId && props.fieldId) {
                                        return this.rxModalService.confirm({
                                            title: 'Warning',
                                            modalStyle: RX_MODAL.modalStyles.warning,
                                            message: 'Record Instance ID and Field ID will be cleared. Do you want to continue?'
                                        });
                                    }
                                    else {
                                        return Promise.resolve(true);
                                    }
                                },
                                required: true
                            }
                        },
                        {
                            name: 'fieldId',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Field name',
                                options: attachmentFields,
                                required: true
                            }
                        },
                        {
                            name: 'recordInstanceId',
                            component: ExpressionInspectorControlComponent,
                            options: {
                                label: 'Record ID',
                                isRequired: true
                            }
                        },
                        {
                            name: 'alignment',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Horizontal alignment',
                                options: RX_IMAGE_ALIGNMENT_OPTIONS
                            }
                        },
                        {
                            name: 'maxWidth',
                            component: StepperWithUnitsFormControlComponent,
                            options: {
                                label: 'Maximum width',
                                defaultUnit: 'px',
                                units: this.maxWidthUnits,
                                stepperOptionByUnits: {
                                    px: {
                                        minValue: 0
                                    },
                                    '%': {
                                        minValue: 0,
                                        maxValue: 100,
                                        defaultValue: 100
                                    }
                                }
                            }
                        },
                        ...getStandardPropsInspectorConfigs()
                    ]
                }
            ]
        };
    }
    validateEmptyProp(propertyName, description) {
        return this.sandbox
            .getComponentPropertyValue(propertyName)
            .pipe(map((value) => (value ? null : this.sandbox.createError(description, propertyName))));
    }
    validateMaxWidth(maxWidth) {
        if (maxWidth) {
            const matches = maxWidth.match(/^([+-]?\d+(?:\.\d+)?)(.*)/);
            if (matches) {
                const numberValue = Number(matches[1]);
                const unitValue = matches[2];
                if (unitValue === '%' && numberValue > 100) {
                    return this.sandbox.createError('Maximum width cannot be greater than 100%.');
                }
                else if (numberValue < 0) {
                    return this.sandbox.createError('Maximum width should be a positive number.');
                }
            }
        }
    }
}

class ImageRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService.register({
            type: RxViewComponentType.Image,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(ImageComponent),
            name: 'Image',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            properties: [
                {
                    name: 'recordInstanceId',
                    enableExpressionEvaluation: true
                },
                ...RX_STANDARD_PROPS_DESC
            ],
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(ImageDesignComponent),
            designComponentModel: ImageDesignModel,
            icon: 'attachment_image_adapt',
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
ImageRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
ImageRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageRegistrationModule, imports: [ImageModule, ImageDesignModule] });
ImageRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageRegistrationModule, imports: [[ImageModule, ImageDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ImageRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ImageModule, ImageDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class PageRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService.register({
            type: RxViewComponentType.Page,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(PageComponent),
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            name: 'Page',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(PageDesignComponent),
            designComponentModel: PageDesignModel,
            hidden: true,
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
PageRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
PageRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageRegistrationModule, imports: [PageModule, PageDesignModule] });
PageRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageRegistrationModule, imports: [[PageModule, PageDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PageRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [PageModule, PageDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class RecordEditorRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.RecordEditor,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(RecordEditorComponent),
            properties: [
                {
                    name: 'recordInstanceId',
                    enableExpressionEvaluation: true
                },
                {
                    name: 'allowEdit',
                    enableExpressionEvaluation: true
                },
                {
                    name: 'label',
                    localizable: true
                },
                RX_AVAILABLE_ON_DEVICES_PROP_DESC
            ],
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            name: 'Record editor',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            icon: 'file_text',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(RecordEditorDesignComponent),
            designComponentModel: RecordEditorDesignModel,
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
RecordEditorRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
RecordEditorRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorRegistrationModule, imports: [RecordEditorModule, RecordEditorDesignModule] });
RecordEditorRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorRegistrationModule, imports: [[RecordEditorModule, RecordEditorDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordEditorRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RecordEditorModule, RecordEditorDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class RecordGridExpressionConfigurator extends RxViewComponentExpressionConfigurator {
    constructor(injector, componentGuid, componentModel) {
        super(injector, componentGuid, componentModel);
        this.componentGuid = componentGuid;
        this.componentModel = componentModel;
        this.rxDefinitionNameService = this.injector.get(RxDefinitionNameService);
        this.rxRecordGridUtilsService = this.injector.get(RxRecordGridUtilsService);
        this.rxRecordDefinitionCacheService = this.injector.get(RxRecordDefinitionCacheService);
        const filterExpressionBranch$ = this.getComponentCommonDataDictionary().pipe(switchMap((componentCommonBranch) => componentCommonBranch
            ? componentModel.recordDefinition$.pipe(concatMap((recordDefinition) => this.rxRecordGridUtilsService.getAssociationDescriptors(recordDefinition.name).pipe(concatMap((associationDescriptors) => associationDescriptors.length
                ? forkJoin(associationDescriptors.map((associationDescriptor) => this.rxRecordDefinitionCacheService
                    .getRecordDefinition(associationDescriptor.recordDefinitionName)
                    .pipe(map((associationRecordDefinition) => (Object.assign(Object.assign({}, associationDescriptor), { recordDefinition: associationRecordDefinition }))))))
                : of([])), map((associationDescriptors) => recordDefinition
                ? {
                    label: 'Filter by',
                    children: [
                        {
                            label: this.rxDefinitionNameService.getDisplayName(recordDefinition.name),
                            icon: 'd-icon-file_o_gear',
                            children: recordDefinition.fieldDefinitions.map((fieldDefinition) => {
                                const selectionList = fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.selection
                                    ? map$1(fieldDefinition.optionNamesById, (optionName, optionValue) => ({
                                        label: optionName,
                                        expression: `\${view.components.${componentGuid}.recordDefinition.fieldDefinitionsById[${fieldDefinition.id}].optionsById[${optionValue}].id}`
                                    }))
                                    : undefined;
                                return {
                                    label: fieldDefinition.name,
                                    icon: 'd-icon-file_o_gear',
                                    expression: `'${fieldDefinition.id}'`,
                                    children: fieldDefinition.resourceType === RX_RECORD_DEFINITION.resourceTypes.selection
                                        ? [
                                            {
                                                label: 'Options',
                                                children: selectionList
                                            }
                                        ]
                                        : null,
                                    autocompleteOptions: selectionList
                                };
                            })
                        },
                        ...(associationDescriptors
                            ? associationDescriptors.map((descriptor) => ({
                                label: this.rxDefinitionNameService.getDisplayName(descriptor.associationDefinition.name),
                                icon: 'd-icon-file_o_gear',
                                children: descriptor.recordDefinition.fieldDefinitions.map((fieldDefinition) => ({
                                    label: fieldDefinition.name,
                                    icon: 'd-icon-file_o_gear',
                                    expression: `'\${recordContext._associations.${descriptor.associationDefinition.guid}.${descriptor.nodeSide}[0].${fieldDefinition.id}}'`
                                }))
                            }))
                            : [])
                    ]
                }
                : []))), map((filterByBranch) => (Object.assign(Object.assign({}, componentCommonBranch), { children: [filterByBranch, ...componentCommonBranch.children] }))))
            : of(null)));
        this.configureForProperty({
            propertyPath: 'filterExpression',
            operators: this.getOperatorRowsByGroup(ExpressionOperatorGroup.AllServer),
            dataDictionary$: this.getCommonDataDictionary(filterExpressionBranch$).pipe(map((dataDictionary) => [
                RX_RECORD_GRID_DESIGN.keywords,
                ...(dataDictionary.filter((dataDictionaryBranch) => dataDictionaryBranch.label !== 'General' && dataDictionaryBranch.label !== 'Functions') || [])
            ]))
        });
    }
}

class RecordGridRegistrationModule {
    constructor(componentFactoryResolver, rxViewComponentRegistryService, rxRecordGridQueryExpressionEvaluatorService, rxRecordQueryExpressionEvaluatorService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.rxRecordGridQueryExpressionEvaluatorService = rxRecordGridQueryExpressionEvaluatorService;
        this.rxRecordQueryExpressionEvaluatorService = rxRecordQueryExpressionEvaluatorService;
        rxViewComponentRegistryService.register({
            type: RX_RECORD_GRID.type,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(RecordGridComponent),
            properties: [
                {
                    name: 'recordDefinitionName',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'enableRowSelection',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'enableFiltering',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'getDataForHiddenColumns',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'requiredFilters',
                    type: ViewComponentPropertyType.Number,
                    designType: ViewComponentPropertyType.Number,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'showDataForAllLocales',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'expandable',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean
                },
                {
                    name: 'bordered',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'striped',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'defaultFilterPreset',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'filters',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'filterExpression',
                    type: ViewComponentPropertyType.String,
                    enableExpressionEvaluation: true,
                    evaluatorService: this.rxRecordGridQueryExpressionEvaluatorService
                },
                {
                    name: 'selectedRows',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'firstSelectedRow',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'clickableRow',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'selectedRowCount',
                    type: ViewComponentPropertyType.Number
                },
                {
                    name: 'totalRowCount',
                    type: ViewComponentPropertyType.Number
                },
                {
                    name: 'isUserAllowedToDeleteRecords',
                    type: ViewComponentPropertyType.Boolean
                },
                {
                    name: 'associationDefinitionName',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'associatedRecordNodeSide',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'associatedRecordId',
                    type: ViewComponentPropertyType.String,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'associatedRoleName',
                    type: ViewComponentPropertyType.String,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'enableFilterPresets',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'queryExpression',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'lastRefreshTime',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'viewPresetSelector',
                    enableExpressionEvaluation: true
                },
                RX_AVAILABLE_ON_DEVICES_PROP_DESC
            ],
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                },
                {
                    name: RX_RECORD_GRID.rowActionsOutletName
                }
            ],
            name: 'Record grid',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            icon: 'table',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(RecordGridDesignComponent),
            designComponentModel: RecordGridDesignModel,
            expressionConfigurator: RecordGridExpressionConfigurator,
            bundleId: RX_APPLICATION.platformBundleId
        }, {
            type: RX_RECORD_GRID.components.column,
            configPropertyName: 'columns',
            properties: [
                {
                    name: 'title',
                    type: ViewComponentPropertyType.String,
                    localizable: true
                },
                {
                    name: 'fieldId',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'visible',
                    type: ViewComponentPropertyType.String,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'sortable',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'filterable',
                    type: ViewComponentPropertyType.String,
                    designType: ViewComponentPropertyType.Boolean,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'clickable',
                    type: ViewComponentPropertyType.String,
                    enableExpressionEvaluation: true
                },
                {
                    name: 'index',
                    type: ViewComponentPropertyType.Number
                },
                {
                    name: 'alignment',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'cellDisplayProperties',
                    designType: ViewComponentPropertyType.Array,
                    type: ViewComponentPropertyType.Array
                },
                {
                    name: 'wrapText',
                    type: ViewComponentPropertyType.Boolean
                },
                {
                    name: 'typeaheadKeystrokeCount',
                    type: ViewComponentPropertyType.Number
                },
                {
                    name: 'additionalQueryCriteria',
                    type: ViewComponentPropertyType.String,
                    enableExpressionEvaluation: true,
                    evaluatorService: this.rxRecordQueryExpressionEvaluatorService
                }
            ],
            isDataComponent: true,
            isContainerComponent: true
        }, {
            type: RX_RECORD_GRID.components.filter,
            configPropertyName: 'recordGridFilters',
            properties: [
                {
                    name: 'value',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'fieldId',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: '$DISPLAYVALUE$',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'label',
                    localizable: true
                }
            ],
            isDataComponent: true
        }, {
            type: RX_RECORD_GRID.components.filterPreset,
            configPropertyName: 'predefinedFilterPresets',
            properties: [
                {
                    name: 'title',
                    type: ViewComponentPropertyType.String,
                    localizable: true
                },
                {
                    name: 'filters',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'filterExpression',
                    enableExpressionEvaluation: true,
                    evaluatorService: this.rxRecordGridQueryExpressionEvaluatorService
                }
            ],
            isDataComponent: true,
            isContainerComponent: true
        }, {
            type: RX_RECORD_GRID.components.viewPreset,
            configPropertyName: 'viewPresets',
            properties: [
                {
                    name: 'viewPresetGuid',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'filters',
                    type: ViewComponentPropertyType.String
                }
            ],
            isDataComponent: true,
            isContainerComponent: true
        }, {
            type: RX_RECORD_GRID.components.columnViewPreset,
            configPropertyName: 'columnViewPresets',
            properties: [
                {
                    name: 'fieldId',
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'index',
                    designType: ViewComponentPropertyType.Number,
                    type: ViewComponentPropertyType.Number
                },
                {
                    name: 'visible',
                    designType: ViewComponentPropertyType.Boolean,
                    type: ViewComponentPropertyType.Boolean
                },
                {
                    name: 'sortable',
                    designType: ViewComponentPropertyType.Object,
                    type: ViewComponentPropertyType.Object
                }
            ],
            isDataComponent: true,
            isContainerComponent: true
        });
    }
}
RecordGridRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridRegistrationModule, deps: [{ token: i0.ComponentFactoryResolver }, { token: i1$4.RxViewComponentRegistryService }, { token: RxRecordGridQueryExpressionEvaluatorService }, { token: i1$4.RxRecordQueryExpressionEvaluatorService }], target: i0.ɵɵFactoryTarget.NgModule });
RecordGridRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridRegistrationModule, imports: [RecordGridModule, RecordGridDesignModule] });
RecordGridRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridRegistrationModule, imports: [[RecordGridModule, RecordGridDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RecordGridRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RecordGridModule, RecordGridDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i1$4.RxViewComponentRegistryService }, { type: RxRecordGridQueryExpressionEvaluatorService }, { type: i1$4.RxRecordQueryExpressionEvaluatorService }]; } });

class RichTextRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver, rxRichTextExpressionEvaluatorService) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxRichTextExpressionEvaluatorService = rxRichTextExpressionEvaluatorService;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.RichText,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(RichTextComponent),
            properties: [
                {
                    name: 'html',
                    enableExpressionEvaluation: true,
                    evaluatorService: this.rxRichTextExpressionEvaluatorService,
                    localizable: true
                },
                ...RX_STANDARD_PROPS_DESC
            ],
            name: 'Rich text',
            isContainerComponent: true,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            icon: 'text',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(RichTextDesignComponent),
            designComponentModel: RichTextDesignModel,
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
RichTextRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }, { token: RxRichTextExpressionEvaluatorService }], target: i0.ɵɵFactoryTarget.NgModule });
RichTextRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextRegistrationModule, imports: [RichTextModule, RichTextDesignModule] });
RichTextRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextRegistrationModule, providers: [RichTextDefinitionAdapterService], imports: [[RichTextModule, RichTextDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RichTextRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RichTextModule, RichTextDesignModule],
                    providers: [RichTextDefinitionAdapterService]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }, { type: RxRichTextExpressionEvaluatorService }]; } });

class TabContainerDesignModel extends ViewDesignerComponentModel {
    constructor(injector, sandbox) {
        super(injector, sandbox);
        this.injector = injector;
        this.sandbox = sandbox;
        this.componentProperties$ = this.sandbox.componentProperties$;
        this.hiddenOnCanvas$ = new BehaviorSubject(false);
        this.selectedTabGuid$ = new Subject();
        this.componentProperties$.pipe(take(1)).subscribe(() => {
            this.sandbox.updateInspectorConfig(this.getInspector());
        });
        combineLatest([
            this.sandbox
                .getComponentPropertyValue('label')
                .pipe(map((value) => (value ? null : this.sandbox.createError('Label cannot be blank.', 'label')))),
            this.sandbox.getComponentPropertyValue('styles').pipe(map(validateCssClassNames)),
            this.sandbox
                .getComponentPropertyValue(RX_AVAILABLE_ON_DEVICES_PROP_NAME)
                .pipe(map(validateAvailableOnDevicesProp))
        ])
            .pipe(map(flatten), map(compact))
            .subscribe((validationIssues) => this.sandbox.setValidationIssues(validationIssues));
        this.selectedTabGuid$.pipe(takeUntil(this.sandbox.destroyed$)).subscribe((selectedTabGuid) => {
            this.hiddenOnCanvas$.next(this.sandbox.guid !== selectedTabGuid);
        });
        this.sandbox
            .getComponentPropertyValue('columnCount')
            .pipe(skip(1))
            .subscribe((columnCount) => {
            this.sandbox.setLayout(this.getDefaultColumnSpans(Number(columnCount)));
        });
        this.sandbox.getComponentPropertyValue('label').subscribe((label) => {
            const componentName = label ? `${this.sandbox.descriptor.name} (${label})` : this.sandbox.descriptor.name;
            this.sandbox.setSettablePropertiesDataDictionary(componentName, [
                {
                    label: 'Hidden',
                    expression: this.getExpressionForProperty('hidden')
                }
            ]);
            this.sandbox.setBreadcrumbs(label);
        });
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({ columnCount: '1', enableLazyLoading: false, label: '', rowWrap: ContainerRowWrap.Sm }, RX_STANDARD_PROPS_DEFAULT_VALUES), initialProperties);
    }
    setContainerLayout(columnSizes) {
        this.sandbox.setLayout(columnSizes);
    }
    getDefaultColumnSpans(columnCount) {
        const columnSpans = [];
        const span = Math.floor(RX_CONTAINER.maxColumnSpan / columnCount);
        times(columnCount, () => columnSpans.push(span));
        columnSpans[columnSpans.length - 1] = (RX_CONTAINER.maxColumnSpan % columnCount) + span;
        return columnSpans;
    }
    getInspector() {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'label',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Label',
                                required: true
                            }
                        },
                        {
                            name: 'enableLazyLoading',
                            component: SwitchFormControlComponent,
                            options: {
                                label: 'Enable lazy loading'
                            }
                        },
                        {
                            name: 'columnCount',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Number of columns',
                                required: true,
                                tooltip: new Tooltip('Resize container columns on the canvas by dragging the dashed column separator line.'),
                                options: times(6, (index) => ({ id: (++index).toString(), name: index.toString() }))
                            }
                        },
                        {
                            name: 'rowWrap',
                            component: SelectFormControlComponent,
                            options: {
                                label: 'Row wrap',
                                sortAlphabetically: false,
                                options: values(RX_CONTAINER.rowWrapOptions),
                                tooltip: new Tooltip(`The Row wrap property controls the layout of multi-column containers based on
                    the width of the view. When the width of the view is decreased to a width less
                    than the selected Row wrap value, each container column after the first one
                    wraps onto a new line.`)
                            }
                        },
                        ...getStandardPropsInspectorConfigs()
                    ]
                }
            ]
        };
    }
}

class TabPanelRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.TabPanel,
            componentFactory: componentFactoryResolver.resolveComponentFactory(RxTabPanelComponent),
            properties: RX_STANDARD_PROPS_DESC,
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            name: 'Tab panel',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            icon: 'app_tab',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(TabPanelDesignComponent),
            designComponentModel: TabPanelDesignModel,
            bundleId: RX_APPLICATION.platformBundleId
        }, {
            type: RxViewComponentType.TabContainer,
            componentFactory: componentFactoryResolver.resolveComponentFactory(RxTabContainerComponent),
            properties: [
                ...RX_STANDARD_PROPS_DESC,
                {
                    name: 'label',
                    type: ViewComponentPropertyType.String,
                    localizable: true
                },
                {
                    name: 'enableLazyLoading',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean,
                    enableExpressionEvaluation: true
                }
            ],
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            name: 'Tab',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            hidden: true,
            icon: 'app_tab',
            designComponentFactory: componentFactoryResolver.resolveComponentFactory(TabContainerDesignComponent),
            designComponentModel: TabContainerDesignModel,
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
TabPanelRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
TabPanelRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelRegistrationModule, imports: [RxTabPanelModule, TabPanelDesignModule] });
TabPanelRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelRegistrationModule, imports: [[RxTabPanelModule, TabPanelDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: TabPanelRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RxTabPanelModule, TabPanelDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class ServiceListDesignModel extends ViewDesignerComponentModel {
    static getInitialProperties(initialProperties) {
        return Object.assign({ serviceRequestId: null, serviceRequestName: null, serviceRequestGuid: null }, initialProperties);
    }
    rxInit() {
        this.sandbox
            .getComponentPropertyValue('serviceRequestId')
            .pipe(map((value) => value ? [] : [this.sandbox.createError('Selected service request ID cannot be blank.', 'serviceRequestId')]), takeUntil(this.sandbox.destroyed$))
            .subscribe((validationIssues) => this.sandbox.setValidationIssues(validationIssues));
        this.sandbox.componentProperties$.pipe(take(1)).subscribe(() => {
            this.sandbox.updateInspectorConfig(this.getInspector());
            this.sandbox.setCommonDataDictionary(this.getCommonProps());
        });
    }
    getCommonProps() {
        return {
            label: this.sandbox.descriptor.name,
            expression: this.getExpressionForProperty('api'),
            children: [
                {
                    label: 'Service request ID',
                    expression: this.getExpressionForProperty('serviceRequestId')
                },
                {
                    label: 'Service request name',
                    expression: this.getExpressionForProperty('serviceRequestName')
                },
                {
                    label: 'Service request GUID',
                    expression: this.getExpressionForProperty('serviceRequestGuid')
                }
            ]
        };
    }
    getInspector() {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'serviceRequestId',
                            component: ExpressionInspectorControlComponent,
                            options: {
                                label: 'Service request ID',
                                isRequired: true
                            }
                        },
                        {
                            name: 'serviceRequestName',
                            component: ExpressionInspectorControlComponent,
                            options: {
                                label: 'Service request name'
                            }
                        },
                        {
                            name: 'serviceRequestGuid',
                            component: ExpressionInspectorControlComponent,
                            options: {
                                label: 'Service request GUID'
                            }
                        }
                    ]
                }
            ]
        };
    }
}

class ServiceListRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService.register({
            type: RxViewComponentType.ServiceList,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(ServiceListComponent),
            name: 'Service list',
            group: RX_VIEW_DESIGNER.stencilGroups.chatbotComponents.label,
            options: {
                canBeEmbeddedInRecordEditor: true
            },
            canBeInsertedInto(componentTypes) {
                return componentTypes.includes(RxViewComponentType.RecordEditor);
            },
            properties: [
                {
                    name: 'serviceRequestId',
                    enableExpressionEvaluation: true,
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'serviceRequestName',
                    enableExpressionEvaluation: true,
                    type: ViewComponentPropertyType.String
                },
                {
                    name: 'serviceRequestGuid',
                    enableExpressionEvaluation: true,
                    type: ViewComponentPropertyType.String
                }
            ],
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(ServiceListDesignComponent),
            designComponentModel: ServiceListDesignModel,
            icon: 'field_dropdown',
            bundleId: RX_APPLICATION.chatbotBundleId,
            availableInBundles: [RX_APPLICATION.chatbotBundleId]
        });
    }
}
ServiceListRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
ServiceListRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListRegistrationModule, imports: [ServiceListModule, ServiceListDesignModule] });
ServiceListRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListRegistrationModule, imports: [[ServiceListModule, ServiceListDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ServiceListRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ServiceListModule, ServiceListDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class UnknownDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.label = `Unknown component: ${this.sandbox.componentType}`;
    }
    rxInit() {
        this.sandbox.componentProperties$.pipe(take(1)).subscribe((componentProperties) => {
            this.sandbox.updateInspectorConfig(this.getInspector(componentProperties));
            this.sandbox.setValidationIssues([this.sandbox.createError(this.label)]);
        });
    }
    getInspector(componentProperties) {
        const controls = keys(componentProperties).map((propertyName) => ({
            name: propertyName,
            component: TextFormControlComponent,
            options: {
                label: propertyName
            },
            isDisabled: true
        }));
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls
                }
            ]
        };
    }
}

class UnknownDesignComponent {
}
UnknownDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
UnknownDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: UnknownDesignComponent, selector: "rx-unknown", inputs: { model: "model" }, ngImport: i0, template: "<adapt-empty-state type=\"objects\" [label]=\"model.label\"></adapt-empty-state>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}:host{border:1px solid #d6d7d8;display:block;position:relative;padding:1rem;height:200px}\n"], components: [{ type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-unknown',
                    templateUrl: 'unknown-design.component.html',
                    styleUrls: ['./unknown-design.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class UnknownDesignModule {
}
UnknownDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
UnknownDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownDesignModule, declarations: [UnknownDesignComponent], imports: [CommonModule, AdaptEmptyStateModule] });
UnknownDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownDesignModule, imports: [[CommonModule, AdaptEmptyStateModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AdaptEmptyStateModule],
                    declarations: [UnknownDesignComponent]
                }]
        }] });

class UnknownRegistrationModule {
    constructor(componentFactoryResolver, rxViewComponentRegistryService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.Unknown,
            outlets: [
                {
                    name: RX_VIEW_DEFINITION.defaultOutletName
                }
            ],
            name: 'Unknown',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(UnknownDesignComponent),
            designComponentModel: UnknownDesignModel,
            hidden: true,
            bundleId: RX_APPLICATION.platformBundleId
        });
    }
}
UnknownRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownRegistrationModule, deps: [{ token: i0.ComponentFactoryResolver }, { token: i1$4.RxViewComponentRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
UnknownRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownRegistrationModule, imports: [UnknownDesignModule] });
UnknownRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownRegistrationModule, imports: [[UnknownDesignModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UnknownRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [UnknownDesignModule]
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i1$4.RxViewComponentRegistryService }]; } });

const RX_CHATBOT_USER_MAPPING = {
    commands: {
        createUserMapping: 'com.bmc.arsys.rx.application.chat.command.CreateChatUserMappingCommand'
    },
    mappingStatus: {
        check: 'check',
        failed: 'failed',
        inProgress: 'inProgress',
        missingParameters: 'missingParameters',
        pending: 'pending',
        success: 'success'
    },
    messages: {
        check: 'com.bmc.arsys.rx.settings.check',
        failed: 'com.bmc.arsys.rx.settings.failed',
        inProgress: 'com.bmc.arsys.rx.settings.inProgress',
        missingParameters: 'com.bmc.arsys.rx.settings.missingParameters',
        pending: 'com.bmc.arsys.rx.settings.pending',
        success: 'com.bmc.arsys.rx.settings.success'
    }
};

class ChatbotUserMappingComponent extends BaseViewComponent {
    constructor(translateService, rxCommandFactoryService, rxNotificationService) {
        super();
        this.translateService = translateService;
        this.rxCommandFactoryService = rxCommandFactoryService;
        this.rxNotificationService = rxNotificationService;
        this.encryptedChatUserAndChatId = null;
        this.chatbotProvider = null;
        this.isMappingInProgress = false;
        this.message = '';
        this.mappingStatus = '';
    }
    ngOnInit() {
        this.isMappingInProgress = false;
        this.config.pipe(take(1)).subscribe((config) => {
            this.encryptedChatUserAndChatId = config.encryptedChatUserAndChatId;
            this.chatbotProvider = config.chatbotProvider;
            if (!this.encryptedChatUserAndChatId) {
                this.mappingStatus = RX_CHATBOT_USER_MAPPING.mappingStatus.missingParameters;
                this.rxNotificationService.addErrorMessage(this.translateService.instant(RX_CHATBOT_USER_MAPPING.messages.missingParameters));
            }
            else {
                this.mappingStatus = RX_CHATBOT_USER_MAPPING.mappingStatus.pending;
            }
            this.updateMessage();
        });
    }
    isMappingButtonVisible() {
        return this.mappingStatus === RX_CHATBOT_USER_MAPPING.mappingStatus.pending;
    }
    mapUser() {
        this.isMappingInProgress = true;
        this.mappingStatus = RX_CHATBOT_USER_MAPPING.mappingStatus.inProgress;
        this.updateMessage();
        const commandPayload = {
            encryptedChatUserAndChatId: this.encryptedChatUserAndChatId,
            chatbotProvider: this.chatbotProvider
        };
        this.rxCommandFactoryService
            .forResourceType(RX_CHATBOT_USER_MAPPING.commands.createUserMapping)
            .execute(commandPayload)
            .pipe(catchError((error) => {
            this.mappingStatus = RX_CHATBOT_USER_MAPPING.mappingStatus.failed;
            this.updateMessage();
            this.isMappingInProgress = false;
            return throwError(error);
        }))
            .subscribe(() => {
            this.mappingStatus = RX_CHATBOT_USER_MAPPING.mappingStatus.success;
            this.updateMessage();
            this.isMappingInProgress = false;
        });
    }
    updateMessage() {
        this.message = this.translateService.instant(RX_CHATBOT_USER_MAPPING.messages[this.mappingStatus]);
    }
}
ChatbotUserMappingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ChatbotUserMappingComponent, deps: [{ token: i2.TranslateService }, { token: i1$1.RxCommandFactoryService }, { token: i1$1.RxNotificationService }], target: i0.ɵɵFactoryTarget.Component });
ChatbotUserMappingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ChatbotUserMappingComponent, selector: "com-bmc-arsys-rx-user-mapping", usesInheritance: true, ngImport: i0, template: "<div class=\"text-center mt-1 container\">\n  <div>\n    <span class=\"text-logo\">{{ 'com.bmc.arsys.rx.settings.title' | translate }}</span>\n  </div>\n  <div class=\"mt-4\">{{ message }}</div>\n  <div>\n    <button\n      rx-id=\"verify-bmc-cloud-account\"\n      class=\"mt-4\"\n      adapt-button\n      btn-type=\"primary\"\n      size=\"large\"\n      type=\"button\"\n      [disabled]=\"isMappingInProgress\"\n      (click)=\"mapUser()\"\n      [hidden]=\"!isMappingButtonVisible()\"\n    >\n      {{ 'com.bmc.arsys.rx.settings.verify-cloud-account' | translate }}\n    </button>\n  </div>\n</div>\n", styles: [":root{--border-radius: 4px;--nav-background: var(--gray-900);--nav-links-color: var(--white);--font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;--color-primary-disabled-hover: #ff8d2a;--color-primary-disabled: #ff7d18;--color-primary: #f86e00;--color-primary-hover: #e45f00;--color-primary-active: #d05100;--color-primary-active-hover: #bc4300;--color-secondary-disabled-hover: #ffffff;--color-secondary-disabled: #ffffff;--color-secondary: #f9f9fa;--color-secondary-hover: #e5e5e6;--color-secondary-active: #d2d2d3;--color-secondary-active-hover: #c0c0c2;--color-active-disabled-hover: #45c8bd;--color-active-disabled: #2db7ad;--color-active: #00a79d;--color-active-hover: #00978e;--color-active-active: #00887f;--color-active-active-hover: #007970;--color-info-disabled-hover: #66d9f1;--color-info-disabled: #52c7df;--color-info: #3cb6ce;--color-info-hover: #21a6bd;--color-info-active: #0096ad;--color-info-active-hover: #00879e;--color-success-disabled-hover: #aae860;--color-success-disabled: #99d550;--color-success: #89c341;--color-success-hover: #7ab232;--color-success-active: #6ba122;--color-success-active-hover: #5d9110;--color-warning-disabled-hover: #ffda46;--color-warning-disabled: #ffc734;--color-warning: #f1b521;--color-warning-hover: #dea406;--color-warning-active: #cc9400;--color-warning-active-hover: #ba8400;--color-danger-disabled-hover: #ff5323;--color-danger-disabled: #ff4313;--color-danger: #f83200;--color-danger-hover: #e31f00;--color-danger-active: #cd0500;--color-danger-active-hover: #b80000;--dense-spacing-custom: false;--table-scroll-width: 0}.container{width:400px;margin:auto}.text-logo{font-size:var(--h1-font-size)}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ChatbotUserMappingComponent, decorators: [{
            type: Component,
            args: [{
                    // This is for retro compatibility to reuse the same view "com.bmc.arsys.rx.settings:BMCCloudVerification".
                    // tslint:disable-next-line:component-selector
                    selector: 'com-bmc-arsys-rx-user-mapping',
                    templateUrl: './chatbot-user-mapping.component.html',
                    styleUrls: ['./chatbot-user-mapping.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i2.TranslateService }, { type: i1$1.RxCommandFactoryService }, { type: i1$1.RxNotificationService }]; } });

/**
 * This component is used by Chatbot to map users from a third party channel
 * as Slack, Skype for Enterprise to their Innovation Studio account.
 * Backend sends a link in Slack for example and when the user clicks on it,
 * a page on the rx.settings bundle will be displayed, leveraging this view component:
 * http://localhost:4200/helix/index.html#/com.bmc.arsys.rx.settings/view/com.bmc.arsys.rx.settings:BMCCloudVerification?encryptedChatUserAndChatId=12345&chatbotProvider=slack
 */
class ChatbotUserMappingRegistrationModule {
    constructor(componentFactoryResolver, rxViewComponentRegistryService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        rxViewComponentRegistryService.register({
            // This is for retro compatibility to reuse the same view "com.bmc.arsys.rx.settings:BMCCloudVerification".
            type: 'com-bmc-arsys-rx-user-mapping',
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(ChatbotUserMappingComponent),
            name: 'Chatbot User Mapping',
            availableInBundles: [RX_APPLICATION.settingsBundleId],
            hidden: true,
            properties: [
                {
                    name: 'encryptedChatUserAndChatId',
                    enableExpressionEvaluation: true
                },
                {
                    name: 'chatbotProvider',
                    enableExpressionEvaluation: true
                }
            ]
        });
    }
}
ChatbotUserMappingRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ChatbotUserMappingRegistrationModule, deps: [{ token: i0.ComponentFactoryResolver }, { token: i1$4.RxViewComponentRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
ChatbotUserMappingRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ChatbotUserMappingRegistrationModule, declarations: [ChatbotUserMappingComponent], imports: [AdaptButtonModule, CommonModule, FormsModule, TranslateModule] });
ChatbotUserMappingRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ChatbotUserMappingRegistrationModule, imports: [[AdaptButtonModule, CommonModule, FormsModule, TranslateModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ChatbotUserMappingRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ChatbotUserMappingComponent],
                    imports: [AdaptButtonModule, CommonModule, FormsModule, TranslateModule],
                    entryComponents: [ChatbotUserMappingComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i1$4.RxViewComponentRegistryService }]; } });

const RX_IFRAME_LOGIN_EVENT = {
    eventMessage: 'LOGIN_SUCCESSFUL'
};

class IframeLoginEventComponent extends BaseViewComponent {
    ngOnInit() {
        var _a;
        (_a = window.opener) === null || _a === void 0 ? void 0 : _a.postMessage(RX_IFRAME_LOGIN_EVENT.eventMessage, '*');
    }
}
IframeLoginEventComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IframeLoginEventComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
IframeLoginEventComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: IframeLoginEventComponent, selector: "com-bmc-arsys-rx-settings-iframe-login-event", usesInheritance: true, ngImport: i0, template: "<img\n  src=\"/com.bmc.arsys.rx.settings/resources/images/login-successful.gif\"\n  alt=\"Login successful\"\n  class=\"login-verification\"\n/>\n", styles: [".login-verification{top:50%;left:50%;position:fixed;transform:translate(-50%,-50%);width:670px}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IframeLoginEventComponent, decorators: [{
            type: Component,
            args: [{
                    // This is for retro compatibility to reuse the same view "com.bmc.arsys.rx.settings:BMCLoginVerification".
                    // tslint:disable-next-line:component-selector
                    selector: 'com-bmc-arsys-rx-settings-iframe-login-event',
                    templateUrl: './iframe-login-event.component.html',
                    styleUrls: ['./iframe-login-event.component.scss']
                }]
        }] });

/**
 * This component is used by view-loader.js script when the login cannot be achieved
 * in an iFrame (for example with Microsoft IDP).
 * In this case view-loader.js loads a view in a window popup that will require the user
 * to log in. Once the user is logged in, this View Component will send a PostMessage to
 * view-loader.js that will close the popup.
 */
class IframeLoginEventRegistrationModule {
    constructor(componentFactoryResolver, rxViewComponentRegistryService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        rxViewComponentRegistryService.register({
            // This is for retro compatibility to reuse the same view "com.bmc.arsys.rx.settings:BMCLoginVerification".
            type: 'com-bmc-arsys-rx-settings-iframe-login-event',
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(IframeLoginEventComponent),
            name: 'IFrame Login Event',
            availableInBundles: [RX_APPLICATION.settingsBundleId],
            hidden: true
        });
    }
}
IframeLoginEventRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IframeLoginEventRegistrationModule, deps: [{ token: i0.ComponentFactoryResolver }, { token: i1$4.RxViewComponentRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
IframeLoginEventRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IframeLoginEventRegistrationModule, declarations: [IframeLoginEventComponent], imports: [CommonModule] });
IframeLoginEventRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IframeLoginEventRegistrationModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: IframeLoginEventRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [IframeLoginEventComponent],
                    imports: [CommonModule],
                    entryComponents: [IframeLoginEventComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i1$4.RxViewComponentRegistryService }]; } });

class SmartReportingRedirectorComponent {
    constructor(rxSmartReportingService) {
        this.rxSmartReportingService = rxSmartReportingService;
    }
    ngOnInit() {
        this.rxSmartReportingService
            .openSmartReporting('_self', {
            query: this.runtimeViewModelApi.getViewInputParameters().param
        })
            .subscribe();
    }
}
SmartReportingRedirectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SmartReportingRedirectorComponent, deps: [{ token: i1$1.RxSmartReportingService }], target: i0.ɵɵFactoryTarget.Component });
SmartReportingRedirectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: SmartReportingRedirectorComponent, selector: "rx-smart-reporting-redirector", inputs: { runtimeViewModelApi: "runtimeViewModelApi" }, ngImport: i0, template: "<div class=\"p-3\">{{ 'com.bmc.arsys.rx.client.smart-reporting-redirector.message' | translate }}</div>\n", pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SmartReportingRedirectorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-smart-reporting-redirector',
                    templateUrl: './smart-reporting-redirector.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxSmartReportingService }]; }, propDecorators: { runtimeViewModelApi: [{
                type: Input
            }] } });

class SmartReportingRedirectorRegistrationModule {
    constructor(componentFactoryResolver, rxViewComponentRegistryService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        rxViewComponentRegistryService.register({
            type: 'rx-smart-reporting-redirector',
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(SmartReportingRedirectorComponent),
            name: 'Smart reporting redirector',
            isPageComponent: true,
            hidden: true,
            availableInBundles: [RX_APPLICATION.settingsBundleId]
        });
    }
}
SmartReportingRedirectorRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SmartReportingRedirectorRegistrationModule, deps: [{ token: i0.ComponentFactoryResolver }, { token: i1$4.RxViewComponentRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
SmartReportingRedirectorRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SmartReportingRedirectorRegistrationModule, declarations: [SmartReportingRedirectorComponent], imports: [TranslateModule] });
SmartReportingRedirectorRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SmartReportingRedirectorRegistrationModule, imports: [[TranslateModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: SmartReportingRedirectorRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [SmartReportingRedirectorComponent],
                    imports: [TranslateModule],
                    entryComponents: [SmartReportingRedirectorComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i1$4.RxViewComponentRegistryService }]; } });

const RX_SHARABLE_VIEW_RESETS_FEATURE_NAME = '23503_SHARABLE_VIEW_PRESET';
const RX_VIEW_PRESET = {
    user: {
        recordDefinitionName: 'CTM:People',
        fields: {
            fullName: 1000000017,
            lastName: 1000000018,
            firstName: 1000000019,
            loginId: RX_RECORD_DEFINITION.coreFieldIds.assignee,
            recordId: RX_RECORD_DEFINITION.coreFieldIds.id,
            email: 1000000048
        }
    },
    sharedViewPreset: {
        recordDefinitionName: 'com.bmc.arsys.rx.settings:SharedViewPreset',
        fields: {
            viewPresetName: 58200,
            viewName: 58201,
            viewPresetInfo: 58202,
            viewPresetSelectorGuid: 58203,
            sharedUsers: 58204,
            id: RX_RECORD_DEFINITION.coreFieldIds.id,
            ownerFullName: 58205
        }
    }
};

class RxShareViewPresetDataService {
    constructor(rxRecordInstanceDataPageService, rxRecordInstanceService, httpClient, rxJsonParserService) {
        this.rxRecordInstanceDataPageService = rxRecordInstanceDataPageService;
        this.rxRecordInstanceService = rxRecordInstanceService;
        this.httpClient = httpClient;
        this.rxJsonParserService = rxJsonParserService;
    }
    searchUsers(query) {
        return this.rxRecordInstanceDataPageService
            .post({
            params: {
                recorddefinition: RX_VIEW_PRESET.user.recordDefinitionName,
                propertySelection: [
                    RX_VIEW_PRESET.user.fields.fullName,
                    RX_VIEW_PRESET.user.fields.email,
                    RX_VIEW_PRESET.user.fields.loginId
                ],
                pageSize: RX_DATA_PAGE.defaultPageSize,
                queryExpression: [
                    RX_VIEW_PRESET.user.fields.fullName,
                    RX_VIEW_PRESET.user.fields.email,
                    RX_VIEW_PRESET.user.fields.loginId
                ]
                    .map((fieldId) => `('${fieldId}' LIKE "%${query}%")`)
                    .join(' OR ')
            }
        })
            .pipe(map((result) => result.data));
    }
    getSharedViewPresets(viewPresetSelectorGuid, loginId) {
        return this.rxRecordInstanceDataPageService
            .post({
            params: {
                recorddefinition: RX_VIEW_PRESET.sharedViewPreset.recordDefinitionName,
                queryExpression: [
                    `'${RX_VIEW_PRESET.sharedViewPreset.fields.viewPresetSelectorGuid}' = "${viewPresetSelectorGuid}"`
                ].join(' AND '),
                propertySelection: [
                    RX_VIEW_PRESET.sharedViewPreset.fields.viewPresetName,
                    RX_VIEW_PRESET.sharedViewPreset.fields.id,
                    RX_VIEW_PRESET.sharedViewPreset.fields.ownerFullName,
                    RX_VIEW_PRESET.sharedViewPreset.fields.sharedUsers
                ]
            }
        })
            .pipe(map((dataPageResult) => dataPageResult.data.filter((sharedViewPreset) => {
            const users = this.rxJsonParserService.tryParseJson(sharedViewPreset[RX_VIEW_PRESET.sharedViewPreset.fields.sharedUsers], []);
            return users.find((user) => user.loginId === loginId);
        })));
    }
    getSharedViewPreset(guid) {
        return this.rxRecordInstanceService.get(RX_VIEW_PRESET.sharedViewPreset.recordDefinitionName, guid);
    }
    createSharedViewPreset(payload) {
        return this.httpClient.post(this.getUrl(), payload, {
            responseType: 'text'
        });
    }
    updateSharedViewPreset(guid, payload) {
        return this.httpClient.put(this.getUrl(guid), payload);
    }
    deleteSharedViewPreset(guid) {
        return this.rxRecordInstanceService.delete(RX_VIEW_PRESET.sharedViewPreset.recordDefinitionName, guid);
    }
    getUrl(guid) {
        return guid
            ? `/api/rx/application/configuration/viewpreset/${guid}`
            : `/api/rx/application/configuration/viewpreset`;
    }
}
RxShareViewPresetDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxShareViewPresetDataService, deps: [{ token: i1$5.RxRecordInstanceDataPageService }, { token: i1$5.RxRecordInstanceService }, { token: i1$9.HttpClient }, { token: i2$1.RxJsonParserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxShareViewPresetDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxShareViewPresetDataService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxShareViewPresetDataService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1$5.RxRecordInstanceDataPageService }, { type: i1$5.RxRecordInstanceService }, { type: i1$9.HttpClient }, { type: i2$1.RxJsonParserService }]; } });

class RxShareViewPresetService {
    constructor(rxShareViewPresetDataService, rxStringService, rxJsonParserService, rxCurrentUserService) {
        this.rxShareViewPresetDataService = rxShareViewPresetDataService;
        this.rxStringService = rxStringService;
        this.rxJsonParserService = rxJsonParserService;
        this.rxCurrentUserService = rxCurrentUserService;
    }
    getAutocompleteSearch(text$) {
        return text$.pipe(debounceTime(250), distinctUntilChanged(), switchMap((searchTerm) => {
            const trimmedValue = searchTerm.trim();
            if (trimmedValue.length > 0) {
                return this.rxShareViewPresetDataService.searchUsers(trimmedValue);
            }
            else {
                return of([]);
            }
        }), map((users) => users.map((user) => ({
            text: user[RX_VIEW_PRESET.user.fields.fullName],
            data: {
                loginId: user[RX_VIEW_PRESET.user.fields.loginId],
                fullName: user[RX_VIEW_PRESET.user.fields.fullName],
                emailAddress: user[RX_VIEW_PRESET.user.fields.email]
            }
        }))));
    }
    getSharedViewPresetUsers(guid) {
        return this.rxShareViewPresetDataService
            .getSharedViewPreset(guid)
            .pipe(map((sharedViewPreset) => this.rxJsonParserService.tryParseJson(sharedViewPreset === null || sharedViewPreset === void 0 ? void 0 : sharedViewPreset.fieldInstances[RX_VIEW_PRESET.sharedViewPreset.fields.sharedUsers].value, [])));
    }
    getSharedViewPresetData(guid) {
        return this.rxShareViewPresetDataService.getSharedViewPreset(guid).pipe(map((sharedViewPreset) => ({
            viewPresetName: sharedViewPreset === null || sharedViewPreset === void 0 ? void 0 : sharedViewPreset.fieldInstances[RX_VIEW_PRESET.sharedViewPreset.fields.viewPresetName].value,
            sharedViewPresets: this.rxJsonParserService.tryParseJson(sharedViewPreset === null || sharedViewPreset === void 0 ? void 0 : sharedViewPreset.fieldInstances[RX_VIEW_PRESET.sharedViewPreset.fields.viewPresetInfo].value, null)
        })));
    }
    createUpdateSharedViewPreset(payload, presetGuid) {
        if (presetGuid) {
            return this.rxShareViewPresetDataService.updateSharedViewPreset(presetGuid, payload).pipe(map(() => presetGuid));
        }
        else {
            return this.rxShareViewPresetDataService.createSharedViewPreset(payload);
        }
    }
    saveSharedViewPreset(data, presetGuid) {
        const sharedUsers$ = data.sharedUsers ? of(data.sharedUsers) : this.getSharedViewPresetUsers(presetGuid);
        return combineLatest([data.runtimeViewModelApi.shareViewPreset(data.presetSelectorGuid), sharedUsers$]).pipe(map(([sharedViewPresets, sharedUsers]) => ({
            viewPresetName: data.currentViewPreset.label,
            viewName: '',
            viewPresetGuid: data.presetSelectorGuid,
            submitter: this.rxCurrentUserService.get().fullName,
            sharedUsers,
            presetInformation: JSON.stringify(sharedViewPresets)
        })), switchMap((payload) => this.createUpdateSharedViewPreset(payload, presetGuid)));
    }
    deleteSharedViewPreset(sharedViewPresetInstanceGuid) {
        return this.rxShareViewPresetDataService.deleteSharedViewPreset(sharedViewPresetInstanceGuid);
    }
    getSharedViewPresetsForCurrentUser(presetSelectorGuid) {
        return this.rxShareViewPresetDataService
            .getSharedViewPresets(presetSelectorGuid, this.rxCurrentUserService.getName())
            .pipe(map((presets) => presets.map((preset) => ({
            label: preset[RX_VIEW_PRESET.sharedViewPreset.fields.viewPresetName],
            guid: preset[RX_VIEW_PRESET.sharedViewPreset.fields.id],
            ownerFullName: preset[RX_VIEW_PRESET.sharedViewPreset.fields.ownerFullName]
        }))));
    }
}
RxShareViewPresetService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxShareViewPresetService, deps: [{ token: RxShareViewPresetDataService }, { token: i2$1.RxStringService }, { token: i2$1.RxJsonParserService }, { token: i1$1.RxCurrentUserService }], target: i0.ɵɵFactoryTarget.Injectable });
RxShareViewPresetService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxShareViewPresetService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxShareViewPresetService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: RxShareViewPresetDataService }, { type: i2$1.RxStringService }, { type: i2$1.RxJsonParserService }, { type: i1$1.RxCurrentUserService }]; } });

class RxViewPresetSelectorUserPreferencesService {
    constructor(rxUserPreferencesService, rxShareViewPresetService) {
        this.rxUserPreferencesService = rxUserPreferencesService;
        this.rxShareViewPresetService = rxShareViewPresetService;
    }
    save(viewPresetSelectorState) {
        const customViewPresets = viewPresetSelectorState.customViewPresetOptions.map((customViewPresetOption) => pick(customViewPresetOption, ['guid', 'label', 'userSharedViewPresetGuid']));
        const sharedViewPresets = viewPresetSelectorState.sharedViewPresetOptions.map((sharedViewPresetOption) => pick(sharedViewPresetOption, ['guid', 'label']));
        const data = {
            preferences: JSON.stringify({
                customViewPresets,
                sharedViewPresets,
                viewPresetGuid: viewPresetSelectorState.appliedViewPresetOption.guid
            }),
            componentTypeName: RxViewComponentType.ViewPresetSelector,
            version: '1.0',
            componentId: this.viewPresetSelectorGuid
        };
        return this.rxUserPreferencesService.setUiComponentPreferences(data, this.viewPresetSelectorGuid);
    }
    applyUserPreferences(viewPresetSelectorGuid, viewPresetSelectorState) {
        this.viewPresetSelectorGuid = viewPresetSelectorGuid;
        return this.get(viewPresetSelectorGuid).pipe(map((preferences) => {
            viewPresetSelectorState.customViewPresetOptions = preferences.customViewPresets;
            if (preferences.sharedViewPresets) {
                viewPresetSelectorState.sharedViewPresetOptions = preferences.sharedViewPresets.map((preset) => (Object.assign(Object.assign({}, preset), { isShared: true })));
            }
            viewPresetSelectorState.appliedViewPresetOption =
                find(viewPresetSelectorState.customViewPresetOptions, { guid: preferences.viewPresetGuid }) ||
                    find(viewPresetSelectorState.systemViewPresetOptions, { guid: preferences.viewPresetGuid }) ||
                    find(viewPresetSelectorState.sharedViewPresetOptions, { guid: preferences.viewPresetGuid }) ||
                    viewPresetSelectorState.systemViewPresetOptions[0];
            return viewPresetSelectorState;
        }), switchMap((state) => this.checkSharedViewPresets(state)));
    }
    get(guid) {
        return this.rxUserPreferencesService.getUiComponentPreferences(guid).pipe(map((preferences) => preferences !== null && preferences !== void 0 ? preferences : {
            customViewPresets: [],
            sharedViewPresets: [],
            viewPresetGuid: null
        }));
    }
    checkSharedViewPresets(state) {
        if (state.sharedViewPresetOptions.length) {
            return this.rxShareViewPresetService.getSharedViewPresetsForCurrentUser(this.viewPresetSelectorGuid).pipe(map((sharedPresets) => {
                let shouldUpdatePreferences = false;
                let removedPresetGuid = null;
                // checking if already added shared presets are still available
                // and updating preset names in case of renaming
                state.sharedViewPresetOptions = state.sharedViewPresetOptions.reduce((result, presetOption) => {
                    const existingPreset = sharedPresets.find((sharedPreset) => sharedPreset.guid === presetOption.guid);
                    if (existingPreset) {
                        if (presetOption.label !== existingPreset.label) {
                            presetOption.label = existingPreset.label;
                            shouldUpdatePreferences = true;
                        }
                        result.push(presetOption);
                    }
                    else {
                        shouldUpdatePreferences = true;
                    }
                    return result;
                }, []);
                // checking if current selected preset is still available
                // and if not - switching to first system preset
                if (state.appliedViewPresetOption.isShared) {
                    const isOptionStillAvailable = state.sharedViewPresetOptions.find((option) => option.guid === state.appliedViewPresetOption.guid);
                    // if preset it not available anymore or sharing was disabled
                    if (!isOptionStillAvailable || !state.isSharingEnabled) {
                        if (!isOptionStillAvailable) {
                            removedPresetGuid = state.appliedViewPresetOption.guid;
                        }
                        state.appliedViewPresetOption = state.systemViewPresetOptions[0];
                    }
                }
                return { state, shouldUpdatePreferences, removedPresetGuid };
            }));
        }
        else {
            return of({ state, shouldUpdatePreferences: false, removedPresetGuid: null });
        }
    }
}
RxViewPresetSelectorUserPreferencesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxViewPresetSelectorUserPreferencesService, deps: [{ token: i1$1.RxUserPreferencesService }, { token: RxShareViewPresetService }], target: i0.ɵɵFactoryTarget.Injectable });
RxViewPresetSelectorUserPreferencesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxViewPresetSelectorUserPreferencesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RxViewPresetSelectorUserPreferencesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.RxUserPreferencesService }, { type: RxShareViewPresetService }]; } });

class RenameViewPresetComponent extends RxModalClass {
    constructor(activeModalRef, injector) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.injector = injector;
        this.viewPresetNameFormControl = new FormControl('');
        this.destroyed$ = new ReplaySubject(1);
        this.modalData = this.activeModalRef.getData();
        this.viewPresetNameFormControl.setValue(this.modalData.viewPresetName);
        this.viewPresetNameFormControl.valueChanges.pipe(takeUntil(this.destroyed$)).subscribe((value) => {
            if (this.viewPresetNameFormControl.dirty && value === this.modalData.viewPresetName) {
                this.viewPresetNameFormControl.reset(this.modalData.viewPresetName);
            }
        });
    }
    ngOnInit() {
        super.ngOnInit();
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
    save() {
        this.activeModalRef.close(this.generateUniqueViewPresetName(this.viewPresetNameFormControl.value));
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
    isViewPresetNameUnique(viewPresetName) {
        const trimmedViewPresetName = viewPresetName.trim();
        return !this.modalData.existingViewPresetNames.some((existingViewPresetName) => existingViewPresetName === trimmedViewPresetName);
    }
    generateUniqueViewPresetName(viewPresetName) {
        const trimmedViewPresetName = viewPresetName.trim();
        let uniqueViewPresetName = trimmedViewPresetName;
        let suffix = 1;
        while (!this.isViewPresetNameUnique(uniqueViewPresetName)) {
            uniqueViewPresetName = `${trimmedViewPresetName}-${suffix++}`;
        }
        return uniqueViewPresetName;
    }
}
RenameViewPresetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RenameViewPresetComponent, deps: [{ token: i1.ActiveModalRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
RenameViewPresetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: RenameViewPresetComponent, selector: "rx-rename-view-preset", usesInheritance: true, ngImport: i0, template: "<div class=\"modal-body\">\n  <adapt-rx-textfield\n    [formControl]=\"viewPresetNameFormControl\"\n    [label]=\"modalData.fieldLabel\"\n    name=\"viewPresetName\"\n    rx-id=\"view-preset-name-field\"\n    [maxlength]=\"254\"\n    required=\"true\"\n    rxNoWhitespace\n    [autofocus]=\"true\"\n  >\n  </adapt-rx-textfield>\n\n  <p *ngIf=\"!isViewPresetNameUnique(viewPresetNameFormControl.value)\" class=\"text-info m-0 pt-1\">\n    {{\n      'com.bmc.arsys.rx.client.view-components.view-preset-selector.view-preset-already-exists.error.message'\n        | translate\n    }}\n  </p>\n</div>\n<div class=\"modal-footer\">\n  <button\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    (click)=\"save()\"\n    [disabled]=\"viewPresetNameFormControl.invalid || viewPresetNameFormControl.pristine\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{ 'com.bmc.arsys.rx.client.common.cancel.label' | translate }}\n  </button>\n</div>\n", components: [{ type: i1.AdaptRxTextfieldComponent, selector: "adapt-rx-textfield", inputs: ["prepend", "append", "isPassword", "autocomplete", "placeholder", "size", "fieldTagText", "fieldTagType", "showValidState", "showValidStateIcon", "showInvalidStateIcon", "validStateMessage", "disabledStyleForReadonlyState"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], directives: [{ type: i2$3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2$1.RxNoWhitespaceValidator, selector: "[rxNoWhitespace]", inputs: ["rxNoWhitespace"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i2$3.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: RenameViewPresetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-rename-view-preset',
                    templateUrl: './rename-view-preset.component.html'
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i0.Injector }]; } });

class ShareViewPresetUsersGridComponent {
    constructor(translateService) {
        this.translateService = translateService;
        this.users = [];
        this.remove = new EventEmitter();
        this.recordGridConfig$ = this.getRecordGridConfig();
    }
    ngOnChanges(changes) {
        if (changes.users.currentValue && !changes.users.firstChange) {
            this.recordGrid.api.refresh().subscribe();
        }
    }
    getRecordGridConfig() {
        const gridColumns = [
            {
                fieldId: 'fullName',
                title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.grid.column.name.title')
            },
            {
                fieldId: 'emailAddress',
                title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.grid.column.email.title')
            }
        ];
        const gridRecordDefinition = {
            fieldDefinitions: [
                {
                    id: 'fullName',
                    resourceType: RX_RECORD_DEFINITION.resourceTypes.character
                },
                {
                    id: 'emailAddress',
                    resourceType: RX_RECORD_DEFINITION.resourceTypes.character
                }
            ]
        };
        return of({
            columns: gridColumns,
            enableFiltering: false,
            enableRowSelection: RowSelectionMode.Multiple,
            recordIdField: 'loginId',
            styles: 'flex-fill',
            toolbarConfig: {
                filter: false,
                visibleColumnsMenu: false
            },
            useExternalFiltering: false,
            actionButtons: [
                {
                    label: this.translateService.instant('com.bmc.arsys.rx.client.common.remove.label'),
                    style: 'tertiary',
                    iconCls: 'minus_circle_o',
                    disabled: () => this.recordGrid.api.getSelectedRows().length === 0,
                    actions: [
                        {
                            name: () => {
                                const selectedUserLoginIds = this.recordGrid.api.getSelectedRows().map((row) => row.loginId);
                                this.remove.emit(selectedUserLoginIds);
                            }
                        }
                    ]
                }
            ],
            getRecordDefinition: () => of(gridRecordDefinition),
            getData: () => of({
                data: this.users,
                totalSize: this.users.length
            })
        });
    }
}
ShareViewPresetUsersGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ShareViewPresetUsersGridComponent, deps: [{ token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
ShareViewPresetUsersGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ShareViewPresetUsersGridComponent, selector: "rx-share-view-preset-users-grid", inputs: { users: "users" }, outputs: { remove: "remove" }, viewQueries: [{ propertyName: "recordGrid", first: true, predicate: RecordGridComponent, descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<rx-record-grid [config]=\"recordGridConfig$\"></rx-record-grid>\n", components: [{ type: RecordGridComponent, selector: "rx-record-grid", inputs: ["config"], outputs: ["dataLoaded"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ShareViewPresetUsersGridComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-share-view-preset-users-grid',
                    templateUrl: './share-view-preset-users-grid.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: i2.TranslateService }]; }, propDecorators: { recordGrid: [{
                type: ViewChild,
                args: [RecordGridComponent, { static: true }]
            }], users: [{
                type: Input
            }], remove: [{
                type: Output
            }] } });

class ShareViewPresetComponent extends RxModalClass {
    constructor(activeModalRef, injector, formBuilder, translateService, rxShareViewPresetService, rxCurrentUserService, rxNotificationService) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.injector = injector;
        this.formBuilder = formBuilder;
        this.translateService = translateService;
        this.rxShareViewPresetService = rxShareViewPresetService;
        this.rxCurrentUserService = rxCurrentUserService;
        this.rxNotificationService = rxNotificationService;
        this.maxRecipients = 100;
        this.strings = {
            users: {
                label: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.users-control.label'),
                placeholder: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.users-control.placeholder')
            },
            addButton: this.translateService.instant('com.bmc.arsys.rx.client.common.add.label'),
            notifyRecipients: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.notify-recipients.label'),
            recipients: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.recipients.label'),
            savedNotification: {
                title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.saved-notification.title'),
                message: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.saved-notification.message')
            },
            removedNotification: {
                title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.removed-notification.title'),
                message: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.removed-notification.message')
            },
            maxRecipientsWarning: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.max-users-warning.message', {
                maxUserCount: this.maxRecipients
            })
        };
        this.form = this.formBuilder.group({
            users: this.formBuilder.control([]),
            notifyRecipients: this.formBuilder.control(false)
        });
        this.modalData = this.activeModalRef.getData();
        this.runtimeViewModelApi = this.modalData.runtimeViewModelApi;
        this.selectedUsers = [];
        this.destroyed$ = new ReplaySubject(1);
        this.currentUserLoginName = this.rxCurrentUserService.getName();
        this.isSelectedUsersChanged = false;
        this.search = (text$) => {
            return this.rxShareViewPresetService.getAutocompleteSearch(text$).pipe(map((tags) => {
                const selectedUsersLoginIDs = this.selectedUsers.map((user) => user.loginId);
                const tagsInputLoginIDs = this.form.get('users').value.map(({ data }) => data.loginId);
                // exclude current user and users that have already been added
                return tags.filter((item) => item.data.loginId !== this.currentUserLoginName &&
                    !selectedUsersLoginIDs.includes(item.data.loginId) &&
                    !tagsInputLoginIDs.includes(item.data.loginId));
            }));
        };
    }
    get isRecipientsLimitReached() {
        return this.form.get('users').value.length + this.selectedUsers.length > this.maxRecipients;
    }
    ngOnInit() {
        super.ngOnInit();
        this.loadExistingSharedViewPresetUsers();
    }
    loadExistingSharedViewPresetUsers() {
        if (this.modalData.currentViewPreset.userSharedViewPresetGuid) {
            this.sharedViewPresetInstanceGuid = this.modalData.currentViewPreset.userSharedViewPresetGuid;
            this.rxShareViewPresetService.getSharedViewPresetUsers(this.sharedViewPresetInstanceGuid).subscribe((users) => {
                this.selectedUsers = users;
            });
        }
    }
    ngOnDestroy() {
        this.destroyed$.next(true);
        this.destroyed$.complete();
    }
    save() {
        if (this.selectedUsers.length) {
            this.saveViewPreset();
        }
        else {
            this.removeViewPreset();
        }
    }
    removeViewPreset() {
        this.rxShareViewPresetService.deleteSharedViewPreset(this.sharedViewPresetInstanceGuid).subscribe(() => {
            this.rxNotificationService.addSuccessMessage(this.strings.removedNotification.message, this.strings.removedNotification.title);
            this.activeModalRef.close(null);
        });
    }
    saveViewPreset() {
        this.rxShareViewPresetService
            .saveSharedViewPreset({
            runtimeViewModelApi: this.runtimeViewModelApi,
            currentViewPreset: this.modalData.currentViewPreset,
            presetSelectorGuid: this.modalData.presetSelectorGuid,
            sharedUsers: this.selectedUsers
        }, this.sharedViewPresetInstanceGuid)
            .subscribe((sharedViewPresetInstanceGuid) => {
            this.rxNotificationService.addSuccessMessage(this.strings.savedNotification.message, this.strings.savedNotification.title);
            this.activeModalRef.close(sharedViewPresetInstanceGuid);
        });
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
    onAdd() {
        const usersToAdd = this.form.get('users').value.map((tag) => (Object.assign({}, tag.data)));
        this.selectedUsers = this.selectedUsers.concat(usersToAdd);
        this.form.get('users').setValue([]);
        this.isSelectedUsersChanged = true;
    }
    removeSelectedUsers(selectedUserLoginIds) {
        this.selectedUsers = this.selectedUsers.filter((user) => !selectedUserLoginIds.includes(user.loginId));
        this.isSelectedUsersChanged = true;
        this.markAsDirty();
    }
    // saving is allowed when changing users of existing preset
    // or creating new preset with at least one user selected
    isSaveButtonDisabled() {
        return !((this.sharedViewPresetInstanceGuid && this.isSelectedUsersChanged) ||
            (!this.sharedViewPresetInstanceGuid && this.selectedUsers.length > 0));
    }
}
ShareViewPresetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ShareViewPresetComponent, deps: [{ token: i1.ActiveModalRef }, { token: i0.Injector }, { token: i2$3.FormBuilder }, { token: i2.TranslateService }, { token: RxShareViewPresetService }, { token: i1$1.RxCurrentUserService }, { token: i1$1.RxNotificationService }], target: i0.ɵɵFactoryTarget.Component });
ShareViewPresetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ShareViewPresetComponent, selector: "rx-share-view-preset", usesInheritance: true, ngImport: i0, template: "<div class=\"modal-body\">\n  <form [formGroup]=\"form\">\n    <div class=\"row row-no-gutters\">\n      <div class=\"col\">\n        <adapt-tag-field\n          formControlName=\"users\"\n          rx-id=\"users-input\"\n          [label]=\"strings.users.label\"\n          [placeholder]=\"strings.users.placeholder\"\n          [replaceModelOnWrite]=\"true\"\n          [suppressManual]=\"true\"\n          [search]=\"search\"\n          [selectItemTemplate]=\"selectItemTemplate\"\n          (ngModelChange)=\"markAsDirty()\"\n        >\n        </adapt-tag-field>\n        <div class=\"warning mb-3\" *ngIf=\"isRecipientsLimitReached\">\n          <adapt-icon name=\"exclamation_triangle\" class=\"text-warning\"></adapt-icon>\n          {{ strings.maxRecipientsWarning }}\n        </div>\n      </div>\n      <div class=\"col-auto pl-0\">\n        <button\n          class=\"add-button\"\n          adapt-button\n          type=\"button\"\n          btn-type=\"secondary\"\n          rx-id=\"add-button\"\n          [disabled]=\"!form.get('users').value.length || isRecipientsLimitReached\"\n          (click)=\"onAdd()\"\n        >\n          <span>{{ strings.addButton }}</span>\n        </button>\n      </div>\n    </div>\n  </form>\n\n  <adapt-rx-control-label [label]=\"strings.recipients\"></adapt-rx-control-label>\n\n  <rx-share-view-preset-users-grid\n    [users]=\"selectedUsers\"\n    (remove)=\"removeSelectedUsers($event)\"\n  ></rx-share-view-preset-users-grid>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"save-button\"\n    [disabled]=\"isSaveButtonDisabled()\"\n    (click)=\"save()\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n  </button>\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{ 'com.bmc.arsys.rx.client.common.cancel.label' | translate }}\n  </button>\n</div>\n\n<ng-template #selectItemTemplate let-result=\"result\" let-term=\"term\">\n  <strong>{{ result.text }}</strong>\n  <div>{{ result.data.emailAddress }}</div>\n</ng-template>\n", styles: [".add-button{margin-top:23px}.warning{margin-top:-10px}:host::ng-deep adapt-tag-field .adapt-mt-wrapper{min-height:80px;padding-right:5px}:host::ng-deep adapt-tag-field .adapt-mt-wrapper .adapt-mt{max-height:72px!important}\n"], components: [{ type: i1.AdaptMetatagComponent, selector: "adapt-metatag, adapt-tag-field", inputs: ["prefix", "suffix", "maxTagLength", "truncateConfig", "id", "testID", "name", "ariaLabel", "search", "maxHeight", "suppressManual", "label", "placeholder", "mainErrorText", "warningStateText", "width", "errorCheck", "warningCheck", "selectItemTemplate", "tagTemplate", "replaceModelOnWrite", "delimiterSymbol", "popupClass", "disabledInput", "openDropdownOnFocus", "selectItemFormatter", "fullWidthEdit", "tagStyleFormatter"], outputs: ["focus", "blur", "removeTag", "addTag", "initTagEditing"] }, { type: i1.AdaptIconComponent, selector: "adapt-icon", inputs: ["name", "classList", "description", "testID"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptRxControlLabelComponent, selector: "adapt-rx-control-label", inputs: ["for", "id", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"] }, { type: ShareViewPresetUsersGridComponent, selector: "rx-share-view-preset-users-grid", inputs: ["users"], outputs: ["remove"] }], directives: [{ type: i2$3.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i2$3.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i2$3.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "translate": i2.TranslatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ShareViewPresetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-share-view-preset',
                    templateUrl: './share-view-preset.component.html',
                    styleUrls: ['./share-view-preset.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i0.Injector }, { type: i2$3.FormBuilder }, { type: i2.TranslateService }, { type: RxShareViewPresetService }, { type: i1$1.RxCurrentUserService }, { type: i1$1.RxNotificationService }]; } });

class AddSharedViewPresetsComponent extends RxModalClass {
    constructor(activeModalRef, injector, translateService) {
        super(activeModalRef, injector);
        this.activeModalRef = activeModalRef;
        this.injector = injector;
        this.translateService = translateService;
        this.recordGridConfig$ = of({
            columns: [
                {
                    fieldId: 'label',
                    title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.add-shared-view-preset.grid.column.preset-name.title')
                },
                {
                    fieldId: 'ownerFullName',
                    title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.add-shared-view-preset.grid.column.shared-by.title')
                }
            ],
            enableFiltering: false,
            enableRowSelection: RowSelectionMode.Multiple,
            recordIdField: 'guid',
            styles: 'flex-fill',
            toolbarConfig: {
                filter: false,
                visibleColumnsMenu: false
            },
            useExternalFiltering: false,
            getRecordDefinition: () => of({
                fieldDefinitions: [
                    {
                        id: 'label',
                        resourceType: RX_RECORD_DEFINITION.resourceTypes.character
                    },
                    {
                        id: 'ownerFullName',
                        resourceType: RX_RECORD_DEFINITION.resourceTypes.character
                    }
                ]
            }),
            getData: () => of({
                data: this.presets,
                totalSize: this.presets.length
            })
        });
        this.modalData = this.activeModalRef.getData();
        this.presets = this.modalData.newPresets;
    }
    ngOnInit() {
        super.ngOnInit();
        this.isAddButtonDisabled$ = this.recordGrid.rowSelectionChanged.pipe(map(isEmpty));
    }
    add() {
        const result = this.recordGrid.api.getSelectedRows().map(({ label, guid }) => ({
            label,
            guid
        }));
        this.activeModalRef.close(result);
    }
    cancel() {
        this.activeModalRef.dismiss(DismissReasons.CLOSE_BTN);
    }
}
AddSharedViewPresetsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AddSharedViewPresetsComponent, deps: [{ token: i1.ActiveModalRef }, { token: i0.Injector }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
AddSharedViewPresetsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: AddSharedViewPresetsComponent, selector: "rx-add-shared-view-presets", viewQueries: [{ propertyName: "recordGrid", first: true, predicate: RecordGridComponent, descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"modal-body\">\n  <div class=\"mb-4\" style=\"white-space: pre-line\">\n    {{\n      'com.bmc.arsys.rx.client.view-components.view-preset-selector.add-shared-view-preset.description.label'\n        | translate\n    }}\n  </div>\n\n  <rx-record-grid [config]=\"recordGridConfig$\"></rx-record-grid>\n</div>\n\n<div class=\"modal-footer\">\n  <button\n    adapt-button\n    btn-type=\"primary\"\n    type=\"button\"\n    rx-id=\"add-button\"\n    (click)=\"add()\"\n    [disabled]=\"isAddButtonDisabled$ | async\"\n  >\n    {{ 'com.bmc.arsys.rx.client.common.add.label' | translate }}\n  </button>\n  <button adapt-button btn-type=\"secondary\" type=\"button\" rx-id=\"cancel-button\" (click)=\"cancel()\">\n    {{ 'com.bmc.arsys.rx.client.common.cancel.label' | translate }}\n  </button>\n</div>\n", components: [{ type: RecordGridComponent, selector: "rx-record-grid", inputs: ["config"], outputs: ["dataLoaded"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], pipes: { "translate": i2.TranslatePipe, "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AddSharedViewPresetsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-add-shared-view-presets',
                    templateUrl: './add-shared-view-presets.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: i1.ActiveModalRef }, { type: i0.Injector }, { type: i2.TranslateService }]; }, propDecorators: { recordGrid: [{
                type: ViewChild,
                args: [RecordGridComponent, { static: true }]
            }] } });

class ViewPresetSelectorComponent extends BaseViewComponent {
    constructor(changeDetectorRef, rxGuidService, rxModalService, rxUtilityModalsService, rxViewPresetSelectorUserPreferencesService, translateService, rxFeatureService, rxNotificationService, rxShareViewPresetService) {
        super();
        this.changeDetectorRef = changeDetectorRef;
        this.rxGuidService = rxGuidService;
        this.rxModalService = rxModalService;
        this.rxUtilityModalsService = rxUtilityModalsService;
        this.rxViewPresetSelectorUserPreferencesService = rxViewPresetSelectorUserPreferencesService;
        this.translateService = translateService;
        this.rxFeatureService = rxFeatureService;
        this.rxNotificationService = rxNotificationService;
        this.rxShareViewPresetService = rxShareViewPresetService;
        this.api = {
            getGuid: () => this.guid,
            markAppliedViewPresetAsEdited: this.markAppliedViewPresetAsEdited.bind(this)
        };
        this.isOperationInProgressSubject = new BehaviorSubject(false);
        this.isViewPresetEditedSubject = new BehaviorSubject(false);
        this.viewPresetSelectorModel$ = combineLatest([this.isOperationInProgressSubject, this.isViewPresetEditedSubject]).pipe(map(([isOperationInProgress, isViewPresetEdited]) => ({
            isOperationInProgress,
            isViewPresetEdited
        })));
        this.strings = {
            deleteLabel: this.translateService.instant('com.bmc.arsys.rx.client.common.delete.label'),
            discardChangesButtonLabel: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.discard-changes.button.label'),
            editedViewPresetTagLabel: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.edited-view-preset-tag.label'),
            renameLabel: this.translateService.instant('com.bmc.arsys.rx.client.common.rename.label'),
            saveLabel: this.translateService.instant('com.bmc.arsys.rx.client.common.save.label'),
            saveAsLabel: this.translateService.instant('com.bmc.arsys.rx.client.common.save-as.label'),
            shareLabel: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share.button.label'),
            systemPresetsTitle: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.preset-type.system.label'),
            sharedPresetsTitle: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.preset-type.shared-with-me.label'),
            customPresetsTitle: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.preset-type.created-by-me.label'),
            sharedTooltip: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.shared-preset.tooltip'),
            addSharedViewPresets: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.add-shared-view-preset.title')
        };
        this.userPreferencesChangedSubject = new Subject();
        this.isSharingFeatureEnabled = this.rxFeatureService.isFeatureEnabled(RX_SHARABLE_VIEW_RESETS_FEATURE_NAME);
        this.userPreferencesChangedSubject
            .pipe(switchMap(() => this.rxViewPresetSelectorUserPreferencesService.save(this.state)), takeUntil(this.destroyed$))
            .subscribe();
    }
    ngOnInit() {
        super.ngOnInit();
        this.notifyPropertyChanged('api', this.api);
        this.config
            .pipe(take(1), map((config) => ({
            systemViewPresetOptions: config.viewPresets,
            customViewPresetOptions: [],
            sharedViewPresetOptions: [],
            appliedViewPresetOption: null,
            isSharingEnabled: config.enableSharing && this.isSharingFeatureEnabled
        })), switchMap((state) => this.rxViewPresetSelectorUserPreferencesService.applyUserPreferences(this.guid, state)), tap(({ state, shouldUpdatePreferences, removedPresetGuid }) => {
            this.state = state;
            this.changeDetectorRef.detectChanges();
            this.isOperationInProgressSubject.next(true);
            if (removedPresetGuid) {
                this.runtimeViewModelApi.deleteViewPreset(removedPresetGuid).subscribe();
            }
            if (shouldUpdatePreferences) {
                this.userPreferencesChangedSubject.next();
            }
        }), switchMap(() => this.applyViewPreset(this.state.appliedViewPresetOption)), finalize(() => this.isOperationInProgressSubject.next(false)))
            .subscribe();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.isOperationInProgressSubject.complete();
        this.isViewPresetEditedSubject.complete();
        this.userPreferencesChangedSubject.complete();
    }
    deleteViewPreset(viewPresetOptionToRemove) {
        this.rxUtilityModalsService
            .confirm(this.translateService.instant(viewPresetOptionToRemove.userSharedViewPresetGuid
            ? 'com.bmc.arsys.rx.client.view-components.view-preset-selector.delete-shared-view-preset-confirmation.message'
            : 'com.bmc.arsys.rx.client.view-components.view-preset-selector.delete-view-preset-confirmation.message'))
            .then((isConfirmed) => {
            if (isConfirmed) {
                const viewPresetGuidToDelete = this.state.appliedViewPresetOption.guid;
                this.state.appliedViewPresetOption = this.state.systemViewPresetOptions[0];
                this.isViewPresetEditedSubject.next(false);
                this.state.customViewPresetOptions = reject(this.state.customViewPresetOptions, {
                    guid: viewPresetGuidToDelete
                });
                this.state.sharedViewPresetOptions = reject(this.state.sharedViewPresetOptions, {
                    guid: viewPresetGuidToDelete
                });
                this.userPreferencesChangedSubject.next();
                this.isOperationInProgressSubject.next(true);
                this.runtimeViewModelApi
                    .applyViewPreset(this.guid, this.state.appliedViewPresetOption.guid)
                    .pipe(finalize(() => {
                    const deleteSharedViewPreset$ = viewPresetOptionToRemove.userSharedViewPresetGuid
                        ? this.rxShareViewPresetService.deleteSharedViewPreset(viewPresetOptionToRemove.userSharedViewPresetGuid)
                        : of(null);
                    deleteSharedViewPreset$
                        .pipe(switchMap(() => this.runtimeViewModelApi.deleteViewPreset(viewPresetGuidToDelete)), finalize(() => this.isOperationInProgressSubject.next(false)))
                        .subscribe();
                }))
                    .subscribe();
            }
        })
            .catch(noop);
    }
    discardViewPresetChanges() {
        this.rxUtilityModalsService
            .confirm(this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.discard-changes-confirmation.message'))
            .then((isConfirmed) => {
            if (isConfirmed) {
                this.isViewPresetEditedSubject.next(false);
                this.isOperationInProgressSubject.next(true);
                const appliedViewPresetOption = this.state.appliedViewPresetOption;
                iif(() => appliedViewPresetOption.isShared, this.getSharedViewPresetData(appliedViewPresetOption).pipe(switchMap((sharedViewPresets) => this.runtimeViewModelApi.discardViewPresetChanges(appliedViewPresetOption.guid, sharedViewPresets))), this.runtimeViewModelApi.discardViewPresetChanges(appliedViewPresetOption.guid))
                    .pipe(finalize(() => this.isOperationInProgressSubject.next(false)))
                    .subscribe();
            }
        })
            .catch(noop);
    }
    renameViewPreset() {
        this.openRenamingModal(this.strings.renameLabel, true)
            .then((viewPresetName) => {
            this.state.appliedViewPresetOption.label = viewPresetName;
            this.state.customViewPresetOptions = sortBy(this.state.customViewPresetOptions, 'label');
            this.userPreferencesChangedSubject.next();
            this.changeDetectorRef.detectChanges();
            // if preset is shared with others - updating with new name
            if (this.state.appliedViewPresetOption.userSharedViewPresetGuid) {
                this.saveSharedViewPreset().subscribe();
            }
        })
            .catch(noop);
    }
    selectPreset(viewPresetOption) {
        this.state.appliedViewPresetOption = viewPresetOption;
        this.isViewPresetEditedSubject.next(false);
        this.userPreferencesChangedSubject.next();
        this.isOperationInProgressSubject.next(true);
        this.applyViewPreset(viewPresetOption)
            .pipe(finalize(() => this.isOperationInProgressSubject.next(false)))
            .subscribe();
    }
    saveAsViewPreset() {
        this.openRenamingModal(this.strings.saveAsLabel)
            .then((viewPresetName) => {
            const viewPreset = {
                guid: this.rxGuidService.generate(),
                label: viewPresetName
            };
            this.state.customViewPresetOptions.push(viewPreset);
            this.state.customViewPresetOptions = sortBy(this.state.customViewPresetOptions, 'label');
            this.state.appliedViewPresetOption = viewPreset;
            this.isViewPresetEditedSubject.next(false);
            this.userPreferencesChangedSubject.next();
            this.isOperationInProgressSubject.next(true);
            this.runtimeViewModelApi
                .applyViewPreset(this.guid, this.state.appliedViewPresetOption.guid)
                .pipe(finalize(() => this.isOperationInProgressSubject.next(false)))
                .subscribe();
        })
            .catch(noop);
    }
    saveViewPreset() {
        this.isViewPresetEditedSubject.next(false);
        this.isOperationInProgressSubject.next(true);
        const saveSharedViewPreset$ = this.state.appliedViewPresetOption.userSharedViewPresetGuid
            ? this.saveSharedViewPreset()
            : of(null);
        saveSharedViewPreset$
            .pipe(switchMap(() => this.runtimeViewModelApi.saveViewPreset(this.state.appliedViewPresetOption.guid)), finalize(() => this.isOperationInProgressSubject.next(false)))
            .subscribe();
    }
    shareViewPreset() {
        this.rxModalService
            .openModal({
            content: ShareViewPresetComponent,
            title: this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.share-view-preset.title'),
            data: {
                runtimeViewModelApi: this.runtimeViewModelApi,
                currentViewPreset: this.state.appliedViewPresetOption,
                presetSelectorGuid: this.guid
            },
            size: 'sm'
        })
            .then((sharedViewPresetGuid) => {
            this.state.appliedViewPresetOption.userSharedViewPresetGuid = sharedViewPresetGuid;
            this.userPreferencesChangedSubject.next();
        })
            .catch(noop);
    }
    onAddSharedPresetsClick() {
        this.rxShareViewPresetService.getSharedViewPresetsForCurrentUser(this.guid).subscribe((presets) => {
            const existingSharedPresetsGuids = this.state.sharedViewPresetOptions.map((option) => option.guid);
            const newPresets = presets.filter((preset) => !existingSharedPresetsGuids.includes(preset.guid));
            if (newPresets.length) {
                this.openAddSharedPresetsModal(newPresets);
            }
            else {
                this.rxNotificationService.addInfoMessage(this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.add-shared-view-preset.notification.no-new-presets.message'), this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.add-shared-view-preset.notification.no-new-presets.title'));
            }
        });
    }
    openAddSharedPresetsModal(newPresets) {
        this.rxModalService
            .openModal({
            content: AddSharedViewPresetsComponent,
            title: this.strings.addSharedViewPresets,
            data: {
                presetSelectorGuid: this.guid,
                newPresets
            },
            size: 'sm'
        })
            .then((addedPresets) => {
            this.state.sharedViewPresetOptions = this.state.sharedViewPresetOptions.concat(addedPresets.map((preset) => (Object.assign(Object.assign({}, preset), { isShared: true }))));
            this.userPreferencesChangedSubject.next();
            if (addedPresets.length) {
                this.rxNotificationService.addSuccessMessage(this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.add-shared-view-preset.notification.presets-added.message'), this.translateService.instant('com.bmc.arsys.rx.client.view-components.view-preset-selector.add-shared-view-preset.notification.presets-added.title'));
            }
        })
            .catch(noop);
    }
    markAppliedViewPresetAsEdited() {
        this.isViewPresetEditedSubject.next(true);
    }
    openRenamingModal(fieldLabel, isEdit) {
        let existingViewPresets = [...this.state.customViewPresetOptions, ...this.state.systemViewPresetOptions];
        if (isEdit) {
            existingViewPresets = existingViewPresets.filter((viewPreset) => viewPreset.guid !== this.state.appliedViewPresetOption.guid);
        }
        return this.rxModalService.openModal({
            content: RenameViewPresetComponent,
            data: {
                fieldLabel,
                existingViewPresetNames: existingViewPresets.map(({ label }) => label),
                viewPresetName: this.state.appliedViewPresetOption.label
            },
            size: 'sm'
        });
    }
    applyViewPreset(viewPresetOption) {
        if (viewPresetOption.isShared) {
            return this.getSharedViewPresetData(viewPresetOption).pipe(switchMap((sharedViewPresets) => this.runtimeViewModelApi.applyViewPreset(this.guid, viewPresetOption.guid, sharedViewPresets)), catchError((error) => this.handleSharedViewPresetLoadError(error, viewPresetOption)));
        }
        else {
            return this.runtimeViewModelApi.applyViewPreset(this.guid, viewPresetOption.guid);
        }
    }
    saveSharedViewPreset() {
        return this.rxShareViewPresetService.saveSharedViewPreset({
            runtimeViewModelApi: this.runtimeViewModelApi,
            currentViewPreset: this.state.appliedViewPresetOption,
            presetSelectorGuid: this.guid
        }, this.state.appliedViewPresetOption.userSharedViewPresetGuid);
    }
    getSharedViewPresetData(viewPresetOption) {
        return this.rxShareViewPresetService.getSharedViewPresetData(viewPresetOption.guid).pipe(map(({ viewPresetName, sharedViewPresets }) => {
            viewPresetOption.label = viewPresetName;
            return sharedViewPresets;
        }));
    }
    handleSharedViewPresetLoadError(error, viewPresetOption) {
        if (error.status === 404) {
            this.state.sharedViewPresetOptions = this.state.sharedViewPresetOptions.filter((option) => option.guid !== viewPresetOption.guid);
            this.runtimeViewModelApi.deleteViewPreset(viewPresetOption.guid).subscribe();
            // if preset was removed - selecting first system preset instead
            this.selectPreset(this.state.systemViewPresetOptions[0]);
            return EMPTY;
        }
        else {
            return throwError(error);
        }
    }
}
ViewPresetSelectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i2$1.RxGuidService }, { token: i1$6.RxModalService }, { token: i1$6.RxUtilityModalsService }, { token: RxViewPresetSelectorUserPreferencesService }, { token: i2.TranslateService }, { token: i1$1.RxFeatureService }, { token: i1$1.RxNotificationService }, { token: RxShareViewPresetService }], target: i0.ɵɵFactoryTarget.Component });
ViewPresetSelectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ViewPresetSelectorComponent, selector: "rx-view-preset-selector", inputs: { config: "config", runtimeViewModelApi: "runtimeViewModelApi" }, providers: [RxViewPresetSelectorUserPreferencesService], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"viewPresetSelectorModel$ | async as viewPresetSelectorModel\">\n  <div class=\"btn-group align-items-center\" *ngIf=\"state\">\n    <div adaptDropdown>\n      <button\n        adapt-button\n        adaptDropdownToggle\n        type=\"button\"\n        btn-type=\"tertiary\"\n        class=\"text-default font-weight-bold text-left\"\n        rx-id=\"toggle-button\"\n        [disabled]=\"viewPresetSelectorModel.isOperationInProgress\"\n      >\n        {{ state.appliedViewPresetOption.label }}\n      </button>\n\n      <div class=\"dropdown-menu {{ isSharingFeatureEnabled ? 'preset-selector' : '' }}\" adaptDropdownMenu tabindex=\"0\">\n        <ng-container *ngIf=\"state.customViewPresetOptions.length\">\n          <div class=\"dropdown-heading\" *ngIf=\"isSharingFeatureEnabled\">{{ strings.customPresetsTitle }}</div>\n          <button\n            *ngFor=\"let customViewPresetOption of state.customViewPresetOptions\"\n            [class.active]=\"customViewPresetOption.guid === state.appliedViewPresetOption.guid\"\n            class=\"dropdown-item\"\n            type=\"button\"\n            (click)=\"selectPreset(customViewPresetOption)\"\n            rx-id=\"custom-view-preset\"\n          >\n            {{ customViewPresetOption.label }}\n\n            <adapt-icon\n              *ngIf=\"customViewPresetOption.userSharedViewPresetGuid && isSharingFeatureEnabled\"\n              name=\"users\"\n              [adaptTooltip]=\"strings.sharedTooltip\"\n              class=\"btn-link float-end ml-2\"\n            ></adapt-icon>\n          </button>\n\n          <div *ngIf=\"!isSharingFeatureEnabled\" class=\"dropdown-divider\"></div>\n        </ng-container>\n\n        <ng-container *ngIf=\"state.isSharingEnabled\">\n          <div class=\"dropdown-heading\">\n            {{ strings.sharedPresetsTitle }}\n\n            <button\n              type=\"button\"\n              class=\"btn btn-link float-end p-0 pl-1 btn-add-shared\"\n              rx-id=\"add-preset-button\"\n              [adaptTooltip]=\"strings.addSharedViewPresets\"\n              (click)=\"onAddSharedPresetsClick()\"\n            >\n              <adapt-icon name=\"plus\"></adapt-icon>\n            </button>\n          </div>\n\n          <button\n            *ngFor=\"let sharedViewPresetOption of state.sharedViewPresetOptions\"\n            class=\"dropdown-item\"\n            [class.active]=\"sharedViewPresetOption.guid === state.appliedViewPresetOption.guid\"\n            type=\"button\"\n            (click)=\"selectPreset(sharedViewPresetOption)\"\n            rx-id=\"shared-view-preset\"\n          >\n            {{ sharedViewPresetOption.label }}\n          </button>\n        </ng-container>\n\n        <div class=\"dropdown-heading\" *ngIf=\"isSharingFeatureEnabled\">{{ strings.systemPresetsTitle }}</div>\n\n        <button\n          *ngFor=\"let systemViewPresetOption of state.systemViewPresetOptions\"\n          class=\"dropdown-item\"\n          [class.active]=\"systemViewPresetOption.guid === state.appliedViewPresetOption.guid\"\n          type=\"button\"\n          (click)=\"selectPreset(systemViewPresetOption)\"\n          rx-id=\"system-view-preset\"\n        >\n          {{ systemViewPresetOption.label }}\n        </button>\n      </div>\n    </div>\n\n    <span class=\"badge badge-secondary extra-small mx-2\" *ngIf=\"viewPresetSelectorModel.isViewPresetEdited\">\n      {{ strings.editedViewPresetTagLabel }}\n    </span>\n\n    <adapt-button\n      btn-type=\"tertiary\"\n      *ngIf=\"\n        !state.appliedViewPresetOption.isSystem &&\n        !state.appliedViewPresetOption.isShared &&\n        viewPresetSelectorModel.isViewPresetEdited\n      \"\n      class=\"d-icon-left-floppy p-2\"\n      rx-id=\"save-button\"\n      [disabled]=\"viewPresetSelectorModel.isOperationInProgress\"\n      (click)=\"saveViewPreset()\"\n    >\n      {{ strings.saveLabel }}\n    </adapt-button>\n\n    <adapt-button\n      btn-type=\"tertiary\"\n      [disabled]=\"viewPresetSelectorModel.isOperationInProgress\"\n      (click)=\"saveAsViewPreset()\"\n      class=\"d-icon-left-save_all_o\"\n      rx-id=\"save-as-button\"\n      *ngIf=\"\n        state.appliedViewPresetOption.isSystem ||\n        state.appliedViewPresetOption.isShared ||\n        !viewPresetSelectorModel.isViewPresetEdited\n      \"\n    >\n      {{ strings.saveAsLabel }}\n    </adapt-button>\n\n    <div\n      class=\"dropdown header-cell-menu-btn\"\n      adaptDropdown\n      *ngIf=\"viewPresetSelectorModel.isViewPresetEdited || !state.appliedViewPresetOption.isSystem\"\n    >\n      <button\n        rx-id=\"more-actions-toggle-button\"\n        class=\"d-icon-ellipsis btn btn-link px-0\"\n        type=\"button\"\n        adaptDropdownToggle\n        [disabled]=\"viewPresetSelectorModel.isOperationInProgress\"\n        [showCaret]=\"false\"\n      ></button>\n\n      <div class=\"dropdown-menu\" adaptDropdownMenu tabindex=\"0\">\n        <adapt-button\n          btn-type=\"tertiary\"\n          *ngIf=\"viewPresetSelectorModel.isViewPresetEdited\"\n          class=\"d-icon-left-undo_adapt dropdown-item\"\n          rx-id=\"discard-changes-button\"\n          (click)=\"discardViewPresetChanges()\"\n        >\n          {{ strings.discardChangesButtonLabel }}\n        </adapt-button>\n\n        <adapt-button\n          btn-type=\"tertiary\"\n          (click)=\"saveAsViewPreset()\"\n          class=\"d-icon-left-save_all_o dropdown-item\"\n          rx-id=\"save-as-button\"\n          *ngIf=\"\n            !state.appliedViewPresetOption.isSystem &&\n            !state.appliedViewPresetOption.isShared &&\n            viewPresetSelectorModel.isViewPresetEdited\n          \"\n        >\n          {{ strings.saveAsLabel }}\n        </adapt-button>\n\n        <adapt-button\n          btn-type=\"tertiary\"\n          *ngIf=\"!state.appliedViewPresetOption.isSystem && !state.appliedViewPresetOption.isShared\"\n          class=\"d-icon-left-field_text dropdown-item\"\n          rx-id=\"rename-selected-view-preset-button\"\n          (click)=\"renameViewPreset()\"\n        >\n          {{ strings.renameLabel }}\n        </adapt-button>\n\n        <adapt-button\n          btn-type=\"tertiary\"\n          *ngIf=\"!state.appliedViewPresetOption.isSystem\"\n          class=\"d-icon-left-trash_adapt dropdown-item\"\n          rx-id=\"remove-selected-view-preset-button\"\n          (click)=\"deleteViewPreset(state.appliedViewPresetOption)\"\n        >\n          {{ strings.deleteLabel }}\n        </adapt-button>\n\n        <adapt-button\n          btn-type=\"tertiary\"\n          *ngIf=\"\n            state.isSharingEnabled &&\n            !state.appliedViewPresetOption.isSystem &&\n            !state.appliedViewPresetOption.isShared &&\n            !viewPresetSelectorModel.isViewPresetEdited\n          \"\n          class=\"d-icon-left-share dropdown-item\"\n          rx-id=\"share-view-preset-button\"\n          (click)=\"shareViewPreset()\"\n        >\n          {{ strings.shareLabel }}\n        </adapt-button>\n      </div>\n    </div>\n  </div>\n</ng-container>\n", styles: ["button[rx-id=toggle-button],button[rx-id=shared-view-preset]{white-space:normal;word-break:break-word}.preset-selector .dropdown-heading{padding:.375rem .875rem;font-weight:bold}.preset-selector .dropdown-item{padding-left:1.75rem}.btn-add-shared{margin-top:-1px}\n"], components: [{ type: i1.AdaptDropdownDirective, selector: "adapt-dropdown, [adaptDropdown]", inputs: ["autoClose", "customClass", "closeOnEscape", "placement", "animationPlacement", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "focusNextElementAfterClose", "appendToBody", "appendTo", "positionTo", "anchorPositionTrackingIntervalMs", "enableAnchorPositionTracking", "recalculatePositionOnElementResize", "setMobileState", "mobileView"], outputs: ["onOpen", "onClose", "anchorPositionChange", "popupAnimationDone"], exportAs: ["adaptDropdown"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptIconComponent, selector: "adapt-icon", inputs: ["name", "classList", "description", "testID"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.AdaptDropdownToggleDirective, selector: "[adaptDropdownToggle]", inputs: ["showCaret", "dropdownTogglerType"] }, { type: i1.AdaptDropdownMenuDirective, selector: "[adaptDropdownMenu]" }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.AdaptTooltipDirective, selector: "[adaptTooltip]", inputs: ["popupDelay", "placement", "width", "minWidth", "useWidthFitting", "adaptRadarDisableEventSending", "adaptTooltip", "manual"], outputs: ["shown", "hidden"], exportAs: ["tooltip"] }], pipes: { "async": i3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-view-preset-selector',
                    templateUrl: './view-preset-selector.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [RxViewPresetSelectorUserPreferencesService],
                    styleUrls: ['./view-preset-selector.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i2$1.RxGuidService }, { type: i1$6.RxModalService }, { type: i1$6.RxUtilityModalsService }, { type: RxViewPresetSelectorUserPreferencesService }, { type: i2.TranslateService }, { type: i1$1.RxFeatureService }, { type: i1$1.RxNotificationService }, { type: RxShareViewPresetService }]; }, propDecorators: { config: [{
                type: Input
            }], runtimeViewModelApi: [{
                type: Input
            }] } });

class ViewPresetSelectorAdapterService {
    adaptDefinition(viewPresetSelectorComponentDefinition) {
        viewPresetSelectorComponentDefinition.componentDefinitions
            .sort((a, b) => a.propertiesByName.index - b.propertiesByName.index)
            .forEach((componentDefinition) => {
            Object.assign(componentDefinition.propertiesByName, {
                guid: componentDefinition.guid,
                isSystem: true
            });
        });
    }
}
ViewPresetSelectorAdapterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorAdapterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ViewPresetSelectorAdapterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorAdapterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorAdapterService, decorators: [{
            type: Injectable
        }] });

class ShareViewPresetModule {
}
ShareViewPresetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ShareViewPresetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ShareViewPresetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ShareViewPresetModule, declarations: [ShareViewPresetComponent, ShareViewPresetUsersGridComponent], imports: [AdaptMetatagModule,
        AdaptButtonModule,
        ReactiveFormsModule,
        TranslateModule,
        RecordGridModule,
        CommonModule,
        AdaptIconModule,
        AdaptRxLabelModule] });
ShareViewPresetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ShareViewPresetModule, imports: [[
            AdaptMetatagModule,
            AdaptButtonModule,
            ReactiveFormsModule,
            TranslateModule,
            RecordGridModule,
            CommonModule,
            AdaptIconModule,
            AdaptRxLabelModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ShareViewPresetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptMetatagModule,
                        AdaptButtonModule,
                        ReactiveFormsModule,
                        TranslateModule,
                        RecordGridModule,
                        CommonModule,
                        AdaptIconModule,
                        AdaptRxLabelModule
                    ],
                    declarations: [ShareViewPresetComponent, ShareViewPresetUsersGridComponent]
                }]
        }] });

class AddSharedViewPresetsModule {
}
AddSharedViewPresetsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AddSharedViewPresetsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AddSharedViewPresetsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AddSharedViewPresetsModule, declarations: [AddSharedViewPresetsComponent], imports: [CommonModule, TranslateModule, AdaptButtonModule, RecordGridModule] });
AddSharedViewPresetsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AddSharedViewPresetsModule, imports: [[CommonModule, TranslateModule, AdaptButtonModule, RecordGridModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AddSharedViewPresetsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [AddSharedViewPresetsComponent],
                    imports: [CommonModule, TranslateModule, AdaptButtonModule, RecordGridModule]
                }]
        }] });

class ViewPresetSelectorModule {
    constructor(rxDefinitionAdapterRegistryService, viewPresetSelectorAdapterService) {
        this.rxDefinitionAdapterRegistryService = rxDefinitionAdapterRegistryService;
        this.viewPresetSelectorAdapterService = viewPresetSelectorAdapterService;
        rxDefinitionAdapterRegistryService.registerRuntimeAdapter(RxViewComponentType.ViewPresetSelector, this.viewPresetSelectorAdapterService);
    }
}
ViewPresetSelectorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorModule, deps: [{ token: i1$1.RxDefinitionAdapterRegistryService }, { token: ViewPresetSelectorAdapterService }], target: i0.ɵɵFactoryTarget.NgModule });
ViewPresetSelectorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorModule, declarations: [RenameViewPresetComponent, ViewPresetSelectorComponent], imports: [AdaptButtonModule,
        AdaptDropdownModule,
        AdaptRxTextfieldModule,
        AdaptTooltipModule,
        CommonModule,
        ReactiveFormsModule,
        RxUniqueValidatorModule,
        TranslateModule,
        RxNoWhitespaceValidatorModule,
        ShareViewPresetModule,
        AddSharedViewPresetsModule,
        AdaptIconModule], exports: [ViewPresetSelectorComponent] });
ViewPresetSelectorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorModule, providers: [ViewPresetSelectorAdapterService], imports: [[
            AdaptButtonModule,
            AdaptDropdownModule,
            AdaptRxTextfieldModule,
            AdaptTooltipModule,
            CommonModule,
            ReactiveFormsModule,
            RxUniqueValidatorModule,
            TranslateModule,
            RxNoWhitespaceValidatorModule,
            ShareViewPresetModule,
            AddSharedViewPresetsModule,
            AdaptIconModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AdaptButtonModule,
                        AdaptDropdownModule,
                        AdaptRxTextfieldModule,
                        AdaptTooltipModule,
                        CommonModule,
                        ReactiveFormsModule,
                        RxUniqueValidatorModule,
                        TranslateModule,
                        RxNoWhitespaceValidatorModule,
                        ShareViewPresetModule,
                        AddSharedViewPresetsModule,
                        AdaptIconModule
                    ],
                    exports: [ViewPresetSelectorComponent],
                    declarations: [RenameViewPresetComponent, ViewPresetSelectorComponent],
                    entryComponents: [ViewPresetSelectorComponent],
                    providers: [ViewPresetSelectorAdapterService]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.RxDefinitionAdapterRegistryService }, { type: ViewPresetSelectorAdapterService }]; } });

class PresetsListWidgetComponent extends InspectorWidgetBase {
    constructor(injector, translateService) {
        super(injector);
        this.injector = injector;
        this.translateService = translateService;
        this.editedPreset = null;
        this.presets = [];
        this.strings = {
            cannotBeBlank: this.translateService.instant('com.bmc.arsys.rx.client.designer.validation.cannot-be-blank.message', {
                propertyName: 'View preset name'
            }),
            duplicateValue: this.translateService.instant('com.bmc.arsys.rx.client.designer.validation.duplicate-value.message')
        };
        this.itemValidationFn = this.itemValidation.bind(this);
    }
    ngOnInit() {
        this.designerItemModel.sandbox
            .getChildComponents()
            .pipe(first(), takeUntil(this.designerItemModel.sandbox.destroyed$))
            .subscribe((res) => {
            res.sort((a, b) => a.data.index - b.data.index);
            this.presets = res.map((component) => ({
                name: component.data.label,
                id: component.guid
            }));
        });
    }
    onPresetsListChange(items) {
        items.forEach((item) => {
            item.name = trim(item.name);
        });
        this.presets = cloneDeep(items);
        const payload = items.map(({ name, id }, index) => ({
            type: RxViewComponentType.ViewPreset,
            guid: String(id),
            data: {
                label: name,
                index
            }
        }));
        this.designerItemModel.sandbox.setChildren(payload);
    }
    onListItemAdd() {
        this.presets.push(this.presets.shift());
    }
    onListItemEdit(preset) {
        this.editedPreset = preset;
    }
    onListItemUpdate() {
        this.editedPreset = null;
    }
    focus() {
        this.adaptRxListBuilderComponent.inputEl.nativeElement.focus();
    }
    itemValidation(value, items, isEdit) {
        let errorMessage = null;
        const otherItemNames = chain(items)
            .reject((item) => isEdit && item.id === this.editedPreset.id)
            .map('name')
            .value();
        const trimmedValue = trim(value);
        if (trimmedValue.length === 0) {
            errorMessage = this.strings.cannotBeBlank;
        }
        else if (otherItemNames.includes(trimmedValue)) {
            errorMessage = this.strings.duplicateValue;
        }
        return errorMessage;
    }
}
PresetsListWidgetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PresetsListWidgetComponent, deps: [{ token: i0.Injector }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
PresetsListWidgetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: PresetsListWidgetComponent, selector: "rx-presets-list-widget", viewQueries: [{ propertyName: "adaptRxListBuilderComponent", first: true, predicate: AdaptRxListBuilderComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<adapt-rx-list-builder\n  [label]=\"'View preset names'\"\n  [(ngModel)]=\"presets\"\n  (ngModelChange)=\"onPresetsListChange($event)\"\n  [hideListAreaLabel]=\"true\"\n  [texts]=\"options.texts\"\n  [readonly]=\"isDisabled\"\n  (listItemAdd)=\"onListItemAdd()\"\n  (listItemEdit)=\"onListItemEdit($event)\"\n  (listItemUpdate)=\"onListItemUpdate()\"\n  [itemValidation]=\"itemValidationFn\"\n>\n</adapt-rx-list-builder>\n", styles: [""], components: [{ type: i1.AdaptRxListBuilderComponent, selector: "adapt-rx-list-builder", inputs: ["hideSearchField", "hideEdit", "hideDelete", "hideListAreaLabel", "customSort", "texts", "menuHeight", "listItemMaxLength", "generateListItemId", "itemValidation", "disabled", "treeStructure", "listItemFormatter", "listItemSetterProp", "listItemContentTemplate", "selectionMode"], outputs: ["listItemAdd", "listItemEdit", "listItemUpdate", "listItemRemove"] }], directives: [{ type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PresetsListWidgetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-presets-list-widget',
                    templateUrl: './presets-list-widget.component.html',
                    styleUrls: ['./presets-list-widget.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i2.TranslateService }]; }, propDecorators: { adaptRxListBuilderComponent: [{
                type: ViewChild,
                args: [AdaptRxListBuilderComponent]
            }] } });

class ViewPresetSelectorDesignModel extends ViewDesignerComponentModel {
    constructor() {
        super(...arguments);
        this.presetComponentGuids$ = this.sandbox.getChildComponentGuids();
        this.otherPresetSelectorsNames$ = this.sandbox
            .getComponentsByType(RxViewComponentType.ViewPresetSelector)
            .pipe(map((selectors) => selectors
            .filter((component) => component.guid !== this.sandbox.guid)
            .map((component) => component.data.name.trim())));
        this.label$ = this.sandbox.getChildComponents().pipe(map((components) => components.sort((a, b) => a.data.index - b.data.index)), map((components) => (components[0] ? components[0].data.label : 'No view presets added')), takeUntil(this.sandbox.destroyed$));
        this.rxFeatureService = this.injector.get(RxFeatureService);
    }
    static getInitialProperties(initialProperties) {
        return Object.assign(Object.assign({ name: 'View preset selector', styles: null, enableSharing: false }, RX_AVAILABLE_ON_DEVICES_DEFAULT_VALUE), initialProperties);
    }
    rxInit() {
        this.sandbox.updateInspectorConfig(this.setInspectorConfig());
        combineLatest([this.sandbox.componentProperties$, this.presetComponentGuids$])
            .pipe(withLatestFrom(this.otherPresetSelectorsNames$), map(([[componentProperties, presetGuids], otherPresetSelectorsNames]) => this.validate(componentProperties, presetGuids, otherPresetSelectorsNames)), takeUntil(this.sandbox.destroyed$))
            .subscribe((validationIssues) => {
            this.sandbox.setValidationIssues(validationIssues);
        });
    }
    setInspectorConfig() {
        return {
            inspectorSectionConfigs: [
                {
                    label: 'General',
                    controls: [
                        {
                            name: 'name',
                            component: TextFormControlComponent,
                            options: {
                                label: 'Name',
                                required: true
                            }
                        },
                        {
                            component: PresetsListWidgetComponent,
                            widgetName: 'presetsList'
                        },
                        this.rxFeatureService.isFeatureEnabled(RX_SHARABLE_VIEW_RESETS_FEATURE_NAME)
                            ? {
                                name: 'enableSharing',
                                component: SwitchFormControlComponent,
                                options: {
                                    label: 'Enable sharing'
                                }
                            }
                            : null,
                        getAvailableOnDevicesInspectorConfig(),
                        getStylesFieldInspectorConfig()
                    ].filter(Boolean)
                }
            ]
        };
    }
    validate(model, presetGuids, otherPresetSelectorsNames) {
        let validationIssues = [];
        const trimmedModelName = model.name.trim();
        if (!trimmedModelName) {
            validationIssues.push(this.sandbox.createError('Name cannot be blank.', 'name'));
        }
        else if (otherPresetSelectorsNames.includes(trimmedModelName)) {
            validationIssues.push(this.sandbox.createError('Name must be unique.', 'name'));
        }
        if (!presetGuids.length) {
            validationIssues.push(this.sandbox.createError('At least one view preset must be added.', 'presetsList'));
        }
        validationIssues = validationIssues.concat(validateStandardProps(model));
        return validationIssues;
    }
}

class ViewPresetSelectorDesignComponent {
}
ViewPresetSelectorDesignComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorDesignComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ViewPresetSelectorDesignComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: ViewPresetSelectorDesignComponent, selector: "rx-view-preset-selector-design", inputs: { model: "model" }, ngImport: i0, template: "<button\n  class=\"dropdown-toggle text-default font-weight-bold text-left\"\n  adapt-button\n  btn-type=\"tertiary\"\n  type=\"button\"\n  readonly\n>\n  {{ model.label$ | async }}\n</button>\n", styles: ["button{white-space:normal;word-break:break-word}\n"], components: [{ type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorDesignComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-view-preset-selector-design',
                    templateUrl: './view-preset-selector-design.component.html',
                    styleUrls: ['./view-preset-selector-design.component.scss']
                }]
        }], propDecorators: { model: [{
                type: Input
            }] } });

class PresetsListWidgetModule {
}
PresetsListWidgetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PresetsListWidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PresetsListWidgetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PresetsListWidgetModule, declarations: [PresetsListWidgetComponent], imports: [CommonModule, AdaptRxListBuilderModule, FormsModule], exports: [PresetsListWidgetComponent] });
PresetsListWidgetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PresetsListWidgetModule, imports: [[CommonModule, AdaptRxListBuilderModule, FormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: PresetsListWidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [PresetsListWidgetComponent],
                    exports: [PresetsListWidgetComponent],
                    imports: [CommonModule, AdaptRxListBuilderModule, FormsModule]
                }]
        }] });

class ViewPresetSelectorDesignModule {
}
ViewPresetSelectorDesignModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorDesignModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ViewPresetSelectorDesignModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorDesignModule, declarations: [ViewPresetSelectorDesignComponent], imports: [CommonModule, PresetsListWidgetModule, AdaptButtonModule] });
ViewPresetSelectorDesignModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorDesignModule, imports: [[CommonModule, PresetsListWidgetModule, AdaptButtonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorDesignModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, PresetsListWidgetModule, AdaptButtonModule],
                    declarations: [ViewPresetSelectorDesignComponent],
                    entryComponents: [ViewPresetSelectorDesignComponent]
                }]
        }] });

class ViewPresetSelectorRegistrationModule {
    constructor(rxViewComponentRegistryService, componentFactoryResolver) {
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        this.componentFactoryResolver = componentFactoryResolver;
        rxViewComponentRegistryService.register({
            type: RxViewComponentType.ViewPresetSelector,
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(ViewPresetSelectorComponent),
            properties: [
                {
                    name: 'styles'
                },
                {
                    name: 'enableSharing',
                    type: ViewComponentPropertyType.Boolean,
                    designType: ViewComponentPropertyType.Boolean
                },
                RX_AVAILABLE_ON_DEVICES_PROP_DESC
            ],
            isContainerComponent: true,
            name: 'View preset selector',
            group: RX_VIEW_DESIGNER.stencilGroups.basicComponents.label,
            icon: 'screens_triangle_down_circle',
            designComponentFactory: this.componentFactoryResolver.resolveComponentFactory(ViewPresetSelectorDesignComponent),
            designComponentModel: ViewPresetSelectorDesignModel,
            bundleId: RX_APPLICATION.platformBundleId
        }, {
            type: RxViewComponentType.ViewPreset,
            configPropertyName: 'viewPresets',
            isDataComponent: true,
            properties: [
                {
                    name: 'label',
                    localizable: true
                },
                {
                    name: 'index',
                    designType: ViewComponentPropertyType.Number,
                    type: ViewComponentPropertyType.Number
                }
            ]
        });
    }
}
ViewPresetSelectorRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorRegistrationModule, deps: [{ token: i1$4.RxViewComponentRegistryService }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.NgModule });
ViewPresetSelectorRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorRegistrationModule, imports: [ViewPresetSelectorDesignModule, ViewPresetSelectorModule] });
ViewPresetSelectorRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorRegistrationModule, imports: [[ViewPresetSelectorDesignModule, ViewPresetSelectorModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewPresetSelectorRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ViewPresetSelectorDesignModule, ViewPresetSelectorModule]
                }]
        }], ctorParameters: function () { return [{ type: i1$4.RxViewComponentRegistryService }, { type: i0.ComponentFactoryResolver }]; } });

class GainsightAdminOptInComponent extends BaseViewComponent {
    constructor(translateService, rxNotificationService, rxGainsightConfiguratorService) {
        super();
        this.translateService = translateService;
        this.rxNotificationService = rxNotificationService;
        this.rxGainsightConfiguratorService = rxGainsightConfiguratorService;
        this.deploymentTypeOptions = RX_GAINSIGHT.deploymentTypes;
        this.environmentTypeOptions = RX_GAINSIGHT.environmentTypes;
        this.vm$ = this.rxGainsightConfiguratorService.getGainsightConfiguration(RX_APPLICATION.innovationStudioBundleId).pipe(take(1), filter((config) => Boolean(config)), map((config) => config.settings), map((settings) => ({
            deploymentTypeOptions: this.deploymentTypeOptions.filter((deploymentType) => deploymentType.name === settings.deploymentType),
            environmentTypeOptions: [settings.environmentType],
            useAdaptRadar: settings.useAdaptRadar,
            loadGainsightFromBmcIt: settings.loadGainsightFromBmcIt,
            adaptAgreementState: {
                organizationPerformance: settings.enableGainsight,
                accountMarketing: false,
                accountPerformance: false,
                organizationMarketing: false
            }
        })), shareReplay(1));
    }
    optionFormatter(deploymentType) {
        return deploymentType.name;
    }
    save() {
        this.vm$
            .pipe(take(1), map((vm) => (Object.assign(Object.assign({}, vm), { deploymentType: vm.deploymentTypeOptions[0].id, environmentType: vm.environmentTypeOptions[0], enableGainsight: vm.adaptAgreementState.organizationPerformance }))), switchMap((gainsightSettings) => this.rxGainsightConfiguratorService.saveGainsightConfiguration(gainsightSettings)))
            .subscribe(() => {
            this.rxNotificationService.addSuccessMessage(this.translateService.instant('com.bmc.arsys.rx.client.gainsight.gainsight-settings-saved.success.message'));
        });
    }
}
GainsightAdminOptInComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: GainsightAdminOptInComponent, deps: [{ token: i2.TranslateService }, { token: i1$1.RxNotificationService }, { token: i2$5.RxGainsightConfiguratorService }], target: i0.ɵɵFactoryTarget.Component });
GainsightAdminOptInComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.3", type: GainsightAdminOptInComponent, selector: "rx-gainsight-admin-opt-in", usesInheritance: true, ngImport: i0, template: "<ng-container class=\"p-0\" *ngIf=\"vm$ | async as vm; else emptyStateTemplate\">\n  <div class=\"mt-1 container\">\n    <h1>\n      <span class=\"text-logo\">{{ 'com.bmc.arsys.rx.client.gainsight.gainsight-settings.title' | translate }}</span>\n    </h1>\n\n    <div>\n      <adapt-agreement-card\n        [showOrganizationSettings]=\"true\"\n        [showMarketingSection]=\"false\"\n        [multiProductUsage]=\"false\"\n        [showShadow]=\"false\"\n        rx-id=\"enable-gainsight\"\n        [(state)]=\"vm.adaptAgreementState\"\n      >\n      </adapt-agreement-card>\n    </div>\n\n    <div class=\"pt-4 pl-0 col-md-4\" [hidden]=\"true\">\n      <adapt-rx-switch\n        [isLabelBefore]=\"true\"\n        [size]=\"'lg'\"\n        label=\"Use ADAPT Radar\"\n        [(ngModel)]=\"vm.useAdaptRadar\"\n        name=\"useAdaptRadar\"\n        rx-id=\"use-adapt-radar\"\n      ></adapt-rx-switch>\n    </div>\n\n    <div class=\"pt-4 pl-0 col-md-4\">\n      <adapt-rx-switch\n        [isLabelBefore]=\"true\"\n        [size]=\"'lg'\"\n        label=\"{{\n          'com.bmc.arsys.rx.client.gainsight.gainsight-settings.load-gainsight-script-from-bmc-it.label' | translate\n        }}\"\n        [(ngModel)]=\"vm.loadGainsightFromBmcIt\"\n        name=\"loadGainsightFromBmcIt\"\n        rx-id=\"load-gainsight-from-bmc\"\n      ></adapt-rx-switch>\n    </div>\n\n    <adapt-rx-select\n      class=\"col-md-3 pt-4 pl-0\"\n      label=\"{{ 'com.bmc.arsys.rx.client.gainsight.gainsight-settings.deployment-type.label' | translate }}\"\n      [options]=\"deploymentTypeOptions\"\n      [optionFormatter]=\"optionFormatter\"\n      [(ngModel)]=\"vm.deploymentTypeOptions\"\n      name=\"deploymentType\"\n      rx-id=\"deployment-type\"\n    >\n    </adapt-rx-select>\n\n    <adapt-rx-select\n      class=\"col-md-3 pt-4 pl-0\"\n      label=\"{{ 'com.bmc.arsys.rx.client.gainsight.gainsight-settings.environment-type.label' | translate }}\"\n      [options]=\"environmentTypeOptions\"\n      [(ngModel)]=\"vm.environmentTypeOptions\"\n      name=\"environmentType\"\n      rx-id=\"environment-type\"\n    >\n    </adapt-rx-select>\n\n    <div class=\"modal-footer mt-4\">\n      <button rx-id=\"save-button\" adapt-button btn-type=\"primary\" type=\"button\" (click)=\"save()\" rx-id=\"save-button\">\n        {{ 'com.bmc.arsys.rx.client.common.save.label' | translate }}\n      </button>\n    </div>\n  </div>\n</ng-container>\n\n<ng-template #emptyStateTemplate>\n  <div class=\"d-flex align-items-center justify-content-center h-100\">\n    <adapt-empty-state\n      class=\"w-100\"\n      label=\"{{ 'com.bmc.arsys.rx.client.gainsight.feature-is-disabled.label' | translate }}\"\n      type=\"config\"\n    ></adapt-empty-state>\n  </div>\n</ng-template>\n", styles: [":host ::ng-deep adapt-agreement-card adapt-agreement-admin-content div:nth-of-type(2)>adapt-rx-switch,:host ::ng-deep adapt-agreement-card adapt-agreement-admin-content hr:nth-of-type(2)~div,:host ::ng-deep adapt-agreement-card adapt-agreement-admin-content h4,:host ::ng-deep adapt-agreement-card adapt-agreement-admin-content hr:nth-of-type(3){display:none}\n"], components: [{ type: i1.AdaptAgreementCardComponent, selector: "adapt-agreement-card", inputs: ["multiProductUsage", "state", "showOrganizationSettings", "showMarketingSection", "showShadow"], outputs: ["stateChange"] }, { type: i1.AdaptRxSwitchComponent, selector: "adapt-rx-switch", inputs: ["value", "size", "isLabelBefore", "checked"] }, { type: i1.AdaptRxSelectComponent, selector: "adapt-rx-select", inputs: ["options", "emptyOption", "optionFormatter", "optionContentTemplate", "disabledOptionResolver", "titleFormatter", "focusFirst", "texts", "multiple", "singleSelectStyle", "enableFilter", "inline", "selectAllButton", "deselectAllButton", "loadMoreButton", "loadMoreCallback", "loadMoreInProgress", "loadingState", "placeholder", "size", "closeOnSelect", "placement", "appendToBody", "popupMaxHeight", "popupClass", "pageSize", "ariaInvalid", "virtualScroll", "virtualScrollItemSize", "virtualScrollTemplateCacheSize", "minBufferPx", "maxBufferPx"], outputs: ["onSelectionChange", "onPopupOpenChange", "onFilterValueChange"] }, { type: i1.AdaptButtonComponent, selector: "adapt-button, button[adapt-button], a[adapt-button]", inputs: ["btn-type", "size", "disabled", "type", "tabIndex"], exportAs: ["adaptBtn"] }, { type: i1.AdaptEmptyStateComponent, selector: "adapt-empty-state", inputs: ["label", "type", "inverted"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2$3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2$3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "async": i3.AsyncPipe, "translate": i2.TranslatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: GainsightAdminOptInComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rx-gainsight-admin-opt-in',
                    templateUrl: './gainsight-admin-opt-in.component.html',
                    styleUrls: ['./gainsight-admin-opt-in.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: i2.TranslateService }, { type: i1$1.RxNotificationService }, { type: i2$5.RxGainsightConfiguratorService }]; } });

class GainsightAdminOptInRegistrationModule {
    constructor(componentFactoryResolver, rxViewComponentRegistryService) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rxViewComponentRegistryService = rxViewComponentRegistryService;
        rxViewComponentRegistryService.register({
            type: 'rx-gainsight-admin-opt-in',
            componentFactory: this.componentFactoryResolver.resolveComponentFactory(GainsightAdminOptInComponent),
            name: 'Gainsight Admin Opt In',
            hidden: true,
            availableInBundles: [RX_APPLICATION.settingsBundleId]
        });
    }
}
GainsightAdminOptInRegistrationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: GainsightAdminOptInRegistrationModule, deps: [{ token: i0.ComponentFactoryResolver }, { token: i1$4.RxViewComponentRegistryService }], target: i0.ɵɵFactoryTarget.NgModule });
GainsightAdminOptInRegistrationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: GainsightAdminOptInRegistrationModule, declarations: [GainsightAdminOptInComponent], imports: [TranslateModule,
        AdaptAgreementModule,
        AdaptRxSelectModule,
        FormsModule,
        AdaptRxSwitchModule,
        CommonModule,
        AdaptButtonModule,
        AdaptEmptyStateModule] });
GainsightAdminOptInRegistrationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: GainsightAdminOptInRegistrationModule, imports: [[
            TranslateModule,
            AdaptAgreementModule,
            AdaptRxSelectModule,
            FormsModule,
            AdaptRxSwitchModule,
            CommonModule,
            AdaptButtonModule,
            AdaptEmptyStateModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: GainsightAdminOptInRegistrationModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [GainsightAdminOptInComponent],
                    imports: [
                        TranslateModule,
                        AdaptAgreementModule,
                        AdaptRxSelectModule,
                        FormsModule,
                        AdaptRxSwitchModule,
                        CommonModule,
                        AdaptButtonModule,
                        AdaptEmptyStateModule
                    ],
                    entryComponents: [GainsightAdminOptInComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i1$4.RxViewComponentRegistryService }]; } });

class ViewComponentsModule {
}
ViewComponentsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewComponentsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ViewComponentsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewComponentsModule, imports: [ActionButtonRegistrationModule,
        ButtonBarRegistrationModule,
        ChatbotUserMappingRegistrationModule,
        ContainerRegistrationModule,
        RecordEditorRegistrationModule,
        FieldComponentsModule,
        IframeLoginEventRegistrationModule,
        RecordGridRegistrationModule,
        RichTextRegistrationModule,
        TabPanelRegistrationModule,
        PageRegistrationModule,
        ImageRegistrationModule,
        ServiceListRegistrationModule,
        SmartReportingRedirectorRegistrationModule,
        UnknownRegistrationModule,
        ViewPresetSelectorRegistrationModule,
        GainsightAdminOptInRegistrationModule] });
ViewComponentsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewComponentsModule, imports: [[
            ActionButtonRegistrationModule,
            ButtonBarRegistrationModule,
            ChatbotUserMappingRegistrationModule,
            ContainerRegistrationModule,
            RecordEditorRegistrationModule,
            FieldComponentsModule,
            IframeLoginEventRegistrationModule,
            RecordGridRegistrationModule,
            RichTextRegistrationModule,
            TabPanelRegistrationModule,
            PageRegistrationModule,
            ImageRegistrationModule,
            ServiceListRegistrationModule,
            SmartReportingRedirectorRegistrationModule,
            UnknownRegistrationModule,
            ViewPresetSelectorRegistrationModule,
            GainsightAdminOptInRegistrationModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ViewComponentsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ActionButtonRegistrationModule,
                        ButtonBarRegistrationModule,
                        ChatbotUserMappingRegistrationModule,
                        ContainerRegistrationModule,
                        RecordEditorRegistrationModule,
                        FieldComponentsModule,
                        IframeLoginEventRegistrationModule,
                        RecordGridRegistrationModule,
                        RichTextRegistrationModule,
                        TabPanelRegistrationModule,
                        PageRegistrationModule,
                        ImageRegistrationModule,
                        ServiceListRegistrationModule,
                        SmartReportingRedirectorRegistrationModule,
                        UnknownRegistrationModule,
                        ViewPresetSelectorRegistrationModule,
                        GainsightAdminOptInRegistrationModule
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ActionButtonComponent, ActionButtonDesignComponent, ActionButtonDesignModule, ActionButtonIconAlignment, ActionButtonModule, ActionButtonSize, ActionButtonStyle, AssociationDesignModule, AssociationManagerFactory, AssociationModule, AssociationRegistrationModule, AttachmentFieldComponent, AttachmentFieldDesignComponent, AttachmentFieldDesignModule, AttachmentFieldModule, AttachmentFieldRegistrationModule, BaseRecordEditorFieldComponent, BaseRecordEditorFieldDesign, BooleanFieldComponent, BooleanFieldDesignComponent, BooleanFieldDesignModule, BooleanFieldModule, BooleanFieldRegistrationModule, ButtonBarComponent, ButtonBarDesignComponent, ButtonBarDesignModel, ButtonBarDesignModule, ButtonBarModule, ChatbotUserMappingComponent, ChatbotUserMappingRegistrationModule, ColumnSortDirection, ContainerComponent, ContainerDesignComponent, ContainerDesignModule, ContainerModule, ContainerRowWrap, DateFieldComponent, DateFieldDesignComponent, DateFieldDesignModule, DateFieldModule, DateFieldRegistrationModule, DateTimeFieldComponent, DateTimeFieldDesignComponent, DateTimeFieldDesignModule, DateTimeFieldModule, DateTimeFieldRegistrationModule, DecimalFieldComponent, DecimalFieldDesignComponent, DecimalFieldDesignModule, DecimalFieldModule, DecimalFieldRegistrationModule, DeprecatedActionButtonStyle, ExtensionContainerDesignComponent, ExtensionContainerDesignModule, ExtensionContainerRegistrationModule, ExtensionContainerSectionComponent, FieldComponentsModule, GainsightAdminOptInRegistrationModule, IframeLoginEventComponent, IframeLoginEventRegistrationModule, ImageComponent, ImageDesignComponent, ImageDesignModule, ImageModule, IntegerFieldComponent, IntegerFieldDesignComponent, IntegerFieldDesignModule, IntegerFieldModule, IntegerFieldRegistrationModule, LocalizedCharacterFieldComponent, LocalizedCharacterFieldRegistrationModule, PageComponent, PageComponentDefinitionAdapterService, PageDesignComponent, PageDesignModule, PageModule, RECORD_EDITOR, RX_ASSOCIATION, RX_BASE_FIELD_PROPERTIES, RX_RECORD_GRID, RX_RECORD_GRID_DESIGN, RecordEditorComponent, RecordEditorDesignComponent, RecordEditorDesignModule, RecordEditorMode, RecordEditorModule, RecordEditorState, RecordGridColumnAlignment, RecordGridColumnEditorControlComponent, RecordGridColumnEditorModalComponent, RecordGridComponent, RecordGridDesignComponent, RecordGridDesignDefinitionMode, RecordGridDesignModule, RecordGridFilterMode, RecordGridFilterSelectControlComponent, RecordGridFilterSelectControlModule, RecordGridModule, RichTextComponent, RichTextDesignComponent, RichTextDesignModule, RichTextModule, RichTextareaFieldComponent, RichTextareaFieldDesignComponent, RichTextareaFieldDesignModule, RichTextareaFieldModule, RichTextareaFieldRegistrationModule, RowSelectionMode, RxAssociationComponent, RxAssociationDesignComponent, RxAssociationEditingMode, RxAssociationManagerService, RxDefaultRecordEditorInputType, RxExtensionContainerComponent, RxExtensionContainerModule, RxLocalizedCharacterFieldModule, RxRecordEditorUtilsService, RxRecordGridAdvancedFilterValue, RxRecordGridAdvancedFilteringService, RxRecordGridDesignUtilsService, RxRecordGridFilterHelperService, RxRecordGridFilterSelectHelperService, RxRecordGridFilterService, RxRecordGridQueryExpressionEvaluatorService, RxRecordGridUtilsService, RxTabContainerComponent, RxTabPanelComponent, RxTabPanelModule, SelectGroupComponent, SelectGroupComponentDefinitionAdapterService, SelectGroupDesignComponent, SelectGroupDesignModel, SelectGroupFieldComponent$1 as SelectGroupFieldComponent, SelectGroupModule, SelectGroupRegistrationModule, SelectionFieldComponent, SelectionFieldDesignComponent, SelectionFieldDesignModule, SelectionFieldModule, SelectionFieldRegistrationModule, ServiceListComponent, ServiceListDesignComponent, ServiceListDesignModule, ServiceListModule, TabPanelDesignModule, TextFieldComponent, TextFieldDesignComponent, TextFieldDesignModule, TextFieldExpressionConfigurator, TextFieldModule, TextFieldMultiSelectionType, TextFieldRegistrationModule, TextareaFieldComponent, TextareaFieldDesignComponent, TextareaFieldDesignModule, TextareaFieldModule, TextareaFieldRegistrationModule, TimeFieldComponent, TimeFieldDesignComponent, TimeFieldDesignModule, TimeFieldModule, TimeFieldRegistrationModule, UploaderFactory, ViewComponentsModule };
//# sourceMappingURL=helix-platform-view-components.js.map
