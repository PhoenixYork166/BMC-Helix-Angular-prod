{"version":3,"file":"view-expression-validator.service.js","sourceRoot":"","sources":["../../../../../../../libs/platform/view/designer/validation/view-expression-validator.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport {\n  IExpressionEvaluator,\n  RxDefaultExpressionEvaluatorService,\n  RxDefaultExpressionValidatorService\n} from '@helix/platform/view/api';\nimport { RxStringService } from '@helix/platform/utils';\nimport { Observable, of } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { isEqual } from 'lodash';\nimport { ExpressionParserToken, RxExpressionParserService } from '@helix/platform/shared/api';\nimport { IViewComponentDesignValidationIssue } from '../public-interfaces/view-component-design-validation-issue.interface';\nimport { ViewDesignerFacade } from '../+state/view-designer.facade';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RxViewExpressionValidatorService {\n  constructor(\n    private rxDefaultExpressionValidatorService: RxDefaultExpressionValidatorService,\n    private rxDefaultExpressionEvaluatorService: RxDefaultExpressionEvaluatorService,\n    private rxStringService: RxStringService,\n    private rxExpressionParserService: RxExpressionParserService,\n    private viewDesignerFacade: ViewDesignerFacade\n  ) {}\n\n  validate(\n    expression: string,\n    propertyName: string,\n    propertyLabel = this.rxStringService.prettify(propertyName),\n    expressionEvaluator: IExpressionEvaluator = this.rxDefaultExpressionEvaluatorService\n  ): Observable<IViewComponentDesignValidationIssue[]> {\n    let issues$ = of([]);\n\n    if (this.rxDefaultExpressionValidatorService.isValid(expression, expressionEvaluator)) {\n      if (this.rxStringService.isNonEmptyString(expression)) {\n        const referencedComponentGuidsSet = new Set<string>();\n\n        this.rxExpressionParserService.parse(expression, (token, expressionFragment) => {\n          if (token === ExpressionParserToken.RxExpression || token === ExpressionParserToken.SingleQuoteRxExpression) {\n            // Extract <ID> from ${view.components.<ID>.<Path>}\n            const result = /\\${view\\.components\\.([0-9a-z-]+)\\..+}/.exec(expressionFragment);\n\n            if (result && result[1]) {\n              referencedComponentGuidsSet.add(result[1]);\n            }\n          }\n\n          return expressionFragment;\n        });\n\n        if (referencedComponentGuidsSet.size) {\n          const referencedComponentGuids = Array.from(referencedComponentGuidsSet);\n\n          issues$ = this.viewDesignerFacade.allComponentGuids$.pipe(\n            map((guids) => referencedComponentGuids.filter((guid) => !guids.has(guid))),\n            distinctUntilChanged(isEqual),\n            map((guids) =>\n              guids.map(() => ({\n                type: 'error',\n                description: 'Expression references a non-existent view component.',\n                propertyName\n              }))\n            )\n          );\n        }\n      }\n    } else {\n      issues$ = of([\n        {\n          type: 'error',\n          description: `${propertyLabel} must be a valid expression.`,\n          propertyName\n        }\n      ]);\n    }\n\n    return issues$;\n  }\n}\n"]}