{"version":3,"file":"expression-parser.service.js","sourceRoot":"","sources":["../../../../../../../libs/platform/shared/api/expression-parser/expression-parser.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { ExpressionParserToken, IReplaceExpressionValueFunc } from './expression-parser.types';\nimport { forEach, isNil } from 'lodash';\nimport { IExpressionOperator } from '../expression-configurator';\n\ninterface IExtractExpressionsResult {\n  expression: string;\n  expressionValues: IterableIterator<string>;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RxExpressionParserService {\n  private readonly tokenRegExpMap = new Map<ExpressionParserToken, RegExp>([\n    [ExpressionParserToken.SingleQuoteRxExpression, /('\\${[^{}$]+}')/g],\n    [ExpressionParserToken.SingleQuoteTextExpression, /('[^$']+')/g],\n    [ExpressionParserToken.ArExpression, /(\\$[A-Z]+\\$)|(\\$\\\\[A-Z]+\\$)/g],\n    [ExpressionParserToken.RxExpression, /(\\${[^{}$]+})/g],\n    [ExpressionParserToken.RxStringExpression, /(\"[^\"]+\")|('[^']+')/g]\n  ]);\n\n  parse(expression: string, replaceFunc: IReplaceExpressionValueFunc, operators: IExpressionOperator[] = []): string {\n    if (operators.length) {\n      const pattern = operators\n        // Sort operators in descending order by length to find a compound operator in an expression.\n        // e.g. \"${foo} >= ${bar}\" has \">=\" operator instead of \">\" and \"=\" separately.\n        .sort((prevOperator, operator) => operator.value.length - prevOperator.value.length)\n        .map((operator) => `\\\\${operator.value.split('').join('\\\\')}`)\n        .join('|');\n\n      this.tokenRegExpMap.set(ExpressionParserToken.RxOperator, new RegExp(pattern, 'g'));\n    }\n\n    const expressionValuesMap = new Map<ExpressionParserToken, IExtractExpressionsResult['expressionValues']>();\n\n    for (const [token] of this.tokenRegExpMap) {\n      let expressionValues;\n\n      ({ expression, expressionValues } = this.extractExpressionValues(\n        expression,\n        token,\n        this.tokenRegExpMap.get(token)\n      ));\n\n      if (expressionValues) {\n        expressionValuesMap.set(token, expressionValues);\n      }\n    }\n\n    return Array.from(expressionValuesMap.keys())\n      .reverse()\n      .reduce(\n        (result, token) =>\n          result.replace(new RegExp(token, 'g'), () => replaceFunc(token, expressionValuesMap.get(token).next().value)),\n        expression\n      );\n  }\n\n  // Replaces all spaces with a single space except user inputs\n  // ${view.foo} =   \"bar\" -> ${view.foo} = \"bar\"\n  // ${view.foo} =   \"    bar\" -> ${view.foo} = \"    bar\"\n  stripSpaces(expression: string): string {\n    let result = expression;\n\n    if (!isNil(expression)) {\n      const token = ExpressionParserToken.RxStringExpression;\n      const extractExpressionsResult = this.extractExpressionValues(expression, token, this.tokenRegExpMap.get(token));\n\n      result = extractExpressionsResult.expression\n        .replace(/\\s+/g, ' ')\n        .replace(\n          new RegExp(ExpressionParserToken.RxStringExpression, 'g'),\n          () => extractExpressionsResult.expressionValues.next().value\n        );\n    }\n\n    return result;\n  }\n\n  private extractExpressionValues(\n    expression: string,\n    token: ExpressionParserToken,\n    regExp: RegExp\n  ): IExtractExpressionsResult {\n    const expressionValues = expression.match(regExp);\n\n    forEach(expressionValues, (value) => (expression = expression.replace(value, token)));\n\n    return {\n      expression,\n      expressionValues: expressionValues && expressionValues.values()\n    };\n  }\n}\n"]}