{"version":3,"file":"record-query-expression-evaluator.service.js","sourceRoot":"","sources":["../../../../../../../libs/platform/view/api/expressions/record-query-expression-evaluator.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { isEmpty, isNil, isNull, isString, isUndefined, map, reduce, result } from 'lodash';\nimport { RxStringService } from '@helix/platform/utils';\nimport { RxRecordInstanceUtilsService } from '@helix/platform/record/api';\nimport { ExpressionParserToken } from '@helix/platform/shared/api';\nimport { IExpressionEvaluator, RX_EXPRESSION_EVALUATOR } from './expression-evaluator.types';\nimport { RxDefaultExpressionEvaluatorService } from './default-expression-evaluator.service';\nimport { RxExpressionHelperService } from './expression-helper.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RxRecordQueryExpressionEvaluatorService implements IExpressionEvaluator {\n  private viewRegExp = /\\${(view.+?)}/g;\n\n  // extract strings surrounded by double quotes,\n  // extracted strings will include escaped double quotes characters (\"\")\n  private stringMatchingRegExp = /\"((?:(?:\"\")*|(?:[^\"])*)*)\"/g;\n\n  private rxStringsExpressionData;\n  private rxExpressionsData;\n  private arRecordAssociationFilterExpressionData;\n\n  // extract strings with associated field id surrounded by quotes\n  private associationExpressionRegExp = new RegExp(\n    \"(')(\\\\$\\\\{\" + RX_EXPRESSION_EVALUATOR.associatedFieldIdPrefixPattern + \"\\\\d+\\\\})(')\",\n    'g'\n  );\n\n  private rxOperatorCounter: number;\n  private rxViewExpressionCounter: number;\n  private rxStringExpressionCounter: number;\n  private rxAssociationFilterExpressionCounter: number;\n\n  constructor(\n    private rxDefaultExpressionEvaluatorService: RxDefaultExpressionEvaluatorService,\n    private rxExpressionHelper: RxExpressionHelperService,\n    private rxStringService: RxStringService,\n    private rxRecordInstanceUtilsService: RxRecordInstanceUtilsService\n  ) {}\n\n  evaluate(expression: string, data: object): string {\n    this.rxOperatorCounter = 0;\n    this.rxViewExpressionCounter = 0;\n    this.rxStringExpressionCounter = 0;\n    this.rxAssociationFilterExpressionCounter = 0;\n\n    let evaluatedExpression = null;\n\n    if (!this.rxStringService.isEmptySafe(expression)) {\n      // Replace strings in double quotes with RX_STRING_EXPRESSION token, e.g.\n      // \"text ${view.foo}\" = ${view.bar}\"text \"\"text in quotes\"\" text\" ->\n      // RX_EXPRESSION_STRING = ${view.bar}RX_EXPRESSION_STRING\n      this.rxStringsExpressionData = this.rxExpressionHelper.extractTokens(\n        this.stringMatchingRegExp,\n        ExpressionParserToken.RxStringExpression,\n        expression\n      );\n\n      // Replace RX association filter expressions with RX_ASSOCIATION_FILTER_EXPRESSION token, e.g.\n      // '7' = '${recordContext._associations...}' -> '7' = RX_ASSOCIATION_FILTER_EXPRESSION\n      this.arRecordAssociationFilterExpressionData = this.rxExpressionHelper.extractTokens(\n        this.associationExpressionRegExp,\n        'RX_ASSOCIATION_FILTER_EXPRESSION',\n        this.rxStringsExpressionData.expression\n      );\n\n      // Replace RX view expressions with RX_VIEW_EXPRESSION token, e.g\n      // ${view.foo} = ${view.bar} -> RX_VIEW_EXPRESSION = RX_VIEW_EXPRESSION\n      this.rxExpressionsData = this.rxExpressionHelper.extractTokens(\n        this.viewRegExp,\n        'RX_VIEW_EXPRESSION',\n        this.arRecordAssociationFilterExpressionData.expression\n      );\n\n      // Prepare operators, e.g\n      // RX_VIEW_EXPRESSION = NOTRX_VIEW_EXPRESSION -> RX_VIEW_EXPRESSION = !RX_VIEW_EXPRESSION\n      this.rxExpressionHelper.prepareOperators(this.rxExpressionsData.expression);\n\n      const rxOperatorsData = this.rxExpressionHelper.extractTokens(\n        /(\\s+(AND|OR)\\s+)|(\\s*(\\(|\\))\\s*)/g,\n        ExpressionParserToken.RxOperator,\n        this.rxExpressionsData.expression\n      );\n\n      evaluatedExpression = map(rxOperatorsData.expression.split(ExpressionParserToken.RxOperator), (operand) => {\n        const likeExpressionMatch = /(.*)\\s+LIKE\\s+(.*)/g.exec(operand);\n\n        // does operand use the LIKE operator?\n        if (likeExpressionMatch) {\n          const leftOperandValue = this.evaluateOperand(likeExpressionMatch[1], data),\n            rightOperandValue = `\"${this.evaluateOperand(likeExpressionMatch[2], data, true)}\"`;\n\n          return `${leftOperandValue} LIKE ${rightOperandValue}`;\n        } else {\n          return this.evaluateOperand(operand, data);\n        }\n      })\n        .join(ExpressionParserToken.RxOperator)\n        .replace(\n          new RegExp(`${ExpressionParserToken.RxOperator}`, 'g'),\n          () => rxOperatorsData.matches[this.rxOperatorCounter++]\n        );\n    }\n\n    return evaluatedExpression;\n  }\n\n  // Evaluate operand by replacing expression tokens with evaluated values.\n  // e.g\n  // RX_EXPRESSION = RX_EXPRESSION_STRING ->\n  // \"${view.foo}\" = \"text ${view.bar}\" ->\n  // \"Foo\" LIKE \"text Bar\"\n  // or\n  // RX_ASSOCIATION_FILTER_EXPRESSION LIKE %RX_STRING_EXPRESSION% ->\n  // '${recordContext.associations...}' LIKE %\"some ${view.textFieldValue}\"% ->\n  // ${recordContext.associations...} LIKE \"%some text \"\" with \\% escaped \\_ wildcards%\"\n  private evaluateOperand(operand: string, data: object, isLikeOperand: boolean = false): string {\n    return reduce(\n      [\n        this.evaluateRxViewExpressions.bind(this),\n        this.evaluateRxStringExpressions.bind(this),\n        this.prepareRxAssociationFilterExpressions.bind(this)\n      ],\n      (expression, evaluator) => evaluator(expression, data, isLikeOperand),\n      operand\n    );\n  }\n\n  private evaluateRxViewExpressions(operand: string, data: object, isLikeOperand: boolean = false): string {\n    return operand.replace(/RX_VIEW_EXPRESSION/g, () => {\n      return this.rxExpressionsData.matches[this.rxViewExpressionCounter++].replace(\n        this.viewRegExp,\n        (match, submatch) => {\n          let value = result(data, submatch);\n\n          if (isUndefined(value)) {\n            return RX_EXPRESSION_EVALUATOR.operands.undefined;\n          } else if (isNull(value) || value === '') {\n            return isLikeOperand ? '' : RX_EXPRESSION_EVALUATOR.operands.null;\n          } else if (isString(value)) {\n            value = isLikeOperand\n              ? this.rxRecordInstanceUtilsService.escapeTextWildcards(value)\n              : value.replace(/\"/g, '\"\"');\n          }\n\n          return isLikeOperand ? value : `\"${value}\"`;\n        }\n      );\n    });\n  }\n\n  private evaluateRxStringExpressions(operand: string, data: object, isLikeOperand: boolean = false): string {\n    return operand.replace(new RegExp(`${ExpressionParserToken.RxStringExpression}`, 'g'), () => {\n      let stringExpression = this.rxStringsExpressionData.matches[this.rxStringExpressionCounter++];\n\n      if (isLikeOperand) {\n        stringExpression = stringExpression.replace(this.stringMatchingRegExp, '$1');\n      }\n\n      stringExpression = stringExpression.replace(this.viewRegExp, (match, submatch) => {\n        const value = result(data, submatch);\n\n        if (isNil(value)) {\n          return '';\n        } else if (isLikeOperand && isString(value)) {\n          return this.rxRecordInstanceUtilsService.escapeTextWildcards(value);\n        }\n\n        return value;\n      });\n\n      if (isEmpty(stringExpression) && !isLikeOperand) {\n        stringExpression = RX_EXPRESSION_EVALUATOR.operands.null;\n      }\n\n      return stringExpression;\n    });\n  }\n\n  private prepareRxAssociationFilterExpressions(operand: string): string {\n    return operand.replace(/RX_ASSOCIATION_FILTER_EXPRESSION/g, () =>\n      this.arRecordAssociationFilterExpressionData.matches[this.rxAssociationFilterExpressionCounter++].replace(\n        this.associationExpressionRegExp,\n        (match, firstQuote, associationExpression, lastQuote) => associationExpression\n      )\n    );\n  }\n}\n"]}