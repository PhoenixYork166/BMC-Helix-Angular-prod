{"version":3,"file":"expression-helper.service.js","sourceRoot":"","sources":["../../../../../../../libs/platform/view/api/expressions/expression-helper.service.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C,OAAO,EAAE,YAAY,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AACzD,OAAO,EAAE,kBAAkB,EAAE,MAAM,4BAA4B,CAAC;;AAUhE,MAAM,OAAO,yBAAyB;IAGpC;QAFA,oBAAe,GAA0C,EAAE,CAAC;QAG1D,SAAS,YAAY,CAAC,UAAkB;YACtC,OAAO,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC5C,CAAC;QAED,SAAS,WAAW,CAAC,UAAkB;YACrC,OAAO,UAAU,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;QAC1C,CAAC;QAED,SAAS,UAAU,CAAC,UAAkB;YACpC,OAAO,UAAU,CAAC,OAAO,CAAC,MAAM,EAAE,kBAAkB,CAAC,EAAE,CAAC,CAAC;QAC3D,CAAC;QAED,SAAS,WAAW,CAAC,UAAkB;YACrC,OAAO,UAAU,CAAC,OAAO,CAAC,OAAO,EAAE,kBAAkB,CAAC,GAAG,CAAC,CAAC;QAC7D,CAAC;QAED,SAAS,YAAY,CAAC,UAAkB;YACtC,OAAO,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAC/D,CAAC;QAED,SAAS,gBAAgB,CAAC,UAAU;YAClC,OAAO,UAAU,CAAC,OAAO,CAAC,YAAY,EAAE,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,YAAY,EAAE,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,YAAY,EAAE,gBAAgB,CAAC,CAAC;IAChH,CAAC;IAED,aAAa,CAAC,KAAa,EAAE,GAAW,EAAE,UAAkB;QAC1D,MAAM,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAExC,OAAO;YACL,OAAO;YACP,UAAU,EAAE,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;SAC3C,CAAC;IACJ,CAAC;IAED,YAAY,CAAC,OAAgC,EAAE,GAAW,EAAE,UAAkB;QAC5E,IAAI,OAAO,KAAK,IAAI,EAAE;YACpB,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBACxB,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YAC9C,CAAC,CAAC,CAAC;SACJ;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,OAAO,CAAC,UAAkB;QACxB,8EAA8E;QAC9E,MAAM,mBAAmB,GAAG,UAAU,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;QAE/F,MAAM,qBAAqB,GAAG,IAAI,CAAC,aAAa,CAC9C,oDAAoD,EACpD,sBAAsB,EACtB,mBAAmB,CACpB,CAAC;QAEF,qBAAqB,CAAC,OAAO,GAAG,GAAG,CAAC,qBAAqB,CAAC,OAAO,EAAE,IAAI,CAAC,wBAAwB,CAAC,CAAC;QAElG,MAAM,eAAe,GAAG,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,eAAe,EAAE,qBAAqB,CAAC,UAAU,CAAC,CAAC;QAE5G,IAAI,kBAAkB,GAAG,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;QAE3E,kBAAkB,GAAG,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,OAAO,EAAE,eAAe,EAAE,kBAAkB,CAAC,CAAC;QAE1G,OAAO,IAAI,CAAC,YAAY,CAAC,qBAAqB,CAAC,OAAO,EAAE,sBAAsB,EAAE,kBAAkB,CAAC,CAAC;IACtG,CAAC;IAED,gBAAgB,CAAC,UAAkB;QACjC,OAAO,MAAM,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,UAAU,CAAC,CAAC;IACxF,CAAC;IAEO,wBAAwB,CAAC,UAAkB;QACjD,MAAM,kBAAkB,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC;QAEjE,kBAAkB,CAAC,OAAO,CAAC,CAAC,iBAAiB,EAAE,EAAE;YAC/C,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,YAAY,CAAC,iBAAiB,CAAC,EAAE,GAAG,CAAC,CAAC;YAEhE,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,iBAAiB,EAAE,CAAC,CAAC;QACrE,CAAC,CAAC,CAAC;QAEH,OAAO,UAAU,CAAC;IACpB,CAAC;IAEO,iBAAiB,CAAC,OAAyB,EAAE,GAAW,EAAE,UAAkB;QAClF,IAAI,OAAO,KAAK,IAAI,EAAE;YACpB,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBACxB,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,GAAG,EAAE,OAAO,KAAK,GAAG,CAAC,CAAC;YACxD,CAAC,CAAC,CAAC;SACJ;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;;sHA/FU,yBAAyB;0HAAzB,yBAAyB,cAFxB,MAAM;2FAEP,yBAAyB;kBAHrC,UAAU;mBAAC;oBACV,UAAU,EAAE,MAAM;iBACnB","sourcesContent":["import { Injectable } from '@angular/core';\nimport { escapeRegExp, map, reduce, uniq } from 'lodash';\nimport { ExpressionOperator } from '@helix/platform/shared/api';\n\nexport interface IExtractedTokens {\n  matches: RegExpMatchArray;\n  expression: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RxExpressionHelperService {\n  prepareHandlers: Array<(expression: string) => string> = [];\n\n  constructor() {\n    function _convertNull(expression: string): string {\n      return expression.replace(/null/gi, null);\n    }\n\n    function _convertNot(expression: string): string {\n      return expression.replace(/not/gi, '!');\n    }\n\n    function _convertOr(expression: string): string {\n      return expression.replace(/or/gi, ExpressionOperator.Or);\n    }\n\n    function _convertAnd(expression: string): string {\n      return expression.replace(/and/gi, ExpressionOperator.And);\n    }\n\n    function _convertLike(expression: string): string {\n      return expression.replace(/like/gi, ExpressionOperator.Like);\n    }\n\n    function _convertContains(expression) {\n      return expression.replace(/contains/gi, ExpressionOperator.Contains);\n    }\n\n    this.prepareHandlers.push(_convertNull, _convertNot, _convertAnd, _convertOr, _convertLike, _convertContains);\n  }\n\n  extractTokens(regex: RegExp, key: string, expression: string): IExtractedTokens {\n    const matches = expression.match(regex);\n\n    return {\n      matches,\n      expression: expression.replace(regex, key)\n    };\n  }\n\n  insertTokens(matches: RegExpMatchArray | null, key: string, expression: string): string {\n    if (matches !== null) {\n      matches.forEach((value) => {\n        expression = expression.replace(key, value);\n      });\n    }\n\n    return expression;\n  }\n\n  prepare(expression: string): string {\n    // replace all spaces with charCode 160 to 32 charCode which supported by jsep\n    const convertedExpression = expression.replace(new RegExp(String.fromCharCode(160), 'g'), ' ');\n\n    const stringExpressionsData = this.extractTokens(\n      /'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'|\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"/g,\n      'RX_STRING_EXPRESSION',\n      convertedExpression\n    );\n\n    stringExpressionsData.matches = map(stringExpressionsData.matches, this.insertLiteralExpressions);\n\n    const expressionsData = this.extractTokens(/\\${[^}]+}/g, 'RX_EXPRESSION', stringExpressionsData.expression);\n\n    let preparedExpression = this.prepareOperators(expressionsData.expression);\n\n    preparedExpression = this.insertExpressions(expressionsData.matches, 'RX_EXPRESSION', preparedExpression);\n\n    return this.insertTokens(stringExpressionsData.matches, 'RX_STRING_EXPRESSION', preparedExpression);\n  }\n\n  prepareOperators(expression: string): string {\n    return reduce(this.prepareHandlers, (result, handler) => handler(result), expression);\n  }\n\n  private insertLiteralExpressions(expression: string): string {\n    const literalExpressions = uniq(expression.match(/\\${[^}$]+}/g));\n\n    literalExpressions.forEach((literalExpression) => {\n      const regexp = new RegExp(escapeRegExp(literalExpression), 'g');\n\n      expression = expression.replace(regexp, `rx-${literalExpression}`);\n    });\n\n    return expression;\n  }\n\n  private insertExpressions(matches: RegExpMatchArray, key: string, expression: string): string {\n    if (matches !== null) {\n      matches.forEach((value) => {\n        expression = expression.replace(key, `\"rx-${value}\"`);\n      });\n    }\n\n    return expression;\n  }\n}\n"]}