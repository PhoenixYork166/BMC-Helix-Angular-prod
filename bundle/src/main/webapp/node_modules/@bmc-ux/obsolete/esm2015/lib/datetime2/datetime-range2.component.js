/* eslint-disable @typescript-eslint/no-explicit-any */
import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Injector, Input, NgZone, Output, Renderer2, ViewChild } from '@angular/core';
import { FormControl } from '@angular/forms';
import { Directionality } from '@angular/cdk/bidi';
import { BehaviorSubject, noop } from 'rxjs';
import { distinctUntilChanged, take } from 'rxjs/operators';
import { transition, trigger, useAnimation } from '@angular/animations';
import moment from 'moment-es6';
import { AdaptDeviceDetectionService, AdaptRadarAngularCustomEventName, AdaptTranslateService, ANIMATION_NAME, createFormControlValidator, createFormControlValueAccessor, formatString, FormComponent } from '@bmc-ux/adapt-angular';
import { Clock2FaceUnit } from './datetime2.model';
import { IsTimeInRange } from '../common/datetime';
import { AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/bidi";
import * as i2 from "@bmc-ux/adapt-angular";
import * as i3 from "@bmc-ux/adapt-radar";
const _c0 = ["inputControlRef"];
const _c1 = ["dropdownRef"];
const _c2 = ["calendarContainer"];
const _c3 = ["nextBtn"];
const _c4 = ["cancelBtn"];
const _c5 = ["clearBtn"];
function AdaptDatetimeRange2Component_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "input", 9, 10);
    i0.ɵɵlistener("input", function AdaptDatetimeRange2Component_div_8_Template_input_input_2_listener() { i0.ɵɵrestoreView(_r11); const _r9 = i0.ɵɵreference(3); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.inputControlWrite(_r9.value); })("focus", function AdaptDatetimeRange2Component_div_8_Template_input_focus_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.inputControlFocus(); })("blur", function AdaptDatetimeRange2Component_div_8_Template_input_blur_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.inputControlBlur(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    const _r0 = i0.ɵɵreference(2);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMap("a3t-datetime--input-control form-control " + (ctx_r1.inputControlClass || ""));
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r1.readonly && ctx_r1.disabledStyleForReadonlyState)("i-date", !ctx_r1.timePicker)("i-date-time", ctx_r1.timePicker && !ctx_r1.timeOnly)("i-time", ctx_r1.timeOnly)("readonly", ctx_r1.readonly)("a3t-datetime--input-control_active", _r0.isOpen())("a3t-datetime--input-control_invalid", ctx_r1._self.errors.length > 0 && ctx_r1._self.control.touched);
    i0.ɵɵproperty("value", ctx_r1.inputControlValue)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly);
    i0.ɵɵattribute("id", ctx_r1.id)("placeholder", ctx_r1.placeholder)("data-testid", ctx_r1.testID);
} }
function AdaptDatetimeRange2Component_ng_template_11_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetimeRange2Component_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelementStart(1, "div", 11);
    i0.ɵɵlistener("mousedown", function AdaptDatetimeRange2Component_ng_template_11_Template_div_mousedown_1_listener() { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.dropdownMouseDown(); });
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptDatetimeRange2Component_ng_template_11_ng_container_3_Template, 1, 0, "ng-container", 6);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n      ");
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    const _r4 = i0.ɵɵreference(17);
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(ctx_r2.dropdownClass || "");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r2.inline)("ngIfThen", _r4);
} }
function AdaptDatetimeRange2Component_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetimeRange2Component_ng_template_16_div_21_span_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r23 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r23.headings.applyBtn);
} }
function AdaptDatetimeRange2Component_ng_template_16_div_21_span_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r24.headings.nextBtn);
} }
function AdaptDatetimeRange2Component_ng_template_16_div_21_Template(rf, ctx) { if (rf & 1) {
    const _r26 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 18);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "div");
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "button", 19, 20);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_div_21_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r26); const ctx_r25 = i0.ɵɵnextContext(2); return ctx_r25.pickerCloseAndCancel(); });
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementStart(9, "div", 21);
    i0.ɵɵtext(10, "\n            ");
    i0.ɵɵelementStart(11, "button", 22, 23);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_div_21_Template_button_click_11_listener() { i0.ɵɵrestoreView(_r26); const ctx_r27 = i0.ɵɵnextContext(2); return ctx_r27.pickerClearAll(); });
    i0.ɵɵtext(13);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n            ");
    i0.ɵɵelementStart(15, "button", 24, 25);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_div_21_Template_button_click_15_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r28 = i0.ɵɵnextContext(2); $event.stopPropagation(); return ctx_r28.goToNextStep(); });
    i0.ɵɵtext(17, "\n              ");
    i0.ɵɵtemplate(18, AdaptDatetimeRange2Component_ng_template_16_div_21_span_18_Template, 2, 1, "span", 4);
    i0.ɵɵtext(19, "\n              ");
    i0.ɵɵtemplate(20, AdaptDatetimeRange2Component_ng_template_16_div_21_span_20_Template, 2, 1, "span", 4);
    i0.ɵɵtext(21, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r18 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("two-rows-wrap", ctx_r18.twoRowsWrap || ctx_r18.threeRowsWrap);
    i0.ɵɵadvance(4);
    i0.ɵɵattribute("data-testid", ctx_r18.testID + "_cancel");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r18.headings.cancelBtn, "");
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("three-rows-wrap", ctx_r18.threeRowsWrap);
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("data-testid", ctx_r18.testID + "_clear");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r18.headings.clearBtn, "");
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("data-testid", ctx_r18.testID + "_apply");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r18.isLastWizardStep);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r18.isLastWizardStep);
} }
function AdaptDatetimeRange2Component_ng_template_16_ng_container_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetimeRange2Component_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    const _r30 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 12, 13);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "div", 14);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementStart(6, "button", 15);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_Template_button_click_6_listener() { i0.ɵɵrestoreView(_r30); const ctx_r29 = i0.ɵɵnextContext(); return ctx_r29.switchToStartDT(); });
    i0.ɵɵtext(7);
    i0.ɵɵelementStart(8, "div");
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n          ");
    i0.ɵɵelementStart(12, "button", 15);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_Template_button_click_12_listener() { i0.ɵɵrestoreView(_r30); const ctx_r31 = i0.ɵɵnextContext(); return ctx_r31.switchToEndDT(); });
    i0.ɵɵtext(13);
    i0.ɵɵelementStart(14, "div");
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n\n        ");
    i0.ɵɵelementStart(19, "adapt-datetime2-picker", 16);
    i0.ɵɵlistener("timeModeChange", function AdaptDatetimeRange2Component_ng_template_16_Template_adapt_datetime2_picker_timeModeChange_19_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r32 = i0.ɵɵnextContext(); return ctx_r32.timeModeChange($event); })("clockFaceChange", function AdaptDatetimeRange2Component_ng_template_16_Template_adapt_datetime2_picker_clockFaceChange_19_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r33 = i0.ɵɵnextContext(); return ctx_r33.clockFaceChange($event); })("valueChange", function AdaptDatetimeRange2Component_ng_template_16_Template_adapt_datetime2_picker_valueChange_19_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r34 = i0.ɵɵnextContext(); return ctx_r34.selectDateTime($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n\n        ");
    i0.ɵɵtemplate(21, AdaptDatetimeRange2Component_ng_template_16_div_21_Template, 24, 11, "div", 17);
    i0.ɵɵtext(22, "\n\n        ");
    i0.ɵɵtemplate(23, AdaptDatetimeRange2Component_ng_template_16_ng_container_23_Template, 1, 0, "ng-container", 6);
    i0.ɵɵtext(24, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n    ");
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    const _r7 = i0.ɵɵreference(22);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("a3t-datetime-inline-light", ctx_r5.inline && ctx_r5.inlineLight)("a3t-datetime-inline-small", ctx_r5.inline && ctx_r5.inlineSize === "small");
    i0.ɵɵproperty("ngClass", ctx_r5.isMobile ? "a3t-datetime--calendar-width" : "a3t-datetime--calendar-min-width");
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("end-active", ctx_r5.isRtl ? ctx_r5.startRangeActive : !ctx_r5.startRangeActive);
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("data-testid", ctx_r5.testID + "_start");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r5.headings.startLabel, "\n            ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r5.startValueSummary);
    i0.ɵɵadvance(3);
    i0.ɵɵattribute("data-testid", ctx_r5.testID + "_end");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r5.headings.endLabel, "\n            ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r5.endValueSummary);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("initialValue", ctx_r5.activeDateTime.initialValue)("activeValue", ctx_r5.activeDateTime.activeValue)("dateFilter", ctx_r5.activeDateTime.dateFilter)("dateRange", ctx_r5.activeDateTime.dateRange)("timeMode", ctx_r5.timeModeState$.value)("activeFace", ctx_r5.clockFaceState$.value)("timePicker", ctx_r5.timePicker)("timeOnly", ctx_r5.timeOnly)("timeSeconds", ctx_r5.seconds)("emptyTimeHeading", ctx_r5.headings.emptyTime)("clockHeadings", ctx_r5.headings)("disabled", ctx_r5.disabled)("readonly", ctx_r5.readonly)("hideDatePickerSummary", true)("preventExpandedDateControls", true)("testID", ctx_r5.testID);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r5.inline);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.inline)("ngIfThen", _r7);
} }
function AdaptDatetimeRange2Component_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 32);
} }
function AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_strong_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "strong");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r37 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", error_r37.name, " ");
} }
function AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 29);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_div_2_Template, 1, 0, "div", 30);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "div", 31);
    i0.ɵɵtemplate(5, AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_strong_5_Template, 2, 1, "strong", 4);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r37 = ctx.$implicit;
    const ctx_r36 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r36.inline);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", error_r37.name);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(error_r37.text);
} }
function AdaptDatetimeRange2Component_ng_template_21_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 27);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_Template, 8, 3, "div", 28);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r35 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r35._self.errors);
} }
function AdaptDatetimeRange2Component_ng_template_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptDatetimeRange2Component_ng_template_21_div_1_Template, 4, 2, "div", 26);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r8._self.errors.length > 0 && ctx_r8._self.control.touched);
} }
const _c6 = function () { return { isPicker: true }; };
const MIN_DROPDOWN_WIDTH = 270;
export class AdaptDatetimeRange2Component extends FormComponent {
    constructor(_injector, _dir, _deviceDetectorService, _renderer, _changeDetectorRef, _ngZone, ts, _adaptRadarService, _elem) {
        super(_injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptDatetimeRange2);
        this._injector = _injector;
        this._dir = _dir;
        this._deviceDetectorService = _deviceDetectorService;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        // Self link
        this._self = this;
        // UI fields
        this.inputControlValue = '';
        this.dropdownAutoClose = 'outside';
        this.timeModeState$ = new BehaviorSubject(false);
        this.clockFaceState$ = new BehaviorSubject(Clock2FaceUnit.Hours);
        this.isLastWizardStep = false;
        this.twoRowsWrap = false;
        this.threeRowsWrap = false;
        this.isRtl = false;
        this.defaultTexts = {
            startLabel: '',
            endLabel: ''
        };
        this.defaultErrors = {
            invalidStartName: '',
            invalidStart: '',
            invalidEndName: '',
            invalidEnd: '',
            rangeName: '',
            range: '',
            rangeOrderName: '',
            rangeOrder: '',
            disabledDateStartName: '',
            disabledDateStart: '',
            disabledDateEndName: '',
            disabledDateEnd: '',
            disabledTimeStartName: '',
            disabledTimeStart: '',
            disabledTimeEndName: '',
            disabledTimeEnd: '',
        };
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * Datetime input label
         */
        this.label = '';
        /**
         * Datetime input placeholder
         */
        this.placeholder = '';
        /**
         * DateTime inline mode
         */
        this.inline = false;
        /**
         * DateTime inline light color scheme mode
         */
        this.inlineLight = true;
        /**
         * DateTime inline small size mode
         */
        this.inlineSize = 'default';
        /**
         * Class for datetime dropdown
         */
        this.dropdownClass = 'dropdown-menu p-0';
        /**
         * Date input format
         */
        this.dateInputFormat = 'L';
        /**
         * Time input format without seconds
         */
        this.timeInputFormat = 'LT';
        /**
         * Time input format with seconds
         */
        this.timeInputLongFormat = 'LTS';
        /**
         * Toggle time picker
         */
        this.timePicker = false;
        /**
         * Use only the time picker flag
         */
        this.timeOnly = false;
        /**
         * Use seconds in time picker
         */
        this.seconds = false;
        /**
         * Use disabled style for the control if [readonly]=true
         */
        this.disabledStyleForReadonlyState = false;
        /**
         * Picker placement
         */
        this.placement = ['bottom-left', 'top-left', 'bottom-right', 'top-right', 'bottom-left'];
        /**
         * Append to body trigger
         */
        this.appendToBody = false;
        /**
         * Prevent choosing dateTime Range value step-by-step
         */
        this.preventWizard = false;
        // Outputs
        /**
         * Event on picker open
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.open = new EventEmitter();
        /**
         * Event on picker close
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.close = new EventEmitter();
        /**
         * Event on ngModel change
         */
        this.valueChange = new EventEmitter();
        /**
         * FormControl focus implementation
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        /**
         * FormControl blur implementation
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Privates fields for ControlValueAccessor
        this._onTouchedCallback = noop;
        this._onChangeCallback = noop;
        // ngModel value
        this._model = null;
        // previousNgModel value
        this._previousModel = null;
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Template refs
        // Active range's edge
        this._dtStartIsActive = true;
        // Subjects
        this._editInProgress = new BehaviorSubject(false);
        this.dropdownAutoClose = this._deviceDetectorService.isMobile() ? false : 'outside';
        this.isMobile = this._deviceDetectorService.isMobile();
        this.isIE = this._deviceDetectorService.isIE();
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get editInProgress() {
        const inline = this.inline;
        const ddOpen = this.dropdownRef && this.dropdownRef.isOpen();
        const inputInFocus = this.inputControlRef && (document.activeElement === this.inputControlRef.nativeElement);
        return !inline && (ddOpen || inputInFocus);
    }
    get startValueSummary() {
        if (this.value && this.value[0]) {
            return this.value[0].isValid() ? this.value[0].format(this._getInputControlFormat()) : this.headings.invalidValueLabel;
        }
        return this.headings.emptyStartLabel;
    }
    get endValueSummary() {
        if (this.value && this.value[1]) {
            return this.value[1].isValid() ? this.value[1].format(this._getInputControlFormat()) : this.headings.invalidValueLabel;
        }
        return this.headings.emptyEndLabel;
    }
    get startRangeActive() {
        return this._dtStartIsActive;
    }
    get value() {
        return this._model;
    }
    set value(v) {
        if (this.disabled) {
            return;
        }
        if (v && (v[0] || v[1])) {
            this._model = [v[0], v[1]];
        }
        else {
            this._model = null;
        }
        this._onChangeCallback(this._model);
        this.valueChange.emit(this._model);
        this._updateActiveDateTime();
        this._inputControlFormatting();
    }
    ngOnInit() {
        super.ngOnInit();
        this.initControl();
        if (!this.id) {
            this.id = `dtr-${AdaptDatetimeRange2Component.DTR_ID++}`;
        }
        if (!this.testID) {
            this.testID = `dtr-${AdaptDatetimeRange2Component.DTR_TEST_ID++}`;
        }
        if (!this.name) {
            this.name = `${this.id}-form-control`;
        }
        if (this.timeOnly) {
            this.timePicker = true;
        }
        if (this.inline) {
            this._openPicker();
        }
        if (!this.mainCls) {
            this.mainCls = this.inline ? '' : 'form-group';
        }
        // Detect close event on dd
        this._dtrDropdownOpenChangeSub = this.dropdownRef.onClose.subscribe(() => {
            if (!this.inline) {
                this._closePicker();
            }
        });
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        this._editInProgress
            .pipe(distinctUntilChanged())
            .subscribe((inProgress) => {
            if (!(this.control && this.control.control)) {
                return;
            }
            if (!inProgress) {
                this.control.control.updateValueAndValidity();
            }
        });
        this.headings = Object.assign(Object.assign({}, this.defaultTexts), this.headings);
        if (this.tooltipIconCls && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIconCls,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
        this.isRtl = this._dir.value === 'rtl';
    }
    ngOnDestroy() {
        this._dtrDropdownOpenChangeSub.unsubscribe();
    }
    setDefaultTexts(translation) {
        this.defaultTexts.startLabel = translation['adapt.datetimeRange.startDate'];
        this.defaultTexts.endLabel = translation['adapt.datetimeRange.endDate'];
        this.defaultTexts.cancelBtn = translation['adapt.common.cancel'];
        this.defaultTexts.clearBtn = translation['adapt.common.clearAll'];
        this.defaultTexts.nextBtn = translation['adapt.common.next'];
        this.defaultTexts.applyBtn = translation['adapt.common.ok'];
        this.defaultTexts.emptyStartLabel = translation['adapt.datetimeRange.emptyStart'];
        this.defaultTexts.emptyEndLabel = translation['adapt.datetimeRange.emptyEnd'];
        this.defaultTexts.emptyTime = translation['adapt.datetimeRange.emptyTime'];
        this.defaultTexts.invalidValueLabel = translation['adapt.datetimeRange.invalidValue'];
        this.requiredLabel = translation['adapt.common.required'];
        this.defaultErrors.invalidStartName = translation['adapt.datetimeRange.error.invalidStartName'];
        this.defaultErrors.invalidStart = translation['adapt.datetimeRange.error.invalidStart'];
        this.defaultErrors.invalidEndName = translation['adapt.datetimeRange.error.invalidEndName'];
        this.defaultErrors.invalidEnd = translation['adapt.datetimeRange.error.invalidEnd'];
        this.defaultErrors.rangeName = translation['adapt.datetimeRange.error.rangeName'];
        this.defaultErrors.range = translation['adapt.datetimeRange.error.range'];
        this.defaultErrors.rangeOrderName = translation['adapt.datetimeRange.error.rangeOrderName'];
        this.defaultErrors.rangeOrder = translation['adapt.datetimeRange.error.rangeOrder'];
        this.defaultErrors.disabledDateStartName = translation['adapt.datetimeRange.error.disabledDateStartName'];
        this.defaultErrors.disabledDateStart = translation['adapt.datetimeRange.error.disabledDateStart'];
        this.defaultErrors.disabledDateEndName = translation['adapt.datetimeRange.error.disabledDateEndName'];
        this.defaultErrors.disabledDateEnd = translation['adapt.datetimeRange.error.disabledDateEnd'];
        this.defaultErrors.disabledTimeStartName = translation['adapt.datetimeRange.error.disabledTimeStartName'];
        this.defaultErrors.disabledTimeStart = translation['adapt.datetimeRange.error.disabledTimeStart'];
        this.defaultErrors.disabledTimeEndName = translation['adapt.datetimeRange.error.disabledTimeEndName'];
        this.defaultErrors.disabledTimeEnd = translation['adapt.datetimeRange.error.disabledTimeEnd'];
    }
    /**
     * Change active range edge to start
     */
    switchToStartDT() {
        this._dtStartIsActive = true;
        this._updateActiveDateTime();
        this.timeModeState$.next(this.timeOnly);
        this.clockFaceState$.next(Clock2FaceUnit.Hours);
    }
    /**
     * Change active range edge to end
     */
    switchToEndDT() {
        this._dtStartIsActive = false;
        this._updateActiveDateTime();
        this.timeModeState$.next(this.timeOnly);
        this.clockFaceState$.next(Clock2FaceUnit.Hours);
    }
    /**
     * Datetime wizard
     */
    goToNextStep() {
        if (this.inline) {
            return;
        }
        if (this.preventWizard) {
            this.pickerCloseAndApply();
            return;
        }
        if (this.timePicker) {
            if (!this.timeModeState$.value) {
                this.timeModeState$.next(true);
            }
            else {
                if (this.clockFaceState$.value === (this.seconds ? Clock2FaceUnit.Seconds : Clock2FaceUnit.Minutes)) {
                    if (this._dtStartIsActive) {
                        this.switchToEndDT();
                    }
                    else {
                        if (!!this.value && !!this.value[1] && this.value[1].isValid()) {
                            if (!!this.value && !!this.value[0] && this.value[0].isValid()) {
                                this.pickerCloseAndApply();
                            }
                            else {
                                this.switchToStartDT();
                            }
                        }
                        else {
                            this.switchToStartDT();
                        }
                    }
                }
                else {
                    this.clockFaceState$.next(this.clockFaceState$.value + 1);
                }
            }
        }
        else {
            this._dtStartIsActive ? this.switchToEndDT() : this.pickerCloseAndApply();
        }
        this._checkIfLastWizardStep();
    }
    /**
     * Select date/time on picker
     */
    selectDateTime(v) {
        const oldModel = this.value ? [this.value[0], this.value[1]] : [null, null];
        if (this._dtStartIsActive) {
            this.value = [
                v.clone(),
                oldModel[1] ? oldModel[1].clone() : null
            ];
        }
        else {
            this.value = [
                oldModel[0] ? oldModel[0].clone() : null,
                v.clone()
            ];
        }
        if (this.inline) {
            this._onTouchedCallback();
        }
    }
    /**
     * Close picker and set previous model value
     */
    pickerCloseAndCancel() {
        this.value = this._previousModel;
        this._closePicker();
    }
    /**
     * Close picker and use current value
     */
    pickerCloseAndApply() {
        this._closePicker();
    }
    /**
     * Clear model value
     */
    pickerClearAll() {
        this.value = null;
        this._checkIfLastWizardStep();
        if (this.isMobile) {
            this._closePicker();
        }
    }
    /**
     * Input control (input) handler
     */
    inputControlWrite(v) {
        this.inputControlValue = v;
        if (v) {
            this.value = this._tryParseRange(v);
        }
        else {
            this.value = [null, null];
        }
    }
    /**
     * Input control (focus) handler
     */
    inputControlFocus() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.focus.emit();
        if (!this.dropdownRef.isOpen()) {
            this._openPicker();
        }
        this._editInProgress.next(this.editInProgress);
    }
    /**
     * Input control (blur) handler
     */
    inputControlBlur() {
        this.blur.emit();
        this._inputControlFormatting();
        if (!this.dropdownRef.isOpen()) {
            this._onTouchedCallback();
        }
        this._editInProgress.next(this.editInProgress);
    }
    /**
     * Dropdown mousedown handler
     */
    dropdownMouseDown() {
        if (this.inputControlRef) {
            this.inputControlRef.nativeElement.blur();
        }
    }
    /**
     * Open picker
     */
    /**
     * Time mode change handler
     */
    timeModeChange(v) {
        if (this.timeModeState$.value !== v) {
            this.timeModeState$.next(v);
        }
        if (v && (this.clockFaceState$.value !== Clock2FaceUnit.Hours)) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this.clockFaceState$.next(Clock2FaceUnit.Hours);
            });
        }
        this._checkIfLastWizardStep();
    }
    /**
     * Close picker
     */
    /**
     * Clock face change handler
     */
    clockFaceChange(v) {
        if (this.clockFaceState$.value !== v) {
            this.clockFaceState$.next(v);
        }
        this._checkIfLastWizardStep();
    }
    writeValue(v) {
        this._model = v ? [v[0] ? moment(v[0]) : null, v[1] ? moment(v[1]) : null] : [null, null];
        this._updateActiveDateTime();
        this._inputControlFormatting();
    }
    /**
     * Get formatted [timeMin] prop value
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * Get formatted [timeMax] prop value
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * Get formatted [timeMin] prop value
     */
    setDisabledState(isDisabled) {
        this._disabled = isDisabled;
    }
    /**
     * Get formatted [timeMax] prop value
     */
    validate(c) {
        const invalidStartValueErrorMsg = {
            dateError: this._customErrorTexts.invalidStartValueError || {
                name: this.defaultErrors.invalidStartName,
                text: this.defaultErrors.invalidStart
            }
        };
        const invalidEndValueErrorMsg = {
            dateError: this._customErrorTexts.invalidEndValueError || {
                name: this.defaultErrors.invalidEndName,
                text: this.defaultErrors.invalidEnd
            }
        };
        const rangeModelErrorMsg = {
            dateError: this._customErrorTexts.missedRangeValueError || {
                name: this.defaultErrors.rangeName,
                text: this.defaultErrors.range
            }
        };
        const rangeErrorMsg = {
            dateError: this._customErrorTexts.rangeValuesOrderError || {
                name: this.defaultErrors.rangeOrderName,
                text: this.defaultErrors.rangeOrder
            }
        };
        const startDateErrorMsg = {
            dateError: this._customErrorTexts.unselectableStartDateError || {
                name: this.defaultErrors.disabledDateStartName,
                text: this.defaultErrors.disabledDateStart
            }
        };
        const endDateErrorMsg = {
            dateError: this._customErrorTexts.unselectableEndDateError || {
                name: this.defaultErrors.disabledDateEndName,
                text: this.defaultErrors.disabledDateEnd
            }
        };
        const unselectableStartTimeErrorMsg = {
            dateError: this._customErrorTexts.unselectableStartTimeError || {
                name: this.defaultErrors.disabledTimeStartName,
                text: formatString(this.defaultErrors.disabledTimeStart, this._getFormattedStartMinTime(), this._getFormattedStartMaxTime())
            }
        };
        const unselectableEndTimeErrorMsg = {
            dateError: this._customErrorTexts.unselectableEndTimeError || {
                name: this.defaultErrors.disabledTimeEndName,
                text: formatString(this.defaultErrors.disabledTimeEnd, this._getFormattedEndMinTime(), this._getFormattedEndMaxTime())
            }
        };
        const invalidStartValueError = c.value && c.value[0] && !c.value[0].isValid();
        const invalidEndValueError = c.value && c.value[1] && !c.value[1].isValid();
        const rangeModelError = !this.editInProgress && c.value && (c.value[0] || c.value[1]) && !(c.value[0] && c.value[1]);
        const rangeError = c.value && c.value[0] && c.value[0].isValid() && c.value[1] && c.value[1].isValid() &&
            c.value[0].isAfter(c.value[1]);
        const startDateError = c.value && c.value[0] && c.value[0].isValid() && !this._startDateFilter(c.value[0], c);
        const endDateError = c.value && c.value[1] && c.value[1].isValid() && !this._endDateFilter(c.value[1], c);
        const unselectableStartTimeError = c.value && c.value[0] && c.value[0].isValid() && this.startTimeMin && this.startTimeMax &&
            !IsTimeInRange(c.value[0], this.startTimeMin, this.startTimeMax);
        const unselectableEndTimeError = c.value && c.value[1] && c.value[1].isValid() && this.endTimeMin && this.endTimeMax &&
            !IsTimeInRange(c.value[1], this.endTimeMin, this.endTimeMax);
        return invalidStartValueError ? invalidStartValueErrorMsg :
            invalidEndValueError ? invalidEndValueErrorMsg :
                rangeModelError ? rangeModelErrorMsg :
                    rangeError ? rangeErrorMsg :
                        startDateError ? startDateErrorMsg :
                            endDateError ? endDateErrorMsg :
                                unselectableStartTimeError ? unselectableStartTimeErrorMsg :
                                    unselectableEndTimeError ? unselectableEndTimeErrorMsg : null;
    }
    /**
     * Get format for input control value
     */
    _truncateBtn(btn) {
        const xPadings = 10;
        if (btn.offsetWidth + xPadings > window.innerWidth - xPadings) {
            this._renderer.addClass(btn, 'text-truncate');
            return window.innerWidth - xPadings;
        }
        else {
            return btn.offsetWidth + xPadings;
        }
    }
    _wrapButtons() {
        const xPadings = 10; // left and right padding
        const cancelBtnWidth = this.cancelBtn.nativeElement.offsetWidth; // cancel button width
        const nextBtnWidth = this.nextBtn.nativeElement.offsetWidth; // next button width
        const clearBtnWidth = this.clearBtn.nativeElement.offsetWidth; // clear button width
        const btnGroupWidth = nextBtnWidth + clearBtnWidth + 5; // clear + next buttons width + margins
        const buttonsWidth = cancelBtnWidth + btnGroupWidth + xPadings; // all buttons width
        let containerWidth = buttonsWidth < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : buttonsWidth;
        if (window.innerWidth - xPadings < buttonsWidth) {
            // wrap button in two rows
            if (btnGroupWidth + xPadings < window.innerWidth - xPadings) {
                const firstRowWidth = btnGroupWidth + xPadings < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : btnGroupWidth + xPadings;
                const secondRowWidth = this._truncateBtn(this.cancelBtn.nativeElement);
                containerWidth = Math.max(firstRowWidth, secondRowWidth);
                this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
                this.twoRowsWrap = true;
            }
            else {
                // wrap button in three rows
                const firstRowWidth = this._truncateBtn(this.nextBtn.nativeElement);
                const secondRowWidth = this._truncateBtn(this.clearBtn.nativeElement);
                const thirdRowWidth = this._truncateBtn(this.cancelBtn.nativeElement);
                const maxButtonWidth = Math.max(firstRowWidth, secondRowWidth, thirdRowWidth);
                containerWidth = maxButtonWidth < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : maxButtonWidth;
                this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
                this.threeRowsWrap = true;
            }
        }
        else {
            this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
        }
    }
    _openPicker() {
        this._updateActiveDateTime();
        if (this._deviceDetectorService.isMobile() && this.inputControlRef) {
            this.inputControlRef.nativeElement.blur();
        }
        if (!this.inline && (this.isMobile || this.isIE)) {
            // in some cases nativeElement is undefined, need to wait for zone stable
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this._wrapButtons();
            });
        }
        this._previousModel = this.value ? [
            this.value[0] ? this.value[0].clone() : null,
            this.value[1] ? this.value[1].clone() : null
        ] : null;
        if (this.inline) {
            return;
        }
        this.switchToStartDT();
        this.dropdownRef.open();
        this.open.emit(this.id);
        this._editInProgress.next(this.editInProgress);
    }
    /**
     * Parse text into dateRange model
     */
    _closePicker() {
        this.twoRowsWrap = false;
        this.threeRowsWrap = false;
        if (this.inline) {
            return;
        }
        this.dropdownRef.close(); // DOUBLE CLOSE BECAUSE OF SUBSCRIPTION
        this.close.emit(this.id);
        this._onTouchedCallback();
        this._editInProgress.next(this.editInProgress);
    }
    /**
     * Get time format
     */
    _inputControlFormatting() {
        if (this.inputControlRef && (this.inputControlRef.nativeElement === document.activeElement)) {
            return;
        }
        if (this.value) {
            if ((this.value[0] && !this.value[0].isValid()) || (this.value[1] && !this.value[1].isValid())) {
                return;
            }
            if (this.value[0] && this.value[0].isValid()) {
                this.inputControlValue = this.value[0].format(this._getInputControlFormat());
            }
            else {
                this.inputControlValue = '';
            }
            if (this.value[1] && this.value[1].isValid()) {
                this.inputControlValue += ' - ' + this.value[1].format(this._getInputControlFormat());
            }
        }
        else {
            this.inputControlValue = '';
        }
        if (!this._changeDetectorRef.destroyed) {
            this._changeDetectorRef.detectChanges();
        }
    }
    /**
     * Combined filter for the start calendar
     */
    _getFormattedStartMinTime() {
        return (this.startTimeMin || moment().startOf('day')).format(this._getTimeFormat());
    }
    /**
     * Combined filter for the end calendar
     */
    _getFormattedStartMaxTime() {
        return (this.startTimeMax || moment().endOf('day')).format(this._getTimeFormat());
    }
    _getFormattedEndMinTime() {
        return (this.endTimeMin || moment().startOf('day')).format(this._getTimeFormat());
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // ControlValueAccessor
    _getFormattedEndMaxTime() {
        return (this.endTimeMax || moment().endOf('day')).format(this._getTimeFormat());
    }
    _getInputControlFormat() {
        let format = this.dateInputFormat;
        if (this.timePicker) {
            format += ` ${this._getTimeFormat()}`;
            if (this.timeOnly) {
                format = this._getTimeFormat();
            }
        }
        return format;
    }
    _tryParseRange(v) {
        let start;
        let end;
        const strictSeparator = v.split(/\s\W\s/g);
        if (strictSeparator.length === 2) {
            start = this.timeOnly ?
                moment(`${moment().format(this.dateInputFormat)} ${strictSeparator[0]}`, this.dateInputFormat + ' ' + this._getTimeFormat()) :
                moment(strictSeparator[0], this._getInputControlFormat());
            end = this.timeOnly ?
                moment(`${moment().format(this.dateInputFormat)} ${strictSeparator[1]}`, this.dateInputFormat + ' ' + this._getTimeFormat()) :
                moment(strictSeparator[1], this._getInputControlFormat());
            return [
                strictSeparator[0] ? start.clone() : null,
                strictSeparator[1] ? end.clone() : null
            ];
        }
        start = this.timeOnly ? moment(`${moment().format(this.dateInputFormat)} ${v}`) : moment(v);
        if (start.isValid()) {
            return [start.clone(), null];
        }
        const parts = v.split(' ');
        if (parts.length > 1) {
            let startStr = '';
            let endStr = '';
            for (let i = 0; i < parts.length; i++) {
                startStr += (parts[i] + ' ');
                const testStart = this.timeOnly ? moment(`${moment().format(this.dateInputFormat)} ${startStr}`) : moment(startStr);
                if (testStart.isValid()) {
                    start = testStart;
                }
                endStr = parts[parts.length - 1 - i] + ' ' + endStr;
                const testEnd = this.timeOnly ? moment(`${moment().format(this.dateInputFormat)} ${endStr}`) : moment(endStr);
                if (testEnd.isValid()) {
                    end = testEnd;
                }
            }
        }
        return [start.clone(), end ? end.clone() : null];
    }
    _getTimeFormat() {
        return this.seconds ? this.timeInputLongFormat : this.timeInputFormat;
    }
    _startDateFilter(d, formControl) {
        const acceptedByRangeFilter = this.value && this.value[1] && this.value[1].isValid() ?
            d.clone().startOf('day').isSameOrBefore(this.value[1].clone().startOf('day')) : true;
        const acceptedByCustomFilter = this.startDateFilter ? this.startDateFilter(d, formControl) : true;
        return acceptedByRangeFilter && acceptedByCustomFilter;
    }
    _endDateFilter(d, formControl) {
        const acceptedByRangeFilter = this.value && this.value[0] && this.value[0].isValid() ?
            d.clone().startOf('day').isSameOrAfter(this.value[0].clone().startOf('day')) : true;
        const acceptedByCustomFilter = this.endDateFilter ? this.endDateFilter(d, formControl) : true;
        return acceptedByRangeFilter && acceptedByCustomFilter;
    }
    _updateActiveDateTime() {
        this.activeDateTime = this._dtStartIsActive ?
            {
                initialValue: this.initialValue ? this.initialValue[0] : null,
                activeValue: this.value ? this.value[0] : null,
                dateFilter: this._startDateFilter.bind(this),
                dateRange: this.value ? [this.value[0], this.value[1]] : [null, null]
            } :
            {
                initialValue: this.initialValue ? this.initialValue[1] : null,
                activeValue: this.value ? this.value[1] : null,
                dateFilter: this._endDateFilter.bind(this),
                dateRange: this.value ? [this.value[0], this.value[1]] : [null, null]
            };
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Validator
    /**
     * Wizard's last step checking
     */
    _checkIfLastWizardStep() {
        const wizard = !this.preventWizard;
        const lastRangeValue = !this._dtStartIsActive;
        const lastTimeStep = this.timePicker && this.timeModeState$.value &&
            (this.clockFaceState$.value === (this.seconds ? Clock2FaceUnit.Seconds : Clock2FaceUnit.Minutes));
        const timePicker = this.timePicker;
        const lastStep = timePicker ? lastTimeStep : true;
        const modelFull = !timePicker ||
            (!!this.value && !!this.value[0] && this.value[0].isValid() && !!this.value[1] && this.value[1].isValid());
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this.isLastWizardStep = !wizard || (lastRangeValue && lastStep && modelFull);
        });
    }
}
// Static fields
AdaptDatetimeRange2Component.DTR_ID = 1;
AdaptDatetimeRange2Component.DTR_TEST_ID = 1;
AdaptDatetimeRange2Component.ɵfac = function AdaptDatetimeRange2Component_Factory(t) { return new (t || AdaptDatetimeRange2Component)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.Directionality), i0.ɵɵdirectiveInject(i2.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptTranslateService), i0.ɵɵdirectiveInject(i3.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptDatetimeRange2Component.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetimeRange2Component, selectors: [["adapt-datetime-range2"]], viewQuery: function AdaptDatetimeRange2Component_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 5);
        i0.ɵɵviewQuery(_c3, 5);
        i0.ɵɵviewQuery(_c4, 5);
        i0.ɵɵviewQuery(_c5, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputControlRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cancelBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearBtn = _t.first);
    } }, hostVars: 3, hostBindings: function AdaptDatetimeRange2Component_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("name", ctx.name);
        i0.ɵɵstyleProp("display", "block");
    } }, inputs: { formControl: "formControl", id: "id", testID: "testID", name: "name", label: "label", placeholder: "placeholder", inline: "inline", inlineLight: "inlineLight", inlineSize: "inlineSize", initialValue: "initialValue", inputControlClass: "inputControlClass", dropdownClass: "dropdownClass", dateInputFormat: "dateInputFormat", timeInputFormat: "timeInputFormat", timeInputLongFormat: "timeInputLongFormat", timePicker: "timePicker", timeOnly: "timeOnly", seconds: "seconds", startTimeMin: "startTimeMin", startTimeMax: "startTimeMax", endTimeMin: "endTimeMin", endTimeMax: "endTimeMax", startDateFilter: "startDateFilter", endDateFilter: "endDateFilter", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", placement: "placement", appendToBody: "appendToBody", headings: "headings", preventWizard: "preventWizard" }, outputs: { open: "open", close: "close", valueChange: "valueChange", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptDatetimeRange2Component),
            createFormControlValidator(AdaptDatetimeRange2Component),
        ]), i0.ɵɵInheritDefinitionFeature], decls: 24, vars: 23, consts: [["adaptDropdown", "", 3, "adaptRadarDisableEventSending", "animationPlacement", "placement", "appendToBody", "autoClose", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "mobileView"], ["dropdownRef", "adaptDropdown"], ["adaptDropdownAnchor", ""], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [4, "ngIf"], ["adaptDropdownMenuTemplate", ""], [4, "ngIf", "ngIfThen"], ["calendar", ""], ["errorTemplate", ""], ["autocomplete", "off", 3, "value", "disabled", "readonly", "input", "focus", "blur"], ["inputControlRef", ""], [3, "mousedown"], [3, "ngClass"], ["calendarContainer", ""], [1, "a3t-datetime-range--header"], ["type", "button", 3, "click"], [3, "initialValue", "activeValue", "dateFilter", "dateRange", "timeMode", "activeFace", "timePicker", "timeOnly", "timeSeconds", "emptyTimeHeading", "clockHeadings", "disabled", "readonly", "hideDatePickerSummary", "preventExpandedDateControls", "testID", "timeModeChange", "clockFaceChange", "valueChange"], ["class", "a3t-datetime--footer", 3, "two-rows-wrap", 4, "ngIf"], [1, "a3t-datetime--footer"], ["type", "button", 1, "btn", "btn-sm", "btn-link", 3, "click"], ["cancelBtn", ""], [1, "d-flex", "justify-content-center"], ["type", "button", 1, "btn", "btn-sm", "btn-secondary", "m-end-1", 3, "click"], ["clearBtn", ""], ["type", "button", 1, "btn", "btn-sm", "btn-primary", 3, "click"], ["nextBtn", ""], ["class", "has-danger adapt-datetime-range2__validation-errors", 4, "ngIf"], [1, "has-danger", "adapt-datetime-range2__validation-errors"], ["class", "form-control-feedback d-flex align-items-start m-0 pt-1 pb-0", 4, "ngFor", "ngForOf"], [1, "form-control-feedback", "d-flex", "align-items-start", "m-0", "pt-1", "pb-0"], ["class", "d-icon-exclamation_triangle flex-grow-0 flex-shrink-0 m-end-2", 4, "ngIf"], [1, "flex-grow-1", "flex-shrink-1"], [1, "d-icon-exclamation_triangle", "flex-grow-0", "flex-shrink-0", "m-end-2"]], template: function AdaptDatetimeRange2Component_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0, 1);
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelementStart(4, "div", 2);
        i0.ɵɵtext(5, "\n        ");
        i0.ɵɵelement(6, "adapt-rx-control-label", 3);
        i0.ɵɵtext(7, "\n\n        ");
        i0.ɵɵtemplate(8, AdaptDatetimeRange2Component_div_8_Template, 5, 22, "div", 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵtemplate(11, AdaptDatetimeRange2Component_ng_template_11_Template, 6, 4, "ng-template", 5);
        i0.ɵɵtext(12, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n\n    ");
        i0.ɵɵtemplate(14, AdaptDatetimeRange2Component_ng_container_14_Template, 1, 0, "ng-container", 6);
        i0.ɵɵtext(15, "\n\n    ");
        i0.ɵɵtemplate(16, AdaptDatetimeRange2Component_ng_template_16_Template, 26, 32, "ng-template", null, 7, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(18, "\n\n    ");
        i0.ɵɵtemplate(19, AdaptDatetimeRange2Component_ng_container_19_Template, 1, 0, "ng-container", 6);
        i0.ɵɵtext(20, "\n\n    ");
        i0.ɵɵtemplate(21, AdaptDatetimeRange2Component_ng_template_21_Template, 3, 1, "ng-template", null, 8, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(23, "\n  ");
    } if (rf & 2) {
        const _r4 = i0.ɵɵreference(17);
        const _r7 = i0.ɵɵreference(22);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("animationPlacement", "center")("placement", ctx.placement)("appendToBody", ctx.appendToBody)("autoClose", ctx.dropdownAutoClose)("holdFocusInMenu", true)("holdFocusOnOpen", false)("autoFocusFirst", false)("restoreFocusAfterClose", false)("mobileView", i0.ɵɵpureFunction0(22, _c6));
        i0.ɵɵadvance(3);
        i0.ɵɵclassProp("has-danger", ctx._self.errors.length > 0 && ctx._self.control.touched);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx._self.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.inline);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", ctx.inline)("ngIfThen", _r4);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", !ctx.inline)("ngIfThen", _r7);
    } }, encapsulation: 2, data: { animation: [
            trigger('heightAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '0',
                            to: '*'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '*',
                            to: '0'
                        }
                    })
                ])
            ]),
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetimeRange2Component, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime-range2',
                template: `
    <div adaptDropdown
         [adaptRadarDisableEventSending]="true"
         #dropdownRef="adaptDropdown"
         [animationPlacement]="'center'"
         [placement]="placement"
         [appendToBody]="appendToBody"
         [autoClose]="dropdownAutoClose"
         [holdFocusInMenu]="true"
         [holdFocusOnOpen]="false"
         [autoFocusFirst]="false"
         [restoreFocusAfterClose]="false"
         [mobileView]="{isPicker: true}">
      <div adaptDropdownAnchor [class.has-danger]="_self.errors.length > 0 && _self.control.touched">
        <adapt-rx-control-label [for]="id"
                                [label]="label"
                                [requiredLabel]="requiredLabel"
                                [showRequiredLabel]="_self.required"
                                [tooltip]="tooltipConfig"></adapt-rx-control-label>

        <div *ngIf="!inline">
          <input #inputControlRef
                 autocomplete="off"
                 [attr.id]="id"
                 [class]="'a3t-datetime--input-control form-control ' + (inputControlClass || '')"
                 [value]="inputControlValue"
                 (input)="inputControlWrite(inputControlRef.value)"
                 (focus)="inputControlFocus()"
                 (blur)="inputControlBlur()"
                 [disabled]="disabled"
                 [readonly]="readonly"
                 [class.form-control-disabled-look]="readonly && this.disabledStyleForReadonlyState"
                 [attr.placeholder]="placeholder"
                 [attr.data-testid]="testID"
                 [class.i-date]="!timePicker"
                 [class.i-date-time]="timePicker && !timeOnly"
                 [class.i-time]="timeOnly"
                 [class.readonly]="readonly"
                 [class.a3t-datetime--input-control_active]="dropdownRef.isOpen()"
                 [class.a3t-datetime--input-control_invalid]="_self.errors.length > 0 && _self.control.touched"/>
        </div>
      </div>
      <ng-template adaptDropdownMenuTemplate>
        <div [class]="dropdownClass || ''" (mousedown)="dropdownMouseDown()">
          <ng-container *ngIf="!inline; then calendar"></ng-container>
        </div>
      </ng-template>
    </div>

    <ng-container *ngIf="inline; then calendar"></ng-container>

    <ng-template #calendar>
      <div #calendarContainer [ngClass]="isMobile ? 'a3t-datetime--calendar-width' : 'a3t-datetime--calendar-min-width'"
           [class.a3t-datetime-inline-light]="inline && inlineLight"
           [class.a3t-datetime-inline-small]="inline && inlineSize === 'small'">
        <div class="a3t-datetime-range--header" [class.end-active]="isRtl ? startRangeActive : !startRangeActive">
          <button type="button"
                  [attr.data-testid]="testID + '_start'"
                  (click)="switchToStartDT()">
            {{headings.startLabel}}
            <div>{{startValueSummary}}</div>
          </button>
          <button type="button"
                  [attr.data-testid]="testID + '_end'"
                  (click)="switchToEndDT()">
            {{headings.endLabel}}
            <div>{{endValueSummary}}</div>
          </button>
        </div>

        <adapt-datetime2-picker [initialValue]="activeDateTime.initialValue"
                                [activeValue]="activeDateTime.activeValue"
                                [dateFilter]="activeDateTime.dateFilter"
                                [dateRange]="activeDateTime.dateRange"
                                [timeMode]="timeModeState$.value"
                                [activeFace]="clockFaceState$.value"
                                [timePicker]="timePicker"
                                [timeOnly]="timeOnly"
                                [timeSeconds]="seconds"
                                [emptyTimeHeading]="headings.emptyTime"
                                [clockHeadings]="headings"
                                [disabled]="disabled"
                                [readonly]="readonly"
                                [hideDatePickerSummary]="true"
                                [preventExpandedDateControls]="true"
                                [testID]="testID"
                                (timeModeChange)="timeModeChange($event)"
                                (clockFaceChange)="clockFaceChange($event)"
                                (valueChange)="selectDateTime($event)"></adapt-datetime2-picker>

        <div class="a3t-datetime--footer" [class.two-rows-wrap]="twoRowsWrap || threeRowsWrap" *ngIf="!inline">
          <div>
            <button #cancelBtn
                    [attr.data-testid]="testID + '_cancel'"
                    type="button"
                    class="btn btn-sm btn-link"
                    (click)="pickerCloseAndCancel()">
              {{headings.cancelBtn}}</button>
          </div>
          <div class="d-flex justify-content-center" [class.three-rows-wrap]="threeRowsWrap">
            <button #clearBtn
                    [attr.data-testid]="testID + '_clear'"
                    type="button"
                    class="btn btn-sm btn-secondary m-end-1" (click)="pickerClearAll()">
              {{headings.clearBtn}}</button>
            <button #nextBtn
                    [attr.data-testid]="testID + '_apply'"
                    type="button"
                    class="btn btn-sm btn-primary" (click)="$event.stopPropagation(); goToNextStep()">
              <span *ngIf="isLastWizardStep">{{headings.applyBtn}}</span>
              <span *ngIf="!isLastWizardStep">{{headings.nextBtn}}</span>
            </button>
          </div>
        </div>

        <ng-container *ngIf="inline; then errorTemplate"></ng-container>
      </div>
    </ng-template>

    <ng-container *ngIf="!inline; then errorTemplate"></ng-container>

    <ng-template #errorTemplate>
      <div class="has-danger adapt-datetime-range2__validation-errors"
           *ngIf="_self.errors.length > 0 && _self.control.touched"
           [@validationFeedbackAnimation]>
        <div class="form-control-feedback d-flex align-items-start m-0 pt-1 pb-0" *ngFor="let error of _self.errors">
          <div class="d-icon-exclamation_triangle flex-grow-0 flex-shrink-0 m-end-2" *ngIf="inline"></div>
          <div class="flex-grow-1 flex-shrink-1"><strong *ngIf="error.name">{{error.name}} </strong>{{error.text}}</div>
        </div>
      </div>
    </ng-template>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.name]': 'name',
                    '[style.display]': '"block"'
                },
                animations: [
                    trigger('heightAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '0',
                                    to: '*'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '*',
                                    to: '0'
                                }
                            })
                        ])
                    ]),
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ],
                providers: [
                    createFormControlValueAccessor(AdaptDatetimeRange2Component),
                    createFormControlValidator(AdaptDatetimeRange2Component),
                ]
            }]
    }], function () { return [{ type: i0.Injector }, { type: i1.Directionality }, { type: i2.AdaptDeviceDetectionService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i2.AdaptTranslateService }, { type: i3.AdaptRadarService }, { type: i0.ElementRef }]; }, { formControl: [{
            type: Input
        }], id: [{
            type: Input
        }], testID: [{
            type: Input
        }], name: [{
            type: Input
        }], label: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], inline: [{
            type: Input
        }], inlineLight: [{
            type: Input
        }], inlineSize: [{
            type: Input
        }], initialValue: [{
            type: Input
        }], inputControlClass: [{
            type: Input
        }], dropdownClass: [{
            type: Input
        }], dateInputFormat: [{
            type: Input
        }], timeInputFormat: [{
            type: Input
        }], timeInputLongFormat: [{
            type: Input
        }], timePicker: [{
            type: Input
        }], timeOnly: [{
            type: Input
        }], seconds: [{
            type: Input
        }], startTimeMin: [{
            type: Input
        }], startTimeMax: [{
            type: Input
        }], endTimeMin: [{
            type: Input
        }], endTimeMax: [{
            type: Input
        }], startDateFilter: [{
            type: Input
        }], endDateFilter: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], placement: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], headings: [{
            type: Input
        }], preventWizard: [{
            type: Input
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], inputControlRef: [{
            type: ViewChild,
            args: ['inputControlRef']
        }], dropdownRef: [{
            type: ViewChild,
            args: ['dropdownRef', { static: true }]
        }], calendarContainer: [{
            type: ViewChild,
            args: ['calendarContainer', { static: false }]
        }], nextBtn: [{
            type: ViewChild,
            args: ['nextBtn', { static: false }]
        }], cancelBtn: [{
            type: ViewChild,
            args: ['cancelBtn', { static: false }]
        }], clearBtn: [{
            type: ViewChild,
            args: ['clearBtn', { static: false }]
        }] }); })();
//# sourceMappingURL=datetime-range2.component.js.map