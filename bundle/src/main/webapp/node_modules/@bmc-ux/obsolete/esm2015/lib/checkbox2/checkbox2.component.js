// TODO update types
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, HostBinding, Injector, Input, Optional, Output, Renderer2, ViewEncapsulation } from '@angular/core';
import { transition, trigger, useAnimation } from '@angular/animations';
import { AdaptRadarAngularCustomEventName, AdaptTranslateService, ANIMATION_NAME, createFormControlValidator, createFormControlValueAccessor, FormComponent, SafeCdr, toBoolean } from '@bmc-ux/adapt-angular';
import { AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@bmc-ux/adapt-angular";
import * as i2 from "@bmc-ux/adapt-radar";
import * as i3 from "@angular/common";
function AdaptCheckbox2Component_ng_container_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelement(2, "span", 11);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "span", 12);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r1.context.requiredLabel);
} }
function AdaptCheckbox2Component_span_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 13);
} }
function AdaptCheckbox2Component_adapt_icon_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 14);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r3.context.tooltipText);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", ctx_r3.context.tooltipIconCls);
} }
function AdaptCheckbox2Component_adapt_icon_27_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 15);
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("name", ctx_r4.context.popoverIcon)("adaptRadarDisableEventSending", true)("placement", ctx_r4.context.popoverPlacement)("adaptPopover", ctx_r4.context.popoverContent)("triggers", ctx_r4.context.popoverTriggers);
} }
function AdaptCheckbox2Component_div_32_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementStart(2, "p", 16);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r5.displayMessage);
} }
const _c0 = [[["", 8, "checkbox-before"]], [["", 8, "checkbox-after"]]];
const _c1 = function (a0) { return { "checkbox__item_no-label": a0 }; };
const _c2 = function (a0) { return { "sr-only": a0 }; };
const _c3 = [".checkbox-before", ".checkbox-after"];
const noop = () => {
    return;
};
let nextUniqueId = 0;
export class AdaptCheckbox2Component extends FormComponent {
    constructor(injector, _element, _renderer, _changeDetectorRef, ts, _adaptRadarService, _entityName) {
        super(injector, ts, _adaptRadarService, _element, _entityName ? _entityName : AdaptRadarAngularCustomEventName.AdaptCheckbox2);
        this._element = _element;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.context = this;
        /**
         * An unique id for each checkbox/switcher
         */
        this._uniqueId = `adapt-checkbox-${++nextUniqueId}`;
        this._label = '';
        this.class = ''; // override the standard class attr with a new one
        /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */
        this.id = this._uniqueId;
        /** Name value will be applied to the input element if present */
        this.name = null;
        /** The tabindex attribute of the native input element */
        this.tabindex = null;
        this.stopPropagation = true;
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        // eslint-disable-next-line @typescript-eslint/typedef
        this.ariaLabel = '';
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        /**
         * Control [aria-describedby] attribute text
         */
        this.ariaDescribedBy = null;
        /** the displayMessage attribute allows to show the additional info for the user */
        this.displayMessage = 'Please fill out this field';
        /** the toggleMessage attribute will toggle the additional messages */
        this.toggleMessage = false;
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        /** Event emitted when the switcher value changes. */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
        /** Event emitted when the checkbox's `indeterminate` value changes. */
        this.indeterminateChange = new EventEmitter();
        this._onTouchedCallback = noop;
        this._onChangeCallback = noop;
        /**
         * Private variables of checkbox/switcher component
         */
        this._checked = false;
        /**
         * An indeterminate state of checkbox component - by default is false;
         */
        this._indeterminate = false;
        this._el = _element.nativeElement;
    }
    get hostClasses() {
        return [
            this.class,
            this.mainCls,
            'checkbox',
            this.readonly ? 'readonly' : '',
        ].join(' ');
    }
    /** The input/switcher element's value. */
    get checked() {
        return this._checked;
    }
    set checked(checked) {
        this._updateCheckedValue(checked, false);
    }
    get indeterminate() {
        return this._indeterminate;
    }
    set indeterminate(indeterminate) {
        const changed = indeterminate !== this._indeterminate;
        this._indeterminate = indeterminate;
        if (changed) {
            this.indeterminateChange.emit(this._indeterminate);
        }
    }
    get inputId() {
        return `${this.id || this._uniqueId}-input`;
    }
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * The label text of the checkbox component
     */
    get label() {
        return this._label;
    }
    set label(v) {
        this._label = v;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    validate() {
        return null;
    }
    /**
     *
     * @returns "true" | "false" | "mixed"
     */
    _getAriaChecked() {
        return this.checked ? 'true' : (this.indeterminate ? 'mixed' : 'false');
    }
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(checked) {
        this._updateCheckedValue(!!checked, true);
    }
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * setDisabledState(isDisabled: boolean)?: void
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    /**
     * Set focus state of the input changes
     */
    onFocus() {
        this._renderer.addClass(this._el, 'is-focused');
    }
    /**
     * Remove focus state of the input changes
     */
    onBlur() {
        this._renderer.removeClass(this._el, 'is-focused');
        this._onTouchedCallback();
    }
    /**
     * Toggle the state of input element on user action
     */
    onInputClick(e) {
        if (this.stopPropagation) {
            e.stopPropagation();
        }
        if (!(this.disabled || this.readonly)) {
            if (this.indeterminate) {
                this.indeterminate = false;
                this.indeterminateChange.emit(this.indeterminate);
            }
            this._toggle();
        }
        else {
            e.preventDefault();
        }
    }
    onInteractionEvent(e) {
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        e.stopPropagation();
    }
    /**
     * Toggle checked/unchecked states in checkbox/switcher component
     */
    _toggle() {
        this.checked = !this.checked;
    }
    _updateCheckedValue(checked, fromOuterComponent) {
        if (checked !== this.checked) {
            this._checked = toBoolean(checked);
            if (!fromOuterComponent) {
                this.change.emit(checked);
            }
            this._onChangeCallback(checked);
            SafeCdr.markForCheck(this._changeDetectorRef);
        }
    }
}
AdaptCheckbox2Component.ɵfac = function AdaptCheckbox2Component_Factory(t) { return new (t || AdaptCheckbox2Component)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i1.AdaptRadarAngularCustomEventName, 8)); };
AdaptCheckbox2Component.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptCheckbox2Component, selectors: [["adapt-checkbox2"], ["div", "adapt-checkbox2", ""], ["adapt-checkbox"]], hostVars: 2, hostBindings: function AdaptCheckbox2Component_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { class: "class", id: "id", name: "name", tabindex: "tabindex", stopPropagation: "stopPropagation", value: "value", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: "ariaDescribedBy", displayMessage: "displayMessage", toggleMessage: "toggleMessage", indeterminate: "indeterminate", label: "label" }, outputs: { focus: "focus", blur: "blur", change: "change", indeterminateChange: "indeterminateChange" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptCheckbox2Component),
            createFormControlValidator(AdaptCheckbox2Component)
        ]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c3, decls: 34, vars: 26, consts: [[1, "checkbox__label"], ["type", "checkbox", 1, "checkbox__input", 3, "id", "disabled", "readOnly", "checked", "required", "tabIndex", "indeterminate", "focus", "blur", "change", "click"], ["input", ""], [1, "checkbox__item", 3, "ngClass"], [1, "icon-indeterminate"], [1, "font-weight-normal", "form-control-label"], [3, "ngClass"], [4, "ngIf"], ["class", "icon-space", 4, "ngIf"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip", 4, "ngIf"], [3, "name", "adaptRadarDisableEventSending", "placement", "adaptPopover", "triggers", 4, "ngIf"], [1, "letter-space"], [1, "form-control-required"], [1, "icon-space"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip"], [3, "name", "adaptRadarDisableEventSending", "placement", "adaptPopover", "triggers"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2", "adapt-counter-error"]], template: function AdaptCheckbox2Component_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c0);
        i0.ɵɵprojection(0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵelementStart(2, "span", 0);
        i0.ɵɵtext(3, "\n  ");
        i0.ɵɵelementStart(4, "label");
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementStart(6, "input", 1, 2);
        i0.ɵɵlistener("focus", function AdaptCheckbox2Component_Template_input_focus_6_listener() { return ctx.onFocus(); })("blur", function AdaptCheckbox2Component_Template_input_blur_6_listener() { return ctx.onBlur(); })("change", function AdaptCheckbox2Component_Template_input_change_6_listener($event) { return ctx.onInteractionEvent($event); })("click", function AdaptCheckbox2Component_Template_input_click_6_listener($event) { return ctx.onInputClick($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n    ");
        i0.ɵɵelementStart(9, "div", 3);
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵelement(11, "span", 4);
        i0.ɵɵtext(12, "\n      ");
        i0.ɵɵelementStart(13, "span", 5);
        i0.ɵɵtext(14, "\n        ");
        i0.ɵɵelementStart(15, "span", 6);
        i0.ɵɵtext(16);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n        ");
        i0.ɵɵtemplate(18, AdaptCheckbox2Component_ng_container_18_Template, 7, 1, "ng-container", 7);
        i0.ɵɵtext(19, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(21, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n\n  ");
        i0.ɵɵtemplate(23, AdaptCheckbox2Component_span_23_Template, 1, 0, "span", 8);
        i0.ɵɵtext(24, "\n\n  ");
        i0.ɵɵtemplate(25, AdaptCheckbox2Component_adapt_icon_25_Template, 1, 3, "adapt-icon", 9);
        i0.ɵɵtext(26, "\n\n\n  ");
        i0.ɵɵtemplate(27, AdaptCheckbox2Component_adapt_icon_27_Template, 1, 5, "adapt-icon", 10);
        i0.ɵɵtext(28, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(29, "\n\n");
        i0.ɵɵprojection(30, 1);
        i0.ɵɵtext(31, "\n\n");
        i0.ɵɵtemplate(32, AdaptCheckbox2Component_div_32_Template, 5, 2, "div", 7);
        i0.ɵɵtext(33, "\n\n\n");
    } if (rf & 2) {
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("id", ctx.inputId)("disabled", ctx.context.disabled)("readOnly", ctx.context.readonly)("checked", ctx.checked)("required", ctx.context.required)("tabIndex", ctx.tabindex)("indeterminate", ctx.indeterminate);
        i0.ɵɵattribute("value", ctx.value)("name", ctx.context.name)("aria-readonly", ctx.readonly)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy)("aria-checked", ctx._getAriaChecked());
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(22, _c1, !ctx.context.label));
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(24, _c2, !ctx.context.label));
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.context.label);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.required);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.context.tooltipIconCls || ctx.context.popoverIcon);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.tooltipIconCls && !ctx.context.popoverIcon);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.popoverIcon);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.toggleMessage);
    } }, directives: [i3.NgClass, i3.NgIf, i1.AdaptIconComponent, i1.AdaptTooltipDirective, i1.AdaptPopoverDirective], styles: [".checkbox__item .adapt-icon { bottom: 0; }"], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptCheckbox2Component, [{
        type: Component,
        args: [{
                selector: 'adapt-checkbox2, div[adapt-checkbox2], adapt-checkbox',
                templateUrl: './checkbox2.component.html',
                providers: [
                    createFormControlValueAccessor(AdaptCheckbox2Component),
                    createFormControlValidator(AdaptCheckbox2Component)
                ],
                styles: ['.checkbox__item .adapt-icon { bottom: 0; }'],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i0.Injector }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i1.AdaptRadarAngularCustomEventName, decorators: [{
                type: Optional
            }] }]; }, { class: [{
            type: Input
        }], id: [{
            type: Input
        }], name: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], stopPropagation: [{
            type: Input
        }], value: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input
        }], displayMessage: [{
            type: Input
        }], toggleMessage: [{
            type: Input
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], change: [{
            type: Output
        }], indeterminateChange: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], indeterminate: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
//# sourceMappingURL=checkbox2.component.js.map