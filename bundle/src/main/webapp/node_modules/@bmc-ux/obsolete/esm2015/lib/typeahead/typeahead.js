/* eslint-disable @typescript-eslint/no-explicit-any */
import { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, forwardRef, Injector, Input, NgZone, Output, Renderer2, TemplateRef, ViewContainerRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { AdaptTypeaheadModel } from './typeahead.config';
import { AdaptTypeaheadWindowComponent } from './typeahead-window';
import { distinctUntilChanged, map, mergeMap, skipWhile, switchMap, take, tap } from 'rxjs/operators';
import { BehaviorSubject, EMPTY, fromEvent, merge, of, Subject } from 'rxjs';
import { Live, PopupService, LayerService, AdaptDeviceDetectionService, positionElements, getEventKeyCode, isDefined, SafeCdr, toString } from '@bmc-ux/adapt-angular';
import * as i0 from "@angular/core";
import * as i1 from "./typeahead.config";
import * as i2 from "@bmc-ux/adapt-angular";
var Key;
(function (Key) {
    Key[Key["Tab"] = 9] = "Tab";
    Key[Key["Enter"] = 13] = "Enter";
    Key[Key["Escape"] = 27] = "Escape";
    Key[Key["ArrowUp"] = 38] = "ArrowUp";
    Key[Key["ArrowDown"] = 40] = "ArrowDown";
})(Key || (Key = {}));
const NGB_TYPEAHEAD_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptTypeaheadDirective),
    multi: true
};
let nextWindowId = 0;
/**
 * NgbTypeahead directive provides a simple way of creating powerful typeaheads from any text input
 */
export class AdaptTypeaheadDirective {
    constructor(_elementRef, _viewContainerRef, _renderer, _injector, componentFactoryResolver, config, ngZone, _live, _layerService, _deviceDetection, _applicationRef) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._renderer = _renderer;
        this._injector = _injector;
        this._live = _live;
        this._layerService = _layerService;
        this._deviceDetection = _deviceDetection;
        this._applicationRef = _applicationRef;
        /**
         * Value for the configurable autocomplete attribute.
         * Defaults to 'off' to disable the native browser autocomplete, but this standard value does not seem
         * to be always correctly taken into account.
         */
        this.autocomplete = 'off';
        /**
         * Disables result provisioning while true
         */
        this.preventResults = false;
        /**
         * Placement of a typeahead accepts:
         * "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
         * "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
         * and array of above values.
         */
        this.placement = 'auto';
        /**
         * Open popup on focus
         */
        this.openOnFocus = false;
        /**
         * An event emitted when a match is selected. Event payload is of type NgbTypeaheadSelectItemEvent.
         */
        this.selectItem = new EventEmitter();
        /**
         * An event emitted when a typeAhead drop down is shown.
         */
        this.typeAheadPopupOpen = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onBlur = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onFocus = new EventEmitter();
        this.popupId = `ngb-typeahead-${nextWindowId++}`;
        this._openOnFocus$ = new Subject();
        this._isIE = false;
        this._onTouched = () => {
            return;
        };
        this._onChange = () => {
            return;
        };
        this.container = config.container;
        this.editable = config.editable;
        this.focusFirst = config.focusFirst;
        this.showHint = config.showHint;
        this.placement = config.placement;
        this._valueChanges = fromEvent(_elementRef.nativeElement, 'input')
            .pipe(map($event => $event.target.value), mergeMap((value) => {
            // IE11 emit input event while placeholder contain spec. caracters
            // fix for the issue https://github.bmc.com/bmc-ux/adapt-angular/issues/2836
            // if it's IE need to check if input is focused, if statement is true - emit event
            if (this._isIE) {
                return this._activeElement === this._elementRef.nativeElement ? of(value) : EMPTY;
            }
            else {
                return of(value);
            }
        }));
        this._resubscribeTypeahead = new BehaviorSubject(null);
        this._popupService = new PopupService(AdaptTypeaheadWindowComponent, _injector, _viewContainerRef, _renderer, componentFactoryResolver, _applicationRef);
        this._zoneSubscription = ngZone.onStable.subscribe(() => {
            if (this.isPopupOpen()) {
                const host = this.positionTo || this._elementRef.nativeElement;
                positionElements(host, this._windowRef.location.nativeElement, this.placement, this.container === 'body');
            }
        });
        this._setValueSubscription$ = ngZone.onStable.pipe(take(1)).subscribe(() => {
            this._inputValueBackup = this._elementRef.nativeElement.value;
        });
    }
    get _activeElement() {
        return document.activeElement;
    }
    ngOnInit() {
        this._isIE = this._deviceDetection.isIE();
        const inputValues$ = this._valueChanges.pipe(distinctUntilChanged(), tap(value => {
            this._inputValueBackup = value;
            if (this.editable) {
                this._onChange(value);
            }
        }));
        const focus$ = merge(inputValues$, this._openOnFocus$);
        const results$ = focus$.pipe(this.ngbTypeahead);
        const processedResults$ = results$.pipe(skipWhile(() => this.preventResults)).pipe(tap((val) => {
            if (!this.editable) {
                const correctValue = val.filter(function (v) {
                    let newValue = this.backupValue;
                    if (newValue) {
                        newValue = newValue.toLowerCase();
                    }
                    if (this.formatter) {
                        v = this.formatter(v);
                    }
                    return newValue === v.toLowerCase();
                    // if (typeof v === 'string' || v instanceof String) {
                    //   return newValue === v.toLowerCase();
                    // } else if (v.name) { // TODO: change logic to work with any object data
                    //   return newValue === v.name.toLowerCase();
                    // } else if (v.dataValue) {
                    //   return newValue === v.dataValue.toLowerCase();
                    // } else {
                    //   return false;
                    // }
                }, { 'backupValue': this._inputValueBackup, 'formatter': this.inputFormatter });
                val.length ? this._onChange(correctValue[0]) : this._onChange(undefined);
            }
        }));
        const userInput$ = this._resubscribeTypeahead.pipe(switchMap(() => processedResults$));
        this._subscription = this._subscribeToUserInput(userInput$);
    }
    ngOnDestroy() {
        this._closePopup();
        this._unsubscribeFromUserInput();
        this._zoneSubscription.unsubscribe();
        this._setValueSubscription$.unsubscribe();
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    writeValue(value) {
        this._inputValueBackup = this._formatItemForInput(value);
        this._writeInputValue(this._formatItemForInput(value));
        // while [(ngModel)] value changed outside need to update the list by correct items
        setTimeout(() => {
            if (this.isPopupOpen() && this._elementRef) {
                this._emitInputEvent();
            }
        });
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    onDocumentClick(event) {
        if (event.target !== this._elementRef.nativeElement) {
            this.dismissPopup();
        }
    }
    /**
     * Dismisses typeahead popup window
     */
    dismissPopup() {
        if (this.isPopupOpen()) {
            this._closePopup();
            this._writeInputValue(this._inputValueBackup);
        }
    }
    /**
     * Returns true if the typeahead popup window is displayed
     */
    isPopupOpen() {
        return this._windowRef != null;
    }
    handleBlur(event) {
        this.onBlur.emit(event);
        this._resubscribeTypeahead.next(null);
        this._onTouched();
    }
    handleFocus(event) {
        this.onFocus.emit(event);
        if (this.openOnFocus) {
            this._openOnFocus$.next(this._inputValueBackup);
            return;
        }
        this.typeAheadPopupOpen.emit({ text: this._inputValueBackup, open: false });
    }
    handleKeyDown(event) {
        if (!this.isPopupOpen()) {
            return;
        }
        const keyCode = getEventKeyCode(event);
        if (Key[toString(keyCode)]) {
            switch (keyCode) {
                case Key.ArrowDown:
                    event.preventDefault();
                    this._windowRef.instance.next();
                    this._showHint();
                    break;
                case Key.ArrowUp:
                    event.preventDefault();
                    this._windowRef.instance.prev();
                    this._showHint();
                    break;
                case Key.Enter:
                case Key.Tab: {
                    const result = this._windowRef.instance.getActive();
                    if (isDefined(result)) {
                        event.preventDefault();
                        event.stopPropagation();
                        this._selectResult(result);
                    }
                    this._closePopup();
                    break;
                }
            }
        }
    }
    _openPopup() {
        if (!this.isPopupOpen()) {
            this.typeAheadPopupOpen.emit({ text: this._inputValueBackup, open: true });
            this._inputValueBackup = this._elementRef.nativeElement.value;
            this._windowRef = this._popupService.open();
            this._windowRef.instance.id = this.popupId;
            this._windowRef.instance.hostClass = this.popupClass;
            this._windowRef.instance.appendedToBody = this.container === 'body';
            this._windowRef.instance.selectEvent.subscribe((result) => this._selectResultClosePopup(result));
            this._windowRef.instance.activeChangeEvent.subscribe((activeId) => this.activeDescendant = activeId);
            const menu = this._windowRef.location.nativeElement;
            if (this.container) {
                if (this.container === 'body') {
                    document.body.appendChild(menu);
                }
                else {
                    this.container.appendChild(menu);
                }
            }
            this._layerService.addComponent(this, (event) => {
                event.preventDefault();
                this._resubscribeTypeahead.next(null);
                this.dismissPopup();
            });
            if (!isDefined(this._documentListenerFunc)) {
                this._documentListenerFunc = this._renderer.listen('document', 'click', this.onDocumentClick.bind(this));
            }
        }
    }
    _closePopup() {
        this._popupService.close();
        this._windowRef = null;
        this.activeDescendant = undefined;
        this._layerService.removeComponent(this);
        this.typeAheadPopupOpen.emit({ text: this._inputValueBackup, open: false });
        if (isDefined(this._documentListenerFunc)) {
            this._documentListenerFunc();
            this._documentListenerFunc = null;
        }
    }
    _selectResult(result) {
        let defaultPrevented = false;
        this.selectItem.emit({
            item: result, preventDefault: () => {
                defaultPrevented = true;
            }
        });
        this._resubscribeTypeahead.next(null);
        if (!defaultPrevented) {
            if (this.inputFormatter) {
                this._inputValueBackup = this.inputFormatter(result);
            }
            else {
                this._inputValueBackup = result;
            }
            this.writeValue(result);
            this._onChange(result);
        }
    }
    _selectResultClosePopup(result) {
        this._selectResult(result);
        this._closePopup();
    }
    _showHint() {
        if (this.showHint && this._windowRef.instance.hasActive() && this._inputValueBackup != null) {
            const userInputLowerCase = this._inputValueBackup.toLowerCase();
            const formattedVal = this._formatItemForInput(this._windowRef.instance.getActive());
            if (userInputLowerCase === formattedVal.substr(0, this._inputValueBackup.length).toLowerCase()) {
                this._writeInputValue(this._inputValueBackup + formattedVal.substr(this._inputValueBackup.length));
                this._elementRef.nativeElement.setSelectionRange.apply(this._elementRef.nativeElement, [this._inputValueBackup.length, formattedVal.length]);
            }
            else {
                this._writeInputValue(this._formatItemForInput(this._windowRef.instance.getActive()));
            }
        }
    }
    _formatItemForInput(item) {
        return item != null && this.inputFormatter ? this.inputFormatter(item) : toString(item);
    }
    _writeInputValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', toString(value));
    }
    _subscribeToUserInput(userInput$) {
        return userInput$.subscribe((results) => {
            if (!results || results.length === 0) {
                this._closePopup();
            }
            else {
                this._openPopup();
                this._windowRef.instance.focusFirst = this.focusFirst;
                this._windowRef.instance.results = results;
                this._windowRef.instance.term = this._elementRef.nativeElement.value;
                this._windowRef.instance.virtualScroll = this.virtualScroll;
                this._windowRef.instance.virtualScrollItemSize = this.virtualScrollItemSize;
                this._windowRef.instance.virtualScrollDropdownWidth = this.virtualScrollDropdownWidth;
                this._windowRef.instance.virtualScrollDropdownHeight = this.virtualScrollDropdownHeight;
                if (this.resultFormatter) {
                    this._windowRef.instance.formatter = this.resultFormatter;
                }
                if (this.resultTemplate) {
                    this._windowRef.instance.resultTemplate = this.resultTemplate;
                }
                this._windowRef.instance.resetActive();
                // The observable stream we are subscribing to might have async steps
                // and if a component containing typeahead is using the OnPush strategy
                // the change detection turn wouldn't be invoked automatically.
                SafeCdr.detectChanges(this._windowRef.changeDetectorRef);
                this._showHint();
            }
            const count = results.length;
            this._live.say(count === 0 ? 'No results available' : `${count} result${count === 1 ? '' : 's'} available`);
        });
    }
    _emitInputEvent() {
        const event = new Event('input');
        this._elementRef.nativeElement.dispatchEvent(event);
    }
    _unsubscribeFromUserInput() {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
        this._subscription = null;
    }
}
AdaptTypeaheadDirective.ɵfac = function AdaptTypeaheadDirective_Factory(t) { return new (t || AdaptTypeaheadDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i1.AdaptTypeaheadModel), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.Live), i0.ɵɵdirectiveInject(i2.LayerService), i0.ɵɵdirectiveInject(i2.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ApplicationRef)); };
AdaptTypeaheadDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTypeaheadDirective, selectors: [["", "adaptTypeaheadDirective", ""], ["input", "ngbTypeahead", ""]], hostAttrs: ["autocapitalize", "off", "autocorrect", "off", "role", "combobox"], hostVars: 8, hostBindings: function AdaptTypeaheadDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("blur", function AdaptTypeaheadDirective_blur_HostBindingHandler($event) { return ctx.handleBlur($event); })("keydown", function AdaptTypeaheadDirective_keydown_HostBindingHandler($event) { return ctx.handleKeyDown($event); })("focus", function AdaptTypeaheadDirective_focus_HostBindingHandler($event) { return ctx.handleFocus($event); });
    } if (rf & 2) {
        i0.ɵɵhostProperty("autocomplete", ctx.autocomplete);
        i0.ɵɵattribute("aria-autocomplete", ctx.showHint ? "both" : "list")("aria-activedescendant", ctx.activeDescendant)("aria-owns", ctx.isPopupOpen() ? ctx.popupId : null)("aria-expanded", ctx.isPopupOpen())("aria-haspopup", "listbox");
        i0.ɵɵclassProp("open", ctx.isPopupOpen());
    } }, inputs: { autocomplete: "autocomplete", container: "container", editable: "editable", focusFirst: "focusFirst", inputFormatter: "inputFormatter", ngbTypeahead: "ngbTypeahead", preventResults: "preventResults", resultFormatter: "resultFormatter", resultTemplate: "resultTemplate", showHint: "showHint", popupClass: "popupClass", placement: "placement", positionTo: "positionTo", openOnFocus: "openOnFocus", virtualScroll: "virtualScroll", virtualScrollItemSize: "virtualScrollItemSize", virtualScrollDropdownWidth: "virtualScrollDropdownWidth", virtualScrollDropdownHeight: "virtualScrollDropdownHeight" }, outputs: { selectItem: "selectItem", typeAheadPopupOpen: "typeAheadPopupOpen", onBlur: "onBlur", onFocus: "onFocus" }, exportAs: ["ngbTypeahead"], features: [i0.ɵɵProvidersFeature([NGB_TYPEAHEAD_VALUE_ACCESSOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptTypeaheadDirective], input[ngbTypeahead]',
                exportAs: 'ngbTypeahead',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '(blur)': 'handleBlur($event)',
                    '[class.open]': 'isPopupOpen()',
                    '(keydown)': 'handleKeyDown($event)',
                    '(focus)': 'handleFocus($event)',
                    '[autocomplete]': 'autocomplete',
                    'autocapitalize': 'off',
                    'autocorrect': 'off',
                    'role': 'combobox',
                    '[attr.aria-autocomplete]': 'showHint ? "both" : "list"',
                    '[attr.aria-activedescendant]': 'activeDescendant',
                    '[attr.aria-owns]': 'isPopupOpen() ? popupId : null',
                    '[attr.aria-expanded]': 'isPopupOpen()',
                    '[attr.aria-haspopup]': '"listbox"'
                },
                providers: [NGB_TYPEAHEAD_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ComponentFactoryResolver }, { type: i1.AdaptTypeaheadModel }, { type: i0.NgZone }, { type: i2.Live }, { type: i2.LayerService }, { type: i2.AdaptDeviceDetectionService }, { type: i0.ApplicationRef }]; }, { autocomplete: [{
            type: Input
        }], container: [{
            type: Input
        }], editable: [{
            type: Input
        }], focusFirst: [{
            type: Input
        }], inputFormatter: [{
            type: Input
        }], ngbTypeahead: [{
            type: Input
        }], preventResults: [{
            type: Input
        }], resultFormatter: [{
            type: Input
        }], resultTemplate: [{
            type: Input
        }], showHint: [{
            type: Input
        }], popupClass: [{
            type: Input
        }], placement: [{
            type: Input
        }], positionTo: [{
            type: Input
        }], openOnFocus: [{
            type: Input
        }], virtualScroll: [{
            type: Input
        }], virtualScrollItemSize: [{
            type: Input
        }], virtualScrollDropdownWidth: [{
            type: Input
        }], virtualScrollDropdownHeight: [{
            type: Input
        }], selectItem: [{
            type: Output
        }], typeAheadPopupOpen: [{
            type: Output
        }], onBlur: [{
            type: Output
        }], onFocus: [{
            type: Output
        }] }); })();
//# sourceMappingURL=typeahead.js.map