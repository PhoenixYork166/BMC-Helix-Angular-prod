/* eslint-disable @typescript-eslint/no-explicit-any */
// Based on ng-bootstrap (https://github.com/ng-bootstrap/ng-bootstrap)
// Licensed under the MIT License
import { Component, ElementRef, EventEmitter, forwardRef, Injector, Input, Output, TemplateRef, ViewChild } from '@angular/core';
import { noop } from 'rxjs';
import { NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';
import { transition, trigger, useAnimation } from '@angular/animations';
import { AdaptTypeaheadConfig } from './typeahead.config';
import { AdaptRadarAngularCustomEventName, AdaptTranslateService, ANIMATION_NAME, hasRequiredValidator, toBoolean } from '@bmc-ux/adapt-angular';
import { AdaptRadarGenericDirective, AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "./typeahead.config";
import * as i2 from "@bmc-ux/adapt-angular";
import * as i3 from "@bmc-ux/adapt-radar";
import * as i4 from "@angular/forms";
import * as i5 from "./typeahead";
import * as i6 from "@angular/common";
const _c0 = ["input"];
function AdaptTypeaheadComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "p", 6);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r1.errorMessage);
} }
function AdaptTypeaheadComponent_div_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "p", 6);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r2.warningMessage);
} }
let nextId = 0;
export const TYPEAHEAD_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptTypeaheadComponent),
    multi: true
};
export class AdaptTypeaheadComponent extends AdaptRadarGenericDirective {
    constructor(config, ts, _injector, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptTypeahead);
        this.ts = ts;
        this._injector = _injector;
        /**
         * Unique id of the element.
         */
        this.id = `typeahead-${nextId++}`;
        /**
         * Placement of a typeahead accepts:
         * "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
         * "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
         * and array of above values.
         */
        this.placement = 'auto';
        this.disabled = false;
        this.readonly = false;
        /**
         * Open popup on focus
         */
        this.openOnFocus = false;
        /**
         * Enable virtual scroll for results window. Can be suitable for big amount of results
         */
        this.virtualScroll = false;
        /**
         * Used to set "itemSize" virtual scroll @Input()
         */
        this.virtualScrollItemSize = 30;
        /**
         * Used to set width for results dropdown
         */
        this.virtualScrollDropdownWidth = '25.625rem';
        /**
         * Used to set height for results dropdown
         */
        this.virtualScrollDropdownHeight = '13.75rem';
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        this.ariaLabel = null;
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        /**
         * The value for the `autocomplete` attribute for the `<input>` element.
         * @since v10.14.0
         */
        this.autocomplete = 'off';
        /**
         * An event emitted when a match is selected. Event payload is of type NgbTypeaheadSelectItemEvent.
         */
        this.selectItem = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.click = new EventEmitter();
        /**
         * The internal data model
         */
        this.innerValue = '';
        /** Actual value, event if it is not matching any typeahead options */
        this.actualInputValue = '';
        /**
         * If the typeAhead drop down is open
         */
        this.isTypeAheadOpen = true;
        /**
         * Placeholders for the callbacks which are later provided by the Control Value Accessor
         */
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this._isTouched = false;
        this._required = false;
        this.editable = config.editable;
        this.focusFirst = config.focusFirst;
        this.showHint = config.showHint;
        this.requiredLabel = ts.getCurrentLanguage()['adapt.common.required'];
    }
    /**
     * A function to transform the provided observable text into the array of results.
     * Note that the "this" argument is undefined so you need to explicitly bind it to a desired "this" target.
     */
    /*
      * Typeahead OperatorFunction
    */
    set typeahead(inputFunction) {
        this._typeahead = inputFunction;
    }
    get typeahead() {
        return this._typeahead;
    }
    /**
     * Append to body trigger
     */
    set appendToBody(state) {
        if (state && !this.appendToContainer) {
            this.appendTo = 'body';
        }
    }
    /**
     * When specified, the drop-down list will be appended to the selected element
     */
    set appendTo(element) {
        this.appendToContainer = element;
    }
    /** Whether the element is required. */
    get required() {
        return this._required || hasRequiredValidator(this._ngControl);
    }
    set required(value) {
        this._required = toBoolean(value);
    }
    /**
     * get accessor
     */
    get value() {
        return this.innerValue;
    }
    /**
     * set accessor including call the onchange callback
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
        this.updateError();
    }
    ngOnInit() {
        this._ngControl = this._injector.get(NgControl, null);
    }
    onFocus(event) {
        this.focus.emit(event);
    }
    onSelect(event) {
        this.selectItem.emit(event);
    }
    /**
     * Triggered when typeAhead drop down is open or closed
     */
    typeAheadPopUpChange(event) {
        this.isTypeAheadOpen = event.open;
        // When input text is empty set as empty instead of undefined
        if (!event.text) {
            this.innerValue = '';
        }
        this.updateError();
    }
    /**
     * Update the error UI
     */
    updateError() {
        if (!this._isTouched && (this.isTypeAheadOpen || this.required)) {
            this.isError = false;
            return;
        }
        this.isError = ((this.required && !this.innerValue) || (!this.editable && this.innerValue === undefined)) && !this.actualInputValue;
    }
    updateWarning() {
        this.isWarning = !this.editable && this._isTouched
            && !this.innerValue && this.actualInputValue && !this.isTypeAheadOpen;
    }
    onInputChange(event) {
        this.actualInputValue = event.target['value'];
    }
    /**
     * Set touched on blur
     */
    onBlur(event) {
        this._isTouched = true;
        this.onTouchedCallback();
        this.blur.emit(event);
        this.updateError();
        this.updateWarning();
    }
    /**
     * From ControlValueAccessor interface
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
        this.updateError();
    }
    /**
     * From ControlValueAccessor interface
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * From ControlValueAccessor interface
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
AdaptTypeaheadComponent.ɵfac = function AdaptTypeaheadComponent_Factory(t) { return new (t || AdaptTypeaheadComponent)(i0.ɵɵdirectiveInject(i1.AdaptTypeaheadConfig), i0.ɵɵdirectiveInject(i2.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i3.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptTypeaheadComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTypeaheadComponent, selectors: [["adapt-typeahead"]], viewQuery: function AdaptTypeaheadComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    } }, hostAttrs: [1, "typeahead"], inputs: { typeahead: "typeahead", label: "label", description: "description", id: "id", editable: "editable", focusFirst: "focusFirst", showHint: "showHint", inputFormatter: "inputFormatter", resultFormatter: "resultFormatter", resultTemplate: "resultTemplate", placeholder: "placeholder", placement: "placement", errorMessage: "errorMessage", warningMessage: "warningMessage", disabled: "disabled", readonly: "readonly", appendToBody: "appendToBody", positionTo: "positionTo", appendTo: "appendTo", requiredLabel: "requiredLabel", openOnFocus: "openOnFocus", virtualScroll: "virtualScroll", virtualScrollItemSize: "virtualScrollItemSize", virtualScrollDropdownWidth: "virtualScrollDropdownWidth", virtualScrollDropdownHeight: "virtualScrollDropdownHeight", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"], autocomplete: "autocomplete", required: "required" }, outputs: { selectItem: "selectItem", focus: "focus", blur: "blur", click: "click" }, features: [i0.ɵɵProvidersFeature([TYPEAHEAD_VALUE_ACCESSOR]), i0.ɵɵInheritDefinitionFeature], decls: 12, vars: 37, consts: [[1, "dropdown", "show"], [3, "for", "label", "requiredLabel", "subLabel", "showRequiredLabel"], ["type", "text", 1, "form-control", 3, "ngModel", "ngbTypeahead", "preventResults", "disabled", "readOnly", "container", "virtualScroll", "virtualScrollItemSize", "virtualScrollDropdownWidth", "virtualScrollDropdownHeight", "positionTo", "placement", "required", "editable", "showHint", "focusFirst", "inputFormatter", "resultFormatter", "resultTemplate", "placeholder", "openOnFocus", "autocomplete", "ngModelChange", "selectItem", "typeAheadPopupOpen", "click", "onBlur", "onFocus", "input"], ["input", ""], ["role", "alert", 4, "ngIf"], ["role", "alert"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"]], template: function AdaptTypeaheadComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵelement(3, "adapt-rx-control-label", 1);
        i0.ɵɵtext(4, "\n      ");
        i0.ɵɵelementStart(5, "input", 2, 3);
        i0.ɵɵlistener("ngModelChange", function AdaptTypeaheadComponent_Template_input_ngModelChange_5_listener($event) { return ctx.value = $event; })("selectItem", function AdaptTypeaheadComponent_Template_input_selectItem_5_listener($event) { return ctx.onSelect($event); })("typeAheadPopupOpen", function AdaptTypeaheadComponent_Template_input_typeAheadPopupOpen_5_listener($event) { return ctx.typeAheadPopUpChange($event); })("click", function AdaptTypeaheadComponent_Template_input_click_5_listener($event) { return ctx.click.emit($event); })("onBlur", function AdaptTypeaheadComponent_Template_input_onBlur_5_listener($event) { return ctx.onBlur($event); })("onFocus", function AdaptTypeaheadComponent_Template_input_onFocus_5_listener($event) { return ctx.onFocus($event); })("input", function AdaptTypeaheadComponent_Template_input_input_5_listener($event) { return ctx.onInputChange($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(7, "\n\n      ");
        i0.ɵɵtemplate(8, AdaptTypeaheadComponent_div_8_Template, 5, 2, "div", 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵtemplate(10, AdaptTypeaheadComponent_div_10_Template, 5, 2, "div", 4);
        i0.ɵɵtext(11, "\n    ");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵclassProp("has-warning", ctx.isWarning && !ctx.isError)("has-danger", !ctx.isWarning && ctx.isError);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("subLabel", ctx.description)("showRequiredLabel", ctx.required);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngModel", ctx.value)("ngbTypeahead", ctx.typeahead)("preventResults", ctx.disabled || ctx.readonly)("disabled", ctx.disabled)("readOnly", ctx.readonly)("container", ctx.appendToContainer)("virtualScroll", ctx.virtualScroll)("virtualScrollItemSize", ctx.virtualScrollItemSize)("virtualScrollDropdownWidth", ctx.virtualScrollDropdownWidth)("virtualScrollDropdownHeight", ctx.virtualScrollDropdownHeight)("positionTo", ctx.positionTo)("placement", ctx.placement)("required", ctx.required)("editable", ctx.editable)("showHint", ctx.showHint)("focusFirst", ctx.focusFirst)("inputFormatter", ctx.inputFormatter)("resultFormatter", ctx.resultFormatter)("resultTemplate", ctx.resultTemplate)("placeholder", ctx.placeholder || "")("openOnFocus", ctx.openOnFocus)("autocomplete", ctx.autocomplete);
        i0.ɵɵattribute("id", ctx.id)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.errorMessage && ctx.isError && !ctx.isWarning);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.warningMessage && ctx.isWarning && !ctx.isError);
    } }, directives: [i2.AdaptRxControlLabelComponent, i2.AdaptDragonInputHandlerDirective, i4.DefaultValueAccessor, i5.AdaptTypeaheadDirective, i4.NgControlStatus, i4.NgModel, i4.RequiredValidator, i6.NgIf], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-typeahead',
                template: `
    <div class="dropdown show"
         [class.has-warning]="isWarning && !isError"
         [class.has-danger]="!isWarning && isError">
      <adapt-rx-control-label [for]="id"
                              [label]="label"
                              [requiredLabel]="requiredLabel"
                              [subLabel]="description"
                              [showRequiredLabel]="required"></adapt-rx-control-label>
      <input #input
             type="text"
             class="form-control"
             [attr.id]="id"
             [(ngModel)]="value"
             [ngbTypeahead]="typeahead"
             [preventResults]="disabled || readonly"
             [disabled]="disabled"
             [readOnly]="readonly"
             [container]="appendToContainer"
             [virtualScroll]="virtualScroll"
             [virtualScrollItemSize]="virtualScrollItemSize"
             [virtualScrollDropdownWidth]="virtualScrollDropdownWidth"
             [virtualScrollDropdownHeight]="virtualScrollDropdownHeight"
             [positionTo]="positionTo"
             [placement]="placement"
             [required]="required"
             [editable]="editable"
             [showHint]="showHint"
             [focusFirst]="focusFirst"
             [inputFormatter]="inputFormatter"
             [resultFormatter]="resultFormatter"
             [resultTemplate]="resultTemplate"
             [placeholder]="placeholder || ''"
             [openOnFocus]="openOnFocus"
             [autocomplete]="autocomplete"
             [attr.aria-label]="ariaLabel"
             [attr.aria-labelledby]="ariaLabelledby"
             [attr.aria-describedby]="ariaDescribedBy"
             (selectItem)="onSelect($event)"
             (typeAheadPopupOpen)="typeAheadPopUpChange($event)"
             (click)="click.emit($event)"
             (onBlur)="onBlur($event)"
             (onFocus)="onFocus($event)"
             (input)="onInputChange($event)"/>

      <div *ngIf="errorMessage && isError && !isWarning" [@validationFeedbackAnimation] role="alert">
        <p class="form-control-feedback m-0 pt-1 pb-2">{{errorMessage}}</p>
      </div>
      <div *ngIf="warningMessage && isWarning && !isError" [@validationFeedbackAnimation] role="alert">
        <p class="form-control-feedback m-0 pt-1 pb-2">{{warningMessage}}</p>
      </div>
    </div>`,
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ],
                providers: [TYPEAHEAD_VALUE_ACCESSOR],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: { 'class': 'typeahead' }
            }]
    }], function () { return [{ type: i1.AdaptTypeaheadConfig }, { type: i2.AdaptTranslateService }, { type: i0.Injector }, { type: i3.AdaptRadarService }, { type: i0.ElementRef }]; }, { typeahead: [{
            type: Input
        }], label: [{
            type: Input
        }], description: [{
            type: Input
        }], id: [{
            type: Input
        }], editable: [{
            type: Input
        }], focusFirst: [{
            type: Input
        }], showHint: [{
            type: Input
        }], inputFormatter: [{
            type: Input
        }], resultFormatter: [{
            type: Input
        }], resultTemplate: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], placement: [{
            type: Input
        }], errorMessage: [{
            type: Input
        }], warningMessage: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], positionTo: [{
            type: Input
        }], appendTo: [{
            type: Input
        }], requiredLabel: [{
            type: Input
        }], openOnFocus: [{
            type: Input
        }], virtualScroll: [{
            type: Input
        }], virtualScrollItemSize: [{
            type: Input
        }], virtualScrollDropdownWidth: [{
            type: Input
        }], virtualScrollDropdownHeight: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], autocomplete: [{
            type: Input
        }], inputElement: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], selectItem: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], click: [{
            type: Output
        }], required: [{
            type: Input
        }] }); })();
//# sourceMappingURL=typeahead.component.js.map