// TODO update types if possible
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ChangeDetectorRef, Component, ElementRef, EventEmitter, forwardRef, Inject, InjectionToken, Injector, Input, NgZone, Optional, Output, Renderer2, ViewChild, ViewEncapsulation } from '@angular/core';
import { FormControl, NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';
import { transition, trigger, useAnimation } from '@angular/animations';
import { fromEvent, ReplaySubject } from 'rxjs';
import { debounceTime, distinctUntilChanged, take, takeUntil, tap } from 'rxjs/operators';
import { Directionality } from '@angular/cdk/bidi';
import { AdaptRadarAngularCustomEventName, AdaptTranslateService, ANIMATION_NAME, debounce, getElementStyles, hasRequiredValidator, ResizeService, SafeCdr, toBoolean, toNumber } from '@bmc-ux/adapt-angular';
import { AdaptRadarGenericDirective, AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@bmc-ux/adapt-angular";
import * as i2 from "@angular/cdk/bidi";
import * as i3 from "@bmc-ux/adapt-radar";
import * as i4 from "@angular/common";
import * as i5 from "./textfield.icons";
import * as i6 from "@angular/forms";
const _c0 = ["input"];
const _c1 = ["inputTextWidthEl"];
function AdaptTextFieldComponent_adapt_textfield_icons_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-textfield-icons", 11);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("error", ctx_r0.isError)("success", !ctx_r0.isError)("iconValid", ctx_r0.iconValid)("iconInvalid", ctx_r0.iconInvalid);
} }
function AdaptTextFieldComponent_textarea_11_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "textarea", 12, 13);
    i0.ɵɵlistener("keydown", function AdaptTextFieldComponent_textarea_11_Template_textarea_keydown_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.onKeydown($event); })("keypress", function AdaptTextFieldComponent_textarea_11_Template_textarea_keypress_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.onKeypress($event); })("keyup", function AdaptTextFieldComponent_textarea_11_Template_textarea_keyup_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.onKeyup($event); })("ngModelChange", function AdaptTextFieldComponent_textarea_11_Template_textarea_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.value = $event; })("focus", function AdaptTextFieldComponent_textarea_11_Template_textarea_focus_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.onFocus($event); })("blur", function AdaptTextFieldComponent_textarea_11_Template_textarea_blur_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.onBlur($event); });
    i0.ɵɵtext(2, "  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r1.customClass, "");
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r1.readonly && ctx_r1.disabledStyleForReadonlyState);
    i0.ɵɵproperty("rows", ctx_r1.rows)("ngModel", ctx_r1.value)("disabled", ctx_r1.disabled)("required", ctx_r1.required)("autofocus", ctx_r1.autofocus)("readonly", ctx_r1.readonly)("placeholder", ctx_r1.placeholder ? ctx_r1.placeholder : "")("pattern", ctx_r1.pattern ? ctx_r1.pattern : ".*");
    i0.ɵɵattribute("name", ctx_r1.name)("aria-required", ctx_r1.required)("aria-invalid", !ctx_r1.disabled && !ctx_r1.control && !ctx_r1.validState && ctx_r1.isError)("aria-label", ctx_r1.arialabel || null)("aria-describedby", ctx_r1.ariaDescribedBy)("id", ctx_r1.id + "_textarea")("data-testid", ctx_r1.testID + "_textarea")("maxlength", ctx_r1.maxlength)("minlength", ctx_r1.minlength)("tabindex", ctx_r1.tabindex);
} }
function AdaptTextFieldComponent_input_13_Template(rf, ctx) { if (rf & 1) {
    const _r18 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "input", 14, 13);
    i0.ɵɵlistener("keydown", function AdaptTextFieldComponent_input_13_Template_input_keydown_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.onKeydown($event); })("keypress", function AdaptTextFieldComponent_input_13_Template_input_keypress_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.onKeypress($event); })("keyup", function AdaptTextFieldComponent_input_13_Template_input_keyup_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.onKeyup($event); })("ngModelChange", function AdaptTextFieldComponent_input_13_Template_input_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.value = $event; })("focus", function AdaptTextFieldComponent_input_13_Template_input_focus_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r22 = i0.ɵɵnextContext(); return ctx_r22.onFocus($event); })("blur", function AdaptTextFieldComponent_input_13_Template_input_blur_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r23 = i0.ɵɵnextContext(); return ctx_r23.onBlur($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r2.customClass, "");
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r2.readonly && ctx_r2.disabledStyleForReadonlyState)("textfield-padding-transition", ctx_r2.overflowText)("pl-0", ctx_r2.isTextOverflow && !ctx_r2.isRtl)("pr-0", ctx_r2.isTextOverflow && ctx_r2.isRtl);
    i0.ɵɵproperty("type", ctx_r2.type)("ngModel", ctx_r2.value)("disabled", ctx_r2.disabled)("required", ctx_r2.required)("autofocus", ctx_r2.autofocus)("readonly", ctx_r2.readonly)("autocomplete", ctx_r2.autocomplete ? ctx_r2.autocomplete : "on")("placeholder", ctx_r2.placeholder ? ctx_r2.placeholder : "")("pattern", ctx_r2.pattern ? ctx_r2.pattern : ".*");
    i0.ɵɵattribute("name", ctx_r2.name)("aria-required", ctx_r2.required)("aria-invalid", !ctx_r2.disabled && !ctx_r2.control && !ctx_r2.validState && ctx_r2.isError)("aria-label", ctx_r2.arialabel || null)("aria-describedby", ctx_r2.ariaDescribedBy)("id", ctx_r2.id + "_input")("data-testid", ctx_r2.testID + "_input")("maxlength", ctx_r2.maxlength)("minlength", ctx_r2.minlength)("min", ctx_r2.min)("max", ctx_r2.max)("step", ctx_r2.step)("tabindex", ctx_r2.tabindex);
} }
function AdaptTextFieldComponent_div_15_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 18);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r24.nestedSettings.addOnTextLeft);
} }
function AdaptTextFieldComponent_div_15_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 20);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r26 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("z-index", "34");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r26.nestedSettings.addOnTextRight);
} }
function AdaptTextFieldComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    const _r28 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptTextFieldComponent_div_15_div_2_Template, 5, 1, "div", 16);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementStart(4, "input", 14, 13);
    i0.ɵɵlistener("keydown", function AdaptTextFieldComponent_div_15_Template_input_keydown_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r27 = i0.ɵɵnextContext(); return ctx_r27.onKeydown($event); })("keypress", function AdaptTextFieldComponent_div_15_Template_input_keypress_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r29 = i0.ɵɵnextContext(); return ctx_r29.onKeypress($event); })("keyup", function AdaptTextFieldComponent_div_15_Template_input_keyup_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r30 = i0.ɵɵnextContext(); return ctx_r30.onKeyup($event); })("ngModelChange", function AdaptTextFieldComponent_div_15_Template_input_ngModelChange_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r31 = i0.ɵɵnextContext(); return ctx_r31.value = $event; })("focus", function AdaptTextFieldComponent_div_15_Template_input_focus_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r32 = i0.ɵɵnextContext(); return ctx_r32.onFocus($event); })("blur", function AdaptTextFieldComponent_div_15_Template_input_blur_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r33 = i0.ɵɵnextContext(); return ctx_r33.onBlur($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵtemplate(7, AdaptTextFieldComponent_div_15_div_7_Template, 5, 3, "div", 17);
    i0.ɵɵtext(8, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", ctx_r3.inputGroupClass);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.nestedSettings.addOnLeft);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r3.customClass, "");
    i0.ɵɵclassProp("textfield-padding-transition", ctx_r3.overflowText)("pl-0", ctx_r3.isTextOverflow && !ctx_r3.isRtl)("pr-0", ctx_r3.isTextOverflow && ctx_r3.isRtl);
    i0.ɵɵproperty("type", ctx_r3.type)("ngModel", ctx_r3.value)("disabled", ctx_r3.disabled)("required", ctx_r3.required)("autofocus", ctx_r3.autofocus)("readonly", ctx_r3.readonly)("autocomplete", ctx_r3.autocomplete ? ctx_r3.autocomplete : "on")("placeholder", ctx_r3.placeholder ? ctx_r3.placeholder : "")("pattern", ctx_r3.pattern ? ctx_r3.pattern : ".*");
    i0.ɵɵattribute("name", ctx_r3.name)("aria-required", ctx_r3.required)("aria-invalid", !ctx_r3.disabled && !ctx_r3.control && !ctx_r3.validState && ctx_r3.isError)("aria-label", ctx_r3.arialabel || null)("aria-describedby", ctx_r3.ariaDescribedBy)("id", ctx_r3.id + "_input")("data-testid", ctx_r3.testID + "_input")("maxlength", ctx_r3.maxlength)("minlength", ctx_r3.minlength)("min", ctx_r3.min)("max", ctx_r3.max)("step", ctx_r3.step)("tabindex", ctx_r3.tabindex);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r3.nestedSettings.addOnRight);
} }
function AdaptTextFieldComponent_div_18_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 23);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "span");
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r34 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("@validationFeedbackChangeAnimation", ctx_r34.isError);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r34.isError ? ctx_r34.errorMessage : !ctx_r34.isError && ctx_r34.isDirty ? ctx_r34.successMessage : "");
} }
function AdaptTextFieldComponent_div_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTextFieldComponent_div_18_p_2_Template, 5, 2, "p", 22);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.errorMessage && ctx_r4.errorMessage !== "" || ctx_r4.successMessage && ctx_r4.successMessage !== "");
} }
function AdaptTextFieldComponent_div_20_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 23);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r35 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n    ", ctx_r35.errorMessage, "\n  ");
} }
function AdaptTextFieldComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTextFieldComponent_div_20_p_2_Template, 2, 1, "p", 22);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.errorMessage && ctx_r5.errorMessage !== "");
} }
function AdaptTextFieldComponent_div_22_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 23);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r36 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n    ", ctx_r36.additionalMessage, "\n  ");
} }
function AdaptTextFieldComponent_div_22_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTextFieldComponent_div_22_p_2_Template, 2, 1, "p", 22);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.additionalMessage && ctx_r6.additionalMessage !== "");
} }
function AdaptTextFieldComponent_div_26_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 24, 25);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", ctx_r7.inputStyles);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r7.value);
} }
const _c2 = [[["", "label-count", ""]], "*"];
const _c3 = ["[label-count]", "*"];
let nextId = 0;
const noop = () => {
    return;
};
const cssTextFieldClasses = {
    FOCUS: 'is-focus',
    // REQUIRED: 'is-required', // not used yet
    // DIRTY: 'is-dirty',
    // NG_DIRTY: 'ng-dirty',
    NG_TOUCHED: 'ng-touched',
    // PRISTINE: 'is-pristine',
    FORM_SUCCESS: 'has-success',
    FORM_DANGER: 'has-danger',
    // VALID: 'form-control-success',
    // IN_VALID: 'form-control-danger'
};
export const DISABLE_NATIVE_VALIDITY_CHECKING = new InjectionToken('disableNativeValidityChecking');
export const ADAPT_TEXTFIELD_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptTextFieldComponent),
    multi: true
};
export class AdaptTextFieldComponent extends AdaptRadarGenericDirective {
    constructor(elemRef, renderer, _resizeService, _dir, ts, _ngZone, _cdr, _injector, nativeCheckGlobalDisabled, _adaptRadarService) {
        super(_adaptRadarService, elemRef, AdaptRadarAngularCustomEventName.AdaptTextField);
        this.elemRef = elemRef;
        this.renderer = renderer;
        this._resizeService = _resizeService;
        this._dir = _dir;
        this.ts = ts;
        this._ngZone = _ngZone;
        this._cdr = _cdr;
        this._injector = _injector;
        this.nativeCheckGlobalDisabled = nativeCheckGlobalDisabled;
        /**
         * Public variables of textfield component
         */
        this.isError = false;
        this.isDirty = false;
        /**
         * addOnTextLeft: string; addOnTextRight: string; addOnLeft: boolean; addOnRight: boolean
         */
        this.nestedSettingsDefault = {
            addOnLeft: true,
            addOnRight: false,
            addOnTextLeft: '@'
        };
        this.inputStyles = null;
        this.isTextOverflow = false;
        this.isRtl = false;
        this.defaultTexts = {};
        this.overflowText = true;
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * The input element type {bs4 view}.
         */
        this.nested = false;
        /**
         * The input element type; by default is 'text'
         */
        this.type = 'text';
        /**
         * Unique id of the element.
         */
        this.id = `adapt-textfield-${nextId++}`;
        /**
         * Unique testID of the element.
         */
        this.testID = `adapt-textfield-${nextId++}`;
        /**
         * Whether the input is with success icon
         */
        this.iconValid = false;
        /**
         * Whether the input is with error icon
         */
        this.iconInvalid = true;
        /**
         * TabIndex attribute of the element
         */
        this.tabindex = null;
        /**
         * Maxlength attribute of the element
         */
        this.maxlength = null;
        /**
         * Minlength attribute of the element
         */
        this.minlength = 0;
        /**
         * Autocomplete attribute of the element.
         */
        this.autocomplete = 'off';
        /**
         * Whether the input is valid
         */
        this.validState = false;
        this.popoverPlacement = 'top';
        this.popoverTriggers = 'click';
        this.setInvalidState = false;
        this.debounceTime = 300;
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.focusEmitter = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.blurEmitter = new EventEmitter();
        this.valueChanged = new EventEmitter();
        this.inputKeydown = new EventEmitter();
        this.inputKeypress = new EventEmitter();
        this.inputKeyup = new EventEmitter();
        /**
         * Use disabled style for the control if [readonly]=true
         */
        this.disabledStyleForReadonlyState = false;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        /**
         * ControlValueAccessor required interface
         */
        this.onTouchedCallback = noop;
        /**
         * ControlValueAccessor required interface
         */
        this.onChangeCallback = noop;
        /**
         * Private variables of textfield component
         */
        this._required = false;
        this._disabled = false;
        this._readonly = false;
        this._rows = null;
        this._disableNativeValidityChecking = false;
        this._maxrows = -1;
        this._autofocus = false;
        this._destroyed$ = new ReplaySubject(1);
        this.el = elemRef.nativeElement;
        this.isRtl = _dir.value === 'rtl';
        this.renderer = renderer;
        const translation = ts.getCurrentLanguage();
        this._successMessage = this.defaultTexts.valid = translation['adapt.textfield.error.valid'];
        this._errorMessage = this.defaultTexts.invalid = translation['adapt.textfield.error.invalid'];
        this.requiredLabel = translation['adapt.common.required'];
    }
    /**
     * An object used to control when error/success messages are shown
     */
    get errorMessage() {
        return this._errorMessage;
    }
    set errorMessage(value) {
        this._errorMessage = value || this.defaultTexts.invalid;
    }
    get successMessage() {
        return this._successMessage;
    }
    set successMessage(value) {
        this._successMessage = value || this.defaultTexts.valid;
    }
    /** Whether the element is required. */
    get required() {
        return this._required || hasRequiredValidator(this.control || this._ngControl);
    }
    set required(value) {
        this._required = toBoolean(value);
    }
    /** Whether the element is disabled. */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = toBoolean(value);
    }
    /** Whether the element is readonly. */
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        this._readonly = toBoolean(value);
    }
    /** Whether the element is textarea. */
    get rows() {
        return this._rows;
    }
    set rows(value) {
        this._rows = toNumber(value);
    }
    /** Whether the element has maxrows. */
    get maxrows() {
        return this._maxrows;
    }
    set maxrows(value) {
        this._maxrows = toNumber(value);
    }
    /** Whether the element has autofocus. */
    get autofocus() {
        return this._autofocus;
    }
    set autofocus(value) {
        this._autofocus = toBoolean(value);
    }
    // @experimental
    get disableNativeValidityChecking() {
        return this._disableNativeValidityChecking;
    }
    set disableNativeValidityChecking(value) {
        this._disableNativeValidityChecking = toBoolean(value);
    }
    /** The input element's value. */
    get value() {
        return this._value;
    }
    set value(v) {
        if (v !== this._value) {
            this._value = v;
            this.onChangeCallback(v);
        }
    }
    get ariaLabel() {
        return this.arialabel;
    }
    set ariaLabel(v) {
        if (v) {
            this.arialabel = v;
        }
    }
    get inputGroupClass() {
        let groupClass = '';
        if (this.customClass) {
            const classList = this.customClass.split(' ');
            classList.forEach(cls => {
                if (cls === 'form-control-lg') {
                    groupClass = 'input-group-lg';
                }
                if (cls === 'form-control-sm') {
                    groupClass = 'input-group-sm';
                }
            });
        }
        return groupClass;
    }
    get additionalMessage() {
        if (this.control) {
            for (const propertyName in this.control.errors) {
                if (Object.prototype.hasOwnProperty.call(this.control.errors, propertyName) && this.control.touched) {
                    return this.errorMessage ? this.errorMessage : this.defaultTexts.invalid;
                }
            }
            if (this.control.valid) {
                return this.successMessage ? this.successMessage : this.defaultTexts.valid;
            }
            return null;
        }
    }
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(value) {
        if (this._value !== value) {
            this._value = value;
            if (this._value !== null) {
                this._applyTextOverflow();
                this.valueChanged.emit(this._value);
            }
        }
    }
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * setDisabledState(isDisabled: boolean)?: void
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngOnInit() {
        this.nestedSettings = Object.assign(Object.assign({}, this.nestedSettingsDefault), this.nestedSettings);
        if (this.tooltipIcon && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIcon,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
        this._ngControl = this._injector.get(NgControl, null);
    }
    ngOnChanges(changes) {
        if (changes.autofocus) {
            this.setFocus();
        }
        // move from setter due to https://github.com/angular/angular/issues/32756
        if (changes.required) {
            SafeCdr.detectChanges(this._cdr);
        }
    }
    ngAfterContentChecked() {
        this.checkIfValid();
    }
    /**
     * Callback for the cases where the focused state of the input changes
     */
    onFocus(event) {
        this.renderer.addClass(this.el, cssTextFieldClasses.FOCUS);
        this.focusEmitter.emit(event);
    }
    /**
     * Callback for the cases where the focused state is out of input element
     */
    onBlur(event) {
        this.renderer.addClass(this.el, cssTextFieldClasses.FOCUS);
        this.onTouchedCallback();
        this.blurEmitter.emit(event);
    }
    /**
     * Check the input element on touch event
     */
    checkOnTouch() {
        if (this.inputElement) {
            this.isDirty = this.inputElement.nativeElement.classList.contains(cssTextFieldClasses.NG_TOUCHED);
        }
    }
    /**
     * Check the input element on valid/invalid state
     */
    checkIfValid() {
        if (this.nativeCheckGlobalDisabled === true) {
            return;
        }
        if (this.disableNativeValidityChecking) {
            return;
        }
        if (this.disabled) {
            this._setSuccessState();
            return;
        }
        this.checkOnTouch();
        if (this.setInvalidState && this.inputElement && this.inputElement.nativeElement.validity) {
            this._setErrorState();
            this.inputElement.nativeElement.classList.add(cssTextFieldClasses.NG_TOUCHED);
            this.isDirty = true;
            return;
        }
        if (this.inputElement && this.inputElement.nativeElement.validity && this.isDirty) {
            if (!this.inputElement.nativeElement.validity.valid) {
                this._setErrorState();
            }
            else {
                this._setSuccessState();
            }
        }
    }
    onKeydown(event) {
        this.inputKeydown.emit(event);
    }
    onKeypress(event) {
        this.inputKeypress.emit(event);
    }
    onKeyup(event) {
        this.inputKeyup.emit(event);
        const input = this.inputElement.nativeElement;
        if (this.maxlength && input.value && input.value.toString().length > this.maxlength) {
            input.value = input.value.toString().substring(0, this.maxlength);
            this.value = input.value.toString().substring(0, this.maxlength);
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        const input = this.inputElement.nativeElement;
        this._isInput = input.nodeName === 'INPUT';
        if (this._isInput && this.overflowText) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this.inputStyles = Object.assign({}, getElementStyles(input));
            });
            this._resizeService.addResizeEventListener(this.elemRef.nativeElement, debounce(this._applyTextOverflow.bind(this), 100));
        }
        fromEvent(input, 'input')
            .pipe(debounceTime(this.debounceTime), distinctUntilChanged(), tap(this._applyTextOverflow.bind(this)), takeUntil(this._destroyed$))
            .subscribe(() => this.valueChanged.emit(this.value));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._resizeService.removeResizeEventListener(this.elemRef.nativeElement);
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    _applyTextOverflow() {
        if (this.overflowText && this.inputElement && this.inputTextWidthEl && this._isInput) {
            const div = this.inputTextWidthEl.nativeElement;
            const input = this.inputElement.nativeElement;
            this.isTextOverflow = div.clientWidth > input.clientWidth;
        }
    }
    _setErrorState() {
        this.isError = true;
        this.renderer.addClass(this.el, cssTextFieldClasses.FORM_DANGER);
        if (this.validState) {
            this.renderer.removeClass(this.el, cssTextFieldClasses.FORM_SUCCESS);
        }
    }
    _setSuccessState() {
        this.isError = false;
        this.renderer.removeClass(this.el, cssTextFieldClasses.FORM_DANGER);
        if (this.validState) {
            this.renderer.addClass(this.el, cssTextFieldClasses.FORM_SUCCESS);
        }
    }
    setFocus() {
        if (!this.autofocus) {
            return;
        }
        /**
         * hot fix for autofocus attr in FF and IE
         */
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this.inputElement.nativeElement.focus();
        });
    }
}
AdaptTextFieldComponent.ɵfac = function AdaptTextFieldComponent_Factory(t) { return new (t || AdaptTextFieldComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.ResizeService), i0.ɵɵdirectiveInject(i2.Directionality), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(DISABLE_NATIVE_VALIDITY_CHECKING, 8), i0.ɵɵdirectiveInject(i3.AdaptRadarService)); };
AdaptTextFieldComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTextFieldComponent, selectors: [["adapt-textfield"], ["div", "form-group", ""]], viewQuery: function AdaptTextFieldComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputTextWidthEl = _t.first);
    } }, hostVars: 7, hostBindings: function AdaptTextFieldComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("id", ctx.id);
        i0.ɵɵclassProp("form-group", true)("textfield", true)("is-icons", ctx.iconValid && ctx.validState || ctx.iconInvalid && ctx.isError);
    } }, inputs: { overflowText: "overflowText", nested: "nested", nestedSettings: "nestedSettings", customClass: "customClass", label: "label", type: "type", id: "id", testID: "testID", icon: "icon", iconValid: "iconValid", iconInvalid: "iconInvalid", tabindex: "tabindex", maxlength: "maxlength", minlength: "minlength", placeholder: "placeholder", autocomplete: "autocomplete", pattern: "pattern", min: "min", max: "max", step: "step", name: "name", validState: "validState", requiredLabel: "requiredLabel", tooltipIcon: "tooltipIcon", tooltipText: "tooltipText", popoverIcon: "popoverIcon", popoverPlacement: "popoverPlacement", popoverTriggers: "popoverTriggers", popoverContent: "popoverContent", errorMessage: ["error", "errorMessage"], successMessage: ["success", "successMessage"], control: "control", setInvalidState: "setInvalidState", debounceTime: "debounceTime", required: "required", disabled: "disabled", readonly: "readonly", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", rows: "rows", maxrows: "maxrows", autofocus: "autofocus", disableNativeValidityChecking: "disableNativeValidityChecking", ariaLabel: "ariaLabel", ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"] }, outputs: { focusEmitter: "focus", blurEmitter: "blur", valueChanged: "valueChanged", inputKeydown: "inputKeydown", inputKeypress: "inputKeypress", inputKeyup: "inputKeyup" }, features: [i0.ɵɵProvidersFeature([ADAPT_TEXTFIELD_ACCESSOR]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c3, decls: 31, vars: 13, consts: [[1, "adapt-textfield-label-wrapper"], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [1, "textfield__wrapper"], [3, "error", "success", "iconValid", "iconInvalid", 4, "ngIf"], [3, "rows", "class", "form-control-disabled-look", "ngModel", "disabled", "required", "autofocus", "readonly", "placeholder", "pattern", "keydown", "keypress", "keyup", "ngModelChange", "focus", "blur", 4, "ngIf"], [3, "class", "form-control-disabled-look", "textfield-padding-transition", "pl-0", "pr-0", "type", "ngModel", "disabled", "required", "autofocus", "readonly", "autocomplete", "placeholder", "pattern", "keydown", "keypress", "keyup", "ngModelChange", "focus", "blur", 4, "ngIf"], ["class", "input-group", 3, "ngClass", 4, "ngIf"], ["role", "alert", 4, "ngIf"], [4, "ngIf"], [1, "textfield-input-wrapper"], ["class", "textfield-input-element-copy", 3, "ngStyle", 4, "ngIf"], [3, "error", "success", "iconValid", "iconInvalid"], [3, "rows", "ngModel", "disabled", "required", "autofocus", "readonly", "placeholder", "pattern", "keydown", "keypress", "keyup", "ngModelChange", "focus", "blur"], ["input", ""], [3, "type", "ngModel", "disabled", "required", "autofocus", "readonly", "autocomplete", "placeholder", "pattern", "keydown", "keypress", "keyup", "ngModelChange", "focus", "blur"], [1, "input-group", 3, "ngClass"], ["class", "input-group-prepend", 4, "ngIf"], ["class", "input-group-append", 3, "zIndex", 4, "ngIf"], [1, "input-group-prepend"], [1, "input-group-text"], [1, "input-group-append"], ["role", "alert"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngIf"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"], [1, "textfield-input-element-copy", 3, "ngStyle"], ["inputTextWidthEl", ""]], template: function AdaptTextFieldComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c2);
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelement(2, "adapt-rx-control-label", 1);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵprojection(4);
        i0.ɵɵtext(5, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n\n");
        i0.ɵɵelementStart(7, "div", 2);
        i0.ɵɵtext(8, "\n\n  ");
        i0.ɵɵtemplate(9, AdaptTextFieldComponent_adapt_textfield_icons_9_Template, 1, 4, "adapt-textfield-icons", 3);
        i0.ɵɵtext(10, "\n\n  ");
        i0.ɵɵtemplate(11, AdaptTextFieldComponent_textarea_11_Template, 3, 23, "textarea", 4);
        i0.ɵɵtext(12, "\n\n  ");
        i0.ɵɵtemplate(13, AdaptTextFieldComponent_input_13_Template, 2, 33, "input", 5);
        i0.ɵɵtext(14, "\n\n  ");
        i0.ɵɵtemplate(15, AdaptTextFieldComponent_div_15_Template, 9, 34, "div", 6);
        i0.ɵɵtext(16, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n\n");
        i0.ɵɵtemplate(18, AdaptTextFieldComponent_div_18_Template, 4, 2, "div", 7);
        i0.ɵɵtext(19, "\n\n");
        i0.ɵɵtemplate(20, AdaptTextFieldComponent_div_20_Template, 4, 2, "div", 7);
        i0.ɵɵtext(21, "\n\n");
        i0.ɵɵtemplate(22, AdaptTextFieldComponent_div_22_Template, 4, 2, "div", 8);
        i0.ɵɵtext(23, "\n\n");
        i0.ɵɵelementStart(24, "div", 9);
        i0.ɵɵtext(25, "\n  ");
        i0.ɵɵtemplate(26, AdaptTextFieldComponent_div_26_Template, 3, 2, "div", 10);
        i0.ɵɵtext(27, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(28, "\n\n");
        i0.ɵɵprojection(29, 1);
        i0.ɵɵtext(30, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.rows ? ctx.id + "_textarea" : ctx.id + "_input")("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngIf", ctx.iconValid || ctx.iconInvalid);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.rows);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.rows && !ctx.nested);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.rows && ctx.nested);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.disabled && !ctx.control && ctx.validState && (ctx.isError || !ctx.isError && ctx.isDirty));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.disabled && !ctx.control && !ctx.validState && ctx.isError);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.control && ctx.additionalMessage !== null);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.overflowText);
    } }, directives: [i1.AdaptRxControlLabelComponent, i4.NgIf, i5.AdaptTextfieldIconsComponent, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i6.NgControlStatus, i6.NgModel, i6.RequiredValidator, i6.MaxLengthValidator, i6.MinLengthValidator, i6.PatternValidator, i4.NgClass, i4.NgStyle], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ]),
            trigger('validationFeedbackChangeAnimation', [
                transition('* => *', [
                    useAnimation(ANIMATION_NAME.opacity)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextFieldComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-textfield, div[form-group]',
                templateUrl: './textfield.component.html',
                providers: [ADAPT_TEXTFIELD_ACCESSOR],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.id]': 'id',
                    '[class.form-group]': 'true',
                    '[class.textfield]': 'true',
                    '[class.is-icons]': '(iconValid && validState) || (iconInvalid && isError)'
                },
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ]),
                    trigger('validationFeedbackChangeAnimation', [
                        transition('* => *', [
                            useAnimation(ANIMATION_NAME.opacity)
                        ])
                    ])
                ],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.ResizeService }, { type: i2.Directionality }, { type: i1.AdaptTranslateService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DISABLE_NATIVE_VALIDITY_CHECKING]
            }] }, { type: i3.AdaptRadarService }]; }, { overflowText: [{
            type: Input
        }], nested: [{
            type: Input
        }], nestedSettings: [{
            type: Input
        }], customClass: [{
            type: Input
        }], label: [{
            type: Input
        }], type: [{
            type: Input
        }], id: [{
            type: Input
        }], testID: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconValid: [{
            type: Input
        }], iconInvalid: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], minlength: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], autocomplete: [{
            type: Input
        }], pattern: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], step: [{
            type: Input
        }], name: [{
            type: Input
        }], validState: [{
            type: Input
        }], requiredLabel: [{
            type: Input
        }], tooltipIcon: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], popoverIcon: [{
            type: Input
        }], popoverPlacement: [{
            type: Input
        }], popoverTriggers: [{
            type: Input
        }], popoverContent: [{
            type: Input
        }], errorMessage: [{
            type: Input,
            args: ['error']
        }], successMessage: [{
            type: Input,
            args: ['success']
        }], control: [{
            type: Input
        }], setInvalidState: [{
            type: Input
        }], debounceTime: [{
            type: Input
        }], inputElement: [{
            type: ViewChild,
            args: ['input']
        }], inputTextWidthEl: [{
            type: ViewChild,
            args: ['inputTextWidthEl']
        }], focusEmitter: [{
            type: Output,
            args: ['focus']
        }], blurEmitter: [{
            type: Output,
            args: ['blur']
        }], valueChanged: [{
            type: Output
        }], inputKeydown: [{
            type: Output
        }], inputKeypress: [{
            type: Output
        }], inputKeyup: [{
            type: Output
        }], required: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], rows: [{
            type: Input
        }], maxrows: [{
            type: Input
        }], autofocus: [{
            type: Input
        }], disableNativeValidityChecking: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }] }); })();
//# sourceMappingURL=textfield.component.js.map