// TODO update types
/* eslint-disable @typescript-eslint/no-explicit-any */
import { Component, ElementRef, EventEmitter, forwardRef, Input, NgZone, Output, Renderer2, ViewChild, ViewEncapsulation } from '@angular/core';
import { FormControl, NG_VALUE_ACCESSOR } from '@angular/forms';
import { transition, trigger, useAnimation } from '@angular/animations';
import { Directionality } from '@angular/cdk/bidi';
import { fromEvent, ReplaySubject } from 'rxjs';
import { debounceTime, distinctUntilChanged, take, takeUntil } from 'rxjs/operators';
import { AdaptRadarAngularCustomEventName, ANIMATION_NAME, debounce, getElementStyles, ResizeService, toBoolean, toNumber } from '@bmc-ux/adapt-angular';
import { AdaptRadarGenericDirective, AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/bidi";
import * as i2 from "@bmc-ux/adapt-angular";
import * as i3 from "@bmc-ux/adapt-radar";
import * as i4 from "@angular/common";
import * as i5 from "../textfield/textfield.icons";
import * as i6 from "@angular/forms";
const _c0 = ["input"];
const _c1 = ["inputTextWidthEl"];
function AdaptTextFieldFormBuilderComponent_adapt_textfield_icons_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-textfield-icons", 11);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("error", ctx_r0.control.invalid)("success", !ctx_r0.control.invalid)("iconValid", ctx_r0.iconValid && ctx_r0.validState)("iconInvalid", ctx_r0.iconInvalid);
} }
function AdaptTextFieldFormBuilderComponent_textarea_11_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "textarea", 12);
    i0.ɵɵlistener("focus", function AdaptTextFieldFormBuilderComponent_textarea_11_Template_textarea_focus_0_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.onFocus($event); })("blur", function AdaptTextFieldFormBuilderComponent_textarea_11_Template_textarea_blur_0_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.onBlur($event); });
    i0.ɵɵtext(1, "  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r1.customClass, "");
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r1.readonly && ctx_r1.disabledStyleForReadonlyState);
    i0.ɵɵproperty("rows", ctx_r1.rows)("formControl", ctx_r1.control)("required", ctx_r1.required)("autofocus", ctx_r1.autofocus)("readonly", ctx_r1.readonly)("placeholder", ctx_r1.placeholder ? ctx_r1.placeholder : "");
    i0.ɵɵattribute("name", ctx_r1.name)("id", ctx_r1.id)("maxlength", ctx_r1.maxlength)("minlength", ctx_r1.minlength)("tabindex", ctx_r1.tabindex)("aria-label", ctx_r1.ariaLabel)("aria-labelledby", ctx_r1.ariaLabelledby)("aria-describedby", ctx_r1.ariaDescribedBy);
} }
function AdaptTextFieldFormBuilderComponent_input_13_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "input", 13, 14);
    i0.ɵɵlistener("keyup", function AdaptTextFieldFormBuilderComponent_input_13_Template_input_keyup_0_listener() { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.onKeyup(); })("focus", function AdaptTextFieldFormBuilderComponent_input_13_Template_input_focus_0_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.onFocus($event); })("blur", function AdaptTextFieldFormBuilderComponent_input_13_Template_input_blur_0_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.onBlur($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r2.customClass, "");
    i0.ɵɵclassProp("textfield-padding-transition", ctx_r2.overflowText)("pl-0", ctx_r2.isTextOverflow && !ctx_r2.isRtl)("pr-0", ctx_r2.isTextOverflow && ctx_r2.isRtl)("form-control-disabled-look", ctx_r2.readonly && ctx_r2.disabledStyleForReadonlyState);
    i0.ɵɵproperty("formControl", ctx_r2.control)("type", ctx_r2.type)("required", ctx_r2.required)("autofocus", ctx_r2.autofocus)("readonly", ctx_r2.readonly)("autocomplete", ctx_r2.autocomplete ? ctx_r2.autocomplete : "on")("placeholder", ctx_r2.placeholder ? ctx_r2.placeholder : "");
    i0.ɵɵattribute("name", ctx_r2.name)("id", ctx_r2.id)("maxlength", ctx_r2.maxlength)("minlength", ctx_r2.minlength)("min", ctx_r2.min)("max", ctx_r2.max)("step", ctx_r2.step)("tabindex", ctx_r2.tabindex)("aria-label", ctx_r2.ariaLabel)("aria-labelledby", ctx_r2.ariaLabelledby)("aria-describedby", ctx_r2.ariaDescribedBy);
} }
function AdaptTextFieldFormBuilderComponent_div_15_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 18);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r15.nestedSettings.addOnTextLeft);
} }
function AdaptTextFieldFormBuilderComponent_div_15_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 20);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r17 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("z-index", "34");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r17.nestedSettings.addOnTextRight);
} }
function AdaptTextFieldFormBuilderComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    const _r19 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptTextFieldFormBuilderComponent_div_15_div_2_Template, 5, 1, "div", 16);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementStart(4, "input", 13, 14);
    i0.ɵɵlistener("keyup", function AdaptTextFieldFormBuilderComponent_div_15_Template_input_keyup_4_listener() { i0.ɵɵrestoreView(_r19); const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.onKeyup(); })("focus", function AdaptTextFieldFormBuilderComponent_div_15_Template_input_focus_4_listener($event) { i0.ɵɵrestoreView(_r19); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.onFocus($event); })("blur", function AdaptTextFieldFormBuilderComponent_div_15_Template_input_blur_4_listener($event) { i0.ɵɵrestoreView(_r19); const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.onBlur($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵtemplate(7, AdaptTextFieldFormBuilderComponent_div_15_div_7_Template, 5, 3, "div", 17);
    i0.ɵɵtext(8, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.nestedSettings.addOnLeft);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r3.customClass, "");
    i0.ɵɵclassProp("textfield-padding-transition", ctx_r3.overflowText)("pl-0", ctx_r3.isTextOverflow && !ctx_r3.isRtl)("pr-0", ctx_r3.isTextOverflow && ctx_r3.isRtl);
    i0.ɵɵproperty("formControl", ctx_r3.control)("type", ctx_r3.type)("required", ctx_r3.required)("autofocus", ctx_r3.autofocus)("readonly", ctx_r3.readonly)("autocomplete", ctx_r3.autocomplete ? ctx_r3.autocomplete : "on")("placeholder", ctx_r3.placeholder ? ctx_r3.placeholder : "");
    i0.ɵɵattribute("name", ctx_r3.name)("id", ctx_r3.id)("maxlength", ctx_r3.maxlength)("minlength", ctx_r3.minlength)("min", ctx_r3.min)("max", ctx_r3.max)("step", ctx_r3.step)("tabindex", ctx_r3.tabindex)("aria-label", ctx_r3.ariaLabel)("aria-labelledby", ctx_r3.ariaLabelledby)("aria-describedby", ctx_r3.ariaDescribedBy);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r3.nestedSettings.addOnRight);
} }
function AdaptTextFieldFormBuilderComponent_div_18_div_4_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 24);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r23 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n        ", ctx_r23.displayMessage, "\n      ");
} }
function AdaptTextFieldFormBuilderComponent_div_18_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTextFieldFormBuilderComponent_div_18_div_4_p_2_Template, 2, 1, "p", 23);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r22 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r22.displayMessage && ctx_r22.displayMessage !== "");
} }
function AdaptTextFieldFormBuilderComponent_div_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementStart(2, "div", 22);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptTextFieldFormBuilderComponent_div_18_div_4_Template, 4, 2, "div", 8);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n  ");
    i0.ɵɵprojection(7, 2);
    i0.ɵɵtext(8, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r4.control && ctx_r4.control.touched && ctx_r4.control.invalid && !ctx_r4.validState);
} }
function AdaptTextFieldFormBuilderComponent_div_20_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 24);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@validationFeedbackChangeAnimation", ctx_r24.control.invalid);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r24.displayMessage);
} }
function AdaptTextFieldFormBuilderComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTextFieldFormBuilderComponent_div_20_p_2_Template, 2, 2, "p", 23);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.displayMessage && ctx_r5.displayMessage !== "");
} }
function AdaptTextFieldFormBuilderComponent_div_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 25, 26);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", ctx_r6.inputStyles);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r6.value);
} }
const _c2 = [[["", 8, "label-count"]], "*", [["", 8, "label-count-bottom"]]];
const _c3 = [".label-count", "*", ".label-count-bottom"];
let nextId = 0;
const noop = () => {
    return;
};
const cssTextFieldClasses = {
    FOCUS: 'is-focus',
    // REQUIRED: 'is-required',       // not used yet
    // DIRTY: 'is-dirty',
    // PRISTINE: 'is-pristine',
    // FORM_SUCCESS: 'has-success',
    // FORM_DANGER: 'has-danger',
    // VALID: 'form-control-success',
    // IN_VALID: 'form-control-danger'
};
export const ADAPT_TEXTFIELD_FORMBUILDER_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptTextFieldFormBuilderComponent),
    multi: true
};
export class AdaptTextFieldFormBuilderComponent extends AdaptRadarGenericDirective {
    constructor(elemRef, renderer, _dir, _ngZone, _resizeService, _adaptRadarService) {
        super(_adaptRadarService, elemRef, AdaptRadarAngularCustomEventName.AdaptTextFieldFormBuilder);
        this.elemRef = elemRef;
        this.renderer = renderer;
        this._dir = _dir;
        this._ngZone = _ngZone;
        this._resizeService = _resizeService;
        this.nestedSettingsDefault = {
            addOnLeft: true,
            addOnRight: false,
            addOnTextLeft: '@'
        };
        this.inputStyles = null;
        this.isTextOverflow = false;
        this.isRtl = false;
        this.overflowText = true;
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * The input element type {bs4 view}.
         */
        this.nested = false;
        /**
         * The input element type; by default is 'text'
         */
        this.type = 'text';
        /**
         * Unique id of the element.
         */
        this.id = `adapt-textfield-${nextId++}`;
        /**
         * Whether the input is with success icon
         */
        this.iconValid = false;
        /**
         * Whether the input is with error icon
         */
        this.iconInvalid = true;
        /**
         * TabIndex attribute of the element
         */
        this.tabindex = null;
        /**
         * Maxlength attribute of the element
         */
        this.maxlength = null;
        /**
         * Minlength attribute of the element
         */
        this.minlength = 0;
        /**
         * Whether the input is valid
         */
        this.validState = false;
        /**
         * Whether the input is required. The plain text 'requiredLabel' for the input element
         */
        this.requiredLabel = '(required)';
        this.popoverPlacement = 'top';
        this.popoverTriggers = 'click';
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        this.ariaLabel = null;
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.focusEmitter = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.blurEmitter = new EventEmitter();
        /**
         * Use disabled style for the control if [readonly]=true
         */
        this.disabledStyleForReadonlyState = false;
        this._readonly = false;
        this._rows = null;
        this._maxrows = -1;
        this._autofocus = false;
        this.hasFocus = false;
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this._destroyed$ = new ReplaySubject(1);
        /**
         * Private variables of textfield component
         */
        this._required = false;
        this.renderer = renderer;
        this.isRtl = _dir.value === 'rtl';
    }
    /** Whether the element is required. */
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = toBoolean(value);
    }
    /** Whether the element is readonly. */
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        this._readonly = toBoolean(value);
    }
    /** Whether the element is textarea. */
    get rows() {
        return this._rows;
    }
    set rows(value) {
        this._rows = toNumber(value);
    }
    /** Whether the element has maxrows. */
    get maxrows() {
        return this._maxrows;
    }
    set maxrows(value) {
        this._maxrows = toNumber(value);
    }
    /** Whether the element has autofocus. */
    get autofocus() {
        return this._autofocus;
    }
    set autofocus(value) {
        this._autofocus = toBoolean(value);
    }
    /** The input element's value. */
    get value() {
        return this._value;
    }
    set value(v) {
        if (v !== this._value) {
            this._value = v;
            this.onChangeCallback(v);
        }
    }
    set toggleStateValidation(value) {
        if (this.control) {
            if (value) {
                this.control.markAsDirty();
                this.control.markAsTouched();
            }
            else {
                this.control.markAsPristine();
                this.control.markAsUntouched();
            }
        }
    }
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(value) {
        if (this._value !== value) {
            this._value = value;
            this._applyTextOverflow();
        }
    }
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    ngOnInit() {
        this.nestedSettings = Object.assign(Object.assign({}, this.nestedSettingsDefault), this.nestedSettings);
        if (this.tooltipIcon && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIcon,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (this.inputElement && this.overflowText) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this.inputStyles = Object.assign({}, getElementStyles(this.inputElement.nativeElement));
            });
            this._resizeService.addResizeEventListener(this.elemRef.nativeElement, debounce(this._applyTextOverflow.bind(this), 100));
            fromEvent(this.inputElement.nativeElement, 'input')
                .pipe(debounceTime(300), distinctUntilChanged(), takeUntil(this._destroyed$))
                .subscribe(() => {
                this._applyTextOverflow();
            });
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._resizeService.removeResizeEventListener(this.elemRef.nativeElement);
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    /**
     * Control disabled state from component
     */
    ngOnChanges(changes) {
        const disableControl = changes.disableControl;
        if (disableControl) {
            disableControl.currentValue ? this.control.disable() : this.control.enable();
        }
    }
    /**
     * Callback for the cases where the focused state of the input changes
     */
    onFocus(event) {
        this.hasFocus = true;
        this.renderer.addClass(this.elemRef.nativeElement, cssTextFieldClasses.FOCUS);
        this.focusEmitter.emit(event);
    }
    /**
     * Callback for the cases where the focused state is out of input element
     */
    onBlur(event) {
        this.hasFocus = false;
        this.renderer.addClass(this.elemRef.nativeElement, cssTextFieldClasses.FOCUS);
        this.onTouchedCallback();
        this.blurEmitter.emit(event);
    }
    onKeyup() {
        this.value = this.inputElement.nativeElement.value;
    }
    _applyTextOverflow() {
        if (this.overflowText && this.inputTextWidthEl && this.inputElement) {
            const div = this.inputTextWidthEl.nativeElement;
            const input = this.inputElement.nativeElement;
            this.isTextOverflow = div.clientWidth > input.clientWidth;
        }
    }
}
AdaptTextFieldFormBuilderComponent.ɵfac = function AdaptTextFieldFormBuilderComponent_Factory(t) { return new (t || AdaptTextFieldFormBuilderComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.Directionality), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.ResizeService), i0.ɵɵdirectiveInject(i3.AdaptRadarService)); };
AdaptTextFieldFormBuilderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTextFieldFormBuilderComponent, selectors: [["adapt-textfield-formbuilder"]], viewQuery: function AdaptTextFieldFormBuilderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputTextWidthEl = _t.first);
    } }, hostVars: 12, hostBindings: function AdaptTextFieldFormBuilderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("form-group", true)("textfield", true)("is-counting", ctx.labelCount)("has-danger", ctx.control.touched && ctx.control.invalid)("has-success", !ctx.control.invalid && ctx.validState)("is-icons", ctx.iconValid && !ctx.control.invalid && ctx.validState || ctx.iconInvalid && ctx.control.touched && ctx.control.invalid);
    } }, inputs: { overflowText: "overflowText", nested: "nested", nestedSettings: "nestedSettings", customClass: "customClass", label: "label", type: "type", id: "id", icon: "icon", iconValid: "iconValid", iconInvalid: "iconInvalid", tabindex: "tabindex", maxlength: "maxlength", minlength: "minlength", placeholder: "placeholder", autocomplete: "autocomplete", pattern: "pattern", min: "min", max: "max", step: "step", name: "name", control: "control", disableControl: "disableControl", displayMessage: "displayMessage", validState: "validState", requiredLabel: "requiredLabel", tooltipIcon: "tooltipIcon", tooltipText: "tooltipText", popoverIcon: "popoverIcon", popoverPlacement: "popoverPlacement", popoverTriggers: "popoverTriggers", popoverContent: "popoverContent", labelCount: "labelCount", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"], required: "required", readonly: "readonly", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", rows: "rows", maxrows: "maxrows", autofocus: "autofocus", toggleStateValidation: "toggleStateValidation" }, outputs: { focusEmitter: "focus", blurEmitter: "blur" }, features: [i0.ɵɵProvidersFeature([ADAPT_TEXTFIELD_FORMBUILDER_ACCESSOR]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c3, decls: 29, vars: 12, consts: [[1, "adapt-counter-label-wrapper"], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [1, "textfield__wrapper"], [3, "error", "success", "iconValid", "iconInvalid", 4, "ngIf"], [3, "rows", "formControl", "class", "required", "autofocus", "readonly", "form-control-disabled-look", "placeholder", "focus", "blur", 4, "ngIf"], [3, "class", "formControl", "textfield-padding-transition", "pl-0", "pr-0", "type", "required", "autofocus", "form-control-disabled-look", "readonly", "autocomplete", "placeholder", "keyup", "focus", "blur", 4, "ngIf"], ["class", "input-group", 4, "ngIf"], ["class", "form-control-flex pt-0", 4, "ngIf"], [4, "ngIf"], [1, "textfield-input-wrapper"], ["class", "textfield-input-element-copy", 3, "ngStyle", 4, "ngIf"], [3, "error", "success", "iconValid", "iconInvalid"], [3, "rows", "formControl", "required", "autofocus", "readonly", "placeholder", "focus", "blur"], [3, "formControl", "type", "required", "autofocus", "readonly", "autocomplete", "placeholder", "keyup", "focus", "blur"], ["input", ""], [1, "input-group"], ["class", "input-group-prepend", 4, "ngIf"], ["class", "input-group-append", 3, "zIndex", 4, "ngIf"], [1, "input-group-prepend"], [1, "input-group-text"], [1, "input-group-append"], [1, "form-control-flex", "pt-0"], [1, "form-control-flex__feedback"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngIf"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"], [1, "textfield-input-element-copy", 3, "ngStyle"], ["inputTextWidthEl", ""]], template: function AdaptTextFieldFormBuilderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c2);
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelement(2, "adapt-rx-control-label", 1);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵprojection(4);
        i0.ɵɵtext(5, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n\n");
        i0.ɵɵelementStart(7, "div", 2);
        i0.ɵɵtext(8, "\n  ");
        i0.ɵɵtemplate(9, AdaptTextFieldFormBuilderComponent_adapt_textfield_icons_9_Template, 1, 4, "adapt-textfield-icons", 3);
        i0.ɵɵtext(10, "\n  ");
        i0.ɵɵtemplate(11, AdaptTextFieldFormBuilderComponent_textarea_11_Template, 2, 19, "textarea", 4);
        i0.ɵɵtext(12, "\n\n  ");
        i0.ɵɵtemplate(13, AdaptTextFieldFormBuilderComponent_input_13_Template, 2, 29, "input", 5);
        i0.ɵɵtext(14, "\n\n  ");
        i0.ɵɵtemplate(15, AdaptTextFieldFormBuilderComponent_div_15_Template, 9, 29, "div", 6);
        i0.ɵɵtext(16, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n\n");
        i0.ɵɵtemplate(18, AdaptTextFieldFormBuilderComponent_div_18_Template, 9, 1, "div", 7);
        i0.ɵɵtext(19, "\n\n");
        i0.ɵɵtemplate(20, AdaptTextFieldFormBuilderComponent_div_20_Template, 4, 2, "div", 8);
        i0.ɵɵtext(21, "\n\n");
        i0.ɵɵelementStart(22, "div", 9);
        i0.ɵɵtext(23, "\n  ");
        i0.ɵɵtemplate(24, AdaptTextFieldFormBuilderComponent_div_24_Template, 3, 2, "div", 10);
        i0.ɵɵtext(25, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(26, "\n\n");
        i0.ɵɵprojection(27, 1);
        i0.ɵɵtext(28, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngIf", ctx.iconValid || ctx.iconInvalid);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.rows);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.rows && !ctx.nested);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.rows && ctx.nested);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.validState);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.control && ctx.control.touched && ctx.validState);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.overflowText);
    } }, directives: [i2.AdaptRxControlLabelComponent, i4.NgIf, i5.AdaptTextfieldIconsComponent, i2.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i6.NgControlStatus, i6.FormControlDirective, i6.RequiredValidator, i6.MaxLengthValidator, i6.MinLengthValidator, i4.NgStyle], styles: ["\n    .textfield .label-count,\n    .textfield .label-count-bottom {\n      color: #999;\n      font-weight: 500;\n    }\n\n    .textfield.has-danger .label-count,\n    .textfield.has-danger .label-count-bottom {\n      color: #f83200;\n    }\n\n    .form-control-flex {\n      display: flex;\n      flex-flow: row nowrap;\n      justify-content: space-between;\n      padding-top: .25rem;\n      transition: all .3s;\n    }\n\n    .form-control-flex .form-control-feedback {\n      padding-top: 0 !important;\n      padding-bottom: 0 !important;\n    }\n\n    .form-control-flex__feedback {\n      flex: 0 1 auto;\n    }\n\n    .label-count-bottom {\n      text-align: right;\n      flex: 0 0 auto;\n    }\n\n  "], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ]),
            trigger('validationFeedbackChangeAnimation', [
                transition('* => *', [
                    useAnimation(ANIMATION_NAME.opacity)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextFieldFormBuilderComponent, [{
        type: Component,
        args: [{
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.form-group]': 'true',
                    '[class.textfield]': 'true',
                    '[class.is-counting]': 'labelCount',
                    '[class.has-danger]': 'control.touched && control.invalid',
                    '[class.has-success]': '!control.invalid && validState',
                    '[class.is-icons]': '(iconValid && !control.invalid && validState) || (iconInvalid && control.touched && control.invalid)'
                },
                selector: 'adapt-textfield-formbuilder',
                providers: [ADAPT_TEXTFIELD_FORMBUILDER_ACCESSOR],
                templateUrl: './textfield-formbuilder.component.html',
                styles: [`
    .textfield .label-count,
    .textfield .label-count-bottom {
      color: #999;
      font-weight: 500;
    }

    .textfield.has-danger .label-count,
    .textfield.has-danger .label-count-bottom {
      color: #f83200;
    }

    .form-control-flex {
      display: flex;
      flex-flow: row nowrap;
      justify-content: space-between;
      padding-top: .25rem;
      transition: all .3s;
    }

    .form-control-flex .form-control-feedback {
      padding-top: 0 !important;
      padding-bottom: 0 !important;
    }

    .form-control-flex__feedback {
      flex: 0 1 auto;
    }

    .label-count-bottom {
      text-align: right;
      flex: 0 0 auto;
    }

  `],
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ]),
                    trigger('validationFeedbackChangeAnimation', [
                        transition('* => *', [
                            useAnimation(ANIMATION_NAME.opacity)
                        ])
                    ])
                ],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.Directionality }, { type: i0.NgZone }, { type: i2.ResizeService }, { type: i3.AdaptRadarService }]; }, { inputElement: [{
            type: ViewChild,
            args: ['input', { static: false }]
        }], inputTextWidthEl: [{
            type: ViewChild,
            args: ['inputTextWidthEl', { static: false }]
        }], overflowText: [{
            type: Input
        }], nested: [{
            type: Input
        }], nestedSettings: [{
            type: Input
        }], customClass: [{
            type: Input
        }], label: [{
            type: Input
        }], type: [{
            type: Input
        }], id: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconValid: [{
            type: Input
        }], iconInvalid: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], minlength: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], autocomplete: [{
            type: Input
        }], pattern: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], step: [{
            type: Input
        }], name: [{
            type: Input
        }], control: [{
            type: Input
        }], disableControl: [{
            type: Input
        }], displayMessage: [{
            type: Input
        }], validState: [{
            type: Input
        }], requiredLabel: [{
            type: Input
        }], tooltipIcon: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], popoverIcon: [{
            type: Input
        }], popoverPlacement: [{
            type: Input
        }], popoverTriggers: [{
            type: Input
        }], popoverContent: [{
            type: Input
        }], labelCount: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], focusEmitter: [{
            type: Output,
            args: ['focus']
        }], blurEmitter: [{
            type: Output,
            args: ['blur']
        }], required: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], rows: [{
            type: Input
        }], maxrows: [{
            type: Input
        }], autofocus: [{
            type: Input
        }], toggleStateValidation: [{
            type: Input
        }] }); })();
//# sourceMappingURL=textfield-formbuilder.component.js.map