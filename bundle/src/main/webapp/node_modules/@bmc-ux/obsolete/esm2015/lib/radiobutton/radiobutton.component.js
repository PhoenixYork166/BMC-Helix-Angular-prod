// TODO update types
/* eslint-disable @typescript-eslint/no-explicit-any */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, HostBinding, Injector, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { AdaptRadarAngularCustomEventName, AdaptTranslateService, createFormControlValidator, createFormControlValueAccessor, FormComponent, SafeCdr } from '@bmc-ux/adapt-angular';
import { AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@bmc-ux/adapt-angular";
import * as i2 from "@bmc-ux/adapt-radar";
import * as i3 from "@angular/common";
const _c0 = ["input"];
function AdaptRadioButtonComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelement(2, "span", 7);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "span", 8);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r1.context.requiredLabel);
} }
function AdaptRadioButtonComponent_adapt_icon_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-icon", 9);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r2.context.tooltipText);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", ctx_r2.context.tooltipIconCls);
} }
const _c1 = [[["", 8, "radio-before"]], [["", 8, "radio-after"]]];
const _c2 = function (a0) { return { "is-focused": a0 }; };
const _c3 = function (a0) { return { "radio__item_no-label": a0 }; };
const _c4 = function (a0) { return { "sr-only": a0 }; };
const _c5 = [".radio-before", ".radio-after"];
const noop = () => {
    return;
};
let nextUniqueId = 0;
export class AdaptRadioButtonComponent extends FormComponent {
    constructor(injector, _changeDetectorRef, ts, _adaptRadarService, _elem) {
        super(injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRadioButton);
        this._changeDetectorRef = _changeDetectorRef;
        // Need for using inherited properties in the template
        this.context = this;
        this.isValid = true;
        /** Name value will be applied to the input element if present */
        this.name = null;
        /** The tabindex attribute of the native input element */
        this.tabindex = null;
        this.label = '';
        this.styleClass = '';
        this.class = ''; // override the standard class attr with a new one
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        // eslint-disable-next-line @typescript-eslint/typedef
        this.ariaLabel = '';
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        /**
         * Control [aria-describedby] attribute text
         */
        this.ariaDescribedBy = null;
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onClick = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        this._uniqueId = `adapt-radiobutton-${++nextUniqueId}`;
        /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.testID = this._uniqueId;
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.id = this._uniqueId;
        this._onTouchedCallback = noop;
        this._onChangeCallback = noop;
    }
    get inputId() {
        return `${this.id || this._uniqueId}-input`;
    }
    get hostClasses() {
        return [
            this.class,
            'radio',
            this.disabled ? 'disabled' : '',
            this.readonly ? 'readonly' : '',
        ].join(' ');
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Add a focus state on key-down/tabbing
     */
    onFocus() {
        this.focused = true;
    }
    /**
     * Remove a focus state on blur event
     */
    onBlur() {
        this.focused = false;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    /**
     * The method from an Abstract class
     */
    validate() {
        return null;
    }
    onInputClick(e) {
        e.stopPropagation();
        if (!(this.disabled || this.readonly)) {
            this.onClick.emit(null);
            this.inputElement.nativeElement.checked = true;
            this.checked = true;
            this._onChangeCallback(this.value);
        }
        else {
            e.preventDefault();
        }
    }
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(v) {
        this.checked = (v === this.value);
        if (this.inputElement.nativeElement) {
            this.inputElement.nativeElement.checked = this.checked;
        }
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * setDisabledState(isDisabled: boolean)?: void
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    _onInputChange(e) {
        if (this.readonly || this.disabled) {
            e.preventDefault();
        }
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        e.stopPropagation();
    }
}
AdaptRadioButtonComponent.ɵfac = function AdaptRadioButtonComponent_Factory(t) { return new (t || AdaptRadioButtonComponent)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRadioButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRadioButtonComponent, selectors: [["adapt-radiobutton"], ["div", "adapt-radiobutton", ""]], viewQuery: function AdaptRadioButtonComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    } }, hostVars: 2, hostBindings: function AdaptRadioButtonComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { value: "value", name: "name", tabindex: "tabindex", label: "label", styleClass: "styleClass", class: "class", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: "ariaDescribedBy", testID: "testID", id: "id" }, outputs: { onClick: "onClick", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptRadioButtonComponent),
            createFormControlValidator(AdaptRadioButtonComponent)
        ]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c5, decls: 23, vars: 29, consts: [[1, "radio__label"], ["type", "radio", 3, "disabled", "readOnly", "required", "id", "tabIndex", "checked", "ngClass", "change", "focus", "blur", "click"], ["input", ""], [1, "radio__item", "form-control-label", "font-weight-normal", 3, "ngClass"], [3, "ngClass"], [4, "ngIf"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip", 4, "ngIf"], [1, "letter-space"], [1, "form-control-required"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip"]], template: function AdaptRadioButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c1);
        i0.ɵɵprojection(0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵelementStart(2, "span", 0);
        i0.ɵɵtext(3, "\n  ");
        i0.ɵɵelementStart(4, "span");
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementStart(6, "input", 1, 2);
        i0.ɵɵlistener("change", function AdaptRadioButtonComponent_Template_input_change_6_listener($event) { return ctx._onInputChange($event); })("focus", function AdaptRadioButtonComponent_Template_input_focus_6_listener() { return ctx.onFocus(); })("blur", function AdaptRadioButtonComponent_Template_input_blur_6_listener() { return ctx.onBlur(); })("click", function AdaptRadioButtonComponent_Template_input_click_6_listener($event) { return ctx.onInputClick($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n    ");
        i0.ɵɵelementStart(9, "label", 3);
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵelementStart(11, "span", 4);
        i0.ɵɵtext(12);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n      ");
        i0.ɵɵtemplate(14, AdaptRadioButtonComponent_ng_container_14_Template, 7, 1, "ng-container", 5);
        i0.ɵɵtext(15, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n\n  ");
        i0.ɵɵtemplate(18, AdaptRadioButtonComponent_adapt_icon_18_Template, 2, 3, "adapt-icon", 6);
        i0.ɵɵtext(19, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n\n");
        i0.ɵɵprojection(21, 1);
        i0.ɵɵtext(22, "\n\n");
    } if (rf & 2) {
        i0.ɵɵadvance(4);
        i0.ɵɵclassMapInterpolate1("radio__label ", ctx.styleClass, "");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("disabled", ctx.context.disabled)("readOnly", ctx.readonly)("required", ctx.context.required)("id", ctx.inputId)("tabIndex", ctx.tabindex)("checked", ctx.checked)("ngClass", i0.ɵɵpureFunction1(23, _c2, ctx.focused));
        i0.ɵɵattribute("value", ctx.value)("data-testid", ctx.testID)("name", ctx.context.name)("aria-readonly", ctx.readonly)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(25, _c3, !ctx.context.label));
        i0.ɵɵattribute("for", ctx.inputId);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(27, _c4, !ctx.context.label));
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.context.label);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.required);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.context.tooltipIconCls);
    } }, directives: [i3.NgClass, i3.NgIf, i1.AdaptIconComponent, i1.AdaptTooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRadioButtonComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-radiobutton, div[adapt-radiobutton]',
                templateUrl: './radiobutton.component.html',
                providers: [
                    createFormControlValueAccessor(AdaptRadioButtonComponent),
                    createFormControlValidator(AdaptRadioButtonComponent)
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.Injector }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { value: [{
            type: Input
        }], name: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], label: [{
            type: Input
        }], styleClass: [{
            type: Input
        }], class: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input
        }], onClick: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], inputElement: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], testID: [{
            type: Input
        }], id: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();
//# sourceMappingURL=radiobutton.component.js.map