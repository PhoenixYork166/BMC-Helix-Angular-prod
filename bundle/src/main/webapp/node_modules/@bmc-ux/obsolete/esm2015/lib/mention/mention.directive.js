import { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, HostListener, Injector, Input, IterableDiffers, NgZone, Output, Renderer2 } from '@angular/core';
import { ALT, BACKSPACE, CONTROL, DOWN_ARROW, ENTER, ESCAPE, LEFT_ARROW, RIGHT_ARROW, SHIFT, TAB, UP_ARROW } from '@angular/cdk/keycodes';
import { AdaptRadarAngularCustomEventName, hasKeyboardKeyCode } from '@bmc-ux/adapt-angular';
import { take } from 'rxjs/operators';
import { AdaptMentionListComponent } from './mention-list/mention-list.component';
import { AdaptRadarGenericDirective, AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@bmc-ux/adapt-radar";
// eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
// eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
export class AdaptMentionDirective extends AdaptRadarGenericDirective {
    constructor(_element, _componentFactory, _differs, _renderer, _injector, _appRef, _ngZone, _adaptRadarService) {
        super(_adaptRadarService, _element, AdaptRadarAngularCustomEventName.AdaptMention);
        this._element = _element;
        this._componentFactory = _componentFactory;
        this._differs = _differs;
        this._renderer = _renderer;
        this._injector = _injector;
        this._appRef = _appRef;
        this._ngZone = _ngZone;
        this.appendToBody = false;
        this.mentionItemSelected = new EventEmitter();
        this.mentionTriggerCharPressed = new EventEmitter();
        this.mentionSearchValueEntered = new EventEmitter();
        this._triggerCharsList = {};
        this._showMentionLoader = false;
        this._modelDiffer = [];
    }
    get showMentionLoader() {
        return this._showMentionLoader;
    }
    set showMentionLoader(state) {
        this._showMentionLoader = state;
        if (this._mentionList) {
            this._mentionList.setLoaderState(state);
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._inputElement = this._element.nativeElement.querySelector('input') || this._element.nativeElement.querySelector('textarea');
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngOnChanges(changes) {
        if (changes.mentionConfig) {
            if (this.mentionConfig) {
                this.mentionConfig.forEach(config => {
                    this._triggerCharsList[config.triggerChar] = config;
                    this._modelDiffer = [];
                    this._modelDiffer.push(this._differs.find([]).create());
                });
            }
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngDoCheck() {
        // need for lazy loading
        if (this._modelDiffer.length && this.mentionConfig) {
            const isArrayChanged = this._modelDiffer.some((differ, index) => {
                return differ.diff(this.mentionConfig[index].items);
            });
            if (isArrayChanged) {
                this._updateMentionList();
            }
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this._mentionListComponentRef) {
            this._mentionList.onItemClick.unsubscribe();
            this._appRef.detachView(this._mentionListComponentRef.hostView);
            this._mentionListComponentRef.destroy();
            this._mentionListComponentRef = null;
        }
    }
    onKeyDown(event) {
        this._createMentionList();
        if (this._mentionList && !this._mentionList.hidden) {
            if (hasKeyboardKeyCode(event, 'ArrowDown', DOWN_ARROW) ||
                hasKeyboardKeyCode(event, 'ArrowUp', UP_ARROW) ||
                hasKeyboardKeyCode(event, 'Tab', TAB) ||
                hasKeyboardKeyCode(event, 'Enter', ENTER)) {
                event.preventDefault();
                return;
            }
        }
    }
    onKeyUp(event) {
        this._createMentionList();
        const { key } = event;
        let config;
        this._currentCaretPosition = this._getCaretPosition(this._inputElement);
        this._isComandKeyPress(event);
        if (this._isInteractionKeyPressed(event) || this._currentCaretPosition === 0) {
            config = this._triggerCharsList[key];
        }
        else {
            config = this._triggerCharsList[this._inputElement.value[this._currentCaretPosition - 1]];
        }
        if (config) {
            const inputVal = this._inputElement.value;
            // don't show list if 'triggerChar' is a part of word. For example somemail@somedomain.com
            const preCaret = inputVal[this._currentCaretPosition - 2];
            if ((this._currentCaretPosition > 1 &&
                ((preCaret === ' ') || (preCaret === '\n') || (preCaret === '\r'))) || this._currentCaretPosition <= 1) {
                this._initConfig(config);
            }
        }
        if (!config) {
            if (hasKeyboardKeyCode(event, 'Backspace', BACKSPACE)) {
                this._reopenList();
            }
        }
        if (!config && this._startPosition >= 0 && this._searching) {
            if (this._currentCaretPosition < this._startPosition) {
                this._stopSearching();
            }
            else {
                if (!this._mentionList.hidden) {
                    if (hasKeyboardKeyCode(event, 'Tab', TAB) || hasKeyboardKeyCode(event, 'Enter', ENTER)) {
                        event.preventDefault();
                        this._updateInputValue();
                        // fire input event so angular bindings are updated
                        const inputEvent = new Event('input', {
                            bubbles: true,
                            cancelable: true,
                        });
                        this._inputElement.dispatchEvent(inputEvent);
                        return;
                    }
                    if (hasKeyboardKeyCode(event, 'Escape', ESCAPE)) {
                        event.preventDefault();
                        this._stopSearching();
                        return;
                    }
                    if (hasKeyboardKeyCode(event, 'ArrowDown', DOWN_ARROW)) {
                        event.preventDefault();
                        this._mentionList.focusNext();
                        return;
                    }
                    if (hasKeyboardKeyCode(event, 'ArrowUp', UP_ARROW)) {
                        event.preventDefault();
                        this._mentionList.focusPrev();
                        return;
                    }
                }
                if (this._searching) {
                    const inputValue = this._inputElement.value;
                    const searchValue = inputValue.substring(this._startPosition, this._currentCaretPosition);
                    this._searchValue = searchValue;
                    this.mentionSearchValueEntered.emit(this._searchValue);
                    this._updateMentionList();
                }
            }
        }
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this._updatePosition();
        });
    }
    onBlur() {
        this._stopSearching();
    }
    _getLastCharIndex(str, char) {
        return str.toLowerCase().lastIndexOf(char);
    }
    _isComandKeyPress(event) {
        if (hasKeyboardKeyCode(event, 'Shift', SHIFT) ||
            hasKeyboardKeyCode(event, 'Alt', ALT) ||
            hasKeyboardKeyCode(event, 'Control', CONTROL)) {
            return;
        }
    }
    _initConfig(config) {
        this._currentConfig = config;
        this._searchValue = null;
        this._searching = true;
        this._startPosition = this._currentCaretPosition;
        this._updateMentionList();
        this._mentionList.setTemplates(this._currentConfig.itemTemplate, this._currentConfig.topSideTemplate);
        this.mentionTriggerCharPressed.emit(config.triggerChar);
    }
    _reopenList() {
        const value = this._inputElement.value;
        const leftPart = value.substring(0, this._currentCaretPosition);
        let triggerCharConfig = null;
        const newLineReg = /\r|\n/g; // regexp for new line in texture
        // well looks like IE doesn't support matchAll, have to fallback for regexp exec(); Need to replace when deprecate IE11
        // const newLinesMatch = [...leftPart.matchAll(newLineReg)].pop(); // it returns iterator, let convert it to array and grab the last one
        let newLinesMatch = null;
        let result = newLineReg.exec(leftPart);
        while (result) {
            result = newLineReg.exec(leftPart);
            newLinesMatch = result;
        }
        let oneLine;
        let cutOffIndex = 0;
        // if we have a new line, let’s get substring from caret position to its start
        if (newLinesMatch) {
            cutOffIndex = newLinesMatch.index + 1;
            oneLine = leftPart.substring(newLinesMatch.index + 1);
        }
        else {
            oneLine = leftPart;
        }
        // Now we have one line of the text which may contain triggerChars or may not
        let found = false;
        if (this.mentionConfig) {
            for (let stringIndex = oneLine.length - 1; stringIndex >= 0; stringIndex--) {
                const char = oneLine[stringIndex];
                const preChar = oneLine[stringIndex - 1] || ' ';
                for (const config of this.mentionConfig) {
                    if ((config.triggerChar === char) && (preChar === ' ')) {
                        triggerCharConfig = { index: stringIndex + cutOffIndex, char: config.triggerChar };
                        found = true;
                        break;
                    }
                }
                if (found) {
                    break;
                }
            }
        }
        if (triggerCharConfig) {
            this._startPosition = triggerCharConfig.index + 1;
            this._searching = true;
            this._currentConfig = this._triggerCharsList[triggerCharConfig.char];
            this._mentionList.setTemplates(this._currentConfig.itemTemplate, this._currentConfig.topSideTemplate);
        }
    }
    _updateInputValue() {
        const selectedConfig = this._mentionList.getActiveValue();
        if (selectedConfig) {
            const selectedValue = this._mentionList.searchKey ? selectedConfig[this._mentionList.searchKey] : selectedConfig;
            this._pasteValue(selectedValue + ' ', this._startPosition, this._currentCaretPosition);
            this.mentionItemSelected.emit(selectedConfig);
        }
        this._stopSearching();
    }
    _updateMentionList() {
        let matches = [];
        let searchKey;
        if (this._currentConfig) {
            const configItems = this._currentConfig.items;
            searchKey = this._currentConfig.searchKey;
            if (this._searchValue) {
                if (searchKey) {
                    matches = configItems.filter(item => item[searchKey].toLowerCase().indexOf(this._searchValue.toLowerCase()) !== -1);
                }
                else {
                    matches = configItems.filter(item => item.toLowerCase().indexOf(this._searchValue.toLowerCase()) !== -1);
                }
            }
            if (this._searchValue === null || this._searchValue.length === 0) {
                matches = configItems;
            }
        }
        if (this._mentionList) {
            this._mentionList.setListItems(matches);
            // Show list if results exist or isLoading state
            if (matches.length > 0 || this.showMentionLoader) {
                this._mentionList.appendToBody = this.appendToBody;
                this._mentionList.showList();
            }
            else {
                this._mentionList.hideList();
            }
            this._mentionList.setActiveIndex(0);
            this._mentionList.setSearchKey(searchKey);
        }
    }
    _createMentionList() {
        if (!this._mentionList) {
            const componentFactory = this._componentFactory.resolveComponentFactory(AdaptMentionListComponent);
            this._mentionListComponentRef = componentFactory.create(this._injector);
            this._appRef.attachView(this._mentionListComponentRef.hostView);
            this._renderer.appendChild(this._inputElement.parentNode, this._mentionListComponentRef.location.nativeElement);
            this._mentionList = this._mentionListComponentRef.instance;
            this._mentionList.initializeConfig(this._inputElement, this.mentionStyleConfig);
            this._mentionList.onItemClick.subscribe(() => {
                this._updateInputValue();
            });
        }
    }
    _hideMentionList() {
        if (this._mentionList) {
            this._mentionList.hideList();
        }
    }
    _updatePosition() {
        this._mentionList.caretUpdated$.next(this._startPosition);
    }
    _stopSearching() {
        this._hideMentionList();
        this._currentConfig = null;
        this._searching = false;
    }
    _getCaretPosition(element) {
        return element.value.slice(0, element.selectionStart).length;
    }
    _pasteValue(text, startPosition, endPosition) {
        const inputValue = this._inputElement.value;
        const value = inputValue.substr(0, startPosition) + text + inputValue.substr(endPosition);
        this._inputElement.value = value;
        const caretPosition = startPosition + text.length;
        this._inputElement.setSelectionRange(caretPosition, caretPosition);
    }
    _isInteractionKeyPressed(event) {
        return hasKeyboardKeyCode(event, 'Backspace', BACKSPACE) || hasKeyboardKeyCode(event, 'Escape', ESCAPE) ||
            hasKeyboardKeyCode(event, 'Tab', TAB) || hasKeyboardKeyCode(event, 'Enter', ENTER) ||
            hasKeyboardKeyCode(event, 'ArrowLeft', LEFT_ARROW) || hasKeyboardKeyCode(event, 'ArrowRight', RIGHT_ARROW) ||
            hasKeyboardKeyCode(event, 'ArrowDown', DOWN_ARROW) || hasKeyboardKeyCode(event, 'ArrowUp', UP_ARROW);
    }
}
AdaptMentionDirective.ɵfac = function AdaptMentionDirective_Factory(t) { return new (t || AdaptMentionDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.AdaptRadarService)); };
AdaptMentionDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptMentionDirective, selectors: [["", "adaptMention", ""]], hostBindings: function AdaptMentionDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("keydown", function AdaptMentionDirective_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); })("keyup", function AdaptMentionDirective_keyup_HostBindingHandler($event) { return ctx.onKeyUp($event); })("blur", function AdaptMentionDirective_blur_HostBindingHandler() { return ctx.onBlur(); });
    } }, inputs: { mentionConfig: ["adaptMention", "mentionConfig"], mentionStyleConfig: "mentionStyleConfig", showMentionLoader: "showMentionLoader", appendToBody: "appendToBody" }, outputs: { mentionItemSelected: "mentionItemSelected", mentionTriggerCharPressed: "mentionTriggerCharPressed", mentionSearchValueEntered: "mentionSearchValueEntered" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMentionDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptMention]'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ComponentFactoryResolver }, { type: i0.IterableDiffers }, { type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ApplicationRef }, { type: i0.NgZone }, { type: i1.AdaptRadarService }]; }, { mentionConfig: [{
            type: Input,
            args: ['adaptMention']
        }], mentionStyleConfig: [{
            type: Input
        }], showMentionLoader: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], mentionItemSelected: [{
            type: Output
        }], mentionTriggerCharPressed: [{
            type: Output
        }], mentionSearchValueEntered: [{
            type: Output
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], onKeyUp: [{
            type: HostListener,
            args: ['keyup', ['$event']]
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();
//# sourceMappingURL=mention.directive.js.map