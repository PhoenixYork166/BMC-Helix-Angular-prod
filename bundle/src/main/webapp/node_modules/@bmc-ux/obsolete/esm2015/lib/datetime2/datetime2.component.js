/* eslint-disable @typescript-eslint/no-explicit-any */
import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Injector, Input, NgZone, Output, Renderer2, ViewChild } from '@angular/core';
import { FormControl } from '@angular/forms';
import { BehaviorSubject, noop } from 'rxjs';
import { take } from 'rxjs/operators';
import { transition, trigger, useAnimation } from '@angular/animations';
import moment from 'moment-es6';
import { AdaptDeviceDetectionService, AdaptRadarAngularCustomEventName, AdaptTranslateService, ANIMATION_NAME, createFormControlValidator, createFormControlValueAccessor, formatString, FormComponent } from '@bmc-ux/adapt-angular';
import { IsTimeInRange } from '../common/datetime';
import { Clock2FaceUnit } from './datetime2.model';
import { AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@bmc-ux/adapt-angular";
import * as i2 from "@bmc-ux/adapt-radar";
const _c0 = ["inputControlRef"];
const _c1 = ["dropdownRef"];
const _c2 = ["calendarContainer"];
const _c3 = ["nextBtn"];
const _c4 = ["cancelBtn"];
const _c5 = ["clearBtn"];
function AdaptDatetime2Component_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "input", 9, 10);
    i0.ɵɵlistener("input", function AdaptDatetime2Component_div_8_Template_input_input_2_listener() { i0.ɵɵrestoreView(_r11); const _r9 = i0.ɵɵreference(3); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.inputControlWrite(_r9.value); })("click", function AdaptDatetime2Component_div_8_Template_input_click_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.inputControlClick(); })("keydown.enter", function AdaptDatetime2Component_div_8_Template_input_keydown_enter_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.inputControlClick(); })("blur", function AdaptDatetime2Component_div_8_Template_input_blur_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.inputControlBlur(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    const _r0 = i0.ɵɵreference(2);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMap("a3t-datetime--input-control form-control " + (ctx_r1.inputControlClass || ""));
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r1.readonly && ctx_r1.disabledStyleForReadonlyState)("readonly", ctx_r1.readonly)("i-date", !ctx_r1.timePicker)("i-date-time", ctx_r1.timePicker && !ctx_r1.timeOnly)("i-time", ctx_r1.timeOnly)("a3t-datetime--input-control_active", _r0.isOpen())("a3t-datetime--input-control_invalid", ctx_r1._self.errors.length > 0 && ctx_r1._self.control.touched);
    i0.ɵɵproperty("value", ctx_r1.inputControlValue)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly);
    i0.ɵɵattribute("id", ctx_r1.id)("placeholder", ctx_r1.placeholder)("aria-describedby", ctx_r1.ariaDescribedBy);
} }
function AdaptDatetime2Component_ng_template_11_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2Component_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelementStart(1, "div", 11);
    i0.ɵɵlistener("mousedown", function AdaptDatetime2Component_ng_template_11_Template_div_mousedown_1_listener() { i0.ɵɵrestoreView(_r17); const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.dropdownMouseDown(); });
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptDatetime2Component_ng_template_11_ng_container_3_Template, 1, 0, "ng-container", 6);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n      ");
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    const _r4 = i0.ɵɵreference(17);
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(ctx_r2.dropdownClass || "");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r2.inline)("ngIfThen", _r4);
} }
function AdaptDatetime2Component_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2Component_ng_template_16_div_6_span_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r24.headings.applyBtn);
} }
function AdaptDatetime2Component_ng_template_16_div_6_span_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r25 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r25.headings.nextBtn);
} }
function AdaptDatetime2Component_ng_template_16_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r27 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "div");
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "button", 17, 18);
    i0.ɵɵlistener("click", function AdaptDatetime2Component_ng_template_16_div_6_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r27); const ctx_r26 = i0.ɵɵnextContext(2); return ctx_r26.pickerCloseAndCancel(); });
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementStart(9, "div", 19);
    i0.ɵɵtext(10, "\n            ");
    i0.ɵɵelementStart(11, "button", 20, 21);
    i0.ɵɵlistener("click", function AdaptDatetime2Component_ng_template_16_div_6_Template_button_click_11_listener() { i0.ɵɵrestoreView(_r27); const ctx_r28 = i0.ɵɵnextContext(2); return ctx_r28.pickerClearAll(); });
    i0.ɵɵtext(13);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n            ");
    i0.ɵɵelementStart(15, "button", 22, 23);
    i0.ɵɵlistener("click", function AdaptDatetime2Component_ng_template_16_div_6_Template_button_click_15_listener($event) { i0.ɵɵrestoreView(_r27); const ctx_r29 = i0.ɵɵnextContext(2); $event.stopPropagation(); return ctx_r29.goToNextStep(); });
    i0.ɵɵtext(17, "\n              ");
    i0.ɵɵtemplate(18, AdaptDatetime2Component_ng_template_16_div_6_span_18_Template, 2, 1, "span", 4);
    i0.ɵɵtext(19, "\n              ");
    i0.ɵɵtemplate(20, AdaptDatetime2Component_ng_template_16_div_6_span_20_Template, 2, 1, "span", 4);
    i0.ɵɵtext(21, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("two-rows-wrap", ctx_r19.twoRowsWrap || ctx_r19.threeRowsWrap);
    i0.ɵɵadvance(4);
    i0.ɵɵpropertyInterpolate("id", ctx_r19.id + "-cancel-btn");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r19.headings.cancelBtn, "");
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("three-rows-wrap", ctx_r19.threeRowsWrap);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("id", ctx_r19.id + "-clear-btn");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r19.headings.clearBtn, "");
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("id", ctx_r19.id + "-wizard-step-btn");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r19.isLastWizardStep);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r19.isLastWizardStep);
} }
function AdaptDatetime2Component_ng_template_16_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2Component_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    const _r31 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 12, 13);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "adapt-datetime2-picker", 14);
    i0.ɵɵlistener("timeModeChange", function AdaptDatetime2Component_ng_template_16_Template_adapt_datetime2_picker_timeModeChange_4_listener($event) { i0.ɵɵrestoreView(_r31); const ctx_r30 = i0.ɵɵnextContext(); return ctx_r30.timeModeChange($event); })("clockFaceChange", function AdaptDatetime2Component_ng_template_16_Template_adapt_datetime2_picker_clockFaceChange_4_listener($event) { i0.ɵɵrestoreView(_r31); const ctx_r32 = i0.ɵɵnextContext(); return ctx_r32.clockFaceChange($event); })("valueChange", function AdaptDatetime2Component_ng_template_16_Template_adapt_datetime2_picker_valueChange_4_listener($event) { i0.ɵɵrestoreView(_r31); const ctx_r33 = i0.ɵɵnextContext(); return ctx_r33.selectDateTime($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵtemplate(6, AdaptDatetime2Component_ng_template_16_div_6_Template, 24, 11, "div", 15);
    i0.ɵɵtext(7, "\n\n        ");
    i0.ɵɵtemplate(8, AdaptDatetime2Component_ng_template_16_ng_container_8_Template, 1, 0, "ng-container", 6);
    i0.ɵɵtext(9, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    const _r7 = i0.ɵɵreference(22);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("a3t-datetime-inline-light", ctx_r5.inline && ctx_r5.inlineLight)("a3t-datetime-inline-small", ctx_r5.inline && ctx_r5.inlineSize === "small");
    i0.ɵɵproperty("ngClass", ctx_r5.isMobile ? "a3t-datetime--calendar-width" : "a3t-datetime--calendar-min-width");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("initialValue", ctx_r5.initialValue)("activeValue", ctx_r5.value)("dateFilter", ctx_r5.dateFilter)("timePicker", ctx_r5.timePicker)("timeOnly", ctx_r5.timeOnly)("monthAndYearOnly", ctx_r5.monthAndYearOnly)("monthFirst", ctx_r5.monthFirst)("timeSeconds", ctx_r5.seconds)("timeFormat", ctx_r5.timeInputFormat)("timeMode", ctx_r5.timeModeState$.value)("activeFace", ctx_r5.clockFaceState$.value)("disabled", ctx_r5.disabled)("readonly", ctx_r5.readonly)("emptyDateHeading", ctx_r5.headings.emptyDate)("emptyTimeHeading", ctx_r5.headings.emptyTime)("clockHeadings", ctx_r5.headings);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r5.inline);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.inline)("ngIfThen", _r7);
} }
function AdaptDatetime2Component_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2Component_ng_template_21_div_1_div_2_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 30);
} }
function AdaptDatetime2Component_ng_template_21_div_1_div_2_strong_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "strong");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r36 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", error_r36.name, " ");
} }
function AdaptDatetime2Component_ng_template_21_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 27);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptDatetime2Component_ng_template_21_div_1_div_2_div_2_Template, 1, 0, "div", 28);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "div", 29);
    i0.ɵɵtemplate(5, AdaptDatetime2Component_ng_template_21_div_1_div_2_strong_5_Template, 2, 1, "strong", 4);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r36 = ctx.$implicit;
    const ctx_r35 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r35.inline);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", error_r36.name);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(error_r36.text);
} }
function AdaptDatetime2Component_ng_template_21_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 25);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptDatetime2Component_ng_template_21_div_1_div_2_Template, 8, 3, "div", 26);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r34 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r34._self.errors);
} }
function AdaptDatetime2Component_ng_template_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptDatetime2Component_ng_template_21_div_1_Template, 4, 2, "div", 24);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r8._self.errors.length > 0 && ctx_r8._self.control.touched);
} }
const _c6 = function () { return { isPicker: true }; };
const MIN_DROPDOWN_WIDTH = 270;
export class AdaptDatetime2Component extends FormComponent {
    constructor(_injector, _deviceDetectorService, _renderer, _changeDetectorRef, _ngZone, ts, _adaptRadarService, _elem) {
        super(_injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptDatetime2);
        this._injector = _injector;
        this._deviceDetectorService = _deviceDetectorService;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        // Self link
        this._self = this;
        // UI fields
        this.inputControlValue = '';
        this.dropdownAutoClose = 'outside';
        this.timeModeState$ = new BehaviorSubject(false);
        this.clockFaceState$ = new BehaviorSubject(Clock2FaceUnit.Hours);
        this.isLastWizardStep = false;
        this.twoRowsWrap = false;
        this.threeRowsWrap = false;
        this.defaultTexts = {};
        this.defaultErrors = {
            invalidValueName: '',
            invalidValue: '',
            disabledDateName: '',
            disabledDate: '',
            disabledTimeName: '',
            disabledTime: '',
        };
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * Datetime input label
         */
        this.label = '';
        /**
         * Datetime input placeholder
         */
        this.placeholder = '';
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Inputs
        /**
         * DateTime inline mode
         */
        this.inline = false;
        /**
         * DateTime inline light color scheme mode
         */
        this.inlineLight = true;
        /**
         * DateTime inline small size mode
         */
        this.inlineSize = 'default';
        /**
         * Class for datetime dropdown
         */
        this.dropdownClass = 'dropdown-menu p-0';
        /**
         * Date input format
         */
        this.dateInputFormat = 'LL';
        /**
         * Time input format without seconds
         */
        this.timeInputFormat = 'LT';
        /**
         * Time input format with seconds
         */
        this.timeInputLongFormat = 'LTS';
        /**
         * Toggle time picker
         */
        this.timePicker = false;
        /**
         * Use only the time picker flag
         */
        this.timeOnly = false;
        /**
         * Use only the month and year picker flag
         */
        this.monthAndYearOnly = false;
        this.monthFirst = false;
        /**
         * Use seconds in time picker
         */
        this.seconds = false;
        /**
         * Use disabled style for the control if [readonly]=true
         */
        this.disabledStyleForReadonlyState = false;
        /**
         * Picker placement
         */
        this.placement = ['bottom-left', 'top-left', 'bottom-right', 'top-right', 'bottom-left'];
        /**
         * Append to body trigger
         */
        this.appendToBody = false;
        /**
         * Prevent choosing dateTime value step-by-step
         */
        this.preventWizard = false;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        // Outputs
        /**
         * Event on picker open
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.open = new EventEmitter();
        /**
         * Event on picker close
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.close = new EventEmitter();
        /**
         * Event on ngModel change
         */
        this.valueChange = new EventEmitter();
        /**
         * FormControl focus implementation
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        /**
         * FormControl blur implementation
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        // Privates fields for ControlValueAccessor
        this._onTouchedCallback = noop;
        this._onChangeCallback = noop;
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Template refs
        // ngModel value
        this._model = null;
        // previousNgModel value
        this._previousModel = null;
        this.dropdownAutoClose = this._deviceDetectorService.isMobile() ? false : 'outside';
        this.isMobile = this._deviceDetectorService.isMobile();
        this.isIE = this._deviceDetectorService.isIE();
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get value() {
        return this._model;
    }
    set value(v) {
        if (this.disabled) {
            return;
        }
        this._model = v;
        this._onChangeCallback(this._model);
        this.valueChange.emit(this._model);
        this._inputControlFormatting();
    }
    ngOnInit() {
        super.ngOnInit();
        this.initControl();
        if (!this.id) {
            this.id = `dt-${AdaptDatetime2Component.DT_ID++}`;
        }
        if (!this.name) {
            this.name = `${this.id}-form-control`;
        }
        if (this.timeOnly) {
            this.timePicker = true;
        }
        if (this.inline) {
            this._openPicker();
        }
        if (!this.mainCls) {
            this.mainCls = this.inline ? '' : 'form-group';
        }
        // Detect close event on dd
        this._dtDropdownOpenChangeSub = this.dropdownRef.onClose.subscribe(() => {
            if (!this.inline) {
                this._closePicker();
            }
        });
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        this.headings = Object.assign(Object.assign({}, this.defaultTexts), this.headings);
        if (this.tooltipIconCls && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIconCls,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    ngOnDestroy() {
        this._dtDropdownOpenChangeSub.unsubscribe();
    }
    setDefaultTexts(translation) {
        this.defaultTexts.emptyDate = translation['adapt.datetime.emptyDate'];
        this.defaultTexts.emptyTime = translation['adapt.datetime.emptyTime'];
        this.defaultTexts.emptyMonth = translation['adapt.datetime.emptyMonth'];
        this.defaultTexts.cancelBtn = translation['adapt.common.cancel'];
        this.defaultTexts.clearBtn = translation['adapt.common.clearAll'];
        this.defaultTexts.nextBtn = translation['adapt.common.next'];
        this.defaultTexts.applyBtn = translation['adapt.common.ok'];
        this.defaultTexts.hhBtn = translation['adapt.datetime.hh'];
        this.defaultTexts.mmBtn = translation['adapt.datetime.mm'];
        this.defaultTexts.ssBtn = translation['adapt.datetime.ss'];
        this.defaultTexts.amBtn = translation['adapt.datetime.am'];
        this.defaultTexts.pmBtn = translation['adapt.datetime.pm'];
        this.requiredLabel = translation['adapt.common.required'];
        this.defaultErrors.invalidValueName = translation['adapt.datetime.error.invalidValueName'];
        this.defaultErrors.invalidValue = translation['adapt.datetime.error.invalidValue'];
        this.defaultErrors.disabledDateName = translation['adapt.datetime.error.disabledDateName'];
        this.defaultErrors.disabledDate = translation['adapt.datetime.error.disabledDate'];
        this.defaultErrors.disabledTimeName = translation['adapt.datetime.error.disabledTimeName'];
        this.defaultErrors.disabledTime = translation['adapt.datetime.error.disabledTime'];
    }
    /**
     * Datetime wizard
     */
    goToNextStep() {
        if (this.inline) {
            return;
        }
        if (this.preventWizard) {
            this.pickerCloseAndApply();
            return;
        }
        if (this.timePicker) {
            if (!this.timeModeState$.value) {
                this.timeModeState$.next(true);
            }
            else {
                if (this.clockFaceState$.value === (this.seconds ? Clock2FaceUnit.Seconds : Clock2FaceUnit.Minutes)) {
                    if (!!this.value && this.value.isValid()) {
                        this.pickerCloseAndApply();
                    }
                    else {
                        if (this.timeOnly) {
                            this.clockFaceState$.next(Clock2FaceUnit.Hours);
                        }
                        else {
                            this.timeModeState$.next(false);
                        }
                    }
                }
                else {
                    this.clockFaceState$.next(this.clockFaceState$.value + 1);
                }
            }
        }
        else {
            this.pickerCloseAndApply();
        }
        this._checkIfLastWizardStep();
    }
    /**
     * Select date/time on picker
     */
    selectDateTime(v) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.value = v.clone();
        if (this.inline) {
            this._onTouchedCallback();
        }
    }
    /**
     * Close picker and set previous model value
     */
    pickerCloseAndCancel() {
        this.value = this._previousModel;
        this._closePicker();
    }
    /**
     * Close picker and use current value
     */
    pickerCloseAndApply() {
        this._closePicker();
    }
    /**
     * Clear model value
     */
    pickerClearAll() {
        this.value = null;
        this._checkIfLastWizardStep();
        if (this.isMobile) {
            this._closePicker();
        }
    }
    /**
     * Input control (input) handler
     */
    inputControlWrite(v) {
        this.inputControlValue = v;
        this.value = this._tryParseToMoment(v);
    }
    /**
     * Input control (click) handler
     */
    inputControlClick() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.focus.emit();
        if (!this.dropdownRef.isOpen()) {
            this._openPicker();
        }
    }
    /**
     * Input control (blur) handler
     */
    inputControlBlur() {
        this.blur.emit();
        this._inputControlFormatting();
        if (!this.dropdownRef.isOpen()) {
            this._onTouchedCallback();
        }
    }
    /**
     * Dropdown mousedown handler
     */
    dropdownMouseDown() {
        this._blurInput();
    }
    /**
     * Open picker
     */
    /**
     * Time mode change handler
     */
    timeModeChange(v) {
        if (this.timeModeState$.value !== v) {
            this.timeModeState$.next(v);
        }
        if (v && (this.clockFaceState$.value !== Clock2FaceUnit.Hours)) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this.clockFaceState$.next(Clock2FaceUnit.Hours);
            });
        }
        this._checkIfLastWizardStep();
    }
    /**
     * Close picker
     */
    /**
     * Clock face change handler
     */
    clockFaceChange(v) {
        if (this.clockFaceState$.value !== v) {
            this.clockFaceState$.next(v);
        }
        this._checkIfLastWizardStep();
    }
    writeValue(v) {
        this._model = this._getNormalizedModelValue(v);
        this._inputControlFormatting();
    }
    /**
     * Parse and format input control value
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * Get formatted [timeMin] prop value
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * Get formatted [timeMax] prop value
     */
    setDisabledState(isDisabled) {
        this._disabled = isDisabled;
    }
    /**
     * Get format for input control value
     */
    validate(c) {
        const dateFormatError = {
            dateError: this._customErrorTexts.dateFormatError || {
                name: this.defaultErrors.invalidValueName,
                text: formatString(this.defaultErrors.invalidValue, moment().format(this._getInputControlFormat()))
            }
        };
        const unselectableDateError = {
            dateError: this._customErrorTexts.unselectableDateError || {
                name: this.defaultErrors.disabledDateName,
                text: this.defaultErrors.disabledDate
            }
        };
        const unselectableTimeError = {
            dateError: this._customErrorTexts.unselectableTimeError || {
                name: this.defaultErrors.disabledTimeName,
                text: formatString(this.defaultErrors.disabledTime, this._getFormattedStartTime(), this._getFormattedEndTime())
            }
        };
        const controlValue = moment.isMoment(c.value) ? c.value : this._getNormalizedModelValue(c.value);
        const errFormat = controlValue && !moment(controlValue).isValid();
        const disableDate = controlValue && moment(controlValue).isValid() && this.dateFilter && !this.dateFilter(controlValue, c);
        const disableTime = controlValue && moment(controlValue).isValid() && this.timeMin && this.timeMax &&
            !IsTimeInRange(controlValue, this.timeMin, this.timeMax);
        return errFormat ? dateFormatError :
            disableDate ? unselectableDateError :
                disableTime ? unselectableTimeError : null;
    }
    _truncateBtn(btn) {
        const xPadings = 10;
        if (btn.offsetWidth + xPadings > window.innerWidth - xPadings) {
            this._renderer.addClass(btn, 'text-truncate');
            return window.innerWidth - xPadings;
        }
        else {
            return btn.offsetWidth + xPadings;
        }
    }
    _wrapButtons() {
        const xPadings = 10; // left and right padding
        const cancelBtnWidth = this.cancelBtn.nativeElement.offsetWidth; // cancel button width
        const nextBtnWidth = this.nextBtn.nativeElement.offsetWidth; // next button width
        const clearBtnWidth = this.clearBtn.nativeElement.offsetWidth; // clear button width
        const btnGroupWidth = nextBtnWidth + clearBtnWidth + 5; // clear + next buttons width + margins
        const buttonsWidth = cancelBtnWidth + btnGroupWidth + xPadings; // all buttons width
        let containerWidth = buttonsWidth < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : buttonsWidth;
        if (window.innerWidth - xPadings < buttonsWidth) {
            // wrap button in two rows
            if (btnGroupWidth + xPadings < window.innerWidth - xPadings) {
                const firstRowWidth = btnGroupWidth + xPadings < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : btnGroupWidth + xPadings;
                const secondRowWidth = this._truncateBtn(this.cancelBtn.nativeElement);
                containerWidth = Math.max(firstRowWidth, secondRowWidth);
                this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
                this.twoRowsWrap = true;
            }
            else {
                // wrap button in three rows
                const firstRowWidth = this._truncateBtn(this.nextBtn.nativeElement);
                const secondRowWidth = this._truncateBtn(this.clearBtn.nativeElement);
                const thirdRowWidth = this._truncateBtn(this.cancelBtn.nativeElement);
                const maxButtonWidth = Math.max(firstRowWidth, secondRowWidth, thirdRowWidth);
                containerWidth = maxButtonWidth < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : maxButtonWidth;
                this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
                this.threeRowsWrap = true;
            }
        }
        else {
            this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
        }
    }
    _openPicker() {
        this._previousModel = this.value ? this.value.clone() : null;
        if (this.inline) {
            return;
        }
        this._checkIfLastWizardStep();
        if (!this.inline && (this.isMobile || this.isIE)) {
            // in some cases nativeElements is undefined, need to wait zone stable
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this._wrapButtons();
            });
        }
        this.timeModeState$.next(this.timeOnly);
        this.clockFaceState$.next(Clock2FaceUnit.Hours);
        this.dropdownRef.open();
        this.open.emit(this.id);
        if (this.isMobile) {
            this._blurInput();
        }
    }
    _closePicker() {
        this.twoRowsWrap = false;
        this.threeRowsWrap = false;
        if (this.inline) {
            return;
        }
        this.dropdownRef.close(); // DOUBLE CLOSE BECAUSE OF SUBSCRIPTION
        this.close.emit(this.id);
        this._onTouchedCallback();
        this._blurInput();
    }
    /**
     * Get time format
     */
    _blurInput() {
        if (this.inputControlRef) {
            this.inputControlRef.nativeElement.blur();
        }
    }
    _inputControlFormatting() {
        if (this.inputControlRef && (this.inputControlRef.nativeElement === document.activeElement)) {
            return;
        }
        if (this.value) {
            if (this.value.isValid()) {
                this.inputControlValue = this.value.format(this._getInputControlFormat());
            }
        }
        else {
            this.inputControlValue = '';
        }
        if (!this._changeDetectorRef.destroyed) {
            this._changeDetectorRef.detectChanges();
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // ControlValueAccessor
    _getFormattedStartTime() {
        return (this.timeMin || moment().startOf('day')).format(this._getTimeFormat());
    }
    _getFormattedEndTime() {
        return (this.timeMax || moment().endOf('day')).format(this._getTimeFormat());
    }
    _getInputControlFormat() {
        let format = this.dateInputFormat;
        if (this.timePicker) {
            format += ` ${this._getTimeFormat()}`;
            if (this.timeOnly) {
                format = this._getTimeFormat();
            }
        }
        if (this.monthAndYearOnly) {
            format = 'MMMM, YYYY';
        }
        return format;
    }
    _tryParseToMoment(valueToParse) {
        let parseResult = null;
        if (valueToParse) {
            if (this.timeOnly) {
                // https://stackoverflow.com/questions/34541196/moment-js-gives-invalid-date-in-firefox
                parseResult = moment(`${moment().format(this.dateInputFormat)} ${valueToParse}`, this.dateInputFormat + ' ' + this._getTimeFormat());
            }
            else {
                parseResult = moment(valueToParse, this._getInputControlFormat());
            }
        }
        return parseResult;
    }
    _getTimeFormat() {
        return this.seconds ? this.timeInputLongFormat : this.timeInputFormat;
    }
    _getNormalizedModelValue(value) {
        let momentValue = null;
        if (value) {
            if (moment.isMoment(value) || moment.isDate(value)) {
                momentValue = moment(value);
            }
            else if (typeof (value) === 'string') {
                if (this.writeValueParseFormat) {
                    momentValue = moment(value, this.writeValueParseFormat);
                }
                else {
                    const formattedDateTime = moment(value, [moment.ISO_8601, this._getInputControlFormat()]);
                    momentValue = formattedDateTime.isValid() ? formattedDateTime : moment(value);
                }
            }
            else {
                throw new Error('Wrong DateTime2 model type!');
            }
        }
        return momentValue;
    }
    /**
     * Wizard's last step checking
     */
    _checkIfLastWizardStep() {
        const wizard = !this.preventWizard;
        const lastTimeStep = this.timePicker && this.timeModeState$.value &&
            (this.clockFaceState$.value === (this.seconds ? Clock2FaceUnit.Seconds : Clock2FaceUnit.Minutes));
        const timePicker = this.timePicker;
        const lastStep = timePicker ? lastTimeStep : true;
        const modelFull = !timePicker || (!!this.value && this.value.isValid());
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this.isLastWizardStep = !wizard || lastStep && modelFull;
        });
    }
}
// Static fields
AdaptDatetime2Component.DT_ID = 1;
AdaptDatetime2Component.ɵfac = function AdaptDatetime2Component_Factory(t) { return new (t || AdaptDatetime2Component)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptDatetime2Component.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetime2Component, selectors: [["adapt-datetime2"]], viewQuery: function AdaptDatetime2Component_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 5);
        i0.ɵɵviewQuery(_c3, 5);
        i0.ɵɵviewQuery(_c4, 5);
        i0.ɵɵviewQuery(_c5, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputControlRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cancelBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearBtn = _t.first);
    } }, hostVars: 3, hostBindings: function AdaptDatetime2Component_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("name", ctx.name);
        i0.ɵɵstyleProp("display", "block");
    } }, inputs: { formControl: "formControl", id: "id", name: "name", label: "label", placeholder: "placeholder", inline: "inline", inlineLight: "inlineLight", inlineSize: "inlineSize", initialValue: "initialValue", inputControlClass: "inputControlClass", dropdownClass: "dropdownClass", dateInputFormat: "dateInputFormat", timeInputFormat: "timeInputFormat", timeInputLongFormat: "timeInputLongFormat", timePicker: "timePicker", timeOnly: "timeOnly", monthAndYearOnly: "monthAndYearOnly", monthFirst: "monthFirst", seconds: "seconds", timeMin: "timeMin", timeMax: "timeMax", dateFilter: "dateFilter", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", placement: "placement", appendToBody: "appendToBody", headings: "headings", preventWizard: "preventWizard", writeValueParseFormat: "writeValueParseFormat", ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"] }, outputs: { open: "open", close: "close", valueChange: "valueChange", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptDatetime2Component),
            createFormControlValidator(AdaptDatetime2Component),
        ]), i0.ɵɵInheritDefinitionFeature], decls: 24, vars: 23, consts: [["adaptDropdown", "", 3, "adaptRadarDisableEventSending", "animationPlacement", "placement", "appendToBody", "autoClose", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "mobileView"], ["dropdownRef", "adaptDropdown"], ["adaptDropdownAnchor", ""], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [4, "ngIf"], ["adaptDropdownMenuTemplate", ""], [4, "ngIf", "ngIfThen"], ["calendar", ""], ["errorTemplate", ""], ["autocomplete", "off", 3, "value", "disabled", "readonly", "input", "click", "keydown.enter", "blur"], ["inputControlRef", ""], [3, "mousedown"], [3, "ngClass"], ["calendarContainer", ""], [3, "initialValue", "activeValue", "dateFilter", "timePicker", "timeOnly", "monthAndYearOnly", "monthFirst", "timeSeconds", "timeFormat", "timeMode", "activeFace", "disabled", "readonly", "emptyDateHeading", "emptyTimeHeading", "clockHeadings", "timeModeChange", "clockFaceChange", "valueChange"], ["class", "a3t-datetime--footer", 3, "two-rows-wrap", 4, "ngIf"], [1, "a3t-datetime--footer"], ["type", "button", 1, "btn", "btn-sm", "btn-link", 3, "id", "click"], ["cancelBtn", ""], [1, "d-flex", "justify-content-center"], ["type", "button", 1, "btn", "btn-sm", "btn-secondary", "m-end-1", 3, "id", "click"], ["clearBtn", ""], ["type", "button", 1, "btn", "btn-sm", "btn-primary", 3, "id", "click"], ["nextBtn", ""], ["class", "has-danger", 4, "ngIf"], [1, "has-danger"], ["class", "form-control-feedback d-flex align-items-start m-0 pt-1 pb-0", 4, "ngFor", "ngForOf"], [1, "form-control-feedback", "d-flex", "align-items-start", "m-0", "pt-1", "pb-0"], ["class", "d-icon-exclamation_triangle flex-grow-0 flex-shrink-0 m-end-2", 4, "ngIf"], [1, "flex-grow-1", "flex-shrink-1"], [1, "d-icon-exclamation_triangle", "flex-grow-0", "flex-shrink-0", "m-end-2"]], template: function AdaptDatetime2Component_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0, 1);
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelementStart(4, "div", 2);
        i0.ɵɵtext(5, "\n        ");
        i0.ɵɵelement(6, "adapt-rx-control-label", 3);
        i0.ɵɵtext(7, "\n\n        ");
        i0.ɵɵtemplate(8, AdaptDatetime2Component_div_8_Template, 5, 22, "div", 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵtemplate(11, AdaptDatetime2Component_ng_template_11_Template, 6, 4, "ng-template", 5);
        i0.ɵɵtext(12, "\n\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n\n    ");
        i0.ɵɵtemplate(14, AdaptDatetime2Component_ng_container_14_Template, 1, 0, "ng-container", 6);
        i0.ɵɵtext(15, "\n\n    ");
        i0.ɵɵtemplate(16, AdaptDatetime2Component_ng_template_16_Template, 11, 24, "ng-template", null, 7, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(18, "\n\n    ");
        i0.ɵɵtemplate(19, AdaptDatetime2Component_ng_container_19_Template, 1, 0, "ng-container", 6);
        i0.ɵɵtext(20, "\n\n    ");
        i0.ɵɵtemplate(21, AdaptDatetime2Component_ng_template_21_Template, 3, 1, "ng-template", null, 8, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(23, "\n  ");
    } if (rf & 2) {
        const _r4 = i0.ɵɵreference(17);
        const _r7 = i0.ɵɵreference(22);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("animationPlacement", "center")("placement", ctx.placement)("appendToBody", ctx.appendToBody)("autoClose", ctx.dropdownAutoClose)("holdFocusInMenu", true)("holdFocusOnOpen", false)("autoFocusFirst", false)("restoreFocusAfterClose", false)("mobileView", i0.ɵɵpureFunction0(22, _c6));
        i0.ɵɵadvance(3);
        i0.ɵɵclassProp("has-danger", ctx._self.errors.length > 0 && ctx._self.control.touched);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx._self.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.inline);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", ctx.inline)("ngIfThen", _r4);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", !ctx.inline)("ngIfThen", _r7);
    } }, encapsulation: 2, data: { animation: [
            trigger('heightAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '0',
                            to: '*'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '*',
                            to: '0'
                        }
                    })
                ])
            ]),
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetime2Component, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime2',
                template: `
    <div adaptDropdown
         [adaptRadarDisableEventSending]="true"
         #dropdownRef="adaptDropdown"
         [animationPlacement]="'center'"
         [placement]="placement"
         [appendToBody]="appendToBody"
         [autoClose]="dropdownAutoClose"
         [holdFocusInMenu]="true"
         [holdFocusOnOpen]="false"
         [autoFocusFirst]="false"
         [restoreFocusAfterClose]="false"
         [mobileView]="{isPicker: true}">
      <div adaptDropdownAnchor [class.has-danger]="_self.errors.length > 0 && _self.control.touched">
        <adapt-rx-control-label [for]="id"
                                [label]="label"
                                [requiredLabel]="requiredLabel"
                                [showRequiredLabel]="_self.required"
                                [tooltip]="tooltipConfig"></adapt-rx-control-label>

        <div *ngIf="!inline">
          <input #inputControlRef
                 autocomplete="off"
                 [attr.id]="id"
                 [class]="'a3t-datetime--input-control form-control ' + (inputControlClass || '')"
                 [class.form-control-disabled-look]="readonly && this.disabledStyleForReadonlyState"
                 [value]="inputControlValue"
                 (input)="inputControlWrite(inputControlRef.value)"
                 (click)="inputControlClick()"
                 (keydown.enter)="inputControlClick()"
                 (blur)="inputControlBlur()"
                 [disabled]="disabled"
                 [readonly]="readonly"
                 [attr.placeholder]="placeholder"
                 [attr.aria-describedby]="ariaDescribedBy"
                 [class.readonly]="readonly"
                 [class.i-date]="!timePicker"
                 [class.i-date-time]="timePicker && !timeOnly"
                 [class.i-time]="timeOnly"
                 [class.a3t-datetime--input-control_active]="dropdownRef.isOpen()"
                 [class.a3t-datetime--input-control_invalid]="_self.errors.length > 0 && _self.control.touched"/>
        </div>
      </div>
      <ng-template adaptDropdownMenuTemplate>
        <div [class]="dropdownClass || ''" (mousedown)="dropdownMouseDown()">
          <ng-container *ngIf="!inline; then calendar"></ng-container>
        </div>
      </ng-template>

    </div>

    <ng-container *ngIf="inline; then calendar"></ng-container>

    <ng-template #calendar>
      <div #calendarContainer [ngClass]="isMobile ? 'a3t-datetime--calendar-width' : 'a3t-datetime--calendar-min-width'"
           [class.a3t-datetime-inline-light]="inline && inlineLight"
           [class.a3t-datetime-inline-small]="inline && inlineSize === 'small'">
        <adapt-datetime2-picker [initialValue]="initialValue"
                                [activeValue]="value"
                                [dateFilter]="dateFilter"
                                [timePicker]="timePicker"
                                [timeOnly]="timeOnly"
                                [monthAndYearOnly]="monthAndYearOnly"
                                [monthFirst]="monthFirst"
                                [timeSeconds]="seconds"
                                [timeFormat]="timeInputFormat"
                                [timeMode]="timeModeState$.value"
                                [activeFace]="clockFaceState$.value"
                                [disabled]="disabled"
                                [readonly]="readonly"
                                [emptyDateHeading]="headings.emptyDate"
                                [emptyTimeHeading]="headings.emptyTime"
                                [clockHeadings]="headings"
                                (timeModeChange)="timeModeChange($event)"
                                (clockFaceChange)="clockFaceChange($event)"
                                (valueChange)="selectDateTime($event)"></adapt-datetime2-picker>
        <div class="a3t-datetime--footer" [class.two-rows-wrap]="twoRowsWrap || threeRowsWrap" *ngIf="!inline">
          <div>
            <button #cancelBtn id="{{id + '-cancel-btn'}}" type="button" class="btn btn-sm btn-link"
                    (click)="pickerCloseAndCancel()">
              {{headings.cancelBtn}}</button>
          </div>
          <div class="d-flex justify-content-center" [class.three-rows-wrap]="threeRowsWrap">
            <button #clearBtn id="{{id + '-clear-btn'}}" type="button" class="btn btn-sm btn-secondary m-end-1"
                    (click)="pickerClearAll()">
              {{headings.clearBtn}}</button>
            <button #nextBtn id="{{id + '-wizard-step-btn'}}" type="button" class="btn btn-sm btn-primary"
                    (click)="$event.stopPropagation(); goToNextStep()">
              <span *ngIf="isLastWizardStep">{{headings.applyBtn}}</span>
              <span *ngIf="!isLastWizardStep">{{headings.nextBtn}}</span>
            </button>
          </div>
        </div>

        <ng-container *ngIf="inline; then errorTemplate"></ng-container>
      </div>
    </ng-template>

    <ng-container *ngIf="!inline; then errorTemplate"></ng-container>

    <ng-template #errorTemplate>
      <div class="has-danger" *ngIf="_self.errors.length > 0 && _self.control.touched" [@validationFeedbackAnimation]>
        <div class="form-control-feedback d-flex align-items-start m-0 pt-1 pb-0" *ngFor="let error of _self.errors">
          <div class="d-icon-exclamation_triangle flex-grow-0 flex-shrink-0 m-end-2" *ngIf="inline"></div>
          <div class="flex-grow-1 flex-shrink-1"><strong *ngIf="error.name">{{error.name}} </strong>{{error.text}}</div>
        </div>
      </div>
    </ng-template>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.name]': 'name',
                    '[style.display]': '"block"'
                },
                animations: [
                    trigger('heightAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '0',
                                    to: '*'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '*',
                                    to: '0'
                                }
                            })
                        ])
                    ]),
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ],
                providers: [
                    createFormControlValueAccessor(AdaptDatetime2Component),
                    createFormControlValidator(AdaptDatetime2Component),
                ]
            }]
    }], function () { return [{ type: i0.Injector }, { type: i1.AdaptDeviceDetectionService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { formControl: [{
            type: Input
        }], id: [{
            type: Input
        }], name: [{
            type: Input
        }], label: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], inline: [{
            type: Input
        }], inlineLight: [{
            type: Input
        }], inlineSize: [{
            type: Input
        }], initialValue: [{
            type: Input
        }], inputControlClass: [{
            type: Input
        }], dropdownClass: [{
            type: Input
        }], dateInputFormat: [{
            type: Input
        }], timeInputFormat: [{
            type: Input
        }], timeInputLongFormat: [{
            type: Input
        }], timePicker: [{
            type: Input
        }], timeOnly: [{
            type: Input
        }], monthAndYearOnly: [{
            type: Input
        }], monthFirst: [{
            type: Input
        }], seconds: [{
            type: Input
        }], timeMin: [{
            type: Input
        }], timeMax: [{
            type: Input
        }], dateFilter: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], placement: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], headings: [{
            type: Input
        }], preventWizard: [{
            type: Input
        }], writeValueParseFormat: [{
            type: Input
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], inputControlRef: [{
            type: ViewChild,
            args: ['inputControlRef']
        }], dropdownRef: [{
            type: ViewChild,
            args: ['dropdownRef', { static: true }]
        }], calendarContainer: [{
            type: ViewChild,
            args: ['calendarContainer']
        }], nextBtn: [{
            type: ViewChild,
            args: ['nextBtn']
        }], cancelBtn: [{
            type: ViewChild,
            args: ['cancelBtn']
        }], clearBtn: [{
            type: ViewChild,
            args: ['clearBtn']
        }] }); })();
//# sourceMappingURL=datetime2.component.js.map