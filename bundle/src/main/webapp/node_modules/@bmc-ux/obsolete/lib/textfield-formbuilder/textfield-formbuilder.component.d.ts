import { AfterViewInit, ElementRef, EventEmitter, NgZone, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChanges, TemplateRef } from '@angular/core';
import { ControlValueAccessor, FormControl } from '@angular/forms';
import { TextfieldNestedSettings } from '../textfield/textfield.interface';
import { Directionality } from '@angular/cdk/bidi';
import { AdaptRxControlLabelTooltip, ResizeService } from '@bmc-ux/adapt-angular';
import { AdaptRadarGenericDirective, AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
export declare const ADAPT_TEXTFIELD_FORMBUILDER_ACCESSOR: any;
export declare class AdaptTextFieldFormBuilderComponent extends AdaptRadarGenericDirective implements ControlValueAccessor, OnInit, OnChanges, AfterViewInit, OnDestroy {
    private elemRef;
    private renderer;
    private _dir;
    private _ngZone;
    private _resizeService;
    nestedSettingsDefault: TextfieldNestedSettings;
    inputStyles: CSSStyleDeclaration;
    isTextOverflow: boolean;
    isRtl: boolean;
    /**
     * Reference to input element
     */
    inputElement: ElementRef;
    inputTextWidthEl: ElementRef<HTMLDivElement>;
    overflowText: boolean;
    /**
     * Label icon with a tooltip or popover
     */
    tooltipConfig: AdaptRxControlLabelTooltip;
    /**
     * The input element type {bs4 view}.
     */
    nested: boolean;
    /**
     *  Whether the element has settings for type 'nested'
     */
    nestedSettings: TextfieldNestedSettings;
    /**
     * Style class of the component.
     */
    customClass: string;
    /**
     * The plain text label for the input element
     */
    label: string;
    /**
     * The input element type; by default is 'text'
     */
    type: string;
    /**
     * Unique id of the element.
     */
    id: string;
    /**
     * The icon must be a dpl-iconfont or adapt-iconfont.
     */
    icon: string;
    /**
     * Whether the input is with success icon
     */
    iconValid: boolean;
    /**
     * Whether the input is with error icon
     */
    iconInvalid: boolean;
    /**
     * TabIndex attribute of the element
     */
    tabindex: number;
    /**
     * Maxlength attribute of the element
     */
    maxlength: number;
    /**
     * Minlength attribute of the element
     */
    minlength: number;
    /**
     * Placeholder attribute of the element.
     */
    placeholder: string;
    /**
     * Autocomplete attribute of the element.
     */
    autocomplete: string;
    /**
     * Additional validation patterns of the element [deprecated]
     */
    pattern: any;
    min: any;
    max: any;
    step: any;
    name: any;
    /** FormControl of input element */
    control: FormControl;
    /** Whether the element is disabled */
    disableControl: any;
    /**
     * An object used to control when error/success messages are shown
     */
    displayMessage: any;
    /**
     * Whether the input is valid
     */
    validState: boolean;
    /**
     * Whether the input is required. The plain text 'requiredLabel' for the input element
     */
    requiredLabel: string;
    /**
     * Tooltip icon and additional text for it.
     */
    tooltipIcon: string;
    tooltipText: string;
    /**
     * Popover icon and additional content for it.
     */
    popoverIcon: string;
    popoverPlacement: string;
    popoverTriggers: string;
    popoverContent: string | TemplateRef<any>;
    labelCount: boolean;
    /**
     * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
     * take precedence so this may be omitted.
     */
    ariaLabel: string | null;
    /**
     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
     */
    ariaLabelledby: string | null;
    ariaDescribedBy: string | null;
    readonly focusEmitter: EventEmitter<FocusEvent>;
    readonly blurEmitter: EventEmitter<FocusEvent>;
    /** Whether the element is required. */
    get required(): any;
    set required(value: any);
    /** Whether the element is readonly. */
    get readonly(): any;
    set readonly(value: any);
    /**
     * Use disabled style for the control if [readonly]=true
     */
    disabledStyleForReadonlyState: boolean;
    /** Whether the element is textarea. */
    get rows(): any;
    set rows(value: any);
    /** Whether the element has maxrows. */
    get maxrows(): any;
    set maxrows(value: any);
    /** Whether the element has autofocus. */
    get autofocus(): any;
    set autofocus(value: any);
    /** The input element's value. */
    get value(): any;
    set value(v: any);
    set toggleStateValidation(value: any);
    private _readonly;
    private _rows;
    private _maxrows;
    private _autofocus;
    private _value;
    private hasFocus;
    private onTouchedCallback;
    private onChangeCallback;
    private _destroyed$;
    /**
     * Private variables of textfield component
     */
    private _required;
    constructor(elemRef: ElementRef, renderer: Renderer2, _dir: Directionality, _ngZone: NgZone, _resizeService: ResizeService, _adaptRadarService: AdaptRadarService);
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(value: any): void;
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn: any): void;
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn: any): void;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * Control disabled state from component
     */
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * Callback for the cases where the focused state of the input changes
     */
    onFocus(event: any): void;
    /**
     * Callback for the cases where the focused state is out of input element
     */
    onBlur(event: any): void;
    onKeyup(): void;
    private _applyTextOverflow;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptTextFieldFormBuilderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AdaptTextFieldFormBuilderComponent, "adapt-textfield-formbuilder", never, { "overflowText": "overflowText"; "nested": "nested"; "nestedSettings": "nestedSettings"; "customClass": "customClass"; "label": "label"; "type": "type"; "id": "id"; "icon": "icon"; "iconValid": "iconValid"; "iconInvalid": "iconInvalid"; "tabindex": "tabindex"; "maxlength": "maxlength"; "minlength": "minlength"; "placeholder": "placeholder"; "autocomplete": "autocomplete"; "pattern": "pattern"; "min": "min"; "max": "max"; "step": "step"; "name": "name"; "control": "control"; "disableControl": "disableControl"; "displayMessage": "displayMessage"; "validState": "validState"; "requiredLabel": "requiredLabel"; "tooltipIcon": "tooltipIcon"; "tooltipText": "tooltipText"; "popoverIcon": "popoverIcon"; "popoverPlacement": "popoverPlacement"; "popoverTriggers": "popoverTriggers"; "popoverContent": "popoverContent"; "labelCount": "labelCount"; "ariaLabel": "aria-label"; "ariaLabelledby": "aria-labelledby"; "ariaDescribedBy": "aria-describedby"; "required": "required"; "readonly": "readonly"; "disabledStyleForReadonlyState": "disabledStyleForReadonlyState"; "rows": "rows"; "maxrows": "maxrows"; "autofocus": "autofocus"; "toggleStateValidation": "toggleStateValidation"; }, { "focusEmitter": "focus"; "blurEmitter": "blur"; }, never, [".label-count", ".label-count-bottom", "*"]>;
}
