import { AfterContentChecked, AfterViewInit, ChangeDetectorRef, ElementRef, EventEmitter, InjectionToken, Injector, NgZone, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChanges, TemplateRef } from '@angular/core';
import { ControlValueAccessor, FormControl } from '@angular/forms';
import { TextfieldNestedSettings } from './textfield.interface';
import { Directionality } from '@angular/cdk/bidi';
import { AdaptRxControlLabelTooltip, AdaptTranslateService, ResizeService } from '@bmc-ux/adapt-angular';
import { AdaptRadarGenericDirective, AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
export declare const DISABLE_NATIVE_VALIDITY_CHECKING: InjectionToken<boolean>;
export declare const ADAPT_TEXTFIELD_ACCESSOR: any;
export declare class AdaptTextFieldComponent extends AdaptRadarGenericDirective implements ControlValueAccessor, AfterContentChecked, OnInit, OnChanges, AfterViewInit, OnDestroy {
    private elemRef;
    private renderer;
    private _resizeService;
    private _dir;
    private ts;
    private _ngZone;
    private _cdr;
    private _injector;
    private nativeCheckGlobalDisabled;
    /**
     * Public variables of textfield component
     */
    isError: boolean;
    isDirty: boolean;
    /**
     * addOnTextLeft: string; addOnTextRight: string; addOnLeft: boolean; addOnRight: boolean
     */
    nestedSettingsDefault: TextfieldNestedSettings;
    inputStyles: CSSStyleDeclaration;
    isTextOverflow: boolean;
    isRtl: boolean;
    defaultTexts: {
        valid?: string;
        invalid?: string;
    };
    overflowText: boolean;
    /**
     * Label icon with a tooltip or popover
     */
    tooltipConfig: AdaptRxControlLabelTooltip;
    /**
     * The input element type {bs4 view}.
     */
    nested: boolean;
    /**
     *  Whether the element has settings for type 'nested'
     */
    nestedSettings: TextfieldNestedSettings;
    /**
     * Style class of the component.
     */
    customClass: string;
    /**
     * The plain text label for the input element
     */
    label: string;
    /**
     * The input element type; by default is 'text'
     */
    type: string;
    /**
     * Unique id of the element.
     */
    id: string;
    /**
     * Unique testID of the element.
     */
    testID: string;
    /**
     * The icon must be a dpl-iconfont or adapt-iconfont.
     */
    icon: string;
    /**
     * Whether the input is with success icon
     */
    iconValid: boolean;
    /**
     * Whether the input is with error icon
     */
    iconInvalid: boolean;
    /**
     * TabIndex attribute of the element
     */
    tabindex: number;
    /**
     * Maxlength attribute of the element
     */
    maxlength: number;
    /**
     * Minlength attribute of the element
     */
    minlength: number;
    /**
     * Placeholder attribute of the element.
     */
    placeholder: string;
    arialabel: string;
    /**
     * Autocomplete attribute of the element.
     */
    autocomplete: string;
    /**
     * Additional validation patterns of the element
     */
    pattern: any;
    min: any;
    max: any;
    step: any;
    /**
     * Name attribute of the element.
     */
    name: string;
    /**
     * Whether the input is valid
     */
    validState: boolean;
    /**
     * Whether the input is required. The plain text 'requiredLabel' for the input element
     */
    requiredLabel: string;
    /**
     * Tooltip icon and additional text for it.
     */
    tooltipIcon: string;
    tooltipText: string;
    /**
     * Popover icon and additional content for it.
     */
    popoverIcon: string;
    popoverPlacement: string;
    popoverTriggers: string;
    popoverContent: string | TemplateRef<any>;
    /**
     * An object used to control when error/success messages are shown
     */
    get errorMessage(): string;
    set errorMessage(value: string);
    get successMessage(): string;
    set successMessage(value: string);
    control: FormControl;
    setInvalidState: boolean;
    debounceTime: number;
    /**
     * Reference to input element
     */
    inputElement: ElementRef;
    inputTextWidthEl: ElementRef<HTMLDivElement>;
    readonly focusEmitter: EventEmitter<FocusEvent>;
    readonly blurEmitter: EventEmitter<FocusEvent>;
    readonly valueChanged: EventEmitter<string>;
    readonly inputKeydown: EventEmitter<KeyboardEvent>;
    readonly inputKeypress: EventEmitter<KeyboardEvent>;
    readonly inputKeyup: EventEmitter<KeyboardEvent>;
    /** Whether the element is required. */
    get required(): any;
    set required(value: any);
    /** Whether the element is disabled. */
    get disabled(): any;
    set disabled(value: any);
    /** Whether the element is readonly. */
    get readonly(): any;
    set readonly(value: any);
    /**
     * Use disabled style for the control if [readonly]=true
     */
    disabledStyleForReadonlyState: boolean;
    /** Whether the element is textarea. */
    get rows(): any;
    set rows(value: any);
    /** Whether the element has maxrows. */
    get maxrows(): any;
    set maxrows(value: any);
    /** Whether the element has autofocus. */
    get autofocus(): any;
    set autofocus(value: any);
    get disableNativeValidityChecking(): any;
    set disableNativeValidityChecking(value: any);
    /** The input element's value. */
    get value(): any;
    set value(v: any);
    get ariaLabel(): string;
    set ariaLabel(v: string);
    ariaDescribedBy: string | null;
    get inputGroupClass(): string;
    private el;
    /**
     * ControlValueAccessor required interface
     */
    private onTouchedCallback;
    /**
     * ControlValueAccessor required interface
     */
    private onChangeCallback;
    /**
     * Private variables of textfield component
     */
    private _required;
    private _disabled;
    private _readonly;
    private _rows;
    private _disableNativeValidityChecking;
    private _maxrows;
    private _autofocus;
    private _value;
    private _errorMessage;
    private _successMessage;
    private _isInput;
    private _destroyed$;
    private _ngControl;
    get additionalMessage(): string | null;
    constructor(elemRef: ElementRef, renderer: Renderer2, _resizeService: ResizeService, _dir: Directionality, ts: AdaptTranslateService, _ngZone: NgZone, _cdr: ChangeDetectorRef, _injector: Injector, nativeCheckGlobalDisabled: boolean, _adaptRadarService: AdaptRadarService);
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(value: any): void;
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn: any): void;
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn: any): void;
    /**
     * interface ControlValueAccessor
     * setDisabledState(isDisabled: boolean)?: void
     */
    setDisabledState(isDisabled: boolean): void;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterContentChecked(): void;
    /**
     * Callback for the cases where the focused state of the input changes
     */
    onFocus(event: any): void;
    /**
     * Callback for the cases where the focused state is out of input element
     */
    onBlur(event: any): void;
    /**
     * Check the input element on touch event
     */
    checkOnTouch(): void;
    /**
     * Check the input element on valid/invalid state
     */
    checkIfValid(): void;
    onKeydown(event: KeyboardEvent): void;
    onKeypress(event: KeyboardEvent): void;
    onKeyup(event: KeyboardEvent): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private _applyTextOverflow;
    private _setErrorState;
    private _setSuccessState;
    private setFocus;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptTextFieldComponent, [null, null, null, null, null, null, null, null, { optional: true; }, null]>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AdaptTextFieldComponent, "adapt-textfield, div[form-group]", never, { "overflowText": "overflowText"; "nested": "nested"; "nestedSettings": "nestedSettings"; "customClass": "customClass"; "label": "label"; "type": "type"; "id": "id"; "testID": "testID"; "icon": "icon"; "iconValid": "iconValid"; "iconInvalid": "iconInvalid"; "tabindex": "tabindex"; "maxlength": "maxlength"; "minlength": "minlength"; "placeholder": "placeholder"; "autocomplete": "autocomplete"; "pattern": "pattern"; "min": "min"; "max": "max"; "step": "step"; "name": "name"; "validState": "validState"; "requiredLabel": "requiredLabel"; "tooltipIcon": "tooltipIcon"; "tooltipText": "tooltipText"; "popoverIcon": "popoverIcon"; "popoverPlacement": "popoverPlacement"; "popoverTriggers": "popoverTriggers"; "popoverContent": "popoverContent"; "errorMessage": "error"; "successMessage": "success"; "control": "control"; "setInvalidState": "setInvalidState"; "debounceTime": "debounceTime"; "required": "required"; "disabled": "disabled"; "readonly": "readonly"; "disabledStyleForReadonlyState": "disabledStyleForReadonlyState"; "rows": "rows"; "maxrows": "maxrows"; "autofocus": "autofocus"; "disableNativeValidityChecking": "disableNativeValidityChecking"; "ariaLabel": "ariaLabel"; "ariaDescribedBy": "aria-describedby"; }, { "focusEmitter": "focus"; "blurEmitter": "blur"; "valueChanged": "valueChanged"; "inputKeydown": "inputKeydown"; "inputKeypress": "inputKeypress"; "inputKeyup": "inputKeyup"; }, never, ["[label-count]", "*"]>;
}
