import { Directionality } from '@angular/cdk/bidi';
import { AfterViewInit, ChangeDetectorRef, DoCheck, ElementRef, EventEmitter, Injector, IterableDiffers, NgZone, OnChanges, OnDestroy, OnInit, QueryList, Renderer2, SimpleChanges, TemplateRef } from '@angular/core';
import { ControlValueAccessor, FormControl } from '@angular/forms';
import { EventManager } from '@angular/platform-browser';
import { Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { AdaptCustomAction, AdaptCustomActionsComponent, AdaptDeviceDetectionService, AdaptFocusMonitorDirective, AdaptFocusMonitorService, AdaptRadarAngularCustomEventName, AdaptTranslateService, KeyValueObject, LayerService, ResizeService, ScrollManageService } from '@bmc-ux/adapt-angular';
import { SelectObjectTypeModel, SelectOption, SelectSettings, SelectTexts } from './select.model';
import { AdaptSelectSearchFilter } from './select.pipe';
import { AdaptRadarGenericDirective, AdaptRadarService } from '@bmc-ux/adapt-radar';
import * as i0 from "@angular/core";
export declare class AdaptSelectComponent extends AdaptRadarGenericDirective implements OnInit, ControlValueAccessor, OnChanges, AfterViewInit, OnDestroy, DoCheck {
    filterSearch: AdaptSelectSearchFilter;
    protected _renderer: Renderer2;
    protected detection: AdaptDeviceDetectionService;
    protected element: ElementRef;
    protected _focusHandle: AdaptFocusMonitorService;
    protected _scrollService: ScrollManageService;
    protected _changeDetectorRef: ChangeDetectorRef;
    protected _ngZone: NgZone;
    private _layerService;
    protected _router: Router;
    private _differs;
    private _eventManager;
    private _dir;
    private _resizeService;
    private _injector;
    private ts;
    tooltipText: string;
    isError: boolean;
    model: number[] | SelectObjectTypeModel[];
    modelArray: any;
    title: string;
    popupId: string;
    numSelected: number;
    isVisible: boolean;
    searchFilterText: FormControl;
    allowIconsBadges: boolean;
    placement: string;
    isAnimationReady: boolean;
    animationState: string;
    textEllipsisOption: string;
    wordBreakOption: string;
    rtl: boolean;
    isMobilePlacement: boolean;
    valueChangesSubscription: Subscription;
    /**
     * Is dropdown clicked flag
     */
    ddClick: boolean;
    defaultSettings: SelectSettings;
    defaultTexts: SelectTexts;
    nullOption: SelectOption;
    displayedOptions: SelectOption[];
    settings: SelectSettings;
    showMoreButton: boolean;
    loadMoreCallback: any;
    texts: SelectTexts;
    single: boolean;
    label: string;
    displayMessage: string;
    ariaLabelledby: string;
    ariaDescribedBy: string | null;
    filterDebounceTime: number;
    /**
     * Unique id of the element.
     */
    id: string;
    /**
     * Unique id of the element.
     */
    testID: string;
    /**
     * Tooltip icon and additional text for it.
     */
    tooltipInputIcon: string;
    tooltipInputText: string;
    whiteSpaceOption: string;
    emitModelChangeWithSingleValue: boolean;
    /**
     * Popover icon and additional content for it.
     */
    popoverIcon: string;
    popoverPlacement: string;
    popoverTriggers: string;
    popoverContent: string | TemplateRef<any>;
    loadingState: boolean;
    loadingDataInProgress: boolean;
    readonly: boolean;
    /**
     * Resolver that checks if the option disabled
     */
    disabledOptionResolver: (option: SelectOption) => boolean;
    readonly selectionLimitReached: EventEmitter<any>;
    readonly dropdownClosed: EventEmitter<any>;
    readonly dropdownOpened: EventEmitter<any>;
    readonly modelArrayChanged: EventEmitter<any>;
    readonly filterValueChanged: EventEmitter<any>;
    menu: ElementRef;
    filterInput: ElementRef;
    labelElement: ElementRef;
    toggleDropdownBtn: ElementRef<HTMLButtonElement>;
    titleWidth: ElementRef;
    optionRef: ElementRef<HTMLElement>;
    dropdownItem: QueryList<ElementRef>;
    focusMonitoring: QueryList<AdaptFocusMonitorDirective>;
    customActionsComponent: AdaptCustomActionsComponent;
    loadMoreBtn: ElementRef<HTMLButtonElement>;
    private _menuAttached?;
    private _removeTapEventListener;
    private _modelDiffer;
    private _menuKeyDownSubscription;
    private _resizeSubject;
    private _pageNumber;
    private _focusMonitoringQueryList;
    private _trackingTimerId;
    private _destroyed$;
    private parentElementRef;
    /**
     * An object for manage wrapper's scroll.
     */
    private _scrollManager;
    private _options;
    set options(options: SelectOption[]);
    get isMobile(): boolean;
    set toggleStateValidation(value: boolean);
    private _disabled;
    get disabled(): boolean;
    set disabled(v: boolean);
    private _customClass;
    get customClass(): string;
    set customClass(v: string);
    private _required;
    get required(): boolean;
    set required(v: boolean);
    private get isAttachedToBody();
    get customActions(): AdaptCustomAction[];
    private _ngControl;
    private static _shouldAllowIconsBadges;
    /**
     * Document click handler
     */
    documentClickHandler: (e: MouseEvent) => void;
    constructor(filterSearch: AdaptSelectSearchFilter, _renderer: Renderer2, detection: AdaptDeviceDetectionService, element: ElementRef, _focusHandle: AdaptFocusMonitorService, _scrollService: ScrollManageService, _changeDetectorRef: ChangeDetectorRef, _ngZone: NgZone, _layerService: LayerService, _router: Router, _differs: IterableDiffers, _eventManager: EventManager, _dir: Directionality, _resizeService: ResizeService, _injector: Injector, ts: AdaptTranslateService, _adaptRadarService: AdaptRadarService, _entityName: AdaptRadarAngularCustomEventName);
    onModelChange: (_: any) => void;
    onModelTouched: () => void;
    setDefaultTexts(translation: KeyValueObject): void;
    writeValue(value: number | number[] | SelectObjectTypeModel | SelectObjectTypeModel[] | string): void;
    registerOnChange(fn: () => void): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    truncateText(opt: any): void;
    loadMoreItems(): void;
    ngOnInit(): void;
    get displayedOptionsCount(): number;
    ngAfterViewInit(): void;
    onAnimationDone(event: any): void;
    close(restoreToggleFocus?: boolean): void;
    open(): void;
    toggleDropdown(): void;
    isSelected(option: SelectOption): boolean;
    setSelected(e: MouseEvent | KeyboardEvent, option: SelectOption): void;
    /** For better performance */
    optionsTrackByFn(index: number, option: SelectOption): any;
    clearSearchFilter(e: MouseEvent): void;
    checkAll(): void;
    uncheckAll(): void;
    uncheckAllOnDelete(event: KeyboardEvent): void;
    isHiddenSelectFilteredButton(): boolean;
    isHiddenUncheckFilteredButton(): boolean;
    isSelectedOption(option: SelectOption): boolean;
    getSelectedItemId(item: number | SelectObjectTypeModel): number;
    notifyArrayChanged(): void;
    cancel(): void;
    getFilteredItems(): number[] | SelectObjectTypeModel[];
    getSelectableFilteredOptions(): SelectOption[];
    isDisabled(option: SelectOption): boolean;
    getSelectableOptions(): SelectOption[];
    allOptionsDisabled(): boolean;
    ngDoCheck(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    showHeader(): boolean;
    getHeaderText(): string;
    getActiveDescendant(): string;
    private _updateFilteredOptions;
    private _focusOnSelectOption;
    /**
     * Update focusMonitor list
     *
     * Need to invoke after each DOM manipulation
     * to be sure that all visible focusable items
     * are available via keyboard
     */
    private _updateFocusMonitoringOnStable;
    private _addToLayoutService;
    private _autoUnselect;
    private _updateTitleView;
    private _updateErrorState;
    private _updateNumSelected;
    private _addModelItem;
    private _removeModelItem;
    private _removeFirstModelItem;
    private _setModel;
    private _setModelAndUpdateStateOnModelChange;
    private _updateStateOnModelChange;
    /**
     * updates the button title with the Selected choice
     */
    private _updateTitle;
    private _getFilteredOptions;
    private _filterDynamicMaxTitle;
    private _numSelectedTitle;
    private _updateMenuWidth;
    private _setMenuMinWidth;
    private _attachToBody;
    private _setPlacement;
    private _detachFromBody;
    private _checkTooltipOption;
    private _applyWrapperScroll;
    private _onModelArrayModified;
    private _createModelItem;
    private _findModelBySelectedOption;
    private _enableTrackingAnchorPosition;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptSelectComponent, [null, null, null, null, null, null, null, null, null, { optional: true; }, null, null, null, null, null, null, null, { optional: true; }]>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AdaptSelectComponent, "adapt-select", never, { "settings": "settings"; "showMoreButton": "showMoreButton"; "loadMoreCallback": "loadMoreCallback"; "texts": "texts"; "single": "single"; "label": "label"; "displayMessage": "displayMessage"; "ariaLabelledby": "aria-labelledby"; "ariaDescribedBy": "aria-describedby"; "filterDebounceTime": "filterDebounceTime"; "id": "id"; "testID": "testID"; "tooltipInputIcon": "tooltipInputIcon"; "tooltipInputText": "tooltipInputText"; "whiteSpaceOption": "whiteSpaceOption"; "emitModelChangeWithSingleValue": "emitModelChangeWithSingleValue"; "popoverIcon": "popoverIcon"; "popoverPlacement": "popoverPlacement"; "popoverTriggers": "popoverTriggers"; "popoverContent": "popoverContent"; "loadingState": "loadingState"; "loadingDataInProgress": "loadingDataInProgress"; "readonly": "readonly"; "disabledOptionResolver": "disabledOptionResolver"; "parentElementRef": "parentElementRef"; "options": "options"; "toggleStateValidation": "toggleStateValidation"; "disabled": "disabled"; "customClass": "customClass"; "required": "required"; }, { "selectionLimitReached": "selectionLimitReached"; "dropdownClosed": "dropdownClosed"; "dropdownOpened": "dropdownOpened"; "modelArrayChanged": "modelArrayChanged"; "filterValueChanged": "filterValueChanged"; }, never, never>;
}
