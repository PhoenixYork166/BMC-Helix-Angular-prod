import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i6 from '@angular/forms';
import { FormsModule, NG_VALUE_ACCESSOR, FormControl, NgControl, ReactiveFormsModule } from '@angular/forms';
import * as i0 from '@angular/core';
import { EventEmitter, Component, Input, Output, ViewChild, HostBinding, NgModule, forwardRef, Optional, Inject, Pipe, QueryList, ViewEncapsulation, ChangeDetectionStrategy, ViewChildren, InjectionToken, Injectable, Directive, HostListener, Version } from '@angular/core';
import * as i1$1 from '@angular/animations';
import { trigger, transition, style, animate, useAnimation, keyframes, state, query, group, animateChild } from '@angular/animations';
import { isNil, isUndefined as isUndefined$1, union, differenceWith, isEqual, keyBy, pick, isFunction, without, values, toArray as toArray$1 } from 'lodash-es';
import { UP_ARROW, DOWN_ARROW, SPACE, BACKSPACE, DELETE, TAB, ENTER, ESCAPE, SHIFT, ALT, CONTROL, LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';
import * as i1 from '@bmc-ux/adapt-angular';
import { FormComponent, AdaptRadarAngularCustomEventName, isUndefined, ANIMATION_DURATION, CounterOperations, formatString, getEventKeyCode, createFormControlValueAccessor, createFormControlValidator, ANIMATION_TIMING_FUNCTION, ANIMATION_NAME, AdaptDeviceDetectionService, AdaptIconModule, AdaptTooltipModule, AdaptPopoverModule, AdaptDragonInputHandlerModule, AdaptRxLabelModule, SafeCdr, GetDragNDrop, GetAngle, GetDistance, AdaptDropdownModule, AdaptAnimationDirectivesModule, AdaptDropdownEditableSize, toBoolean, hasRequiredValidator, isDefined, hasKeyboardKeyCode, adaptWarn, positionElements, availableTargetPlacements, AdaptCustomActionsComponent, AdaptFocusMonitorDirective, AdaptFocusMonitorService, AdaptBusyModule, AdaptFocusMonitorDirectiveModule, AdaptCustomActionsModule, AdaptEmptyStateModule, toNumber, getElementStyles, debounce, AdaptCustomActionsAlignEnum, toString, scrollToActive, PopupService, Live, ARIA_LIVE_DELAY, DEFAULT_ARIA_LIVE_DELAY, AdaptHighlightModule, AdaptButtonModule, UploaderMode, UploaderSelectionMode, FileSize, retrieveFileSize, MessageStatus, INITIAL_CHUNK_NUMBER, toArray, ANIMATION_DND, ANIMATION_DROP, FILE_IS_UPLOADED_PERCENTAGE, AdaptUploaderItemComponent, FileManager, IconManager, ANIMATION_INIT_STATE, SendFileService, AdaptAlertModule, AdaptCollapseModule, AdaptTruncateFileNameModule, AdaptUploadItemModule, AdaptFileSizePipeModule, AdaptFileTypesPipeModule, isString, convertPlacement } from '@bmc-ux/adapt-angular';
import * as i2 from '@bmc-ux/adapt-radar';
import { AdaptRadarGenericDirective } from '@bmc-ux/adapt-radar';
import { ai_angle_left, ai_dots } from '@bmc-ux/dpl-iconfont';
import * as i2$1 from '@angular/cdk/bidi';
import { take, distinctUntilChanged, map, debounceTime, throttleTime, takeUntil, tap, delay, mergeMap, skipWhile, switchMap } from 'rxjs/operators';
import moment from 'moment-es6';
import { BehaviorSubject, noop as noop$5, of, Subject, ReplaySubject, asyncScheduler, fromEvent, EMPTY, merge } from 'rxjs';
import * as i5 from '@angular/cdk/drag-drop';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import * as i4 from '@angular/platform-browser';
import { HammerModule } from '@angular/platform-browser';
import * as i3$1 from '@angular/router';
import { NavigationStart } from '@angular/router';
import * as i3$2 from '@angular/cdk/scrolling';
import { ScrollingModule } from '@angular/cdk/scrolling';

const _c0$p = ["container"];
const _c1$j = ["input"];
const _c2$h = ["prefixEl"];
const _c3$d = ["suffixEl"];
const _c4$a = ["mobileActionsContainer"];
function AdaptCounterComponent_adapt_rx_control_label_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-rx-control-label", 14);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("for", ctx_r1.id)("label", ctx_r1.label)("requiredLabel", ctx_r1.requiredLabel)("showRequiredLabel", ctx_r1.required)("tooltip", ctx_r1.tooltipConfig);
} }
function AdaptCounterComponent_div_12_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 15, 16);
    i0.ɵɵlistener("mouseenter", function AdaptCounterComponent_div_12_Template_div_mouseenter_0_listener() { i0.ɵɵrestoreView(_r11); const _r8 = i0.ɵɵreference(1); const _r9 = i0.ɵɵreference(4); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.toggleTooltip(_r8, _r9); })("mouseout", function AdaptCounterComponent_div_12_Template_div_mouseout_0_listener() { i0.ɵɵrestoreView(_r11); const _r8 = i0.ɵɵreference(1); const _r9 = i0.ɵɵreference(4); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.toggleTooltip(_r8, _r9); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵelementStart(3, "span", 17, 18);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r2.prefix);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r2.prefix);
} }
function AdaptCounterComponent_div_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 19);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelement(2, "span", 20);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("@errorToggleAnimation", undefined);
} }
function AdaptCounterComponent_div_24_button_11_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 29);
    i0.ɵɵlistener("click", function AdaptCounterComponent_div_24_button_11_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r17); const ctx_r16 = i0.ɵɵnextContext(2); return ctx_r16.increaseMobile(); })("@highlightMobileIncrease.start", function AdaptCounterComponent_div_24_button_11_Template_button_animation_highlightMobileIncrease_start_0_listener($event) { i0.ɵɵrestoreView(_r17); const ctx_r18 = i0.ɵɵnextContext(2); return ctx_r18.onAnimationIncreaseStart($event); })("@highlightMobileIncrease.done", function AdaptCounterComponent_div_24_button_11_Template_button_animation_highlightMobileIncrease_done_0_listener($event) { i0.ɵɵrestoreView(_r17); const ctx_r19 = i0.ɵɵnextContext(2); return ctx_r19.onAnimationIncreaseDone($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("pointer-events", ctx_r14.increaseAnimationDone ? "all" : "none");
    i0.ɵɵproperty("disabled", !ctx_r14.increaseAllowed())("@highlightMobileIncrease", undefined);
    i0.ɵɵattribute("aria-label", ctx_r14.defaultErrors.increase)("data-testid", ctx_r14.testID + "_plus");
} }
function AdaptCounterComponent_div_24_button_13_Template(rf, ctx) { if (rf & 1) {
    const _r21 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 30);
    i0.ɵɵlistener("click", function AdaptCounterComponent_div_24_button_13_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r21); const ctx_r20 = i0.ɵɵnextContext(2); return ctx_r20.decreaseMobile(); })("@highlightMobileDecrease.start", function AdaptCounterComponent_div_24_button_13_Template_button_animation_highlightMobileDecrease_start_0_listener($event) { i0.ɵɵrestoreView(_r21); const ctx_r22 = i0.ɵɵnextContext(2); return ctx_r22.onAnimationDecreaseStart($event); })("@highlightMobileDecrease.done", function AdaptCounterComponent_div_24_button_13_Template_button_animation_highlightMobileDecrease_done_0_listener($event) { i0.ɵɵrestoreView(_r21); const ctx_r23 = i0.ɵɵnextContext(2); return ctx_r23.onAnimationDecreaseDone($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("pointer-events", ctx_r15.decreaseAnimationDone ? "all" : "none");
    i0.ɵɵproperty("disabled", !ctx_r15.decreaseAllowed())("@highlightMobileDecrease", undefined);
    i0.ɵɵattribute("aria-label", ctx_r15.defaultErrors.decrease)("data-testid", ctx_r15.testID + "_minus");
} }
function AdaptCounterComponent_div_24_Template(rf, ctx) { if (rf & 1) {
    const _r25 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵlistener("click", function AdaptCounterComponent_div_24_Template_div_click_0_listener() { i0.ɵɵrestoreView(_r25); const ctx_r24 = i0.ɵɵnextContext(); return ctx_r24.checkForMobileSpinners(); });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "button", 22);
    i0.ɵɵlistener("click", function AdaptCounterComponent_div_24_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r25); const ctx_r26 = i0.ɵɵnextContext(); return ctx_r26.increaseCounter(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "button", 23);
    i0.ɵɵlistener("click", function AdaptCounterComponent_div_24_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r25); const ctx_r27 = i0.ɵɵnextContext(); return ctx_r27.decreaseCounter(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n\n        ");
    i0.ɵɵelementStart(6, "div", 24, 25);
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementStart(9, "div", 26);
    i0.ɵɵtext(10, "\n            ");
    i0.ɵɵtemplate(11, AdaptCounterComponent_div_24_button_11_Template, 1, 6, "button", 27);
    i0.ɵɵtext(12, "\n            ");
    i0.ɵɵtemplate(13, AdaptCounterComponent_div_24_button_13_Template, 1, 6, "button", 28);
    i0.ɵɵtext(14, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("focused", ctx_r5.isMobile && ctx_r5.isSpinnerMobile);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("@highlightArrow", ctx_r5.animateArrowUp)("disabled", ctx_r5.context.disabled || !ctx_r5.increaseAllowed());
    i0.ɵɵattribute("aria-label", ctx_r5.defaultErrors.increase)("data-testid", ctx_r5.testID + "_plus");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("@highlightArrow", ctx_r5.animateArrowDown)("disabled", ctx_r5.context.disabled || !ctx_r5.decreaseAllowed());
    i0.ɵɵattribute("aria-label", ctx_r5.defaultErrors.decrease)("data-testid", ctx_r5.testID + "_minus");
    i0.ɵɵadvance(7);
    i0.ɵɵproperty("ngIf", ctx_r5.isSpinnerMobile);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.isSpinnerMobile);
} }
function AdaptCounterComponent_div_27_Template(rf, ctx) { if (rf & 1) {
    const _r31 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 31, 32);
    i0.ɵɵlistener("mouseenter", function AdaptCounterComponent_div_27_Template_div_mouseenter_0_listener() { i0.ɵɵrestoreView(_r31); const _r28 = i0.ɵɵreference(1); const _r29 = i0.ɵɵreference(4); const ctx_r30 = i0.ɵɵnextContext(); return ctx_r30.toggleTooltip(_r28, _r29); })("mouseout", function AdaptCounterComponent_div_27_Template_div_mouseout_0_listener() { i0.ɵɵrestoreView(_r31); const _r28 = i0.ɵɵreference(1); const _r29 = i0.ɵɵreference(4); const ctx_r32 = i0.ɵɵnextContext(); return ctx_r32.toggleTooltip(_r28, _r29); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵelementStart(3, "span", 17, 33);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r6.suffix);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r6.suffix);
} }
function AdaptCounterComponent_div_31_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 36);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "b");
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵelementStart(4, "span");
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const e_r34 = ctx.$implicit;
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("", e_r34.name, " ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(e_r34.text);
} }
function AdaptCounterComponent_div_31_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 34);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptCounterComponent_div_31_p_2_Template, 7, 2, "p", 35);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r7.context.errors);
} }
const _c5$8 = function (a0) { return { "adapt-counter__wrp--disabled": a0 }; };
// eslint-disable-next-line @typescript-eslint/no-var-requires
const bigNumber = require('bignumber.js');
class AdaptCounterComponent extends FormComponent {
    constructor(_renderer, _injector, _deviceDetection, ts, _adaptRadarService, _elem) {
        super(_injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptCounter);
        this._renderer = _renderer;
        this._injector = _injector;
        this._deviceDetection = _deviceDetection;
        // Need for using inherited properties in the template
        this.context = this;
        this.animateArrowUp = false;
        this.animateArrowDown = false;
        this.isCompact = false;
        this.increaseAnimationDone = false;
        this.decreaseAnimationDone = false;
        this.focused = false;
        this.isMobile = false;
        this.isSpinnerMobile = false;
        this.defaultErrors = {};
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        this.label = '';
        this.allowScientific = true;
        this.step = 1;
        this.width = '100%';
        this.preventInnerValidation = false;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        this.valueChanged = new EventEmitter();
        this._patterns = {
            scientific: /^-?(\d+|\d+\.\d+|\.\d+)([eE][-+]?\d+)?$/g,
            normal: /^-?(\d+|\d+\.\d+|\.\d+)?$/g
        };
        this._numberPatters = /^[+-]?(\d+|\.\d+|\d+\.\d+|\d+\.)(e[+-]?\d+)?$/;
        this._minWidthToMobile = 200;
        this._isValidNumber = true;
        this.propagateChange = () => {
            return;
        };
        this._onTouchedCallback = () => {
            return;
        };
        this.id = `c-${AdaptCounterComponent.id}`;
        AdaptCounterComponent.id++;
        this.setDefaultTexts(ts.getCurrentLanguage());
        this.currentLocale = ts.getCurrentLocale();
    }
    set max(value) {
        this._max = this._isSafeNumber(value) ? parseFloat(value) : bigNumber(value);
    }
    get max() {
        return !!this._max || this._max === 0 ? this._max : Number.MAX_SAFE_INTEGER;
    }
    set min(value) {
        this._min = this._isSafeNumber(value) ? parseFloat(value) : bigNumber(value);
    }
    get min() {
        return !!this._min || this._min === 0 ? this._min : Number.MIN_SAFE_INTEGER;
    }
    set allowIntegerOnly(value) {
        this._integerOnly = this.allowScientific ? false : value;
    }
    get allowIntegerOnly() {
        return this._integerOnly;
    }
    get hostClasses() {
        return [
            this.mainCls,
            'adapt-counter',
            this.isErrorExist ? 'is-error' : '',
            this.suppressIcons ? 'prevent-success-icon' : ''
        ].join(' ');
    }
    get isErrorExist() {
        return Boolean(this.errors.length);
    }
    get customClass() {
        let customCls = '';
        switch (this.size) {
            case 'small':
                customCls = 'form-control-sm';
                break;
            case 'large':
                customCls = 'form-control-lg';
                break;
        }
        return customCls;
    }
    get inputSize() {
        return (this._value && this._value.toString().length) || 1;
    }
    get value() {
        return this._value;
    }
    get _isTruncatedPrefix() {
        if (isUndefined(this.prefixEl)) {
            return false;
        }
        const { scrollWidth, offsetWidth } = this.prefixEl.nativeElement;
        return scrollWidth > offsetWidth;
    }
    get _isTruncatedSuffix() {
        if (isUndefined(this.suffixEl)) {
            return false;
        }
        const { scrollWidth, offsetWidth } = this.suffixEl.nativeElement;
        return scrollWidth > offsetWidth;
    }
    ngOnInit() {
        super.ngOnInit();
        this.mainCls = this.mainCls + ' form-group';
        this.isMobile = this._deviceDetection.isMobile();
        super.initControl();
        this.pattern = this.allowScientific ? this._patterns.scientific : this._patterns.normal;
        if (this.step % 1 !== 0) {
            // If step is not an integer then extract the length of the decimal part
            this.precision = this.step.toString().split(/[.]/)[1].length;
        }
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        if (this.context.tooltipIconCls && !this.context.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.context.tooltipIconCls,
                content: this.context.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.context.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.context.popoverIcon,
                content: this.popoverContent,
                placement: this.context.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.context.popoverTriggers
            };
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._renderer.setStyle(this.containerEl.nativeElement, 'width', this.width);
    }
    setDefaultTexts(translation) {
        this.defaultErrors.decrease = translation['adapt.counter.decrease'];
        this.defaultErrors.increase = translation['adapt.counter.increase'];
        this.defaultErrors.range = translation['adapt.counter.error.range'];
        this.defaultErrors.rangeName = translation['adapt.counter.error.rangeName'];
        this.defaultErrors.invalid = translation['adapt.counter.error.invalid'];
        this.defaultErrors.invalidName = translation['adapt.counter.error.invalidName'];
    }
    writeValue(value) {
        this._setValue(value, false);
        this.counterValue = this._value && this.pattern.test(value) ? value : this._value;
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this._disabled = isDisabled;
        this._closeMobileSpinners();
    }
    checkForMobileSpinners() {
        if (this.isMobile && !this.disabled) {
            this._openMobileSpinners();
        }
    }
    increaseCounter(animationNeeded) {
        if (this.isMobile) {
            return;
        }
        this._onTouchedCallback();
        this.increase();
        if (animationNeeded) {
            const timer = setTimeout(() => {
                this.animateArrowUp = false;
                clearTimeout(timer);
            }, parseFloat(ANIMATION_DURATION.fast) * 1000);
            this.animateArrowUp = true;
        }
    }
    decreaseCounter(animationNeeded) {
        if (this.isMobile) {
            return;
        }
        this._onTouchedCallback();
        this.decrease();
        if (animationNeeded) {
            const timer = setTimeout(() => {
                this.animateArrowDown = false;
                clearTimeout(timer);
            }, parseFloat(ANIMATION_DURATION.fast) * 1000);
            this.animateArrowDown = true;
        }
    }
    increaseMobile() {
        this._onTouchedCallback();
        this.increase();
    }
    decreaseMobile() {
        this._onTouchedCallback();
        this.decrease();
    }
    increase() {
        const newValue = this.calculateNewValue(CounterOperations.INCREASE);
        if (newValue === null) { // implicit check
            if (this.min < 0 && this.max > 0) {
                this._setValue(0, true);
            }
            else {
                this._setValue(this.min, true);
            }
        }
        else if (newValue < this.min) {
            this._setValue(this.min, true);
        }
        else {
            this._setValue(newValue > this.max ? this.max : newValue, true);
        }
        this.valueChanged.emit(this.value);
        this.counterValue = this.value;
    }
    decrease() {
        const newValue = this.calculateNewValue(CounterOperations.DECREASE);
        if (newValue === null) { // implicit check
            if (this.min < 0 && this.max > 0) {
                this._setValue(0, true);
            }
            else {
                this._setValue(this.max, true);
            }
        }
        else if (newValue > this.max) {
            this._setValue(this.max, true);
        }
        else {
            this._setValue(newValue < this.min ? this.min : newValue, true);
        }
        this.valueChanged.emit(this.value);
        this.counterValue = this.value;
    }
    calculateNewValue(operation) {
        const counterNumValue = parseFloat(this.counterValue);
        if (isNaN(counterNumValue)) {
            return null;
        }
        const valuePrecision = !this.precision && counterNumValue % 1 !== 0
            ? counterNumValue.toString().split(/[.]/)[1].length
            : this.precision;
        switch (operation) {
            case CounterOperations.INCREASE:
                return this._toFixed(counterNumValue + this.step, valuePrecision);
            case CounterOperations.DECREASE:
                return this._toFixed(counterNumValue - this.step, valuePrecision);
        }
    }
    increaseAllowed() {
        if (isNaN(this.value)) {
            return true;
        }
        return isNil(this.value) || this.value < this.max;
    }
    decreaseAllowed() {
        if (isNaN(this.value)) {
            return true;
        }
        return isNil(this.value) || this.value > this.min;
    }
    validate(c) {
        if (this.preventInnerValidation) {
            return;
        }
        if (!isNil(c.value)) {
            if (!this._isValidNumber) {
                return {
                    counterError: this._customErrorTexts.invalidNumberError || {
                        name: this.defaultErrors.invalidName,
                        text: this.defaultErrors.invalid,
                    }
                };
            }
            const hasRangeError = bigNumber.isBigNumber(c.value) ?
                (bigNumber(c.value).lt(this.min) || bigNumber(c.value).gt(this.max)) :
                (c.value < this.min || c.value > this.max) || isNaN(c.value);
            if (hasRangeError) {
                return {
                    counterError: this._customErrorTexts.rangeError || {
                        name: this.defaultErrors.rangeName,
                        text: formatString(this.defaultErrors.range, this.min.toLocaleString(this.currentLocale), this.max.toLocaleString(this.currentLocale))
                    }
                };
            }
        }
        return null;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    onInput(input) {
        this._setValue(input.value, true);
        this.counterValue = input.value;
        this.valueChanged.emit(!!this.value || this.value === 0 ? this.value : null);
    }
    onKeyPress(e) {
        if (this.disabled || this.readonly) {
            return;
        }
        const regExp = new RegExp(this.allowScientific
            ? /^[-+]?\.?[0-9]?[eE]?$/g
            : this.allowIntegerOnly ? /^[-+]?\d?$/g : /^[-+]?\.?[0-9]?$/g);
        const isValidChar = !!regExp.test(e.key);
        if (!isValidChar) {
            e.preventDefault();
            return;
        }
    }
    onFocus() {
        this.focused = true;
        this.focus.emit();
    }
    onBlur() {
        this.focused = false;
        this.blur.emit();
        this._onTouchedCallback();
        this.propagateChange();
    }
    onKeyDown(e) {
        if (this.disabled || this.readonly) {
            return;
        }
        const keyCode = getEventKeyCode(e);
        if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
            e.preventDefault();
            switch (keyCode) {
                case UP_ARROW: {
                    if (this.increaseAllowed()) {
                        this.increaseCounter(true);
                    }
                    break;
                }
                case DOWN_ARROW: {
                    if (this.decreaseAllowed()) {
                        this.decreaseCounter(true);
                    }
                    break;
                }
            }
        }
    }
    toggleTooltip(tooltip, el) {
        tooltip.delay = 0;
        if (!tooltip.isOpen() && el.offsetWidth >= el.scrollWidth) {
            return;
        }
        if (tooltip.isOpen()) {
            tooltip.close();
        }
        else {
            tooltip.open();
        }
    }
    onAnimationIncreaseStart(event) {
        if (event.phaseName === 'start') {
            this.increaseAnimationDone = false;
        }
    }
    onAnimationIncreaseDone(event) {
        if (event.phaseName === 'done') {
            this.increaseAnimationDone = true;
        }
    }
    onAnimationDecreaseStart(event) {
        if (event.phaseName === 'start') {
            this.decreaseAnimationDone = false;
        }
    }
    onAnimationDecreaseDone(event) {
        if (event.phaseName === 'done') {
            this.decreaseAnimationDone = true;
        }
    }
    _setValue(v, propagateChange) {
        if (v === null || v === undefined || v.toString().length === 0) {
            this._value = null;
        }
        else {
            this._isValidNumber = !!this._numberPatters.test(v.toString());
            this._value = this._isSafeNumber(v) ? parseFloat(v) : bigNumber(v);
        }
        if (propagateChange) {
            this.propagateChange();
        }
    }
    /**
     * Opens the mobile spinners
     */
    _openMobileSpinners() {
        if (!this.isSpinnerMobile) {
            this.isSpinnerMobile = true;
            // Set timeout to skip 'open' click
            setTimeout(() => {
                this._removeDocumentClickListener = this._renderer.listen('document', 'click', (event) => {
                    if (!this.mobileActionsContainer.nativeElement.contains(event.target)) {
                        this._closeMobileSpinners();
                    }
                });
            }, 0);
        }
    }
    /**
     * Closes the mobile spinners
     */
    _closeMobileSpinners() {
        if (this.isSpinnerMobile) {
            this.isSpinnerMobile = false;
            this._removeDocumentClickListener();
        }
    }
    _isSafeNumber(value) {
        // for NaN return true
        if (isNaN(value)) {
            return true;
        }
        // check if passed argument is decimal
        const isDecimal = value && value.toString().indexOf('.') > 0;
        const quotient = isDecimal ? value.toString().split(/[.]/)[0] : value.toString();
        if (Number.isSafeInteger(Number(quotient))) {
            if (!isDecimal) {
                return true;
            }
            return !(Number(quotient) === Number.MAX_SAFE_INTEGER || Number(quotient) === Number.MIN_SAFE_INTEGER);
        }
        return false;
    }
    _toFixed(value, precision = 0) {
        const power = Math.pow(10, precision);
        return Math.round(value * power) / power;
    }
}
AdaptCounterComponent.id = 0;
AdaptCounterComponent.ɵfac = function AdaptCounterComponent_Factory(t) { return new (t || AdaptCounterComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptCounterComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptCounterComponent, selectors: [["adapt-counter"]], viewQuery: function AdaptCounterComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$p, 7);
        i0.ɵɵviewQuery(_c1$j, 7);
        i0.ɵɵviewQuery(_c2$h, 5);
        i0.ɵɵviewQuery(_c3$d, 5);
        i0.ɵɵviewQuery(_c4$a, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.containerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.prefixEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.suffixEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.mobileActionsContainer = _t.first);
    } }, hostVars: 2, hostBindings: function AdaptCounterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { id: "id", testID: "testID", name: "name", prefix: "prefix", suffix: "suffix", label: "label", max: "max", min: "min", allowScientific: "allowScientific", step: "step", width: "width", formControl: "formControl", size: "size", preventInnerValidation: "preventInnerValidation", allowIntegerOnly: "allowIntegerOnly", ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"] }, outputs: { focus: "focus", blur: "blur", valueChanged: "valueChanged" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptCounterComponent),
            createFormControlValidator(AdaptCounterComponent)
        ]), i0.ɵɵInheritDefinitionFeature], decls: 34, vars: 23, consts: [[1, "adapt-counter__wrp", 3, "ngClass"], ["container", ""], [1, "adapt-counter__label--wrp"], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip", 4, "ngIf"], [1, "adapt-counter__content"], ["class", "adapt-counter-adding adapt-counter-prefix", "manual", "", "placement", "auto", 3, "adaptRadarDisableEventSending", "adaptTooltip", "mouseenter", "mouseout", 4, "ngIf"], [1, "adapt-counter-container"], [1, "adapt-counter-input-wrapper"], [1, "adapt-counter-input", "form-control", "rx-form-control", 3, "id", "ngClass", "value", "disabled", "readOnly", "input", "keypress", "keydown", "focus", "blur"], ["input", ""], ["class", "adapt-counter-icon", 4, "ngIf"], ["class", "adapt-counter-spinners", 3, "focused", "click", 4, "ngIf"], ["class", "adapt-counter-adding adapt-counter-suffix", "manual", "", "placement", "auto", 3, "adaptRadarDisableEventSending", "adaptTooltip", "mouseenter", "mouseout", 4, "ngIf"], ["class", "adapt-counter-errors-list has-danger", 4, "ngIf"], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], ["manual", "", "placement", "auto", 1, "adapt-counter-adding", "adapt-counter-prefix", 3, "adaptRadarDisableEventSending", "adaptTooltip", "mouseenter", "mouseout"], ["prefixTooltip", "tooltip"], [1, "adapt-counter-adding-text"], ["prefixEl", ""], [1, "adapt-counter-icon"], [1, "adapt-counter-icon-error"], [1, "adapt-counter-spinners", 3, "click"], ["type", "button", "role", "button", 1, "adapt-counter-spinner", "adapt-counter-spinner__increase", 3, "disabled", "click"], ["type", "button", "role", "button", 1, "adapt-counter-spinner", "adapt-counter-spinner__decrease", 3, "disabled", "click"], [1, "adapt-counter-spinners--mobile"], ["mobileActionsContainer", ""], [1, "btn-float-block"], ["class", "btn btn-primary btn-circle d-icon-triangle_up adapt-counter-spinner__increase", "type", "button", 3, "pointerEvents", "disabled", "click", 4, "ngIf"], ["class", "btn btn-primary btn-circle d-icon-triangle_down adapt-counter-spinner__decrease", "type", "button", 3, "pointerEvents", "disabled", "click", 4, "ngIf"], ["type", "button", 1, "btn", "btn-primary", "btn-circle", "d-icon-triangle_up", "adapt-counter-spinner__increase", 3, "disabled", "click"], ["type", "button", 1, "btn", "btn-primary", "btn-circle", "d-icon-triangle_down", "adapt-counter-spinner__decrease", 3, "disabled", "click"], ["manual", "", "placement", "auto", 1, "adapt-counter-adding", "adapt-counter-suffix", 3, "adaptRadarDisableEventSending", "adaptTooltip", "mouseenter", "mouseout"], ["suffixTooltip", "tooltip"], ["suffixEl", ""], [1, "adapt-counter-errors-list", "has-danger"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngFor", "ngForOf"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"]], template: function AdaptCounterComponent_Template(rf, ctx) { if (rf & 1) {
        const _r35 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵtext(3, "\n  ");
        i0.ɵɵelementStart(4, "div", 2);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵtemplate(6, AdaptCounterComponent_adapt_rx_control_label_6_Template, 1, 5, "adapt-rx-control-label", 3);
        i0.ɵɵtext(7, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n  ");
        i0.ɵɵtext(9, "\n\n  ");
        i0.ɵɵelementStart(10, "div", 4);
        i0.ɵɵtext(11, "\n    ");
        i0.ɵɵtemplate(12, AdaptCounterComponent_div_12_Template, 7, 3, "div", 5);
        i0.ɵɵtext(13, "\n\n    ");
        i0.ɵɵelementStart(14, "div", 6);
        i0.ɵɵtext(15, "\n      ");
        i0.ɵɵelementStart(16, "div", 7);
        i0.ɵɵtext(17, "\n        ");
        i0.ɵɵelementStart(18, "input", 8, 9);
        i0.ɵɵlistener("input", function AdaptCounterComponent_Template_input_input_18_listener() { i0.ɵɵrestoreView(_r35); const _r3 = i0.ɵɵreference(19); return ctx.onInput(_r3); })("keypress", function AdaptCounterComponent_Template_input_keypress_18_listener($event) { return ctx.onKeyPress($event); })("keydown", function AdaptCounterComponent_Template_input_keydown_18_listener($event) { return ctx.onKeyDown($event); })("focus", function AdaptCounterComponent_Template_input_focus_18_listener() { return ctx.onFocus(); })("blur", function AdaptCounterComponent_Template_input_blur_18_listener() { return ctx.onBlur(); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n        ");
        i0.ɵɵtemplate(21, AdaptCounterComponent_div_21_Template, 4, 1, "div", 10);
        i0.ɵɵtext(22, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(23, "\n      ");
        i0.ɵɵtemplate(24, AdaptCounterComponent_div_24_Template, 17, 12, "div", 11);
        i0.ɵɵtext(25, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(26, "\n\n    ");
        i0.ɵɵtemplate(27, AdaptCounterComponent_div_27_Template, 7, 3, "div", 12);
        i0.ɵɵtext(28, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(29, "\n  ");
        i0.ɵɵtext(30, "\n  ");
        i0.ɵɵtemplate(31, AdaptCounterComponent_div_31_Template, 4, 2, "div", 13);
        i0.ɵɵtext(32, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(33, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(21, _c5$8, ctx.context.disabled));
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", !ctx.context.hideLabel);
        i0.ɵɵadvance(4);
        i0.ɵɵclassProp("adapt-counter__content--compact", ctx.isCompact);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.prefix);
        i0.ɵɵadvance(4);
        i0.ɵɵclassProp("focused", ctx.focused);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("id", ctx.id)("ngClass", ctx.customClass)("value", ctx.counterValue)("disabled", ctx.context.disabled)("readOnly", ctx.readonly);
        i0.ɵɵattribute("data-testid", ctx.testID)("placeholder", ctx.context.placeholder)("aria-describedby", ctx.ariaDescribedBy)("aria-readonly", ctx.readonly)("size", ctx.inputSize);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.isErrorExist);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.readonly);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.suffix);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.isErrorExist);
    } }, directives: [i3.NgClass, i3.NgIf, i1.AdaptDragonInputHandlerDirective, i1.AdaptRxControlLabelComponent, i1.AdaptTooltipDirective, i3.NgForOf], encapsulation: 2, data: { animation: [
            trigger('highlightMobileIncrease', [
                transition(':enter', [
                    style({ bottom: 0, opacity: 0 }),
                    animate(ANIMATION_DURATION.fast + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ bottom: 'calc(100% + 10px)', opacity: 1 }))
                ]),
                transition(':leave', [
                    style({ bottom: 'calc(100% + 10px)', opacity: 1 }),
                    animate('.12s', style({ bottom: 0, opacity: 0 }))
                ])
            ]),
            trigger('highlightMobileDecrease', [
                transition(':enter', [
                    style({ top: 0, opacity: 0 }),
                    animate(ANIMATION_DURATION.fast + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ top: 'calc(100% + 10px)', opacity: 1 }))
                ]),
                transition(':leave', [
                    style({ top: 'calc(100% + 10px)', opacity: 1 }),
                    animate('.12s', style({ top: 0, opacity: 0 }))
                ])
            ]),
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ]),
            trigger('errorToggleAnimation', [
                transition(':enter', [
                    style({
                        opacity: 0
                    }),
                    animate(250)
                ]),
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    // animate(150)
                ])
            ]),
            trigger('highlightArrow', [
                transition('0 => 1', animate(ANIMATION_DURATION.medium, keyframes([
                    style({ color: '*', offset: 0 }),
                    style({ color: '#00867E', offset: 1 })
                ])))
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptCounterComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-counter',
                templateUrl: './counter.component.html',
                providers: [
                    createFormControlValueAccessor(AdaptCounterComponent),
                    createFormControlValidator(AdaptCounterComponent)
                ],
                animations: [
                    trigger('highlightMobileIncrease', [
                        transition(':enter', [
                            style({ bottom: 0, opacity: 0 }),
                            animate(ANIMATION_DURATION.fast + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ bottom: 'calc(100% + 10px)', opacity: 1 }))
                        ]),
                        transition(':leave', [
                            style({ bottom: 'calc(100% + 10px)', opacity: 1 }),
                            animate('.12s', style({ bottom: 0, opacity: 0 }))
                        ])
                    ]),
                    trigger('highlightMobileDecrease', [
                        transition(':enter', [
                            style({ top: 0, opacity: 0 }),
                            animate(ANIMATION_DURATION.fast + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ top: 'calc(100% + 10px)', opacity: 1 }))
                        ]),
                        transition(':leave', [
                            style({ top: 'calc(100% + 10px)', opacity: 1 }),
                            animate('.12s', style({ top: 0, opacity: 0 }))
                        ])
                    ]),
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ]),
                    trigger('errorToggleAnimation', [
                        transition(':enter', [
                            style({
                                opacity: 0
                            }),
                            animate(250)
                        ]),
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            // animate(150)
                        ])
                    ]),
                    trigger('highlightArrow', [
                        transition('0 => 1', animate(ANIMATION_DURATION.medium, keyframes([
                            style({ color: '*', offset: 0 }),
                            style({ color: '#00867E', offset: 1 })
                        ])))
                    ])
                ]
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.Injector }, { type: i1.AdaptDeviceDetectionService }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { id: [{
            type: Input
        }], testID: [{
            type: Input
        }], name: [{
            type: Input
        }], prefix: [{
            type: Input
        }], suffix: [{
            type: Input
        }], label: [{
            type: Input
        }], max: [{
            type: Input
        }], min: [{
            type: Input
        }], allowScientific: [{
            type: Input
        }], step: [{
            type: Input
        }], width: [{
            type: Input
        }], formControl: [{
            type: Input
        }], size: [{
            type: Input
        }], preventInnerValidation: [{
            type: Input
        }], allowIntegerOnly: [{
            type: Input
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], valueChanged: [{
            type: Output
        }], containerEl: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }], inputEl: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], prefixEl: [{
            type: ViewChild,
            args: ['prefixEl', { static: false }]
        }], suffixEl: [{
            type: ViewChild,
            args: ['suffixEl', { static: false }]
        }], mobileActionsContainer: [{
            type: ViewChild,
            args: ['mobileActionsContainer', { static: false }]
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class AdaptCounterModule {
}
AdaptCounterModule.ɵfac = function AdaptCounterModule_Factory(t) { return new (t || AdaptCounterModule)(); };
AdaptCounterModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptCounterModule });
AdaptCounterModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [AdaptDeviceDetectionService], imports: [[
            CommonModule,
            FormsModule,
            AdaptIconModule,
            AdaptTooltipModule,
            AdaptPopoverModule.forRoot(),
            AdaptDragonInputHandlerModule,
            AdaptRxLabelModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptCounterModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AdaptIconModule,
                    AdaptTooltipModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptDragonInputHandlerModule,
                    AdaptRxLabelModule
                ],
                declarations: [AdaptCounterComponent],
                exports: [AdaptCounterComponent],
                providers: [AdaptDeviceDetectionService]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptCounterModule, { declarations: [AdaptCounterComponent], imports: [CommonModule,
        FormsModule,
        AdaptIconModule,
        AdaptTooltipModule, i1.AdaptPopoverModule, AdaptDragonInputHandlerModule,
        AdaptRxLabelModule], exports: [AdaptCounterComponent] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
class Calendar2 {
}
class Calendar2Day {
}
var Clock2FaceUnit;
(function (Clock2FaceUnit) {
    Clock2FaceUnit[Clock2FaceUnit["Hours"] = 0] = "Hours";
    Clock2FaceUnit[Clock2FaceUnit["Minutes"] = 1] = "Minutes";
    Clock2FaceUnit[Clock2FaceUnit["Seconds"] = 2] = "Seconds";
})(Clock2FaceUnit || (Clock2FaceUnit = {}));

function IsLocaleHasMeridiem(locale) {
    // 24-hours format time string has 8 symbols (ex.: 11:11:11)
    // If more than 8, locale time has meridiem
    return moment([2020, 10, 10, 23, 11, 11]).locale(locale).format('LTS').length > 8;
}
function IsDateRangeValid(dStart, dEnd) {
    if (!(dStart && dEnd)) {
        throw new Error('Wrong input params!');
    }
    return dStart.isValid() && dEnd.isValid() && dStart.isSameOrBefore(dEnd);
}
function IsTimeRangeValid(tStart, tEnd) {
    if (!(tStart && tEnd)) {
        throw new Error('Wrong input params!');
    }
    const _tStart = moment().startOf('day').hour(tStart.hour()).minute(tStart.minute());
    const _tEnd = moment().startOf('day').hour(tEnd.hour()).minute(tEnd.minute());
    return _tStart.isSameOrBefore(_tEnd);
}
function IsTimeInRange(t, tStart, tEnd) {
    if (!(t && tStart && tEnd)) {
        throw new Error('Wrong input params!');
    }
    if (!IsTimeRangeValid(tStart, tEnd)) {
        return false;
    }
    const _t = moment().startOf('day').hour(t.hour()).minute(t.minute());
    const _tStart = moment().startOf('day').hour(tStart.hour()).minute(tStart.minute());
    const _tEnd = moment().startOf('day').hour(tEnd.hour()).minute(tEnd.minute());
    return _t.isBetween(_tStart, _tEnd, null, '[]');
}
function IsSameDays(d1, d2) {
    if (!(d1 && d2)) {
        throw new Error('Wrong input params!');
    }
    return d1.isSame(d2, 'year') && d1.isSame(d2, 'month') && d1.isSame(d2, 'day');
}

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$o = ["inputControlRef"];
const _c1$i = ["dropdownRef"];
const _c2$g = ["calendarContainer"];
const _c3$c = ["nextBtn"];
const _c4$9 = ["cancelBtn"];
const _c5$7 = ["clearBtn"];
function AdaptDatetime2Component_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "input", 9, 10);
    i0.ɵɵlistener("input", function AdaptDatetime2Component_div_8_Template_input_input_2_listener() { i0.ɵɵrestoreView(_r11); const _r9 = i0.ɵɵreference(3); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.inputControlWrite(_r9.value); })("click", function AdaptDatetime2Component_div_8_Template_input_click_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.inputControlClick(); })("keydown.enter", function AdaptDatetime2Component_div_8_Template_input_keydown_enter_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.inputControlClick(); })("blur", function AdaptDatetime2Component_div_8_Template_input_blur_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.inputControlBlur(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    const _r0 = i0.ɵɵreference(2);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMap("a3t-datetime--input-control form-control " + (ctx_r1.inputControlClass || ""));
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r1.readonly && ctx_r1.disabledStyleForReadonlyState)("readonly", ctx_r1.readonly)("i-date", !ctx_r1.timePicker)("i-date-time", ctx_r1.timePicker && !ctx_r1.timeOnly)("i-time", ctx_r1.timeOnly)("a3t-datetime--input-control_active", _r0.isOpen())("a3t-datetime--input-control_invalid", ctx_r1._self.errors.length > 0 && ctx_r1._self.control.touched);
    i0.ɵɵproperty("value", ctx_r1.inputControlValue)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly);
    i0.ɵɵattribute("id", ctx_r1.id)("placeholder", ctx_r1.placeholder)("aria-describedby", ctx_r1.ariaDescribedBy);
} }
function AdaptDatetime2Component_ng_template_11_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2Component_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelementStart(1, "div", 11);
    i0.ɵɵlistener("mousedown", function AdaptDatetime2Component_ng_template_11_Template_div_mousedown_1_listener() { i0.ɵɵrestoreView(_r17); const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.dropdownMouseDown(); });
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptDatetime2Component_ng_template_11_ng_container_3_Template, 1, 0, "ng-container", 6);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n      ");
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    const _r4 = i0.ɵɵreference(17);
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(ctx_r2.dropdownClass || "");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r2.inline)("ngIfThen", _r4);
} }
function AdaptDatetime2Component_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2Component_ng_template_16_div_6_span_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r24.headings.applyBtn);
} }
function AdaptDatetime2Component_ng_template_16_div_6_span_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r25 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r25.headings.nextBtn);
} }
function AdaptDatetime2Component_ng_template_16_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r27 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "div");
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "button", 17, 18);
    i0.ɵɵlistener("click", function AdaptDatetime2Component_ng_template_16_div_6_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r27); const ctx_r26 = i0.ɵɵnextContext(2); return ctx_r26.pickerCloseAndCancel(); });
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementStart(9, "div", 19);
    i0.ɵɵtext(10, "\n            ");
    i0.ɵɵelementStart(11, "button", 20, 21);
    i0.ɵɵlistener("click", function AdaptDatetime2Component_ng_template_16_div_6_Template_button_click_11_listener() { i0.ɵɵrestoreView(_r27); const ctx_r28 = i0.ɵɵnextContext(2); return ctx_r28.pickerClearAll(); });
    i0.ɵɵtext(13);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n            ");
    i0.ɵɵelementStart(15, "button", 22, 23);
    i0.ɵɵlistener("click", function AdaptDatetime2Component_ng_template_16_div_6_Template_button_click_15_listener($event) { i0.ɵɵrestoreView(_r27); const ctx_r29 = i0.ɵɵnextContext(2); $event.stopPropagation(); return ctx_r29.goToNextStep(); });
    i0.ɵɵtext(17, "\n              ");
    i0.ɵɵtemplate(18, AdaptDatetime2Component_ng_template_16_div_6_span_18_Template, 2, 1, "span", 4);
    i0.ɵɵtext(19, "\n              ");
    i0.ɵɵtemplate(20, AdaptDatetime2Component_ng_template_16_div_6_span_20_Template, 2, 1, "span", 4);
    i0.ɵɵtext(21, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("two-rows-wrap", ctx_r19.twoRowsWrap || ctx_r19.threeRowsWrap);
    i0.ɵɵadvance(4);
    i0.ɵɵpropertyInterpolate("id", ctx_r19.id + "-cancel-btn");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r19.headings.cancelBtn, "");
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("three-rows-wrap", ctx_r19.threeRowsWrap);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("id", ctx_r19.id + "-clear-btn");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r19.headings.clearBtn, "");
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("id", ctx_r19.id + "-wizard-step-btn");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r19.isLastWizardStep);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r19.isLastWizardStep);
} }
function AdaptDatetime2Component_ng_template_16_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2Component_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    const _r31 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 12, 13);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "adapt-datetime2-picker", 14);
    i0.ɵɵlistener("timeModeChange", function AdaptDatetime2Component_ng_template_16_Template_adapt_datetime2_picker_timeModeChange_4_listener($event) { i0.ɵɵrestoreView(_r31); const ctx_r30 = i0.ɵɵnextContext(); return ctx_r30.timeModeChange($event); })("clockFaceChange", function AdaptDatetime2Component_ng_template_16_Template_adapt_datetime2_picker_clockFaceChange_4_listener($event) { i0.ɵɵrestoreView(_r31); const ctx_r32 = i0.ɵɵnextContext(); return ctx_r32.clockFaceChange($event); })("valueChange", function AdaptDatetime2Component_ng_template_16_Template_adapt_datetime2_picker_valueChange_4_listener($event) { i0.ɵɵrestoreView(_r31); const ctx_r33 = i0.ɵɵnextContext(); return ctx_r33.selectDateTime($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵtemplate(6, AdaptDatetime2Component_ng_template_16_div_6_Template, 24, 11, "div", 15);
    i0.ɵɵtext(7, "\n\n        ");
    i0.ɵɵtemplate(8, AdaptDatetime2Component_ng_template_16_ng_container_8_Template, 1, 0, "ng-container", 6);
    i0.ɵɵtext(9, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    const _r7 = i0.ɵɵreference(22);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("a3t-datetime-inline-light", ctx_r5.inline && ctx_r5.inlineLight)("a3t-datetime-inline-small", ctx_r5.inline && ctx_r5.inlineSize === "small");
    i0.ɵɵproperty("ngClass", ctx_r5.isMobile ? "a3t-datetime--calendar-width" : "a3t-datetime--calendar-min-width");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("initialValue", ctx_r5.initialValue)("activeValue", ctx_r5.value)("dateFilter", ctx_r5.dateFilter)("timePicker", ctx_r5.timePicker)("timeOnly", ctx_r5.timeOnly)("monthAndYearOnly", ctx_r5.monthAndYearOnly)("monthFirst", ctx_r5.monthFirst)("timeSeconds", ctx_r5.seconds)("timeFormat", ctx_r5.timeInputFormat)("timeMode", ctx_r5.timeModeState$.value)("activeFace", ctx_r5.clockFaceState$.value)("disabled", ctx_r5.disabled)("readonly", ctx_r5.readonly)("emptyDateHeading", ctx_r5.headings.emptyDate)("emptyTimeHeading", ctx_r5.headings.emptyTime)("clockHeadings", ctx_r5.headings);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r5.inline);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.inline)("ngIfThen", _r7);
} }
function AdaptDatetime2Component_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2Component_ng_template_21_div_1_div_2_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 30);
} }
function AdaptDatetime2Component_ng_template_21_div_1_div_2_strong_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "strong");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r36 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", error_r36.name, " ");
} }
function AdaptDatetime2Component_ng_template_21_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 27);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptDatetime2Component_ng_template_21_div_1_div_2_div_2_Template, 1, 0, "div", 28);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "div", 29);
    i0.ɵɵtemplate(5, AdaptDatetime2Component_ng_template_21_div_1_div_2_strong_5_Template, 2, 1, "strong", 4);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r36 = ctx.$implicit;
    const ctx_r35 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r35.inline);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", error_r36.name);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(error_r36.text);
} }
function AdaptDatetime2Component_ng_template_21_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 25);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptDatetime2Component_ng_template_21_div_1_div_2_Template, 8, 3, "div", 26);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r34 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r34._self.errors);
} }
function AdaptDatetime2Component_ng_template_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptDatetime2Component_ng_template_21_div_1_Template, 4, 2, "div", 24);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r8._self.errors.length > 0 && ctx_r8._self.control.touched);
} }
const _c6$5 = function () { return { isPicker: true }; };
const MIN_DROPDOWN_WIDTH$1 = 270;
class AdaptDatetime2Component extends FormComponent {
    constructor(_injector, _deviceDetectorService, _renderer, _changeDetectorRef, _ngZone, ts, _adaptRadarService, _elem) {
        super(_injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptDatetime2);
        this._injector = _injector;
        this._deviceDetectorService = _deviceDetectorService;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        // Self link
        this._self = this;
        // UI fields
        this.inputControlValue = '';
        this.dropdownAutoClose = 'outside';
        this.timeModeState$ = new BehaviorSubject(false);
        this.clockFaceState$ = new BehaviorSubject(Clock2FaceUnit.Hours);
        this.isLastWizardStep = false;
        this.twoRowsWrap = false;
        this.threeRowsWrap = false;
        this.defaultTexts = {};
        this.defaultErrors = {
            invalidValueName: '',
            invalidValue: '',
            disabledDateName: '',
            disabledDate: '',
            disabledTimeName: '',
            disabledTime: '',
        };
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * Datetime input label
         */
        this.label = '';
        /**
         * Datetime input placeholder
         */
        this.placeholder = '';
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Inputs
        /**
         * DateTime inline mode
         */
        this.inline = false;
        /**
         * DateTime inline light color scheme mode
         */
        this.inlineLight = true;
        /**
         * DateTime inline small size mode
         */
        this.inlineSize = 'default';
        /**
         * Class for datetime dropdown
         */
        this.dropdownClass = 'dropdown-menu p-0';
        /**
         * Date input format
         */
        this.dateInputFormat = 'LL';
        /**
         * Time input format without seconds
         */
        this.timeInputFormat = 'LT';
        /**
         * Time input format with seconds
         */
        this.timeInputLongFormat = 'LTS';
        /**
         * Toggle time picker
         */
        this.timePicker = false;
        /**
         * Use only the time picker flag
         */
        this.timeOnly = false;
        /**
         * Use only the month and year picker flag
         */
        this.monthAndYearOnly = false;
        this.monthFirst = false;
        /**
         * Use seconds in time picker
         */
        this.seconds = false;
        /**
         * Use disabled style for the control if [readonly]=true
         */
        this.disabledStyleForReadonlyState = false;
        /**
         * Picker placement
         */
        this.placement = ['bottom-left', 'top-left', 'bottom-right', 'top-right', 'bottom-left'];
        /**
         * Append to body trigger
         */
        this.appendToBody = false;
        /**
         * Prevent choosing dateTime value step-by-step
         */
        this.preventWizard = false;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        // Outputs
        /**
         * Event on picker open
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.open = new EventEmitter();
        /**
         * Event on picker close
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.close = new EventEmitter();
        /**
         * Event on ngModel change
         */
        this.valueChange = new EventEmitter();
        /**
         * FormControl focus implementation
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        /**
         * FormControl blur implementation
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        // Privates fields for ControlValueAccessor
        this._onTouchedCallback = noop$5;
        this._onChangeCallback = noop$5;
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Template refs
        // ngModel value
        this._model = null;
        // previousNgModel value
        this._previousModel = null;
        this.dropdownAutoClose = this._deviceDetectorService.isMobile() ? false : 'outside';
        this.isMobile = this._deviceDetectorService.isMobile();
        this.isIE = this._deviceDetectorService.isIE();
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get value() {
        return this._model;
    }
    set value(v) {
        if (this.disabled) {
            return;
        }
        this._model = v;
        this._onChangeCallback(this._model);
        this.valueChange.emit(this._model);
        this._inputControlFormatting();
    }
    ngOnInit() {
        super.ngOnInit();
        this.initControl();
        if (!this.id) {
            this.id = `dt-${AdaptDatetime2Component.DT_ID++}`;
        }
        if (!this.name) {
            this.name = `${this.id}-form-control`;
        }
        if (this.timeOnly) {
            this.timePicker = true;
        }
        if (this.inline) {
            this._openPicker();
        }
        if (!this.mainCls) {
            this.mainCls = this.inline ? '' : 'form-group';
        }
        // Detect close event on dd
        this._dtDropdownOpenChangeSub = this.dropdownRef.onClose.subscribe(() => {
            if (!this.inline) {
                this._closePicker();
            }
        });
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        this.headings = Object.assign(Object.assign({}, this.defaultTexts), this.headings);
        if (this.tooltipIconCls && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIconCls,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    ngOnDestroy() {
        this._dtDropdownOpenChangeSub.unsubscribe();
    }
    setDefaultTexts(translation) {
        this.defaultTexts.emptyDate = translation['adapt.datetime.emptyDate'];
        this.defaultTexts.emptyTime = translation['adapt.datetime.emptyTime'];
        this.defaultTexts.emptyMonth = translation['adapt.datetime.emptyMonth'];
        this.defaultTexts.cancelBtn = translation['adapt.common.cancel'];
        this.defaultTexts.clearBtn = translation['adapt.common.clearAll'];
        this.defaultTexts.nextBtn = translation['adapt.common.next'];
        this.defaultTexts.applyBtn = translation['adapt.common.ok'];
        this.defaultTexts.hhBtn = translation['adapt.datetime.hh'];
        this.defaultTexts.mmBtn = translation['adapt.datetime.mm'];
        this.defaultTexts.ssBtn = translation['adapt.datetime.ss'];
        this.defaultTexts.amBtn = translation['adapt.datetime.am'];
        this.defaultTexts.pmBtn = translation['adapt.datetime.pm'];
        this.requiredLabel = translation['adapt.common.required'];
        this.defaultErrors.invalidValueName = translation['adapt.datetime.error.invalidValueName'];
        this.defaultErrors.invalidValue = translation['adapt.datetime.error.invalidValue'];
        this.defaultErrors.disabledDateName = translation['adapt.datetime.error.disabledDateName'];
        this.defaultErrors.disabledDate = translation['adapt.datetime.error.disabledDate'];
        this.defaultErrors.disabledTimeName = translation['adapt.datetime.error.disabledTimeName'];
        this.defaultErrors.disabledTime = translation['adapt.datetime.error.disabledTime'];
    }
    /**
     * Datetime wizard
     */
    goToNextStep() {
        if (this.inline) {
            return;
        }
        if (this.preventWizard) {
            this.pickerCloseAndApply();
            return;
        }
        if (this.timePicker) {
            if (!this.timeModeState$.value) {
                this.timeModeState$.next(true);
            }
            else {
                if (this.clockFaceState$.value === (this.seconds ? Clock2FaceUnit.Seconds : Clock2FaceUnit.Minutes)) {
                    if (!!this.value && this.value.isValid()) {
                        this.pickerCloseAndApply();
                    }
                    else {
                        if (this.timeOnly) {
                            this.clockFaceState$.next(Clock2FaceUnit.Hours);
                        }
                        else {
                            this.timeModeState$.next(false);
                        }
                    }
                }
                else {
                    this.clockFaceState$.next(this.clockFaceState$.value + 1);
                }
            }
        }
        else {
            this.pickerCloseAndApply();
        }
        this._checkIfLastWizardStep();
    }
    /**
     * Select date/time on picker
     */
    selectDateTime(v) {
        if (this.disabled || this.readonly) {
            return;
        }
        this.value = v.clone();
        if (this.inline) {
            this._onTouchedCallback();
        }
    }
    /**
     * Close picker and set previous model value
     */
    pickerCloseAndCancel() {
        this.value = this._previousModel;
        this._closePicker();
    }
    /**
     * Close picker and use current value
     */
    pickerCloseAndApply() {
        this._closePicker();
    }
    /**
     * Clear model value
     */
    pickerClearAll() {
        this.value = null;
        this._checkIfLastWizardStep();
        if (this.isMobile) {
            this._closePicker();
        }
    }
    /**
     * Input control (input) handler
     */
    inputControlWrite(v) {
        this.inputControlValue = v;
        this.value = this._tryParseToMoment(v);
    }
    /**
     * Input control (click) handler
     */
    inputControlClick() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.focus.emit();
        if (!this.dropdownRef.isOpen()) {
            this._openPicker();
        }
    }
    /**
     * Input control (blur) handler
     */
    inputControlBlur() {
        this.blur.emit();
        this._inputControlFormatting();
        if (!this.dropdownRef.isOpen()) {
            this._onTouchedCallback();
        }
    }
    /**
     * Dropdown mousedown handler
     */
    dropdownMouseDown() {
        this._blurInput();
    }
    /**
     * Open picker
     */
    /**
     * Time mode change handler
     */
    timeModeChange(v) {
        if (this.timeModeState$.value !== v) {
            this.timeModeState$.next(v);
        }
        if (v && (this.clockFaceState$.value !== Clock2FaceUnit.Hours)) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this.clockFaceState$.next(Clock2FaceUnit.Hours);
            });
        }
        this._checkIfLastWizardStep();
    }
    /**
     * Close picker
     */
    /**
     * Clock face change handler
     */
    clockFaceChange(v) {
        if (this.clockFaceState$.value !== v) {
            this.clockFaceState$.next(v);
        }
        this._checkIfLastWizardStep();
    }
    writeValue(v) {
        this._model = this._getNormalizedModelValue(v);
        this._inputControlFormatting();
    }
    /**
     * Parse and format input control value
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * Get formatted [timeMin] prop value
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * Get formatted [timeMax] prop value
     */
    setDisabledState(isDisabled) {
        this._disabled = isDisabled;
    }
    /**
     * Get format for input control value
     */
    validate(c) {
        const dateFormatError = {
            dateError: this._customErrorTexts.dateFormatError || {
                name: this.defaultErrors.invalidValueName,
                text: formatString(this.defaultErrors.invalidValue, moment().format(this._getInputControlFormat()))
            }
        };
        const unselectableDateError = {
            dateError: this._customErrorTexts.unselectableDateError || {
                name: this.defaultErrors.disabledDateName,
                text: this.defaultErrors.disabledDate
            }
        };
        const unselectableTimeError = {
            dateError: this._customErrorTexts.unselectableTimeError || {
                name: this.defaultErrors.disabledTimeName,
                text: formatString(this.defaultErrors.disabledTime, this._getFormattedStartTime(), this._getFormattedEndTime())
            }
        };
        const controlValue = moment.isMoment(c.value) ? c.value : this._getNormalizedModelValue(c.value);
        const errFormat = controlValue && !moment(controlValue).isValid();
        const disableDate = controlValue && moment(controlValue).isValid() && this.dateFilter && !this.dateFilter(controlValue, c);
        const disableTime = controlValue && moment(controlValue).isValid() && this.timeMin && this.timeMax &&
            !IsTimeInRange(controlValue, this.timeMin, this.timeMax);
        return errFormat ? dateFormatError :
            disableDate ? unselectableDateError :
                disableTime ? unselectableTimeError : null;
    }
    _truncateBtn(btn) {
        const xPadings = 10;
        if (btn.offsetWidth + xPadings > window.innerWidth - xPadings) {
            this._renderer.addClass(btn, 'text-truncate');
            return window.innerWidth - xPadings;
        }
        else {
            return btn.offsetWidth + xPadings;
        }
    }
    _wrapButtons() {
        const xPadings = 10; // left and right padding
        const cancelBtnWidth = this.cancelBtn.nativeElement.offsetWidth; // cancel button width
        const nextBtnWidth = this.nextBtn.nativeElement.offsetWidth; // next button width
        const clearBtnWidth = this.clearBtn.nativeElement.offsetWidth; // clear button width
        const btnGroupWidth = nextBtnWidth + clearBtnWidth + 5; // clear + next buttons width + margins
        const buttonsWidth = cancelBtnWidth + btnGroupWidth + xPadings; // all buttons width
        let containerWidth = buttonsWidth < MIN_DROPDOWN_WIDTH$1 ? MIN_DROPDOWN_WIDTH$1 : buttonsWidth;
        if (window.innerWidth - xPadings < buttonsWidth) {
            // wrap button in two rows
            if (btnGroupWidth + xPadings < window.innerWidth - xPadings) {
                const firstRowWidth = btnGroupWidth + xPadings < MIN_DROPDOWN_WIDTH$1 ? MIN_DROPDOWN_WIDTH$1 : btnGroupWidth + xPadings;
                const secondRowWidth = this._truncateBtn(this.cancelBtn.nativeElement);
                containerWidth = Math.max(firstRowWidth, secondRowWidth);
                this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
                this.twoRowsWrap = true;
            }
            else {
                // wrap button in three rows
                const firstRowWidth = this._truncateBtn(this.nextBtn.nativeElement);
                const secondRowWidth = this._truncateBtn(this.clearBtn.nativeElement);
                const thirdRowWidth = this._truncateBtn(this.cancelBtn.nativeElement);
                const maxButtonWidth = Math.max(firstRowWidth, secondRowWidth, thirdRowWidth);
                containerWidth = maxButtonWidth < MIN_DROPDOWN_WIDTH$1 ? MIN_DROPDOWN_WIDTH$1 : maxButtonWidth;
                this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
                this.threeRowsWrap = true;
            }
        }
        else {
            this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
        }
    }
    _openPicker() {
        this._previousModel = this.value ? this.value.clone() : null;
        if (this.inline) {
            return;
        }
        this._checkIfLastWizardStep();
        if (!this.inline && (this.isMobile || this.isIE)) {
            // in some cases nativeElements is undefined, need to wait zone stable
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this._wrapButtons();
            });
        }
        this.timeModeState$.next(this.timeOnly);
        this.clockFaceState$.next(Clock2FaceUnit.Hours);
        this.dropdownRef.open();
        this.open.emit(this.id);
        if (this.isMobile) {
            this._blurInput();
        }
    }
    _closePicker() {
        this.twoRowsWrap = false;
        this.threeRowsWrap = false;
        if (this.inline) {
            return;
        }
        this.dropdownRef.close(); // DOUBLE CLOSE BECAUSE OF SUBSCRIPTION
        this.close.emit(this.id);
        this._onTouchedCallback();
        this._blurInput();
    }
    /**
     * Get time format
     */
    _blurInput() {
        if (this.inputControlRef) {
            this.inputControlRef.nativeElement.blur();
        }
    }
    _inputControlFormatting() {
        if (this.inputControlRef && (this.inputControlRef.nativeElement === document.activeElement)) {
            return;
        }
        if (this.value) {
            if (this.value.isValid()) {
                this.inputControlValue = this.value.format(this._getInputControlFormat());
            }
        }
        else {
            this.inputControlValue = '';
        }
        if (!this._changeDetectorRef.destroyed) {
            this._changeDetectorRef.detectChanges();
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // ControlValueAccessor
    _getFormattedStartTime() {
        return (this.timeMin || moment().startOf('day')).format(this._getTimeFormat());
    }
    _getFormattedEndTime() {
        return (this.timeMax || moment().endOf('day')).format(this._getTimeFormat());
    }
    _getInputControlFormat() {
        let format = this.dateInputFormat;
        if (this.timePicker) {
            format += ` ${this._getTimeFormat()}`;
            if (this.timeOnly) {
                format = this._getTimeFormat();
            }
        }
        if (this.monthAndYearOnly) {
            format = 'MMMM, YYYY';
        }
        return format;
    }
    _tryParseToMoment(valueToParse) {
        let parseResult = null;
        if (valueToParse) {
            if (this.timeOnly) {
                // https://stackoverflow.com/questions/34541196/moment-js-gives-invalid-date-in-firefox
                parseResult = moment(`${moment().format(this.dateInputFormat)} ${valueToParse}`, this.dateInputFormat + ' ' + this._getTimeFormat());
            }
            else {
                parseResult = moment(valueToParse, this._getInputControlFormat());
            }
        }
        return parseResult;
    }
    _getTimeFormat() {
        return this.seconds ? this.timeInputLongFormat : this.timeInputFormat;
    }
    _getNormalizedModelValue(value) {
        let momentValue = null;
        if (value) {
            if (moment.isMoment(value) || moment.isDate(value)) {
                momentValue = moment(value);
            }
            else if (typeof (value) === 'string') {
                if (this.writeValueParseFormat) {
                    momentValue = moment(value, this.writeValueParseFormat);
                }
                else {
                    const formattedDateTime = moment(value, [moment.ISO_8601, this._getInputControlFormat()]);
                    momentValue = formattedDateTime.isValid() ? formattedDateTime : moment(value);
                }
            }
            else {
                throw new Error('Wrong DateTime2 model type!');
            }
        }
        return momentValue;
    }
    /**
     * Wizard's last step checking
     */
    _checkIfLastWizardStep() {
        const wizard = !this.preventWizard;
        const lastTimeStep = this.timePicker && this.timeModeState$.value &&
            (this.clockFaceState$.value === (this.seconds ? Clock2FaceUnit.Seconds : Clock2FaceUnit.Minutes));
        const timePicker = this.timePicker;
        const lastStep = timePicker ? lastTimeStep : true;
        const modelFull = !timePicker || (!!this.value && this.value.isValid());
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this.isLastWizardStep = !wizard || lastStep && modelFull;
        });
    }
}
// Static fields
AdaptDatetime2Component.DT_ID = 1;
AdaptDatetime2Component.ɵfac = function AdaptDatetime2Component_Factory(t) { return new (t || AdaptDatetime2Component)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptDatetime2Component.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetime2Component, selectors: [["adapt-datetime2"]], viewQuery: function AdaptDatetime2Component_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$o, 5);
        i0.ɵɵviewQuery(_c1$i, 7);
        i0.ɵɵviewQuery(_c2$g, 5);
        i0.ɵɵviewQuery(_c3$c, 5);
        i0.ɵɵviewQuery(_c4$9, 5);
        i0.ɵɵviewQuery(_c5$7, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputControlRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cancelBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearBtn = _t.first);
    } }, hostVars: 3, hostBindings: function AdaptDatetime2Component_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("name", ctx.name);
        i0.ɵɵstyleProp("display", "block");
    } }, inputs: { formControl: "formControl", id: "id", name: "name", label: "label", placeholder: "placeholder", inline: "inline", inlineLight: "inlineLight", inlineSize: "inlineSize", initialValue: "initialValue", inputControlClass: "inputControlClass", dropdownClass: "dropdownClass", dateInputFormat: "dateInputFormat", timeInputFormat: "timeInputFormat", timeInputLongFormat: "timeInputLongFormat", timePicker: "timePicker", timeOnly: "timeOnly", monthAndYearOnly: "monthAndYearOnly", monthFirst: "monthFirst", seconds: "seconds", timeMin: "timeMin", timeMax: "timeMax", dateFilter: "dateFilter", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", placement: "placement", appendToBody: "appendToBody", headings: "headings", preventWizard: "preventWizard", writeValueParseFormat: "writeValueParseFormat", ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"] }, outputs: { open: "open", close: "close", valueChange: "valueChange", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptDatetime2Component),
            createFormControlValidator(AdaptDatetime2Component),
        ]), i0.ɵɵInheritDefinitionFeature], decls: 24, vars: 23, consts: [["adaptDropdown", "", 3, "adaptRadarDisableEventSending", "animationPlacement", "placement", "appendToBody", "autoClose", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "mobileView"], ["dropdownRef", "adaptDropdown"], ["adaptDropdownAnchor", ""], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [4, "ngIf"], ["adaptDropdownMenuTemplate", ""], [4, "ngIf", "ngIfThen"], ["calendar", ""], ["errorTemplate", ""], ["autocomplete", "off", 3, "value", "disabled", "readonly", "input", "click", "keydown.enter", "blur"], ["inputControlRef", ""], [3, "mousedown"], [3, "ngClass"], ["calendarContainer", ""], [3, "initialValue", "activeValue", "dateFilter", "timePicker", "timeOnly", "monthAndYearOnly", "monthFirst", "timeSeconds", "timeFormat", "timeMode", "activeFace", "disabled", "readonly", "emptyDateHeading", "emptyTimeHeading", "clockHeadings", "timeModeChange", "clockFaceChange", "valueChange"], ["class", "a3t-datetime--footer", 3, "two-rows-wrap", 4, "ngIf"], [1, "a3t-datetime--footer"], ["type", "button", 1, "btn", "btn-sm", "btn-link", 3, "id", "click"], ["cancelBtn", ""], [1, "d-flex", "justify-content-center"], ["type", "button", 1, "btn", "btn-sm", "btn-secondary", "m-end-1", 3, "id", "click"], ["clearBtn", ""], ["type", "button", 1, "btn", "btn-sm", "btn-primary", 3, "id", "click"], ["nextBtn", ""], ["class", "has-danger", 4, "ngIf"], [1, "has-danger"], ["class", "form-control-feedback d-flex align-items-start m-0 pt-1 pb-0", 4, "ngFor", "ngForOf"], [1, "form-control-feedback", "d-flex", "align-items-start", "m-0", "pt-1", "pb-0"], ["class", "d-icon-exclamation_triangle flex-grow-0 flex-shrink-0 m-end-2", 4, "ngIf"], [1, "flex-grow-1", "flex-shrink-1"], [1, "d-icon-exclamation_triangle", "flex-grow-0", "flex-shrink-0", "m-end-2"]], template: function AdaptDatetime2Component_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0, 1);
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelementStart(4, "div", 2);
        i0.ɵɵtext(5, "\n        ");
        i0.ɵɵelement(6, "adapt-rx-control-label", 3);
        i0.ɵɵtext(7, "\n\n        ");
        i0.ɵɵtemplate(8, AdaptDatetime2Component_div_8_Template, 5, 22, "div", 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵtemplate(11, AdaptDatetime2Component_ng_template_11_Template, 6, 4, "ng-template", 5);
        i0.ɵɵtext(12, "\n\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n\n    ");
        i0.ɵɵtemplate(14, AdaptDatetime2Component_ng_container_14_Template, 1, 0, "ng-container", 6);
        i0.ɵɵtext(15, "\n\n    ");
        i0.ɵɵtemplate(16, AdaptDatetime2Component_ng_template_16_Template, 11, 24, "ng-template", null, 7, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(18, "\n\n    ");
        i0.ɵɵtemplate(19, AdaptDatetime2Component_ng_container_19_Template, 1, 0, "ng-container", 6);
        i0.ɵɵtext(20, "\n\n    ");
        i0.ɵɵtemplate(21, AdaptDatetime2Component_ng_template_21_Template, 3, 1, "ng-template", null, 8, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(23, "\n  ");
    } if (rf & 2) {
        const _r4 = i0.ɵɵreference(17);
        const _r7 = i0.ɵɵreference(22);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("animationPlacement", "center")("placement", ctx.placement)("appendToBody", ctx.appendToBody)("autoClose", ctx.dropdownAutoClose)("holdFocusInMenu", true)("holdFocusOnOpen", false)("autoFocusFirst", false)("restoreFocusAfterClose", false)("mobileView", i0.ɵɵpureFunction0(22, _c6$5));
        i0.ɵɵadvance(3);
        i0.ɵɵclassProp("has-danger", ctx._self.errors.length > 0 && ctx._self.control.touched);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx._self.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.inline);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", ctx.inline)("ngIfThen", _r4);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", !ctx.inline)("ngIfThen", _r7);
    } }, encapsulation: 2, data: { animation: [
            trigger('heightAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '0',
                            to: '*'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '*',
                            to: '0'
                        }
                    })
                ])
            ]),
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetime2Component, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime2',
                template: `
    <div adaptDropdown
         [adaptRadarDisableEventSending]="true"
         #dropdownRef="adaptDropdown"
         [animationPlacement]="'center'"
         [placement]="placement"
         [appendToBody]="appendToBody"
         [autoClose]="dropdownAutoClose"
         [holdFocusInMenu]="true"
         [holdFocusOnOpen]="false"
         [autoFocusFirst]="false"
         [restoreFocusAfterClose]="false"
         [mobileView]="{isPicker: true}">
      <div adaptDropdownAnchor [class.has-danger]="_self.errors.length > 0 && _self.control.touched">
        <adapt-rx-control-label [for]="id"
                                [label]="label"
                                [requiredLabel]="requiredLabel"
                                [showRequiredLabel]="_self.required"
                                [tooltip]="tooltipConfig"></adapt-rx-control-label>

        <div *ngIf="!inline">
          <input #inputControlRef
                 autocomplete="off"
                 [attr.id]="id"
                 [class]="'a3t-datetime--input-control form-control ' + (inputControlClass || '')"
                 [class.form-control-disabled-look]="readonly && this.disabledStyleForReadonlyState"
                 [value]="inputControlValue"
                 (input)="inputControlWrite(inputControlRef.value)"
                 (click)="inputControlClick()"
                 (keydown.enter)="inputControlClick()"
                 (blur)="inputControlBlur()"
                 [disabled]="disabled"
                 [readonly]="readonly"
                 [attr.placeholder]="placeholder"
                 [attr.aria-describedby]="ariaDescribedBy"
                 [class.readonly]="readonly"
                 [class.i-date]="!timePicker"
                 [class.i-date-time]="timePicker && !timeOnly"
                 [class.i-time]="timeOnly"
                 [class.a3t-datetime--input-control_active]="dropdownRef.isOpen()"
                 [class.a3t-datetime--input-control_invalid]="_self.errors.length > 0 && _self.control.touched"/>
        </div>
      </div>
      <ng-template adaptDropdownMenuTemplate>
        <div [class]="dropdownClass || ''" (mousedown)="dropdownMouseDown()">
          <ng-container *ngIf="!inline; then calendar"></ng-container>
        </div>
      </ng-template>

    </div>

    <ng-container *ngIf="inline; then calendar"></ng-container>

    <ng-template #calendar>
      <div #calendarContainer [ngClass]="isMobile ? 'a3t-datetime--calendar-width' : 'a3t-datetime--calendar-min-width'"
           [class.a3t-datetime-inline-light]="inline && inlineLight"
           [class.a3t-datetime-inline-small]="inline && inlineSize === 'small'">
        <adapt-datetime2-picker [initialValue]="initialValue"
                                [activeValue]="value"
                                [dateFilter]="dateFilter"
                                [timePicker]="timePicker"
                                [timeOnly]="timeOnly"
                                [monthAndYearOnly]="monthAndYearOnly"
                                [monthFirst]="monthFirst"
                                [timeSeconds]="seconds"
                                [timeFormat]="timeInputFormat"
                                [timeMode]="timeModeState$.value"
                                [activeFace]="clockFaceState$.value"
                                [disabled]="disabled"
                                [readonly]="readonly"
                                [emptyDateHeading]="headings.emptyDate"
                                [emptyTimeHeading]="headings.emptyTime"
                                [clockHeadings]="headings"
                                (timeModeChange)="timeModeChange($event)"
                                (clockFaceChange)="clockFaceChange($event)"
                                (valueChange)="selectDateTime($event)"></adapt-datetime2-picker>
        <div class="a3t-datetime--footer" [class.two-rows-wrap]="twoRowsWrap || threeRowsWrap" *ngIf="!inline">
          <div>
            <button #cancelBtn id="{{id + '-cancel-btn'}}" type="button" class="btn btn-sm btn-link"
                    (click)="pickerCloseAndCancel()">
              {{headings.cancelBtn}}</button>
          </div>
          <div class="d-flex justify-content-center" [class.three-rows-wrap]="threeRowsWrap">
            <button #clearBtn id="{{id + '-clear-btn'}}" type="button" class="btn btn-sm btn-secondary m-end-1"
                    (click)="pickerClearAll()">
              {{headings.clearBtn}}</button>
            <button #nextBtn id="{{id + '-wizard-step-btn'}}" type="button" class="btn btn-sm btn-primary"
                    (click)="$event.stopPropagation(); goToNextStep()">
              <span *ngIf="isLastWizardStep">{{headings.applyBtn}}</span>
              <span *ngIf="!isLastWizardStep">{{headings.nextBtn}}</span>
            </button>
          </div>
        </div>

        <ng-container *ngIf="inline; then errorTemplate"></ng-container>
      </div>
    </ng-template>

    <ng-container *ngIf="!inline; then errorTemplate"></ng-container>

    <ng-template #errorTemplate>
      <div class="has-danger" *ngIf="_self.errors.length > 0 && _self.control.touched" [@validationFeedbackAnimation]>
        <div class="form-control-feedback d-flex align-items-start m-0 pt-1 pb-0" *ngFor="let error of _self.errors">
          <div class="d-icon-exclamation_triangle flex-grow-0 flex-shrink-0 m-end-2" *ngIf="inline"></div>
          <div class="flex-grow-1 flex-shrink-1"><strong *ngIf="error.name">{{error.name}} </strong>{{error.text}}</div>
        </div>
      </div>
    </ng-template>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.name]': 'name',
                    '[style.display]': '"block"'
                },
                animations: [
                    trigger('heightAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '0',
                                    to: '*'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '*',
                                    to: '0'
                                }
                            })
                        ])
                    ]),
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ],
                providers: [
                    createFormControlValueAccessor(AdaptDatetime2Component),
                    createFormControlValidator(AdaptDatetime2Component),
                ]
            }]
    }], function () { return [{ type: i0.Injector }, { type: i1.AdaptDeviceDetectionService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { formControl: [{
            type: Input
        }], id: [{
            type: Input
        }], name: [{
            type: Input
        }], label: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], inline: [{
            type: Input
        }], inlineLight: [{
            type: Input
        }], inlineSize: [{
            type: Input
        }], initialValue: [{
            type: Input
        }], inputControlClass: [{
            type: Input
        }], dropdownClass: [{
            type: Input
        }], dateInputFormat: [{
            type: Input
        }], timeInputFormat: [{
            type: Input
        }], timeInputLongFormat: [{
            type: Input
        }], timePicker: [{
            type: Input
        }], timeOnly: [{
            type: Input
        }], monthAndYearOnly: [{
            type: Input
        }], monthFirst: [{
            type: Input
        }], seconds: [{
            type: Input
        }], timeMin: [{
            type: Input
        }], timeMax: [{
            type: Input
        }], dateFilter: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], placement: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], headings: [{
            type: Input
        }], preventWizard: [{
            type: Input
        }], writeValueParseFormat: [{
            type: Input
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], inputControlRef: [{
            type: ViewChild,
            args: ['inputControlRef']
        }], dropdownRef: [{
            type: ViewChild,
            args: ['dropdownRef', { static: true }]
        }], calendarContainer: [{
            type: ViewChild,
            args: ['calendarContainer']
        }], nextBtn: [{
            type: ViewChild,
            args: ['nextBtn']
        }], cancelBtn: [{
            type: ViewChild,
            args: ['cancelBtn']
        }], clearBtn: [{
            type: ViewChild,
            args: ['clearBtn']
        }] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$n = ["inputControlRef"];
const _c1$h = ["dropdownRef"];
const _c2$f = ["calendarContainer"];
const _c3$b = ["nextBtn"];
const _c4$8 = ["cancelBtn"];
const _c5$6 = ["clearBtn"];
function AdaptDatetimeRange2Component_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "input", 9, 10);
    i0.ɵɵlistener("input", function AdaptDatetimeRange2Component_div_8_Template_input_input_2_listener() { i0.ɵɵrestoreView(_r11); const _r9 = i0.ɵɵreference(3); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.inputControlWrite(_r9.value); })("focus", function AdaptDatetimeRange2Component_div_8_Template_input_focus_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.inputControlFocus(); })("blur", function AdaptDatetimeRange2Component_div_8_Template_input_blur_2_listener() { i0.ɵɵrestoreView(_r11); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.inputControlBlur(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    const _r0 = i0.ɵɵreference(2);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMap("a3t-datetime--input-control form-control " + (ctx_r1.inputControlClass || ""));
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r1.readonly && ctx_r1.disabledStyleForReadonlyState)("i-date", !ctx_r1.timePicker)("i-date-time", ctx_r1.timePicker && !ctx_r1.timeOnly)("i-time", ctx_r1.timeOnly)("readonly", ctx_r1.readonly)("a3t-datetime--input-control_active", _r0.isOpen())("a3t-datetime--input-control_invalid", ctx_r1._self.errors.length > 0 && ctx_r1._self.control.touched);
    i0.ɵɵproperty("value", ctx_r1.inputControlValue)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly);
    i0.ɵɵattribute("id", ctx_r1.id)("placeholder", ctx_r1.placeholder)("data-testid", ctx_r1.testID);
} }
function AdaptDatetimeRange2Component_ng_template_11_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetimeRange2Component_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelementStart(1, "div", 11);
    i0.ɵɵlistener("mousedown", function AdaptDatetimeRange2Component_ng_template_11_Template_div_mousedown_1_listener() { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.dropdownMouseDown(); });
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptDatetimeRange2Component_ng_template_11_ng_container_3_Template, 1, 0, "ng-container", 6);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n      ");
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    const _r4 = i0.ɵɵreference(17);
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(ctx_r2.dropdownClass || "");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r2.inline)("ngIfThen", _r4);
} }
function AdaptDatetimeRange2Component_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetimeRange2Component_ng_template_16_div_21_span_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r23 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r23.headings.applyBtn);
} }
function AdaptDatetimeRange2Component_ng_template_16_div_21_span_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r24.headings.nextBtn);
} }
function AdaptDatetimeRange2Component_ng_template_16_div_21_Template(rf, ctx) { if (rf & 1) {
    const _r26 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 18);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "div");
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "button", 19, 20);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_div_21_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r26); const ctx_r25 = i0.ɵɵnextContext(2); return ctx_r25.pickerCloseAndCancel(); });
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementStart(9, "div", 21);
    i0.ɵɵtext(10, "\n            ");
    i0.ɵɵelementStart(11, "button", 22, 23);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_div_21_Template_button_click_11_listener() { i0.ɵɵrestoreView(_r26); const ctx_r27 = i0.ɵɵnextContext(2); return ctx_r27.pickerClearAll(); });
    i0.ɵɵtext(13);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n            ");
    i0.ɵɵelementStart(15, "button", 24, 25);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_div_21_Template_button_click_15_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r28 = i0.ɵɵnextContext(2); $event.stopPropagation(); return ctx_r28.goToNextStep(); });
    i0.ɵɵtext(17, "\n              ");
    i0.ɵɵtemplate(18, AdaptDatetimeRange2Component_ng_template_16_div_21_span_18_Template, 2, 1, "span", 4);
    i0.ɵɵtext(19, "\n              ");
    i0.ɵɵtemplate(20, AdaptDatetimeRange2Component_ng_template_16_div_21_span_20_Template, 2, 1, "span", 4);
    i0.ɵɵtext(21, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r18 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("two-rows-wrap", ctx_r18.twoRowsWrap || ctx_r18.threeRowsWrap);
    i0.ɵɵadvance(4);
    i0.ɵɵattribute("data-testid", ctx_r18.testID + "_cancel");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r18.headings.cancelBtn, "");
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("three-rows-wrap", ctx_r18.threeRowsWrap);
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("data-testid", ctx_r18.testID + "_clear");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r18.headings.clearBtn, "");
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("data-testid", ctx_r18.testID + "_apply");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r18.isLastWizardStep);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r18.isLastWizardStep);
} }
function AdaptDatetimeRange2Component_ng_template_16_ng_container_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetimeRange2Component_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    const _r30 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 12, 13);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "div", 14);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementStart(6, "button", 15);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_Template_button_click_6_listener() { i0.ɵɵrestoreView(_r30); const ctx_r29 = i0.ɵɵnextContext(); return ctx_r29.switchToStartDT(); });
    i0.ɵɵtext(7);
    i0.ɵɵelementStart(8, "div");
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n          ");
    i0.ɵɵelementStart(12, "button", 15);
    i0.ɵɵlistener("click", function AdaptDatetimeRange2Component_ng_template_16_Template_button_click_12_listener() { i0.ɵɵrestoreView(_r30); const ctx_r31 = i0.ɵɵnextContext(); return ctx_r31.switchToEndDT(); });
    i0.ɵɵtext(13);
    i0.ɵɵelementStart(14, "div");
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n\n        ");
    i0.ɵɵelementStart(19, "adapt-datetime2-picker", 16);
    i0.ɵɵlistener("timeModeChange", function AdaptDatetimeRange2Component_ng_template_16_Template_adapt_datetime2_picker_timeModeChange_19_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r32 = i0.ɵɵnextContext(); return ctx_r32.timeModeChange($event); })("clockFaceChange", function AdaptDatetimeRange2Component_ng_template_16_Template_adapt_datetime2_picker_clockFaceChange_19_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r33 = i0.ɵɵnextContext(); return ctx_r33.clockFaceChange($event); })("valueChange", function AdaptDatetimeRange2Component_ng_template_16_Template_adapt_datetime2_picker_valueChange_19_listener($event) { i0.ɵɵrestoreView(_r30); const ctx_r34 = i0.ɵɵnextContext(); return ctx_r34.selectDateTime($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n\n        ");
    i0.ɵɵtemplate(21, AdaptDatetimeRange2Component_ng_template_16_div_21_Template, 24, 11, "div", 17);
    i0.ɵɵtext(22, "\n\n        ");
    i0.ɵɵtemplate(23, AdaptDatetimeRange2Component_ng_template_16_ng_container_23_Template, 1, 0, "ng-container", 6);
    i0.ɵɵtext(24, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n    ");
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    const _r7 = i0.ɵɵreference(22);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("a3t-datetime-inline-light", ctx_r5.inline && ctx_r5.inlineLight)("a3t-datetime-inline-small", ctx_r5.inline && ctx_r5.inlineSize === "small");
    i0.ɵɵproperty("ngClass", ctx_r5.isMobile ? "a3t-datetime--calendar-width" : "a3t-datetime--calendar-min-width");
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("end-active", ctx_r5.isRtl ? ctx_r5.startRangeActive : !ctx_r5.startRangeActive);
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("data-testid", ctx_r5.testID + "_start");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r5.headings.startLabel, "\n            ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r5.startValueSummary);
    i0.ɵɵadvance(3);
    i0.ɵɵattribute("data-testid", ctx_r5.testID + "_end");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r5.headings.endLabel, "\n            ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r5.endValueSummary);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("initialValue", ctx_r5.activeDateTime.initialValue)("activeValue", ctx_r5.activeDateTime.activeValue)("dateFilter", ctx_r5.activeDateTime.dateFilter)("dateRange", ctx_r5.activeDateTime.dateRange)("timeMode", ctx_r5.timeModeState$.value)("activeFace", ctx_r5.clockFaceState$.value)("timePicker", ctx_r5.timePicker)("timeOnly", ctx_r5.timeOnly)("timeSeconds", ctx_r5.seconds)("emptyTimeHeading", ctx_r5.headings.emptyTime)("clockHeadings", ctx_r5.headings)("disabled", ctx_r5.disabled)("readonly", ctx_r5.readonly)("hideDatePickerSummary", true)("preventExpandedDateControls", true)("testID", ctx_r5.testID);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r5.inline);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.inline)("ngIfThen", _r7);
} }
function AdaptDatetimeRange2Component_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 32);
} }
function AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_strong_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "strong");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r37 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", error_r37.name, " ");
} }
function AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 29);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_div_2_Template, 1, 0, "div", 30);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "div", 31);
    i0.ɵɵtemplate(5, AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_strong_5_Template, 2, 1, "strong", 4);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r37 = ctx.$implicit;
    const ctx_r36 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r36.inline);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", error_r37.name);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(error_r37.text);
} }
function AdaptDatetimeRange2Component_ng_template_21_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 27);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptDatetimeRange2Component_ng_template_21_div_1_div_2_Template, 8, 3, "div", 28);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r35 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r35._self.errors);
} }
function AdaptDatetimeRange2Component_ng_template_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptDatetimeRange2Component_ng_template_21_div_1_Template, 4, 2, "div", 26);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r8._self.errors.length > 0 && ctx_r8._self.control.touched);
} }
const _c6$4 = function () { return { isPicker: true }; };
const MIN_DROPDOWN_WIDTH = 270;
class AdaptDatetimeRange2Component extends FormComponent {
    constructor(_injector, _dir, _deviceDetectorService, _renderer, _changeDetectorRef, _ngZone, ts, _adaptRadarService, _elem) {
        super(_injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptDatetimeRange2);
        this._injector = _injector;
        this._dir = _dir;
        this._deviceDetectorService = _deviceDetectorService;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        // Self link
        this._self = this;
        // UI fields
        this.inputControlValue = '';
        this.dropdownAutoClose = 'outside';
        this.timeModeState$ = new BehaviorSubject(false);
        this.clockFaceState$ = new BehaviorSubject(Clock2FaceUnit.Hours);
        this.isLastWizardStep = false;
        this.twoRowsWrap = false;
        this.threeRowsWrap = false;
        this.isRtl = false;
        this.defaultTexts = {
            startLabel: '',
            endLabel: ''
        };
        this.defaultErrors = {
            invalidStartName: '',
            invalidStart: '',
            invalidEndName: '',
            invalidEnd: '',
            rangeName: '',
            range: '',
            rangeOrderName: '',
            rangeOrder: '',
            disabledDateStartName: '',
            disabledDateStart: '',
            disabledDateEndName: '',
            disabledDateEnd: '',
            disabledTimeStartName: '',
            disabledTimeStart: '',
            disabledTimeEndName: '',
            disabledTimeEnd: '',
        };
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * Datetime input label
         */
        this.label = '';
        /**
         * Datetime input placeholder
         */
        this.placeholder = '';
        /**
         * DateTime inline mode
         */
        this.inline = false;
        /**
         * DateTime inline light color scheme mode
         */
        this.inlineLight = true;
        /**
         * DateTime inline small size mode
         */
        this.inlineSize = 'default';
        /**
         * Class for datetime dropdown
         */
        this.dropdownClass = 'dropdown-menu p-0';
        /**
         * Date input format
         */
        this.dateInputFormat = 'L';
        /**
         * Time input format without seconds
         */
        this.timeInputFormat = 'LT';
        /**
         * Time input format with seconds
         */
        this.timeInputLongFormat = 'LTS';
        /**
         * Toggle time picker
         */
        this.timePicker = false;
        /**
         * Use only the time picker flag
         */
        this.timeOnly = false;
        /**
         * Use seconds in time picker
         */
        this.seconds = false;
        /**
         * Use disabled style for the control if [readonly]=true
         */
        this.disabledStyleForReadonlyState = false;
        /**
         * Picker placement
         */
        this.placement = ['bottom-left', 'top-left', 'bottom-right', 'top-right', 'bottom-left'];
        /**
         * Append to body trigger
         */
        this.appendToBody = false;
        /**
         * Prevent choosing dateTime Range value step-by-step
         */
        this.preventWizard = false;
        // Outputs
        /**
         * Event on picker open
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.open = new EventEmitter();
        /**
         * Event on picker close
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.close = new EventEmitter();
        /**
         * Event on ngModel change
         */
        this.valueChange = new EventEmitter();
        /**
         * FormControl focus implementation
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        /**
         * FormControl blur implementation
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Privates fields for ControlValueAccessor
        this._onTouchedCallback = noop$5;
        this._onChangeCallback = noop$5;
        // ngModel value
        this._model = null;
        // previousNgModel value
        this._previousModel = null;
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Template refs
        // Active range's edge
        this._dtStartIsActive = true;
        // Subjects
        this._editInProgress = new BehaviorSubject(false);
        this.dropdownAutoClose = this._deviceDetectorService.isMobile() ? false : 'outside';
        this.isMobile = this._deviceDetectorService.isMobile();
        this.isIE = this._deviceDetectorService.isIE();
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get editInProgress() {
        const inline = this.inline;
        const ddOpen = this.dropdownRef && this.dropdownRef.isOpen();
        const inputInFocus = this.inputControlRef && (document.activeElement === this.inputControlRef.nativeElement);
        return !inline && (ddOpen || inputInFocus);
    }
    get startValueSummary() {
        if (this.value && this.value[0]) {
            return this.value[0].isValid() ? this.value[0].format(this._getInputControlFormat()) : this.headings.invalidValueLabel;
        }
        return this.headings.emptyStartLabel;
    }
    get endValueSummary() {
        if (this.value && this.value[1]) {
            return this.value[1].isValid() ? this.value[1].format(this._getInputControlFormat()) : this.headings.invalidValueLabel;
        }
        return this.headings.emptyEndLabel;
    }
    get startRangeActive() {
        return this._dtStartIsActive;
    }
    get value() {
        return this._model;
    }
    set value(v) {
        if (this.disabled) {
            return;
        }
        if (v && (v[0] || v[1])) {
            this._model = [v[0], v[1]];
        }
        else {
            this._model = null;
        }
        this._onChangeCallback(this._model);
        this.valueChange.emit(this._model);
        this._updateActiveDateTime();
        this._inputControlFormatting();
    }
    ngOnInit() {
        super.ngOnInit();
        this.initControl();
        if (!this.id) {
            this.id = `dtr-${AdaptDatetimeRange2Component.DTR_ID++}`;
        }
        if (!this.testID) {
            this.testID = `dtr-${AdaptDatetimeRange2Component.DTR_TEST_ID++}`;
        }
        if (!this.name) {
            this.name = `${this.id}-form-control`;
        }
        if (this.timeOnly) {
            this.timePicker = true;
        }
        if (this.inline) {
            this._openPicker();
        }
        if (!this.mainCls) {
            this.mainCls = this.inline ? '' : 'form-group';
        }
        // Detect close event on dd
        this._dtrDropdownOpenChangeSub = this.dropdownRef.onClose.subscribe(() => {
            if (!this.inline) {
                this._closePicker();
            }
        });
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        this._editInProgress
            .pipe(distinctUntilChanged())
            .subscribe((inProgress) => {
            if (!(this.control && this.control.control)) {
                return;
            }
            if (!inProgress) {
                this.control.control.updateValueAndValidity();
            }
        });
        this.headings = Object.assign(Object.assign({}, this.defaultTexts), this.headings);
        if (this.tooltipIconCls && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIconCls,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
        this.isRtl = this._dir.value === 'rtl';
    }
    ngOnDestroy() {
        this._dtrDropdownOpenChangeSub.unsubscribe();
    }
    setDefaultTexts(translation) {
        this.defaultTexts.startLabel = translation['adapt.datetimeRange.startDate'];
        this.defaultTexts.endLabel = translation['adapt.datetimeRange.endDate'];
        this.defaultTexts.cancelBtn = translation['adapt.common.cancel'];
        this.defaultTexts.clearBtn = translation['adapt.common.clearAll'];
        this.defaultTexts.nextBtn = translation['adapt.common.next'];
        this.defaultTexts.applyBtn = translation['adapt.common.ok'];
        this.defaultTexts.emptyStartLabel = translation['adapt.datetimeRange.emptyStart'];
        this.defaultTexts.emptyEndLabel = translation['adapt.datetimeRange.emptyEnd'];
        this.defaultTexts.emptyTime = translation['adapt.datetimeRange.emptyTime'];
        this.defaultTexts.invalidValueLabel = translation['adapt.datetimeRange.invalidValue'];
        this.requiredLabel = translation['adapt.common.required'];
        this.defaultErrors.invalidStartName = translation['adapt.datetimeRange.error.invalidStartName'];
        this.defaultErrors.invalidStart = translation['adapt.datetimeRange.error.invalidStart'];
        this.defaultErrors.invalidEndName = translation['adapt.datetimeRange.error.invalidEndName'];
        this.defaultErrors.invalidEnd = translation['adapt.datetimeRange.error.invalidEnd'];
        this.defaultErrors.rangeName = translation['adapt.datetimeRange.error.rangeName'];
        this.defaultErrors.range = translation['adapt.datetimeRange.error.range'];
        this.defaultErrors.rangeOrderName = translation['adapt.datetimeRange.error.rangeOrderName'];
        this.defaultErrors.rangeOrder = translation['adapt.datetimeRange.error.rangeOrder'];
        this.defaultErrors.disabledDateStartName = translation['adapt.datetimeRange.error.disabledDateStartName'];
        this.defaultErrors.disabledDateStart = translation['adapt.datetimeRange.error.disabledDateStart'];
        this.defaultErrors.disabledDateEndName = translation['adapt.datetimeRange.error.disabledDateEndName'];
        this.defaultErrors.disabledDateEnd = translation['adapt.datetimeRange.error.disabledDateEnd'];
        this.defaultErrors.disabledTimeStartName = translation['adapt.datetimeRange.error.disabledTimeStartName'];
        this.defaultErrors.disabledTimeStart = translation['adapt.datetimeRange.error.disabledTimeStart'];
        this.defaultErrors.disabledTimeEndName = translation['adapt.datetimeRange.error.disabledTimeEndName'];
        this.defaultErrors.disabledTimeEnd = translation['adapt.datetimeRange.error.disabledTimeEnd'];
    }
    /**
     * Change active range edge to start
     */
    switchToStartDT() {
        this._dtStartIsActive = true;
        this._updateActiveDateTime();
        this.timeModeState$.next(this.timeOnly);
        this.clockFaceState$.next(Clock2FaceUnit.Hours);
    }
    /**
     * Change active range edge to end
     */
    switchToEndDT() {
        this._dtStartIsActive = false;
        this._updateActiveDateTime();
        this.timeModeState$.next(this.timeOnly);
        this.clockFaceState$.next(Clock2FaceUnit.Hours);
    }
    /**
     * Datetime wizard
     */
    goToNextStep() {
        if (this.inline) {
            return;
        }
        if (this.preventWizard) {
            this.pickerCloseAndApply();
            return;
        }
        if (this.timePicker) {
            if (!this.timeModeState$.value) {
                this.timeModeState$.next(true);
            }
            else {
                if (this.clockFaceState$.value === (this.seconds ? Clock2FaceUnit.Seconds : Clock2FaceUnit.Minutes)) {
                    if (this._dtStartIsActive) {
                        this.switchToEndDT();
                    }
                    else {
                        if (!!this.value && !!this.value[1] && this.value[1].isValid()) {
                            if (!!this.value && !!this.value[0] && this.value[0].isValid()) {
                                this.pickerCloseAndApply();
                            }
                            else {
                                this.switchToStartDT();
                            }
                        }
                        else {
                            this.switchToStartDT();
                        }
                    }
                }
                else {
                    this.clockFaceState$.next(this.clockFaceState$.value + 1);
                }
            }
        }
        else {
            this._dtStartIsActive ? this.switchToEndDT() : this.pickerCloseAndApply();
        }
        this._checkIfLastWizardStep();
    }
    /**
     * Select date/time on picker
     */
    selectDateTime(v) {
        const oldModel = this.value ? [this.value[0], this.value[1]] : [null, null];
        if (this._dtStartIsActive) {
            this.value = [
                v.clone(),
                oldModel[1] ? oldModel[1].clone() : null
            ];
        }
        else {
            this.value = [
                oldModel[0] ? oldModel[0].clone() : null,
                v.clone()
            ];
        }
        if (this.inline) {
            this._onTouchedCallback();
        }
    }
    /**
     * Close picker and set previous model value
     */
    pickerCloseAndCancel() {
        this.value = this._previousModel;
        this._closePicker();
    }
    /**
     * Close picker and use current value
     */
    pickerCloseAndApply() {
        this._closePicker();
    }
    /**
     * Clear model value
     */
    pickerClearAll() {
        this.value = null;
        this._checkIfLastWizardStep();
        if (this.isMobile) {
            this._closePicker();
        }
    }
    /**
     * Input control (input) handler
     */
    inputControlWrite(v) {
        this.inputControlValue = v;
        if (v) {
            this.value = this._tryParseRange(v);
        }
        else {
            this.value = [null, null];
        }
    }
    /**
     * Input control (focus) handler
     */
    inputControlFocus() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.focus.emit();
        if (!this.dropdownRef.isOpen()) {
            this._openPicker();
        }
        this._editInProgress.next(this.editInProgress);
    }
    /**
     * Input control (blur) handler
     */
    inputControlBlur() {
        this.blur.emit();
        this._inputControlFormatting();
        if (!this.dropdownRef.isOpen()) {
            this._onTouchedCallback();
        }
        this._editInProgress.next(this.editInProgress);
    }
    /**
     * Dropdown mousedown handler
     */
    dropdownMouseDown() {
        if (this.inputControlRef) {
            this.inputControlRef.nativeElement.blur();
        }
    }
    /**
     * Open picker
     */
    /**
     * Time mode change handler
     */
    timeModeChange(v) {
        if (this.timeModeState$.value !== v) {
            this.timeModeState$.next(v);
        }
        if (v && (this.clockFaceState$.value !== Clock2FaceUnit.Hours)) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this.clockFaceState$.next(Clock2FaceUnit.Hours);
            });
        }
        this._checkIfLastWizardStep();
    }
    /**
     * Close picker
     */
    /**
     * Clock face change handler
     */
    clockFaceChange(v) {
        if (this.clockFaceState$.value !== v) {
            this.clockFaceState$.next(v);
        }
        this._checkIfLastWizardStep();
    }
    writeValue(v) {
        this._model = v ? [v[0] ? moment(v[0]) : null, v[1] ? moment(v[1]) : null] : [null, null];
        this._updateActiveDateTime();
        this._inputControlFormatting();
    }
    /**
     * Get formatted [timeMin] prop value
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * Get formatted [timeMax] prop value
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * Get formatted [timeMin] prop value
     */
    setDisabledState(isDisabled) {
        this._disabled = isDisabled;
    }
    /**
     * Get formatted [timeMax] prop value
     */
    validate(c) {
        const invalidStartValueErrorMsg = {
            dateError: this._customErrorTexts.invalidStartValueError || {
                name: this.defaultErrors.invalidStartName,
                text: this.defaultErrors.invalidStart
            }
        };
        const invalidEndValueErrorMsg = {
            dateError: this._customErrorTexts.invalidEndValueError || {
                name: this.defaultErrors.invalidEndName,
                text: this.defaultErrors.invalidEnd
            }
        };
        const rangeModelErrorMsg = {
            dateError: this._customErrorTexts.missedRangeValueError || {
                name: this.defaultErrors.rangeName,
                text: this.defaultErrors.range
            }
        };
        const rangeErrorMsg = {
            dateError: this._customErrorTexts.rangeValuesOrderError || {
                name: this.defaultErrors.rangeOrderName,
                text: this.defaultErrors.rangeOrder
            }
        };
        const startDateErrorMsg = {
            dateError: this._customErrorTexts.unselectableStartDateError || {
                name: this.defaultErrors.disabledDateStartName,
                text: this.defaultErrors.disabledDateStart
            }
        };
        const endDateErrorMsg = {
            dateError: this._customErrorTexts.unselectableEndDateError || {
                name: this.defaultErrors.disabledDateEndName,
                text: this.defaultErrors.disabledDateEnd
            }
        };
        const unselectableStartTimeErrorMsg = {
            dateError: this._customErrorTexts.unselectableStartTimeError || {
                name: this.defaultErrors.disabledTimeStartName,
                text: formatString(this.defaultErrors.disabledTimeStart, this._getFormattedStartMinTime(), this._getFormattedStartMaxTime())
            }
        };
        const unselectableEndTimeErrorMsg = {
            dateError: this._customErrorTexts.unselectableEndTimeError || {
                name: this.defaultErrors.disabledTimeEndName,
                text: formatString(this.defaultErrors.disabledTimeEnd, this._getFormattedEndMinTime(), this._getFormattedEndMaxTime())
            }
        };
        const invalidStartValueError = c.value && c.value[0] && !c.value[0].isValid();
        const invalidEndValueError = c.value && c.value[1] && !c.value[1].isValid();
        const rangeModelError = !this.editInProgress && c.value && (c.value[0] || c.value[1]) && !(c.value[0] && c.value[1]);
        const rangeError = c.value && c.value[0] && c.value[0].isValid() && c.value[1] && c.value[1].isValid() &&
            c.value[0].isAfter(c.value[1]);
        const startDateError = c.value && c.value[0] && c.value[0].isValid() && !this._startDateFilter(c.value[0], c);
        const endDateError = c.value && c.value[1] && c.value[1].isValid() && !this._endDateFilter(c.value[1], c);
        const unselectableStartTimeError = c.value && c.value[0] && c.value[0].isValid() && this.startTimeMin && this.startTimeMax &&
            !IsTimeInRange(c.value[0], this.startTimeMin, this.startTimeMax);
        const unselectableEndTimeError = c.value && c.value[1] && c.value[1].isValid() && this.endTimeMin && this.endTimeMax &&
            !IsTimeInRange(c.value[1], this.endTimeMin, this.endTimeMax);
        return invalidStartValueError ? invalidStartValueErrorMsg :
            invalidEndValueError ? invalidEndValueErrorMsg :
                rangeModelError ? rangeModelErrorMsg :
                    rangeError ? rangeErrorMsg :
                        startDateError ? startDateErrorMsg :
                            endDateError ? endDateErrorMsg :
                                unselectableStartTimeError ? unselectableStartTimeErrorMsg :
                                    unselectableEndTimeError ? unselectableEndTimeErrorMsg : null;
    }
    /**
     * Get format for input control value
     */
    _truncateBtn(btn) {
        const xPadings = 10;
        if (btn.offsetWidth + xPadings > window.innerWidth - xPadings) {
            this._renderer.addClass(btn, 'text-truncate');
            return window.innerWidth - xPadings;
        }
        else {
            return btn.offsetWidth + xPadings;
        }
    }
    _wrapButtons() {
        const xPadings = 10; // left and right padding
        const cancelBtnWidth = this.cancelBtn.nativeElement.offsetWidth; // cancel button width
        const nextBtnWidth = this.nextBtn.nativeElement.offsetWidth; // next button width
        const clearBtnWidth = this.clearBtn.nativeElement.offsetWidth; // clear button width
        const btnGroupWidth = nextBtnWidth + clearBtnWidth + 5; // clear + next buttons width + margins
        const buttonsWidth = cancelBtnWidth + btnGroupWidth + xPadings; // all buttons width
        let containerWidth = buttonsWidth < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : buttonsWidth;
        if (window.innerWidth - xPadings < buttonsWidth) {
            // wrap button in two rows
            if (btnGroupWidth + xPadings < window.innerWidth - xPadings) {
                const firstRowWidth = btnGroupWidth + xPadings < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : btnGroupWidth + xPadings;
                const secondRowWidth = this._truncateBtn(this.cancelBtn.nativeElement);
                containerWidth = Math.max(firstRowWidth, secondRowWidth);
                this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
                this.twoRowsWrap = true;
            }
            else {
                // wrap button in three rows
                const firstRowWidth = this._truncateBtn(this.nextBtn.nativeElement);
                const secondRowWidth = this._truncateBtn(this.clearBtn.nativeElement);
                const thirdRowWidth = this._truncateBtn(this.cancelBtn.nativeElement);
                const maxButtonWidth = Math.max(firstRowWidth, secondRowWidth, thirdRowWidth);
                containerWidth = maxButtonWidth < MIN_DROPDOWN_WIDTH ? MIN_DROPDOWN_WIDTH : maxButtonWidth;
                this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
                this.threeRowsWrap = true;
            }
        }
        else {
            this._renderer.setStyle(this.calendarContainer.nativeElement, 'width', `${containerWidth}px`);
        }
    }
    _openPicker() {
        this._updateActiveDateTime();
        if (this._deviceDetectorService.isMobile() && this.inputControlRef) {
            this.inputControlRef.nativeElement.blur();
        }
        if (!this.inline && (this.isMobile || this.isIE)) {
            // in some cases nativeElement is undefined, need to wait for zone stable
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this._wrapButtons();
            });
        }
        this._previousModel = this.value ? [
            this.value[0] ? this.value[0].clone() : null,
            this.value[1] ? this.value[1].clone() : null
        ] : null;
        if (this.inline) {
            return;
        }
        this.switchToStartDT();
        this.dropdownRef.open();
        this.open.emit(this.id);
        this._editInProgress.next(this.editInProgress);
    }
    /**
     * Parse text into dateRange model
     */
    _closePicker() {
        this.twoRowsWrap = false;
        this.threeRowsWrap = false;
        if (this.inline) {
            return;
        }
        this.dropdownRef.close(); // DOUBLE CLOSE BECAUSE OF SUBSCRIPTION
        this.close.emit(this.id);
        this._onTouchedCallback();
        this._editInProgress.next(this.editInProgress);
    }
    /**
     * Get time format
     */
    _inputControlFormatting() {
        if (this.inputControlRef && (this.inputControlRef.nativeElement === document.activeElement)) {
            return;
        }
        if (this.value) {
            if ((this.value[0] && !this.value[0].isValid()) || (this.value[1] && !this.value[1].isValid())) {
                return;
            }
            if (this.value[0] && this.value[0].isValid()) {
                this.inputControlValue = this.value[0].format(this._getInputControlFormat());
            }
            else {
                this.inputControlValue = '';
            }
            if (this.value[1] && this.value[1].isValid()) {
                this.inputControlValue += ' - ' + this.value[1].format(this._getInputControlFormat());
            }
        }
        else {
            this.inputControlValue = '';
        }
        if (!this._changeDetectorRef.destroyed) {
            this._changeDetectorRef.detectChanges();
        }
    }
    /**
     * Combined filter for the start calendar
     */
    _getFormattedStartMinTime() {
        return (this.startTimeMin || moment().startOf('day')).format(this._getTimeFormat());
    }
    /**
     * Combined filter for the end calendar
     */
    _getFormattedStartMaxTime() {
        return (this.startTimeMax || moment().endOf('day')).format(this._getTimeFormat());
    }
    _getFormattedEndMinTime() {
        return (this.endTimeMin || moment().startOf('day')).format(this._getTimeFormat());
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // ControlValueAccessor
    _getFormattedEndMaxTime() {
        return (this.endTimeMax || moment().endOf('day')).format(this._getTimeFormat());
    }
    _getInputControlFormat() {
        let format = this.dateInputFormat;
        if (this.timePicker) {
            format += ` ${this._getTimeFormat()}`;
            if (this.timeOnly) {
                format = this._getTimeFormat();
            }
        }
        return format;
    }
    _tryParseRange(v) {
        let start;
        let end;
        const strictSeparator = v.split(/\s\W\s/g);
        if (strictSeparator.length === 2) {
            start = this.timeOnly ?
                moment(`${moment().format(this.dateInputFormat)} ${strictSeparator[0]}`, this.dateInputFormat + ' ' + this._getTimeFormat()) :
                moment(strictSeparator[0], this._getInputControlFormat());
            end = this.timeOnly ?
                moment(`${moment().format(this.dateInputFormat)} ${strictSeparator[1]}`, this.dateInputFormat + ' ' + this._getTimeFormat()) :
                moment(strictSeparator[1], this._getInputControlFormat());
            return [
                strictSeparator[0] ? start.clone() : null,
                strictSeparator[1] ? end.clone() : null
            ];
        }
        start = this.timeOnly ? moment(`${moment().format(this.dateInputFormat)} ${v}`) : moment(v);
        if (start.isValid()) {
            return [start.clone(), null];
        }
        const parts = v.split(' ');
        if (parts.length > 1) {
            let startStr = '';
            let endStr = '';
            for (let i = 0; i < parts.length; i++) {
                startStr += (parts[i] + ' ');
                const testStart = this.timeOnly ? moment(`${moment().format(this.dateInputFormat)} ${startStr}`) : moment(startStr);
                if (testStart.isValid()) {
                    start = testStart;
                }
                endStr = parts[parts.length - 1 - i] + ' ' + endStr;
                const testEnd = this.timeOnly ? moment(`${moment().format(this.dateInputFormat)} ${endStr}`) : moment(endStr);
                if (testEnd.isValid()) {
                    end = testEnd;
                }
            }
        }
        return [start.clone(), end ? end.clone() : null];
    }
    _getTimeFormat() {
        return this.seconds ? this.timeInputLongFormat : this.timeInputFormat;
    }
    _startDateFilter(d, formControl) {
        const acceptedByRangeFilter = this.value && this.value[1] && this.value[1].isValid() ?
            d.clone().startOf('day').isSameOrBefore(this.value[1].clone().startOf('day')) : true;
        const acceptedByCustomFilter = this.startDateFilter ? this.startDateFilter(d, formControl) : true;
        return acceptedByRangeFilter && acceptedByCustomFilter;
    }
    _endDateFilter(d, formControl) {
        const acceptedByRangeFilter = this.value && this.value[0] && this.value[0].isValid() ?
            d.clone().startOf('day').isSameOrAfter(this.value[0].clone().startOf('day')) : true;
        const acceptedByCustomFilter = this.endDateFilter ? this.endDateFilter(d, formControl) : true;
        return acceptedByRangeFilter && acceptedByCustomFilter;
    }
    _updateActiveDateTime() {
        this.activeDateTime = this._dtStartIsActive ?
            {
                initialValue: this.initialValue ? this.initialValue[0] : null,
                activeValue: this.value ? this.value[0] : null,
                dateFilter: this._startDateFilter.bind(this),
                dateRange: this.value ? [this.value[0], this.value[1]] : [null, null]
            } :
            {
                initialValue: this.initialValue ? this.initialValue[1] : null,
                activeValue: this.value ? this.value[1] : null,
                dateFilter: this._endDateFilter.bind(this),
                dateRange: this.value ? [this.value[0], this.value[1]] : [null, null]
            };
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Validator
    /**
     * Wizard's last step checking
     */
    _checkIfLastWizardStep() {
        const wizard = !this.preventWizard;
        const lastRangeValue = !this._dtStartIsActive;
        const lastTimeStep = this.timePicker && this.timeModeState$.value &&
            (this.clockFaceState$.value === (this.seconds ? Clock2FaceUnit.Seconds : Clock2FaceUnit.Minutes));
        const timePicker = this.timePicker;
        const lastStep = timePicker ? lastTimeStep : true;
        const modelFull = !timePicker ||
            (!!this.value && !!this.value[0] && this.value[0].isValid() && !!this.value[1] && this.value[1].isValid());
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this.isLastWizardStep = !wizard || (lastRangeValue && lastStep && modelFull);
        });
    }
}
// Static fields
AdaptDatetimeRange2Component.DTR_ID = 1;
AdaptDatetimeRange2Component.DTR_TEST_ID = 1;
AdaptDatetimeRange2Component.ɵfac = function AdaptDatetimeRange2Component_Factory(t) { return new (t || AdaptDatetimeRange2Component)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i2$1.Directionality), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptDatetimeRange2Component.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetimeRange2Component, selectors: [["adapt-datetime-range2"]], viewQuery: function AdaptDatetimeRange2Component_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$n, 5);
        i0.ɵɵviewQuery(_c1$h, 7);
        i0.ɵɵviewQuery(_c2$f, 5);
        i0.ɵɵviewQuery(_c3$b, 5);
        i0.ɵɵviewQuery(_c4$8, 5);
        i0.ɵɵviewQuery(_c5$6, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputControlRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nextBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cancelBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearBtn = _t.first);
    } }, hostVars: 3, hostBindings: function AdaptDatetimeRange2Component_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("name", ctx.name);
        i0.ɵɵstyleProp("display", "block");
    } }, inputs: { formControl: "formControl", id: "id", testID: "testID", name: "name", label: "label", placeholder: "placeholder", inline: "inline", inlineLight: "inlineLight", inlineSize: "inlineSize", initialValue: "initialValue", inputControlClass: "inputControlClass", dropdownClass: "dropdownClass", dateInputFormat: "dateInputFormat", timeInputFormat: "timeInputFormat", timeInputLongFormat: "timeInputLongFormat", timePicker: "timePicker", timeOnly: "timeOnly", seconds: "seconds", startTimeMin: "startTimeMin", startTimeMax: "startTimeMax", endTimeMin: "endTimeMin", endTimeMax: "endTimeMax", startDateFilter: "startDateFilter", endDateFilter: "endDateFilter", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", placement: "placement", appendToBody: "appendToBody", headings: "headings", preventWizard: "preventWizard" }, outputs: { open: "open", close: "close", valueChange: "valueChange", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptDatetimeRange2Component),
            createFormControlValidator(AdaptDatetimeRange2Component),
        ]), i0.ɵɵInheritDefinitionFeature], decls: 24, vars: 23, consts: [["adaptDropdown", "", 3, "adaptRadarDisableEventSending", "animationPlacement", "placement", "appendToBody", "autoClose", "holdFocusInMenu", "holdFocusOnOpen", "autoFocusFirst", "restoreFocusAfterClose", "mobileView"], ["dropdownRef", "adaptDropdown"], ["adaptDropdownAnchor", ""], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [4, "ngIf"], ["adaptDropdownMenuTemplate", ""], [4, "ngIf", "ngIfThen"], ["calendar", ""], ["errorTemplate", ""], ["autocomplete", "off", 3, "value", "disabled", "readonly", "input", "focus", "blur"], ["inputControlRef", ""], [3, "mousedown"], [3, "ngClass"], ["calendarContainer", ""], [1, "a3t-datetime-range--header"], ["type", "button", 3, "click"], [3, "initialValue", "activeValue", "dateFilter", "dateRange", "timeMode", "activeFace", "timePicker", "timeOnly", "timeSeconds", "emptyTimeHeading", "clockHeadings", "disabled", "readonly", "hideDatePickerSummary", "preventExpandedDateControls", "testID", "timeModeChange", "clockFaceChange", "valueChange"], ["class", "a3t-datetime--footer", 3, "two-rows-wrap", 4, "ngIf"], [1, "a3t-datetime--footer"], ["type", "button", 1, "btn", "btn-sm", "btn-link", 3, "click"], ["cancelBtn", ""], [1, "d-flex", "justify-content-center"], ["type", "button", 1, "btn", "btn-sm", "btn-secondary", "m-end-1", 3, "click"], ["clearBtn", ""], ["type", "button", 1, "btn", "btn-sm", "btn-primary", 3, "click"], ["nextBtn", ""], ["class", "has-danger adapt-datetime-range2__validation-errors", 4, "ngIf"], [1, "has-danger", "adapt-datetime-range2__validation-errors"], ["class", "form-control-feedback d-flex align-items-start m-0 pt-1 pb-0", 4, "ngFor", "ngForOf"], [1, "form-control-feedback", "d-flex", "align-items-start", "m-0", "pt-1", "pb-0"], ["class", "d-icon-exclamation_triangle flex-grow-0 flex-shrink-0 m-end-2", 4, "ngIf"], [1, "flex-grow-1", "flex-shrink-1"], [1, "d-icon-exclamation_triangle", "flex-grow-0", "flex-shrink-0", "m-end-2"]], template: function AdaptDatetimeRange2Component_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0, 1);
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelementStart(4, "div", 2);
        i0.ɵɵtext(5, "\n        ");
        i0.ɵɵelement(6, "adapt-rx-control-label", 3);
        i0.ɵɵtext(7, "\n\n        ");
        i0.ɵɵtemplate(8, AdaptDatetimeRange2Component_div_8_Template, 5, 22, "div", 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵtemplate(11, AdaptDatetimeRange2Component_ng_template_11_Template, 6, 4, "ng-template", 5);
        i0.ɵɵtext(12, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n\n    ");
        i0.ɵɵtemplate(14, AdaptDatetimeRange2Component_ng_container_14_Template, 1, 0, "ng-container", 6);
        i0.ɵɵtext(15, "\n\n    ");
        i0.ɵɵtemplate(16, AdaptDatetimeRange2Component_ng_template_16_Template, 26, 32, "ng-template", null, 7, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(18, "\n\n    ");
        i0.ɵɵtemplate(19, AdaptDatetimeRange2Component_ng_container_19_Template, 1, 0, "ng-container", 6);
        i0.ɵɵtext(20, "\n\n    ");
        i0.ɵɵtemplate(21, AdaptDatetimeRange2Component_ng_template_21_Template, 3, 1, "ng-template", null, 8, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(23, "\n  ");
    } if (rf & 2) {
        const _r4 = i0.ɵɵreference(17);
        const _r7 = i0.ɵɵreference(22);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("animationPlacement", "center")("placement", ctx.placement)("appendToBody", ctx.appendToBody)("autoClose", ctx.dropdownAutoClose)("holdFocusInMenu", true)("holdFocusOnOpen", false)("autoFocusFirst", false)("restoreFocusAfterClose", false)("mobileView", i0.ɵɵpureFunction0(22, _c6$4));
        i0.ɵɵadvance(3);
        i0.ɵɵclassProp("has-danger", ctx._self.errors.length > 0 && ctx._self.control.touched);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx._self.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.inline);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", ctx.inline)("ngIfThen", _r4);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", !ctx.inline)("ngIfThen", _r7);
    } }, encapsulation: 2, data: { animation: [
            trigger('heightAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '0',
                            to: '*'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '*',
                            to: '0'
                        }
                    })
                ])
            ]),
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetimeRange2Component, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime-range2',
                template: `
    <div adaptDropdown
         [adaptRadarDisableEventSending]="true"
         #dropdownRef="adaptDropdown"
         [animationPlacement]="'center'"
         [placement]="placement"
         [appendToBody]="appendToBody"
         [autoClose]="dropdownAutoClose"
         [holdFocusInMenu]="true"
         [holdFocusOnOpen]="false"
         [autoFocusFirst]="false"
         [restoreFocusAfterClose]="false"
         [mobileView]="{isPicker: true}">
      <div adaptDropdownAnchor [class.has-danger]="_self.errors.length > 0 && _self.control.touched">
        <adapt-rx-control-label [for]="id"
                                [label]="label"
                                [requiredLabel]="requiredLabel"
                                [showRequiredLabel]="_self.required"
                                [tooltip]="tooltipConfig"></adapt-rx-control-label>

        <div *ngIf="!inline">
          <input #inputControlRef
                 autocomplete="off"
                 [attr.id]="id"
                 [class]="'a3t-datetime--input-control form-control ' + (inputControlClass || '')"
                 [value]="inputControlValue"
                 (input)="inputControlWrite(inputControlRef.value)"
                 (focus)="inputControlFocus()"
                 (blur)="inputControlBlur()"
                 [disabled]="disabled"
                 [readonly]="readonly"
                 [class.form-control-disabled-look]="readonly && this.disabledStyleForReadonlyState"
                 [attr.placeholder]="placeholder"
                 [attr.data-testid]="testID"
                 [class.i-date]="!timePicker"
                 [class.i-date-time]="timePicker && !timeOnly"
                 [class.i-time]="timeOnly"
                 [class.readonly]="readonly"
                 [class.a3t-datetime--input-control_active]="dropdownRef.isOpen()"
                 [class.a3t-datetime--input-control_invalid]="_self.errors.length > 0 && _self.control.touched"/>
        </div>
      </div>
      <ng-template adaptDropdownMenuTemplate>
        <div [class]="dropdownClass || ''" (mousedown)="dropdownMouseDown()">
          <ng-container *ngIf="!inline; then calendar"></ng-container>
        </div>
      </ng-template>
    </div>

    <ng-container *ngIf="inline; then calendar"></ng-container>

    <ng-template #calendar>
      <div #calendarContainer [ngClass]="isMobile ? 'a3t-datetime--calendar-width' : 'a3t-datetime--calendar-min-width'"
           [class.a3t-datetime-inline-light]="inline && inlineLight"
           [class.a3t-datetime-inline-small]="inline && inlineSize === 'small'">
        <div class="a3t-datetime-range--header" [class.end-active]="isRtl ? startRangeActive : !startRangeActive">
          <button type="button"
                  [attr.data-testid]="testID + '_start'"
                  (click)="switchToStartDT()">
            {{headings.startLabel}}
            <div>{{startValueSummary}}</div>
          </button>
          <button type="button"
                  [attr.data-testid]="testID + '_end'"
                  (click)="switchToEndDT()">
            {{headings.endLabel}}
            <div>{{endValueSummary}}</div>
          </button>
        </div>

        <adapt-datetime2-picker [initialValue]="activeDateTime.initialValue"
                                [activeValue]="activeDateTime.activeValue"
                                [dateFilter]="activeDateTime.dateFilter"
                                [dateRange]="activeDateTime.dateRange"
                                [timeMode]="timeModeState$.value"
                                [activeFace]="clockFaceState$.value"
                                [timePicker]="timePicker"
                                [timeOnly]="timeOnly"
                                [timeSeconds]="seconds"
                                [emptyTimeHeading]="headings.emptyTime"
                                [clockHeadings]="headings"
                                [disabled]="disabled"
                                [readonly]="readonly"
                                [hideDatePickerSummary]="true"
                                [preventExpandedDateControls]="true"
                                [testID]="testID"
                                (timeModeChange)="timeModeChange($event)"
                                (clockFaceChange)="clockFaceChange($event)"
                                (valueChange)="selectDateTime($event)"></adapt-datetime2-picker>

        <div class="a3t-datetime--footer" [class.two-rows-wrap]="twoRowsWrap || threeRowsWrap" *ngIf="!inline">
          <div>
            <button #cancelBtn
                    [attr.data-testid]="testID + '_cancel'"
                    type="button"
                    class="btn btn-sm btn-link"
                    (click)="pickerCloseAndCancel()">
              {{headings.cancelBtn}}</button>
          </div>
          <div class="d-flex justify-content-center" [class.three-rows-wrap]="threeRowsWrap">
            <button #clearBtn
                    [attr.data-testid]="testID + '_clear'"
                    type="button"
                    class="btn btn-sm btn-secondary m-end-1" (click)="pickerClearAll()">
              {{headings.clearBtn}}</button>
            <button #nextBtn
                    [attr.data-testid]="testID + '_apply'"
                    type="button"
                    class="btn btn-sm btn-primary" (click)="$event.stopPropagation(); goToNextStep()">
              <span *ngIf="isLastWizardStep">{{headings.applyBtn}}</span>
              <span *ngIf="!isLastWizardStep">{{headings.nextBtn}}</span>
            </button>
          </div>
        </div>

        <ng-container *ngIf="inline; then errorTemplate"></ng-container>
      </div>
    </ng-template>

    <ng-container *ngIf="!inline; then errorTemplate"></ng-container>

    <ng-template #errorTemplate>
      <div class="has-danger adapt-datetime-range2__validation-errors"
           *ngIf="_self.errors.length > 0 && _self.control.touched"
           [@validationFeedbackAnimation]>
        <div class="form-control-feedback d-flex align-items-start m-0 pt-1 pb-0" *ngFor="let error of _self.errors">
          <div class="d-icon-exclamation_triangle flex-grow-0 flex-shrink-0 m-end-2" *ngIf="inline"></div>
          <div class="flex-grow-1 flex-shrink-1"><strong *ngIf="error.name">{{error.name}} </strong>{{error.text}}</div>
        </div>
      </div>
    </ng-template>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.name]': 'name',
                    '[style.display]': '"block"'
                },
                animations: [
                    trigger('heightAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '0',
                                    to: '*'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '*',
                                    to: '0'
                                }
                            })
                        ])
                    ]),
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ],
                providers: [
                    createFormControlValueAccessor(AdaptDatetimeRange2Component),
                    createFormControlValidator(AdaptDatetimeRange2Component),
                ]
            }]
    }], function () { return [{ type: i0.Injector }, { type: i2$1.Directionality }, { type: i1.AdaptDeviceDetectionService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { formControl: [{
            type: Input
        }], id: [{
            type: Input
        }], testID: [{
            type: Input
        }], name: [{
            type: Input
        }], label: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], inline: [{
            type: Input
        }], inlineLight: [{
            type: Input
        }], inlineSize: [{
            type: Input
        }], initialValue: [{
            type: Input
        }], inputControlClass: [{
            type: Input
        }], dropdownClass: [{
            type: Input
        }], dateInputFormat: [{
            type: Input
        }], timeInputFormat: [{
            type: Input
        }], timeInputLongFormat: [{
            type: Input
        }], timePicker: [{
            type: Input
        }], timeOnly: [{
            type: Input
        }], seconds: [{
            type: Input
        }], startTimeMin: [{
            type: Input
        }], startTimeMax: [{
            type: Input
        }], endTimeMin: [{
            type: Input
        }], endTimeMax: [{
            type: Input
        }], startDateFilter: [{
            type: Input
        }], endDateFilter: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], placement: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], headings: [{
            type: Input
        }], preventWizard: [{
            type: Input
        }], open: [{
            type: Output
        }], close: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], inputControlRef: [{
            type: ViewChild,
            args: ['inputControlRef']
        }], dropdownRef: [{
            type: ViewChild,
            args: ['dropdownRef', { static: true }]
        }], calendarContainer: [{
            type: ViewChild,
            args: ['calendarContainer', { static: false }]
        }], nextBtn: [{
            type: ViewChild,
            args: ['nextBtn', { static: false }]
        }], cancelBtn: [{
            type: ViewChild,
            args: ['cancelBtn', { static: false }]
        }], clearBtn: [{
            type: ViewChild,
            args: ['clearBtn', { static: false }]
        }] }); })();

const _c0$m = ["calendarContainerRef"];
function AdaptDatetime2YearPickerComponent_tr_13_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelementStart(2, "td", 5);
    i0.ɵɵtext(3, "\n                      ");
    i0.ɵɵelementStart(4, "button", 6);
    i0.ɵɵlistener("click", function AdaptDatetime2YearPickerComponent_tr_13_ng_container_2_Template_button_click_4_listener() { const restoredCtx = i0.ɵɵrestoreView(_r8); const year_r5 = restoredCtx.$implicit; const col_r6 = restoredCtx.index; const row_r3 = i0.ɵɵnextContext().index; const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.onYearClick(year_r5.date, row_r3, col_r6); });
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const year_r5 = ctx.$implicit;
    i0.ɵɵadvance(4);
    i0.ɵɵclassProp("active", year_r5.isSelected)("today", year_r5.isToday)("disabled", year_r5.isDisabled);
    i0.ɵɵproperty("disabled", year_r5.isDisabled);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(year_r5.date.format("YYYY"));
} }
function AdaptDatetime2YearPickerComponent_tr_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "tr");
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵtemplate(2, AdaptDatetime2YearPickerComponent_tr_13_ng_container_2_Template, 8, 8, "ng-container", 4);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const years_r2 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", years_r2);
} }
class AdaptDatetime2YearPickerComponent {
    constructor(_animationBuilder) {
        this._animationBuilder = _animationBuilder;
        this.animationDirectionForward = true;
        this.disabled = false;
        this.yearSelect = new EventEmitter();
        this._initialDate = moment();
        this._activeDate = null;
        this._animationReady = false;
        this._redraw = true;
        this._activeIndex = 4;
        this._columnsAmount = 3;
        this._rowsAmount = 4;
        this._itemsAmount = this._rowsAmount * this._columnsAmount;
    }
    set initialDate(initDate) {
        if (initDate && initDate.isValid()) {
            this._initialDate = initDate.clone();
        }
    }
    set activeDate(activeDate) {
        if (activeDate && activeDate.isValid()) {
            this._activeDate = activeDate.clone();
        }
        else {
            this._activeDate = null;
        }
        if (this.calendar) {
            this._patchCalendar();
        }
    }
    ngOnInit() {
        this._initCalendar();
        this._drawCalendar();
    }
    onYearClick(year, row, col) {
        this.yearSelect.emit(year.clone());
        this._activeIndex = this._columnsAmount * row + col;
        this._redraw = false;
    }
    ngOnChanges(changes) {
        if (changes.yearsPage) {
            if (this._redraw || this.yearsPage) {
                this._drawCalendar();
                this._redraw = true;
            }
        }
    }
    ngAfterViewInit() {
        this.calendarPlayers.prevOut = this._animationBuilder.build(this.animationsSet.prevOut)
            .create(this.calendarContainerRef.nativeElement);
        this.calendarPlayers.prevIn = this._animationBuilder.build(this.animationsSet.prevIn)
            .create(this.calendarContainerRef.nativeElement);
        this.calendarPlayers.nextOut = this._animationBuilder.build(this.animationsSet.nextOut)
            .create(this.calendarContainerRef.nativeElement);
        this.calendarPlayers.nextIn = this._animationBuilder.build(this.animationsSet.nextIn)
            .create(this.calendarContainerRef.nativeElement);
        this._animationReady = true;
    }
    _initCalendar() {
        this.calendar =
            Array(this._rowsAmount)
                .fill(0)
                .map(() => Array(this._columnsAmount)
                .fill(0)
                .map(() => new Calendar2Day()));
    }
    _drawCalendar() {
        const initialDate = Number(this._initialDate.clone().format('YYYY'));
        const startYear = this._initialDate.clone().startOf('year');
        const yearsArr = new Array(this._itemsAmount).fill(0).map(() => new Calendar2Day());
        yearsArr.forEach((item, index) => {
            if (this._activeIndex > index || this._activeIndex < index) {
                yearsArr[index].date = startYear.year(initialDate - (this._activeIndex - index) + (this._itemsAmount * this.yearsPage)).clone();
            }
            else {
                yearsArr[index].date = startYear.year(initialDate + this._itemsAmount * this.yearsPage).clone();
            }
        });
        // Animate calendar while component redraw
        this._animateCalendarChange((() => {
            // Need to transform one-dimensional array into multi-dimensional (4 x 3)
            this.calendar = yearsArr.reduce((rows, key, index) => {
                return (index % this._columnsAmount === 0 ? rows.push([key])
                    : rows[rows.length - 1].push(key)) && rows;
            }, []);
            this._patchCalendar();
        }).bind(this));
    }
    _animateCalendarChange(changeValFn) {
        if (this._animationReady) {
            this.calendarPlayers.prevOut.reset();
            this.calendarPlayers.prevIn.reset();
            this.calendarPlayers.nextOut.reset();
            this.calendarPlayers.nextIn.reset();
            const _in = this.animationDirectionForward ? this.calendarPlayers.nextIn : this.calendarPlayers.prevIn;
            const _out = this.animationDirectionForward ? this.calendarPlayers.nextOut : this.calendarPlayers.prevOut;
            _out.onDone(() => {
                changeValFn();
                _in.play();
            });
            _out.play();
        }
        else {
            changeValFn();
        }
    }
    _patchCalendar() {
        this.calendar.forEach((years) => {
            years.forEach((year) => {
                year.isSelected = this._activeDate ?
                    this._activeDate.clone().startOf('year').isSame(year.date.startOf('year')) : false;
                year.isToday = moment().startOf('year').isSame(year.date.startOf('year'));
                year.isDisabled = this.disabled;
            });
        });
    }
}
AdaptDatetime2YearPickerComponent.ɵfac = function AdaptDatetime2YearPickerComponent_Factory(t) { return new (t || AdaptDatetime2YearPickerComponent)(i0.ɵɵdirectiveInject(i1$1.AnimationBuilder)); };
AdaptDatetime2YearPickerComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetime2YearPickerComponent, selectors: [["adapt-datetime2-year-picker"]], viewQuery: function AdaptDatetime2YearPickerComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$m, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarContainerRef = _t.first);
    } }, inputs: { calendarPlayers: "calendarPlayers", animationsSet: "animationsSet", yearsPage: "yearsPage", disabled: "disabled", initialDate: "initialDate", activeDate: "activeDate" }, outputs: { yearSelect: "yearSelect" }, features: [i0.ɵɵNgOnChangesFeature], decls: 22, vars: 1, consts: [[1, "a3t-calendar--table", "a3t-calendar--year_table"], ["calendarContainerRef", ""], ["aria-hidden", "true"], ["colspan", "3", 1, "a3t-calendar--table-space-cell"], [4, "ngFor", "ngForOf"], ["role", "gridcell", 1, "a3t-calendar--table-day", "a3t-calendar--table-year"], ["type", "button", 3, "disabled", "click"]], template: function AdaptDatetime2YearPickerComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n      ");
        i0.ɵɵelementStart(1, "table", 0);
        i0.ɵɵtext(2, "\n          ");
        i0.ɵɵelement(3, "thead");
        i0.ɵɵtext(4, "\n          ");
        i0.ɵɵelementStart(5, "tbody", null, 1);
        i0.ɵɵtext(7, "\n          ");
        i0.ɵɵelementStart(8, "tr", 2);
        i0.ɵɵtext(9, "\n              ");
        i0.ɵɵelement(10, "td", 3);
        i0.ɵɵtext(11, "\n          ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(12, "\n          ");
        i0.ɵɵtemplate(13, AdaptDatetime2YearPickerComponent_tr_13_Template, 4, 1, "tr", 4);
        i0.ɵɵtext(14, "\n          ");
        i0.ɵɵelementStart(15, "tr", 2);
        i0.ɵɵtext(16, "\n              ");
        i0.ɵɵelement(17, "td", 3);
        i0.ɵɵtext(18, "\n          ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(19, "\n          ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(21, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(13);
        i0.ɵɵproperty("ngForOf", ctx.calendar);
    } }, directives: [i3.NgForOf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetime2YearPickerComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime2-year-picker',
                template: `
      <table class="a3t-calendar--table a3t-calendar--year_table">
          <thead></thead>
          <tbody #calendarContainerRef>
          <tr aria-hidden="true">
              <td colspan="3" class="a3t-calendar--table-space-cell"></td>
          </tr>
          <tr *ngFor="let years of calendar; let row = index">
              <ng-container *ngFor="let year of years; let col = index">
                  <td class="a3t-calendar--table-day a3t-calendar--table-year"
                      role="gridcell">
                      <button
                              type="button"
                              (click)="onYearClick(year.date, row, col)"
                              [class.active]="year.isSelected"
                              [class.today]="year.isToday"
                              [class.disabled]="year.isDisabled"
                              [disabled]="year.isDisabled"
                      >{{ year.date.format('YYYY') }}</button>
                  </td>
              </ng-container>
          </tr>
          <tr aria-hidden="true">
              <td colspan="3" class="a3t-calendar--table-space-cell"></td>
          </tr>
          </tbody>
      </table>
  `
            }]
    }], function () { return [{ type: i1$1.AnimationBuilder }]; }, { calendarContainerRef: [{
            type: ViewChild,
            args: ['calendarContainerRef']
        }], calendarPlayers: [{
            type: Input
        }], animationsSet: [{
            type: Input
        }], yearsPage: [{
            type: Input
        }], disabled: [{
            type: Input
        }], yearSelect: [{
            type: Output
        }], initialDate: [{
            type: Input
        }], activeDate: [{
            type: Input
        }] }); })();

function AdaptDatetime2MonthPickerComponent_tr_10_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "td", 4);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementStart(4, "button", 5);
    i0.ɵɵlistener("click", function AdaptDatetime2MonthPickerComponent_tr_10_ng_container_2_Template_button_click_4_listener() { const restoredCtx = i0.ɵɵrestoreView(_r5); const month_r3 = restoredCtx.$implicit; const ctx_r4 = i0.ɵɵnextContext(2); return ctx_r4.onMonthClick(month_r3.date); });
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const month_r3 = ctx.$implicit;
    i0.ɵɵadvance(4);
    i0.ɵɵclassProp("active", month_r3.isSelected)("today", month_r3.isToday)("disabled", month_r3.isDisabled);
    i0.ɵɵproperty("disabled", month_r3.isDisabled);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(month_r3.date.format("MMM"));
} }
function AdaptDatetime2MonthPickerComponent_tr_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "tr");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptDatetime2MonthPickerComponent_tr_10_ng_container_2_Template, 8, 8, "ng-container", 3);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const months_r1 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", months_r1);
} }
class AdaptDatetime2MonthPickerComponent {
    constructor() {
        this.disabled = false;
        this.selectMonth = new EventEmitter();
        this._initialDate = moment();
        this._activeDate = null;
        this._columnsAmount = 3;
        this._rowsAmount = 4;
        this._itemsAmount = this._rowsAmount * this._columnsAmount;
    }
    set initialDate(initDate) {
        if (initDate && initDate.isValid()) {
            this._initialDate = initDate.clone();
        }
    }
    set activeDate(activeDate) {
        if (activeDate && activeDate.isValid()) {
            this._activeDate = activeDate.clone();
            this._initialDate = activeDate.clone();
            this._drawCalendar();
        }
        else {
            this._activeDate = null;
            if (this.calendar) {
                this._patchCalendar();
            }
        }
    }
    ngOnInit() {
        this._initCalendar();
        this._drawCalendar();
    }
    onMonthClick(month) {
        this.selectMonth.emit(month.clone());
    }
    _initCalendar() {
        this.calendar =
            Array(this._rowsAmount)
                .fill(0)
                .map(() => Array(this._columnsAmount)
                .fill(0)
                .map(() => new Calendar2Day()));
    }
    _drawCalendar() {
        const momentArr = moment.monthsShort();
        const startDate = this._initialDate.clone();
        const monthArr = new Array(this._itemsAmount).fill(0).map(() => new Calendar2Day());
        monthArr.forEach((item, index) => {
            monthArr[index].date = startDate.month(momentArr[index]).clone();
        });
        this.calendar = monthArr.reduce((rows, key, index) => {
            return (index % this._columnsAmount === 0 ? rows.push([key])
                : rows[rows.length - 1].push(key)) && rows;
        }, []);
        this._patchCalendar();
    }
    _patchCalendar() {
        this.calendar.forEach((months) => {
            months.forEach((month) => {
                month.isSelected = this._activeDate ?
                    this._activeDate.clone().startOf('month').isSame(month.date.startOf('month')) : false;
                month.isToday = moment().startOf('month').isSame(month.date.startOf('month'));
                month.isDisabled = this.disabled;
            });
        });
    }
}
AdaptDatetime2MonthPickerComponent.ɵfac = function AdaptDatetime2MonthPickerComponent_Factory(t) { return new (t || AdaptDatetime2MonthPickerComponent)(); };
AdaptDatetime2MonthPickerComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetime2MonthPickerComponent, selectors: [["adapt-datetime2-month-picker"]], inputs: { initialDate: "initialDate", activeDate: "activeDate", disabled: "disabled" }, outputs: { selectMonth: "selectMonth" }, decls: 19, vars: 1, consts: [[1, "a3t-calendar--table", "a3t-calendar--month_table"], ["aria-hidden", "true"], ["colspan", "3", 1, "a3t-calendar--table-space-cell"], [4, "ngFor", "ngForOf"], ["role", "gridcell", 1, "a3t-calendar--table-day", "a3t-calendar--table-month"], ["type", "button", 3, "disabled", "click"]], template: function AdaptDatetime2MonthPickerComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "table", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵelementStart(3, "tbody");
        i0.ɵɵtext(4, "\n        ");
        i0.ɵɵelementStart(5, "tr", 1);
        i0.ɵɵtext(6, "\n          ");
        i0.ɵɵelement(7, "td", 2);
        i0.ɵɵtext(8, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(9, "\n        ");
        i0.ɵɵtemplate(10, AdaptDatetime2MonthPickerComponent_tr_10_Template, 4, 1, "tr", 3);
        i0.ɵɵtext(11, "\n        ");
        i0.ɵɵelementStart(12, "tr", 1);
        i0.ɵɵtext(13, "\n          ");
        i0.ɵɵelement(14, "td", 2);
        i0.ɵɵtext(15, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(10);
        i0.ɵɵproperty("ngForOf", ctx.calendar);
    } }, directives: [i3.NgForOf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetime2MonthPickerComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime2-month-picker',
                template: `
    <table class="a3t-calendar--table  a3t-calendar--month_table">
      <tbody>
        <tr aria-hidden="true">
          <td colspan="3" class="a3t-calendar--table-space-cell"></td>
        </tr>
        <tr *ngFor="let months of calendar">
          <ng-container *ngFor="let month of months">
            <td class="a3t-calendar--table-day a3t-calendar--table-month"
                role="gridcell">
              <button type="button"
                (click)="onMonthClick(month.date)"
                [class.active]="month.isSelected"
                [class.today]="month.isToday"
                [class.disabled]="month.isDisabled"
                [disabled]="month.isDisabled"
              >{{month.date.format('MMM')}}</button>
            </td>
          </ng-container>
        </tr>
        <tr aria-hidden="true">
          <td colspan="3" class="a3t-calendar--table-space-cell"></td>
        </tr>
      </tbody>
    </table>
  `
            }]
    }], null, { initialDate: [{
            type: Input
        }], activeDate: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selectMonth: [{
            type: Output
        }] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$l = ["daysTable"];
const _c1$g = ["calendarContainerRef"];
function AdaptDatetime2CalendarComponent_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2CalendarComponent_div_1_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_6_adapt_icon_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_left");
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_6_adapt_icon_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_right");
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_6_adapt_icon_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_left");
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_6_adapt_icon_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_right");
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    const _r14 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n              ");
    i0.ɵɵelementStart(1, "div", 7);
    i0.ɵɵtext(2, "\n                  ");
    i0.ɵɵelementStart(3, "button", 8);
    i0.ɵɵlistener("click", function AdaptDatetime2CalendarComponent_div_1_ng_template_6_Template_button_click_3_listener($event) { i0.ɵɵrestoreView(_r14); const ctx_r13 = i0.ɵɵnextContext(2); $event.stopPropagation(); return ctx_r13.calendarUIActions.prevYear(); });
    i0.ɵɵtext(4, "\n                      ");
    i0.ɵɵtemplate(5, AdaptDatetime2CalendarComponent_div_1_ng_template_6_adapt_icon_5_Template, 1, 2, "adapt-icon", 9);
    i0.ɵɵtext(6, "\n                      ");
    i0.ɵɵtemplate(7, AdaptDatetime2CalendarComponent_div_1_ng_template_6_adapt_icon_7_Template, 1, 2, "adapt-icon", 9);
    i0.ɵɵtext(8, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n                  ");
    i0.ɵɵelementStart(10, "div", 10);
    i0.ɵɵlistener("keydown.arrowUp", function AdaptDatetime2CalendarComponent_div_1_ng_template_6_Template_div_keydown_arrowUp_10_listener($event) { i0.ɵɵrestoreView(_r14); const ctx_r15 = i0.ɵɵnextContext(2); $event.preventDefault(); return ctx_r15.calendarUIActions.nextYear(); })("keydown.arrowRight", function AdaptDatetime2CalendarComponent_div_1_ng_template_6_Template_div_keydown_arrowRight_10_listener($event) { i0.ɵɵrestoreView(_r14); const ctx_r16 = i0.ɵɵnextContext(2); $event.preventDefault(); return ctx_r16.calendarUIActions.nextYear(); })("keydown.arrowDown", function AdaptDatetime2CalendarComponent_div_1_ng_template_6_Template_div_keydown_arrowDown_10_listener($event) { i0.ɵɵrestoreView(_r14); const ctx_r17 = i0.ɵɵnextContext(2); $event.preventDefault(); return ctx_r17.calendarUIActions.prevYear(); })("keydown.arrowLeft", function AdaptDatetime2CalendarComponent_div_1_ng_template_6_Template_div_keydown_arrowLeft_10_listener($event) { i0.ɵɵrestoreView(_r14); const ctx_r18 = i0.ɵɵnextContext(2); $event.preventDefault(); return ctx_r18.calendarUIActions.prevYear(); });
    i0.ɵɵtext(11, "\n                      ");
    i0.ɵɵelement(12, "div", 11);
    i0.ɵɵtext(13, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n                  ");
    i0.ɵɵelementStart(15, "button", 8);
    i0.ɵɵlistener("click", function AdaptDatetime2CalendarComponent_div_1_ng_template_6_Template_button_click_15_listener($event) { i0.ɵɵrestoreView(_r14); const ctx_r19 = i0.ɵɵnextContext(2); $event.stopPropagation(); return ctx_r19.calendarUIActions.nextYear(); });
    i0.ɵɵtext(16, "\n                      ");
    i0.ɵɵtemplate(17, AdaptDatetime2CalendarComponent_div_1_ng_template_6_adapt_icon_17_Template, 1, 2, "adapt-icon", 9);
    i0.ɵɵtext(18, "\n                      ");
    i0.ɵɵtemplate(19, AdaptDatetime2CalendarComponent_div_1_ng_template_6_adapt_icon_19_Template, 1, 2, "adapt-icon", 9);
    i0.ɵɵtext(20, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(21, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n          ");
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("a3t-calendar--year-picker", ctx_r6.monthAndYearOnly);
    i0.ɵɵattribute("aria-label", ctx_r6.defaultTexts.emptyYear);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("disabled", ctx_r6.calendarUIState.disabled)("readonly", ctx_r6.calendarUIState.readonly);
    i0.ɵɵproperty("disabled", ctx_r6.calendarUIState.disabled);
    i0.ɵɵattribute("data-testid", ctx_r6.testID + "_prevYear");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r6.isRtl);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.isRtl);
    i0.ɵɵadvance(3);
    i0.ɵɵattribute("aria-label", ctx_r6.defaultTexts.emptyYear)("aria-valuenow", ctx_r6.calendarUIState.date.format("YYYY"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptTextSlide", ctx_r6.calendarUIState.date.format("YYYY"))("slideForward", ctx_r6.animationDirectionForward);
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("disabled", ctx_r6.calendarUIState.disabled)("readonly", ctx_r6.calendarUIState.readonly);
    i0.ɵɵproperty("disabled", ctx_r6.calendarUIState.disabled);
    i0.ɵɵattribute("data-testid", ctx_r6.testID + "_nextYear");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.isRtl);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r6.isRtl);
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_adapt_icon_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_left");
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_adapt_icon_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_right");
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_adapt_icon_16_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_left");
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_adapt_icon_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_right");
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r26 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 7);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelementStart(2, "button", 8);
    i0.ɵɵlistener("click", function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_Template_button_click_2_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r25 = i0.ɵɵnextContext(3); $event.stopPropagation(); return ctx_r25.calendarUIActions.prevMonth(); });
    i0.ɵɵtext(3, "\n                      ");
    i0.ɵɵtemplate(4, AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_adapt_icon_4_Template, 1, 2, "adapt-icon", 9);
    i0.ɵɵtext(5, "\n                      ");
    i0.ɵɵtemplate(6, AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_adapt_icon_6_Template, 1, 2, "adapt-icon", 9);
    i0.ɵɵtext(7, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n                  ");
    i0.ɵɵelementStart(9, "div", 10);
    i0.ɵɵlistener("keydown.arrowUp", function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_Template_div_keydown_arrowUp_9_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r27 = i0.ɵɵnextContext(3); $event.preventDefault(); return ctx_r27.calendarUIActions.nextMonth(); })("keydown.arrowRight", function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_Template_div_keydown_arrowRight_9_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r28 = i0.ɵɵnextContext(3); $event.preventDefault(); return ctx_r28.calendarUIActions.nextMonth(); })("keydown.arrowDown", function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_Template_div_keydown_arrowDown_9_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r29 = i0.ɵɵnextContext(3); $event.preventDefault(); return ctx_r29.calendarUIActions.prevMonth(); })("keydown.arrowLeft", function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_Template_div_keydown_arrowLeft_9_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r30 = i0.ɵɵnextContext(3); $event.preventDefault(); return ctx_r30.calendarUIActions.prevMonth(); });
    i0.ɵɵtext(10, "\n                      ");
    i0.ɵɵelement(11, "div", 11);
    i0.ɵɵtext(12, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n                  ");
    i0.ɵɵelementStart(14, "button", 8);
    i0.ɵɵlistener("click", function AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_Template_button_click_14_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r31 = i0.ɵɵnextContext(3); $event.stopPropagation(); return ctx_r31.calendarUIActions.nextMonth(); });
    i0.ɵɵtext(15, "\n                      ");
    i0.ɵɵtemplate(16, AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_adapt_icon_16_Template, 1, 2, "adapt-icon", 9);
    i0.ɵɵtext(17, "\n                      ");
    i0.ɵɵtemplate(18, AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_adapt_icon_18_Template, 1, 2, "adapt-icon", 9);
    i0.ɵɵtext(19, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r20 = i0.ɵɵnextContext(3);
    i0.ɵɵattribute("aria-label", ctx_r20.defaultTexts.emptyMonth);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("disabled", ctx_r20.calendarUIState.disabled)("readonly", ctx_r20.calendarUIState.readonly);
    i0.ɵɵproperty("disabled", ctx_r20.calendarUIState.disabled);
    i0.ɵɵattribute("data-testid", ctx_r20.testID + "_prevMonth");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r20.isRtl);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r20.isRtl);
    i0.ɵɵadvance(3);
    i0.ɵɵattribute("aria-label", ctx_r20.defaultTexts.emptyMonth)("aria-valuetext", ctx_r20.calendarUIState.date.format("MMMM"));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptTextSlide", ctx_r20.calendarUIState.date.format(ctx_r20.calendarUIState.expanded ? "MMMM" : "MMM"))("slideForward", ctx_r20.animationDirectionForward);
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("disabled", ctx_r20.calendarUIState.disabled)("readonly", ctx_r20.calendarUIState.readonly);
    i0.ɵɵproperty("disabled", ctx_r20.calendarUIState.disabled);
    i0.ɵɵattribute("data-testid", ctx_r20.testID + "_nextMonth");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r20.isRtl);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r20.isRtl);
} }
function AdaptDatetime2CalendarComponent_div_1_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n              ");
    i0.ɵɵtemplate(1, AdaptDatetime2CalendarComponent_div_1_ng_template_9_div_1_Template, 21, 21, "div", 13);
    i0.ɵɵtext(2, "\n          ");
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !ctx_r8.monthAndYearOnly);
} }
function AdaptDatetime2CalendarComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 3);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptDatetime2CalendarComponent_div_1_ng_container_2_Template, 1, 0, "ng-container", 4);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵtemplate(4, AdaptDatetime2CalendarComponent_div_1_ng_container_4_Template, 1, 0, "ng-container", 4);
    i0.ɵɵtext(5, "\n\n          ");
    i0.ɵɵtemplate(6, AdaptDatetime2CalendarComponent_div_1_ng_template_6_Template, 23, 23, "ng-template", null, 5, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵtemplate(9, AdaptDatetime2CalendarComponent_div_1_ng_template_9_Template, 3, 1, "ng-template", null, 6, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(11, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r5 = i0.ɵɵreference(7);
    const _r7 = i0.ɵɵreference(10);
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("a3t-calendar--controls_expanded", ctx_r0.calendarUIState.expanded);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r0.calendarUIState.expanded)("ngIfThen", _r7)("ngIfElse", _r5);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.calendarUIState.expanded)("ngIfThen", _r7)("ngIfElse", _r5);
} }
function AdaptDatetime2CalendarComponent_table_3_ng_container_7_th_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "th", 22);
} }
function AdaptDatetime2CalendarComponent_table_3_ng_container_7_th_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "th", 22);
} }
function AdaptDatetime2CalendarComponent_table_3_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵtemplate(2, AdaptDatetime2CalendarComponent_table_3_ng_container_7_th_2_Template, 1, 0, "th", 20);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelementStart(4, "th", 21);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n                  ");
    i0.ɵɵtemplate(7, AdaptDatetime2CalendarComponent_table_3_ng_container_7_th_7_Template, 1, 0, "th", 20);
    i0.ɵɵtext(8, "\n              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const dayOfWeek_r36 = ctx.$implicit;
    const first_r37 = ctx.first;
    const last_r38 = ctx.last;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", first_r37);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("\n                      ", dayOfWeek_r36.date.format("dd"), "\n                  ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", last_r38);
} }
function AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_td_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "td", 22);
} if (rf & 2) {
    const day_r43 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵclassProp("range", day_r43.isInRange && !day_r43.isRangeFrom)("other-month", day_r43.isOtherMonth);
} }
function AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_td_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "td", 22);
} if (rf & 2) {
    const day_r43 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵclassProp("range", day_r43.isInRange && !day_r43.isRangeTo)("other-month", day_r43.isOtherMonth);
} }
function AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r52 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵtemplate(2, AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_td_2_Template, 1, 4, "td", 23);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelementStart(4, "td", 24);
    i0.ɵɵtext(5, "\n                      ");
    i0.ɵɵelementStart(6, "button", 25, 26);
    i0.ɵɵlistener("click", function AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_Template_button_click_6_listener() { const restoredCtx = i0.ɵɵrestoreView(_r52); const day_r43 = restoredCtx.$implicit; const ctx_r51 = i0.ɵɵnextContext(3); return ctx_r51.onDayClick(day_r43.date); })("keydown.arrowLeft", function AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_Template_button_keydown_arrowLeft_6_listener($event) { i0.ɵɵrestoreView(_r52); const _r47 = i0.ɵɵreference(7); const ctx_r53 = i0.ɵɵnextContext(3); return ctx_r53.onDayFocusChange($event, _r47, "l"); })("keydown.arrowUp", function AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_Template_button_keydown_arrowUp_6_listener($event) { i0.ɵɵrestoreView(_r52); const _r47 = i0.ɵɵreference(7); const ctx_r54 = i0.ɵɵnextContext(3); return ctx_r54.onDayFocusChange($event, _r47, "t"); })("keydown.arrowRight", function AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_Template_button_keydown_arrowRight_6_listener($event) { i0.ɵɵrestoreView(_r52); const _r47 = i0.ɵɵreference(7); const ctx_r55 = i0.ɵɵnextContext(3); return ctx_r55.onDayFocusChange($event, _r47, "r"); })("keydown.arrowDown", function AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_Template_button_keydown_arrowDown_6_listener($event) { i0.ɵɵrestoreView(_r52); const _r47 = i0.ɵɵreference(7); const ctx_r56 = i0.ɵɵnextContext(3); return ctx_r56.onDayFocusChange($event, _r47, "b"); });
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n                  ");
    i0.ɵɵtemplate(11, AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_td_11_Template, 1, 4, "td", 23);
    i0.ɵɵtext(12, "\n              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const day_r43 = ctx.$implicit;
    const first_r44 = ctx.first;
    const last_r45 = ctx.last;
    const ctx_r42 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", first_r44);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("range", day_r43.isInRange && !(day_r43.isRangeFrom && day_r43.isRangeTo))("range-from", ctx_r42.isRtl ? day_r43.isRangeTo && !day_r43.isRangeFrom : day_r43.isRangeFrom && !day_r43.isRangeTo)("range-to", ctx_r42.isRtl ? day_r43.isRangeFrom && !day_r43.isRangeTo : day_r43.isRangeTo && !day_r43.isRangeFrom)("other-month", day_r43.isOtherMonth);
    i0.ɵɵattribute("aria-label", day_r43.date.format("LL"))("aria-disabled", day_r43.isDisabled || day_r43.isOtherMonth)("aria-readonly", day_r43.isReadonly)("aria-hidden", day_r43.isDisabled || day_r43.isOtherMonth)("aria-selected", day_r43.isSelected);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("active", day_r43.isSelected)("today", day_r43.isToday)("range-edge", day_r43.isRangeFrom || day_r43.isRangeTo)("disabled", day_r43.isDisabled || day_r43.isOtherMonth)("readonly", day_r43.isReadonly);
    i0.ɵɵproperty("disabled", day_r43.isDisabled || day_r43.isOtherMonth);
    i0.ɵɵattribute("data-testid", ctx_r42.testID + "_day_" + day_r43.date.date());
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(day_r43.date.date());
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", last_r45);
} }
function AdaptDatetime2CalendarComponent_table_3_tr_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "tr");
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵtemplate(2, AdaptDatetime2CalendarComponent_table_3_tr_19_ng_container_2_Template, 13, 28, "ng-container", 17);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const week_r41 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", week_r41);
} }
function AdaptDatetime2CalendarComponent_table_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "table", 14, 15);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵelementStart(3, "thead", 16);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "tr");
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵtemplate(7, AdaptDatetime2CalendarComponent_table_3_ng_container_7_Template, 9, 3, "ng-container", 17);
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵelementStart(11, "tbody", null, 18);
    i0.ɵɵtext(13, "\n          ");
    i0.ɵɵelementStart(14, "tr", 16);
    i0.ɵɵtext(15, "\n              ");
    i0.ɵɵelement(16, "td", 19);
    i0.ɵɵtext(17, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n          ");
    i0.ɵɵtemplate(19, AdaptDatetime2CalendarComponent_table_3_tr_19_Template, 4, 1, "tr", 17);
    i0.ɵɵtext(20, "\n          ");
    i0.ɵɵelementStart(21, "tr", 16);
    i0.ɵɵtext(22, "\n              ");
    i0.ɵɵelement(23, "td", 19);
    i0.ɵɵtext(24, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(26, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(7);
    i0.ɵɵproperty("ngForOf", ctx_r1.calendar[0]);
    i0.ɵɵadvance(12);
    i0.ɵɵproperty("ngForOf", ctx_r1.calendar);
} }
function AdaptDatetime2CalendarComponent_adapt_datetime2_year_picker_5_Template(rf, ctx) { if (rf & 1) {
    const _r58 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-datetime2-year-picker", 27);
    i0.ɵɵlistener("yearSelect", function AdaptDatetime2CalendarComponent_adapt_datetime2_year_picker_5_Template_adapt_datetime2_year_picker_yearSelect_0_listener($event) { i0.ɵɵrestoreView(_r58); const ctx_r57 = i0.ɵɵnextContext(); return ctx_r57.yearSelect($event); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("initialDate", ctx_r2.initialDate)("yearsPage", ctx_r2.yearsPage)("activeDate", ctx_r2.activeDate)("animationsSet", ctx_r2._animationsSet)("calendarPlayers", ctx_r2._calendarPlayers);
} }
const _c2$e = ["dndArea"];
const _c3$a = ["clockFaceContainerRef"];
function AdaptDatetime2ClockComponent_ng_container_13_span_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 2);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("active", ctx_r5._activeFace === 2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r5.texts.ssBtn);
} }
function AdaptDatetime2ClockComponent_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelement(2, "span", 3);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵtemplate(4, AdaptDatetime2ClockComponent_ng_container_13_span_4_Template, 2, 3, "span", 11);
    i0.ɵɵtext(5, "\n              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r0.seconds);
} }
function AdaptDatetime2ClockComponent_button_16_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 12);
    i0.ɵɵlistener("click", function AdaptDatetime2ClockComponent_button_16_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.changeMeridiem(); });
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵelementStart(2, "span", 2);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n              ");
    i0.ɵɵelement(5, "span", 3);
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵelementStart(7, "span", 2);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵattribute("data-testid", ctx_r1.testID + "_ampm");
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("active", !ctx_r1._isPM);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.texts.amBtn);
    i0.ɵɵadvance(4);
    i0.ɵɵclassProp("active", ctx_r1._isPM);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.texts.pmBtn);
} }
function AdaptDatetime2ClockComponent_div_25_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1, "\n                      ");
    i0.ɵɵelementStart(2, "div", 16);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n                      ");
    i0.ɵɵelement(5, "div", 17);
    i0.ɵɵtext(6, "\n                  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const label_r10 = ctx.$implicit;
    const index_r11 = ctx.index;
    const ticksSet_r8 = i0.ɵɵnextContext().$implicit;
    const ctx_r9 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("transform", "rotate(" + index_r11 / ticksSet_r8.length * 360 + "deg)");
    i0.ɵɵclassProp("a3t-clock--tick_active", label_r10.value === ctx_r9.uiFace.active)("readonly", ctx_r9.readonly);
    i0.ɵɵattribute("data-testid", ctx_r9.testID + "_tick_" + index_r11 / ticksSet_r8.length * 360);
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("transform", "rotate(" + -index_r11 / ticksSet_r8.length * 360 + "deg)");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                          ", label_r10.uiValue, "\n                      ");
} }
function AdaptDatetime2ClockComponent_div_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 13);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵtemplate(2, AdaptDatetime2ClockComponent_div_25_div_2_Template, 7, 10, "div", 14);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ticksSet_r8 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ticksSet_r8);
} }
const _c4$7 = ["hoursField"];
function AdaptDatetime2PickerComponent_div_3_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 8);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelement(2, "adapt-icon", 9);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelementStart(4, "button", 10);
    i0.ɵɵlistener("click", function AdaptDatetime2PickerComponent_div_3_div_2_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(2); return ctx_r6.timeMode = false; });
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@heightAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "calendar");
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("data-testid", ctx_r3.testID + "_dateSummary")("aria-label", ctx_r3.dateSummary);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r3.dateSummary);
} }
function AdaptDatetime2PickerComponent_div_3_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 11);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelementStart(2, "button", 10);
    i0.ɵɵlistener("click", function AdaptDatetime2PickerComponent_div_3_div_4_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(2); return ctx_r8.monthMode = false; });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@heightAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("data-testid", ctx_r4.testID + "_yearSummary")("aria-label", ctx_r4.yearSummary);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r4.yearSummary);
} }
function AdaptDatetime2PickerComponent_div_3_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 12);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelementStart(2, "adapt-datetime2-calendar", 13);
    i0.ɵɵlistener("daySelect", function AdaptDatetime2PickerComponent_div_3_div_6_Template_adapt_datetime2_calendar_daySelect_2_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(2); return ctx_r10.selectDate($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@heightAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("expandedControlsStyle", !ctx_r5.timePicker && !ctx_r5.preventExpandedDateControls)("initialDate", ctx_r5.initialValue)("activeDate", ctx_r5.activeDate)("monthAndYearOnly", ctx_r5.monthAndYearOnly)("range", ctx_r5.dateRange)("filter", ctx_r5.dateFilter)("disabled", ctx_r5.disabled)("readonly", ctx_r5.readonly)("testID", ctx_r5.testID);
} }
function AdaptDatetime2PickerComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 4);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵtemplate(2, AdaptDatetime2PickerComponent_div_3_div_2_Template, 7, 6, "div", 5);
    i0.ɵɵtext(3, "\n\n              ");
    i0.ɵɵtemplate(4, AdaptDatetime2PickerComponent_div_3_div_4_Template, 5, 4, "div", 6);
    i0.ɵɵtext(5, "\n\n              ");
    i0.ɵɵtemplate(6, AdaptDatetime2PickerComponent_div_3_div_6_Template, 4, 10, "div", 7);
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.timeMode && !ctx_r0.timeOnly && !ctx_r0.hideDatePickerSummary);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.monthMode && ctx_r0.monthAndYearOnly && !ctx_r0.hideDatePickerSummary);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r0.timeMode && !ctx_r0.monthAndYearOnly || !ctx_r0.monthMode && ctx_r0.monthAndYearOnly);
} }
function AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    const _r20 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementStart(2, "input", 21);
    i0.ɵɵlistener("focus", function AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_7_Template_input_focus_2_listener() { i0.ɵɵrestoreView(_r20); const ctx_r19 = i0.ɵɵnextContext(3); ctx_r19.activeFace = ctx_r19.activeFaceVariants.Seconds; return ctx_r19.clockFaceChange.emit(ctx_r19.activeFaceVariants.Seconds); })("input", function AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_7_Template_input_input_2_listener($event) { i0.ɵɵrestoreView(_r20); const ctx_r21 = i0.ɵɵnextContext(3); return ctx_r21.timeUnitInput($event, "s"); })("keydown", function AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_7_Template_input_keydown_2_listener($event) { i0.ɵɵrestoreView(_r20); const ctx_r22 = i0.ɵɵnextContext(3); return ctx_r22.timeUnitKeydown($event, "s"); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n                              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                                  ", ctx_r17.defaultTexts.timeSeparator, "\n                                  ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("value", ctx_r17.timeSummary.ss);
    i0.ɵɵattribute("aria-valuenow", ctx_r17.timeSummary.ss)("aria-label", ctx_r17.defaultTexts.seconds);
} }
function AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    const _r24 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                                  ");
    i0.ɵɵelementStart(2, "input", 23);
    i0.ɵɵlistener("click", function AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_9_Template_input_click_2_listener() { i0.ɵɵrestoreView(_r24); const ctx_r23 = i0.ɵɵnextContext(3); return ctx_r23.changeMeridiem(); })("keydown.arrowUp", function AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_9_Template_input_keydown_arrowUp_2_listener($event) { i0.ɵɵrestoreView(_r24); const ctx_r25 = i0.ɵɵnextContext(3); $event.preventDefault(); return ctx_r25.changeMeridiem(); })("keydown.arrowDown", function AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_9_Template_input_keydown_arrowDown_2_listener($event) { i0.ɵɵrestoreView(_r24); const ctx_r26 = i0.ɵɵnextContext(3); $event.preventDefault(); return ctx_r26.changeMeridiem(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n                              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("value", ctx_r18.timeSummary.a);
    i0.ɵɵattribute("aria-valuenow", ctx_r18.timeSummary.a)("aria-label", ctx_r18.defaultTexts.meridiem);
} }
function AdaptDatetime2PickerComponent_div_5_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    const _r28 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                              ");
    i0.ɵɵelementStart(2, "input", 21, 22);
    i0.ɵɵlistener("focus", function AdaptDatetime2PickerComponent_div_5_ng_container_10_Template_input_focus_2_listener() { i0.ɵɵrestoreView(_r28); const ctx_r27 = i0.ɵɵnextContext(2); ctx_r27.activeFace = ctx_r27.activeFaceVariants.Hours; return ctx_r27.clockFaceChange.emit(ctx_r27.activeFaceVariants.Hours); })("input", function AdaptDatetime2PickerComponent_div_5_ng_container_10_Template_input_input_2_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r29 = i0.ɵɵnextContext(2); return ctx_r29.timeUnitInput($event, "h"); })("keydown", function AdaptDatetime2PickerComponent_div_5_ng_container_10_Template_input_keydown_2_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r30 = i0.ɵɵnextContext(2); return ctx_r30.timeUnitKeydown($event, "h"); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4);
    i0.ɵɵelementStart(5, "input", 21);
    i0.ɵɵlistener("focus", function AdaptDatetime2PickerComponent_div_5_ng_container_10_Template_input_focus_5_listener() { i0.ɵɵrestoreView(_r28); const ctx_r31 = i0.ɵɵnextContext(2); ctx_r31.activeFace = ctx_r31.activeFaceVariants.Minutes; return ctx_r31.clockFaceChange.emit(ctx_r31.activeFaceVariants.Minutes); })("input", function AdaptDatetime2PickerComponent_div_5_ng_container_10_Template_input_input_5_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r32 = i0.ɵɵnextContext(2); return ctx_r32.timeUnitInput($event, "m"); })("keydown", function AdaptDatetime2PickerComponent_div_5_ng_container_10_Template_input_keydown_5_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r33 = i0.ɵɵnextContext(2); return ctx_r33.timeUnitKeydown($event, "m"); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n\n                              ");
    i0.ɵɵtemplate(7, AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_7_Template, 4, 4, "ng-container", 18);
    i0.ɵɵtext(8, "\n\n                              ");
    i0.ɵɵtemplate(9, AdaptDatetime2PickerComponent_div_5_ng_container_10_ng_container_9_Template, 4, 3, "ng-container", 18);
    i0.ɵɵtext(10, "\n                          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("value", ctx_r12.timeSummary.hh);
    i0.ɵɵattribute("aria-valuenow", ctx_r12.timeSummary.hh)("aria-label", ctx_r12.defaultTexts.hours);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n                              ", ctx_r12.defaultTexts.timeSeparator, "\n                              ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("value", ctx_r12.timeSummary.mm);
    i0.ɵɵattribute("aria-valuenow", ctx_r12.timeSummary.mm)("aria-label", ctx_r12.defaultTexts.minutes);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r12.timeSeconds);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r12.hasMeridiem);
} }
function AdaptDatetime2PickerComponent_div_5_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    const _r35 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                              ");
    i0.ɵɵelementStart(2, "span", 24);
    i0.ɵɵlistener("focus", function AdaptDatetime2PickerComponent_div_5_ng_container_12_Template_span_focus_2_listener() { i0.ɵɵrestoreView(_r35); const ctx_r34 = i0.ɵɵnextContext(2); return ctx_r34.setCurrentDate(); });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n                          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r13.emptyTimeHeading);
} }
function AdaptDatetime2PickerComponent_div_5_button_16_Template(rf, ctx) { if (rf & 1) {
    const _r37 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 25);
    i0.ɵɵlistener("click", function AdaptDatetime2PickerComponent_div_5_button_16_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r37); const ctx_r36 = i0.ɵɵnextContext(2); return ctx_r36.timeMode = !ctx_r36.timeMode; });
    i0.ɵɵtext(1, "\n                      ");
    i0.ɵɵelement(2, "adapt-icon", 26);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("rotation-180", !ctx_r14.timeMode);
    i0.ɵɵattribute("data-testid", ctx_r14.testID + "_timeMode");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_down");
} }
function AdaptDatetime2PickerComponent_div_5_div_19_Template(rf, ctx) { if (rf & 1) {
    const _r39 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 27);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelementStart(2, "adapt-datetime2-clock", 28);
    i0.ɵɵlistener("timeSelect", function AdaptDatetime2PickerComponent_div_5_div_19_Template_adapt_datetime2_clock_timeSelect_2_listener($event) { i0.ɵɵrestoreView(_r39); const ctx_r38 = i0.ɵɵnextContext(2); return ctx_r38.selectTime($event); })("clockFaceChange", function AdaptDatetime2PickerComponent_div_5_div_19_Template_adapt_datetime2_clock_clockFaceChange_2_listener($event) { i0.ɵɵrestoreView(_r39); const ctx_r40 = i0.ɵɵnextContext(2); return ctx_r40.clockFaceChange.emit($event); });
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@heightAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("activeTime", ctx_r15.clockState)("activeFace", ctx_r15.activeFace)("seconds", ctx_r15.timeSeconds)("hasMeridiem", ctx_r15.hasMeridiem)("disabled", ctx_r15.disabled)("readonly", ctx_r15.readonly)("texts", ctx_r15.clockHeadings)("testID", ctx_r15.testID);
} }
function AdaptDatetime2PickerComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 14);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵelementStart(2, "div", 15);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelementStart(4, "div", 16);
    i0.ɵɵtext(5, "\n                      ");
    i0.ɵɵelement(6, "adapt-icon", 9);
    i0.ɵɵtext(7, "\n\n                      ");
    i0.ɵɵelementStart(8, "div", 17);
    i0.ɵɵtext(9, "\n                          ");
    i0.ɵɵtemplate(10, AdaptDatetime2PickerComponent_div_5_ng_container_10_Template, 11, 9, "ng-container", 18);
    i0.ɵɵtext(11, "\n\n                          ");
    i0.ɵɵtemplate(12, AdaptDatetime2PickerComponent_div_5_ng_container_12_Template, 5, 1, "ng-container", 18);
    i0.ɵɵtext(13, "\n\n                      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n\n                  ");
    i0.ɵɵtemplate(16, AdaptDatetime2PickerComponent_div_5_button_16_Template, 4, 5, "button", 19);
    i0.ɵɵtext(17, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n              ");
    i0.ɵɵtemplate(19, AdaptDatetime2PickerComponent_div_5_div_19_Template, 5, 9, "div", 20);
    i0.ɵɵtext(20, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("a3t-datetime--time-picker-summary_active", ctx_r1.timeMode);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "clock_o");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r1.timeSummary);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r1.timeSummary);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", !ctx_r1.timeOnly);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r1.timeMode);
} }
function AdaptDatetime2PickerComponent_div_7_div_19_Template(rf, ctx) { if (rf & 1) {
    const _r43 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 33);
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelementStart(2, "adapt-datetime2-month-picker", 34);
    i0.ɵɵlistener("selectMonth", function AdaptDatetime2PickerComponent_div_7_div_19_Template_adapt_datetime2_month_picker_selectMonth_2_listener($event) { i0.ɵɵrestoreView(_r43); const ctx_r42 = i0.ɵɵnextContext(2); return ctx_r42.selectMonth($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r41 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@heightAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("initialDate", ctx_r41.initialValue)("activeDate", ctx_r41.activeDate);
} }
function AdaptDatetime2PickerComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    const _r45 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 29);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵelementStart(2, "div", 15);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelementStart(4, "div", 16);
    i0.ɵɵtext(5, "\n                      ");
    i0.ɵɵelementStart(6, "div", 17);
    i0.ɵɵtext(7, "\n              ");
    i0.ɵɵelementStart(8, "span", 30);
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n                      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n\n                  ");
    i0.ɵɵelementStart(13, "button", 25);
    i0.ɵɵlistener("click", function AdaptDatetime2PickerComponent_div_7_Template_button_click_13_listener() { i0.ɵɵrestoreView(_r45); const ctx_r44 = i0.ɵɵnextContext(); return ctx_r44.monthMode = !ctx_r44.monthMode; });
    i0.ɵɵtext(14, "\n                      ");
    i0.ɵɵelement(15, "adapt-icon", 31);
    i0.ɵɵtext(16, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n              ");
    i0.ɵɵtemplate(19, AdaptDatetime2PickerComponent_div_7_div_19_Template, 4, 3, "div", 32);
    i0.ɵɵtext(20, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("a3t-datetime--time-picker-summary_active", ctx_r2.monthMode);
    i0.ɵɵadvance(6);
    i0.ɵɵattribute("aria-label", ctx_r2.defaultTexts.month);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r2.monthSummary, "\n              ");
    i0.ɵɵadvance(4);
    i0.ɵɵclassProp("rotation-180", !ctx_r2.monthMode);
    i0.ɵɵattribute("data-testid", ctx_r2.testID + "_monthMode");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "angle_down");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r2.monthMode);
} }
class AdaptDatetime2CalendarComponent {
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    constructor(_animationBuilder, _dir, _dt, _dtr, _changeDetectorRef, ts) {
        this._animationBuilder = _animationBuilder;
        this._dir = _dir;
        this._dt = _dt;
        this._dtr = _dtr;
        this._changeDetectorRef = _changeDetectorRef;
        this.ts = ts;
        this.animationDirectionForward = true;
        this.isRtl = false;
        this.yearsPage = 0;
        this.defaultTexts = {};
        this.calendarUIActions = {
            prevYear: () => {
                if (!this.monthAndYearOnly) {
                    this.animationDirectionForward = false;
                    this._initialDate.subtract(1, 'year');
                    this._drawCalendar();
                }
                else {
                    this.yearsPage--;
                }
            },
            nextYear: () => {
                if (!this.monthAndYearOnly) {
                    this.animationDirectionForward = true;
                    this._initialDate.add(1, 'year');
                    this._drawCalendar();
                }
                else {
                    this.yearsPage++;
                }
            },
            prevMonth: () => {
                this.animationDirectionForward = false;
                this._initialDate.subtract(1, 'month');
                this._drawCalendar();
            },
            nextMonth: () => {
                this.animationDirectionForward = true;
                this._initialDate.add(1, 'month');
                this._drawCalendar();
            },
        };
        this.monthAndYearOnly = false;
        // Outputs
        this.daySelect = new EventEmitter();
        this._animationsSet = {
            prevOut: [
                style({
                    transform: 'translate(0px, 0px)',
                    opacity: 1
                }),
                animate('100ms', style({
                    transform: 'translate(10px, 0px)',
                    opacity: 0
                }))
            ],
            prevIn: [
                style({
                    transform: 'translate(-10px, 0px)',
                    opacity: 0
                }),
                animate('100ms', style({
                    transform: 'translate(0px, 0px)',
                    opacity: 1
                }))
            ],
            nextOut: [
                style({
                    transform: 'translate(0px, 0px)',
                    opacity: 1
                }),
                animate('100ms', style({
                    transform: 'translate(-10px, 0px)',
                    opacity: 0
                }))
            ],
            nextIn: [
                style({
                    transform: 'translate(10px, 0px)',
                    opacity: 0
                }),
                animate('100ms', style({
                    transform: 'translate(0px, 0px)',
                    opacity: 1
                }))
            ]
        };
        this._calendarPlayers = {
            nextOut: null,
            nextIn: null,
            prevOut: null,
            prevIn: null
        };
        this._animationReady = false;
        this._initialDate = moment();
        this._activeDate = null;
        this._range = [null, null];
        this._hideControls = false;
        this._expandedControlsStyle = false;
        this._initCalendar();
        this._drawCalendar();
        if (_dt || _dtr) {
            this._formControl = (_dt || _dtr).control.control;
        }
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    set initialDate(v) {
        if (v && v.isValid()) {
            this._initialDate = v.clone();
            this._drawCalendar();
        }
    }
    get initialDate() {
        return this._initialDate;
    }
    set activeDate(v) {
        if (v !== undefined) {
            if (v && v.isValid()) {
                this._activeDate = v.clone();
                if (this._activeDate.clone().startOf('month').isSame(this._initialDate.clone().startOf('month'))) {
                    this._patchCalendar();
                }
                else {
                    this._initialDate = v.clone();
                    this._drawCalendar();
                }
            }
            else {
                this._activeDate = null;
                this._patchCalendar();
            }
        }
    }
    get activeDate() {
        return this._activeDate;
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    set filter(v) {
        if (v !== undefined) {
            this._filter = v ? v : null;
            this._patchCalendar();
        }
    }
    set range(v) {
        if (v) {
            this._range[0] = v[0] && v[0].isValid() ? v[0].clone() : null;
            this._range[1] = v[1] && v[1].isValid() ? v[1].clone() : null;
            this._patchCalendar();
        }
    }
    set disabled(v) {
        if (v !== undefined) {
            this._disabled = v;
            this._patchCalendar();
        }
    }
    set readonly(v) {
        if (v !== undefined) {
            this._readonly = v;
            this._patchCalendar();
        }
    }
    set hideControls(v) {
        if (v !== undefined) {
            this._hideControls = v;
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    set expandedControlsStyle(v) {
        if (v !== undefined) {
            this._expandedControlsStyle = v;
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    get calendarUIState() {
        return {
            date: this._initialDate,
            disabled: this._disabled,
            readonly: this._readonly,
            hideControls: this._hideControls,
            expanded: this._expandedControlsStyle
        };
    }
    // Inputs
    set state(config) {
        if (!config) {
            return;
        }
        let needPatch = false;
        let needRedraw = false;
        if (config.initialDate && config.initialDate.isValid()) {
            this._initialDate = config.initialDate.clone();
            needRedraw = true;
        }
        if (config.activeDate !== undefined) {
            if (config.activeDate && config.activeDate.isValid()) {
                this._activeDate = config.activeDate.clone();
                if (this._activeDate.clone().startOf('month').isSame(this._initialDate.clone().startOf('month'))) {
                    needPatch = true;
                }
                else {
                    this._initialDate = config.activeDate.clone();
                    needRedraw = true;
                }
            }
            else {
                this._activeDate = null;
                needPatch = true;
            }
        }
        if (config.filter !== undefined) {
            this._filter = config.filter ? config.filter : null;
            needPatch = true;
        }
        if (config.range) {
            this._range[0] = config.range[0] && config.range[0].isValid() ? config.range[0].clone() : null;
            this._range[1] = config.range[1] && config.range[1].isValid() ? config.range[1].clone() : null;
            needPatch = true;
        }
        if (config.disabled !== undefined) {
            this._disabled = config.disabled;
            needPatch = true;
        }
        if (config.readonly !== undefined) {
            this._readonly = config.readonly;
            needPatch = true;
        }
        if (config.hideControls !== undefined) {
            this._hideControls = config.hideControls;
        }
        if (config.expandedControlsStyle !== undefined) {
            this._expandedControlsStyle = config.expandedControlsStyle;
        }
        // Update
        if (needPatch) {
            this._patchCalendar();
        }
        if (needRedraw) {
            this._drawCalendar();
        }
    }
    ngOnInit() {
        this.isRtl = this._dir.value === 'rtl';
    }
    ngAfterViewInit() {
        if (!this.monthAndYearOnly) {
            this._calendarPlayers.prevOut = this._animationBuilder.build(this._animationsSet.prevOut)
                .create(this.calendarContainerRef.nativeElement);
            this._calendarPlayers.prevIn = this._animationBuilder.build(this._animationsSet.prevIn)
                .create(this.calendarContainerRef.nativeElement);
            this._calendarPlayers.nextOut = this._animationBuilder.build(this._animationsSet.nextOut)
                .create(this.calendarContainerRef.nativeElement);
            this._calendarPlayers.nextIn = this._animationBuilder.build(this._animationsSet.nextIn)
                .create(this.calendarContainerRef.nativeElement);
        }
        this._animationReady = true;
    }
    setDefaultTexts(translation) {
        this.defaultTexts.emptyYear = translation['adapt.datetime.emptyYear'];
        this.defaultTexts.emptyMonth = translation['adapt.datetime.emptyMonth'];
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Private methods
    /**
     * Init days table
     */
    // UI Methods
    /**
     * Calendar day click handler
     */
    onDayClick(date) {
        this.daySelect.emit(date.clone());
    }
    yearSelect(date) {
        this.daySelect.emit(date.clone());
        this.yearsPage = 0;
    }
    /**
     * Update days table with month change
     */
    /**
     * Keyboard navigation for days table
     */
    onDayFocusChange(event, element, direction = 'r') {
        event.preventDefault();
        if (!this._calendarDOM) {
            this._calendarDOM = Array.prototype.slice.call(this.daysTable.nativeElement.querySelectorAll('button'));
        }
        const elIndex = this._calendarDOM.indexOf(element);
        let newIndex;
        switch (direction) {
            case 'l':
            case 't': {
                newIndex = elIndex - (direction === 'l' ? 1 : 7);
                while ((newIndex >= 0) && this._calendarDOM[newIndex] && this._calendarDOM[newIndex].disabled) {
                    newIndex--;
                }
                if (newIndex >= 0) {
                    this._calendarDOM[newIndex].focus();
                }
                break;
            }
            case 'r':
            case 'b': {
                newIndex = elIndex + (direction === 'r' ? 1 : 7);
                while (this._calendarDOM[newIndex] && this._calendarDOM[newIndex].disabled) {
                    newIndex++;
                }
                if (newIndex < this._calendarDOM.length) {
                    this._calendarDOM[newIndex].focus();
                }
                break;
            }
        }
    }
    /**
     * Update days table without month change
     */
    _initCalendar() {
        this.calendar =
            Array(6)
                .fill(0)
                .map(() => Array(7)
                .fill(0)
                .map(() => new Calendar2Day()));
    }
    _drawCalendar() {
        const startDay = this._initialDate.clone().startOf('month').startOf('week');
        const tempDate = startDay.clone().subtract(1, 'day');
        this._animateCalendarChange((() => {
            this.calendar.forEach((week, weekIndex) => {
                week.forEach((day, dayIndex) => {
                    this.calendar[weekIndex][dayIndex].date = tempDate.add(1, 'day').clone();
                });
            });
            this._patchCalendar();
        }).bind(this));
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    _patchCalendar() {
        this.calendar.forEach((week) => {
            week.forEach((day) => {
                day.isSelected = this._activeDate ?
                    this._activeDate.clone().startOf('day').isSame(day.date.startOf('day')) : false;
                day.isToday = moment().startOf('day').isSame(day.date.startOf('day'));
                day.isOtherMonth = day.date.month() !== this._initialDate.month();
                day.isDisabled = this._disabled ||
                    (this._filter ? !this._filter(day.date, this._formControl) : false);
                day.isReadonly = this._readonly;
                day.isInRange = this._range[0] && this._range[1]
                    && day.date.isBetween(this._range[0], this._range[1], 'day', '[]');
                day.isRangeFrom = this._range[0] && this._range[0].startOf('day').isSame(day.date.startOf('day'));
                day.isRangeTo = this._range[1] && this._range[1].endOf('day').isSame(day.date.endOf('day'));
            });
        });
    }
    /**
     * Calendar change animation
     */
    _animateCalendarChange(changeValFn) {
        if (!this.monthAndYearOnly) {
            if (this._animationReady) {
                this._calendarPlayers.prevOut.reset();
                this._calendarPlayers.prevIn.reset();
                this._calendarPlayers.nextOut.reset();
                this._calendarPlayers.nextIn.reset();
                const _in = this.animationDirectionForward ? this._calendarPlayers.nextIn : this._calendarPlayers.prevIn;
                const _out = this.animationDirectionForward ? this._calendarPlayers.nextOut : this._calendarPlayers.prevOut;
                _out.onDone(() => {
                    changeValFn();
                    _in.play();
                    SafeCdr.detectChanges(this._changeDetectorRef);
                });
                _out.play();
            }
            else {
                changeValFn();
            }
        }
    }
}
AdaptDatetime2CalendarComponent.ɵfac = function AdaptDatetime2CalendarComponent_Factory(t) { return new (t || AdaptDatetime2CalendarComponent)(i0.ɵɵdirectiveInject(i1$1.AnimationBuilder), i0.ɵɵdirectiveInject(i2$1.Directionality), i0.ɵɵdirectiveInject(forwardRef(() => AdaptDatetime2Component), 8), i0.ɵɵdirectiveInject(forwardRef(() => AdaptDatetimeRange2Component), 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptTranslateService)); };
AdaptDatetime2CalendarComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetime2CalendarComponent, selectors: [["adapt-datetime2-calendar"]], viewQuery: function AdaptDatetime2CalendarComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$l, 5);
        i0.ɵɵviewQuery(_c1$g, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.daysTable = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.calendarContainerRef = _t.first);
    } }, hostVars: 2, hostBindings: function AdaptDatetime2CalendarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("a3t-calendar", true);
    } }, inputs: { testID: "testID", monthAndYearOnly: "monthAndYearOnly", initialDate: "initialDate", activeDate: "activeDate", filter: "filter", range: "range", disabled: "disabled", readonly: "readonly", hideControls: "hideControls", expandedControlsStyle: "expandedControlsStyle", state: "state" }, outputs: { daySelect: "daySelect" }, decls: 7, vars: 3, consts: [["class", "a3t-calendar--controls", 3, "a3t-calendar--controls_expanded", 4, "ngIf"], ["class", "a3t-calendar--table", 4, "ngIf"], [3, "initialDate", "yearsPage", "activeDate", "animationsSet", "calendarPlayers", "yearSelect", 4, "ngIf"], [1, "a3t-calendar--controls"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["pickYear", ""], ["pickMonth", ""], [1, "a3t-calendar--controls-line"], ["type", "button", "aria-hidden", "true", "tabindex", "-1", 1, "a3t-calendar--controls-btn", 3, "disabled", "click"], [3, "adaptRadarDisableEventSending", "name", 4, "ngIf"], ["tabindex", "0", "role", "spinbutton", 1, "a3t-calendar--controls-info", 3, "keydown.arrowUp", "keydown.arrowRight", "keydown.arrowDown", "keydown.arrowLeft"], [3, "adaptTextSlide", "slideForward"], [3, "adaptRadarDisableEventSending", "name"], ["class", "a3t-calendar--controls-line", 4, "ngIf"], [1, "a3t-calendar--table"], ["daysTable", ""], ["aria-hidden", "true"], [4, "ngFor", "ngForOf"], ["calendarContainerRef", ""], ["colspan", "9", 1, "a3t-calendar--table-space-cell"], ["class", "a3t-calendar--table-edge-cell", "aria-hidden", "true", 4, "ngIf"], [1, "a3t-calendar--table-week-name"], ["aria-hidden", "true", 1, "a3t-calendar--table-edge-cell"], ["class", "a3t-calendar--table-edge-cell", "aria-hidden", "true", 3, "range", "other-month", 4, "ngIf"], ["role", "gridcell", 1, "a3t-calendar--table-day"], ["type", "button", 3, "disabled", "click", "keydown.arrowLeft", "keydown.arrowUp", "keydown.arrowRight", "keydown.arrowDown"], ["dayEl", ""], [3, "initialDate", "yearsPage", "activeDate", "animationsSet", "calendarPlayers", "yearSelect"]], template: function AdaptDatetime2CalendarComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n      ");
        i0.ɵɵtemplate(1, AdaptDatetime2CalendarComponent_div_1_Template, 12, 8, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵtemplate(3, AdaptDatetime2CalendarComponent_table_3_Template, 27, 2, "table", 1);
        i0.ɵɵtext(4, "\n\n      ");
        i0.ɵɵtemplate(5, AdaptDatetime2CalendarComponent_adapt_datetime2_year_picker_5_Template, 2, 5, "adapt-datetime2-year-picker", 2);
        i0.ɵɵtext(6, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.calendarUIState.hideControls);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.monthAndYearOnly);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.monthAndYearOnly);
    } }, directives: [i3.NgIf, i1.AdaptTextSlideDirective, i1.AdaptIconComponent, i3.NgForOf, AdaptDatetime2YearPickerComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetime2CalendarComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime2-calendar',
                template: `
      <div class="a3t-calendar--controls"
           *ngIf="!calendarUIState.hideControls"
           [class.a3t-calendar--controls_expanded]="calendarUIState.expanded">
          <ng-container *ngIf="!calendarUIState.expanded; then pickMonth; else pickYear"></ng-container>
          <ng-container *ngIf="calendarUIState.expanded; then pickMonth; else pickYear"></ng-container>

          <ng-template #pickYear>
              <div class="a3t-calendar--controls-line"
                   [class.a3t-calendar--year-picker]="monthAndYearOnly"
                   attr.aria-label="{{defaultTexts.emptyYear}}"
              >
                  <button type="button"
                          class="a3t-calendar--controls-btn"
                          aria-hidden="true"
                          tabindex="-1"
                          [attr.data-testid]="testID + '_prevYear'"
                          [disabled]="calendarUIState.disabled"
                          [class.disabled]="calendarUIState.disabled"
                          [class.readonly]="calendarUIState.readonly"
                          (click)="$event.stopPropagation(); calendarUIActions.prevYear()">
                      <adapt-icon [adaptRadarDisableEventSending]="true" *ngIf="!isRtl" [name]="'angle_left'"></adapt-icon>
                      <adapt-icon [adaptRadarDisableEventSending]="true" *ngIf="isRtl" [name]="'angle_right'"></adapt-icon>
                  </button>
                  <div class="a3t-calendar--controls-info"
                       tabindex="0"
                       attr.aria-label="{{defaultTexts.emptyYear}}"
                       role="spinbutton"
                       [attr.aria-valuenow]="calendarUIState.date.format('YYYY')"
                       (keydown.arrowUp)="$event.preventDefault(); calendarUIActions.nextYear()"
                       (keydown.arrowRight)="$event.preventDefault(); calendarUIActions.nextYear()"
                       (keydown.arrowDown)="$event.preventDefault(); calendarUIActions.prevYear()"
                       (keydown.arrowLeft)="$event.preventDefault(); calendarUIActions.prevYear()">
                      <div [adaptTextSlide]="calendarUIState.date.format('YYYY')"
                           [slideForward]="animationDirectionForward"></div>
                  </div>
                  <button type="button"
                          class="a3t-calendar--controls-btn"
                          aria-hidden="true"
                          tabindex="-1"
                          [attr.data-testid]="testID + '_nextYear'"
                          [disabled]="calendarUIState.disabled"
                          [class.disabled]="calendarUIState.disabled"
                          [class.readonly]="calendarUIState.readonly"
                          (click)="$event.stopPropagation(); calendarUIActions.nextYear()">
                      <adapt-icon [adaptRadarDisableEventSending]="true" *ngIf="isRtl" [name]="'angle_left'"></adapt-icon>
                      <adapt-icon [adaptRadarDisableEventSending]="true" *ngIf="!isRtl" [name]="'angle_right'"></adapt-icon>
                  </button>
              </div>
          </ng-template>
          <ng-template #pickMonth>
              <div class="a3t-calendar--controls-line"
                   attr.aria-label="{{defaultTexts.emptyMonth}}"
                   *ngIf="!monthAndYearOnly">
                  <button type="button"
                          class="a3t-calendar--controls-btn"
                          aria-hidden="true"
                          tabindex="-1"
                          [attr.data-testid]="testID + '_prevMonth'"
                          [disabled]="calendarUIState.disabled"
                          [class.disabled]="calendarUIState.disabled"
                          [class.readonly]="calendarUIState.readonly"
                          (click)="$event.stopPropagation(); calendarUIActions.prevMonth()">
                      <adapt-icon [adaptRadarDisableEventSending]="true" *ngIf="!isRtl" [name]="'angle_left'"></adapt-icon>
                      <adapt-icon [adaptRadarDisableEventSending]="true" *ngIf="isRtl" [name]="'angle_right'"></adapt-icon>
                  </button>
                  <div class="a3t-calendar--controls-info"
                       tabindex="0"
                       attr.aria-label="{{defaultTexts.emptyMonth}}"
                       role="spinbutton"
                       [attr.aria-valuetext]="calendarUIState.date.format('MMMM')"
                       (keydown.arrowUp)="$event.preventDefault(); calendarUIActions.nextMonth()"
                       (keydown.arrowRight)="$event.preventDefault(); calendarUIActions.nextMonth()"
                       (keydown.arrowDown)="$event.preventDefault(); calendarUIActions.prevMonth()"
                       (keydown.arrowLeft)="$event.preventDefault(); calendarUIActions.prevMonth()">
                      <div [adaptTextSlide]="calendarUIState.date.format(calendarUIState.expanded ? 'MMMM' : 'MMM')"
                           [slideForward]="animationDirectionForward"></div>
                  </div>
                  <button type="button"
                          class="a3t-calendar--controls-btn"
                          aria-hidden="true"
                          tabindex="-1"
                          [attr.data-testid]="testID + '_nextMonth'"
                          [disabled]="calendarUIState.disabled"
                          [class.disabled]="calendarUIState.disabled"
                          [class.readonly]="calendarUIState.readonly"
                          (click)="$event.stopPropagation(); calendarUIActions.nextMonth()">
                      <adapt-icon [adaptRadarDisableEventSending]="true" *ngIf="isRtl" [name]="'angle_left'"></adapt-icon>
                      <adapt-icon [adaptRadarDisableEventSending]="true" *ngIf="!isRtl" [name]="'angle_right'"></adapt-icon>
                  </button>
              </div>
          </ng-template>
      </div>
      <table class="a3t-calendar--table" #daysTable *ngIf="!monthAndYearOnly">
          <thead aria-hidden="true">
          <tr>
              <ng-container *ngFor="let dayOfWeek of calendar[0]; let first = first; let last = last">
                  <th class="a3t-calendar--table-edge-cell" aria-hidden="true" *ngIf="first"></th>
                  <th class="a3t-calendar--table-week-name">
                      {{dayOfWeek.date.format('dd')}}
                  </th>
                  <th class="a3t-calendar--table-edge-cell" aria-hidden="true" *ngIf="last"></th>
              </ng-container>
          </tr>
          </thead>
          <tbody #calendarContainerRef>
          <tr aria-hidden="true">
              <td colspan="9" class="a3t-calendar--table-space-cell"></td>
          </tr>
          <tr *ngFor="let week of calendar">
              <ng-container *ngFor="let day of week; let first = first; let last = last">
                  <td class="a3t-calendar--table-edge-cell"
                      aria-hidden="true"
                      *ngIf="first"
                      [class.range]="day.isInRange && !day.isRangeFrom"
                      [class.other-month]="day.isOtherMonth"></td>
                  <td class="a3t-calendar--table-day"
                      role="gridcell"
                      [class.range]="day.isInRange && !(day.isRangeFrom && day.isRangeTo)"
                      [class.range-from]="isRtl ? (day.isRangeTo && !day.isRangeFrom) : (day.isRangeFrom && !day.isRangeTo)"
                      [class.range-to]="isRtl ? (day.isRangeFrom && !day.isRangeTo) : (day.isRangeTo && !day.isRangeFrom)"
                      [class.other-month]="day.isOtherMonth"
                      [attr.aria-label]="day.date.format('LL')"
                      [attr.aria-disabled]="day.isDisabled || day.isOtherMonth"
                      [attr.aria-readonly]="day.isReadonly"
                      [attr.aria-hidden]="day.isDisabled || day.isOtherMonth"
                      [attr.aria-selected]="day.isSelected">
                      <button type="button"
                              #dayEl
                              (click)="onDayClick(day.date)"
                              [class.active]="day.isSelected"
                              [class.today]="day.isToday"
                              [class.range-edge]="day.isRangeFrom || day.isRangeTo"
                              [class.disabled]="day.isDisabled || day.isOtherMonth"
                              [class.readonly]="day.isReadonly"
                              [disabled]="day.isDisabled || day.isOtherMonth"
                              [attr.data-testid]="testID + '_day_' + day.date.date()"
                              (keydown.arrowLeft)="onDayFocusChange($event, dayEl, 'l')"
                              (keydown.arrowUp)="onDayFocusChange($event, dayEl, 't')"
                              (keydown.arrowRight)="onDayFocusChange($event, dayEl, 'r')"
                              (keydown.arrowDown)="onDayFocusChange($event, dayEl, 'b')">{{day.date.date()}}</button>
                  </td>
                  <td class="a3t-calendar--table-edge-cell"
                      aria-hidden="true"
                      *ngIf="last"
                      [class.range]="day.isInRange && !day.isRangeTo"
                      [class.other-month]="day.isOtherMonth"></td>
              </ng-container>
          </tr>
          <tr aria-hidden="true">
              <td colspan="9" class="a3t-calendar--table-space-cell"></td>
          </tr>
          </tbody>
      </table>

      <adapt-datetime2-year-picker *ngIf="monthAndYearOnly"
                                   [initialDate]="initialDate"
                                   [yearsPage]="yearsPage"
                                   [activeDate]="activeDate"
                                   (yearSelect)="yearSelect($event)"
                                   [animationsSet]="_animationsSet"
                                   [calendarPlayers]="_calendarPlayers">
      </adapt-datetime2-year-picker>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.a3t-calendar]': 'true'
                }
            }]
    }], function () { return [{ type: i1$1.AnimationBuilder }, { type: i2$1.Directionality }, { type: AdaptDatetime2Component, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [forwardRef(() => AdaptDatetime2Component)]
            }] }, { type: AdaptDatetimeRange2Component, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [forwardRef(() => AdaptDatetimeRange2Component)]
            }] }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptTranslateService }]; }, { testID: [{
            type: Input
        }], monthAndYearOnly: [{
            type: Input
        }], daySelect: [{
            type: Output
        }], daysTable: [{
            type: ViewChild,
            args: ['daysTable']
        }], calendarContainerRef: [{
            type: ViewChild,
            args: ['calendarContainerRef']
        }], initialDate: [{
            type: Input
        }], activeDate: [{
            type: Input
        }], filter: [{
            type: Input
        }], range: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], hideControls: [{
            type: Input
        }], expandedControlsStyle: [{
            type: Input
        }], state: [{
            type: Input
        }] }); })();
class AdaptDatetime2ClockComponent {
    constructor(_renderer, _animationBuilder, ts) {
        this._renderer = _renderer;
        this._animationBuilder = _animationBuilder;
        this.ts = ts;
        this._isPM = false;
        this._activeFace = Clock2FaceUnit.Hours;
        this._hasMeridiem = false;
        this.defaultTexts = {};
        this.seconds = false;
        this.autoFaceSwitch = true;
        this.disabled = false;
        this.readonly = false;
        this.timeSelect = new EventEmitter();
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        this.clockFaceChange = new EventEmitter();
        // Private fields
        this._innerFaceDNDTolerance = .65;
        this._faceSize = 220;
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        this._hoursFaceTicks24 = [
            Array(12)
                .fill(0)
                .map((x, i) => {
                return {
                    value: i || 12,
                    uiValue: (i || 12).toString()
                };
            }),
            Array(12)
                .fill(0)
                .map((x, i) => {
                return {
                    value: i ? i + 12 : 0,
                    uiValue: (i ? i + 12 : 0).toString()
                };
            })
        ];
        this._hoursFaceTicks12 = [
            Array(12)
                .fill(0)
                .map((x, i) => {
                return {
                    value: i || 12,
                    uiValue: (i || 12).toString()
                };
            })
        ];
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Private view settings
        this._hoursFace = {
            ticks: this._hoursFaceTicks24
        };
        // UI Fields
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.uiFace = this._hoursFace;
        // Inputs
        this._minutesFace = {
            ticks: [
                Array(60)
                    .fill(0)
                    .map((x, i) => {
                    return {
                        value: i,
                        uiValue: (i % 5 ? '' : i).toString()
                    };
                })
            ]
        };
        this._secondsFace = {
            ticks: [
                Array(60)
                    .fill(0)
                    .map((x, i) => {
                    return {
                        value: i,
                        uiValue: (i % 5 ? '' : i).toString()
                    };
                })
            ]
        };
        this._animationReady = false;
        this._animationsSet = {
            out: [
                style({
                    transform: 'scale(1)',
                    opacity: 1
                }),
                animate('100ms', style({
                    transform: 'scale(1.1)',
                    opacity: 0
                }))
            ],
            in: [
                style({
                    transform: 'scale(.9)',
                    opacity: 0
                }),
                animate('100ms', style({
                    transform: 'scale(1)',
                    opacity: 1
                }))
            ]
        };
        this._animationPlayers = {
            out: null,
            in: null
        };
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Outputs
    set activeFace(nextFace) {
        if (nextFace === undefined) {
            return;
        }
        this.gotoNextFace(nextFace);
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    set hasMeridiem(nextMeridiem) {
        this._hasMeridiem = !!nextMeridiem;
        if (this._hasMeridiem) {
            this._hoursFace.ticks = this._hoursFaceTicks12;
        }
        else {
            this._hoursFace.ticks = this._hoursFaceTicks24;
        }
    }
    set activeTime(nextActiveTime) {
        if (!nextActiveTime) {
            return;
        }
        if (this._hasMeridiem) {
            this._isPM = nextActiveTime[0] >= 12;
            const isMidnight = nextActiveTime[0] === 12;
            this._hoursFace.active = (nextActiveTime[0] - (this._isPM && !isMidnight ? 12 : 0)) || 12;
        }
        else {
            this._hoursFace.active = nextActiveTime[0];
        }
        this._minutesFace.active = nextActiveTime[1];
        this._secondsFace.active = nextActiveTime[2];
    }
    get _model() {
        let hours = this._hoursFace.active || 0;
        if (this._hasMeridiem) {
            if (this._isPM) {
                hours += (hours === 12 ? 0 : 12);
            }
            else {
                hours = (hours === 12 ? 0 : hours);
            }
        }
        return [
            hours,
            this._minutesFace.active || 0,
            this._secondsFace.active || 0
        ];
    }
    ngOnInit() {
        this._initDragNDrop();
        this.texts = Object.assign(Object.assign({}, this.defaultTexts), this.texts);
    }
    ngAfterViewInit() {
        this._animationPlayers.out = this._animationBuilder.build(this._animationsSet.out)
            .create(this.clockFaceContainerRef.nativeElement);
        this._animationPlayers.in = this._animationBuilder.build(this._animationsSet.in)
            .create(this.clockFaceContainerRef.nativeElement);
        this._animationReady = true;
    }
    setDefaultTexts(translation) {
        this.defaultTexts.hhBtn = translation['adapt.datetime.hh'];
        this.defaultTexts.mmBtn = translation['adapt.datetime.mm'];
        this.defaultTexts.ssBtn = translation['adapt.datetime.ss'];
        this.defaultTexts.amBtn = translation['adapt.datetime.am'];
        this.defaultTexts.pmBtn = translation['adapt.datetime.pm'];
    }
    /**
     * Return current model state
     */
    ngOnDestroy() {
        this._dndSubscription.unsubscribe();
    }
    /**
     * Init drag and drop
     */
    /**
     * Change time meridiem
     */
    changeMeridiem() {
        this._isPM = !this._isPM;
        this.timeSelect.emit(this._model);
    }
    /**
     * Change time unit face
     */
    gotoNextFace(nextFace) {
        if (nextFace === this._activeFace) {
            return;
        }
        if (nextFace === undefined) {
            nextFace = (this._activeFace + 1) % 3;
        }
        this._animateClockFaceChange((() => {
            switch (nextFace) {
                case Clock2FaceUnit.Hours: {
                    this.uiFace = this._hoursFace;
                    this._activeFace = Clock2FaceUnit.Hours;
                    break;
                }
                case Clock2FaceUnit.Minutes: {
                    this.uiFace = this._minutesFace;
                    this._activeFace = Clock2FaceUnit.Minutes;
                    break;
                }
                case Clock2FaceUnit.Seconds: {
                    if (this.seconds) {
                        this.uiFace = this._secondsFace;
                        this._activeFace = Clock2FaceUnit.Seconds;
                    }
                    else {
                        this.uiFace = this._hoursFace;
                        this._activeFace = Clock2FaceUnit.Hours;
                    }
                    break;
                }
                default: {
                    this.uiFace = this._hoursFace;
                    this._activeFace = Clock2FaceUnit.Hours;
                    break;
                }
            }
            this.clockFaceChange.emit(this._activeFace);
        }).bind(this));
    }
    _initDragNDrop() {
        this._renderer.setStyle(this.dndArea.nativeElement, 'width', `${this._faceSize}px`);
        this._renderer.setStyle(this.dndArea.nativeElement, 'height', `${this._faceSize}px`);
        let centerX;
        let centerY;
        const dragStart = () => {
            const elRect = this.dndArea.nativeElement.getBoundingClientRect();
            centerX = elRect.left + elRect.width / 2;
            centerY = elRect.top + elRect.height / 2;
        };
        const dragEnd = () => {
            if (this.autoFaceSwitch) {
                if (!(this.seconds ? this._activeFace === Clock2FaceUnit.Seconds : this._activeFace === Clock2FaceUnit.Minutes)) {
                    this.gotoNextFace();
                }
            }
        };
        this._dndSubscription = GetDragNDrop(this.dndArea.nativeElement, null, null, dragStart, dragEnd)
            .pipe(map(moveCoords => {
            if (this.disabled || this.readonly) {
                return;
            }
            const angle = Math.round(GetAngle(centerX, centerY, moveCoords.x, moveCoords.y) * 100) / 100;
            const distance = Math.round(GetDistance(centerX, centerY, moveCoords.x, moveCoords.y) * 100) / 100;
            const face = (this.uiFace.ticks.length === 1) || (distance > this._faceSize / 2 * this._innerFaceDNDTolerance) ?
                this.uiFace.ticks[0] :
                this.uiFace.ticks[1];
            const ticksCount = face.length;
            this.uiFace.active = face[Math.round(angle * ticksCount / 360) % ticksCount].value;
            return face[Math.round(angle * ticksCount / 360) % ticksCount];
        }), distinctUntilChanged())
            .subscribe(() => {
            this.timeSelect.emit(this._model);
        });
    }
    _animateClockFaceChange(changeValFn) {
        if (this._animationReady) {
            this._animationPlayers.out.reset();
            this._animationPlayers.in.reset();
            this._animationPlayers.out.onDone(() => {
                changeValFn();
                this._animationPlayers.in.play();
            });
            this._animationPlayers.out.play();
        }
        else {
            changeValFn();
        }
    }
}
AdaptDatetime2ClockComponent.ɵfac = function AdaptDatetime2ClockComponent_Factory(t) { return new (t || AdaptDatetime2ClockComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1$1.AnimationBuilder), i0.ɵɵdirectiveInject(i1.AdaptTranslateService)); };
AdaptDatetime2ClockComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetime2ClockComponent, selectors: [["adapt-datetime2-clock"]], viewQuery: function AdaptDatetime2ClockComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c2$e, 7);
        i0.ɵɵviewQuery(_c3$a, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dndArea = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clockFaceContainerRef = _t.first);
    } }, hostVars: 5, hostBindings: function AdaptDatetime2ClockComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("aria-hidden", true);
        i0.ɵɵclassProp("a3t-clock", true)("a3t-clock_disabled", ctx.disabled);
    } }, inputs: { testID: "testID", seconds: "seconds", autoFaceSwitch: "autoFaceSwitch", disabled: "disabled", readonly: "readonly", texts: "texts", activeFace: "activeFace", hasMeridiem: "hasMeridiem", activeTime: "activeTime" }, outputs: { timeSelect: "timeSelect", clockFaceChange: "clockFaceChange" }, decls: 29, vars: 10, consts: [[1, "a3t-clock--controls"], ["type", "button", "tabindex", "-1", 1, "a3t-clock--control-btn", "m-end-2", 3, "click"], [1, "a3t-clock--control-item"], [1, "a3t-clock--control-separator"], [4, "ngIf"], ["type", "button", "class", "a3t-clock--control-btn", "tabindex", "-1", 3, "click", 4, "ngIf"], [1, "a3t-clock--faces"], ["dndArea", ""], [2, "width", "100%", "height", "100%"], ["clockFaceContainerRef", ""], ["class", "a3t-clock--face", 4, "ngFor", "ngForOf"], ["class", "a3t-clock--control-item", 3, "active", 4, "ngIf"], ["type", "button", "tabindex", "-1", 1, "a3t-clock--control-btn", 3, "click"], [1, "a3t-clock--face"], ["class", "a3t-clock--tick", 3, "a3t-clock--tick_active", "readonly", "transform", 4, "ngFor", "ngForOf"], [1, "a3t-clock--tick"], [1, "a3t-clock--tick-label"], [1, "a3t-clock--tick-arrow"]], template: function AdaptDatetime2ClockComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n      ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n          ");
        i0.ɵɵelementStart(3, "button", 1);
        i0.ɵɵlistener("click", function AdaptDatetime2ClockComponent_Template_button_click_3_listener() { return ctx.gotoNextFace(); });
        i0.ɵɵtext(4, "\n              ");
        i0.ɵɵelementStart(5, "span", 2);
        i0.ɵɵtext(6);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(7, "\n              ");
        i0.ɵɵelement(8, "span", 3);
        i0.ɵɵtext(9, "\n              ");
        i0.ɵɵelementStart(10, "span", 2);
        i0.ɵɵtext(11);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(12, "\n              ");
        i0.ɵɵtemplate(13, AdaptDatetime2ClockComponent_ng_container_13_Template, 6, 1, "ng-container", 4);
        i0.ɵɵtext(14, "\n          ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(15, "\n          ");
        i0.ɵɵtemplate(16, AdaptDatetime2ClockComponent_button_16_Template, 10, 7, "button", 5);
        i0.ɵɵtext(17, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n      ");
        i0.ɵɵelementStart(19, "div", 6, 7);
        i0.ɵɵtext(21, "\n          ");
        i0.ɵɵelementStart(22, "div", 8, 9);
        i0.ɵɵtext(24, "\n              ");
        i0.ɵɵtemplate(25, AdaptDatetime2ClockComponent_div_25_Template, 4, 1, "div", 10);
        i0.ɵɵtext(26, "\n          ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(27, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(28, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(3);
        i0.ɵɵattribute("data-testid", ctx.testID + "_hhmmss");
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("active", ctx._activeFace === 0);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.texts.hhBtn);
        i0.ɵɵadvance(4);
        i0.ɵɵclassProp("active", ctx._activeFace === 1);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.texts.mmBtn);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.seconds);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx._hasMeridiem);
        i0.ɵɵadvance(9);
        i0.ɵɵproperty("ngForOf", ctx.uiFace.ticks);
    } }, directives: [i3.NgIf, i3.NgForOf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetime2ClockComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime2-clock',
                template: `
      <div class="a3t-clock--controls">
          <button type="button"
                  class="a3t-clock--control-btn m-end-2"
                  [attr.data-testid]="testID + '_hhmmss'"
                  tabindex="-1" (click)="gotoNextFace()">
              <span class="a3t-clock--control-item" [class.active]="_activeFace === 0">{{texts.hhBtn}}</span>
              <span class="a3t-clock--control-separator"></span>
              <span class="a3t-clock--control-item" [class.active]="_activeFace === 1">{{texts.mmBtn}}</span>
              <ng-container *ngIf="seconds">
                  <span class="a3t-clock--control-separator"></span>
                  <span class="a3t-clock--control-item" [class.active]="_activeFace === 2" *ngIf="seconds">{{texts.ssBtn}}</span>
              </ng-container>
          </button>
          <button type="button"
                  class="a3t-clock--control-btn"
                  [attr.data-testid]="testID + '_ampm'"
                  tabindex="-1" (click)="changeMeridiem()" *ngIf="_hasMeridiem">
              <span class="a3t-clock--control-item" [class.active]="!_isPM">{{texts.amBtn}}</span>
              <span class="a3t-clock--control-separator"></span>
              <span class="a3t-clock--control-item" [class.active]="_isPM">{{texts.pmBtn}}</span>
          </button>
      </div>
      <div class="a3t-clock--faces" #dndArea>
          <div #clockFaceContainerRef style="width: 100%; height: 100%">
              <div class="a3t-clock--face" *ngFor="let ticksSet of uiFace.ticks">
                  <div class="a3t-clock--tick"
                       *ngFor="let label of ticksSet; let index = index"
                       [class.a3t-clock--tick_active]="label.value === uiFace.active"
                       [class.readonly]="readonly"
                       [attr.data-testid]="testID + '_tick_' + index / ticksSet.length * 360"
                       [style.transform]="'rotate(' + (index / ticksSet.length * 360) + 'deg)'">
                      <div class="a3t-clock--tick-label" [style.transform]="'rotate(' + (- index / ticksSet.length * 360) + 'deg)'">
                          {{label.uiValue}}
                      </div>
                      <div class="a3t-clock--tick-arrow"></div>
                  </div>
              </div>
          </div>
      </div>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.a3t-clock]': 'true',
                    '[class.a3t-clock_disabled]': 'disabled',
                    '[attr.aria-hidden]': 'true',
                }
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i1$1.AnimationBuilder }, { type: i1.AdaptTranslateService }]; }, { testID: [{
            type: Input
        }], seconds: [{
            type: Input
        }], autoFaceSwitch: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], texts: [{
            type: Input
        }], timeSelect: [{
            type: Output
        }], clockFaceChange: [{
            type: Output
        }], dndArea: [{
            type: ViewChild,
            args: ['dndArea', { static: true }]
        }], clockFaceContainerRef: [{
            type: ViewChild,
            args: ['clockFaceContainerRef', { static: true }]
        }], activeFace: [{
            type: Input
        }], hasMeridiem: [{
            type: Input
        }], activeTime: [{
            type: Input
        }] }); })();
class AdaptDatetime2PickerComponent {
    constructor(ts, _ngZone, _changeDetectorRef) {
        this.ts = ts;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this.monthMode = false;
        this.activeFaceVariants = Clock2FaceUnit;
        this.defaultTexts = {};
        this.dateFormat = 'LL';
        this.timeFormat = 'LT';
        this.timePicker = false;
        this.timeOnly = false;
        this.monthAndYearOnly = false;
        this.monthFirst = false;
        this.timeSeconds = false;
        this.activeFace = Clock2FaceUnit.Hours;
        this.hideDatePickerSummary = false;
        this.valueChange = new EventEmitter();
        this.timeModeChange = new EventEmitter();
        this.clockFaceChange = new EventEmitter();
        this._timeMode = false;
        this._model = {
            year: 0,
            month: 0,
            day: 0,
            hour: 0,
            minute: 0,
            second: 0
        };
        this._localeHasMeridiem = IsLocaleHasMeridiem(moment.locale());
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get timeMode() {
        return this.timePicker && this._timeMode || this.timeOnly;
    }
    set timeMode(v) {
        if (!this.timePicker) {
            return;
        }
        if (v !== undefined) {
            this._timeMode = !!v;
            this.timeModeChange.emit(!!v);
        }
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    set activeValue(v) {
        if (v && v.isValid()) {
            this._model.year = v.year();
            this._model.month = v.month();
            this._model.day = v.date();
            this._model.hour = v.hour();
            this._model.minute = v.minute();
            this._model.second = this.timeSeconds ? v.second() : 0;
            this.activeDate = v.clone();
        }
        else {
            this.activeDate = null;
        }
    }
    get clockState() {
        return [
            this._model.hour,
            this._model.minute,
            this._model.second,
        ];
    }
    get hasMeridiem() {
        let oddTime = false;
        if (this.timeFormat !== 'LT') {
            oddTime = !!this.timeFormat.match(/a/i);
        }
        else {
            oddTime = this._localeHasMeridiem;
        }
        return oddTime;
    }
    get dateSummary() {
        return this.activeDate && this.activeDate.isValid() ?
            this.activeDate.format(this.dateFormat) : (this.emptyDateHeading || this.defaultTexts.emptyDate);
    }
    get yearSummary() {
        return this.activeDate && this.activeDate.isValid() ?
            this.activeDate.format('YYYY') : (this.emptyDateHeading || this.defaultTexts.emptyYear);
    }
    get monthSummary() {
        return this.activeDate && this.activeDate.isValid() ?
            this.activeDate.format('MMMM') : this.emptyMonthHeading;
    }
    get timeSummary() {
        this.emptyTimeHeading = this.emptyTimeHeading || this.defaultTexts.emptyTime;
        return this.activeDate && this.activeDate.isValid() ? {
            hh: ('0' + this.activeDate.format(this.hasMeridiem ? 'h' : 'H')).substr(-2),
            mm: this.activeDate.format('mm'),
            ss: this.activeDate.format('ss'),
            a: this.activeDate.format('A')
        } : false;
    }
    ngOnInit() {
        const initVal = this.activeDate ? this.activeDate :
            this.initialValue && this.initialValue.isValid() ? this.initialValue : moment();
        if (!this.testID) {
            this.testID = `dt-${AdaptDatetime2PickerComponent.DT_ID++}`;
        }
        this._model.year = initVal.year();
        this._model.month = initVal.month();
        this._model.day = initVal.date();
        this._model.hour = initVal.hour();
        this._model.minute = initVal.minute();
        this._model.second = this.timeSeconds ? initVal.second() : 0;
        this.monthMode = this.monthFirst;
    }
    setDefaultTexts(translation) {
        this.defaultTexts.emptyTime = translation['adapt.datetime.emptyTime'];
        this.defaultTexts.emptyDate = translation['adapt.datetime.emptyDate'];
        this.defaultTexts.emptyYear = translation['adapt.datetime.emptyYear'];
        this.defaultTexts.timeSeparator = translation['adapt.datetime.timeSeparator'];
        this.defaultTexts.hours = translation['adapt.datetime.hours'];
        this.defaultTexts.minutes = translation['adapt.datetime.minutes'];
        this.defaultTexts.seconds = translation['adapt.datetime.seconds'];
        this.defaultTexts.meridiem = translation['adapt.datetime.meridiem'];
        this.defaultTexts.month = translation['adapt.datetime.month'];
        this.defaultTexts.amBtn = translation['adapt.datetime.am'];
        this.defaultTexts.pmBtn = translation['adapt.datetime.pm'];
    }
    selectDate(v) {
        if (!this.readonly) {
            this._model.year = v.year();
            if (!this.monthAndYearOnly) {
                this._model.month = v.month();
                this._model.day = v.date();
            }
            this.activeDate = v.clone();
            this.valueChange.emit(moment(this._model));
        }
    }
    selectTime(v) {
        this._model.hour = v[0];
        this._model.minute = v[1];
        this._model.second = v[2];
        this.valueChange.emit(moment(this._model));
    }
    selectMonth(v) {
        this._model.month = v.month();
        this.activeDate = v.clone();
        this.valueChange.emit(moment(this._model));
    }
    setCurrentDate() {
        this.activeDate = moment();
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this.hoursField.nativeElement.focus();
        });
    }
    changeMeridiem() {
        this._model.hour = (this._model.hour + 12) % 24;
        this.valueChange.emit(moment(this._model));
    }
    timeUnitKeydown(event, unit) {
        const keycode = getEventKeyCode(event);
        let action;
        switch (keycode) {
            case UP_ARROW: {
                event.preventDefault();
                action = '+';
                break;
            }
            case DOWN_ARROW: {
                event.preventDefault();
                action = '-';
                break;
            }
        }
        if (action) {
            switch (unit) {
                case 'h': {
                    if (this.hasMeridiem) {
                        this._model.hour = action === '+' ?
                            this._model.hour === 11 ? 0 : this._model.hour === 23 ? 12 : this._model.hour + 1 :
                            this._model.hour === 0 ? 11 : this._model.hour === 12 ? 23 : this._model.hour - 1;
                    }
                    else {
                        this._model.hour = action === '+' ?
                            (this._model.hour + 1) % 24 :
                            ((this._model.hour - 1) < 0 ? 23 : this._model.hour - 1);
                    }
                    break;
                }
                case 'm': {
                    this._model.minute = action === '+' ?
                        (this._model.minute + 1) % 60 :
                        ((this._model.minute - 1) < 0 ? 59 : this._model.minute - 1);
                    break;
                }
                case 's': {
                    this._model.second = action === '+' ?
                        (this._model.second + 1) % 60 :
                        ((this._model.second - 1) < 0 ? 59 : this._model.second - 1);
                    break;
                }
            }
            this.valueChange.emit(moment(this._model));
        }
    }
    timeUnitInput(event, unit) {
        const value = event.target.value;
        const parsedValue = parseInt(value, 10);
        const parsedValueIsNumber = Number.isInteger(parsedValue);
        switch (unit) {
            case 'h': {
                this._model.hour = parsedValueIsNumber ? parsedValue % (this.hasMeridiem ? 12 : 24) : 0;
                break;
            }
            case 'm': {
                this._model.minute = parsedValueIsNumber ? parsedValue % 60 : 0;
                break;
            }
            case 's': {
                this._model.second = parsedValueIsNumber ? parsedValue % 60 : 0;
                break;
            }
        }
        this.valueChange.emit(moment(this._model));
    }
}
// Locale time format
AdaptDatetime2PickerComponent.DT_ID = 1;
AdaptDatetime2PickerComponent.ɵfac = function AdaptDatetime2PickerComponent_Factory(t) { return new (t || AdaptDatetime2PickerComponent)(i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptDatetime2PickerComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDatetime2PickerComponent, selectors: [["adapt-datetime2-picker"]], viewQuery: function AdaptDatetime2PickerComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c4$7, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.hoursField = _t.first);
    } }, inputs: { dateRange: "dateRange", dateFormat: "dateFormat", dateFilter: "dateFilter", timeFormat: "timeFormat", timePicker: "timePicker", timeOnly: "timeOnly", monthAndYearOnly: "monthAndYearOnly", monthFirst: "monthFirst", timeSeconds: "timeSeconds", activeFace: "activeFace", initialValue: "initialValue", disabled: "disabled", readonly: "readonly", hideDatePickerSummary: "hideDatePickerSummary", preventExpandedDateControls: "preventExpandedDateControls", emptyDateHeading: "emptyDateHeading", emptyTimeHeading: "emptyTimeHeading", emptyMonthHeading: "emptyMonthHeading", clockHeadings: "clockHeadings", testID: "testID", timeMode: "timeMode", activeValue: "activeValue" }, outputs: { valueChange: "valueChange", timeModeChange: "timeModeChange", clockFaceChange: "clockFaceChange" }, decls: 10, vars: 5, consts: [[1, "a3t-datetime"], ["class", "a3t-datetime--date-picker", 4, "ngIf"], ["class", "a3t-datetime--time-picker", 4, "ngIf"], ["class", "a3t-datetime--time-picker a3t-datetime--year-picker", 4, "ngIf"], [1, "a3t-datetime--date-picker"], ["class", "a3t-datetime--date-picker-summary", 4, "ngIf"], ["class", "a3t-datetime--date-picker-summary a3t-datetime--year-picker-summary", 4, "ngIf"], ["class", "a3t-datetime--date-picker-wrapper", 4, "ngIf"], [1, "a3t-datetime--date-picker-summary"], [1, "mx-2", 3, "adaptRadarDisableEventSending", "name"], ["type", "button", 3, "click"], [1, "a3t-datetime--date-picker-summary", "a3t-datetime--year-picker-summary"], [1, "a3t-datetime--date-picker-wrapper"], [3, "expandedControlsStyle", "initialDate", "activeDate", "monthAndYearOnly", "range", "filter", "disabled", "readonly", "testID", "daySelect"], [1, "a3t-datetime--time-picker"], [1, "a3t-datetime--time-picker-summary"], [1, "a3t-datetime--time-picker-summary-info"], [1, "a3t-datetime--time-picker-summary-input-wrapper"], [4, "ngIf"], ["type", "button", "class", "a3t-datetime--time-picker-summary-toggle", "aria-hidden", "true", "tabindex", "-1", 3, "rotation-180", "click", 4, "ngIf"], ["class", "a3t-datetime--time-picker-wrapper", 4, "ngIf"], ["type", "text", "role", "spinbutton", 1, "a3t-datetime--time-picker-summary-input", "a3t-datetime--time-picker-summary-input-field", 3, "value", "focus", "input", "keydown"], ["hoursField", ""], ["type", "button", "role", "spinbutton", 1, "a3t-datetime--time-picker-summary-input", "mx-1", 3, "value", "click", "keydown.arrowUp", "keydown.arrowDown"], ["tabindex", "0", 1, "a3t-datetime--time-picker-summary-input", 3, "focus"], ["type", "button", "aria-hidden", "true", "tabindex", "-1", 1, "a3t-datetime--time-picker-summary-toggle", 3, "click"], [1, "mr-2", 3, "adaptRadarDisableEventSending", "name"], [1, "a3t-datetime--time-picker-wrapper"], [3, "activeTime", "activeFace", "seconds", "hasMeridiem", "disabled", "readonly", "texts", "testID", "timeSelect", "clockFaceChange"], [1, "a3t-datetime--time-picker", "a3t-datetime--year-picker"], ["tabindex", "0", "role", "textbox", 1, "a3t-datetime--time-picker-summary-input"], [1, "ml-1", "mr-1", 3, "adaptRadarDisableEventSending", "name"], ["class", "a3t-datetime--month-picker-wrapper", 4, "ngIf"], [1, "a3t-datetime--month-picker-wrapper"], [3, "initialDate", "activeDate", "selectMonth"]], template: function AdaptDatetime2PickerComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n      ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n          ");
        i0.ɵɵtemplate(3, AdaptDatetime2PickerComponent_div_3_Template, 8, 3, "div", 1);
        i0.ɵɵtext(4, "\n\n          ");
        i0.ɵɵtemplate(5, AdaptDatetime2PickerComponent_div_5_Template, 21, 8, "div", 2);
        i0.ɵɵtext(6, "\n\n          ");
        i0.ɵɵtemplate(7, AdaptDatetime2PickerComponent_div_7_Template, 21, 10, "div", 3);
        i0.ɵɵtext(8, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(9, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵclassProp("a3t-datetime_compact", ctx.hideDatePickerSummary);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.timeOnly);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.timePicker);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.monthAndYearOnly);
    } }, directives: [i3.NgIf, i1.AdaptIconComponent, AdaptDatetime2CalendarComponent, i1.AdaptDragonInputHandlerDirective, AdaptDatetime2ClockComponent, AdaptDatetime2MonthPickerComponent], encapsulation: 2, data: { animation: [
            trigger('heightAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '0',
                            to: '*'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '*',
                            to: '0'
                        }
                    })
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetime2PickerComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-datetime2-picker',
                template: `
      <div class="a3t-datetime" [class.a3t-datetime_compact]="hideDatePickerSummary">
          <div class="a3t-datetime--date-picker" *ngIf="!timeOnly">
              <div class="a3t-datetime--date-picker-summary" *ngIf="timeMode && !timeOnly && !hideDatePickerSummary" [@heightAnimation]>
                  <adapt-icon [adaptRadarDisableEventSending]="true" [name]="'calendar'" class="mx-2"></adapt-icon>
                  <button type="button" (click)="timeMode = false"
                          [attr.data-testid]="testID + '_dateSummary'"
                          [attr.aria-label]="dateSummary">{{dateSummary}}</button>
              </div>

              <div class="a3t-datetime--date-picker-summary a3t-datetime--year-picker-summary"
                   *ngIf="monthMode && monthAndYearOnly && !hideDatePickerSummary" [@heightAnimation]>
                  <button type="button" (click)="monthMode = false"
                          [attr.data-testid]="testID + '_yearSummary'"
                          [attr.aria-label]="yearSummary">{{yearSummary}}</button>
              </div>

              <div class="a3t-datetime--date-picker-wrapper"
                   *ngIf="(!timeMode && !monthAndYearOnly) || (!monthMode && monthAndYearOnly)" [@heightAnimation]>
                  <adapt-datetime2-calendar [expandedControlsStyle]="!timePicker && !preventExpandedDateControls"
                                            [initialDate]="initialValue"
                                            [activeDate]="activeDate"
                                            [monthAndYearOnly]="monthAndYearOnly"
                                            [range]="dateRange"
                                            [filter]="dateFilter"
                                            [disabled]="disabled"
                                            [readonly]="readonly"
                                            [testID]="testID"
                                            (daySelect)="selectDate($event)"></adapt-datetime2-calendar>
              </div>
          </div>

          <div class="a3t-datetime--time-picker" *ngIf="timePicker">
              <div class="a3t-datetime--time-picker-summary"
                   [class.a3t-datetime--time-picker-summary_active]="timeMode">
                  <div class="a3t-datetime--time-picker-summary-info">
                      <adapt-icon [adaptRadarDisableEventSending]="true" [name]="'clock_o'" class="mx-2"></adapt-icon>

                      <div class="a3t-datetime--time-picker-summary-input-wrapper">
                          <ng-container *ngIf="timeSummary">
                              <input type="text"
                                     role="spinbutton"
                                     class="a3t-datetime--time-picker-summary-input a3t-datetime--time-picker-summary-input-field"
                                     #hoursField
                                     [value]="timeSummary.hh"
                                     [attr.aria-valuenow]="timeSummary.hh"
                                     [attr.aria-label]="defaultTexts.hours"
                                     (focus)="activeFace = activeFaceVariants.Hours; clockFaceChange.emit(activeFaceVariants.Hours)"
                                     (input)="timeUnitInput($event, 'h')"
                                     (keydown)="timeUnitKeydown($event, 'h')"/>
                              {{this.defaultTexts.timeSeparator}}
                              <input type="text"
                                     role="spinbutton"
                                     class="a3t-datetime--time-picker-summary-input a3t-datetime--time-picker-summary-input-field"
                                     [value]="timeSummary.mm"
                                     [attr.aria-valuenow]="timeSummary.mm"
                                     [attr.aria-label]="defaultTexts.minutes"
                                     (focus)="activeFace = activeFaceVariants.Minutes; clockFaceChange.emit(activeFaceVariants.Minutes)"
                                     (input)="timeUnitInput($event, 'm')"
                                     (keydown)="timeUnitKeydown($event, 'm')"/>

                              <ng-container *ngIf="timeSeconds">
                                  {{this.defaultTexts.timeSeparator}}
                                  <input type="text"
                                         role="spinbutton"
                                         class="a3t-datetime--time-picker-summary-input a3t-datetime--time-picker-summary-input-field"
                                         [value]="timeSummary.ss"
                                         [attr.aria-valuenow]="timeSummary.ss"
                                         [attr.aria-label]="defaultTexts.seconds"
                                         (focus)="activeFace = activeFaceVariants.Seconds; clockFaceChange.emit(activeFaceVariants.Seconds)"
                                         (input)="timeUnitInput($event, 's')"
                                         (keydown)="timeUnitKeydown($event, 's')"/>
                              </ng-container>

                              <ng-container *ngIf="hasMeridiem">
                                  <input type="button"
                                         role="spinbutton"
                                         class="a3t-datetime--time-picker-summary-input mx-1"
                                         [value]="timeSummary.a"
                                         [attr.aria-valuenow]="timeSummary.a"
                                         [attr.aria-label]="defaultTexts.meridiem"
                                         (click)="changeMeridiem()"
                                         (keydown.arrowUp)="$event.preventDefault(); changeMeridiem()"
                                         (keydown.arrowDown)="$event.preventDefault(); changeMeridiem()"/>
                              </ng-container>
                          </ng-container>

                          <ng-container *ngIf="!timeSummary">
                              <span tabindex="0" (focus)="setCurrentDate()"
                                    class="a3t-datetime--time-picker-summary-input">{{emptyTimeHeading}}</span>
                          </ng-container>

                      </div>
                  </div>

                  <button type="button"
                          class="a3t-datetime--time-picker-summary-toggle"
                          aria-hidden="true"
                          tabindex="-1"
                          [class.rotation-180]="!timeMode"
                          [attr.data-testid]="testID + '_timeMode'"
                          *ngIf="!timeOnly"
                          (click)="timeMode = !timeMode">
                      <adapt-icon [adaptRadarDisableEventSending]="true" [name]="'angle_down'" class="mr-2"></adapt-icon>
                  </button>
              </div>
              <div class="a3t-datetime--time-picker-wrapper"
                   *ngIf="timeMode"
                   [@heightAnimation]>
                  <adapt-datetime2-clock [activeTime]="clockState"
                                         [activeFace]="activeFace"
                                         [seconds]="timeSeconds"
                                         [hasMeridiem]="hasMeridiem"
                                         [disabled]="disabled"
                                         [readonly]="readonly"
                                         [texts]="clockHeadings"
                                         [testID]="testID"
                                         (timeSelect)="selectTime($event)"
                                         (clockFaceChange)="clockFaceChange.emit($event)">
                  </adapt-datetime2-clock>
              </div>
          </div>

          <div class="a3t-datetime--time-picker a3t-datetime--year-picker" *ngIf="monthAndYearOnly">
              <div class="a3t-datetime--time-picker-summary"
                   [class.a3t-datetime--time-picker-summary_active]="monthMode">
                  <div class="a3t-datetime--time-picker-summary-info">
                      <div class="a3t-datetime--time-picker-summary-input-wrapper">
              <span class="a3t-datetime--time-picker-summary-input"
                    tabindex="0"
                    [attr.aria-label]="defaultTexts.month"
                    role="textbox">
                {{ monthSummary }}
              </span>
                      </div>
                  </div>

                  <button type="button"
                          class="a3t-datetime--time-picker-summary-toggle"
                          aria-hidden="true"
                          tabindex="-1"
                          [attr.data-testid]="testID + '_monthMode'"
                          [class.rotation-180]="!monthMode"
                          (click)="monthMode = !monthMode">
                      <adapt-icon [adaptRadarDisableEventSending]="true" [name]="'angle_down'" class="ml-1 mr-1"></adapt-icon>
                  </button>
              </div>
              <div class="a3t-datetime--month-picker-wrapper" *ngIf="monthMode" [@heightAnimation]>
                  <adapt-datetime2-month-picker
                          [initialDate]="initialValue"
                          [activeDate]="activeDate"
                          (selectMonth)="selectMonth($event)"
                  ></adapt-datetime2-month-picker>
              </div>
          </div>
      </div>
  `,
                animations: [
                    trigger('heightAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '0',
                                    to: '*'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '*',
                                    to: '0'
                                }
                            })
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i1.AdaptTranslateService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, { hoursField: [{
            type: ViewChild,
            args: ['hoursField', { static: false }]
        }], dateRange: [{
            type: Input
        }], dateFormat: [{
            type: Input
        }], dateFilter: [{
            type: Input
        }], timeFormat: [{
            type: Input
        }], timePicker: [{
            type: Input
        }], timeOnly: [{
            type: Input
        }], monthAndYearOnly: [{
            type: Input
        }], monthFirst: [{
            type: Input
        }], timeSeconds: [{
            type: Input
        }], activeFace: [{
            type: Input
        }], initialValue: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], hideDatePickerSummary: [{
            type: Input
        }], preventExpandedDateControls: [{
            type: Input
        }], emptyDateHeading: [{
            type: Input
        }], emptyTimeHeading: [{
            type: Input
        }], emptyMonthHeading: [{
            type: Input
        }], clockHeadings: [{
            type: Input
        }], testID: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], timeModeChange: [{
            type: Output
        }], clockFaceChange: [{
            type: Output
        }], timeMode: [{
            type: Input
        }], activeValue: [{
            type: Input
        }] }); })();

class AdaptDatetime2Module {
    constructor(iconConfig) {
        iconConfig.registerIcons([ai_angle_left]);
    }
}
AdaptDatetime2Module.ɵfac = function AdaptDatetime2Module_Factory(t) { return new (t || AdaptDatetime2Module)(i0.ɵɵinject(i1.AdaptIconConfig)); };
AdaptDatetime2Module.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptDatetime2Module });
AdaptDatetime2Module.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            AdaptDropdownModule.forRoot(),
            AdaptIconModule,
            AdaptPopoverModule.forRoot(),
            AdaptTooltipModule,
            AdaptAnimationDirectivesModule,
            AdaptDragonInputHandlerModule,
            AdaptRxLabelModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDatetime2Module, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AdaptDropdownModule.forRoot(),
                    AdaptIconModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptTooltipModule,
                    AdaptAnimationDirectivesModule,
                    AdaptDragonInputHandlerModule,
                    AdaptRxLabelModule
                ],
                declarations: [
                    AdaptDatetime2CalendarComponent,
                    AdaptDatetime2ClockComponent,
                    AdaptDatetime2Component,
                    AdaptDatetime2PickerComponent,
                    AdaptDatetimeRange2Component,
                    AdaptDatetime2MonthPickerComponent,
                    AdaptDatetime2YearPickerComponent
                ],
                exports: [
                    AdaptDatetime2CalendarComponent,
                    AdaptDatetime2ClockComponent,
                    AdaptDatetime2Component,
                    AdaptDatetime2PickerComponent,
                    AdaptDatetimeRange2Component,
                    AdaptDatetime2MonthPickerComponent,
                    AdaptDatetime2YearPickerComponent
                ]
            }]
    }], function () { return [{ type: i1.AdaptIconConfig }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptDatetime2Module, { declarations: [AdaptDatetime2CalendarComponent,
        AdaptDatetime2ClockComponent,
        AdaptDatetime2Component,
        AdaptDatetime2PickerComponent,
        AdaptDatetimeRange2Component,
        AdaptDatetime2MonthPickerComponent,
        AdaptDatetime2YearPickerComponent], imports: [CommonModule,
        FormsModule, i1.AdaptDropdownModule, AdaptIconModule, i1.AdaptPopoverModule, AdaptTooltipModule,
        AdaptAnimationDirectivesModule,
        AdaptDragonInputHandlerModule,
        AdaptRxLabelModule], exports: [AdaptDatetime2CalendarComponent,
        AdaptDatetime2ClockComponent,
        AdaptDatetime2Component,
        AdaptDatetime2PickerComponent,
        AdaptDatetimeRange2Component,
        AdaptDatetime2MonthPickerComponent,
        AdaptDatetime2YearPickerComponent] }); })();
i0.ɵɵsetComponentScope(AdaptDatetime2Component, [i1.AdaptDropdownDirective, i1.AdaptDropdownAnchorDirective, i1.AdaptRxControlLabelComponent, i3.NgIf, i1.AdaptDragonInputHandlerDirective, i1.AdaptDropdownMenuTemplateDirective, i3.NgClass, AdaptDatetime2PickerComponent, i3.NgForOf], []);
i0.ɵɵsetComponentScope(AdaptDatetimeRange2Component, [i1.AdaptDropdownDirective, i1.AdaptDropdownAnchorDirective, i1.AdaptRxControlLabelComponent, i3.NgIf, i1.AdaptDragonInputHandlerDirective, i1.AdaptDropdownMenuTemplateDirective, i3.NgClass, AdaptDatetime2PickerComponent, i3.NgForOf], []);

const _c0$k = ["customInput"];
function AdaptDropDownEditableComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵelementStart(1, "div", 10);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n        ");
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate2("", ctx_r1.label ? ctx_r1.label + ":" : "", " ", ctx_r1.model, "");
} }
function AdaptDropDownEditableComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 11);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementContainer(2, 12);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    const _r0 = i0.ɵɵreference(6);
    i0.ɵɵclassMap("btn btn-secondary w-100 text-default align-start " + ctx_r2.size);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r0);
} }
function AdaptDropDownEditableComponent_button_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 13);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementContainer(2, 12);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    const _r0 = i0.ɵɵreference(6);
    i0.ɵɵclassMap("btn btn-secondary dropdown-toggle w-100 align-start " + ctx_r3.size);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r0);
} }
function AdaptDropDownEditableComponent_input_12_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "input", 14, 15);
    i0.ɵɵlistener("ngModelChange", function AdaptDropDownEditableComponent_input_12_Template_input_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.customItemModel = $event; })("blur", function AdaptDropDownEditableComponent_input_12_Template_input_blur_0_listener() { i0.ɵɵrestoreView(_r12); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.exitFocusMode(); })("keyup.esc", function AdaptDropDownEditableComponent_input_12_Template_input_keyup_esc_0_listener() { i0.ɵɵrestoreView(_r12); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.exitFocusMode(); })("keydown.enter", function AdaptDropDownEditableComponent_input_12_Template_input_keydown_enter_0_listener() { i0.ɵɵrestoreView(_r12); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.exitFocusMode(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("form-control-sm", ctx_r4.size === ctx_r4.sizeVariants.small)("form-control-lg", ctx_r4.size === ctx_r4.sizeVariants.large);
    i0.ɵɵproperty("ngModel", ctx_r4.customItemModel);
} }
function AdaptDropDownEditableComponent_ng_template_17_ng_template_1_Template(rf, ctx) { }
function AdaptDropDownEditableComponent_ng_template_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, AdaptDropDownEditableComponent_ng_template_17_ng_template_1_Template, 0, 0, "ng-template", 12);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r8 = i0.ɵɵreference(26);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function AdaptDropDownEditableComponent_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    const _r19 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "button", 16);
    i0.ɵɵlistener("click", function AdaptDropDownEditableComponent_ng_container_19_Template_button_click_2_listener() { const restoredCtx = i0.ɵɵrestoreView(_r19); const item_r17 = restoredCtx.$implicit; const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.setModel(item_r17); });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r17 = ctx.$implicit;
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("active", item_r17 === ctx_r6.model);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(item_r17);
} }
function AdaptDropDownEditableComponent_ng_template_21_ng_template_1_Template(rf, ctx) { }
function AdaptDropDownEditableComponent_ng_template_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, AdaptDropDownEditableComponent_ng_template_21_ng_template_1_Template, 0, 0, "ng-template", 12);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r8 = i0.ɵɵreference(26);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", _r8);
} }
function AdaptDropDownEditableComponent_ng_template_25_Template(rf, ctx) { if (rf & 1) {
    const _r22 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "button", 17);
    i0.ɵɵlistener("click", function AdaptDropDownEditableComponent_ng_template_25_Template_button_click_1_listener() { i0.ɵɵrestoreView(_r22); const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.enterEditMode(); });
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "span");
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("active", ctx_r9.customItemModel === ctx_r9.model);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("text-secondary", !ctx_r9.customItemModel);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r9.customItemModel || ctx_r9.moreTitle);
} }
class AdaptDropDownEditableComponent extends AdaptRadarGenericDirective {
    constructor(ts, _ngZone, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptDropDownEditable);
        this.ts = ts;
        this._ngZone = _ngZone;
        this.model = 0;
        this.editMode = false;
        this.sizeVariants = AdaptDropdownEditableSize;
        this.defaultTexts = {};
        this.width = '100%';
        this.readonly = false;
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.items = [];
        this.size = this.sizeVariants.medium;
        this.mobileView = {};
        this.customValueOnTop = false;
        this.valueChange = new EventEmitter();
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    set value(v) {
        if (v !== undefined) {
            this.model = v;
            if (this.items.length && this.items.indexOf(v) === -1) {
                this.customItemModel = v;
            }
        }
    }
    get value() {
        return this.model;
    }
    ngOnInit() {
        this.moreTitle = this.moreTitle || this.defaultTexts.moreTitle;
    }
    setDefaultTexts(translation) {
        this.defaultTexts.moreTitle = translation['adapt.dropdownEditable.more'];
    }
    setModel(item) {
        this.model = item;
        this.customItemModel = null;
        this.valueChange.emit(this.model);
    }
    enterEditMode() {
        this.editMode = true;
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe((() => {
            this.customInput.nativeElement.focus();
        }));
    }
    exitFocusMode() {
        if (this.customItemModel) {
            this.model = this.customItemModel;
            this.valueChange.emit(this.model);
        }
        this.editMode = false;
    }
}
AdaptDropDownEditableComponent.ɵfac = function AdaptDropDownEditableComponent_Factory(t) { return new (t || AdaptDropDownEditableComponent)(i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptDropDownEditableComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDropDownEditableComponent, selectors: [["adapt-dropdown-editable"]], viewQuery: function AdaptDropDownEditableComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$k, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customInput = _t.first);
    } }, hostVars: 4, hostBindings: function AdaptDropDownEditableComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵstyleProp("display", "inline-block")("width", ctx.width);
    } }, inputs: { value: "value", width: "width", readonly: "readonly", moreTitle: "moreTitle", label: "label", items: "items", size: "size", mobileView: "mobileView", customValueOnTop: "customValueOnTop" }, outputs: { valueChange: "valueChange" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 28, vars: 8, consts: [["adaptDropdown", "", 3, "adaptRadarDisableEventSending", "mobileView"], ["adaptDropdownAnchor", "", 2, "background", "none", "padding", "0"], ["uiValue", ""], ["style", "background: none; border: 0; cursor: default;", 3, "class", 4, "ngIf"], ["type", "button", "adaptDropdownToggle", "", 3, "class", 4, "ngIf"], ["type", "text", "class", "form-control", 3, "form-control-sm", "form-control-lg", "ngModel", "ngModelChange", "blur", "keyup.esc", "keydown.enter", 4, "ngIf"], ["adaptDropdownMenu", "", 1, "dropdown-menu"], [3, "ngIf"], [4, "ngFor", "ngForOf"], ["addCustomValueTemplate", ""], [2, "overflow", "hidden", "white-space", "nowrap", "text-overflow", "ellipsis"], [2, "background", "none", "border", "0", "cursor", "default"], [3, "ngTemplateOutlet"], ["type", "button", "adaptDropdownToggle", ""], ["type", "text", 1, "form-control", 3, "ngModel", "ngModelChange", "blur", "keyup.esc", "keydown.enter"], ["customInput", ""], ["type", "button", 1, "dropdown-item", 3, "click"], ["type", "button", 1, "dropdown-item", "dropdown-item-editable", 3, "click"]], template: function AdaptDropDownEditableComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵelementStart(3, "div", 1);
        i0.ɵɵtext(4, "\n        ");
        i0.ɵɵtemplate(5, AdaptDropDownEditableComponent_ng_template_5_Template, 4, 2, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n\n        ");
        i0.ɵɵtemplate(8, AdaptDropDownEditableComponent_div_8_Template, 4, 3, "div", 3);
        i0.ɵɵtext(9, "\n        ");
        i0.ɵɵtemplate(10, AdaptDropDownEditableComponent_button_10_Template, 4, 3, "button", 4);
        i0.ɵɵtext(11, "\n        ");
        i0.ɵɵtemplate(12, AdaptDropDownEditableComponent_input_12_Template, 2, 5, "input", 5);
        i0.ɵɵtext(13, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(14, "\n      ");
        i0.ɵɵelementStart(15, "div", 6);
        i0.ɵɵtext(16, "\n        ");
        i0.ɵɵtemplate(17, AdaptDropDownEditableComponent_ng_template_17_Template, 3, 1, "ng-template", 7);
        i0.ɵɵtext(18, "\n        ");
        i0.ɵɵtemplate(19, AdaptDropDownEditableComponent_ng_container_19_Template, 5, 3, "ng-container", 8);
        i0.ɵɵtext(20, "\n        ");
        i0.ɵɵtemplate(21, AdaptDropDownEditableComponent_ng_template_21_Template, 3, 1, "ng-template", 7);
        i0.ɵɵtext(22, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(23, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(24, "\n\n    ");
        i0.ɵɵtemplate(25, AdaptDropDownEditableComponent_ng_template_25_Template, 7, 5, "ng-template", null, 9, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(27, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("mobileView", ctx.mobileView);
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngIf", ctx.readonly && !ctx.editMode);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.readonly && !ctx.editMode);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.editMode);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.customValueOnTop);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", ctx.items);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.customValueOnTop);
    } }, directives: [i1.AdaptDropdownDirective, i1.AdaptDropdownAnchorDirective, i3.NgIf, i1.AdaptDropdownMenuDirective, i3.NgForOf, i3.NgTemplateOutlet, i1.AdaptDropdownToggleDirective, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i6.NgControlStatus, i6.NgModel], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropDownEditableComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-dropdown-editable',
                template: `
    <div adaptDropdown
         [adaptRadarDisableEventSending]="true"
         [mobileView]="mobileView">
      <div adaptDropdownAnchor style="background: none; padding: 0">
        <ng-template #uiValue>
          <div
            style="overflow: hidden; white-space: nowrap; text-overflow: ellipsis">{{label ? (label + ':') : ''}} {{model}}</div>
        </ng-template>

        <div
          *ngIf="readonly && !editMode"
          [class]="'btn btn-secondary w-100 text-default align-start ' + size"
          style="background: none; border: 0; cursor: default;">
          <ng-container [ngTemplateOutlet]="uiValue"></ng-container>
        </div>
        <button type="button"
                [class]="'btn btn-secondary dropdown-toggle w-100 align-start ' + size"
                *ngIf="!readonly && !editMode"
                adaptDropdownToggle>
          <ng-container [ngTemplateOutlet]="uiValue"></ng-container>
        </button>
        <input #customInput
               type="text"
               class="form-control"
               [class.form-control-sm]="size === sizeVariants.small"
               [class.form-control-lg]="size === sizeVariants.large"
               [(ngModel)]="customItemModel"
               *ngIf="editMode"
               (blur)="exitFocusMode()"
               (keyup.esc)="exitFocusMode()"
               (keydown.enter)="exitFocusMode()"/>
      </div>
      <div adaptDropdownMenu class="dropdown-menu">
        <ng-template [ngIf]="customValueOnTop">
          <ng-template [ngTemplateOutlet]="addCustomValueTemplate"></ng-template>
        </ng-template>
        <ng-container *ngFor="let item of items">
          <button class="dropdown-item"
                  type="button"
                  [class.active]="item === model"
                  (click)="setModel(item)">{{item}}</button>
        </ng-container>
        <ng-template [ngIf]="!customValueOnTop">
          <ng-template [ngTemplateOutlet]="addCustomValueTemplate"></ng-template>
        </ng-template>
      </div>
    </div>

    <ng-template #addCustomValueTemplate>
      <button class="dropdown-item dropdown-item-editable"
              type="button"
              [class.active]="customItemModel === model"
              (click)="enterEditMode()">
        <span [class.text-secondary]="!customItemModel">{{customItemModel || moreTitle}}</span>
      </button>
    </ng-template>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[style.display]': '"inline-block"',
                    '[style.width]': 'width'
                }
            }]
    }], function () { return [{ type: i1.AdaptTranslateService }, { type: i0.NgZone }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { value: [{
            type: Input
        }], width: [{
            type: Input
        }], readonly: [{
            type: Input
        }], moreTitle: [{
            type: Input
        }], label: [{
            type: Input
        }], items: [{
            type: Input
        }], size: [{
            type: Input
        }], mobileView: [{
            type: Input
        }], customValueOnTop: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], customInput: [{
            type: ViewChild,
            args: ['customInput']
        }] }); })();

class AdaptDropdownEditableModule {
}
AdaptDropdownEditableModule.ɵfac = function AdaptDropdownEditableModule_Factory(t) { return new (t || AdaptDropdownEditableModule)(); };
AdaptDropdownEditableModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptDropdownEditableModule });
AdaptDropdownEditableModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            AdaptDropdownModule.forRoot(),
            AdaptDragonInputHandlerModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropdownEditableModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AdaptDropdownModule.forRoot(),
                    AdaptDragonInputHandlerModule
                ],
                declarations: [AdaptDropDownEditableComponent],
                exports: [AdaptDropDownEditableComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptDropdownEditableModule, { declarations: [AdaptDropDownEditableComponent], imports: [CommonModule,
        FormsModule, i1.AdaptDropdownModule, AdaptDragonInputHandlerModule], exports: [AdaptDropDownEditableComponent] }); })();

var SelectModelFormat;
(function (SelectModelFormat) {
    SelectModelFormat["number"] = "number";
    SelectModelFormat["object"] = "object";
})(SelectModelFormat || (SelectModelFormat = {}));

/**
 * Search filter by name and badgeText
 */
class AdaptSelectSearchFilter {
    transform(options, args) {
        return options.filter((option) => {
            return option.name && option.name.toLowerCase().indexOf((args || '').toLowerCase()) > -1
                || option.badgeText && option.badgeText.toLowerCase().indexOf((args || '').toLowerCase()) > -1;
        });
    }
}
AdaptSelectSearchFilter.ɵfac = function AdaptSelectSearchFilter_Factory(t) { return new (t || AdaptSelectSearchFilter)(); };
AdaptSelectSearchFilter.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: "searchFilter", type: AdaptSelectSearchFilter, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSelectSearchFilter, [{
        type: Pipe,
        args: [{
                name: 'searchFilter'
            }]
    }], null, null); })();
/**
 * Search filter by name
 */
class AdaptSelectSearchFilterAsync {
    transform(options, query) {
        return of(options).pipe(map(data => {
            if (!query) {
                return data;
            }
            return data.filter((option) => option.name.toLowerCase().indexOf((query || '').toLowerCase()) > -1);
        }));
    }
}
AdaptSelectSearchFilterAsync.ɵfac = function AdaptSelectSearchFilterAsync_Factory(t) { return new (t || AdaptSelectSearchFilterAsync)(); };
AdaptSelectSearchFilterAsync.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: "searchFilterAsync", type: AdaptSelectSearchFilterAsync, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSelectSearchFilterAsync, [{
        type: Pipe,
        args: [{
                name: 'searchFilterAsync'
            }]
    }], null, null); })();
class AdaptSelectSearchFilterModule {
}
AdaptSelectSearchFilterModule.ɵfac = function AdaptSelectSearchFilterModule_Factory(t) { return new (t || AdaptSelectSearchFilterModule)(); };
AdaptSelectSearchFilterModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptSelectSearchFilterModule });
AdaptSelectSearchFilterModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSelectSearchFilterModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    AdaptSelectSearchFilter,
                    AdaptSelectSearchFilterAsync
                ],
                exports: [
                    AdaptSelectSearchFilter,
                    AdaptSelectSearchFilterAsync
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptSelectSearchFilterModule, { declarations: [AdaptSelectSearchFilter, AdaptSelectSearchFilterAsync], imports: [CommonModule], exports: [AdaptSelectSearchFilter, AdaptSelectSearchFilterAsync] }); })();

// TODO update types
const _c0$j = ["menu"];
const _c1$f = ["filterInput"];
const _c2$d = ["labelElement"];
const _c3$9 = ["toggleDropdownBtn"];
const _c4$6 = ["titleWidth"];
const _c5$5 = ["optionRef"];
const _c6$3 = ["loadMoreBtn"];
const _c7$2 = ["dropdownItem"];
function AdaptSelectComponent_span_4_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "span", 8);
    i0.ɵɵelementStart(2, "span", 9);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r8.texts.requiredText);
} }
function AdaptSelectComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "span", 6, 7);
    i0.ɵɵlistener("click", function AdaptSelectComponent_span_4_Template_span_click_0_listener() { i0.ɵɵrestoreView(_r10); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.toggleDropdown(); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵelementStart(3, "span");
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
    i0.ɵɵtemplate(5, AdaptSelectComponent_span_4_ng_container_5_Template, 5, 1, "ng-container", 3);
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("sr-only", ctx_r0.settings.hideLabel);
    i0.ɵɵattribute("id", ctx_r0.ariaLabelledby);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(ctx_r0.label);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.required);
} }
function AdaptSelectComponent_ng_container_6_adapt_icon_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 12);
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", ctx_r11.tooltipInputIcon)("adaptTooltip", ctx_r11.tooltipInputText);
} }
function AdaptSelectComponent_ng_container_6_adapt_icon_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 13);
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", ctx_r12.popoverIcon)("placement", ctx_r12.popoverPlacement)("adaptPopover", ctx_r12.popoverContent)("triggers", ctx_r12.popoverTriggers);
} }
function AdaptSelectComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "span", 8);
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵtemplate(3, AdaptSelectComponent_ng_container_6_adapt_icon_3_Template, 1, 3, "adapt-icon", 10);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵtemplate(5, AdaptSelectComponent_ng_container_6_adapt_icon_5_Template, 1, 5, "adapt-icon", 11);
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r1.tooltipInputIcon && !ctx_r1.popoverIcon);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r1.popoverIcon);
} }
function AdaptSelectComponent_button_9_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 14, 15);
    i0.ɵɵlistener("click", function AdaptSelectComponent_button_9_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r15); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.toggleDropdown(); })("keyup", function AdaptSelectComponent_button_9_Template_button_keyup_0_listener($event) { i0.ɵɵrestoreView(_r15); const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.uncheckAllOnDelete($event); });
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("disabled", ctx_r2.readonly)("is-active", ctx_r2.isVisible)("dropdown-toggle-up", ctx_r2.placement === "top");
    i0.ɵɵproperty("ngClass", ctx_r2.settings.buttonClasses)("disabled", ctx_r2.disabled);
    i0.ɵɵattribute("aria-expanded", ctx_r2.isVisible)("aria-labelledby", ctx_r2.ariaLabelledby + " " + ctx_r2.id + "_button")("aria-describedby", ctx_r2.ariaDescribedBy)("aria-disabled", ctx_r2.disabled)("id", ctx_r2.id + "_button")("aria-readonly", ctx_r2.readonly)("aria-invalid", ctx_r2.isError)("aria-required", ctx_r2.required)("aria-multiselectable", !ctx_r2.single)("aria-activedescendant", ctx_r2.getActiveDescendant())("aria-owns", ctx_r2.isVisible ? ctx_r2.popupId : null);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n    ", ctx_r2.title, "\n  ");
} }
function AdaptSelectComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    const _r20 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "button", 16, 15);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_11_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r20); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.toggleDropdown(); })("keyup", function AdaptSelectComponent_ng_container_11_Template_button_keyup_2_listener($event) { i0.ɵɵrestoreView(_r20); const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.uncheckAllOnDelete($event); });
    i0.ɵɵtext(4);
    i0.ɵɵelementStart(5, "span", 17, 18);
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("is-active", ctx_r3.isVisible);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r3.tooltipText)("placement", "auto")("ngClass", ctx_r3.settings.buttonClasses)("disabled", ctx_r3.disabled);
    i0.ɵɵattribute("aria-expanded", ctx_r3.isVisible)("aria-disabled", ctx_r3.disabled)("aria-readonly", ctx_r3.readonly)("aria-invalid", ctx_r3.isError)("aria-required", ctx_r3.required)("aria-multiselectable", !ctx_r3.single)("aria-activedescendant", ctx_r3.getActiveDescendant())("aria-owns", ctx_r3.isVisible ? ctx_r3.popupId : null)("aria-labelledby", ctx_r3.ariaLabelledby + " " + ctx_r3.id + "_button")("aria-describedby", ctx_r3.ariaDescribedBy)("id", ctx_r3.id + "_button");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("", ctx_r3.title, "\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r3.title);
} }
function AdaptSelectComponent_ng_container_13_div_2_div_5_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r34 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 36);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_13_div_2_div_5_button_5_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r34); const ctx_r33 = i0.ɵɵnextContext(4); return ctx_r33.clearSearchFilter($event); });
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("@searchAnim", undefined);
} }
function AdaptSelectComponent_ng_container_13_div_2_div_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 32);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelement(2, "input", 33, 34);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵtemplate(5, AdaptSelectComponent_ng_container_13_div_2_div_5_button_5_Template, 2, 1, "button", 35);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("placeholder", ctx_r24.texts.searchPlaceholder);
    i0.ɵɵproperty("formControl", ctx_r24.searchFilterText);
    i0.ɵɵattribute("aria-controls", ctx_r24.popupId);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r24.searchFilterText.value.length > 0);
} }
function AdaptSelectComponent_ng_container_13_div_2_div_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 37);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r25 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r25.getHeaderText(), "\n          ");
} }
function AdaptSelectComponent_ng_container_13_div_2_div_11_adapt_custom_actions_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-custom-actions", 41);
} if (rf & 2) {
    const ctx_r35 = i0.ɵɵnextContext(4);
    i0.ɵɵproperty("actions", ctx_r35.customActions);
} }
function AdaptSelectComponent_ng_container_13_div_2_div_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 38);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "span", 39);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n\n            ");
    i0.ɵɵtemplate(5, AdaptSelectComponent_ng_container_13_div_2_div_11_adapt_custom_actions_5_Template, 1, 1, "adapt-custom-actions", 40);
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r26 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("@actionsAnim", ctx_r26.settings.showCheckAll || ctx_r26.settings.showUncheckAll || ctx_r26.searchFilterText.value ? "show" : "hide");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("@openClose", ctx_r26.rtl ? ctx_r26.searchFilterText.value ? "showRTL" : "hideRTL" : ctx_r26.searchFilterText.value ? "show" : "hide");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate2("\n                ", ctx_r26.texts.filteredTo, " ", ctx_r26.getFilteredItems().length, "\n            ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r26.settings.showCheckAll || ctx_r26.settings.showUncheckAll);
} }
const _c8$2 = function (a0) { return { "ellipsis": a0 }; };
function AdaptSelectComponent_ng_container_13_div_2_ng_container_15_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r41 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 44, 45);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_13_div_2_ng_container_15_button_2_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r41); const ctx_r40 = i0.ɵɵnextContext(4); return ctx_r40.setSelected($event, ctx_r40.nullOption); });
    i0.ɵɵtext(2, "\n            ");
    i0.ɵɵelementStart(3, "span", null, 46);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r36 = i0.ɵɵnextContext(4);
    i0.ɵɵclassProp("active", ctx_r36.isSelected(ctx_r36.nullOption));
    i0.ɵɵproperty("adaptFocusMonitor", ctx_r36.nullOption.id)("ngClass", i0.ɵɵpureFunction1(12, _c8$2, ctx_r36.settings.truncateText));
    i0.ɵɵattribute("id", ctx_r36.id + "-" + ctx_r36.nullOption.id + "_item");
    i0.ɵɵadvance(3);
    i0.ɵɵstyleProp("white-space", ctx_r36.whiteSpaceOption)("word-break", ctx_r36.wordBreakOption)("font-style", "italic");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r36.nullOption.name);
} }
function AdaptSelectComponent_ng_container_13_div_2_ng_container_15_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r47 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 47, 45);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_13_div_2_ng_container_15_button_4_Template_button_click_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r47); const option_r42 = restoredCtx.$implicit; const ctx_r46 = i0.ɵɵnextContext(4); return ctx_r46.setSelected($event, option_r42); });
    i0.ɵɵtext(2, "\n            ");
    i0.ɵɵelementStart(3, "span", null, 46);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r42 = ctx.$implicit;
    const index_r43 = ctx.index;
    const ctx_r37 = i0.ɵɵnextContext(4);
    i0.ɵɵclassProp("active", ctx_r37.isSelected(option_r42));
    i0.ɵɵproperty("adaptFocusMonitor", option_r42.id)("disabled", option_r42.disabled)("ngClass", i0.ɵɵpureFunction1(11, _c8$2, ctx_r37.settings.truncateText));
    i0.ɵɵattribute("id", ctx_r37.id + "-" + index_r43 + "_item");
    i0.ɵɵadvance(3);
    i0.ɵɵstyleProp("white-space", ctx_r37.whiteSpaceOption)("word-break", ctx_r37.wordBreakOption);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(option_r42.name);
} }
function AdaptSelectComponent_ng_container_13_div_2_ng_container_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵtemplate(2, AdaptSelectComponent_ng_container_13_div_2_ng_container_15_button_2_Template, 7, 14, "button", 42);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵtemplate(4, AdaptSelectComponent_ng_container_13_div_2_ng_container_15_button_4_Template, 7, 13, "button", 43);
    i0.ɵɵpipe(5, "slice");
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r27 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r27.settings.emptyOption && !ctx_r27.searchFilterText.value.length);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind3(5, 3, ctx_r27.displayedOptions, 0, ctx_r27.displayedOptionsCount))("ngForTrackBy", ctx_r27.optionsTrackByFn);
} }
function AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_adapt_icon_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-icon", 57);
    i0.ɵɵtext(1, "\n                    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r49 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", option_r49.icon)("classList", "text-" + option_r49.iconType);
} }
function AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_span_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 58);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r49 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("ngClass", "badge-" + option_r49.badgeType);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                      ", option_r49.badgeText, "\n                    ");
} }
function AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_Template(rf, ctx) { if (rf & 1) {
    const _r58 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li", 50, 45);
    i0.ɵɵlistener("keydown.space", function AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_Template_li_keydown_space_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r58); const option_r49 = restoredCtx.$implicit; const ctx_r57 = i0.ɵɵnextContext(4); return ctx_r57.setSelected($event, option_r49); })("keyup.enter", function AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_Template_li_keyup_enter_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r58); const option_r49 = restoredCtx.$implicit; const ctx_r59 = i0.ɵɵnextContext(4); return ctx_r59.setSelected($event, option_r49); });
    i0.ɵɵtext(2, "\n                  ");
    i0.ɵɵelementStart(3, "div", 51);
    i0.ɵɵtext(4, "\n                    ");
    i0.ɵɵelementStart(5, "label", 52);
    i0.ɵɵtext(6, "\n                      ");
    i0.ɵɵelementStart(7, "input", 53);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_Template_input_click_7_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r58); const option_r49 = restoredCtx.$implicit; const ctx_r60 = i0.ɵɵnextContext(4); return ctx_r60.setSelected($event, option_r49); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n                      ");
    i0.ɵɵelementStart(9, "span", 54, 46);
    i0.ɵɵtext(11, "\n                    ");
    i0.ɵɵtemplate(12, AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_adapt_icon_12_Template, 2, 3, "adapt-icon", 55);
    i0.ɵɵtext(13);
    i0.ɵɵtemplate(14, AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_span_14_Template, 2, 2, "span", 56);
    i0.ɵɵtext(15, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n                    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n                ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r49 = ctx.$implicit;
    const index_r50 = ctx.index;
    const ctx_r48 = i0.ɵɵnextContext(4);
    i0.ɵɵproperty("adaptFocusMonitor", option_r49.id);
    i0.ɵɵattribute("id", ctx_r48.id + "-" + index_r50 + "_item")("aria-selected", ctx_r48.isSelected(option_r49));
    i0.ɵɵadvance(7);
    i0.ɵɵproperty("disabled", option_r49.disabled)("checked", ctx_r48.isSelected(option_r49));
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("white-space", ctx_r48.whiteSpaceOption)("text-overflow", ctx_r48.textEllipsisOption)("word-break", ctx_r48.wordBreakOption);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r48.allowIconsBadges && option_r49.icon);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                        ", option_r49.name, "\n                        ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r48.allowIconsBadges && option_r49.badgeText);
} }
function AdaptSelectComponent_ng_container_13_div_2_ng_container_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵelementStart(2, "ul", 48);
    i0.ɵɵtext(3, "\n                ");
    i0.ɵɵtemplate(4, AdaptSelectComponent_ng_container_13_div_2_ng_container_17_li_4_Template, 19, 14, "li", 49);
    i0.ɵɵpipe(5, "slice");
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n\n            ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r28 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind3(5, 2, ctx_r28.displayedOptions, 0, ctx_r28.displayedOptionsCount))("ngForTrackBy", ctx_r28.optionsTrackByFn);
} }
function AdaptSelectComponent_ng_container_13_div_2_div_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 59);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r29 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", ctx_r29.texts.notFound, "\n        ");
} }
function AdaptSelectComponent_ng_container_13_div_2_ng_container_35_Template(rf, ctx) { if (rf & 1) {
    const _r63 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "button", 60, 61);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_13_div_2_ng_container_35_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r63); const ctx_r62 = i0.ɵɵnextContext(3); return ctx_r62.loadMoreItems(); });
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r30 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptInlineLoader", ctx_r30.loadingDataInProgress)("activeText", ctx_r30.texts.loadingText);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n          ", ctx_r30.texts.loadMore, "\n        ");
} }
const _c9$1 = function (a0, a1) { return { "activeLoad": a0, "dropdown_select__menu-sticky": a1 }; };
function AdaptSelectComponent_ng_container_13_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r65 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 20, 21);
    i0.ɵɵlistener("@selectAnim.done", function AdaptSelectComponent_ng_container_13_div_2_Template_div_animation_selectAnim_done_0_listener($event) { i0.ɵɵrestoreView(_r65); const ctx_r64 = i0.ɵɵnextContext(2); return ctx_r64.onAnimationDone($event); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵelementStart(3, "div", 22);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵtemplate(5, AdaptSelectComponent_ng_container_13_div_2_div_5_Template, 7, 4, "div", 23);
    i0.ɵɵtext(6, "\n\n        ");
    i0.ɵɵelementStart(7, "div", 24);
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵtemplate(9, AdaptSelectComponent_ng_container_13_div_2_div_9_Template, 2, 1, "div", 25);
    i0.ɵɵtext(10, "\n\n          ");
    i0.ɵɵtemplate(11, AdaptSelectComponent_ng_container_13_div_2_div_11_Template, 7, 5, "div", 26);
    i0.ɵɵtext(12, "\n\n          ");
    i0.ɵɵelementStart(13, "div", 27);
    i0.ɵɵtext(14, "\n            ");
    i0.ɵɵtemplate(15, AdaptSelectComponent_ng_container_13_div_2_ng_container_15_Template, 7, 7, "ng-container", 3);
    i0.ɵɵtext(16, "\n\n            ");
    i0.ɵɵtemplate(17, AdaptSelectComponent_ng_container_13_div_2_ng_container_17_Template, 8, 6, "ng-container", 3);
    i0.ɵɵtext(18, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(19, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n        ");
    i0.ɵɵtemplate(21, AdaptSelectComponent_ng_container_13_div_2_div_21_Template, 2, 1, "div", 28);
    i0.ɵɵtext(22, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n\n      ");
    i0.ɵɵelementStart(24, "div", 29);
    i0.ɵɵtext(25, "\n        ");
    i0.ɵɵelementStart(26, "div", 30);
    i0.ɵɵtext(27, "\n          ");
    i0.ɵɵelement(28, "div", 31);
    i0.ɵɵtext(29, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(30, "\n        ");
    i0.ɵɵelementStart(31, "span");
    i0.ɵɵtext(32);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(33, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(34, "\n\n      ");
    i0.ɵɵtemplate(35, AdaptSelectComponent_ng_container_13_div_2_ng_container_35_Template, 6, 3, "ng-container", 3);
    i0.ɵɵtext(36, "\n\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r22 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("max-height", ctx_r22.settings.maxHeight)("z-index", ctx_r22.settings.zIndex);
    i0.ɵɵclassProp("pull-right", ctx_r22.settings.pullRight)("select-hidden", !ctx_r22.isAnimationReady)("bottom-gap", !ctx_r22.isMobile)("dropdown-menu-right", ctx_r22.settings.pullRight)("dropdown-menu-mobile-placement", ctx_r22.isMobilePlacement)("sticky", ctx_r22.isMobilePlacement && ctx_r22.settings.stickyHeader)("is-top", ctx_r22.placement === "top");
    i0.ɵɵproperty("@selectAnim", ctx_r22.animationState)("ngClass", i0.ɵɵpureFunction2(31, _c9$1, ctx_r22.loadingState, ctx_r22.settings.stickyHeader));
    i0.ɵɵattribute("id", ctx_r22.popupId)("aria-describedby", ctx_r22.ariaDescribedBy)("aria-multiselectable", false);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", ctx_r22.settings.enableSearch);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r22.showHeader());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r22.displayedOptions && ctx_r22.displayedOptions.length !== 0);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r22.displayedOptions && ctx_r22.settings.checkedStyle !== "checkbox");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r22.displayedOptions && ctx_r22.settings.checkedStyle === "checkbox");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r22.displayedOptions && ctx_r22.displayedOptions.length === 0);
    i0.ɵɵadvance(11);
    i0.ɵɵtextInterpolate(ctx_r22.texts.loadingText);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r22.settings.pageSize && ctx_r22.showMoreButton);
} }
function AdaptSelectComponent_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptSelectComponent_ng_container_13_div_2_Template, 37, 34, "div", 19);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.isVisible);
} }
function AdaptSelectComponent_ng_container_16_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 64);
} if (rf & 2) {
    i0.ɵɵproperty("@selectOverlayAnim", undefined);
} }
function AdaptSelectComponent_ng_container_16_div_4_div_3_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r77 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 71);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_16_div_4_div_3_button_2_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r77); const ctx_r76 = i0.ɵɵnextContext(4); return ctx_r76.cancel(); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r73 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r73.texts.cancelBtnText);
} }
function AdaptSelectComponent_ng_container_16_div_4_div_3_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 72);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r74 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r74.texts.titleMobileText);
} }
function AdaptSelectComponent_ng_container_16_div_4_div_3_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r79 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 73);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_16_div_4_div_3_button_6_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r79); const ctx_r78 = i0.ɵɵnextContext(4); return ctx_r78.toggleDropdown(); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r75 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r75.texts.doneBtnText);
} }
const _c10$1 = function (a0) { return { "m-select__header_sticky": a0 }; };
function AdaptSelectComponent_ng_container_16_div_4_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 67);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptSelectComponent_ng_container_16_div_4_div_3_button_2_Template, 2, 1, "button", 68);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵtemplate(4, AdaptSelectComponent_ng_container_16_div_4_div_3_div_4_Template, 2, 1, "div", 69);
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵtemplate(6, AdaptSelectComponent_ng_container_16_div_4_div_3_button_6_Template, 2, 1, "button", 70);
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r69 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(4, _c10$1, ctx_r69.settings.stickyHeader));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r69.settings.cancelBtn);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r69.settings.titleMobile);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r69.settings.doneBtn && !ctx_r69.single);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_2_a_4_Template(rf, ctx) { if (rf & 1) {
    const _r88 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 80);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_2_a_4_Template_a_click_0_listener($event) { i0.ɵɵrestoreView(_r88); const ctx_r87 = i0.ɵɵnextContext(5); return ctx_r87.clearSearchFilter($event); });
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("@searchAnim", undefined);
} }
const _c11$1 = function (a0) { return { "m-select__controls_sticky": a0 }; };
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 77);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelement(2, "input", 78);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵtemplate(4, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_2_a_4_Template, 2, 1, "a", 79);
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r80 = i0.ɵɵnextContext(4);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(5, _c11$1, ctx_r80.settings.stickyHeader));
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("placeholder", ctx_r80.texts.searchPlaceholder);
    i0.ɵɵproperty("adaptFocusMonitor", -1)("formControl", ctx_r80.searchFilterText);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r80.searchFilterText.value.length > 0);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 37);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r81 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", ctx_r81.getHeaderText(), "\n        ");
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 81);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "span", 39);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n\n          ");
    i0.ɵɵelement(5, "adapt-custom-actions", 41);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r82 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("@openClose", ctx_r82.rtl ? ctx_r82.searchFilterText.value ? "showRTL" : "hideRTL" : ctx_r82.searchFilterText.value ? "show" : "hide");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate2("\n              ", ctx_r82.texts.filteredTo, " ", ctx_r82.getFilteredItems().length, "\n          ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("actions", ctx_r82.customActions);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_8_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r94 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 84, 45);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_8_button_2_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r94); const ctx_r93 = i0.ɵɵnextContext(5); return ctx_r93.setSelected($event, ctx_r93.nullOption); });
    i0.ɵɵtext(2, "\n            ");
    i0.ɵɵelementStart(3, "span", null, 46);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r89 = i0.ɵɵnextContext(5);
    i0.ɵɵclassProp("active", ctx_r89.isSelected(ctx_r89.nullOption));
    i0.ɵɵattribute("id", ctx_r89.id + "-" + ctx_r89.nullOption.id + "_item");
    i0.ɵɵadvance(3);
    i0.ɵɵstyleProp("white-space", ctx_r89.whiteSpaceOption)("word-break", ctx_r89.wordBreakOption)("font-style", "italic");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r89.nullOption.name);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_8_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r100 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 85, 45);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_8_button_4_Template_button_click_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r100); const option_r95 = restoredCtx.$implicit; const ctx_r99 = i0.ɵɵnextContext(5); return ctx_r99.setSelected($event, option_r95); });
    i0.ɵɵtext(2, "\n            ");
    i0.ɵɵelementStart(3, "span", null, 46);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r95 = ctx.$implicit;
    const index_r96 = ctx.index;
    const ctx_r90 = i0.ɵɵnextContext(5);
    i0.ɵɵclassProp("active", ctx_r90.isSelected(option_r95));
    i0.ɵɵproperty("disabled", option_r95.disabled);
    i0.ɵɵattribute("id", ctx_r90.id + "-" + index_r96 + "_item");
    i0.ɵɵadvance(3);
    i0.ɵɵstyleProp("white-space", ctx_r90.whiteSpaceOption)("word-break", ctx_r90.wordBreakOption);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(option_r95.name);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_8_button_2_Template, 7, 10, "button", 82);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵtemplate(4, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_8_button_4_Template, 7, 9, "button", 83);
    i0.ɵɵpipe(5, "slice");
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r83 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r83.settings.emptyOption && !ctx_r83.searchFilterText.value.length);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind3(5, 3, ctx_r83.displayedOptions, 0, ctx_r83.displayedOptionsCount))("ngForTrackBy", ctx_r83.optionsTrackByFn);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_adapt_icon_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-icon", 57);
    i0.ɵɵtext(1, "\n                    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r102 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", option_r102.icon)("classList", "text-" + option_r102.iconType);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_span_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 58);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r102 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("ngClass", "badge-" + option_r102.badgeType);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                      ", option_r102.badgeText, "\n                    ");
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_Template(rf, ctx) { if (rf & 1) {
    const _r111 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li", 88, 45);
    i0.ɵɵlistener("keydown.space", function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_Template_li_keydown_space_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r111); const option_r102 = restoredCtx.$implicit; const ctx_r110 = i0.ɵɵnextContext(5); return ctx_r110.setSelected($event, option_r102); })("keyup.enter", function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_Template_li_keyup_enter_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r111); const option_r102 = restoredCtx.$implicit; const ctx_r112 = i0.ɵɵnextContext(5); return ctx_r112.setSelected($event, option_r102); });
    i0.ɵɵtext(2, "\n              ");
    i0.ɵɵelementStart(3, "div", 51);
    i0.ɵɵtext(4, "\n                ");
    i0.ɵɵelementStart(5, "label", 52);
    i0.ɵɵtext(6, "\n                  ");
    i0.ɵɵelementStart(7, "input", 53);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_Template_input_click_7_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r111); const option_r102 = restoredCtx.$implicit; const ctx_r113 = i0.ɵɵnextContext(5); return ctx_r113.setSelected($event, option_r102); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n                  ");
    i0.ɵɵelementStart(9, "span", 54, 46);
    i0.ɵɵtext(11, "\n                    ");
    i0.ɵɵtemplate(12, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_adapt_icon_12_Template, 2, 3, "adapt-icon", 55);
    i0.ɵɵtext(13);
    i0.ɵɵtemplate(14, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_span_14_Template, 2, 2, "span", 56);
    i0.ɵɵtext(15, "\n                    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n                ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r102 = ctx.$implicit;
    const index_r103 = ctx.index;
    const ctx_r101 = i0.ɵɵnextContext(5);
    i0.ɵɵproperty("adaptFocusMonitor", option_r102.id);
    i0.ɵɵattribute("id", ctx_r101.id + "-" + index_r103 + "_item")("aria-selected", ctx_r101.isSelected(option_r102));
    i0.ɵɵadvance(7);
    i0.ɵɵproperty("disabled", option_r102.disabled)("checked", ctx_r101.isSelected(option_r102));
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("white-space", ctx_r101.whiteSpaceOption)("word-break", ctx_r101.wordBreakOption);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r101.allowIconsBadges && option_r102.icon);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                    ", option_r102.name, "\n                    ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r101.allowIconsBadges && option_r102.badgeText);
} }
const _c12 = function (a0) { return { "list-unstyled__load-more_mobile": a0 }; };
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n\n          ");
    i0.ɵɵelementStart(2, "ul", 86);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵtemplate(4, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_li_4_Template, 19, 12, "li", 87);
    i0.ɵɵpipe(5, "slice");
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r84 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(7, _c12, ctx_r84.settings.pageSize && ctx_r84.showMoreButton));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind3(5, 3, ctx_r84.displayedOptions, 0, ctx_r84.displayedOptionsCount))("ngForTrackBy", ctx_r84.optionsTrackByFn);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 89);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r85 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", ctx_r85.texts.notFound, "\n        ");
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_2_Template, 6, 7, "div", 74);
    i0.ɵɵtext(3, "\n\n        ");
    i0.ɵɵtemplate(4, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_4_Template, 2, 1, "div", 25);
    i0.ɵɵtext(5, "\n\n        ");
    i0.ɵɵtemplate(6, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_6_Template, 7, 4, "div", 75);
    i0.ɵɵtext(7, "\n\n        ");
    i0.ɵɵtemplate(8, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_8_Template, 7, 7, "ng-container", 3);
    i0.ɵɵtext(9, "\n\n        ");
    i0.ɵɵtemplate(10, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_ng_container_10_Template, 8, 9, "ng-container", 3);
    i0.ɵɵtext(11, "\n        ");
    i0.ɵɵtemplate(12, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_div_12_Template, 2, 1, "div", 76);
    i0.ɵɵtext(13, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r70 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r70.settings.enableSearch);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r70.showHeader);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r70.displayedOptions && ctx_r70.displayedOptions.length !== 0 && (ctx_r70.settings.showCheckAll || ctx_r70.settings.showUncheckAll));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r70.displayedOptions && ctx_r70.settings.checkedStyle !== "checkbox");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r70.displayedOptions && ctx_r70.settings.checkedStyle === "checkbox");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r70.displayedOptions && ctx_r70.displayedOptions.length === 0);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "div", 29);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "div", 30);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelement(6, "div", 31);
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementStart(9, "span");
    i0.ɵɵtext(10);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r71 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(10);
    i0.ɵɵtextInterpolate(ctx_r71.texts.loadingText);
} }
function AdaptSelectComponent_ng_container_16_div_4_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    const _r115 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "button", 90);
    i0.ɵɵlistener("click", function AdaptSelectComponent_ng_container_16_div_4_ng_container_9_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r115); const ctx_r114 = i0.ɵɵnextContext(3); return ctx_r114.loadMoreItems(); });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r72 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptInlineLoader", ctx_r72.loadingDataInProgress)("activeText", ctx_r72.texts.loadingText);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", ctx_r72.texts.loadMore, "\n        ");
} }
function AdaptSelectComponent_ng_container_16_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 65, 21);
    i0.ɵɵtext(2, "\n\n      ");
    i0.ɵɵtemplate(3, AdaptSelectComponent_ng_container_16_div_4_div_3_Template, 8, 6, "div", 66);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵtemplate(5, AdaptSelectComponent_ng_container_16_div_4_ng_container_5_Template, 14, 6, "ng-container", 3);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵtemplate(7, AdaptSelectComponent_ng_container_16_div_4_ng_container_7_Template, 13, 1, "ng-container", 3);
    i0.ɵɵtext(8, "\n\n      ");
    i0.ɵɵtemplate(9, AdaptSelectComponent_ng_container_16_div_4_ng_container_9_Template, 5, 3, "ng-container", 3);
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r67 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("max-height", ctx_r67.settings.maxHeight)("z-index", ctx_r67.settings.zIndex);
    i0.ɵɵclassProp("pull-right", ctx_r67.settings.pullRight)("dropdown-menu-right", ctx_r67.settings.pullRight);
    i0.ɵɵproperty("@selectMenuAnim", undefined);
    i0.ɵɵattribute("id", ctx_r67.popupId)("aria-describedby", ctx_r67.ariaDescribedBy)("aria-multiselectable", !ctx_r67.single);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r67.isMobile);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r67.loadingState);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r67.loadingState);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r67.settings.pageSize && ctx_r67.showMoreButton);
} }
function AdaptSelectComponent_ng_container_16_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptSelectComponent_ng_container_16_div_2_Template, 1, 1, "div", 62);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptSelectComponent_ng_container_16_div_4_Template, 11, 16, "div", 63);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.isVisible);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.isVisible);
} }
function AdaptSelectComponent_div_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 91);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "p", 92);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("@validationFeedbackChangeAnimation", ctx_r6.isError);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r6.displayMessage);
} }
const MULTISELECT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptSelectComponent),
    multi: true
};
let nextId$4 = 0;
let nextTestId = 0;
// eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
class AdaptSelectComponent extends AdaptRadarGenericDirective {
    constructor(filterSearch, _renderer, detection, element, _focusHandle, _scrollService, _changeDetectorRef, _ngZone, _layerService, _router, _differs, _eventManager, _dir, _resizeService, _injector, ts, _adaptRadarService, _entityName) {
        super(_adaptRadarService, element, _entityName ? _entityName : AdaptRadarAngularCustomEventName.AdaptSelect);
        this.filterSearch = filterSearch;
        this._renderer = _renderer;
        this.detection = detection;
        this.element = element;
        this._focusHandle = _focusHandle;
        this._scrollService = _scrollService;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this._layerService = _layerService;
        this._router = _router;
        this._differs = _differs;
        this._eventManager = _eventManager;
        this._dir = _dir;
        this._resizeService = _resizeService;
        this._injector = _injector;
        this.ts = ts;
        this.tooltipText = '';
        this.isError = false;
        this.numSelected = 0;
        this.isVisible = false;
        this.searchFilterText = new FormControl('');
        this.allowIconsBadges = false;
        this.animationState = 'close';
        this.rtl = false;
        /**
         * Is dropdown clicked flag
         */
        this.ddClick = false;
        this.defaultSettings = {
            pullRight: false,
            enableSearch: false,
            checkedStyle: 'simple',
            buttonClasses: '',
            selectionLimit: 0,
            closeOnSelect: false,
            autoUnselect: false,
            showCheckAll: false,
            showUncheckAll: false,
            showTooltip: false,
            dynamicTitleMaxItems: 1,
            maxHeight: null,
            showCheckedAll: false,
            hideLabel: false,
            cancelBtn: true,
            doneBtn: true,
            titleMobile: true,
            placement: 'auto',
            appendToBody: false,
            appendTo: null,
            positionTo: null,
            enablePositionTracking: false,
            positionTrackingIntervalMs: 50,
            truncateText: false,
            containerWidth: null,
            emptyOption: false,
            stickyHeader: true,
            modelFormat: SelectModelFormat.number
        };
        this.defaultTexts = {};
        this.nullOption = {
            id: null,
            name: null
        };
        this.showMoreButton = false;
        this.single = false;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaLabelledby = `adapt-select-aria-label-${nextId$4++}`;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        this.filterDebounceTime = 300;
        /**
         * Unique id of the element.
         */
        this.id = `adapt-select-${nextId$4++}`;
        /**
         * Unique id of the element.
         */
        this.testID = `adapt-select-${nextTestId++}`;
        this.emitModelChangeWithSingleValue = false;
        this.popoverPlacement = 'top';
        this.popoverTriggers = 'click';
        this.loadingState = false;
        this.loadingDataInProgress = false;
        this.readonly = false;
        // Outputs
        this.selectionLimitReached = new EventEmitter();
        this.dropdownClosed = new EventEmitter();
        this.dropdownOpened = new EventEmitter();
        this.modelArrayChanged = new EventEmitter();
        this.filterValueChanged = new EventEmitter();
        this._resizeSubject = new Subject();
        this._pageNumber = 1;
        this._focusMonitoringQueryList = new QueryList();
        this._destroyed$ = new ReplaySubject(1);
        /**
         * An object for manage wrapper's scroll.
         */
        this._scrollManager = null;
        this._disabled = false;
        this._required = false;
        /**
         * Document click handler
         */
        this.documentClickHandler = ((e) => {
            // Check if clicked node inside menu ViewChild to decide should we close dropdown
            // We include labelElement and toggleDropdownButton for correct work of toggleDropdown() method
            const el = e.target;
            if (el instanceof Node && this.menu.nativeElement.contains(el)
                || (this.labelElement && el instanceof Node && this.labelElement.nativeElement.contains(el))
                || (this.toggleDropdownBtn && el instanceof Node && this.toggleDropdownBtn.nativeElement.contains(el))) {
                return;
            }
            this.close();
        });
        // eslint-disable-next-line
        this.onModelChange = (_) => {
        };
        // eslint-disable-next-line
        this.onModelTouched = () => {
        };
        /**
         * Emits output with debounce if user filter for something
         */
        this.valueChangesSubscription = this.searchFilterText.valueChanges
            .pipe(debounceTime(this.filterDebounceTime))
            .subscribe((value) => {
            this._updateFilteredOptions();
            SafeCdr.detectChanges(this._changeDetectorRef);
            this.filterValueChanged.emit(value);
        });
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    set options(options) {
        this._options = options;
        this._updateFilteredOptions();
    }
    get isMobile() {
        return this.detection.deviceMobile();
    }
    set toggleStateValidation(value) {
        this.isError = value;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(v) {
        this._disabled = toBoolean(v);
    }
    get customClass() {
        return this._customClass;
    }
    set customClass(v) {
        this._renderer.addClass(this.element.nativeElement, v);
    }
    get required() {
        return this._required || hasRequiredValidator(this._ngControl);
    }
    set required(v) {
        this._required = toBoolean(v);
    }
    get isAttachedToBody() {
        return this.settings.appendToBody || this.isMobile || this.settings.appendTo === 'body';
    }
    get customActions() {
        return [
            {
                name: this.searchFilterText.value ? this.texts.checkAllFilter : this.texts.checkAll,
                visible: this.settings.showCheckAll && !this.isHiddenSelectFilteredButton(),
                onClick: this.checkAll.bind(this)
            },
            {
                name: this.searchFilterText.value ? this.texts.uncheckAllFilter : this.texts.uncheckAll,
                visible: this.settings.showUncheckAll && !this.isHiddenUncheckFilteredButton(),
                onClick: this.uncheckAll.bind(this)
            }
        ];
    }
    // Check if select was render from <adapt-list-selector> component to allow showing icons and badges
    // From other places showing icons and badges forbidden
    static _shouldAllowIconsBadges(ref) {
        if (ref && ref.nativeElement && ref.nativeElement.tagName) {
            return ref.nativeElement.tagName.toLowerCase() === 'adapt-list-selector';
        }
        else {
            return false;
        }
    }
    setDefaultTexts(translation) {
        this.defaultTexts.checkAll = translation['adapt.select.checkAll'];
        this.defaultTexts.checkAllFilter = translation['adapt.select.checkAllFilter'];
        this.defaultTexts.uncheckAll = translation['adapt.select.uncheckAll'];
        this.defaultTexts.uncheckAllFilter = translation['adapt.select.uncheckAllFilter'];
        this.defaultTexts.filteredTo = translation['adapt.select.filteredTo'];
        this.defaultTexts.checked = translation['adapt.select.checked'];
        this.defaultTexts.checkedPlural = translation['adapt.select.checkedPlural'];
        this.defaultTexts.checkedAll = translation['adapt.select.checkedAll'];
        this.defaultTexts.searchPlaceholder = translation['adapt.select.searchPlaceholder'];
        this.defaultTexts.defaultTitle = translation['adapt.select.defaultTitle'];
        this.defaultTexts.headerText = translation['adapt.select.headerText'];
        this.defaultTexts.headerTextSingle = translation['adapt.select.headerTextSingle'];
        this.defaultTexts.notFound = translation['adapt.select.notFound'];
        this.defaultTexts.requiredText = translation['adapt.common.required'];
        this.defaultTexts.cancelBtnText = translation['adapt.common.cancel'];
        this.defaultTexts.doneBtnText = translation['adapt.common.done'];
        this.defaultTexts.titleMobileText = translation['adapt.select.titleMobileText'];
        this.defaultTexts.loadingText = translation['adapt.select.loadingText'];
        this.defaultTexts.emptyOptionText = translation['adapt.select.emptyOptionText'];
        this.defaultTexts.loadMore = translation['adapt.select.loadMore'];
        this.defaultTexts.numberOptionsText = translation['adapt.select.numberOptionsText'];
    }
    writeValue(value) {
        if (!isUndefined$1(value)) {
            const valueArray = ((value == null || value === '') && !this.settings.emptyOption) ? [] : Array.isArray(value) ? value : [value];
            const modelValue = this.settings.modelFormat === SelectModelFormat.object && valueArray[0]
                ? valueArray[0].id
                : valueArray[0];
            this._setModelAndUpdateStateOnModelChange(valueArray, false);
            if (modelValue !== null) {
                this._modelDiffer = this._differs.find(this.model).create();
            }
        }
    }
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    truncateText(opt) {
        this.whiteSpaceOption = opt ? 'nowrap' : 'normal';
        this.textEllipsisOption = opt ? 'ellipsis' : 'inherit';
        this.wordBreakOption = opt ? 'inherit' : 'break-word';
    }
    loadMoreItems() {
        if (this.loadMoreCallback) {
            this.loadMoreCallback();
        }
        else {
            this._pageNumber++;
            this.showMoreButton = this.displayedOptions.length > this.displayedOptionsCount;
        }
        if (this.settings.enableSearch && this.searchFilterText.value !== '') {
            this._focusHandle.focusOnFirstElement();
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngOnInit() {
        this.popupId = this.id + '_popup';
        this.rtl = this._dir.value === 'rtl';
        this.settings = Object.assign(Object.assign({}, this.defaultSettings), this.settings);
        this.texts = Object.assign(Object.assign({}, this.defaultTexts), this.texts);
        // additional check for single select header
        // if someone already modified (translated) plural form we are setting it as default
        if (this.single && this.texts.headerText) {
            this.texts.headerTextSingle = this.texts.headerText;
        }
        this.title = this.texts.defaultTitle;
        this.nullOption.name = this.texts.emptyOptionText;
        this.allowIconsBadges = AdaptSelectComponent._shouldAllowIconsBadges(this.parentElementRef);
        this._ngZone.onStable.pipe(take(1)).subscribe(() => this._updateTitleView());
        /** Get scroll manager */
        if (this.isMobile) {
            this._scrollManager = this._scrollService.getScrollManager(document.body);
        }
        /** Truncate option */
        this.truncateText(this.settings.truncateText);
        this._ngControl = this._injector.get(NgControl, null);
    }
    get displayedOptionsCount() {
        var _a, _b;
        if (((_a = this.settings) === null || _a === void 0 ? void 0 : _a.pageSize) && !this.loadMoreCallback) {
            return this.settings.pageSize * this._pageNumber;
        }
        else {
            return ((_b = this.displayedOptions) === null || _b === void 0 ? void 0 : _b.length) || 0;
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._focusHandle.init(this._focusMonitoringQueryList);
        if (this.element) {
            this._focusHandle.registerKeyDown(this.element.nativeElement);
            this._resizeService.addResizeEventListener(this.element.nativeElement, this._resizeSubject.next.bind(this._resizeSubject));
            this._resizeSubject
                .pipe(throttleTime(100, asyncScheduler, { trailing: true }), takeUntil(this._destroyed$))
                .subscribe(() => {
                this._checkTooltipOption();
            });
        }
        this.focusMonitoring.changes
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            this._updateFocusMonitoringOnStable();
        });
    }
    onAnimationDone(event) {
        if (this.isAttachedToBody) {
            if (this._router) {
                this._router.events
                    .pipe(takeUntil(this._destroyed$))
                    .subscribe((n) => n instanceof NavigationStart ? this._detachFromBody() : '');
            }
        }
        if (event.toState === 'void') {
            this._detachFromBody();
        }
    }
    close(restoreToggleFocus = false) {
        if (!this.isVisible) {
            return;
        }
        this.isVisible = false;
        this.searchFilterText.setValue('');
        this._applyWrapperScroll();
        this.dropdownClosed.emit(this.model);
        this.animationState = 'close';
        this._updateErrorState();
        this.onModelTouched();
        if (this._removeTapEventListener) {
            this._removeTapEventListener();
        }
        this._layerService.removeComponent(this);
        if ((restoreToggleFocus || this.isAttachedToBody) && this.toggleDropdownBtn) {
            // for preventing jumping of focus
            this.toggleDropdownBtn.nativeElement.focus();
        }
        SafeCdr.markForCheck(this._changeDetectorRef);
        if (this._trackingTimerId) {
            clearInterval(this._trackingTimerId);
            this._trackingTimerId = null;
        }
    }
    open() {
        if (this.isVisible || this.disabled || this.readonly) {
            return;
        }
        this.isAnimationReady = false;
        this.isVisible = true;
        this._applyWrapperScroll();
        this._removeTapEventListener = this._eventManager.addGlobalEventListener('document', 'tap', this.documentClickHandler.bind(this));
        this._updateFocusMonitoringOnStable();
        this._ngZone.onStable
            .asObservable()
            .pipe(take(1), tap(() => {
            this._updateMenuWidth();
            this._attachToBody();
            this._enableTrackingAnchorPosition();
        }), delay(0), takeUntil(this._destroyed$))
            .subscribe(() => {
            this._focusOnSelectOption();
            if (this.isMobile) {
                // Prevent dropdown-menu height change on searching to avoid going behind the keyboard (adapt-angular#3399)
                const computedHeight = window.getComputedStyle(this.menu.nativeElement).height;
                this._renderer.setStyle(this.menu.nativeElement, 'minHeight', computedHeight);
            }
        });
        this.dropdownOpened.emit(this.model);
        this._addToLayoutService();
        this._updateFilteredOptions();
    }
    toggleDropdown() {
        if (this.disabled || this.readonly) {
            return;
        }
        if (this.isVisible) {
            this.close();
        }
        else {
            this.open();
        }
    }
    isSelected(option) {
        const modelValue = this._findModelBySelectedOption(option);
        return modelValue === null || isDefined(modelValue);
    }
    setSelected(e, option) {
        if (getEventKeyCode(e) === SPACE) {
            e.preventDefault();
        }
        if (option.disabled) {
            return;
        }
        if (!this.model) {
            this.model = [];
        }
        // don't call preventDefault or do logic below
        // e.preventDefault();
        // https://stackoverflow.com/questions/30426523/
        // according to this article should not call preventDefault or should do this logic
        // const checkboxEl = querySelectorChildrenAndSelf(e.currentTarget as HTMLElement, '.checkbox__input') as HTMLInputElement;
        // if (checkboxEl) {
        //   setTimeout(() => {
        //     checkboxEl.checked = this.isSelected(option);
        //   });
        // }
        const itemToRemove = this._findModelBySelectedOption(option);
        const { selectionLimit, autoUnselect, closeOnSelect } = this.settings;
        if (this.single) {
            if (!itemToRemove) {
                this._setModelAndUpdateStateOnModelChange([this._createModelItem(option)], true);
            }
            this.close(true);
        }
        else {
            if (!isUndefined$1(itemToRemove)) {
                this._removeModelItem(itemToRemove);
            }
            else {
                if ((selectionLimit === 0 || this.model.length < selectionLimit)) {
                    this._addModelItem(this._createModelItem(option));
                }
                else {
                    if (autoUnselect) {
                        this._autoUnselect(this._createModelItem(option));
                    }
                    else {
                        this.selectionLimitReached.emit(this.model.length);
                    }
                }
            }
            this._updateStateOnModelChange(true);
            if (closeOnSelect) {
                this.close(true);
            }
        }
        this._updateFocusMonitoringOnStable();
    }
    /** For better performance */
    optionsTrackByFn(index, option) {
        return option.id;
    }
    clearSearchFilter(e) {
        e.preventDefault();
        this.searchFilterText.setValue('');
        e.target.previousElementSibling.focus();
    }
    checkAll() {
        if (this.settings.enableSearch && this._options && this.searchFilterText.value !== '') {
            // union of selected items in model and filtered items
            this._setModelAndUpdateStateOnModelChange(union(this.model, this.getFilteredItems()), true);
        }
        else {
            this._setModelAndUpdateStateOnModelChange(this.getSelectableOptions()
                .map(item => this._createModelItem(item)), true);
        }
        this._updateFocusMonitoringOnStable();
    }
    uncheckAll() {
        if (this.settings.enableSearch && this._options && this.searchFilterText.value !== '') {
            this._setModelAndUpdateStateOnModelChange(differenceWith(this.model, this.getFilteredItems(), isEqual), true);
        }
        else {
            this._setModelAndUpdateStateOnModelChange([], true);
        }
        this._updateFocusMonitoringOnStable();
    }
    uncheckAllOnDelete(event) {
        if (hasKeyboardKeyCode(event, 'Backspace', BACKSPACE) || hasKeyboardKeyCode(event, 'Delete', DELETE)) {
            this.uncheckAll();
        }
    }
    isHiddenSelectFilteredButton() {
        return this.getSelectableFilteredOptions().every(option => this.isSelectedOption(option));
    }
    isHiddenUncheckFilteredButton() {
        return this.getSelectableFilteredOptions().every(option => !this.isSelectedOption(option));
    }
    isSelectedOption(option) {
        const optionId = option.id;
        return this.model && this.model.some(item => this.getSelectedItemId(item) === optionId);
    }
    getSelectedItemId(item) {
        return (typeof item === 'object' && item !== null) ? item.id : item;
    }
    notifyArrayChanged() {
        if (!this.model || !this._options) {
            this.modelArray = [];
        }
        else {
            const indexed = keyBy(this._options, 'id');
            const modelIds = this.settings.modelFormat === SelectModelFormat.number
                ? this.model
                : this.model.map(item => item.id);
            /**
             * pick({a: 1, b: 2, c: 3, d: 4}, ['a', 'e', 'f']); //=> {a: 1}
             */
            this.modelArray = pick(indexed, modelIds);
            this.modelArrayChanged.emit(this.modelArray);
        }
    }
    cancel() {
        if (!this.single) {
            this.uncheckAll();
        }
        this.close();
    }
    getFilteredItems() {
        return this.getSelectableFilteredOptions()
            .map(item => this._createModelItem(item));
    }
    getSelectableFilteredOptions() {
        const searchValue = this.searchFilterText.value;
        const selectableOptions = this.getSelectableOptions();
        return searchValue ? this.filterSearch.transform(selectableOptions, searchValue) : selectableOptions;
    }
    isDisabled(option) {
        return this.disabled || this.readonly || option.disabled
            || (isFunction(this.disabledOptionResolver) ? this.disabledOptionResolver(option) : false);
    }
    getSelectableOptions() {
        return this._options.filter(option => !this.isDisabled(option));
    }
    allOptionsDisabled() {
        return isFunction(this.disabledOptionResolver)
            ? this.displayedOptions.every(option => this.disabledOptionResolver(option))
            : false;
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngDoCheck() {
        if (this._modelDiffer && this.model) {
            // true: even if changed inside component
            if (this._modelDiffer.diff(this.model)) {
                this._onModelArrayModified();
            }
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngOnChanges(changes) {
        if (changes.options && changes.options.currentValue !== undefined) {
            if (this._options && this.texts && this.settings) {
                this._updateTitleView();
            }
        }
        if (changes.settings && !isUndefined$1(changes.settings.previousValue)) {
            this.settings = Object.assign(Object.assign({}, this.defaultSettings), this.settings);
        }
        if (changes.texts && !isUndefined$1(changes.texts.previousValue)) {
            this.texts = Object.assign(Object.assign({}, this.defaultTexts), this.texts);
            if (changes.texts.currentValue.defaultTitle) {
                this.title = changes.texts.currentValue.defaultTitle;
            }
            if (changes.texts.currentValue.emptyOptionText) {
                this.nullOption.name = changes.texts.currentValue.emptyOptionText;
            }
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngOnDestroy() {
        super.ngOnDestroy();
        this.close();
        this._detachFromBody();
        this._resizeService.removeResizeEventListener(this.element.nativeElement);
        this.valueChangesSubscription.unsubscribe();
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    showHeader() {
        let isTextEmpty;
        let isSearchEmpty = false;
        if (this.settings.enableSearch && this._options) {
            isSearchEmpty = this.filterSearch.transform(this._options, this.searchFilterText.value).length === 0;
        }
        if (this.single === true) {
            isTextEmpty = this.texts.headerTextSingle === '';
        }
        else {
            isTextEmpty = this.texts.headerText === '';
        }
        return !!(this._options && !isSearchEmpty && !isTextEmpty);
    }
    getHeaderText() {
        return (this.single === true) ? this.texts.headerTextSingle : this.texts.headerText;
    }
    getActiveDescendant() {
        return this.optionRef ? this.optionRef.nativeElement.id : null;
    }
    _updateFilteredOptions() {
        var _a;
        let displayedOptions;
        if (this.searchFilterText.value) { // no need to filter values
            displayedOptions = this._options && this.filterSearch.transform(this._options, this.searchFilterText.value);
        }
        else {
            displayedOptions = this._options;
        }
        this.displayedOptions = displayedOptions;
        if (((_a = this.settings) === null || _a === void 0 ? void 0 : _a.pageSize) && !this.loadMoreCallback) {
            this.showMoreButton = this.displayedOptions.length > this.displayedOptionsCount;
        }
    }
    _focusOnSelectOption() {
        if (this.single && this.model && this.model.length) {
            if (this.settings.enableSearch) {
                this._focusHandle.focusOnElement(-1);
            }
            else {
                const optId = this.getSelectedItemId(this.model[0]);
                const selectedOptInd = this.focusMonitoring.toArray().findIndex(item => item.optionId === optId);
                if (selectedOptInd >= 0) {
                    this._focusHandle.focusOnElement(selectedOptInd);
                }
                else {
                    // maybe unreal case
                    this._focusHandle.focusOnFirstElement();
                }
            }
        }
        else {
            this._focusHandle.focusOnFirstElement();
        }
    }
    /**
     * Update focusMonitor list
     *
     * Need to invoke after each DOM manipulation
     * to be sure that all visible focusable items
     * are available via keyboard
     */
    _updateFocusMonitoringOnStable() {
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            // Get all available focusMonitoring items
            const focusMonitoringList = this.focusMonitoring.toArray();
            // SelectAll/ClearAll actions are located in the child AdaptCustomActionsComponent component,
            // so we cant get them via @ViewChildren. Need to add them manually
            if (this.customActionsComponent) {
                const customActionsFocusList = this.customActionsComponent.focusMonitorDirectiveQueryList.toArray();
                if (this.settings.enableSearch) {
                    // When filter enabled
                    if (this.searchFilterText.value.length > 0) {
                        // When filter has value: filter clear button exist
                        focusMonitoringList.splice(2, 0, ...customActionsFocusList);
                    }
                    else {
                        // When filter has no value
                        focusMonitoringList.splice(1, 0, ...customActionsFocusList);
                    }
                }
                else {
                    focusMonitoringList.splice(0, 0, ...customActionsFocusList);
                }
            }
            // Reset internal focusMonitoringQueryList with actual focusable elements
            if (this.detection.isIE()) {
                // Update QueryList manually for IE 11 because QueryList.prototype.reset method does not work in IE11 properly
                // it triggers additional cd - which is the cause for dropdown to "blink" on first call to loadMore()
                this._focusMonitoringQueryList = new QueryList();
            }
            else {
                this._focusMonitoringQueryList.reset(focusMonitoringList);
            }
        });
    }
    _addToLayoutService() {
        this._layerService.addComponent(this, () => {
            this.close();
        });
    }
    _autoUnselect(item) {
        this._addModelItem(item);
        this._removeFirstModelItem();
    }
    _updateTitleView() {
        this._updateNumSelected();
        this._updateTitle();
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    _updateErrorState() {
        const model = this.model;
        const modelValue = this.settings.modelFormat === SelectModelFormat.object && model && model[0]
            ? model[0].id
            : model && model[0];
        // Cases like [''], [undefined], [false] - doesn't covered because such model values are not valid
        this.isError = this.required ? !(model && model.length && (modelValue !== null)) : false;
    }
    _updateNumSelected() {
        this.numSelected = this.model && this.model.length || 0;
    }
    _addModelItem(item) {
        return this._setModel([...this.model, item]);
    }
    _removeModelItem(itemToRemove) {
        return this._setModel(this.model.filter(item => item !== itemToRemove));
    }
    _removeFirstModelItem() {
        return this._setModel([...this.model.slice(1)]);
    }
    _setModel(newModel) {
        this.model = newModel;
        return newModel;
    }
    _setModelAndUpdateStateOnModelChange(newModel, updateErrorAndFireOnModelChangeEvent) {
        this._setModel(newModel);
        this._updateStateOnModelChange(updateErrorAndFireOnModelChangeEvent);
    }
    _updateStateOnModelChange(updateErrorAndFireOnModelChangeEvent) {
        this._updateTitleView();
        if (updateErrorAndFireOnModelChangeEvent) {
            this._updateErrorState();
            const valueToEmit = this.emitModelChangeWithSingleValue && this.single ?
                (this.model && this.model.length ? this.model[0] : null) :
                this.model;
            this.onModelChange(valueToEmit);
            // this.onModelChange();
        }
        this.notifyArrayChanged();
    }
    /**
     * updates the button title with the Selected choice
     */
    _updateTitle() {
        if (this.numSelected === 0) {
            this.title = this.texts.defaultTitle;
            this._checkTooltipOption();
        }
        else if (this.numSelected > 1 && this.single && this._options) {
            adaptWarn(`ADAPT-ANGULAR Warning! Single Select! Use only one selected value instead of ${this.model}`);
            if (this.model.length > 1) {
                this._setModel([this.model[this.model.length - 1]]);
            }
            this._filterDynamicMaxTitle();
        }
        else if (this.settings.dynamicTitleMaxItems >= this.numSelected && this._options) {
            this._filterDynamicMaxTitle();
            this._checkTooltipOption();
        }
        else {
            this._numSelectedTitle();
            this._checkTooltipOption(true);
        }
    }
    _getFilteredOptions() {
        let filteredOptions = [];
        // In case we have no options but model exists. For example for cases when options should be loaded on select opening
        if (this.settings.modelFormat === SelectModelFormat.object && this.model && this.model.length) {
            filteredOptions = this.model.filter((item) => {
                return isDefined(this._findModelBySelectedOption(item));
            });
            // In case we have options
        }
        else if (this._options && this._options.length) {
            filteredOptions = this._options.filter((option) => {
                return isDefined(this._findModelBySelectedOption(option));
            });
        }
        return filteredOptions;
    }
    _filterDynamicMaxTitle() {
        const filteredOptions = this._getFilteredOptions();
        if (filteredOptions.length === 0) {
            this.title = this.texts.defaultTitle;
        }
        else {
            this.title = filteredOptions.map((option) => option.name)
                .join(', ');
        }
    }
    _numSelectedTitle() {
        if (!this._options) {
            return;
        }
        const isEqual = () => this.model.length === this._options.length;
        const { checkedPlural, checked, checkedAll } = this.texts;
        this.settings.showCheckedAll && isEqual() ?
            this.title = `${checkedAll} ${checkedPlural}` :
            this.title = `${this.numSelected} ${this.numSelected === 1 ? checked : checkedPlural}`;
    }
    _updateMenuWidth() {
        if (!this.isMobile) {
            this._setMenuMinWidth(this.dropdownItem);
        }
    }
    _setMenuMinWidth(el) {
        if (el && el.toArray().length > 0) {
            this._renderer.setStyle(this.menu.nativeElement, 'minWidth', `${this.settings.containerWidth}px`);
        }
    }
    _attachToBody() {
        const { placement, appendToBody, positionTo, appendTo } = this.settings;
        if (this.menu && this.element) {
            const host = positionTo || this.element.nativeElement;
            const menu = this.menu.nativeElement;
            const labelElement = this.labelElement && this.labelElement.nativeElement;
            const menuStyle = (property, val) => this._renderer.setStyle(menu, property, val);
            this.placement = this._setPlacement(host, menu, placement);
            this.isAnimationReady = true;
            this.animationState = 'open';
            if (!this.isMobile && this.placement === 'top' && this.label) {
                menuStyle('marginBottom', `${-(labelElement.offsetHeight)}px`);
            }
            if (this.isAttachedToBody) {
                this._renderer.addClass(menu, 'dd-menu--in-body');
                this._renderer.appendChild(document.body, menu);
            }
            else if (appendTo) {
                this._renderer.appendChild(appendTo, menu);
            }
            if (this.isAttachedToBody || appendTo) {
                this._menuAttached = menu;
                if (!this.isMobile) {
                    menuStyle('maxWidth', `${host.offsetWidth}px`);
                    menuStyle('bottom', this.placement === 'top' ? 'auto' : '');
                    positionElements(host, menu, this.placement, appendToBody || appendTo === 'body');
                    if (this._menuKeyDownSubscription) {
                        this._menuKeyDownSubscription.unsubscribe();
                    }
                    this._menuKeyDownSubscription = this._focusHandle.registerKeyDown(menu);
                }
            }
        }
    }
    _setPlacement(host, menu, placement) {
        if (placement === 'auto') {
            const placements = availableTargetPlacements(host, menu);
            this.isMobilePlacement = placement.indexOf('mobile') !== -1 || !placements.length;
            if (placements.indexOf('top') !== -1 && placements.indexOf('bottom') === -1) {
                placement = 'top';
            }
            else {
                placement = 'bottom';
            }
        }
        return placement;
    }
    _detachFromBody() {
        if (this._menuAttached) {
            this._renderer.removeChild(document.body, this._menuAttached);
            this._menuAttached = null;
        }
    }
    _checkTooltipOption(isNumSelectedTitle = false) {
        if (this.settings.showTooltip && this.titleWidth) {
            /**
             * Additional func to parse the string for avoiding the issues
             */
            const parseString = (value, num = 10) => parseInt(value, num);
            this._ngZone.onStable
                .asObservable()
                .pipe(distinctUntilChanged(), take(1))
                .subscribe(() => {
                if (isNumSelectedTitle) {
                    const filteredOptions = this._getFilteredOptions();
                    if (filteredOptions.length) {
                        this.tooltipText = filteredOptions.map((option) => option.name).join(', ');
                    }
                }
                else {
                    const element = this.titleWidth.nativeElement;
                    const { parentElement } = element;
                    const computed = getComputedStyle(parentElement);
                    const paddingLeft = parseString(computed.paddingLeft);
                    const paddingRight = parseString(computed.paddingRight);
                    const total = paddingLeft + paddingRight + element.clientWidth;
                    parentElement.clientWidth < total ? this.tooltipText = this.title : this.tooltipText = '';
                }
            });
        }
    }
    _applyWrapperScroll() {
        if (this._scrollManager) {
            this.isMobile && this.isVisible ? this._scrollManager.hide(this) : this._scrollManager.show(this);
        }
    }
    _onModelArrayModified() {
        this._updateErrorState();
        this._updateTitleView();
    }
    _createModelItem(option) {
        return this.settings.modelFormat === SelectModelFormat.number
            ? option.id
            : { id: option.id, name: option.name };
    }
    _findModelBySelectedOption(option) {
        if (!this.model || !option) {
            return;
        }
        return this.model.find((item) => {
            if (isUndefined$1(item)) {
                return;
            }
            if (this.settings.emptyOption && item === null && option.id === null) {
                return true;
            }
            return item === option.id || (item && item.id === option.id);
        });
    }
    _enableTrackingAnchorPosition() {
        if ((this.settings.appendToBody || this.settings.appendTo === 'body') && this.settings.enablePositionTracking && !this.isMobile) {
            const getSizeAndPositionFromRect = (rect) => {
                return { height: rect.height, width: rect.width, left: rect.left, top: rect.top };
            };
            const anchor = this.settings.positionTo || this.element.nativeElement;
            let previousAnchorRect = getSizeAndPositionFromRect(anchor.getBoundingClientRect());
            this._trackingTimerId = window.setInterval(() => {
                const currentAnchorRect = getSizeAndPositionFromRect(anchor.getBoundingClientRect());
                if (!isEqual(previousAnchorRect, currentAnchorRect)) {
                    previousAnchorRect = currentAnchorRect;
                    this._attachToBody();
                    SafeCdr.detectChanges(this._changeDetectorRef);
                }
            }, this.settings.positionTrackingIntervalMs);
        }
    }
}
AdaptSelectComponent.ɵfac = function AdaptSelectComponent_Factory(t) { return new (t || AdaptSelectComponent)(i0.ɵɵdirectiveInject(AdaptSelectSearchFilter), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.AdaptFocusMonitorService), i0.ɵɵdirectiveInject(i1.ScrollManageService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LayerService), i0.ɵɵdirectiveInject(i3$1.Router, 8), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i4.EventManager), i0.ɵɵdirectiveInject(i2$1.Directionality), i0.ɵɵdirectiveInject(i1.ResizeService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i1.AdaptRadarAngularCustomEventName, 8)); };
AdaptSelectComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSelectComponent, selectors: [["adapt-select"]], viewQuery: function AdaptSelectComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$j, 5);
        i0.ɵɵviewQuery(_c1$f, 5);
        i0.ɵɵviewQuery(_c2$d, 5);
        i0.ɵɵviewQuery(_c3$9, 5);
        i0.ɵɵviewQuery(_c4$6, 5);
        i0.ɵɵviewQuery(_c5$5, 5);
        i0.ɵɵviewQuery(AdaptCustomActionsComponent, 5);
        i0.ɵɵviewQuery(_c6$3, 5);
        i0.ɵɵviewQuery(_c7$2, 5);
        i0.ɵɵviewQuery(AdaptFocusMonitorDirective, 5, AdaptFocusMonitorDirective);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menu = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterInput = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelElement = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toggleDropdownBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.titleWidth = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customActionsComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.loadMoreBtn = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropdownItem = _t);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.focusMonitoring = _t);
    } }, hostVars: 9, hostBindings: function AdaptSelectComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("id", ctx.id);
        i0.ɵɵclassProp("adapt-select", true)("adapt-select--mobile", ctx.isMobile)("is-responsive", ctx.settings.fullWidth)("is-error", ctx.isError);
    } }, inputs: { settings: "settings", showMoreButton: "showMoreButton", loadMoreCallback: "loadMoreCallback", texts: "texts", single: "single", label: "label", displayMessage: "displayMessage", ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"], filterDebounceTime: "filterDebounceTime", id: "id", testID: "testID", tooltipInputIcon: "tooltipInputIcon", tooltipInputText: "tooltipInputText", whiteSpaceOption: "whiteSpaceOption", emitModelChangeWithSingleValue: "emitModelChangeWithSingleValue", popoverIcon: "popoverIcon", popoverPlacement: "popoverPlacement", popoverTriggers: "popoverTriggers", popoverContent: "popoverContent", loadingState: "loadingState", loadingDataInProgress: "loadingDataInProgress", readonly: "readonly", disabledOptionResolver: "disabledOptionResolver", parentElementRef: "parentElementRef", options: "options", toggleStateValidation: "toggleStateValidation", disabled: "disabled", customClass: "customClass", required: "required" }, outputs: { selectionLimitReached: "selectionLimitReached", dropdownClosed: "dropdownClosed", dropdownOpened: "dropdownOpened", modelArrayChanged: "modelArrayChanged", filterValueChanged: "filterValueChanged" }, features: [i0.ɵɵProvidersFeature([
            MULTISELECT_VALUE_ACCESSOR,
            AdaptSelectSearchFilter,
            AdaptFocusMonitorService
        ]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 21, vars: 7, consts: [[1, "dropdown", "dropdown_select"], [1, "adapt-select-label-wrapper"], ["class", "form-control-label mb-1 d-inline-block", 3, "sr-only", "click", 4, "ngIf"], [4, "ngIf"], ["type", "button", "role", "button", "aria-haspopup", "listbox", "class", "dropdown-toggle btn btn-secondary", 3, "ngClass", "disabled", "is-active", "dropdown-toggle-up", "click", "keyup", 4, "ngIf"], ["class", "dropdown_select__error", 4, "ngIf"], [1, "form-control-label", "mb-1", "d-inline-block", 3, "click"], ["labelElement", ""], [1, "letter-space"], [1, "form-control-required"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip", 4, "ngIf"], [3, "adaptRadarDisableEventSending", "name", "placement", "adaptPopover", "triggers", 4, "ngIf"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip"], [3, "adaptRadarDisableEventSending", "name", "placement", "adaptPopover", "triggers"], ["type", "button", "role", "button", "aria-haspopup", "listbox", 1, "dropdown-toggle", "btn", "btn-secondary", 3, "ngClass", "disabled", "click", "keyup"], ["toggleDropdownBtn", ""], ["type", "button", "role", "button", "aria-haspopup", "listbox", 1, "dropdown-toggle", "btn", "btn-secondary", 3, "adaptRadarDisableEventSending", "adaptTooltip", "placement", "ngClass", "disabled", "click", "keyup"], [1, "dropdown-toggle-title"], ["titleWidth", ""], ["class", "dropdown_select__menu", "role", "listbox", 3, "pull-right", "select-hidden", "bottom-gap", "dropdown-menu-right", "dropdown-menu-mobile-placement", "sticky", "max-height", "zIndex", "is-top", "ngClass", 4, "ngIf"], ["role", "listbox", 1, "dropdown_select__menu", 3, "ngClass"], ["menu", ""], [1, "select_option_container"], ["class", "form-group d-icon-search dropdown_select__search", "tabindex", "-1", 4, "ngIf"], [1, "dropdown_select__menu-content-wrapper"], ["class", "dropdown-header", 4, "ngIf"], ["class", "d-flex dropdown-item", 4, "ngIf"], [1, "dropdown_select__menu-content"], ["role", "presentation", "class", "dropdown-header dropdown-help-text ng-scope", "tabindex", "-1", 4, "ngIf"], [1, "select-loader-container"], [1, "loader-container"], [1, "loader-section"], ["tabindex", "-1", 1, "form-group", "d-icon-search", "dropdown_select__search"], ["type", "text", "role", "searchbox", "adaptFocusMonitor", "", 1, "form-control", 3, "placeholder", "formControl"], ["filterInput", ""], ["type", "button", "adaptFocusMonitor", "", "class", "dropdown_select__search-cross d-icon-cross_adapt", 3, "click", 4, "ngIf"], ["type", "button", "adaptFocusMonitor", "", 1, "dropdown_select__search-cross", "d-icon-cross_adapt", 3, "click"], [1, "dropdown-header"], [1, "d-flex", "dropdown-item"], [1, "dropdown__counter"], ["class", "d-flex", 3, "actions", 4, "ngIf"], [1, "d-flex", 3, "actions"], ["class", "dropdown-item", "role", "option", "tabindex", "0", 3, "adaptFocusMonitor", "ngClass", "active", "click", 4, "ngIf"], ["class", "dropdown-item", "role", "option", "tabindex", "0", 3, "adaptFocusMonitor", "disabled", "ngClass", "active", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "option", "tabindex", "0", 1, "dropdown-item", 3, "adaptFocusMonitor", "ngClass", "click"], ["optionRef", ""], ["dropdownItem", ""], ["role", "option", "tabindex", "0", 1, "dropdown-item", 3, "adaptFocusMonitor", "disabled", "ngClass", "click"], [1, "list-unstyled"], ["class", "dropdown-item focusable", "tabindex", "0", "role", "option", 3, "adaptFocusMonitor", "keydown.space", "keyup.enter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["tabindex", "0", "role", "option", 1, "dropdown-item", "focusable", 3, "adaptFocusMonitor", "keydown.space", "keyup.enter"], [1, "checkbox"], [1, "checkbox__label", "d-block"], ["type", "checkbox", "tabindex", "-1", 1, "checkbox__input", 3, "disabled", "checked", "click"], [1, "checkbox__item"], ["class", "dropdown-item__icon", 3, "adaptRadarDisableEventSending", "name", "classList", 4, "ngIf"], ["class", "badge dropdown-item__badge", 3, "ngClass", 4, "ngIf"], [1, "dropdown-item__icon", 3, "adaptRadarDisableEventSending", "name", "classList"], [1, "badge", "dropdown-item__badge", 3, "ngClass"], ["role", "presentation", "tabindex", "-1", 1, "dropdown-header", "dropdown-help-text", "ng-scope"], ["type", "button", "role", "button", "adaptFocusMonitor", "", 1, "btn", "btn-link", 3, "adaptInlineLoader", "activeText", "click"], ["loadMoreBtn", ""], ["class", "dropdown_select__overlay", 4, "ngIf"], ["class", "dropdown_select__menu dropdown_select__menu--mobile", "role", "listbox", 3, "pull-right", "dropdown-menu-right", "max-height", "zIndex", 4, "ngIf"], [1, "dropdown_select__overlay"], ["role", "listbox", 1, "dropdown_select__menu", "dropdown_select__menu--mobile"], ["class", "m-select__header", 3, "ngClass", 4, "ngIf"], [1, "m-select__header", 3, "ngClass"], ["class", "m-select__button m-select__button--cancel", 3, "click", 4, "ngIf"], ["class", "m-select__title", 4, "ngIf"], ["class", "m-select__button m-select__button--done", 3, "click", 4, "ngIf"], [1, "m-select__button", "m-select__button--cancel", 3, "click"], [1, "m-select__title"], [1, "m-select__button", "m-select__button--done", 3, "click"], ["class", "form-group d-icon-search dropdown_select__search", 3, "ngClass", 4, "ngIf"], ["class", "d-flex dropdown-item dropdown_select__wrap", 4, "ngIf"], ["role", "presentation", "class", "dropdown-header dropdown-help-text ng-scope", 4, "ngIf"], [1, "form-group", "d-icon-search", "dropdown_select__search", 3, "ngClass"], ["type", "text", "aria-describedby", "sizing-addon3", 1, "form-control", 3, "adaptFocusMonitor", "placeholder", "formControl"], ["href", "#", "class", "dropdown_select__search-cross d-icon-cross_adapt", 3, "click", 4, "ngIf"], ["href", "#", 1, "dropdown_select__search-cross", "d-icon-cross_adapt", 3, "click"], [1, "d-flex", "dropdown-item", "dropdown_select__wrap"], ["class", "dropdown-item", "role", "option", "tabindex", "0", 3, "active", "click", 4, "ngIf"], ["class", "dropdown-item", "role", "option", "tabindex", "0", 3, "active", "disabled", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "option", "tabindex", "0", 1, "dropdown-item", 3, "click"], ["role", "option", "tabindex", "0", 1, "dropdown-item", 3, "disabled", "click"], [1, "list-unstyled", 3, "ngClass"], ["class", "dropdown-item focusable", "role", "option", "tabindex", "0", 3, "adaptFocusMonitor", "keydown.space", "keyup.enter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "option", "tabindex", "0", 1, "dropdown-item", "focusable", 3, "adaptFocusMonitor", "keydown.space", "keyup.enter"], ["role", "presentation", 1, "dropdown-header", "dropdown-help-text", "ng-scope"], ["type", "button", "role", "button", "adaptFocusMonitor", "", 1, "btn", "btn-link", "btn-link__load-more_mobile", 3, "adaptInlineLoader", "activeText", "click"], [1, "dropdown_select__error"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"]], template: function AdaptSelectComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelementStart(2, "div", 1);
        i0.ɵɵtext(3, "\n    ");
        i0.ɵɵtemplate(4, AdaptSelectComponent_span_4_Template, 7, 5, "span", 2);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵtemplate(6, AdaptSelectComponent_ng_container_6_Template, 7, 2, "ng-container", 3);
        i0.ɵɵtext(7, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n  ");
        i0.ɵɵtemplate(9, AdaptSelectComponent_button_9_Template, 3, 20, "button", 4);
        i0.ɵɵtext(10, "\n\n  ");
        i0.ɵɵtemplate(11, AdaptSelectComponent_ng_container_11_Template, 10, 20, "ng-container", 3);
        i0.ɵɵtext(12, "\n\n  ");
        i0.ɵɵtemplate(13, AdaptSelectComponent_ng_container_13_Template, 4, 1, "ng-container", 3);
        i0.ɵɵtext(14, "\n\n\n  ");
        i0.ɵɵtext(15, "\n\n  ");
        i0.ɵɵtemplate(16, AdaptSelectComponent_ng_container_16_Template, 6, 2, "ng-container", 3);
        i0.ɵɵtext(17, "\n\n  ");
        i0.ɵɵtemplate(18, AdaptSelectComponent_div_18_Template, 5, 3, "div", 5);
        i0.ɵɵtext(19, "\n\n\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.label);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.label && !ctx.settings.hideLabel);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.settings.showTooltip);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.settings.showTooltip);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.isMobile);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.isMobile);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.isError && ctx.displayMessage);
    } }, directives: [i3.NgIf, i1.AdaptIconComponent, i1.AdaptTooltipDirective, i1.AdaptPopoverDirective, i3.NgClass, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i1.AdaptFocusMonitorDirective, i6.NgControlStatus, i6.FormControlDirective, i1.AdaptCustomActionsComponent, i3.NgForOf, i1.AdaptInlineStandaloneDirective], pipes: [i3.SlicePipe], styles: ["\n    .btn-group .adapt-select {\n      margin-bottom: 0\n    }\n\n    .select-hidden {\n      visibility: hidden;\n    }\n\n    .dropdown_select .dropdown_select__search-cross {\n      border: none;\n      background: transparent;\n    }\n\n    .adapt-select--mobile .dropdown-item .checkbox__label .checkbox__item:before,\n    .adapt-select--mobile .dropdown-item .checkbox__label .checkbox__item:after {\n      top: 0.5rem;\n    }\n\n    .dropdown__counter {\n      display: inline-flex;\n      overflow: hidden;\n      color: #959799;\n      white-space: nowrap;\n      opacity: 0;\n      align-self: center;\n    }\n\n    .btn-link__load-more_mobile {\n      border: 0;\n      padding: 0.375rem .875rem;\n    }\n\n    .list-unstyled__load-more_mobile {\n      margin-bottom: 0;\n    }\n  "], encapsulation: 2, data: { animation: [
            trigger('selectMenuAnim', [
                transition('void => *', [
                    style({ bottom: '-100%', opacity: .2 }),
                    animate(`.4s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ bottom: '0', opacity: 1 }))
                ]),
                transition('* => void', [
                    style({ bottom: '0', opacity: 1 }),
                    animate(`.6s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ bottom: '-100%', opacity: 0 }))
                ])
            ]),
            trigger('selectOverlayAnim', [
                transition('void => *', [
                    style({ visibility: 'hidden', opacity: 0 }),
                    animate(`.6s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: 1 }))
                ]),
                transition('* => void', [
                    style({ visibility: 'visible', opacity: 1 }),
                    animate(`.6s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0 }))
                ])
            ]),
            trigger('selectAnim', [
                state('close', style({ transform: 'scale(.5)', opacity: '0' })),
                state('open', style({ transform: 'scale(1)', opacity: '1' })),
                transition('close => open', animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionOut}`)),
                transition(':leave', [
                    style({ transform: 'scale(1)', opacity: '1' }),
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionOut}`, style({ transform: 'scale(.5)', opacity: '0' }))
                ])
            ]),
            trigger('searchAnim', [
                transition('void => *', [
                    style({ visibility: 'hidden', opacity: 0 }),
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: .6 }))
                ]),
                transition('* => void', [
                    style({ visibility: 'visible', opacity: .6 }),
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0 }))
                ])
            ]),
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ]),
            trigger('validationFeedbackChangeAnimation', [
                transition('* => *', [
                    useAnimation(ANIMATION_NAME.opacity)
                ])
            ]),
            trigger('openClose', [
                state('show', style({
                    width: '*',
                    marginRight: '.875rem',
                    opacity: 1
                })),
                // '*, hide' have the same styles for the proper close animation
                state('*', style({
                    marginRight: '0',
                    width: '0px',
                    opacity: 0
                })),
                state('hide', style({
                    marginRight: '0',
                    width: '0px',
                    opacity: 0
                })),
                transition('show => hide', [
                    animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                ]),
                transition('hide => show', [
                    animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                ]),
                state('showRTL', style({
                    width: '*',
                    marginRight: '0',
                    marginLeft: '.875rem',
                    opacity: 1
                })),
                state('hideRTL', style({
                    marginRight: '-2px',
                    marginLeft: '0',
                    width: '0px',
                    opacity: 0
                })),
                transition('showRTL => hideRTL', [
                    animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                ]),
                transition('hideRTL => showRTL', [
                    animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                ])
            ]),
            trigger('actionsAnim', [
                state('show', style({
                    height: '*',
                    padding: '*',
                    opacity: 1
                })),
                state('*', style({
                    height: '0px',
                    padding: '0px',
                    opacity: 0
                })),
                state('hide', style({
                    height: '0px',
                    padding: '0px',
                    opacity: 0
                })),
                transition('show => hide', [
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                ]),
                transition('hide => show', [
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSelectComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-select',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.adapt-select]': 'true',
                    '[class.adapt-select--mobile]': 'isMobile',
                    '[class.is-responsive]': 'settings.fullWidth',
                    '[class.is-error]': 'isError',
                    '[attr.id]': 'id'
                },
                templateUrl: './select.component.html',
                // TODO: remove styles after the adapt-css package update
                styles: [`
    .btn-group .adapt-select {
      margin-bottom: 0
    }

    .select-hidden {
      visibility: hidden;
    }

    .dropdown_select .dropdown_select__search-cross {
      border: none;
      background: transparent;
    }

    .adapt-select--mobile .dropdown-item .checkbox__label .checkbox__item:before,
    .adapt-select--mobile .dropdown-item .checkbox__label .checkbox__item:after {
      top: 0.5rem;
    }

    .dropdown__counter {
      display: inline-flex;
      overflow: hidden;
      color: #959799;
      white-space: nowrap;
      opacity: 0;
      align-self: center;
    }

    .btn-link__load-more_mobile {
      border: 0;
      padding: 0.375rem .875rem;
    }

    .list-unstyled__load-more_mobile {
      margin-bottom: 0;
    }
  `],
                providers: [
                    MULTISELECT_VALUE_ACCESSOR,
                    AdaptSelectSearchFilter,
                    AdaptFocusMonitorService
                ],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('selectMenuAnim', [
                        transition('void => *', [
                            style({ bottom: '-100%', opacity: .2 }),
                            animate(`.4s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ bottom: '0', opacity: 1 }))
                        ]),
                        transition('* => void', [
                            style({ bottom: '0', opacity: 1 }),
                            animate(`.6s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ bottom: '-100%', opacity: 0 }))
                        ])
                    ]),
                    trigger('selectOverlayAnim', [
                        transition('void => *', [
                            style({ visibility: 'hidden', opacity: 0 }),
                            animate(`.6s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: 1 }))
                        ]),
                        transition('* => void', [
                            style({ visibility: 'visible', opacity: 1 }),
                            animate(`.6s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0 }))
                        ])
                    ]),
                    trigger('selectAnim', [
                        state('close', style({ transform: 'scale(.5)', opacity: '0' })),
                        state('open', style({ transform: 'scale(1)', opacity: '1' })),
                        transition('close => open', animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionOut}`)),
                        transition(':leave', [
                            style({ transform: 'scale(1)', opacity: '1' }),
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionOut}`, style({ transform: 'scale(.5)', opacity: '0' }))
                        ])
                    ]),
                    trigger('searchAnim', [
                        transition('void => *', [
                            style({ visibility: 'hidden', opacity: 0 }),
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: .6 }))
                        ]),
                        transition('* => void', [
                            style({ visibility: 'visible', opacity: .6 }),
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0 }))
                        ])
                    ]),
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ]),
                    trigger('validationFeedbackChangeAnimation', [
                        transition('* => *', [
                            useAnimation(ANIMATION_NAME.opacity)
                        ])
                    ]),
                    trigger('openClose', [
                        state('show', style({
                            width: '*',
                            marginRight: '.875rem',
                            opacity: 1
                        })),
                        // '*, hide' have the same styles for the proper close animation
                        state('*', style({
                            marginRight: '0',
                            width: '0px',
                            opacity: 0
                        })),
                        state('hide', style({
                            marginRight: '0',
                            width: '0px',
                            opacity: 0
                        })),
                        transition('show => hide', [
                            animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                        ]),
                        transition('hide => show', [
                            animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                        ]),
                        state('showRTL', style({
                            width: '*',
                            marginRight: '0',
                            marginLeft: '.875rem',
                            opacity: 1
                        })),
                        state('hideRTL', style({
                            marginRight: '-2px',
                            marginLeft: '0',
                            width: '0px',
                            opacity: 0
                        })),
                        transition('showRTL => hideRTL', [
                            animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                        ]),
                        transition('hideRTL => showRTL', [
                            animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                        ])
                    ]),
                    trigger('actionsAnim', [
                        state('show', style({
                            height: '*',
                            padding: '*',
                            opacity: 1
                        })),
                        state('*', style({
                            height: '0px',
                            padding: '0px',
                            opacity: 0
                        })),
                        state('hide', style({
                            height: '0px',
                            padding: '0px',
                            opacity: 0
                        })),
                        transition('show => hide', [
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                        ]),
                        transition('hide => show', [
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                        ])
                    ])
                ],
                preserveWhitespaces: true,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: AdaptSelectSearchFilter }, { type: i0.Renderer2 }, { type: i1.AdaptDeviceDetectionService }, { type: i0.ElementRef }, { type: i1.AdaptFocusMonitorService }, { type: i1.ScrollManageService }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.LayerService }, { type: i3$1.Router, decorators: [{
                type: Optional
            }] }, { type: i0.IterableDiffers }, { type: i4.EventManager }, { type: i2$1.Directionality }, { type: i1.ResizeService }, { type: i0.Injector }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i1.AdaptRadarAngularCustomEventName, decorators: [{
                type: Optional
            }] }]; }, { settings: [{
            type: Input
        }], showMoreButton: [{
            type: Input
        }], loadMoreCallback: [{
            type: Input
        }], texts: [{
            type: Input
        }], single: [{
            type: Input
        }], label: [{
            type: Input
        }], displayMessage: [{
            type: Input
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], filterDebounceTime: [{
            type: Input
        }], id: [{
            type: Input
        }], testID: [{
            type: Input
        }], tooltipInputIcon: [{
            type: Input
        }], tooltipInputText: [{
            type: Input
        }], whiteSpaceOption: [{
            type: Input
        }], emitModelChangeWithSingleValue: [{
            type: Input
        }], popoverIcon: [{
            type: Input
        }], popoverPlacement: [{
            type: Input
        }], popoverTriggers: [{
            type: Input
        }], popoverContent: [{
            type: Input
        }], loadingState: [{
            type: Input
        }], loadingDataInProgress: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disabledOptionResolver: [{
            type: Input
        }], selectionLimitReached: [{
            type: Output
        }], dropdownClosed: [{
            type: Output
        }], dropdownOpened: [{
            type: Output
        }], modelArrayChanged: [{
            type: Output
        }], filterValueChanged: [{
            type: Output
        }], menu: [{
            type: ViewChild,
            args: ['menu']
        }], filterInput: [{
            type: ViewChild,
            args: ['filterInput']
        }], labelElement: [{
            type: ViewChild,
            args: ['labelElement']
        }], toggleDropdownBtn: [{
            type: ViewChild,
            args: ['toggleDropdownBtn']
        }], titleWidth: [{
            type: ViewChild,
            args: ['titleWidth']
        }], optionRef: [{
            type: ViewChild,
            args: ['optionRef', { static: false }]
        }], dropdownItem: [{
            type: ViewChildren,
            args: ['dropdownItem']
        }], focusMonitoring: [{
            type: ViewChildren,
            args: [AdaptFocusMonitorDirective,
                { read: AdaptFocusMonitorDirective }]
        }], customActionsComponent: [{
            type: ViewChild,
            args: [AdaptCustomActionsComponent, { static: false }]
        }], loadMoreBtn: [{
            type: ViewChild,
            args: ['loadMoreBtn']
        }], parentElementRef: [{
            type: Input
        }], options: [{
            type: Input
        }], toggleStateValidation: [{
            type: Input
        }], disabled: [{
            type: Input
        }], customClass: [{
            type: Input
        }], required: [{
            type: Input
        }] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$i = ["list"];
function AdaptListComponent_adapt_rx_control_label_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-rx-control-label", 9);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("label", ctx_r0.label)("requiredLabel", ctx_r0.texts.requiredText)("showRequiredLabel", ctx_r0.required)("tooltip", ctx_r0.tooltipConfig);
} }
function AdaptListComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "adapt-empty-state", 10);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "div", 11);
    i0.ɵɵtext(5, "\n              ");
    i0.ɵɵprojection(6);
    i0.ɵɵtext(7, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("type", "objects")("label", ctx_r1.texts.notFound);
} }
function AdaptListComponent_ng_container_14_adapt_icon_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 19);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "dots");
} }
function AdaptListComponent_ng_container_14_adapt_icon_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 20);
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", item_r6.icon)("ngClass", "text-" + item_r6.iconType);
} }
function AdaptListComponent_ng_container_14_span_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 21);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("ngClass", "badge-" + item_r6.badgeType);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(item_r6.badgeText);
} }
function AdaptListComponent_ng_container_14_button_15_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 22);
    i0.ɵɵlistener("click", function AdaptListComponent_ng_container_14_button_15_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r16); const item_r6 = i0.ɵɵnextContext().$implicit; const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.deselectItem(item_r6.id); });
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelementStart(2, "span", 23);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n                ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const i_r7 = i0.ɵɵnextContext().index;
    const ctx_r11 = i0.ɵɵnextContext();
    i0.ɵɵproperty("disabled", ctx_r11.disabled);
    i0.ɵɵattribute("aria-labelledby", "deleteText-" + i_r7 + " name-" + i_r7);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("id", "deleteText-" + i_r7);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r11.texts.remove);
} }
const _c1$e = function (a0, a1) { return { "hover-disabled": a0, "disabled": a1 }; };
function AdaptListComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    const _r19 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "div", 12);
    i0.ɵɵlistener("cdkDragMoved", function AdaptListComponent_ng_container_14_Template_div_cdkDragMoved_2_listener() { i0.ɵɵrestoreView(_r19); const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.move(); });
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementStart(4, "div", 13);
    i0.ɵɵtext(5, "\n                ");
    i0.ɵɵtemplate(6, AdaptListComponent_ng_container_14_adapt_icon_6_Template, 1, 2, "adapt-icon", 14);
    i0.ɵɵtext(7, "\n                ");
    i0.ɵɵelementStart(8, "span", 15);
    i0.ɵɵlistener("keydown.ArrowUp", function AdaptListComponent_ng_container_14_Template_span_keydown_ArrowUp_8_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r19); const i_r7 = restoredCtx.index; const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.onUp($event, i_r7); })("keydown.ArrowDown", function AdaptListComponent_ng_container_14_Template_span_keydown_ArrowDown_8_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r19); const i_r7 = restoredCtx.index; const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.onDown($event, i_r7); });
    i0.ɵɵtext(9, "\n                    ");
    i0.ɵɵtemplate(10, AdaptListComponent_ng_container_14_adapt_icon_10_Template, 1, 3, "adapt-icon", 16);
    i0.ɵɵtext(11);
    i0.ɵɵtemplate(12, AdaptListComponent_ng_container_14_span_12_Template, 2, 2, "span", 17);
    i0.ɵɵtext(13, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n\n                ");
    i0.ɵɵtemplate(15, AdaptListComponent_ng_container_14_button_15_Template, 5, 4, "button", 18);
    i0.ɵɵtext(16, "\n\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r6 = ctx.$implicit;
    const i_r7 = ctx.index;
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("cdkDragDisabled", ctx_r3.disabled);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(9, _c1$e, ctx_r3.hideControls, ctx_r3.disabled));
    i0.ɵɵattribute("id", ctx_r3.id + "_item_" + i_r7);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !(ctx_r3.disabled || ctx_r3.readonly) && !!ctx_r3.enableDnD);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("id", "name-" + i_r7);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", item_r6.icon);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                  ", item_r6.name, "\n                  ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", item_r6.badgeText);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", !ctx_r3.readonly);
} }
function AdaptListComponent_div_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 24);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "p", 25);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r4.displayErrorMessage);
} }
function AdaptListComponent_div_20_p_2_strong_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "strong");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r23 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", error_r23.name, " ");
} }
function AdaptListComponent_div_20_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 25);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptListComponent_div_20_p_2_strong_2_Template, 2, 1, "strong", 4);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r23 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", error_r23.name);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", error_r23.text, "\n        ");
} }
function AdaptListComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 24);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptListComponent_div_20_p_2_Template, 4, 2, "p", 26);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r5._self.errors);
} }
const _c2$c = [[["", 8, "empty-text"]]];
const _c3$8 = function (a0) { return { "is-error": a0 }; };
const _c4$5 = [".empty-text"];
let listSelectorCount = 0;
class AdaptListComponent extends FormComponent {
    constructor(_renderer, element, _injector, _changeDetectorRef, _ngZone, ts, _adaptRadarService) {
        super(_injector, ts, _adaptRadarService, element, AdaptRadarAngularCustomEventName.AdaptList);
        this._renderer = _renderer;
        this.element = element;
        this._injector = _injector;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this._adaptRadarService = _adaptRadarService;
        this.createdList = [];
        this.isErrorExist = false;
        this.isEmptyState = false;
        this.hideControls = false;
        this._self = this;
        this.defaultSettings = {
            enableSearch: true,
            checkedStyle: 'checkbox',
            showCheckAll: true,
            showUncheckAll: true,
            hideLabel: false
        };
        this.defaultTexts = { selectTitle: '' };
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        this.listChanged = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        this.selectedIndexes = [];
        this.enableDnD = true;
        /**
         * Unique id of the element.
         */
        this.id = `list-selector-${listSelectorCount++}`;
        this._isTouched = false;
        this._onTouchedCallback = () => {
            return;
        };
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get customClass() {
        return this._customClass;
    }
    set customClass(v) {
        this._renderer.addClass(this.element.nativeElement, v);
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(v) {
        this._disabled = toBoolean(v);
    }
    get maxHeight() {
        return this._maxHeight;
    }
    set maxHeight(v) {
        this._renderer.setStyle(this.listEl.nativeElement, 'maxHeight', v);
    }
    set value(v) {
        this._value = v;
    }
    get value() {
        return this._value;
    }
    updateListOrder(listIndexes) {
        this.createdList = [];
        if (this.selectedIndexes !== listIndexes) {
            this.selectedIndexes = listIndexes;
        }
        /**
         * in case there is existing list that should be loaded
         * we need to show it in given particular order
         * that is why there is a sorting of options base on selectedIndexes
         */
        listIndexes.map(function (index) {
            const element = this.options.find(item => item.id === index);
            if (element) {
                this.createdList.push();
            }
        }.bind(this));
    }
    ngOnInit() {
        // Sending radar event directly to avoid issues with the premature invocation of "initControl" in parent ngOnInit()
        // ERROR NullInjectorError: R3InjectorError(AppModule)[NgControl -> NgControl -> NgControl]:
        // So do not call super.ngOnInit() here
        // TODO ?
        this._adaptRadarService.sendGenericComponentEvent(AdaptRadarAngularCustomEventName.AdaptList);
        this.settings = Object.assign(Object.assign({}, this.defaultSettings), this.settings);
        this.texts = Object.assign(Object.assign({}, this.defaultTexts), this.texts);
        this.refToElement = this.element;
        if (!this.displayErrorMessage) {
            this.displayErrorMessage = this.defaultError;
        }
        this.updateListOrder(this.selectedIndexes);
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        if (this.formControl) {
            super.initControl();
        }
        if (this.tooltipInputIcon && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipInputIcon,
                content: this.tooltipInputText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    setDefaultTexts(translation) {
        this.defaultTexts.requiredText = translation['adapt.common.required'];
        this.defaultTexts.remove = translation['adapt.listSelector.remove'];
        this.defaultTexts.notFound = translation['adapt.listSelector.notFound'];
        this.defaultTexts.selectTitle = translation['adapt.listSelector.selectTitle'];
        this.defaultError = translation['adapt.listSelector.error'];
    }
    writeValue(value) {
        if (value) {
            this.value = value;
        }
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    validate() {
        return;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    deselectItem(id) {
        /**
         *  without([1, 2, 1, 3, 4], [1, 2]); //=> [3, 4]
         */
        this.selectedIndexes = without(this.selectedIndexes, id);
        this._isTouched = true;
        this._onTouchedCallback();
        this.propagateChange(this.selectedIndexes);
    }
    updateListBuilder(obj) {
        /**
         *  need to convert obj to Array
         *  values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
         */
        const newItems = values(obj);
        /**
         *  identify values need to be deleted
         *  difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
         */
        const toBeRemoved = differenceWith(this.createdList, newItems, isEqual);
        /**
         * remove them
         *  without([1, 2, 1, 3, 4], 1, 2); //=> [3, 4]
         */
        const stay = without(this.createdList, ...toBeRemoved);
        /**
         *  now we need to add new values to the list
         *  union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
         */
        this.createdList = union(stay, newItems);
        if (this._isTouched) {
            this.propagateChange(this.createdList);
        }
    }
    onListAnimationDone(event) {
        if (event.fromState === 0 || event.toState === 0) {
            return;
        }
        this.isEmptyState = !this.createdList.length;
        this.updateModel();
    }
    onListAnimationStart(event) {
        if (event.fromState === 0 || event.toState === 0) {
            this.isEmptyState = !this.createdList.length;
            this.updateModel();
        }
    }
    dropdownClosed() {
        this._isTouched = true;
        this.checkValid();
        this._onTouchedCallback();
        this.propagateChange(this.createdList);
    }
    // defaultTitle: 'Available (' + this.opts.length + ')',
    updateSelectTitle() {
        // console.log(' (' + (this.options.length - this.selectedIndexes.length) + ')');
        // this.selectTexts.checkedPlural = this.texts.selectTitle + ' (' + (this.options.length - this.selectedIndexes.length) + ')';
        // this.selectTexts.defaultTitle = this.texts.selectTitle + ' (' + (this.options.length - this.selectedIndexes.length) + ')';
    }
    updateModel() {
        this.checkValid();
        this.listChanged.emit(this.createdList);
    }
    drop(event) {
        moveItemInArray(this.createdList, event.previousIndex, event.currentIndex);
        this.hideControls = false;
        this._updateControl();
    }
    onUp(e, prevIndex) {
        if (this.disabled || this.readonly) {
            return;
        }
        e.preventDefault(); // we do not want to scroll the page
        moveItemInArray(this.createdList, prevIndex, (prevIndex === 0) ? 0 : --prevIndex);
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            e.target.focus();
        });
        this._updateControl();
    }
    onDown(e, prevIndex) {
        if (this.disabled || this.readonly) {
            return;
        }
        e.preventDefault();
        let currentIndex = this.createdList.length;
        if (prevIndex !== this.createdList.length) {
            currentIndex = prevIndex++;
        }
        moveItemInArray(this.createdList, prevIndex, currentIndex);
        this._updateControl();
    }
    move() {
        this.hideControls = true;
    }
    checkValid() {
        this.isErrorExist = (this.required && !this.createdList.length && this._isTouched);
    }
    _updateControl() {
        this._isTouched = true;
        this._onTouchedCallback();
        this.propagateChange(this.createdList);
        this.updateModel();
    }
}
AdaptListComponent.ɵfac = function AdaptListComponent_Factory(t) { return new (t || AdaptListComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i1.AdaptRadarAngularService)); };
AdaptListComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptListComponent, selectors: [["adapt-list-selector"]], viewQuery: function AdaptListComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$i, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.listEl = _t.first);
    } }, hostVars: 1, hostBindings: function AdaptListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("id", ctx.id);
    } }, inputs: { selectedIndexes: "selectedIndexes", options: "options", settings: "settings", selectTexts: "selectTexts", texts: "texts", label: "label", enableDnD: "enableDnD", id: "id", name: "name", tooltipInputIcon: "tooltipInputIcon", tooltipInputText: "tooltipInputText", displayErrorMessage: "displayErrorMessage", formControl: "formControl", customClass: "customClass", disabled: "disabled", maxHeight: "maxHeight", updateListOrder: "updateListOrder" }, outputs: { listChanged: "listChanged", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptListComponent),
            createFormControlValidator(AdaptListComponent),
        ]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c4$5, decls: 23, vars: 18, consts: [[1, "adapt-list-selector", 3, "ngClass"], [3, "label", "requiredLabel", "showRequiredLabel", "tooltip", 4, "ngIf"], [1, "adapt-list"], [3, "options", "settings", "disabled", "readonly", "parentElementRef", "texts", "ngModel", "customClass", "ngModelChange", "modelArrayChanged", "dropdownClosed"], [4, "ngIf"], ["cdkDropList", "", 1, "adapt-list-container", 3, "cdkDropListDisabled", "cdkDropListDropped"], ["list", ""], [4, "ngFor", "ngForOf"], ["class", "has-danger", 4, "ngIf"], [3, "label", "requiredLabel", "showRequiredLabel", "tooltip"], [3, "type", "label"], [1, "empty-info"], ["cdkDrag", "", "cdkDragLockAxis", "y", 1, "adapt-list-builder__list-wrp", 3, "cdkDragDisabled", "cdkDragMoved"], [1, "adapt-list-item", 3, "ngClass"], ["class", "adapt-list-drag m-end-1", 3, "adaptRadarDisableEventSending", "name", 4, "ngIf"], ["tabindex", "0", 1, "adapt-list-name", 3, "id", "keydown.ArrowUp", "keydown.ArrowDown"], ["class", "adapt-list__icon", 3, "adaptRadarDisableEventSending", "name", "ngClass", 4, "ngIf"], ["class", "badge adapt-list__badge", 3, "ngClass", 4, "ngIf"], ["type", "button", "class", "d-icon-trash_adapt btn btn-link list-remove", 3, "disabled", "click", 4, "ngIf"], [1, "adapt-list-drag", "m-end-1", 3, "adaptRadarDisableEventSending", "name"], [1, "adapt-list__icon", 3, "adaptRadarDisableEventSending", "name", "ngClass"], [1, "badge", "adapt-list__badge", 3, "ngClass"], ["type", "button", 1, "d-icon-trash_adapt", "btn", "btn-link", "list-remove", 3, "disabled", "click"], [1, "sr-only", 3, "id"], [1, "has-danger"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngFor", "ngForOf"]], template: function AdaptListComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c2$c);
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵtemplate(3, AdaptListComponent_adapt_rx_control_label_3_Template, 1, 4, "adapt-rx-control-label", 1);
        i0.ɵɵtext(4, "\n\n      ");
        i0.ɵɵelementStart(5, "div", 2);
        i0.ɵɵtext(6, "\n        ");
        i0.ɵɵelementStart(7, "adapt-select", 3);
        i0.ɵɵlistener("ngModelChange", function AdaptListComponent_Template_adapt_select_ngModelChange_7_listener($event) { return ctx.selectedIndexes = $event; })("modelArrayChanged", function AdaptListComponent_Template_adapt_select_modelArrayChanged_7_listener($event) { return ctx.updateListBuilder($event); })("dropdownClosed", function AdaptListComponent_Template_adapt_select_dropdownClosed_7_listener() { return ctx.dropdownClosed(); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n        ");
        i0.ɵɵtemplate(9, AdaptListComponent_ng_container_9_Template, 10, 2, "ng-container", 4);
        i0.ɵɵtext(10, "\n\n        ");
        i0.ɵɵelementStart(11, "div", 5, 6);
        i0.ɵɵlistener("cdkDropListDropped", function AdaptListComponent_Template_div_cdkDropListDropped_11_listener($event) { return ctx.drop($event); })("@listAnimation.done", function AdaptListComponent_Template_div_animation_listAnimation_done_11_listener($event) { return ctx.onListAnimationDone($event); })("@listAnimation.start", function AdaptListComponent_Template_div_animation_listAnimation_start_11_listener($event) { return ctx.onListAnimationStart($event); });
        i0.ɵɵtext(13, "\n          ");
        i0.ɵɵtemplate(14, AdaptListComponent_ng_container_14_Template, 19, 12, "ng-container", 7);
        i0.ɵɵtext(15, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n\n      ");
        i0.ɵɵtemplate(18, AdaptListComponent_div_18_Template, 5, 2, "div", 8);
        i0.ɵɵtext(19, "\n\n      ");
        i0.ɵɵtemplate(20, AdaptListComponent_div_20_Template, 4, 2, "div", 8);
        i0.ɵɵtext(21, "\n\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(16, _c3$8, ctx.isErrorExist));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.settings.hideLabel);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("options", ctx.options)("settings", ctx.settings)("disabled", ctx.disabled)("readonly", ctx.readonly)("parentElementRef", ctx.refToElement)("texts", ctx.selectTexts)("ngModel", ctx.selectedIndexes)("customClass", "adapt-list-select");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.isEmptyState);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("cdkDropListDisabled", ctx.disabled || ctx.readonly || !ctx.enableDnD)("@listAnimation", ctx.createdList.length);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngForOf", ctx.createdList);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.isErrorExist && !ctx.formControl);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.formControl && ctx._self.errors.length > 0 && ctx._self.control.touched);
    } }, directives: [i3.NgClass, i3.NgIf, AdaptSelectComponent, i6.NgControlStatus, i6.NgModel, i5.CdkDropList, i3.NgForOf, i1.AdaptRxControlLabelComponent, i1.AdaptEmptyStateComponent, i5.CdkDrag, i1.AdaptIconComponent], encapsulation: 2, data: { animation: [
            trigger('listAnimation', [
                transition(':enter, * => 0', []),
                transition(':decrement', [
                    query('.adapt-list-builder__list-wrp:leave', [
                        style({ transform: 'scale(1)', opacity: 1, height: '*' }),
                        animate(ANIMATION_DURATION.medium + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ transform: 'scale(0.5)', opacity: 0, height: 0 }))
                    ], { optional: true })
                ]),
                transition(':increment', [
                    query('.adapt-list-builder__list-wrp:enter', [
                        style({ transform: 'scale(0.5)', opacity: 0 }),
                        animate(ANIMATION_DURATION.medium + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ transform: 'scale(1)', opacity: 1 }))
                    ], { optional: true })
                ]),
            ]),
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptListComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-list-selector',
                template: `
    <div class="adapt-list-selector" [ngClass]="{'is-error': isErrorExist}">
      <adapt-rx-control-label *ngIf="!settings.hideLabel"
                              [label]="label"
                              [requiredLabel]="texts.requiredText"
                              [showRequiredLabel]="required"
                              [tooltip]="tooltipConfig"></adapt-rx-control-label>

      <div class="adapt-list">
        <adapt-select [options]="options"
                      [settings]="settings"
                      [disabled]="disabled"
                      [readonly]="readonly"
                      [parentElementRef]="refToElement"
                      [texts]="selectTexts"
                      [(ngModel)]="selectedIndexes"
                      (modelArrayChanged)="updateListBuilder($event)"
                      (dropdownClosed)="dropdownClosed()"
                      [customClass]="'adapt-list-select'"></adapt-select>

        <ng-container *ngIf="isEmptyState">
          <adapt-empty-state [type]="'objects'" [label]="texts.notFound">
            <div class="empty-info">
              <ng-content select=".empty-text"></ng-content>
            </div>
          </adapt-empty-state>
        </ng-container>

        <div cdkDropList class="adapt-list-container" (cdkDropListDropped)="drop($event)" #list
             [cdkDropListDisabled]="disabled || readonly || !enableDnD"
             [@listAnimation]="createdList.length"
             (@listAnimation.done)="onListAnimationDone($event)"
             (@listAnimation.start)="onListAnimationStart($event)">
          <ng-container *ngFor="let item of createdList; let i = index">
            <div class="adapt-list-builder__list-wrp" cdkDrag cdkDragLockAxis="y" (cdkDragMoved)="move()"
                 [cdkDragDisabled]="disabled">
              <div class="adapt-list-item" [ngClass]="{'hover-disabled' : hideControls, 'disabled' : disabled }"
                   [attr.id]="id + '_item_' + i">
                <adapt-icon *ngIf="!(disabled || readonly) && !!enableDnD"
                            [adaptRadarDisableEventSending]="true"
                            [name]="'dots'"
                            class="adapt-list-drag m-end-1"></adapt-icon>
                <span class="adapt-list-name" tabindex="0"
                      (keydown.ArrowUp)="onUp($event, i)"
                      (keydown.ArrowDown)="onDown($event, i)"
                      [id]="'name-' + i">
                    <adapt-icon *ngIf="item.icon"
                                [adaptRadarDisableEventSending]="true"
                                [name]="item.icon"
                                class="adapt-list__icon"
                                [ngClass]="'text-' + item.iconType"></adapt-icon>
                  {{item.name}}
                  <span *ngIf="item.badgeText" class="badge adapt-list__badge"
                        [ngClass]="'badge-'+item.badgeType">{{item.badgeText}}</span>
                  </span>

                <button (click)="deselectItem(item.id)"
                        [disabled]="disabled"
                        *ngIf="!readonly"
                        type="button"
                        class="d-icon-trash_adapt btn btn-link list-remove"
                        [attr.aria-labelledby]="'deleteText-' + i + ' name-' + i">
                  <span [id]="'deleteText-' + i" class="sr-only">{{texts.remove}}</span>
                </button>

              </div>
            </div>
          </ng-container>
        </div>
      </div>

      <div class="has-danger" *ngIf="isErrorExist && !formControl" [@validationFeedbackAnimation]>
        <p class="form-control-feedback m-0 pt-1 pb-2">{{displayErrorMessage}}</p>
      </div>

      <div class="has-danger" *ngIf="formControl && _self.errors.length > 0 && _self.control.touched"
           [@validationFeedbackAnimation]>
        <p class="form-control-feedback m-0 pt-1 pb-2" *ngFor="let error of _self.errors">
          <strong *ngIf="error.name">{{error.name}} </strong>
          {{error.text}}
        </p>
      </div>

    </div>
  `,
                animations: [
                    trigger('listAnimation', [
                        transition(':enter, * => 0', []),
                        transition(':decrement', [
                            query('.adapt-list-builder__list-wrp:leave', [
                                style({ transform: 'scale(1)', opacity: 1, height: '*' }),
                                animate(ANIMATION_DURATION.medium + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ transform: 'scale(0.5)', opacity: 0, height: 0 }))
                            ], { optional: true })
                        ]),
                        transition(':increment', [
                            query('.adapt-list-builder__list-wrp:enter', [
                                style({ transform: 'scale(0.5)', opacity: 0 }),
                                animate(ANIMATION_DURATION.medium + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ transform: 'scale(1)', opacity: 1 }))
                            ], { optional: true })
                        ]),
                    ]),
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ],
                providers: [
                    createFormControlValueAccessor(AdaptListComponent),
                    createFormControlValidator(AdaptListComponent),
                ],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.id]': 'id'
                }
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.Injector }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.AdaptTranslateService }, { type: i1.AdaptRadarAngularService }]; }, { listEl: [{
            type: ViewChild,
            args: ['list', { static: true }]
        }], listChanged: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], selectedIndexes: [{
            type: Input
        }], options: [{
            type: Input
        }], settings: [{
            type: Input
        }], selectTexts: [{
            type: Input
        }], texts: [{
            type: Input
        }], label: [{
            type: Input
        }], enableDnD: [{
            type: Input
        }], id: [{
            type: Input
        }], name: [{
            type: Input
        }], tooltipInputIcon: [{
            type: Input
        }], tooltipInputText: [{
            type: Input
        }], displayErrorMessage: [{
            type: Input
        }], formControl: [{
            type: Input
        }], customClass: [{
            type: Input
        }], disabled: [{
            type: Input
        }], maxHeight: [{
            type: Input
        }], updateListOrder: [{
            type: Input
        }] }); })();

class AdaptSelectModule {
}
AdaptSelectModule.ɵfac = function AdaptSelectModule_Factory(t) { return new (t || AdaptSelectModule)(); };
AdaptSelectModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptSelectModule });
AdaptSelectModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            HammerModule,
            ReactiveFormsModule,
            AdaptIconModule,
            AdaptTooltipModule,
            AdaptPopoverModule.forRoot(),
            AdaptBusyModule,
            AdaptSelectSearchFilterModule,
            AdaptFocusMonitorDirectiveModule,
            AdaptDragonInputHandlerModule,
            AdaptCustomActionsModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSelectModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HammerModule,
                    ReactiveFormsModule,
                    AdaptIconModule,
                    AdaptTooltipModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptBusyModule,
                    AdaptSelectSearchFilterModule,
                    AdaptFocusMonitorDirectiveModule,
                    AdaptDragonInputHandlerModule,
                    AdaptCustomActionsModule
                ],
                exports: [AdaptSelectComponent],
                declarations: [AdaptSelectComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptSelectModule, { declarations: [AdaptSelectComponent], imports: [CommonModule,
        FormsModule,
        HammerModule,
        ReactiveFormsModule,
        AdaptIconModule,
        AdaptTooltipModule, i1.AdaptPopoverModule, AdaptBusyModule,
        AdaptSelectSearchFilterModule,
        AdaptFocusMonitorDirectiveModule,
        AdaptDragonInputHandlerModule,
        AdaptCustomActionsModule], exports: [AdaptSelectComponent] }); })();

class AdaptListSelectorModule {
    constructor(iconService) {
        iconService.registerIcons([ai_dots]);
    }
    static forRoot() {
        return {
            ngModule: AdaptListSelectorModule
        };
    }
}
AdaptListSelectorModule.ɵfac = function AdaptListSelectorModule_Factory(t) { return new (t || AdaptListSelectorModule)(i0.ɵɵinject(i1.AdaptIconConfig)); };
AdaptListSelectorModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptListSelectorModule });
AdaptListSelectorModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            DragDropModule,
            AdaptSelectModule,
            AdaptEmptyStateModule,
            AdaptIconModule,
            AdaptTooltipModule,
            AdaptPopoverModule,
            AdaptRxLabelModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptListSelectorModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    DragDropModule,
                    AdaptSelectModule,
                    AdaptEmptyStateModule,
                    AdaptIconModule,
                    AdaptTooltipModule,
                    AdaptPopoverModule,
                    AdaptRxLabelModule
                ],
                declarations: [AdaptListComponent],
                exports: [AdaptListComponent]
            }]
    }], function () { return [{ type: i1.AdaptIconConfig }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptListSelectorModule, { declarations: [AdaptListComponent], imports: [CommonModule,
        FormsModule,
        DragDropModule,
        AdaptSelectModule,
        AdaptEmptyStateModule,
        AdaptIconModule,
        AdaptTooltipModule,
        AdaptPopoverModule,
        AdaptRxLabelModule], exports: [AdaptListComponent] }); })();

function AdaptTextfieldIconsComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 2);
} if (rf & 2) {
    i0.ɵɵproperty("@textfieldIconAnim", undefined);
} }
function AdaptTextfieldIconsComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 3);
} if (rf & 2) {
    i0.ɵɵproperty("@textfieldIconAnim", undefined);
} }
class AdaptTextfieldIconsComponent {
    constructor() {
        this.error = false;
        this.success = false;
        this.iconValid = false;
        this.iconInvalid = false;
    }
}
AdaptTextfieldIconsComponent.ɵfac = function AdaptTextfieldIconsComponent_Factory(t) { return new (t || AdaptTextfieldIconsComponent)(); };
AdaptTextfieldIconsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTextfieldIconsComponent, selectors: [["adapt-textfield-icons"]], inputs: { error: "error", success: "success", iconValid: "iconValid", iconInvalid: "iconInvalid" }, decls: 4, vars: 2, consts: [["class", "form-control-danger form-control--icons", 4, "ngIf"], ["class", "form-control-success form-control--icons", 4, "ngIf"], [1, "form-control-danger", "form-control--icons"], [1, "form-control-success", "form-control--icons"]], template: function AdaptTextfieldIconsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵtemplate(1, AdaptTextfieldIconsComponent_span_1_Template, 1, 1, "span", 0);
        i0.ɵɵtext(2, "\n    ");
        i0.ɵɵtemplate(3, AdaptTextfieldIconsComponent_span_3_Template, 1, 1, "span", 1);
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.error && ctx.iconInvalid);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.success && ctx.iconValid);
    } }, directives: [i3.NgIf], encapsulation: 2, data: { animation: [trigger('textfieldIconAnim', [
                transition('void => *', [
                    style({ visibility: 'hidden', opacity: 0 }),
                    animate(`.5s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: 1 })),
                ]),
                transition('* => void', [
                    style({ visibility: 'visible', opacity: 1 }),
                    animate(`.15s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0 }))
                ])
            ])] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextfieldIconsComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-textfield-icons',
                template: `
    <span class="form-control-danger form-control--icons" *ngIf="error && iconInvalid" [@textfieldIconAnim]></span>
    <span class="form-control-success form-control--icons" *ngIf="success && iconValid" [@textfieldIconAnim]></span>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [trigger('textfieldIconAnim', [
                        transition('void => *', [
                            style({ visibility: 'hidden', opacity: 0 }),
                            animate(`.5s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: 1 })),
                        ]),
                        transition('* => void', [
                            style({ visibility: 'visible', opacity: 1 }),
                            animate(`.15s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0 }))
                        ])
                    ])],
                encapsulation: ViewEncapsulation.None,
            }]
    }], null, { error: [{
            type: Input
        }], success: [{
            type: Input
        }], iconValid: [{
            type: Input
        }], iconInvalid: [{
            type: Input
        }] }); })();
class AdaptTextFieldIconsModule {
    static forRoot() {
        return {
            ngModule: AdaptTextFieldIconsModule,
            providers: []
        };
    }
}
AdaptTextFieldIconsModule.ɵfac = function AdaptTextFieldIconsModule_Factory(t) { return new (t || AdaptTextFieldIconsModule)(); };
AdaptTextFieldIconsModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptTextFieldIconsModule });
AdaptTextFieldIconsModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextFieldIconsModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                exports: [AdaptTextfieldIconsComponent],
                declarations: [AdaptTextfieldIconsComponent],
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptTextFieldIconsModule, { declarations: [AdaptTextfieldIconsComponent], imports: [CommonModule], exports: [AdaptTextfieldIconsComponent] }); })();

// TODO update types if possible
const _c0$h = ["input"];
const _c1$d = ["inputTextWidthEl"];
function AdaptTextFieldComponent_adapt_textfield_icons_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-textfield-icons", 11);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("error", ctx_r0.isError)("success", !ctx_r0.isError)("iconValid", ctx_r0.iconValid)("iconInvalid", ctx_r0.iconInvalid);
} }
function AdaptTextFieldComponent_textarea_11_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "textarea", 12, 13);
    i0.ɵɵlistener("keydown", function AdaptTextFieldComponent_textarea_11_Template_textarea_keydown_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.onKeydown($event); })("keypress", function AdaptTextFieldComponent_textarea_11_Template_textarea_keypress_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.onKeypress($event); })("keyup", function AdaptTextFieldComponent_textarea_11_Template_textarea_keyup_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.onKeyup($event); })("ngModelChange", function AdaptTextFieldComponent_textarea_11_Template_textarea_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.value = $event; })("focus", function AdaptTextFieldComponent_textarea_11_Template_textarea_focus_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.onFocus($event); })("blur", function AdaptTextFieldComponent_textarea_11_Template_textarea_blur_0_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.onBlur($event); });
    i0.ɵɵtext(2, "  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r1.customClass, "");
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r1.readonly && ctx_r1.disabledStyleForReadonlyState);
    i0.ɵɵproperty("rows", ctx_r1.rows)("ngModel", ctx_r1.value)("disabled", ctx_r1.disabled)("required", ctx_r1.required)("autofocus", ctx_r1.autofocus)("readonly", ctx_r1.readonly)("placeholder", ctx_r1.placeholder ? ctx_r1.placeholder : "")("pattern", ctx_r1.pattern ? ctx_r1.pattern : ".*");
    i0.ɵɵattribute("name", ctx_r1.name)("aria-required", ctx_r1.required)("aria-invalid", !ctx_r1.disabled && !ctx_r1.control && !ctx_r1.validState && ctx_r1.isError)("aria-label", ctx_r1.arialabel || null)("aria-describedby", ctx_r1.ariaDescribedBy)("id", ctx_r1.id + "_textarea")("data-testid", ctx_r1.testID + "_textarea")("maxlength", ctx_r1.maxlength)("minlength", ctx_r1.minlength)("tabindex", ctx_r1.tabindex);
} }
function AdaptTextFieldComponent_input_13_Template(rf, ctx) { if (rf & 1) {
    const _r18 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "input", 14, 13);
    i0.ɵɵlistener("keydown", function AdaptTextFieldComponent_input_13_Template_input_keydown_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.onKeydown($event); })("keypress", function AdaptTextFieldComponent_input_13_Template_input_keypress_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.onKeypress($event); })("keyup", function AdaptTextFieldComponent_input_13_Template_input_keyup_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.onKeyup($event); })("ngModelChange", function AdaptTextFieldComponent_input_13_Template_input_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.value = $event; })("focus", function AdaptTextFieldComponent_input_13_Template_input_focus_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r22 = i0.ɵɵnextContext(); return ctx_r22.onFocus($event); })("blur", function AdaptTextFieldComponent_input_13_Template_input_blur_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r23 = i0.ɵɵnextContext(); return ctx_r23.onBlur($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r2.customClass, "");
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r2.readonly && ctx_r2.disabledStyleForReadonlyState)("textfield-padding-transition", ctx_r2.overflowText)("pl-0", ctx_r2.isTextOverflow && !ctx_r2.isRtl)("pr-0", ctx_r2.isTextOverflow && ctx_r2.isRtl);
    i0.ɵɵproperty("type", ctx_r2.type)("ngModel", ctx_r2.value)("disabled", ctx_r2.disabled)("required", ctx_r2.required)("autofocus", ctx_r2.autofocus)("readonly", ctx_r2.readonly)("autocomplete", ctx_r2.autocomplete ? ctx_r2.autocomplete : "on")("placeholder", ctx_r2.placeholder ? ctx_r2.placeholder : "")("pattern", ctx_r2.pattern ? ctx_r2.pattern : ".*");
    i0.ɵɵattribute("name", ctx_r2.name)("aria-required", ctx_r2.required)("aria-invalid", !ctx_r2.disabled && !ctx_r2.control && !ctx_r2.validState && ctx_r2.isError)("aria-label", ctx_r2.arialabel || null)("aria-describedby", ctx_r2.ariaDescribedBy)("id", ctx_r2.id + "_input")("data-testid", ctx_r2.testID + "_input")("maxlength", ctx_r2.maxlength)("minlength", ctx_r2.minlength)("min", ctx_r2.min)("max", ctx_r2.max)("step", ctx_r2.step)("tabindex", ctx_r2.tabindex);
} }
function AdaptTextFieldComponent_div_15_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 18);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r24.nestedSettings.addOnTextLeft);
} }
function AdaptTextFieldComponent_div_15_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 20);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r26 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("z-index", "34");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r26.nestedSettings.addOnTextRight);
} }
function AdaptTextFieldComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    const _r28 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptTextFieldComponent_div_15_div_2_Template, 5, 1, "div", 16);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementStart(4, "input", 14, 13);
    i0.ɵɵlistener("keydown", function AdaptTextFieldComponent_div_15_Template_input_keydown_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r27 = i0.ɵɵnextContext(); return ctx_r27.onKeydown($event); })("keypress", function AdaptTextFieldComponent_div_15_Template_input_keypress_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r29 = i0.ɵɵnextContext(); return ctx_r29.onKeypress($event); })("keyup", function AdaptTextFieldComponent_div_15_Template_input_keyup_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r30 = i0.ɵɵnextContext(); return ctx_r30.onKeyup($event); })("ngModelChange", function AdaptTextFieldComponent_div_15_Template_input_ngModelChange_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r31 = i0.ɵɵnextContext(); return ctx_r31.value = $event; })("focus", function AdaptTextFieldComponent_div_15_Template_input_focus_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r32 = i0.ɵɵnextContext(); return ctx_r32.onFocus($event); })("blur", function AdaptTextFieldComponent_div_15_Template_input_blur_4_listener($event) { i0.ɵɵrestoreView(_r28); const ctx_r33 = i0.ɵɵnextContext(); return ctx_r33.onBlur($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵtemplate(7, AdaptTextFieldComponent_div_15_div_7_Template, 5, 3, "div", 17);
    i0.ɵɵtext(8, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", ctx_r3.inputGroupClass);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.nestedSettings.addOnLeft);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r3.customClass, "");
    i0.ɵɵclassProp("textfield-padding-transition", ctx_r3.overflowText)("pl-0", ctx_r3.isTextOverflow && !ctx_r3.isRtl)("pr-0", ctx_r3.isTextOverflow && ctx_r3.isRtl);
    i0.ɵɵproperty("type", ctx_r3.type)("ngModel", ctx_r3.value)("disabled", ctx_r3.disabled)("required", ctx_r3.required)("autofocus", ctx_r3.autofocus)("readonly", ctx_r3.readonly)("autocomplete", ctx_r3.autocomplete ? ctx_r3.autocomplete : "on")("placeholder", ctx_r3.placeholder ? ctx_r3.placeholder : "")("pattern", ctx_r3.pattern ? ctx_r3.pattern : ".*");
    i0.ɵɵattribute("name", ctx_r3.name)("aria-required", ctx_r3.required)("aria-invalid", !ctx_r3.disabled && !ctx_r3.control && !ctx_r3.validState && ctx_r3.isError)("aria-label", ctx_r3.arialabel || null)("aria-describedby", ctx_r3.ariaDescribedBy)("id", ctx_r3.id + "_input")("data-testid", ctx_r3.testID + "_input")("maxlength", ctx_r3.maxlength)("minlength", ctx_r3.minlength)("min", ctx_r3.min)("max", ctx_r3.max)("step", ctx_r3.step)("tabindex", ctx_r3.tabindex);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r3.nestedSettings.addOnRight);
} }
function AdaptTextFieldComponent_div_18_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 23);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "span");
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r34 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("@validationFeedbackChangeAnimation", ctx_r34.isError);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r34.isError ? ctx_r34.errorMessage : !ctx_r34.isError && ctx_r34.isDirty ? ctx_r34.successMessage : "");
} }
function AdaptTextFieldComponent_div_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTextFieldComponent_div_18_p_2_Template, 5, 2, "p", 22);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.errorMessage && ctx_r4.errorMessage !== "" || ctx_r4.successMessage && ctx_r4.successMessage !== "");
} }
function AdaptTextFieldComponent_div_20_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 23);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r35 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n    ", ctx_r35.errorMessage, "\n  ");
} }
function AdaptTextFieldComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTextFieldComponent_div_20_p_2_Template, 2, 1, "p", 22);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.errorMessage && ctx_r5.errorMessage !== "");
} }
function AdaptTextFieldComponent_div_22_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 23);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r36 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n    ", ctx_r36.additionalMessage, "\n  ");
} }
function AdaptTextFieldComponent_div_22_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTextFieldComponent_div_22_p_2_Template, 2, 1, "p", 22);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.additionalMessage && ctx_r6.additionalMessage !== "");
} }
function AdaptTextFieldComponent_div_26_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 24, 25);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", ctx_r7.inputStyles);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r7.value);
} }
const _c2$b = [[["", "label-count", ""]], "*"];
const _c3$7 = ["[label-count]", "*"];
let nextId$3 = 0;
const noop$4 = () => {
    return;
};
const cssTextFieldClasses$1 = {
    FOCUS: 'is-focus',
    // REQUIRED: 'is-required', // not used yet
    // DIRTY: 'is-dirty',
    // NG_DIRTY: 'ng-dirty',
    NG_TOUCHED: 'ng-touched',
    // PRISTINE: 'is-pristine',
    FORM_SUCCESS: 'has-success',
    FORM_DANGER: 'has-danger',
    // VALID: 'form-control-success',
    // IN_VALID: 'form-control-danger'
};
const DISABLE_NATIVE_VALIDITY_CHECKING = new InjectionToken('disableNativeValidityChecking');
const ADAPT_TEXTFIELD_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptTextFieldComponent),
    multi: true
};
class AdaptTextFieldComponent extends AdaptRadarGenericDirective {
    constructor(elemRef, renderer, _resizeService, _dir, ts, _ngZone, _cdr, _injector, nativeCheckGlobalDisabled, _adaptRadarService) {
        super(_adaptRadarService, elemRef, AdaptRadarAngularCustomEventName.AdaptTextField);
        this.elemRef = elemRef;
        this.renderer = renderer;
        this._resizeService = _resizeService;
        this._dir = _dir;
        this.ts = ts;
        this._ngZone = _ngZone;
        this._cdr = _cdr;
        this._injector = _injector;
        this.nativeCheckGlobalDisabled = nativeCheckGlobalDisabled;
        /**
         * Public variables of textfield component
         */
        this.isError = false;
        this.isDirty = false;
        /**
         * addOnTextLeft: string; addOnTextRight: string; addOnLeft: boolean; addOnRight: boolean
         */
        this.nestedSettingsDefault = {
            addOnLeft: true,
            addOnRight: false,
            addOnTextLeft: '@'
        };
        this.inputStyles = null;
        this.isTextOverflow = false;
        this.isRtl = false;
        this.defaultTexts = {};
        this.overflowText = true;
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * The input element type {bs4 view}.
         */
        this.nested = false;
        /**
         * The input element type; by default is 'text'
         */
        this.type = 'text';
        /**
         * Unique id of the element.
         */
        this.id = `adapt-textfield-${nextId$3++}`;
        /**
         * Unique testID of the element.
         */
        this.testID = `adapt-textfield-${nextId$3++}`;
        /**
         * Whether the input is with success icon
         */
        this.iconValid = false;
        /**
         * Whether the input is with error icon
         */
        this.iconInvalid = true;
        /**
         * TabIndex attribute of the element
         */
        this.tabindex = null;
        /**
         * Maxlength attribute of the element
         */
        this.maxlength = null;
        /**
         * Minlength attribute of the element
         */
        this.minlength = 0;
        /**
         * Autocomplete attribute of the element.
         */
        this.autocomplete = 'off';
        /**
         * Whether the input is valid
         */
        this.validState = false;
        this.popoverPlacement = 'top';
        this.popoverTriggers = 'click';
        this.setInvalidState = false;
        this.debounceTime = 300;
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.focusEmitter = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.blurEmitter = new EventEmitter();
        this.valueChanged = new EventEmitter();
        this.inputKeydown = new EventEmitter();
        this.inputKeypress = new EventEmitter();
        this.inputKeyup = new EventEmitter();
        /**
         * Use disabled style for the control if [readonly]=true
         */
        this.disabledStyleForReadonlyState = false;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        /**
         * ControlValueAccessor required interface
         */
        this.onTouchedCallback = noop$4;
        /**
         * ControlValueAccessor required interface
         */
        this.onChangeCallback = noop$4;
        /**
         * Private variables of textfield component
         */
        this._required = false;
        this._disabled = false;
        this._readonly = false;
        this._rows = null;
        this._disableNativeValidityChecking = false;
        this._maxrows = -1;
        this._autofocus = false;
        this._destroyed$ = new ReplaySubject(1);
        this.el = elemRef.nativeElement;
        this.isRtl = _dir.value === 'rtl';
        this.renderer = renderer;
        const translation = ts.getCurrentLanguage();
        this._successMessage = this.defaultTexts.valid = translation['adapt.textfield.error.valid'];
        this._errorMessage = this.defaultTexts.invalid = translation['adapt.textfield.error.invalid'];
        this.requiredLabel = translation['adapt.common.required'];
    }
    /**
     * An object used to control when error/success messages are shown
     */
    get errorMessage() {
        return this._errorMessage;
    }
    set errorMessage(value) {
        this._errorMessage = value || this.defaultTexts.invalid;
    }
    get successMessage() {
        return this._successMessage;
    }
    set successMessage(value) {
        this._successMessage = value || this.defaultTexts.valid;
    }
    /** Whether the element is required. */
    get required() {
        return this._required || hasRequiredValidator(this.control || this._ngControl);
    }
    set required(value) {
        this._required = toBoolean(value);
    }
    /** Whether the element is disabled. */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = toBoolean(value);
    }
    /** Whether the element is readonly. */
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        this._readonly = toBoolean(value);
    }
    /** Whether the element is textarea. */
    get rows() {
        return this._rows;
    }
    set rows(value) {
        this._rows = toNumber(value);
    }
    /** Whether the element has maxrows. */
    get maxrows() {
        return this._maxrows;
    }
    set maxrows(value) {
        this._maxrows = toNumber(value);
    }
    /** Whether the element has autofocus. */
    get autofocus() {
        return this._autofocus;
    }
    set autofocus(value) {
        this._autofocus = toBoolean(value);
    }
    // @experimental
    get disableNativeValidityChecking() {
        return this._disableNativeValidityChecking;
    }
    set disableNativeValidityChecking(value) {
        this._disableNativeValidityChecking = toBoolean(value);
    }
    /** The input element's value. */
    get value() {
        return this._value;
    }
    set value(v) {
        if (v !== this._value) {
            this._value = v;
            this.onChangeCallback(v);
        }
    }
    get ariaLabel() {
        return this.arialabel;
    }
    set ariaLabel(v) {
        if (v) {
            this.arialabel = v;
        }
    }
    get inputGroupClass() {
        let groupClass = '';
        if (this.customClass) {
            const classList = this.customClass.split(' ');
            classList.forEach(cls => {
                if (cls === 'form-control-lg') {
                    groupClass = 'input-group-lg';
                }
                if (cls === 'form-control-sm') {
                    groupClass = 'input-group-sm';
                }
            });
        }
        return groupClass;
    }
    get additionalMessage() {
        if (this.control) {
            for (const propertyName in this.control.errors) {
                if (Object.prototype.hasOwnProperty.call(this.control.errors, propertyName) && this.control.touched) {
                    return this.errorMessage ? this.errorMessage : this.defaultTexts.invalid;
                }
            }
            if (this.control.valid) {
                return this.successMessage ? this.successMessage : this.defaultTexts.valid;
            }
            return null;
        }
    }
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(value) {
        if (this._value !== value) {
            this._value = value;
            if (this._value !== null) {
                this._applyTextOverflow();
                this.valueChanged.emit(this._value);
            }
        }
    }
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * setDisabledState(isDisabled: boolean)?: void
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngOnInit() {
        this.nestedSettings = Object.assign(Object.assign({}, this.nestedSettingsDefault), this.nestedSettings);
        if (this.tooltipIcon && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIcon,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
        this._ngControl = this._injector.get(NgControl, null);
    }
    ngOnChanges(changes) {
        if (changes.autofocus) {
            this.setFocus();
        }
        // move from setter due to https://github.com/angular/angular/issues/32756
        if (changes.required) {
            SafeCdr.detectChanges(this._cdr);
        }
    }
    ngAfterContentChecked() {
        this.checkIfValid();
    }
    /**
     * Callback for the cases where the focused state of the input changes
     */
    onFocus(event) {
        this.renderer.addClass(this.el, cssTextFieldClasses$1.FOCUS);
        this.focusEmitter.emit(event);
    }
    /**
     * Callback for the cases where the focused state is out of input element
     */
    onBlur(event) {
        this.renderer.addClass(this.el, cssTextFieldClasses$1.FOCUS);
        this.onTouchedCallback();
        this.blurEmitter.emit(event);
    }
    /**
     * Check the input element on touch event
     */
    checkOnTouch() {
        if (this.inputElement) {
            this.isDirty = this.inputElement.nativeElement.classList.contains(cssTextFieldClasses$1.NG_TOUCHED);
        }
    }
    /**
     * Check the input element on valid/invalid state
     */
    checkIfValid() {
        if (this.nativeCheckGlobalDisabled === true) {
            return;
        }
        if (this.disableNativeValidityChecking) {
            return;
        }
        if (this.disabled) {
            this._setSuccessState();
            return;
        }
        this.checkOnTouch();
        if (this.setInvalidState && this.inputElement && this.inputElement.nativeElement.validity) {
            this._setErrorState();
            this.inputElement.nativeElement.classList.add(cssTextFieldClasses$1.NG_TOUCHED);
            this.isDirty = true;
            return;
        }
        if (this.inputElement && this.inputElement.nativeElement.validity && this.isDirty) {
            if (!this.inputElement.nativeElement.validity.valid) {
                this._setErrorState();
            }
            else {
                this._setSuccessState();
            }
        }
    }
    onKeydown(event) {
        this.inputKeydown.emit(event);
    }
    onKeypress(event) {
        this.inputKeypress.emit(event);
    }
    onKeyup(event) {
        this.inputKeyup.emit(event);
        const input = this.inputElement.nativeElement;
        if (this.maxlength && input.value && input.value.toString().length > this.maxlength) {
            input.value = input.value.toString().substring(0, this.maxlength);
            this.value = input.value.toString().substring(0, this.maxlength);
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        const input = this.inputElement.nativeElement;
        this._isInput = input.nodeName === 'INPUT';
        if (this._isInput && this.overflowText) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this.inputStyles = Object.assign({}, getElementStyles(input));
            });
            this._resizeService.addResizeEventListener(this.elemRef.nativeElement, debounce(this._applyTextOverflow.bind(this), 100));
        }
        fromEvent(input, 'input')
            .pipe(debounceTime(this.debounceTime), distinctUntilChanged(), tap(this._applyTextOverflow.bind(this)), takeUntil(this._destroyed$))
            .subscribe(() => this.valueChanged.emit(this.value));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._resizeService.removeResizeEventListener(this.elemRef.nativeElement);
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    _applyTextOverflow() {
        if (this.overflowText && this.inputElement && this.inputTextWidthEl && this._isInput) {
            const div = this.inputTextWidthEl.nativeElement;
            const input = this.inputElement.nativeElement;
            this.isTextOverflow = div.clientWidth > input.clientWidth;
        }
    }
    _setErrorState() {
        this.isError = true;
        this.renderer.addClass(this.el, cssTextFieldClasses$1.FORM_DANGER);
        if (this.validState) {
            this.renderer.removeClass(this.el, cssTextFieldClasses$1.FORM_SUCCESS);
        }
    }
    _setSuccessState() {
        this.isError = false;
        this.renderer.removeClass(this.el, cssTextFieldClasses$1.FORM_DANGER);
        if (this.validState) {
            this.renderer.addClass(this.el, cssTextFieldClasses$1.FORM_SUCCESS);
        }
    }
    setFocus() {
        if (!this.autofocus) {
            return;
        }
        /**
         * hot fix for autofocus attr in FF and IE
         */
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this.inputElement.nativeElement.focus();
        });
    }
}
AdaptTextFieldComponent.ɵfac = function AdaptTextFieldComponent_Factory(t) { return new (t || AdaptTextFieldComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.ResizeService), i0.ɵɵdirectiveInject(i2$1.Directionality), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(DISABLE_NATIVE_VALIDITY_CHECKING, 8), i0.ɵɵdirectiveInject(i2.AdaptRadarService)); };
AdaptTextFieldComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTextFieldComponent, selectors: [["adapt-textfield"], ["div", "form-group", ""]], viewQuery: function AdaptTextFieldComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$h, 5);
        i0.ɵɵviewQuery(_c1$d, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputTextWidthEl = _t.first);
    } }, hostVars: 7, hostBindings: function AdaptTextFieldComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("id", ctx.id);
        i0.ɵɵclassProp("form-group", true)("textfield", true)("is-icons", ctx.iconValid && ctx.validState || ctx.iconInvalid && ctx.isError);
    } }, inputs: { overflowText: "overflowText", nested: "nested", nestedSettings: "nestedSettings", customClass: "customClass", label: "label", type: "type", id: "id", testID: "testID", icon: "icon", iconValid: "iconValid", iconInvalid: "iconInvalid", tabindex: "tabindex", maxlength: "maxlength", minlength: "minlength", placeholder: "placeholder", autocomplete: "autocomplete", pattern: "pattern", min: "min", max: "max", step: "step", name: "name", validState: "validState", requiredLabel: "requiredLabel", tooltipIcon: "tooltipIcon", tooltipText: "tooltipText", popoverIcon: "popoverIcon", popoverPlacement: "popoverPlacement", popoverTriggers: "popoverTriggers", popoverContent: "popoverContent", errorMessage: ["error", "errorMessage"], successMessage: ["success", "successMessage"], control: "control", setInvalidState: "setInvalidState", debounceTime: "debounceTime", required: "required", disabled: "disabled", readonly: "readonly", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", rows: "rows", maxrows: "maxrows", autofocus: "autofocus", disableNativeValidityChecking: "disableNativeValidityChecking", ariaLabel: "ariaLabel", ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"] }, outputs: { focusEmitter: "focus", blurEmitter: "blur", valueChanged: "valueChanged", inputKeydown: "inputKeydown", inputKeypress: "inputKeypress", inputKeyup: "inputKeyup" }, features: [i0.ɵɵProvidersFeature([ADAPT_TEXTFIELD_ACCESSOR]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c3$7, decls: 31, vars: 13, consts: [[1, "adapt-textfield-label-wrapper"], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [1, "textfield__wrapper"], [3, "error", "success", "iconValid", "iconInvalid", 4, "ngIf"], [3, "rows", "class", "form-control-disabled-look", "ngModel", "disabled", "required", "autofocus", "readonly", "placeholder", "pattern", "keydown", "keypress", "keyup", "ngModelChange", "focus", "blur", 4, "ngIf"], [3, "class", "form-control-disabled-look", "textfield-padding-transition", "pl-0", "pr-0", "type", "ngModel", "disabled", "required", "autofocus", "readonly", "autocomplete", "placeholder", "pattern", "keydown", "keypress", "keyup", "ngModelChange", "focus", "blur", 4, "ngIf"], ["class", "input-group", 3, "ngClass", 4, "ngIf"], ["role", "alert", 4, "ngIf"], [4, "ngIf"], [1, "textfield-input-wrapper"], ["class", "textfield-input-element-copy", 3, "ngStyle", 4, "ngIf"], [3, "error", "success", "iconValid", "iconInvalid"], [3, "rows", "ngModel", "disabled", "required", "autofocus", "readonly", "placeholder", "pattern", "keydown", "keypress", "keyup", "ngModelChange", "focus", "blur"], ["input", ""], [3, "type", "ngModel", "disabled", "required", "autofocus", "readonly", "autocomplete", "placeholder", "pattern", "keydown", "keypress", "keyup", "ngModelChange", "focus", "blur"], [1, "input-group", 3, "ngClass"], ["class", "input-group-prepend", 4, "ngIf"], ["class", "input-group-append", 3, "zIndex", 4, "ngIf"], [1, "input-group-prepend"], [1, "input-group-text"], [1, "input-group-append"], ["role", "alert"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngIf"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"], [1, "textfield-input-element-copy", 3, "ngStyle"], ["inputTextWidthEl", ""]], template: function AdaptTextFieldComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c2$b);
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelement(2, "adapt-rx-control-label", 1);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵprojection(4);
        i0.ɵɵtext(5, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n\n");
        i0.ɵɵelementStart(7, "div", 2);
        i0.ɵɵtext(8, "\n\n  ");
        i0.ɵɵtemplate(9, AdaptTextFieldComponent_adapt_textfield_icons_9_Template, 1, 4, "adapt-textfield-icons", 3);
        i0.ɵɵtext(10, "\n\n  ");
        i0.ɵɵtemplate(11, AdaptTextFieldComponent_textarea_11_Template, 3, 23, "textarea", 4);
        i0.ɵɵtext(12, "\n\n  ");
        i0.ɵɵtemplate(13, AdaptTextFieldComponent_input_13_Template, 2, 33, "input", 5);
        i0.ɵɵtext(14, "\n\n  ");
        i0.ɵɵtemplate(15, AdaptTextFieldComponent_div_15_Template, 9, 34, "div", 6);
        i0.ɵɵtext(16, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n\n");
        i0.ɵɵtemplate(18, AdaptTextFieldComponent_div_18_Template, 4, 2, "div", 7);
        i0.ɵɵtext(19, "\n\n");
        i0.ɵɵtemplate(20, AdaptTextFieldComponent_div_20_Template, 4, 2, "div", 7);
        i0.ɵɵtext(21, "\n\n");
        i0.ɵɵtemplate(22, AdaptTextFieldComponent_div_22_Template, 4, 2, "div", 8);
        i0.ɵɵtext(23, "\n\n");
        i0.ɵɵelementStart(24, "div", 9);
        i0.ɵɵtext(25, "\n  ");
        i0.ɵɵtemplate(26, AdaptTextFieldComponent_div_26_Template, 3, 2, "div", 10);
        i0.ɵɵtext(27, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(28, "\n\n");
        i0.ɵɵprojection(29, 1);
        i0.ɵɵtext(30, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.rows ? ctx.id + "_textarea" : ctx.id + "_input")("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngIf", ctx.iconValid || ctx.iconInvalid);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.rows);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.rows && !ctx.nested);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.rows && ctx.nested);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.disabled && !ctx.control && ctx.validState && (ctx.isError || !ctx.isError && ctx.isDirty));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.disabled && !ctx.control && !ctx.validState && ctx.isError);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.control && ctx.additionalMessage !== null);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.overflowText);
    } }, directives: [i1.AdaptRxControlLabelComponent, i3.NgIf, AdaptTextfieldIconsComponent, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i6.NgControlStatus, i6.NgModel, i6.RequiredValidator, i6.MaxLengthValidator, i6.MinLengthValidator, i6.PatternValidator, i3.NgClass, i3.NgStyle], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ]),
            trigger('validationFeedbackChangeAnimation', [
                transition('* => *', [
                    useAnimation(ANIMATION_NAME.opacity)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextFieldComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-textfield, div[form-group]',
                templateUrl: './textfield.component.html',
                providers: [ADAPT_TEXTFIELD_ACCESSOR],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.id]': 'id',
                    '[class.form-group]': 'true',
                    '[class.textfield]': 'true',
                    '[class.is-icons]': '(iconValid && validState) || (iconInvalid && isError)'
                },
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ]),
                    trigger('validationFeedbackChangeAnimation', [
                        transition('* => *', [
                            useAnimation(ANIMATION_NAME.opacity)
                        ])
                    ])
                ],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.ResizeService }, { type: i2$1.Directionality }, { type: i1.AdaptTranslateService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i0.Injector }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DISABLE_NATIVE_VALIDITY_CHECKING]
            }] }, { type: i2.AdaptRadarService }]; }, { overflowText: [{
            type: Input
        }], nested: [{
            type: Input
        }], nestedSettings: [{
            type: Input
        }], customClass: [{
            type: Input
        }], label: [{
            type: Input
        }], type: [{
            type: Input
        }], id: [{
            type: Input
        }], testID: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconValid: [{
            type: Input
        }], iconInvalid: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], minlength: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], autocomplete: [{
            type: Input
        }], pattern: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], step: [{
            type: Input
        }], name: [{
            type: Input
        }], validState: [{
            type: Input
        }], requiredLabel: [{
            type: Input
        }], tooltipIcon: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], popoverIcon: [{
            type: Input
        }], popoverPlacement: [{
            type: Input
        }], popoverTriggers: [{
            type: Input
        }], popoverContent: [{
            type: Input
        }], errorMessage: [{
            type: Input,
            args: ['error']
        }], successMessage: [{
            type: Input,
            args: ['success']
        }], control: [{
            type: Input
        }], setInvalidState: [{
            type: Input
        }], debounceTime: [{
            type: Input
        }], inputElement: [{
            type: ViewChild,
            args: ['input']
        }], inputTextWidthEl: [{
            type: ViewChild,
            args: ['inputTextWidthEl']
        }], focusEmitter: [{
            type: Output,
            args: ['focus']
        }], blurEmitter: [{
            type: Output,
            args: ['blur']
        }], valueChanged: [{
            type: Output
        }], inputKeydown: [{
            type: Output
        }], inputKeypress: [{
            type: Output
        }], inputKeyup: [{
            type: Output
        }], required: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], rows: [{
            type: Input
        }], maxrows: [{
            type: Input
        }], autofocus: [{
            type: Input
        }], disableNativeValidityChecking: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }] }); })();

// TODO update types
function AdaptListBuilderItemComponent_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "div", 3);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementStart(4, "adapt-textfield", 4);
    i0.ɵɵlistener("ngModelChange", function AdaptListBuilderItemComponent_div_0_ng_container_2_Template_adapt_textfield_ngModelChange_4_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(2); return ctx_r3.inputControlModel = $event; })("blur", function AdaptListBuilderItemComponent_div_0_ng_container_2_Template_adapt_textfield_blur_4_listener() { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(2); return ctx_r5.isItemDisallowed ? ctx_r5.cancelEditMode() : ctx_r5.exitEditMode(); })("keyup", function AdaptListBuilderItemComponent_div_0_ng_container_2_Template_adapt_textfield_keyup_4_listener() { i0.ɵɵrestoreView(_r4); const ctx_r6 = i0.ɵɵnextContext(2); return ctx_r6.editChange(); })("keyup.esc", function AdaptListBuilderItemComponent_div_0_ng_container_2_Template_adapt_textfield_keyup_esc_4_listener() { i0.ɵɵrestoreView(_r4); const ctx_r7 = i0.ɵɵnextContext(2); return ctx_r7.cancelEditMode(); })("keydown.enter", function AdaptListBuilderItemComponent_div_0_ng_container_2_Template_adapt_textfield_keydown_enter_4_listener($event) { return $event.preventDefault(); })("keyup.enter", function AdaptListBuilderItemComponent_div_0_ng_container_2_Template_adapt_textfield_keyup_enter_4_listener() { i0.ɵɵrestoreView(_r4); const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.isItemDisallowed ? false : ctx_r9.exitEditMode(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n\n    ");
    i0.ɵɵelementStart(7, "div", 5);
    i0.ɵɵtext(8, "\n      ");
    i0.ɵɵelement(9, "adapt-custom-actions", 6);
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngModel", ctx_r1.inputControlModel)("autofocus", true);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("alignedTo", ctx_r1.customActionsAlignedTo)("actions", ctx_r1.customActions);
} }
function AdaptListBuilderItemComponent_div_0_ng_container_4_adapt_icon_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 13);
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", "dots");
} }
function AdaptListBuilderItemComponent_div_0_ng_container_4_button_11_Template(rf, ctx) { if (rf & 1) {
    const _r14 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 14);
    i0.ɵɵlistener("click", function AdaptListBuilderItemComponent_div_0_ng_container_4_button_11_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r14); const ctx_r13 = i0.ɵɵnextContext(3); return ctx_r13.enterEditMode(); });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "span", 15);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("placement", ctx_r11.itemActionsTooltipConfig.editBtn.placement)("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r11.itemActionsTooltipConfig.editBtn.tooltipText);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r11.controlLabels.edit);
} }
function AdaptListBuilderItemComponent_div_0_ng_container_4_button_13_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 16);
    i0.ɵɵlistener("click", function AdaptListBuilderItemComponent_div_0_ng_container_4_button_13_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(3); return ctx_r15.deleteItem(); });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "span", 15);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("placement", ctx_r12.itemActionsTooltipConfig.deleteBtn.placement)("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r12.itemActionsTooltipConfig.deleteBtn.tooltipText);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r12.controlLabels.delete);
} }
function AdaptListBuilderItemComponent_div_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    const _r18 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n\n    ");
    i0.ɵɵtemplate(2, AdaptListBuilderItemComponent_div_0_ng_container_4_adapt_icon_2_Template, 1, 2, "adapt-icon", 7);
    i0.ɵɵtext(3, "\n\n    ");
    i0.ɵɵelementStart(4, "span", 8);
    i0.ɵɵlistener("keydown.ArrowUp", function AdaptListBuilderItemComponent_div_0_ng_container_4_Template_span_keydown_ArrowUp_4_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r17 = i0.ɵɵnextContext(2); return ctx_r17.onUp($event); })("keydown.ArrowDown", function AdaptListBuilderItemComponent_div_0_ng_container_4_Template_span_keydown_ArrowDown_4_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r19 = i0.ɵɵnextContext(2); return ctx_r19.onDown($event); });
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelement(6, "adapt-highlight", 9);
    i0.ɵɵtext(7, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n\n    ");
    i0.ɵɵelementStart(9, "div", 10);
    i0.ɵɵtext(10, "\n      ");
    i0.ɵɵtemplate(11, AdaptListBuilderItemComponent_div_0_ng_container_4_button_11_Template, 5, 4, "button", 11);
    i0.ɵɵtext(12, "\n\n      ");
    i0.ɵɵtemplate(13, AdaptListBuilderItemComponent_div_0_ng_container_4_button_13_Template, 5, 4, "button", 12);
    i0.ɵɵtext(14, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r2.draggable);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("result", ctx_r2.listItem.name)("term", ctx_r2.query);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", !ctx_r2.hideEdit);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r2.hideDelete);
} }
const _c0$g = function (a0, a1, a2) { return { "cursor-default": a0, "disabled": a1, "hover-disabled": a2 }; };
function AdaptListBuilderItemComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵtext(1, "\n\n  ");
    i0.ɵɵtemplate(2, AdaptListBuilderItemComponent_div_0_ng_container_2_Template, 12, 4, "ng-container", 2);
    i0.ɵɵtext(3, "\n\n\n  ");
    i0.ɵɵtemplate(4, AdaptListBuilderItemComponent_div_0_ng_container_4_Template, 16, 5, "ng-container", 2);
    i0.ɵɵtext(5, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(3, _c0$g, !!ctx_r0.query, ctx_r0.disabled, ctx_r0.disabled || ctx_r0.hideControls || ctx_r0.editMode));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.editMode);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r0.editMode && ctx_r0.listItem);
} }
class AdaptListBuilderItemComponent {
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        this.editMode = false;
        this.inputControlModel = '';
        this.customActionsAlignedTo = AdaptCustomActionsAlignEnum.Right;
        this.id = '';
        this.query = '';
        this.hideControls = false;
        this.isItemDisallowed = false;
        this.hideEdit = false;
        this.hideDelete = false;
        this.draggable = true;
        this.disabled = false;
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onEdit = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onDelete = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onSave = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onCancel = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onKeyUp = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onKeyDown = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onEditChange = new EventEmitter();
        // ### ControlValueAccessor implementation
        this.propagateChange = () => {
            return;
        };
    }
    get customActions() {
        return [
            {
                name: this.controlLabels.cancel,
                visible: true,
                onClick: this.cancelEditMode.bind(this),
                onMouseDown: (event) => {
                    event.preventDefault();
                }
            },
            {
                name: this.controlLabels.save,
                visible: !this.isItemDisallowed,
                onClick: this.exitEditMode.bind(this),
                onMouseDown: (event) => {
                    event.preventDefault();
                }
            }
        ];
    }
    /**
     * Save value and exit edit mode
     */
    exitEditMode() {
        this.editMode = false;
        this.listItem.name = this.inputControlModel;
        this.onSave.emit(this.listItem);
        this.onEditChange.emit('');
    }
    /**
     * Exit edit mode without saving
     */
    cancelEditMode() {
        this.editMode = false;
        this.onCancel.emit(this.listItem);
        this.onEditChange.emit('');
    }
    enterEditMode() {
        this.editMode = true;
        this.inputControlModel = this.listItem.name;
    }
    deleteItem() {
        this.onDelete.emit(this.listItem);
    }
    editChange() {
        this.onEditChange.emit(this.inputControlModel);
    }
    onUp(e) {
        e.preventDefault();
        this.onKeyUp.emit();
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe((() => {
            e.target.focus();
        }).bind(e));
    }
    onDown(e) {
        e.preventDefault();
        this.onKeyDown.emit();
    }
    writeValue(value) {
        if (value) {
            this.listItem = value;
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched() {
        return;
    }
}
AdaptListBuilderItemComponent.ɵfac = function AdaptListBuilderItemComponent_Factory(t) { return new (t || AdaptListBuilderItemComponent)(i0.ɵɵdirectiveInject(i0.NgZone)); };
AdaptListBuilderItemComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptListBuilderItemComponent, selectors: [["adapt-list-builder-item"]], hostVars: 3, hostBindings: function AdaptListBuilderItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("id", ctx.id);
        i0.ɵɵstyleProp("display", "block");
    } }, inputs: { id: "id", query: "query", controlLabels: "controlLabels", itemActionsTooltipConfig: "itemActionsTooltipConfig", hideControls: "hideControls", isItemDisallowed: "isItemDisallowed", hideEdit: "hideEdit", hideDelete: "hideDelete", draggable: "draggable", disabled: "disabled" }, outputs: { onEdit: "onEdit", onDelete: "onDelete", onSave: "onSave", onCancel: "onCancel", onKeyUp: "onKeyUp", onKeyDown: "onKeyDown", onEditChange: "onEditChange" }, features: [i0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => AdaptListBuilderItemComponent),
                multi: true
            }
        ])], decls: 2, vars: 1, consts: [["class", "adapt-list-item adapt-builder-list-item", 3, "ngClass", 4, "ngIf"], [1, "adapt-list-item", "adapt-builder-list-item", 3, "ngClass"], [4, "ngIf"], [1, "adapt-list-item__edit-mode"], [3, "ngModel", "autofocus", "ngModelChange", "blur", "keyup", "keyup.esc", "keydown.enter", "keyup.enter"], [1, "adapt-list-item__controls"], [3, "alignedTo", "actions"], ["class", "adapt-list-drag m-end-1", 3, "adaptRadarDisableEventSending", "name", 4, "ngIf"], ["tabindex", "0", 1, "adapt-list-name", 3, "keydown.ArrowUp", "keydown.ArrowDown"], [3, "result", "term"], [1, "adapt-buttons-wrapper"], ["type", "button", "class", "d-icon-pencil_adapt btn btn-link list-update", 3, "placement", "adaptRadarDisableEventSending", "adaptTooltip", "click", 4, "ngIf"], ["type", "button", "class", "d-icon-trash_adapt btn btn-link list-remove", 3, "placement", "adaptRadarDisableEventSending", "adaptTooltip", "click", 4, "ngIf"], [1, "adapt-list-drag", "m-end-1", 3, "adaptRadarDisableEventSending", "name"], ["type", "button", 1, "d-icon-pencil_adapt", "btn", "btn-link", "list-update", 3, "placement", "adaptRadarDisableEventSending", "adaptTooltip", "click"], [1, "sr-only"], ["type", "button", 1, "d-icon-trash_adapt", "btn", "btn-link", "list-remove", 3, "placement", "adaptRadarDisableEventSending", "adaptTooltip", "click"]], template: function AdaptListBuilderItemComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptListBuilderItemComponent_div_0_Template, 6, 7, "div", 0);
        i0.ɵɵtext(1, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.listItem);
    } }, directives: [i3.NgIf, i3.NgClass, AdaptTextFieldComponent, i6.NgControlStatus, i6.NgModel, i1.AdaptCustomActionsComponent, i1.AdaptHighlightDirective, i1.AdaptIconComponent, i1.AdaptTooltipDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptListBuilderItemComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-list-builder-item',
                templateUrl: './list-builder-item.component.html',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => AdaptListBuilderItemComponent),
                        multi: true
                    }
                ],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.id]': 'id',
                    '[style.display]': "'block'"
                }
            }]
    }], function () { return [{ type: i0.NgZone }]; }, { id: [{
            type: Input
        }], query: [{
            type: Input
        }], controlLabels: [{
            type: Input
        }], itemActionsTooltipConfig: [{
            type: Input
        }], hideControls: [{
            type: Input
        }], isItemDisallowed: [{
            type: Input
        }], hideEdit: [{
            type: Input
        }], hideDelete: [{
            type: Input
        }], draggable: [{
            type: Input
        }], disabled: [{
            type: Input
        }], onEdit: [{
            type: Output
        }], onDelete: [{
            type: Output
        }], onSave: [{
            type: Output
        }], onCancel: [{
            type: Output
        }], onKeyUp: [{
            type: Output
        }], onKeyDown: [{
            type: Output
        }], onEditChange: [{
            type: Output
        }] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$f = ["list"];
const _c1$c = ["search"];
function AdaptListBuilderComponent_adapt_rx_control_label_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-rx-control-label", 8);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("label", ctx_r0.label)("requiredLabel", ctx_r0.texts.requiredText)("showRequiredLabel", ctx_r0.required)("subLabel", ctx_r0.subLabel)("tooltip", ctx_r0.tooltipConfig);
} }
function AdaptListBuilderComponent_div_9_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 14);
    i0.ɵɵlistener("click", function AdaptListBuilderComponent_div_9_button_7_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(2); return ctx_r10.addListItem(); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", ctx_r9.isItemDisallowed);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n        ", ctx_r9.texts.add, "\n      ");
} }
function AdaptListBuilderComponent_div_9_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9, 10);
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵelement(3, "span", 11);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementStart(5, "input", 12);
    i0.ɵɵlistener("ngModelChange", function AdaptListBuilderComponent_div_9_Template_input_ngModelChange_5_listener($event) { i0.ɵɵrestoreView(_r13); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.searchFilterText = $event; })("keyup", function AdaptListBuilderComponent_div_9_Template_input_keyup_5_listener() { i0.ɵɵrestoreView(_r13); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.searchChange(); })("keyup.esc", function AdaptListBuilderComponent_div_9_Template_input_keyup_esc_5_listener() { i0.ɵɵrestoreView(_r13); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.cleanField(); })("keydown.enter", function AdaptListBuilderComponent_div_9_Template_input_keydown_enter_5_listener($event) { return $event.preventDefault(); })("keyup.enter", function AdaptListBuilderComponent_div_9_Template_input_keyup_enter_5_listener() { i0.ɵɵrestoreView(_r13); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.isItemDisallowed ? false : ctx_r17.addListItem(); })("blur", function AdaptListBuilderComponent_div_9_Template_input_blur_5_listener() { i0.ɵɵrestoreView(_r13); const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.onBlur(); })("focus", function AdaptListBuilderComponent_div_9_Template_input_focus_5_listener() { i0.ɵɵrestoreView(_r13); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.onFocus(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵtemplate(7, AdaptListBuilderComponent_div_9_button_7_Template, 2, 2, "button", 13);
    i0.ɵɵtext(8, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵpropertyInterpolate("placeholder", ctx_r1.texts.searchPlaceholder);
    i0.ɵɵproperty("ngModel", ctx_r1.searchFilterText)("disabled", ctx_r1.disabled);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !(ctx_r1.disabled || ctx_r1.readonly) && ctx_r1.searchFilterText.length > 0);
} }
function AdaptListBuilderComponent_ng_container_14_div_2_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 20);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "span");
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵelement(4, "span", 21);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelementStart(6, "span");
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const data_r20 = i0.ɵɵnextContext(2).ngIf;
    const ctx_r23 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r23.texts.headerText);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate2("(", data_r20.length, " ", ctx_r23.texts.numberOptionsText, ")");
} }
function AdaptListBuilderComponent_ng_container_14_div_2_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r29 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 22);
    i0.ɵɵlistener("cdkDragMoved", function AdaptListBuilderComponent_ng_container_14_div_2_div_5_Template_div_cdkDragMoved_0_listener() { i0.ɵɵrestoreView(_r29); const ctx_r28 = i0.ɵɵnextContext(3); return ctx_r28.move(); });
    i0.ɵɵtext(1, "\n\n            ");
    i0.ɵɵelementStart(2, "adapt-list-builder-item", 23);
    i0.ɵɵlistener("ngModelChange", function AdaptListBuilderComponent_ng_container_14_div_2_div_5_Template_adapt_list_builder_item_ngModelChange_2_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r29); const index_r27 = restoredCtx.index; const data_r20 = i0.ɵɵnextContext(2).ngIf; return (data_r20[index_r27] = $event); })("onEditChange", function AdaptListBuilderComponent_ng_container_14_div_2_div_5_Template_adapt_list_builder_item_onEditChange_2_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r32 = i0.ɵɵnextContext(3); return ctx_r32.editChange($event); })("onDelete", function AdaptListBuilderComponent_ng_container_14_div_2_div_5_Template_adapt_list_builder_item_onDelete_2_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r33 = i0.ɵɵnextContext(3); return ctx_r33.deleteListItem($event); })("onKeyUp", function AdaptListBuilderComponent_ng_container_14_div_2_div_5_Template_adapt_list_builder_item_onKeyUp_2_listener() { const restoredCtx = i0.ɵɵrestoreView(_r29); const index_r27 = restoredCtx.index; const ctx_r34 = i0.ɵɵnextContext(3); return ctx_r34.onUp(index_r27); })("onKeyDown", function AdaptListBuilderComponent_ng_container_14_div_2_div_5_Template_adapt_list_builder_item_onKeyDown_2_listener() { const restoredCtx = i0.ɵɵrestoreView(_r29); const index_r27 = restoredCtx.index; const ctx_r35 = i0.ɵɵnextContext(3); return ctx_r35.onDown(index_r27); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r26 = ctx.$implicit;
    const index_r27 = ctx.index;
    const data_r20 = i0.ɵɵnextContext(2).ngIf;
    const ctx_r24 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@itemAnimation", undefined)("cdkDragDisabled", ctx_r24.disabled || ctx_r24.readonly || option_r26.disabled);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngModel", data_r20[index_r27])("id", ctx_r24.id + "_item_" + index_r27)("disabled", option_r26.disabled || ctx_r24.readonly || ctx_r24.disabled)("query", ctx_r24.searchFilterText)("controlLabels", ctx_r24.texts)("itemActionsTooltipConfig", ctx_r24.listItemActionsTooltip)("hideControls", ctx_r24.hideControls)("isItemDisallowed", ctx_r24.isItemDisallowed)("hideEdit", ctx_r24.disabled || ctx_r24.readonly || ctx_r24.hideEdit)("hideDelete", ctx_r24.disabled || ctx_r24.readonly || ctx_r24.hideDelete)("draggable", !(ctx_r24.disabled || ctx_r24.readonly));
} }
function AdaptListBuilderComponent_ng_container_14_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r38 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 16, 17);
    i0.ɵɵlistener("cdkDropListDropped", function AdaptListBuilderComponent_ng_container_14_div_2_Template_div_cdkDropListDropped_0_listener($event) { i0.ɵɵrestoreView(_r38); const ctx_r37 = i0.ɵɵnextContext(2); return ctx_r37.drop($event); });
    i0.ɵɵtext(2, "\n\n          ");
    i0.ɵɵtemplate(3, AdaptListBuilderComponent_ng_container_14_div_2_div_3_Template, 9, 3, "div", 18);
    i0.ɵɵtext(4, "\n\n          ");
    i0.ɵɵtemplate(5, AdaptListBuilderComponent_ng_container_14_div_2_div_5_Template, 4, 13, "div", 19);
    i0.ɵɵtext(6, "\n\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const data_r20 = i0.ɵɵnextContext().ngIf;
    const ctx_r21 = i0.ɵɵnextContext();
    i0.ɵɵproperty("cdkDropListDisabled", !!ctx_r21.searchFilterText || ctx_r21.disabled || ctx_r21.readonly)("@listAnimation", ctx_r21.options.length);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", !ctx_r21.hideListAreaLabel);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", data_r20);
} }
function AdaptListBuilderComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptListBuilderComponent_ng_container_14_div_2_Template, 7, 4, "div", 15);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const data_r20 = ctx.ngIf;
    i0.ɵɵnextContext();
    const _r3 = i0.ɵɵreference(21);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", data_r20 && data_r20.length)("ngIfElse", _r3);
} }
function AdaptListBuilderComponent_ng_template_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 24);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "adapt-empty-state", 25);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "div", 26);
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵprojection(7);
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n    ");
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("type", "objects")("label", ctx_r4.texts.notFound);
} }
function AdaptListBuilderComponent_div_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "p", 27);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r5.displayErrorMessage);
} }
function AdaptListBuilderComponent_div_26_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "p", 27);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r6.validationErrorMessage);
} }
function AdaptListBuilderComponent_div_28_p_2_strong_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "strong");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r41 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", error_r41.name, " ");
} }
function AdaptListBuilderComponent_div_28_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 27);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptListBuilderComponent_div_28_p_2_strong_2_Template, 2, 1, "strong", 5);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r41 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", error_r41.name);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n      ", error_r41.text, "\n    ");
} }
function AdaptListBuilderComponent_div_28_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 28);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptListBuilderComponent_div_28_p_2_Template, 4, 2, "p", 29);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r7._self.errors);
} }
const _c2$a = [[["", 8, "empty-text"]]];
const _c3$6 = function (a0) { return { "is-error": a0 }; };
const _c4$4 = function (a0) { return { "height": a0 }; };
const _c5$4 = function (a0) { return { "adapt-list-builder__list": a0 }; };
const _c6$2 = [".empty-text"];
let listBuilderCount = 0;
class AdaptListBuilderComponent extends FormComponent {
    constructor(_renderer, _injector, ts, _adaptRadarService, _elem) {
        super(_injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptListBuilder);
        this._renderer = _renderer;
        this._injector = _injector;
        this._adaptRadarService = _adaptRadarService;
        this.searchFilterText = '';
        this.hideControls = false;
        this._self = this;
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        this.defaultSettings = {
            enableSearch: true,
            checkedStyle: 'dpl-iconfont',
            hideLabel: false,
        };
        this.defaultItemsTooltipConfig = {
            editBtn: {
                placement: 'top',
                tooltipText: ''
            },
            deleteBtn: {
                placement: 'top',
                tooltipText: ''
            }
        };
        this.defaultTexts = {};
        this.defaultErrorTexts = {};
        this.isItemDisallowed = false;
        this.listChanged = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        /**
         * Unique id of the element.
         */
        this.id = `list-builder-${listBuilderCount++}`;
        this.hideSearchField = false;
        this.hideEdit = false;
        this.hideDelete = false;
        this.hideListAreaLabel = false;
        this._isTouched = false;
        this._onTouchedCallback = () => {
            return;
        };
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get isErrorExist() {
        return this.required && !this.options.length && this._isTouched;
    }
    set value(v) {
        this._value = v;
    }
    ngOnInit() {
        // Sending radar event directly to avoid issues with the premature invocation of "initControl" in parent ngOnInit()
        // ERROR NullInjectorError: R3InjectorError(AppModule)[NgControl -> NgControl -> NgControl]:
        // So do not call super.ngOnInit() here
        // TODO ?
        this._adaptRadarService.sendGenericComponentEvent(AdaptRadarAngularCustomEventName.AdaptListBuilder);
        this.settings = Object.assign(Object.assign({}, this.defaultSettings), this.settings);
        this.texts = Object.assign(Object.assign({}, this.defaultTexts), this.texts);
        this.listItemActionsTooltip = Object.assign(Object.assign({}, this.defaultItemsTooltipConfig), this.listItemActionsTooltip);
        if (!this.displayErrorMessage) {
            this.displayErrorMessage = this.defaultErrorTexts.errorEmpty;
        }
        if (!this.validationErrorMessage) {
            this.validationErrorMessage = this.defaultErrorTexts.errorInvalid;
        }
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        if (this.formControl) {
            super.initControl();
        }
        if (this.tooltipInputIcon && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipInputIcon,
                content: this.tooltipInputText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    setDefaultTexts(translation) {
        this.defaultTexts.requiredText = translation['adapt.common.required'];
        this.defaultTexts.searchPlaceholder = translation['adapt.listBuilder.searchPlaceholder'];
        this.defaultTexts.headerText = translation['adapt.listBuilder.headerText'];
        this.defaultTexts.numberOptionsText = translation['adapt.listBuilder.numberOptionsText'];
        this.defaultTexts.add = translation['adapt.listBuilder.add'];
        this.defaultTexts.notFound = translation['adapt.listBuilder.notFound'];
        this.defaultTexts.edit = translation['adapt.common.edit'];
        this.defaultTexts.save = translation['adapt.common.save'];
        this.defaultTexts.cancel = translation['adapt.common.cancel'];
        this.defaultTexts.delete = translation['adapt.common.delete'];
        // by some weird reason we have additional defaults for tooltip texts
        // TODO: double check do we need them
        this.defaultItemsTooltipConfig.editBtn.tooltipText = translation['adapt.listBuilder.editTooltip'];
        this.defaultItemsTooltipConfig.deleteBtn.tooltipText = translation['adapt.listBuilder.deleteTooltip'];
        this.defaultErrorTexts.errorEmpty = translation['adapt.listBuilder.error.empty'];
        this.defaultErrorTexts.errorInvalidName = translation['adapt.listBuilder.error.invalidName'];
        this.defaultErrorTexts.errorInvalid = translation['adapt.listBuilder.error.invalid'];
    }
    writeValue(value) {
        if (value) {
            this.value = value;
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    validate() {
        const validationError = {
            invalidData: this._customErrorTexts.validationError || {
                name: this.defaultErrorTexts.errorInvalidName,
                text: this.defaultErrorTexts.errorInvalid
            }
        };
        if (!this.options.length) {
            return null;
        }
        return this.isItemDisallowed ? validationError : null;
    }
    checkItemDisallowed() {
        return this.allowAddingToList && this.allowAddingToList(this.searchFilterText, this.options);
    }
    addListItem() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.options.push({
            id: this.generateListItemId() ? this.generateListItemId() : '',
            name: this.searchFilterText
        });
        this.cleanField();
        this.updateModel();
    }
    deleteListItem(option) {
        const index = this.options.indexOf(option);
        this.options.splice(index, 1);
        this.updateModel();
        this._isTouched = true;
    }
    editChange(value) {
        this.isItemDisallowed = this.allowAddingToList && this.allowAddingToList(value, this.options);
        // Need for reactive forms validation
        this._onTouchedCallback();
        this.propagateChange(this.options);
    }
    drop(event) {
        moveItemInArray(this.options, event.previousIndex, event.currentIndex);
        this.hideControls = false;
        this.updateModel();
    }
    onUp(index) {
        if (this.disabled || this.readonly) {
            return;
        }
        moveItemInArray(this.options, index, (index === 0) ? 0 : --index);
        this.updateModel();
    }
    onDown(index) {
        if (this.disabled || this.readonly) {
            return;
        }
        let currentIndex = this.options.length;
        if (index !== this.options.length) {
            currentIndex = index++;
        }
        moveItemInArray(this.options, index, currentIndex);
        this.updateModel();
    }
    move() {
        this.hideControls = true;
    }
    searchChange() {
        this.isItemDisallowed = this.checkItemDisallowed();
        this._onTouchedCallback();
        this.propagateChange(this.options);
    }
    cleanField() {
        this.searchFilterText = '';
    }
    onBlur() {
        this._renderer.removeClass(this.search.nativeElement, 'focused');
        this._isTouched = true;
        this.propagateChange(this.options);
        this._onTouchedCallback();
    }
    onFocus() {
        this._renderer.addClass(this.search.nativeElement, 'focused');
    }
    updateModel() {
        this.propagateChange(this.options);
        this._onTouchedCallback();
        this.listChanged.emit(this.options);
    }
}
AdaptListBuilderComponent.ɵfac = function AdaptListBuilderComponent_Factory(t) { return new (t || AdaptListBuilderComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i1.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptListBuilderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptListBuilderComponent, selectors: [["adapt-list-builder"]], viewQuery: function AdaptListBuilderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$f, 5);
        i0.ɵɵviewQuery(_c1$c, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.list = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.search = _t.first);
    } }, hostVars: 1, hostBindings: function AdaptListBuilderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("id", ctx.id);
    } }, inputs: { label: "label", subLabel: ["sub-label", "subLabel"], id: "id", name: "name", tooltipInputIcon: "tooltipInputIcon", tooltipInputText: "tooltipInputText", options: "options", settings: "settings", texts: "texts", listItemActionsTooltip: "listItemActionsTooltip", displayErrorMessage: "displayErrorMessage", validationErrorMessage: "validationErrorMessage", formControl: "formControl", menuHeight: "menuHeight", hideSearchField: "hideSearchField", hideEdit: "hideEdit", hideDelete: "hideDelete", hideListAreaLabel: "hideListAreaLabel", generateListItemId: "generateListItemId", allowAddingToList: "allowAddingToList" }, outputs: { listChanged: "listChanged", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptListBuilderComponent),
            createFormControlValidator(AdaptListBuilderComponent),
            AdaptSelectSearchFilter
        ]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c6$2, decls: 31, vars: 24, consts: [[1, "adapt-list-builder", 3, "ngClass"], [3, "label", "requiredLabel", "showRequiredLabel", "subLabel", "tooltip", 4, "ngIf"], [1, "adapt-list-builder__wrp"], ["class", "adapt-list-builder__search", "tabindex", "-1", 4, "ngIf"], [1, "adapt-list-container", "adapt-list", 3, "ngStyle", "ngClass"], [4, "ngIf"], ["empty", ""], ["class", "has-danger", 4, "ngIf"], [3, "label", "requiredLabel", "showRequiredLabel", "subLabel", "tooltip"], ["tabindex", "-1", 1, "adapt-list-builder__search"], ["search", ""], [1, "d-icon-search"], ["type", "text", "tabindex", "0", 1, "form-control", "m-start-1", 3, "ngModel", "placeholder", "disabled", "ngModelChange", "keyup", "keyup.esc", "keydown.enter", "keyup.enter", "blur", "focus"], ["type", "button", "role", "button", "tabindex", "0", "class", "adapt-list-builder__add-item btn btn-link", 3, "disabled", "click", 4, "ngIf"], ["type", "button", "role", "button", "tabindex", "0", 1, "adapt-list-builder__add-item", "btn", "btn-link", 3, "disabled", "click"], ["cdkDropList", "", 3, "cdkDropListDisabled", "cdkDropListDropped", 4, "ngIf", "ngIfElse"], ["cdkDropList", "", 3, "cdkDropListDisabled", "cdkDropListDropped"], ["list", ""], ["class", "adapt-list-builder__list-header", 4, "ngIf"], ["class", "adapt-list-builder__list-wrp", "cdkDrag", "", "cdkDragLockAxis", "y", 3, "cdkDragDisabled", "cdkDragMoved", 4, "ngFor", "ngForOf"], [1, "adapt-list-builder__list-header"], [1, "letter-space"], ["cdkDrag", "", "cdkDragLockAxis", "y", 1, "adapt-list-builder__list-wrp", 3, "cdkDragDisabled", "cdkDragMoved"], [3, "ngModel", "id", "disabled", "query", "controlLabels", "itemActionsTooltipConfig", "hideControls", "isItemDisallowed", "hideEdit", "hideDelete", "draggable", "ngModelChange", "onEditChange", "onDelete", "onKeyUp", "onKeyDown"], [1, "list-container"], [3, "type", "label"], [1, "empty-info"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"], [1, "has-danger"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngFor", "ngForOf"]], template: function AdaptListBuilderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c2$a);
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n\n  ");
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵtemplate(3, AdaptListBuilderComponent_adapt_rx_control_label_3_Template, 1, 5, "adapt-rx-control-label", 1);
        i0.ɵɵtext(4, "\n  ");
        i0.ɵɵtext(5, "\n\n  ");
        i0.ɵɵelementStart(6, "div", 2);
        i0.ɵɵtext(7, "\n\n    ");
        i0.ɵɵtext(8, "\n    ");
        i0.ɵɵtemplate(9, AdaptListBuilderComponent_div_9_Template, 9, 4, "div", 3);
        i0.ɵɵtext(10, "\n    ");
        i0.ɵɵtext(11, "\n\n    ");
        i0.ɵɵelementStart(12, "div", 4);
        i0.ɵɵtext(13, "\n      ");
        i0.ɵɵtemplate(14, AdaptListBuilderComponent_ng_container_14_Template, 4, 2, "ng-container", 5);
        i0.ɵɵpipe(15, "async");
        i0.ɵɵpipe(16, "searchFilterAsync");
        i0.ɵɵtext(17, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n    ");
        i0.ɵɵtext(19, "\n\n    ");
        i0.ɵɵtemplate(20, AdaptListBuilderComponent_ng_template_20_Template, 12, 2, "ng-template", null, 6, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(22, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(23, "\n\n  ");
        i0.ɵɵtemplate(24, AdaptListBuilderComponent_div_24_Template, 5, 2, "div", 5);
        i0.ɵɵtext(25, "\n\n  ");
        i0.ɵɵtemplate(26, AdaptListBuilderComponent_div_26_Template, 5, 2, "div", 5);
        i0.ɵɵtext(27, "\n\n  ");
        i0.ɵɵtemplate(28, AdaptListBuilderComponent_div_28_Template, 4, 2, "div", 7);
        i0.ɵɵtext(29, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(30, "\n");
    } if (rf & 2) {
        i0.ɵɵclassProp("disabled", ctx.disabled)("readonly", ctx.readonly);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(18, _c3$6, ctx.isErrorExist || ctx.isItemDisallowed));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.settings.hideLabel);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", !ctx.hideSearchField);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(20, _c4$4, ctx.menuHeight))("ngClass", i0.ɵɵpureFunction1(22, _c5$4, !ctx.hideSearchField));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", i0.ɵɵpipeBind1(15, 13, i0.ɵɵpipeBind2(16, 15, ctx.options, ctx.searchFilterText)));
        i0.ɵɵadvance(10);
        i0.ɵɵproperty("ngIf", ctx.isErrorExist && !ctx.isItemDisallowed && !ctx.formControl);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.isErrorExist && ctx.isItemDisallowed && !ctx.formControl);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.formControl && ctx._self.errors.length > 0 && ctx._self.control.touched);
    } }, directives: [i3.NgClass, i3.NgIf, i3.NgStyle, i1.AdaptRxControlLabelComponent, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i6.NgControlStatus, i6.NgModel, i5.CdkDropList, i3.NgForOf, i5.CdkDrag, AdaptListBuilderItemComponent, i1.AdaptEmptyStateComponent], pipes: [i3.AsyncPipe, AdaptSelectSearchFilterAsync], encapsulation: 2, data: { animation: [
            trigger('listAnimation', [
                transition(':decrement', [
                    group([
                        query('@itemAnimation', [
                            animateChild()
                        ], { optional: true })
                    ])
                ]),
                transition(':enter, :increment', [
                    query('@itemAnimation', [
                        animateChild()
                    ], { optional: true })
                ]),
            ]),
            trigger('itemAnimation', [
                transition(':enter', [
                    style({ transform: 'scale(0.5)', opacity: 0 }),
                    animate(ANIMATION_DURATION.medium + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ transform: 'scale(1)', opacity: 1 }))
                ]),
                transition(':leave', [
                    style({ transform: 'scale(1)', opacity: 1, height: '*' }),
                    animate(ANIMATION_DURATION.medium + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ transform: 'scale(0.5)', opacity: 0, height: '0px' }))
                ]),
            ]),
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptListBuilderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-list-builder',
                templateUrl: './list-builder.component.html',
                providers: [
                    createFormControlValueAccessor(AdaptListBuilderComponent),
                    createFormControlValidator(AdaptListBuilderComponent),
                    AdaptSelectSearchFilter
                ],
                animations: [
                    trigger('listAnimation', [
                        transition(':decrement', [
                            group([
                                query('@itemAnimation', [
                                    animateChild()
                                ], { optional: true })
                            ])
                        ]),
                        transition(':enter, :increment', [
                            query('@itemAnimation', [
                                animateChild()
                            ], { optional: true })
                        ]),
                    ]),
                    trigger('itemAnimation', [
                        transition(':enter', [
                            style({ transform: 'scale(0.5)', opacity: 0 }),
                            animate(ANIMATION_DURATION.medium + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ transform: 'scale(1)', opacity: 1 }))
                        ]),
                        transition(':leave', [
                            style({ transform: 'scale(1)', opacity: 1, height: '*' }),
                            animate(ANIMATION_DURATION.medium + ' ' + ANIMATION_TIMING_FUNCTION.base.transitionInOut, style({ transform: 'scale(0.5)', opacity: 0, height: '0px' }))
                        ]),
                    ]),
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.id]': 'id'
                }
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.Injector }, { type: i1.AdaptTranslateService }, { type: i1.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { list: [{
            type: ViewChild,
            args: ['list']
        }], search: [{
            type: ViewChild,
            args: ['search']
        }], listChanged: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], label: [{
            type: Input
        }], subLabel: [{
            type: Input,
            args: ['sub-label']
        }], id: [{
            type: Input
        }], name: [{
            type: Input
        }], tooltipInputIcon: [{
            type: Input
        }], tooltipInputText: [{
            type: Input
        }], options: [{
            type: Input
        }], settings: [{
            type: Input
        }], texts: [{
            type: Input
        }], listItemActionsTooltip: [{
            type: Input
        }], displayErrorMessage: [{
            type: Input
        }], validationErrorMessage: [{
            type: Input
        }], formControl: [{
            type: Input
        }], menuHeight: [{
            type: Input
        }], hideSearchField: [{
            type: Input
        }], hideEdit: [{
            type: Input
        }], hideDelete: [{
            type: Input
        }], hideListAreaLabel: [{
            type: Input
        }], generateListItemId: [{
            type: Input
        }], allowAddingToList: [{
            type: Input
        }] }); })();

class AdaptTextFieldModule {
}
AdaptTextFieldModule.ɵfac = function AdaptTextFieldModule_Factory(t) { return new (t || AdaptTextFieldModule)(); };
AdaptTextFieldModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptTextFieldModule });
AdaptTextFieldModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            FormsModule,
            CommonModule,
            AdaptTextFieldIconsModule,
            AdaptIconModule,
            AdaptTooltipModule,
            AdaptPopoverModule.forRoot(),
            AdaptDragonInputHandlerModule,
            AdaptRxLabelModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextFieldModule, [{
        type: NgModule,
        args: [{
                imports: [
                    FormsModule,
                    CommonModule,
                    AdaptTextFieldIconsModule,
                    AdaptIconModule,
                    AdaptTooltipModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptDragonInputHandlerModule,
                    AdaptRxLabelModule
                ],
                exports: [AdaptTextFieldComponent],
                declarations: [AdaptTextFieldComponent],
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptTextFieldModule, { declarations: [AdaptTextFieldComponent], imports: [FormsModule,
        CommonModule,
        AdaptTextFieldIconsModule,
        AdaptIconModule,
        AdaptTooltipModule, i1.AdaptPopoverModule, AdaptDragonInputHandlerModule,
        AdaptRxLabelModule], exports: [AdaptTextFieldComponent] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$e = ["optionButton"];
function AdaptTypeaheadWindowComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelement(1, "adapt-highlight", 2);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const result_r4 = ctx.result;
    const term_r5 = ctx.term;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("result", ctx_r1.formatter(result_r4))("term", term_r5);
} }
function AdaptTypeaheadWindowComponent_ng_container_4_button_4_ng_template_3_Template(rf, ctx) { }
const _c1$b = function (a0, a1) { return { result: a0, term: a1 }; };
function AdaptTypeaheadWindowComponent_ng_container_4_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 5, 6);
    i0.ɵɵlistener("mouseenter", function AdaptTypeaheadWindowComponent_ng_container_4_button_4_Template_button_mouseenter_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r12); const idx_r8 = restoredCtx.index; const ctx_r11 = i0.ɵɵnextContext(2); return ctx_r11.markActive(idx_r8); })("click", function AdaptTypeaheadWindowComponent_ng_container_4_button_4_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r12); const result_r7 = restoredCtx.$implicit; const ctx_r13 = i0.ɵɵnextContext(2); return ctx_r13.select(result_r7); });
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptTypeaheadWindowComponent_ng_container_4_button_4_ng_template_3_Template, 0, 0, "ng-template", 7);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const result_r7 = ctx.$implicit;
    const idx_r8 = ctx.index;
    const ctx_r6 = i0.ɵɵnextContext(2);
    const _r0 = i0.ɵɵreference(2);
    i0.ɵɵclassProp("active", idx_r8 === ctx_r6.activeIdx);
    i0.ɵɵproperty("id", ctx_r6.id + "-" + idx_r8);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r6.resultTemplate || _r0)("ngTemplateOutletContext", i0.ɵɵpureFunction2(5, _c1$b, result_r7, ctx_r6.term));
} }
const _c2$9 = function (a0) { return { "height": a0 }; };
function AdaptTypeaheadWindowComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "cdk-virtual-scroll-viewport", 3);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵtemplate(4, AdaptTypeaheadWindowComponent_ng_container_4_button_4_Template, 5, 8, "button", 4);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("itemSize", ctx_r2.virtualScrollItemSize)("ngStyle", i0.ɵɵpureFunction1(4, _c2$9, ctx_r2.virtualScrollDropdownHeight));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("cdkVirtualForOf", ctx_r2.results)("cdkVirtualForTrackBy", ctx_r2.trackByForResults);
} }
function AdaptTypeaheadWindowComponent_ng_container_6_button_2_ng_template_3_Template(rf, ctx) { }
function AdaptTypeaheadWindowComponent_ng_container_6_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r20 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 5, 6);
    i0.ɵɵlistener("mouseenter", function AdaptTypeaheadWindowComponent_ng_container_6_button_2_Template_button_mouseenter_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r20); const idx_r16 = restoredCtx.index; const ctx_r19 = i0.ɵɵnextContext(2); return ctx_r19.markActive(idx_r16); })("click", function AdaptTypeaheadWindowComponent_ng_container_6_button_2_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r20); const result_r15 = restoredCtx.$implicit; const ctx_r21 = i0.ɵɵnextContext(2); return ctx_r21.select(result_r15); });
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtemplate(3, AdaptTypeaheadWindowComponent_ng_container_6_button_2_ng_template_3_Template, 0, 0, "ng-template", 7);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const result_r15 = ctx.$implicit;
    const idx_r16 = ctx.index;
    const ctx_r14 = i0.ɵɵnextContext(2);
    const _r0 = i0.ɵɵreference(2);
    i0.ɵɵclassProp("active", idx_r16 === ctx_r14.activeIdx);
    i0.ɵɵproperty("id", ctx_r14.id + "-" + idx_r16);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r14.resultTemplate || _r0)("ngTemplateOutletContext", i0.ɵɵpureFunction2(5, _c1$b, result_r15, ctx_r14.term));
} }
function AdaptTypeaheadWindowComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTypeaheadWindowComponent_ng_container_6_button_2_Template, 5, 8, "button", 8);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r3.results)("ngForTrackBy", ctx_r3.trackByForResults);
} }
class AdaptTypeaheadWindowComponent {
    constructor(_elementRef, _ngZone) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this.activeIdx = 0;
        /**
         * Flag indicating if the first row should be active initially
         */
        this.focusFirst = true;
        /**
         * A function used to format a given result before display. This function should return a formatted string without any
         * HTML markup
         */
        this.formatter = toString;
        /**
         * The flag informing that the popup is appended to document.body
         */
        this.appendedToBody = false;
        /**
         * Event raised when user selects a particular result row
         */
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.selectEvent = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-rename
        this.activeChangeEvent = new EventEmitter();
    }
    get className() {
        return `dropdown-menu show ${this.hostClass || ''} ${this.virtualScroll ? 'dropdown-menu_virtual-scroll' : ''}`;
    }
    get dropdownWidth() {
        return this.virtualScroll ? this.virtualScrollDropdownWidth : 'auto';
    }
    get popupZIndex() {
        return this.appendedToBody ? '1060' : null;
    }
    hasActive() {
        return this.activeIdx > -1 && this.activeIdx < this.results.length;
    }
    getActive() {
        return this.results[this.activeIdx];
    }
    markActive(activeIdx) {
        this.activeIdx = activeIdx;
        this._activeChanged();
    }
    next() {
        if (this.activeIdx !== this.results.length - 1) {
            this.activeIdx++;
        }
        this._activeChanged();
    }
    prev() {
        if (this.activeIdx < 0) {
            this.activeIdx = 0;
        }
        else if (this.activeIdx > 0) {
            this.activeIdx--;
        }
        this._activeChanged();
    }
    resetActive() {
        this.activeIdx = this.focusFirst ? 0 : -1;
        this._activeChanged();
    }
    select(item) {
        this.selectEvent.emit(item);
    }
    ngOnInit() {
        this.resetActive();
    }
    trackByForResults(index) {
        return index;
    }
    _activeChanged() {
        this.activeChangeEvent.emit(this.activeIdx >= 0 ? this.id + '-' + this.activeIdx : undefined);
        this.scrollToActiveItem();
    }
    scrollToActiveItem() {
        this._ngZone.onStable.pipe(take(1)).subscribe(() => {
            if (!this.optionButtons) {
                return;
            }
            const activeButtonElRef = this.optionButtons.find(el => el.nativeElement.classList.contains('active'));
            if (activeButtonElRef) {
                const buttonEl = activeButtonElRef.nativeElement;
                scrollToActive(buttonEl);
            }
        });
    }
}
AdaptTypeaheadWindowComponent.ɵfac = function AdaptTypeaheadWindowComponent_Factory(t) { return new (t || AdaptTypeaheadWindowComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone)); };
AdaptTypeaheadWindowComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTypeaheadWindowComponent, selectors: [["ngb-typeahead-window"], ["adapt-typeahead-window"]], viewQuery: function AdaptTypeaheadWindowComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$e, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionButtons = _t);
    } }, hostAttrs: ["role", "listbox"], hostVars: 7, hostBindings: function AdaptTypeaheadWindowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵhostProperty("id", ctx.id);
        i0.ɵɵclassMap(ctx.className);
        i0.ɵɵstyleProp("width", ctx.dropdownWidth)("z-index", ctx.popupZIndex);
    } }, inputs: { id: "id", focusFirst: "focusFirst", results: "results", term: "term", formatter: "formatter", resultTemplate: "resultTemplate", appendedToBody: "appendedToBody", hostClass: "hostClass", virtualScroll: "virtualScroll", virtualScrollItemSize: "virtualScrollItemSize", virtualScrollDropdownHeight: "virtualScrollDropdownHeight", virtualScrollDropdownWidth: "virtualScrollDropdownWidth" }, outputs: { selectEvent: "select", activeChangeEvent: "activeChange" }, exportAs: ["ngbTypeaheadWindow"], decls: 8, vars: 2, consts: [["rt", ""], [4, "ngIf"], [3, "result", "term"], [3, "itemSize", "ngStyle"], ["type", "button", "class", "dropdown-item", "role", "option", 3, "id", "active", "mouseenter", "click", 4, "cdkVirtualFor", "cdkVirtualForOf", "cdkVirtualForTrackBy"], ["type", "button", "role", "option", 1, "dropdown-item", 3, "id", "mouseenter", "click"], ["optionButton", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["type", "button", "class", "dropdown-item", "role", "option", 3, "id", "active", "mouseenter", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"]], template: function AdaptTypeaheadWindowComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵtemplate(1, AdaptTypeaheadWindowComponent_ng_template_1_Template, 3, 2, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(3, "\n    ");
        i0.ɵɵtemplate(4, AdaptTypeaheadWindowComponent_ng_container_4_Template, 7, 6, "ng-container", 1);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵtemplate(6, AdaptTypeaheadWindowComponent_ng_container_6_Template, 4, 2, "ng-container", 1);
        i0.ɵɵtext(7, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.virtualScroll);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.virtualScroll);
    } }, directives: [i3.NgIf, i1.AdaptHighlightDirective, i3$2.CdkVirtualScrollViewport, i3$2.CdkFixedSizeVirtualScroll, i3.NgStyle, i3$2.CdkVirtualForOf, i3.NgTemplateOutlet, i3.NgForOf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadWindowComponent, [{
        type: Component,
        args: [{
                selector: 'ngb-typeahead-window, adapt-typeahead-window',
                exportAs: 'ngbTypeaheadWindow',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: { 'role': 'listbox', '[id]': 'id' },
                template: `
    <ng-template #rt let-result="result" let-term="term">
      <adapt-highlight [result]="formatter(result)" [term]="term"></adapt-highlight>
    </ng-template>
    <ng-container *ngIf="virtualScroll">
      <cdk-virtual-scroll-viewport
        [itemSize]="virtualScrollItemSize"
        [ngStyle]="{'height': virtualScrollDropdownHeight}">
        <button #optionButton
                *cdkVirtualFor="let result of results; let idx = index; trackBy: trackByForResults"
                type="button"
                class="dropdown-item"
                role="option"
                [id]="id + '-' + idx"
                [class.active]="idx === activeIdx"
                (mouseenter)="markActive(idx)"
                (click)="select(result)">
          <ng-template [ngTemplateOutlet]="resultTemplate || rt"
                       [ngTemplateOutletContext]="{result: result, term: term}"></ng-template>
        </button>
      </cdk-virtual-scroll-viewport>
    </ng-container>
    <ng-container *ngIf="!virtualScroll">
      <button #optionButton
              *ngFor="let result of results; let idx = index; trackBy: trackByForResults"
              type="button"
              class="dropdown-item"
              role="option"
              [id]="id + '-' + idx"
              [class.active]="idx === activeIdx"
              (mouseenter)="markActive(idx)"
              (click)="select(result)">
        <ng-template [ngTemplateOutlet]="resultTemplate || rt"
                     [ngTemplateOutletContext]="{result: result, term: term}"></ng-template>
      </button>
    </ng-container>
  `
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, { id: [{
            type: Input
        }], focusFirst: [{
            type: Input
        }], results: [{
            type: Input
        }], term: [{
            type: Input
        }], formatter: [{
            type: Input
        }], resultTemplate: [{
            type: Input
        }], appendedToBody: [{
            type: Input
        }], hostClass: [{
            type: Input
        }], virtualScroll: [{
            type: Input
        }], virtualScrollItemSize: [{
            type: Input
        }], virtualScrollDropdownHeight: [{
            type: Input
        }], virtualScrollDropdownWidth: [{
            type: Input
        }], selectEvent: [{
            type: Output,
            args: ['select']
        }], activeChangeEvent: [{
            type: Output,
            args: ['activeChange']
        }], optionButtons: [{
            type: ViewChildren,
            args: ['optionButton']
        }], className: [{
            type: HostBinding,
            args: ['class']
        }], dropdownWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], popupZIndex: [{
            type: HostBinding,
            args: ['style.zIndex']
        }] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
class AdaptTypeaheadConfig {
    constructor() {
        this.editable = false;
        this.focusFirst = false;
        this.showHint = false;
    }
}
AdaptTypeaheadConfig.ɵfac = function AdaptTypeaheadConfig_Factory(t) { return new (t || AdaptTypeaheadConfig)(); };
AdaptTypeaheadConfig.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptTypeaheadConfig, factory: AdaptTypeaheadConfig.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadConfig, [{
        type: Injectable
    }], null, null); })();
/**
 * Configuration service for the AdaptTypeahead component.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the typeaheads used in the application.
 */
class AdaptTypeaheadModel {
    constructor(_dir) {
        this._dir = _dir;
        this.editable = true;
        this.focusFirst = true;
        this.showHint = false;
        this._isRtl = false;
        this._isRtl = this._dir.value === 'rtl';
        this.placement = 'auto';
    }
}
AdaptTypeaheadModel.ɵfac = function AdaptTypeaheadModel_Factory(t) { return new (t || AdaptTypeaheadModel)(i0.ɵɵinject(i2$1.Directionality)); };
AdaptTypeaheadModel.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptTypeaheadModel, factory: AdaptTypeaheadModel.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadModel, [{
        type: Injectable
    }], function () { return [{ type: i2$1.Directionality }]; }, null); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
var Key;
(function (Key) {
    Key[Key["Tab"] = 9] = "Tab";
    Key[Key["Enter"] = 13] = "Enter";
    Key[Key["Escape"] = 27] = "Escape";
    Key[Key["ArrowUp"] = 38] = "ArrowUp";
    Key[Key["ArrowDown"] = 40] = "ArrowDown";
})(Key || (Key = {}));
const NGB_TYPEAHEAD_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptTypeaheadDirective),
    multi: true
};
let nextWindowId = 0;
/**
 * NgbTypeahead directive provides a simple way of creating powerful typeaheads from any text input
 */
class AdaptTypeaheadDirective {
    constructor(_elementRef, _viewContainerRef, _renderer, _injector, componentFactoryResolver, config, ngZone, _live, _layerService, _deviceDetection, _applicationRef) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._renderer = _renderer;
        this._injector = _injector;
        this._live = _live;
        this._layerService = _layerService;
        this._deviceDetection = _deviceDetection;
        this._applicationRef = _applicationRef;
        /**
         * Value for the configurable autocomplete attribute.
         * Defaults to 'off' to disable the native browser autocomplete, but this standard value does not seem
         * to be always correctly taken into account.
         */
        this.autocomplete = 'off';
        /**
         * Disables result provisioning while true
         */
        this.preventResults = false;
        /**
         * Placement of a typeahead accepts:
         * "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
         * "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
         * and array of above values.
         */
        this.placement = 'auto';
        /**
         * Open popup on focus
         */
        this.openOnFocus = false;
        /**
         * An event emitted when a match is selected. Event payload is of type NgbTypeaheadSelectItemEvent.
         */
        this.selectItem = new EventEmitter();
        /**
         * An event emitted when a typeAhead drop down is shown.
         */
        this.typeAheadPopupOpen = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onBlur = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onFocus = new EventEmitter();
        this.popupId = `ngb-typeahead-${nextWindowId++}`;
        this._openOnFocus$ = new Subject();
        this._isIE = false;
        this._onTouched = () => {
            return;
        };
        this._onChange = () => {
            return;
        };
        this.container = config.container;
        this.editable = config.editable;
        this.focusFirst = config.focusFirst;
        this.showHint = config.showHint;
        this.placement = config.placement;
        this._valueChanges = fromEvent(_elementRef.nativeElement, 'input')
            .pipe(map($event => $event.target.value), mergeMap((value) => {
            // IE11 emit input event while placeholder contain spec. caracters
            // fix for the issue https://github.bmc.com/bmc-ux/adapt-angular/issues/2836
            // if it's IE need to check if input is focused, if statement is true - emit event
            if (this._isIE) {
                return this._activeElement === this._elementRef.nativeElement ? of(value) : EMPTY;
            }
            else {
                return of(value);
            }
        }));
        this._resubscribeTypeahead = new BehaviorSubject(null);
        this._popupService = new PopupService(AdaptTypeaheadWindowComponent, _injector, _viewContainerRef, _renderer, componentFactoryResolver, _applicationRef);
        this._zoneSubscription = ngZone.onStable.subscribe(() => {
            if (this.isPopupOpen()) {
                const host = this.positionTo || this._elementRef.nativeElement;
                positionElements(host, this._windowRef.location.nativeElement, this.placement, this.container === 'body');
            }
        });
        this._setValueSubscription$ = ngZone.onStable.pipe(take(1)).subscribe(() => {
            this._inputValueBackup = this._elementRef.nativeElement.value;
        });
    }
    get _activeElement() {
        return document.activeElement;
    }
    ngOnInit() {
        this._isIE = this._deviceDetection.isIE();
        const inputValues$ = this._valueChanges.pipe(distinctUntilChanged(), tap(value => {
            this._inputValueBackup = value;
            if (this.editable) {
                this._onChange(value);
            }
        }));
        const focus$ = merge(inputValues$, this._openOnFocus$);
        const results$ = focus$.pipe(this.ngbTypeahead);
        const processedResults$ = results$.pipe(skipWhile(() => this.preventResults)).pipe(tap((val) => {
            if (!this.editable) {
                const correctValue = val.filter(function (v) {
                    let newValue = this.backupValue;
                    if (newValue) {
                        newValue = newValue.toLowerCase();
                    }
                    if (this.formatter) {
                        v = this.formatter(v);
                    }
                    return newValue === v.toLowerCase();
                    // if (typeof v === 'string' || v instanceof String) {
                    //   return newValue === v.toLowerCase();
                    // } else if (v.name) { // TODO: change logic to work with any object data
                    //   return newValue === v.name.toLowerCase();
                    // } else if (v.dataValue) {
                    //   return newValue === v.dataValue.toLowerCase();
                    // } else {
                    //   return false;
                    // }
                }, { 'backupValue': this._inputValueBackup, 'formatter': this.inputFormatter });
                val.length ? this._onChange(correctValue[0]) : this._onChange(undefined);
            }
        }));
        const userInput$ = this._resubscribeTypeahead.pipe(switchMap(() => processedResults$));
        this._subscription = this._subscribeToUserInput(userInput$);
    }
    ngOnDestroy() {
        this._closePopup();
        this._unsubscribeFromUserInput();
        this._zoneSubscription.unsubscribe();
        this._setValueSubscription$.unsubscribe();
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    writeValue(value) {
        this._inputValueBackup = this._formatItemForInput(value);
        this._writeInputValue(this._formatItemForInput(value));
        // while [(ngModel)] value changed outside need to update the list by correct items
        setTimeout(() => {
            if (this.isPopupOpen() && this._elementRef) {
                this._emitInputEvent();
            }
        });
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    onDocumentClick(event) {
        if (event.target !== this._elementRef.nativeElement) {
            this.dismissPopup();
        }
    }
    /**
     * Dismisses typeahead popup window
     */
    dismissPopup() {
        if (this.isPopupOpen()) {
            this._closePopup();
            this._writeInputValue(this._inputValueBackup);
        }
    }
    /**
     * Returns true if the typeahead popup window is displayed
     */
    isPopupOpen() {
        return this._windowRef != null;
    }
    handleBlur(event) {
        this.onBlur.emit(event);
        this._resubscribeTypeahead.next(null);
        this._onTouched();
    }
    handleFocus(event) {
        this.onFocus.emit(event);
        if (this.openOnFocus) {
            this._openOnFocus$.next(this._inputValueBackup);
            return;
        }
        this.typeAheadPopupOpen.emit({ text: this._inputValueBackup, open: false });
    }
    handleKeyDown(event) {
        if (!this.isPopupOpen()) {
            return;
        }
        const keyCode = getEventKeyCode(event);
        if (Key[toString(keyCode)]) {
            switch (keyCode) {
                case Key.ArrowDown:
                    event.preventDefault();
                    this._windowRef.instance.next();
                    this._showHint();
                    break;
                case Key.ArrowUp:
                    event.preventDefault();
                    this._windowRef.instance.prev();
                    this._showHint();
                    break;
                case Key.Enter:
                case Key.Tab: {
                    const result = this._windowRef.instance.getActive();
                    if (isDefined(result)) {
                        event.preventDefault();
                        event.stopPropagation();
                        this._selectResult(result);
                    }
                    this._closePopup();
                    break;
                }
            }
        }
    }
    _openPopup() {
        if (!this.isPopupOpen()) {
            this.typeAheadPopupOpen.emit({ text: this._inputValueBackup, open: true });
            this._inputValueBackup = this._elementRef.nativeElement.value;
            this._windowRef = this._popupService.open();
            this._windowRef.instance.id = this.popupId;
            this._windowRef.instance.hostClass = this.popupClass;
            this._windowRef.instance.appendedToBody = this.container === 'body';
            this._windowRef.instance.selectEvent.subscribe((result) => this._selectResultClosePopup(result));
            this._windowRef.instance.activeChangeEvent.subscribe((activeId) => this.activeDescendant = activeId);
            const menu = this._windowRef.location.nativeElement;
            if (this.container) {
                if (this.container === 'body') {
                    document.body.appendChild(menu);
                }
                else {
                    this.container.appendChild(menu);
                }
            }
            this._layerService.addComponent(this, (event) => {
                event.preventDefault();
                this._resubscribeTypeahead.next(null);
                this.dismissPopup();
            });
            if (!isDefined(this._documentListenerFunc)) {
                this._documentListenerFunc = this._renderer.listen('document', 'click', this.onDocumentClick.bind(this));
            }
        }
    }
    _closePopup() {
        this._popupService.close();
        this._windowRef = null;
        this.activeDescendant = undefined;
        this._layerService.removeComponent(this);
        this.typeAheadPopupOpen.emit({ text: this._inputValueBackup, open: false });
        if (isDefined(this._documentListenerFunc)) {
            this._documentListenerFunc();
            this._documentListenerFunc = null;
        }
    }
    _selectResult(result) {
        let defaultPrevented = false;
        this.selectItem.emit({
            item: result, preventDefault: () => {
                defaultPrevented = true;
            }
        });
        this._resubscribeTypeahead.next(null);
        if (!defaultPrevented) {
            if (this.inputFormatter) {
                this._inputValueBackup = this.inputFormatter(result);
            }
            else {
                this._inputValueBackup = result;
            }
            this.writeValue(result);
            this._onChange(result);
        }
    }
    _selectResultClosePopup(result) {
        this._selectResult(result);
        this._closePopup();
    }
    _showHint() {
        if (this.showHint && this._windowRef.instance.hasActive() && this._inputValueBackup != null) {
            const userInputLowerCase = this._inputValueBackup.toLowerCase();
            const formattedVal = this._formatItemForInput(this._windowRef.instance.getActive());
            if (userInputLowerCase === formattedVal.substr(0, this._inputValueBackup.length).toLowerCase()) {
                this._writeInputValue(this._inputValueBackup + formattedVal.substr(this._inputValueBackup.length));
                this._elementRef.nativeElement.setSelectionRange.apply(this._elementRef.nativeElement, [this._inputValueBackup.length, formattedVal.length]);
            }
            else {
                this._writeInputValue(this._formatItemForInput(this._windowRef.instance.getActive()));
            }
        }
    }
    _formatItemForInput(item) {
        return item != null && this.inputFormatter ? this.inputFormatter(item) : toString(item);
    }
    _writeInputValue(value) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', toString(value));
    }
    _subscribeToUserInput(userInput$) {
        return userInput$.subscribe((results) => {
            if (!results || results.length === 0) {
                this._closePopup();
            }
            else {
                this._openPopup();
                this._windowRef.instance.focusFirst = this.focusFirst;
                this._windowRef.instance.results = results;
                this._windowRef.instance.term = this._elementRef.nativeElement.value;
                this._windowRef.instance.virtualScroll = this.virtualScroll;
                this._windowRef.instance.virtualScrollItemSize = this.virtualScrollItemSize;
                this._windowRef.instance.virtualScrollDropdownWidth = this.virtualScrollDropdownWidth;
                this._windowRef.instance.virtualScrollDropdownHeight = this.virtualScrollDropdownHeight;
                if (this.resultFormatter) {
                    this._windowRef.instance.formatter = this.resultFormatter;
                }
                if (this.resultTemplate) {
                    this._windowRef.instance.resultTemplate = this.resultTemplate;
                }
                this._windowRef.instance.resetActive();
                // The observable stream we are subscribing to might have async steps
                // and if a component containing typeahead is using the OnPush strategy
                // the change detection turn wouldn't be invoked automatically.
                SafeCdr.detectChanges(this._windowRef.changeDetectorRef);
                this._showHint();
            }
            const count = results.length;
            this._live.say(count === 0 ? 'No results available' : `${count} result${count === 1 ? '' : 's'} available`);
        });
    }
    _emitInputEvent() {
        const event = new Event('input');
        this._elementRef.nativeElement.dispatchEvent(event);
    }
    _unsubscribeFromUserInput() {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
        this._subscription = null;
    }
}
AdaptTypeaheadDirective.ɵfac = function AdaptTypeaheadDirective_Factory(t) { return new (t || AdaptTypeaheadDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(AdaptTypeaheadModel), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.Live), i0.ɵɵdirectiveInject(i1.LayerService), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ApplicationRef)); };
AdaptTypeaheadDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTypeaheadDirective, selectors: [["", "adaptTypeaheadDirective", ""], ["input", "ngbTypeahead", ""]], hostAttrs: ["autocapitalize", "off", "autocorrect", "off", "role", "combobox"], hostVars: 8, hostBindings: function AdaptTypeaheadDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("blur", function AdaptTypeaheadDirective_blur_HostBindingHandler($event) { return ctx.handleBlur($event); })("keydown", function AdaptTypeaheadDirective_keydown_HostBindingHandler($event) { return ctx.handleKeyDown($event); })("focus", function AdaptTypeaheadDirective_focus_HostBindingHandler($event) { return ctx.handleFocus($event); });
    } if (rf & 2) {
        i0.ɵɵhostProperty("autocomplete", ctx.autocomplete);
        i0.ɵɵattribute("aria-autocomplete", ctx.showHint ? "both" : "list")("aria-activedescendant", ctx.activeDescendant)("aria-owns", ctx.isPopupOpen() ? ctx.popupId : null)("aria-expanded", ctx.isPopupOpen())("aria-haspopup", "listbox");
        i0.ɵɵclassProp("open", ctx.isPopupOpen());
    } }, inputs: { autocomplete: "autocomplete", container: "container", editable: "editable", focusFirst: "focusFirst", inputFormatter: "inputFormatter", ngbTypeahead: "ngbTypeahead", preventResults: "preventResults", resultFormatter: "resultFormatter", resultTemplate: "resultTemplate", showHint: "showHint", popupClass: "popupClass", placement: "placement", positionTo: "positionTo", openOnFocus: "openOnFocus", virtualScroll: "virtualScroll", virtualScrollItemSize: "virtualScrollItemSize", virtualScrollDropdownWidth: "virtualScrollDropdownWidth", virtualScrollDropdownHeight: "virtualScrollDropdownHeight" }, outputs: { selectItem: "selectItem", typeAheadPopupOpen: "typeAheadPopupOpen", onBlur: "onBlur", onFocus: "onFocus" }, exportAs: ["ngbTypeahead"], features: [i0.ɵɵProvidersFeature([NGB_TYPEAHEAD_VALUE_ACCESSOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptTypeaheadDirective], input[ngbTypeahead]',
                exportAs: 'ngbTypeahead',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '(blur)': 'handleBlur($event)',
                    '[class.open]': 'isPopupOpen()',
                    '(keydown)': 'handleKeyDown($event)',
                    '(focus)': 'handleFocus($event)',
                    '[autocomplete]': 'autocomplete',
                    'autocapitalize': 'off',
                    'autocorrect': 'off',
                    'role': 'combobox',
                    '[attr.aria-autocomplete]': 'showHint ? "both" : "list"',
                    '[attr.aria-activedescendant]': 'activeDescendant',
                    '[attr.aria-owns]': 'isPopupOpen() ? popupId : null',
                    '[attr.aria-expanded]': 'isPopupOpen()',
                    '[attr.aria-haspopup]': '"listbox"'
                },
                providers: [NGB_TYPEAHEAD_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ComponentFactoryResolver }, { type: AdaptTypeaheadModel }, { type: i0.NgZone }, { type: i1.Live }, { type: i1.LayerService }, { type: i1.AdaptDeviceDetectionService }, { type: i0.ApplicationRef }]; }, { autocomplete: [{
            type: Input
        }], container: [{
            type: Input
        }], editable: [{
            type: Input
        }], focusFirst: [{
            type: Input
        }], inputFormatter: [{
            type: Input
        }], ngbTypeahead: [{
            type: Input
        }], preventResults: [{
            type: Input
        }], resultFormatter: [{
            type: Input
        }], resultTemplate: [{
            type: Input
        }], showHint: [{
            type: Input
        }], popupClass: [{
            type: Input
        }], placement: [{
            type: Input
        }], positionTo: [{
            type: Input
        }], openOnFocus: [{
            type: Input
        }], virtualScroll: [{
            type: Input
        }], virtualScrollItemSize: [{
            type: Input
        }], virtualScrollDropdownWidth: [{
            type: Input
        }], virtualScrollDropdownHeight: [{
            type: Input
        }], selectItem: [{
            type: Output
        }], typeAheadPopupOpen: [{
            type: Output
        }], onBlur: [{
            type: Output
        }], onFocus: [{
            type: Output
        }] }); })();

class AdaptTypeaheadSubModule {
    static forRoot() {
        return {
            ngModule: AdaptTypeaheadSubModule,
            providers: [
                Live,
                AdaptTypeaheadModel, {
                    provide: ARIA_LIVE_DELAY,
                    useValue: DEFAULT_ARIA_LIVE_DELAY
                },
                AdaptDeviceDetectionService
            ]
        };
    }
}
AdaptTypeaheadSubModule.ɵfac = function AdaptTypeaheadSubModule_Factory(t) { return new (t || AdaptTypeaheadSubModule)(); };
AdaptTypeaheadSubModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptTypeaheadSubModule });
AdaptTypeaheadSubModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule, ScrollingModule, AdaptHighlightModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadSubModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    AdaptTypeaheadDirective,
                    AdaptTypeaheadWindowComponent
                ],
                exports: [AdaptTypeaheadDirective,],
                imports: [CommonModule, ScrollingModule, AdaptHighlightModule],
                entryComponents: [AdaptTypeaheadWindowComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptTypeaheadSubModule, { declarations: [AdaptTypeaheadDirective,
        AdaptTypeaheadWindowComponent], imports: [CommonModule, ScrollingModule, AdaptHighlightModule], exports: [AdaptTypeaheadDirective] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$d = ["input"];
function AdaptTypeaheadComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "p", 6);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r1.errorMessage);
} }
function AdaptTypeaheadComponent_div_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "p", 6);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r2.warningMessage);
} }
let nextId$2 = 0;
const TYPEAHEAD_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptTypeaheadComponent),
    multi: true
};
class AdaptTypeaheadComponent extends AdaptRadarGenericDirective {
    constructor(config, ts, _injector, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptTypeahead);
        this.ts = ts;
        this._injector = _injector;
        /**
         * Unique id of the element.
         */
        this.id = `typeahead-${nextId$2++}`;
        /**
         * Placement of a typeahead accepts:
         * "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
         * "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
         * and array of above values.
         */
        this.placement = 'auto';
        this.disabled = false;
        this.readonly = false;
        /**
         * Open popup on focus
         */
        this.openOnFocus = false;
        /**
         * Enable virtual scroll for results window. Can be suitable for big amount of results
         */
        this.virtualScroll = false;
        /**
         * Used to set "itemSize" virtual scroll @Input()
         */
        this.virtualScrollItemSize = 30;
        /**
         * Used to set width for results dropdown
         */
        this.virtualScrollDropdownWidth = '25.625rem';
        /**
         * Used to set height for results dropdown
         */
        this.virtualScrollDropdownHeight = '13.75rem';
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        this.ariaLabel = null;
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        /**
         * The value for the `autocomplete` attribute for the `<input>` element.
         * @since v10.14.0
         */
        this.autocomplete = 'off';
        /**
         * An event emitted when a match is selected. Event payload is of type NgbTypeaheadSelectItemEvent.
         */
        this.selectItem = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.click = new EventEmitter();
        /**
         * The internal data model
         */
        this.innerValue = '';
        /** Actual value, event if it is not matching any typeahead options */
        this.actualInputValue = '';
        /**
         * If the typeAhead drop down is open
         */
        this.isTypeAheadOpen = true;
        /**
         * Placeholders for the callbacks which are later provided by the Control Value Accessor
         */
        this.onTouchedCallback = noop$5;
        this.onChangeCallback = noop$5;
        this._isTouched = false;
        this._required = false;
        this.editable = config.editable;
        this.focusFirst = config.focusFirst;
        this.showHint = config.showHint;
        this.requiredLabel = ts.getCurrentLanguage()['adapt.common.required'];
    }
    /**
     * A function to transform the provided observable text into the array of results.
     * Note that the "this" argument is undefined so you need to explicitly bind it to a desired "this" target.
     */
    /*
      * Typeahead OperatorFunction
    */
    set typeahead(inputFunction) {
        this._typeahead = inputFunction;
    }
    get typeahead() {
        return this._typeahead;
    }
    /**
     * Append to body trigger
     */
    set appendToBody(state) {
        if (state && !this.appendToContainer) {
            this.appendTo = 'body';
        }
    }
    /**
     * When specified, the drop-down list will be appended to the selected element
     */
    set appendTo(element) {
        this.appendToContainer = element;
    }
    /** Whether the element is required. */
    get required() {
        return this._required || hasRequiredValidator(this._ngControl);
    }
    set required(value) {
        this._required = toBoolean(value);
    }
    /**
     * get accessor
     */
    get value() {
        return this.innerValue;
    }
    /**
     * set accessor including call the onchange callback
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
        this.updateError();
    }
    ngOnInit() {
        this._ngControl = this._injector.get(NgControl, null);
    }
    onFocus(event) {
        this.focus.emit(event);
    }
    onSelect(event) {
        this.selectItem.emit(event);
    }
    /**
     * Triggered when typeAhead drop down is open or closed
     */
    typeAheadPopUpChange(event) {
        this.isTypeAheadOpen = event.open;
        // When input text is empty set as empty instead of undefined
        if (!event.text) {
            this.innerValue = '';
        }
        this.updateError();
    }
    /**
     * Update the error UI
     */
    updateError() {
        if (!this._isTouched && (this.isTypeAheadOpen || this.required)) {
            this.isError = false;
            return;
        }
        this.isError = ((this.required && !this.innerValue) || (!this.editable && this.innerValue === undefined)) && !this.actualInputValue;
    }
    updateWarning() {
        this.isWarning = !this.editable && this._isTouched
            && !this.innerValue && this.actualInputValue && !this.isTypeAheadOpen;
    }
    onInputChange(event) {
        this.actualInputValue = event.target['value'];
    }
    /**
     * Set touched on blur
     */
    onBlur(event) {
        this._isTouched = true;
        this.onTouchedCallback();
        this.blur.emit(event);
        this.updateError();
        this.updateWarning();
    }
    /**
     * From ControlValueAccessor interface
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
        this.updateError();
    }
    /**
     * From ControlValueAccessor interface
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * From ControlValueAccessor interface
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
AdaptTypeaheadComponent.ɵfac = function AdaptTypeaheadComponent_Factory(t) { return new (t || AdaptTypeaheadComponent)(i0.ɵɵdirectiveInject(AdaptTypeaheadConfig), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptTypeaheadComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTypeaheadComponent, selectors: [["adapt-typeahead"]], viewQuery: function AdaptTypeaheadComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$d, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    } }, hostAttrs: [1, "typeahead"], inputs: { typeahead: "typeahead", label: "label", description: "description", id: "id", editable: "editable", focusFirst: "focusFirst", showHint: "showHint", inputFormatter: "inputFormatter", resultFormatter: "resultFormatter", resultTemplate: "resultTemplate", placeholder: "placeholder", placement: "placement", errorMessage: "errorMessage", warningMessage: "warningMessage", disabled: "disabled", readonly: "readonly", appendToBody: "appendToBody", positionTo: "positionTo", appendTo: "appendTo", requiredLabel: "requiredLabel", openOnFocus: "openOnFocus", virtualScroll: "virtualScroll", virtualScrollItemSize: "virtualScrollItemSize", virtualScrollDropdownWidth: "virtualScrollDropdownWidth", virtualScrollDropdownHeight: "virtualScrollDropdownHeight", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"], autocomplete: "autocomplete", required: "required" }, outputs: { selectItem: "selectItem", focus: "focus", blur: "blur", click: "click" }, features: [i0.ɵɵProvidersFeature([TYPEAHEAD_VALUE_ACCESSOR]), i0.ɵɵInheritDefinitionFeature], decls: 12, vars: 37, consts: [[1, "dropdown", "show"], [3, "for", "label", "requiredLabel", "subLabel", "showRequiredLabel"], ["type", "text", 1, "form-control", 3, "ngModel", "ngbTypeahead", "preventResults", "disabled", "readOnly", "container", "virtualScroll", "virtualScrollItemSize", "virtualScrollDropdownWidth", "virtualScrollDropdownHeight", "positionTo", "placement", "required", "editable", "showHint", "focusFirst", "inputFormatter", "resultFormatter", "resultTemplate", "placeholder", "openOnFocus", "autocomplete", "ngModelChange", "selectItem", "typeAheadPopupOpen", "click", "onBlur", "onFocus", "input"], ["input", ""], ["role", "alert", 4, "ngIf"], ["role", "alert"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"]], template: function AdaptTypeaheadComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵelement(3, "adapt-rx-control-label", 1);
        i0.ɵɵtext(4, "\n      ");
        i0.ɵɵelementStart(5, "input", 2, 3);
        i0.ɵɵlistener("ngModelChange", function AdaptTypeaheadComponent_Template_input_ngModelChange_5_listener($event) { return ctx.value = $event; })("selectItem", function AdaptTypeaheadComponent_Template_input_selectItem_5_listener($event) { return ctx.onSelect($event); })("typeAheadPopupOpen", function AdaptTypeaheadComponent_Template_input_typeAheadPopupOpen_5_listener($event) { return ctx.typeAheadPopUpChange($event); })("click", function AdaptTypeaheadComponent_Template_input_click_5_listener($event) { return ctx.click.emit($event); })("onBlur", function AdaptTypeaheadComponent_Template_input_onBlur_5_listener($event) { return ctx.onBlur($event); })("onFocus", function AdaptTypeaheadComponent_Template_input_onFocus_5_listener($event) { return ctx.onFocus($event); })("input", function AdaptTypeaheadComponent_Template_input_input_5_listener($event) { return ctx.onInputChange($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(7, "\n\n      ");
        i0.ɵɵtemplate(8, AdaptTypeaheadComponent_div_8_Template, 5, 2, "div", 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵtemplate(10, AdaptTypeaheadComponent_div_10_Template, 5, 2, "div", 4);
        i0.ɵɵtext(11, "\n    ");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵclassProp("has-warning", ctx.isWarning && !ctx.isError)("has-danger", !ctx.isWarning && ctx.isError);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("subLabel", ctx.description)("showRequiredLabel", ctx.required);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngModel", ctx.value)("ngbTypeahead", ctx.typeahead)("preventResults", ctx.disabled || ctx.readonly)("disabled", ctx.disabled)("readOnly", ctx.readonly)("container", ctx.appendToContainer)("virtualScroll", ctx.virtualScroll)("virtualScrollItemSize", ctx.virtualScrollItemSize)("virtualScrollDropdownWidth", ctx.virtualScrollDropdownWidth)("virtualScrollDropdownHeight", ctx.virtualScrollDropdownHeight)("positionTo", ctx.positionTo)("placement", ctx.placement)("required", ctx.required)("editable", ctx.editable)("showHint", ctx.showHint)("focusFirst", ctx.focusFirst)("inputFormatter", ctx.inputFormatter)("resultFormatter", ctx.resultFormatter)("resultTemplate", ctx.resultTemplate)("placeholder", ctx.placeholder || "")("openOnFocus", ctx.openOnFocus)("autocomplete", ctx.autocomplete);
        i0.ɵɵattribute("id", ctx.id)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.errorMessage && ctx.isError && !ctx.isWarning);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.warningMessage && ctx.isWarning && !ctx.isError);
    } }, directives: [i1.AdaptRxControlLabelComponent, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, AdaptTypeaheadDirective, i6.NgControlStatus, i6.NgModel, i6.RequiredValidator, i3.NgIf], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-typeahead',
                template: `
    <div class="dropdown show"
         [class.has-warning]="isWarning && !isError"
         [class.has-danger]="!isWarning && isError">
      <adapt-rx-control-label [for]="id"
                              [label]="label"
                              [requiredLabel]="requiredLabel"
                              [subLabel]="description"
                              [showRequiredLabel]="required"></adapt-rx-control-label>
      <input #input
             type="text"
             class="form-control"
             [attr.id]="id"
             [(ngModel)]="value"
             [ngbTypeahead]="typeahead"
             [preventResults]="disabled || readonly"
             [disabled]="disabled"
             [readOnly]="readonly"
             [container]="appendToContainer"
             [virtualScroll]="virtualScroll"
             [virtualScrollItemSize]="virtualScrollItemSize"
             [virtualScrollDropdownWidth]="virtualScrollDropdownWidth"
             [virtualScrollDropdownHeight]="virtualScrollDropdownHeight"
             [positionTo]="positionTo"
             [placement]="placement"
             [required]="required"
             [editable]="editable"
             [showHint]="showHint"
             [focusFirst]="focusFirst"
             [inputFormatter]="inputFormatter"
             [resultFormatter]="resultFormatter"
             [resultTemplate]="resultTemplate"
             [placeholder]="placeholder || ''"
             [openOnFocus]="openOnFocus"
             [autocomplete]="autocomplete"
             [attr.aria-label]="ariaLabel"
             [attr.aria-labelledby]="ariaLabelledby"
             [attr.aria-describedby]="ariaDescribedBy"
             (selectItem)="onSelect($event)"
             (typeAheadPopupOpen)="typeAheadPopUpChange($event)"
             (click)="click.emit($event)"
             (onBlur)="onBlur($event)"
             (onFocus)="onFocus($event)"
             (input)="onInputChange($event)"/>

      <div *ngIf="errorMessage && isError && !isWarning" [@validationFeedbackAnimation] role="alert">
        <p class="form-control-feedback m-0 pt-1 pb-2">{{errorMessage}}</p>
      </div>
      <div *ngIf="warningMessage && isWarning && !isError" [@validationFeedbackAnimation] role="alert">
        <p class="form-control-feedback m-0 pt-1 pb-2">{{warningMessage}}</p>
      </div>
    </div>`,
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ],
                providers: [TYPEAHEAD_VALUE_ACCESSOR],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: { 'class': 'typeahead' }
            }]
    }], function () { return [{ type: AdaptTypeaheadConfig }, { type: i1.AdaptTranslateService }, { type: i0.Injector }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { typeahead: [{
            type: Input
        }], label: [{
            type: Input
        }], description: [{
            type: Input
        }], id: [{
            type: Input
        }], editable: [{
            type: Input
        }], focusFirst: [{
            type: Input
        }], showHint: [{
            type: Input
        }], inputFormatter: [{
            type: Input
        }], resultFormatter: [{
            type: Input
        }], resultTemplate: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], placement: [{
            type: Input
        }], errorMessage: [{
            type: Input
        }], warningMessage: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], positionTo: [{
            type: Input
        }], appendTo: [{
            type: Input
        }], requiredLabel: [{
            type: Input
        }], openOnFocus: [{
            type: Input
        }], virtualScroll: [{
            type: Input
        }], virtualScrollItemSize: [{
            type: Input
        }], virtualScrollDropdownWidth: [{
            type: Input
        }], virtualScrollDropdownHeight: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], autocomplete: [{
            type: Input
        }], inputElement: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], selectItem: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], click: [{
            type: Output
        }], required: [{
            type: Input
        }] }); })();

class AdaptTypeaheadModule {
    static forRoot() {
        return {
            ngModule: AdaptTypeaheadModule,
            providers: [TYPEAHEAD_VALUE_ACCESSOR, AdaptTypeaheadConfig]
        };
    }
}
AdaptTypeaheadModule.ɵfac = function AdaptTypeaheadModule_Factory(t) { return new (t || AdaptTypeaheadModule)(); };
AdaptTypeaheadModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptTypeaheadModule });
AdaptTypeaheadModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule, FormsModule, AdaptTypeaheadSubModule.forRoot(), AdaptRxLabelModule, AdaptDragonInputHandlerModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTypeaheadModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, FormsModule, AdaptTypeaheadSubModule.forRoot(), AdaptRxLabelModule, AdaptDragonInputHandlerModule],
                exports: [AdaptTypeaheadComponent],
                declarations: [AdaptTypeaheadComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptTypeaheadModule, { declarations: [AdaptTypeaheadComponent], imports: [CommonModule, FormsModule, AdaptTypeaheadSubModule, AdaptRxLabelModule, AdaptDragonInputHandlerModule], exports: [AdaptTypeaheadComponent] }); })();

class AdaptListBuilderModule {
    constructor(iconService) {
        iconService.registerIcons([ai_dots]);
    }
    static forRoot() {
        return {
            ngModule: AdaptListBuilderModule,
            providers: [AdaptSelectSearchFilter]
        };
    }
}
AdaptListBuilderModule.ɵfac = function AdaptListBuilderModule_Factory(t) { return new (t || AdaptListBuilderModule)(i0.ɵɵinject(i1.AdaptIconConfig)); };
AdaptListBuilderModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptListBuilderModule });
AdaptListBuilderModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            DragDropModule,
            FormsModule,
            AdaptIconModule,
            AdaptTooltipModule,
            AdaptPopoverModule.forRoot(),
            AdaptEmptyStateModule,
            AdaptSelectSearchFilterModule,
            AdaptTextFieldModule,
            AdaptTypeaheadSubModule,
            AdaptDragonInputHandlerModule,
            AdaptRxLabelModule,
            AdaptCustomActionsModule,
            AdaptHighlightModule,
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptListBuilderModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    DragDropModule,
                    FormsModule,
                    AdaptIconModule,
                    AdaptTooltipModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptEmptyStateModule,
                    AdaptSelectSearchFilterModule,
                    AdaptTextFieldModule,
                    AdaptTypeaheadSubModule,
                    AdaptDragonInputHandlerModule,
                    AdaptRxLabelModule,
                    AdaptCustomActionsModule,
                    AdaptHighlightModule,
                ],
                declarations: [AdaptListBuilderComponent, AdaptListBuilderItemComponent],
                exports: [AdaptListBuilderComponent]
            }]
    }], function () { return [{ type: i1.AdaptIconConfig }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptListBuilderModule, { declarations: [AdaptListBuilderComponent, AdaptListBuilderItemComponent], imports: [CommonModule,
        DragDropModule,
        FormsModule,
        AdaptIconModule,
        AdaptTooltipModule, i1.AdaptPopoverModule, AdaptEmptyStateModule,
        AdaptSelectSearchFilterModule,
        AdaptTextFieldModule,
        AdaptTypeaheadSubModule,
        AdaptDragonInputHandlerModule,
        AdaptRxLabelModule,
        AdaptCustomActionsModule,
        AdaptHighlightModule], exports: [AdaptListBuilderComponent] }); })();

function AdaptRatingComponent_ng_container_0_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r6 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 2);
    i0.ɵɵlistener("mouseenter", function AdaptRatingComponent_ng_container_0_button_2_Template_button_mouseenter_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r6); const index_r4 = restoredCtx.index; const ctx_r5 = i0.ɵɵnextContext(2); return ctx_r5.onEnter(index_r4 + 1); })("click", function AdaptRatingComponent_ng_container_0_button_2_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r6); const index_r4 = restoredCtx.index; const ctx_r7 = i0.ɵɵnextContext(2); return ctx_r7.observerOnClick(index_r4 + 1); });
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "span", 3);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const rating_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("is-active", rating_r3.fill === 100)("is-half-active", rating_r3.fill > 0 && rating_r3.fill < 100)("is-readonly", ctx_r2.disabled);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r2.tooltip[index_r4])("placement", "top");
    i0.ɵɵattribute("tabindex", ctx_r2.disabled ? -1 : null);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r2.tooltip && ctx_r2.tooltip[index_r4] ? ctx_r2.tooltip[index_r4] : rating_r3.index);
} }
function AdaptRatingComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptRatingComponent_ng_container_0_button_2_Template, 5, 11, "button", 1);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r0.ratingList);
} }
function AdaptRatingComponent_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 5);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "span", 3);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const rating_r9 = ctx.$implicit;
    const index_r10 = ctx.index;
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("is-active", rating_r9.fill === 100)("is-half-active", rating_r9.fill > 0 && rating_r9.fill < 100);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r8.tooltip[index_r10])("placement", "top");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r8.tooltip && ctx_r8.tooltip[index_r10] ? ctx_r8.tooltip[index_r10] : rating_r9.index);
} }
function AdaptRatingComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptRatingComponent_ng_container_2_span_2_Template, 5, 8, "span", 4);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r1.ratingList);
} }
const noop$3 = () => {
    return;
};
// TODO: Refactor this if possible
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
const ADAPT_RATING_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptRatingComponent),
    multi: true
};
class AdaptRatingComponent extends AdaptRadarGenericDirective {
    constructor(ts, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRating);
        this.ts = ts;
        this.ratingList = [];
        // eslint-disable-next-line @angular-eslint/no-output-rename
        this.activeRateChanged = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-rename
        this.hoverChanged = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-rename
        this.leaveChanged = new EventEmitter();
        this._onTouchedCallback = noop$3;
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._onChangeCallback = noop$3;
        this._size = 'extra-small';
        this._disabled = false;
        this._maxValue = 5;
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get size() {
        return this._size;
    }
    set size(v) {
        this._size = v;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    get disabled() {
        return this._disabled;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set disabled(v) {
        this._disabled = toBoolean(v);
    }
    get tooltip() {
        return this._tooltip;
    }
    set tooltip(v) {
        this._tooltip = v;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    get maxValue() {
        return this._maxValue;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set maxValue(v) {
        this._maxValue = toNumber(v);
        this._createArrayList();
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    get rate() {
        return this._rate;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set rate(v) {
        this._rate = toNumber(v);
        this._onChangeCallback(v);
    }
    setDefaultTexts(translation) {
        this.tooltip = [
            translation['adapt.rating.like.l1'],
            translation['adapt.rating.like.l2'],
            translation['adapt.rating.like.l3'],
            translation['adapt.rating.like.l4'],
            translation['adapt.rating.like.l5'],
        ];
    }
    writeValue(value) {
        if (this._rate !== value) {
            this._rate = value;
        }
        this._updateValue(value);
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    ngOnInit() {
        this._createArrayList();
        this._updateState(this.rate);
    }
    observerOnClick(value) {
        this._updateValue(value);
    }
    onEnter(value) {
        this.hoverChanged.emit(value);
        if (this._isNotDisabled()) {
            this._updateState(value);
        }
    }
    reset() {
        this.leaveChanged.emit(this.currentRating);
        this._updateState(this.rate);
    }
    _updateValue(v) {
        const ratingValue = this._getValueInRange(v, this.maxValue, 1);
        if (this._isNotDisabled() && this.rate !== ratingValue) {
            this.rate = ratingValue;
        }
        this._updateState(this.rate);
        this.activeRateChanged.emit(this.rate);
    }
    _getValueInRange(value, max, min = 0) {
        return Math.max(Math.min(value, max), min);
    }
    _isNotDisabled() {
        return !this.readonly && !this.disabled;
    }
    _updateState(ratingValue) {
        this.currentRating = ratingValue;
        this.ratingList.map((_, i) => _.fill = this._getFillValue(i));
    }
    _createArrayList() {
        this.ratingList = Array.from({ length: this.maxValue }, (_, v) => ({ fill: 0, index: v }));
    }
    _getFillValue(index) {
        const diff = this.currentRating - index;
        if (diff >= 1) {
            return 100;
        }
        if (diff < 1 && diff > 0) {
            return Number.parseInt((diff * 100).toFixed(2), 10);
        }
        return 0;
    }
}
AdaptRatingComponent.ɵfac = function AdaptRatingComponent_Factory(t) { return new (t || AdaptRatingComponent)(i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRatingComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRatingComponent, selectors: [["adapt-rating"]], hostVars: 10, hostBindings: function AdaptRatingComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("mouseleave", function AdaptRatingComponent_mouseleave_HostBindingHandler() { return ctx.reset(); });
    } if (rf & 2) {
        i0.ɵɵclassProp("a-rating", true)("a-rating_small", ctx.size === "small" && !ctx.readonly)("a-rating_medium", ctx.size === "medium" && !ctx.readonly)("a-rating_large", ctx.size === "large" && !ctx.readonly)("a-rating_readonly", ctx.readonly);
    } }, inputs: { readonly: "readonly", size: "size", disabled: "disabled", tooltip: "tooltip", maxValue: "maxValue", rate: "rate" }, outputs: { activeRateChanged: "active-rate-changed", hoverChanged: "hover-changed", leaveChanged: "leave-changed" }, features: [i0.ɵɵProvidersFeature([ADAPT_RATING_ACCESSOR]), i0.ɵɵInheritDefinitionFeature], decls: 4, vars: 2, consts: [[4, "ngIf"], ["type", "button", "class", "a-rating__item d-icon-star_o", 3, "is-active", "is-half-active", "is-readonly", "adaptRadarDisableEventSending", "adaptTooltip", "placement", "mouseenter", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "a-rating__item", "d-icon-star_o", 3, "adaptRadarDisableEventSending", "adaptTooltip", "placement", "mouseenter", "click"], [1, "sr-only"], ["class", "a-rating__item d-icon-star_o is-readonly", 3, "is-active", "is-half-active", "adaptRadarDisableEventSending", "adaptTooltip", "placement", 4, "ngFor", "ngForOf"], [1, "a-rating__item", "d-icon-star_o", "is-readonly", 3, "adaptRadarDisableEventSending", "adaptTooltip", "placement"]], template: function AdaptRatingComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptRatingComponent_ng_container_0_Template, 4, 1, "ng-container", 0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptRatingComponent_ng_container_2_Template, 4, 1, "ng-container", 0);
        i0.ɵɵtext(3, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", !ctx.readonly);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.readonly);
    } }, directives: [i3.NgIf, i3.NgForOf, i1.AdaptTooltipDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRatingComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rating',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.a-rating]': 'true',
                    '[class.a-rating_small]': 'size === "small" && !readonly',
                    '[class.a-rating_medium]': 'size === "medium" && !readonly',
                    '[class.a-rating_large]': 'size === "large" && !readonly',
                    '[class.a-rating_readonly]': 'readonly',
                    '(mouseleave)': 'reset()'
                },
                templateUrl: './rating.component.html',
                encapsulation: ViewEncapsulation.None,
                providers: [ADAPT_RATING_ACCESSOR]
            }]
    }], function () { return [{ type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { readonly: [{
            type: Input
        }], activeRateChanged: [{
            type: Output,
            args: ['active-rate-changed']
        }], hoverChanged: [{
            type: Output,
            args: ['hover-changed']
        }], leaveChanged: [{
            type: Output,
            args: ['leave-changed']
        }], size: [{
            type: Input
        }], disabled: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], rate: [{
            type: Input
        }] }); })();

function AdaptRatingVotingComponent_button_0_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r2.thanksText);
} }
const _c0$c = function (a0, a1, a2, a3, a4, a5) { return { "d-icon-star": a0, "d-icon-star_o": a1, "d-icon-thumb_up_adapt": a2, "d-icon-thumb_up_o_adapt": a3, "d-icon-flag": a4, "d-icon-flag_o": a5 }; };
function AdaptRatingVotingComponent_button_0_span_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 4);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r3.tooltip !== "" ? ctx_r3.tooltip : "");
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction6(5, _c0$c, ctx_r3.type === "star" && ctx_r3.isActive, ctx_r3.type === "star" && !ctx_r3.isActive, ctx_r3.type === "like" && ctx_r3.isActive, ctx_r3.type === "like" && !ctx_r3.isActive, ctx_r3.type === "flag" && ctx_r3.isActive, ctx_r3.type === "flag" && !ctx_r3.isActive))("placement", ctx_r3.tooltipPlacement)("adaptRadarDisableEventSending", true);
    i0.ɵɵattribute("aria-label", ctx_r3.tooltip || "");
} }
const _c1$a = function (a0, a1, a2, a3, a4) { return { "a-rating-voting__btn": a0, "btn btn-secondary btn-sm": a1, "is-star-icon": a2, "is-active": a3, "active": a4 }; };
function AdaptRatingVotingComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 2);
    i0.ɵɵlistener("click", function AdaptRatingVotingComponent_button_0_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.handleClick(); });
    i0.ɵɵtext(1, "\n\n  ");
    i0.ɵɵtemplate(2, AdaptRatingVotingComponent_button_0_span_2_Template, 2, 1, "span", 1);
    i0.ɵɵtext(3, "\n\n  ");
    i0.ɵɵtemplate(4, AdaptRatingVotingComponent_button_0_span_4_Template, 2, 12, "span", 3);
    i0.ɵɵtext(5, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction5(3, _c1$a, ctx_r0.type !== "thanks", ctx_r0.type === "thanks", ctx_r0.type === "star", ctx_r0.isActive, ctx_r0.type === "thanks" && ctx_r0.isActive));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.type === "thanks");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.type !== "thanks");
} }
function AdaptRatingVotingComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementStart(2, "span", 5);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r1.thanksAbbrMessage, " ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\"", ctx_r1.thanksText, "\"");
} }
const RATING_VOTING_TYPES = [
    'star',
    'flag',
    'like',
    'thanks',
];
class RatingVotingTypeError extends Error {
    constructor(type) {
        super(`Rating voting type "${type}" isn't supported (allowed: star, like, flag, thanks).`);
    }
}
class AdaptRatingVotingComponent extends AdaptRadarGenericDirective {
    constructor(ts, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRatingVoting);
        this.ts = ts;
        this.isActive = false;
        this.wasClick = true;
        this.type = 'star';
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix, @angular-eslint/no-output-rename
        this.onVotingChanged = new EventEmitter();
        this._tooltip = '';
        this._tooltipPlacement = 'top';
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get thanksText() {
        return this._thanksText;
    }
    set thanksText(text) {
        this._thanksText = text;
    }
    get thanksAbbrMessage() {
        return this._thanksAbbrMessage;
    }
    set thanksAbbrMessage(text) {
        this._thanksAbbrMessage = text;
    }
    get tooltip() {
        return this._tooltip;
    }
    set tooltip(v) {
        this._tooltip = v;
    }
    get tooltipPlacement() {
        return this._tooltipPlacement;
    }
    set tooltipPlacement(placement) {
        this._tooltipPlacement = placement;
    }
    setDefaultTexts(translation) {
        this.thanksText = translation['adapt.rating.vote.thank'];
        this.thanksAbbrMessage = translation['adapt.rating.vote.confirm'];
    }
    handleClick() {
        this.isActive = !this.isActive;
        this.onVotingChanged.emit({ type: this.type, isActive: this.isActive });
        if (this.type === 'thanks') {
            this.wasClick = false;
        }
    }
    ngOnChanges() {
        if (this.type && RATING_VOTING_TYPES.indexOf(this.type) === -1) {
            throw new RatingVotingTypeError(this.type);
        }
    }
}
AdaptRatingVotingComponent.ɵfac = function AdaptRatingVotingComponent_Factory(t) { return new (t || AdaptRatingVotingComponent)(i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRatingVotingComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRatingVotingComponent, selectors: [["adapt-rating-voting"]], hostVars: 2, hostBindings: function AdaptRatingVotingComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("a-rating-voting", true);
    } }, inputs: { type: "type", thanksText: "thanksText", thanksAbbrMessage: "thanksAbbrMessage", tooltip: "tooltip", tooltipPlacement: "tooltipPlacement" }, outputs: { onVotingChanged: "voting-change" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 4, vars: 2, consts: [["type", "button", 3, "ngClass", "click", 4, "ngIf"], [4, "ngIf"], ["type", "button", 3, "ngClass", "click"], ["class", "a-rating-voting__icon", 3, "ngClass", "placement", "adaptRadarDisableEventSending", "adaptTooltip", 4, "ngIf"], [1, "a-rating-voting__icon", 3, "ngClass", "placement", "adaptRadarDisableEventSending", "adaptTooltip"], [1, "font-weight-semibold"]], template: function AdaptRatingVotingComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptRatingVotingComponent_button_0_Template, 6, 9, "button", 0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptRatingVotingComponent_span_2_Template, 4, 2, "span", 1);
        i0.ɵɵtext(3, "\n\n\n\n\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.wasClick);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.wasClick);
    } }, directives: [i3.NgIf, i3.NgClass, i1.AdaptTooltipDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRatingVotingComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rating-voting',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.a-rating-voting]': 'true'
                },
                templateUrl: './rating-voting.component.html',
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { type: [{
            type: Input
        }], onVotingChanged: [{
            type: Output,
            args: ['voting-change']
        }], thanksText: [{
            type: Input
        }], thanksAbbrMessage: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], tooltipPlacement: [{
            type: Input
        }] }); })();

var RatingLikeEnum;
(function (RatingLikeEnum) {
    RatingLikeEnum[RatingLikeEnum["point"] = 5] = "point";
    RatingLikeEnum[RatingLikeEnum["point2"] = 3] = "point2";
})(RatingLikeEnum || (RatingLikeEnum = {}));

const _c0$b = function (a0, a1) { return { "is-selected": a0, "is-inactive": a1 }; };
function AdaptRatingLikeComponent_ng_container_0_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 2);
    i0.ɵɵlistener("click", function AdaptRatingLikeComponent_ng_container_0_button_2_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r8); const index_r2 = i0.ɵɵnextContext().index; const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.handleClick($event, index_r2); });
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext();
    const item_r1 = ctx_r9.$implicit;
    const index_r2 = ctx_r9.index;
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("a-rating__item is-", item_r1, "");
    i0.ɵɵclassProp("is-disabled", ctx_r5.disabledList.indexOf(index_r2) !== -1);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", !ctx_r5.disabled && ctx_r5.tooltip[index_r2] !== "" ? ctx_r5.tooltip[index_r2] : "")("ngClass", i0.ɵɵpureFunction2(11, _c0$b, ctx_r5.selectedLike === index_r2, ctx_r5.selectedLike !== index_r2 && ctx_r5.selectedLike !== null))("disabled", ctx_r5.disabled)("placement", ctx_r5.tooltipPlacement);
    i0.ɵɵattribute("aria-label", ctx_r5.tooltip[index_r2] || "");
} }
function AdaptRatingLikeComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptRatingLikeComponent_ng_container_0_button_2_Template, 2, 14, "button", 1);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r3 = ctx.last;
    const first_r4 = ctx.first;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.point === 3 ? !last_r3 && !first_r4 : true);
} }
const RatingLikeTypes = [
    'terrible',
    'disliked',
    'ok',
    'good',
    'excellent'
];
class RatingLikeValuesError extends Error {
    constructor(length) {
        super(`Rating Like values parameter should have 3 or 5 string values. Instead got ${length} values.`);
    }
}
class AdaptRatingLikeComponent extends AdaptRadarGenericDirective {
    constructor(ts, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRatingLike);
        this.ts = ts;
        this.selectedLike = null;
        this.types = RatingLikeTypes;
        this.disabled = false;
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onChange = new EventEmitter();
        this._ratingValues = RatingLikeTypes;
        this._point = RatingLikeEnum.point;
        this._tooltipPlacement = 'top';
        this._size = 'small';
        this._disabledList = [];
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get ratingValues() {
        return this._ratingValues;
    }
    set ratingValues(v) {
        if (v.length === 5) {
            this._ratingValues = v;
        }
        else if (v.length === 3) {
            this._ratingValues = ['', ...v, ''];
        }
        else {
            throw new RatingLikeValuesError(v.length);
        }
    }
    get point() {
        return this._point;
    }
    set point(v) {
        this._point = toNumber(v);
    }
    get tooltip() {
        return this._tooltip;
    }
    set tooltip(v) {
        this._tooltip = v;
    }
    get tooltipPlacement() {
        return this._tooltipPlacement;
    }
    set tooltipPlacement(placement) {
        this._tooltipPlacement = placement;
    }
    get size() {
        return this._size;
    }
    set size(v) {
        this._size = v;
    }
    get disabledList() {
        return this._disabledList;
    }
    set disabledList(array) {
        this._disabledList = array;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set rate(v) {
        const setValue = toNumber(v);
        if (setValue && setValue > 0 && setValue <= this.point) {
            this.selectedLike = setValue - 1;
        }
    }
    setDefaultTexts(translation) {
        this.tooltip = [
            translation['adapt.rating.like.l1'],
            translation['adapt.rating.like.l2'],
            translation['adapt.rating.like.l3'],
            translation['adapt.rating.like.l4'],
            translation['adapt.rating.like.l5'],
        ];
    }
    handleClick(e, index) {
        if (!this.disabled) {
            this._stopDisabled(e, index);
            this.selectedLike = index;
            this.onChange.emit({ type: this.ratingValues[index] });
        }
    }
    _stopDisabled(e, index) {
        if (this.disabledList.indexOf(index) === -1) {
            e.preventDefault();
            e.stopPropagation();
        }
    }
}
AdaptRatingLikeComponent.ɵfac = function AdaptRatingLikeComponent_Factory(t) { return new (t || AdaptRatingLikeComponent)(i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRatingLikeComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRatingLikeComponent, selectors: [["adapt-rating-like"]], hostVars: 10, hostBindings: function AdaptRatingLikeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("a-rating", true)("a-rating_like", true)("a-rating_small", ctx.size === "small")("a-rating_medium", ctx.size === "medium")("a-rating_large", ctx.size === "large");
    } }, inputs: { disabled: "disabled", ratingValues: "ratingValues", point: "point", tooltip: "tooltip", tooltipPlacement: "tooltipPlacement", size: "size", disabledList: "disabledList", rate: "rate" }, outputs: { onChange: "onChange" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["type", "button", 3, "class", "is-disabled", "adaptRadarDisableEventSending", "adaptTooltip", "ngClass", "disabled", "placement", "click", 4, "ngIf"], ["type", "button", 3, "adaptRadarDisableEventSending", "adaptTooltip", "ngClass", "disabled", "placement", "click"]], template: function AdaptRatingLikeComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptRatingLikeComponent_ng_container_0_Template, 4, 1, "ng-container", 0);
        i0.ɵɵtext(1, "\n\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngForOf", ctx.types);
    } }, directives: [i3.NgForOf, i3.NgIf, i1.AdaptTooltipDirective, i3.NgClass], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRatingLikeComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rating-like',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.a-rating]': 'true',
                    '[class.a-rating_like]': 'true',
                    '[class.a-rating_small]': 'size === "small" ',
                    '[class.a-rating_medium]': 'size === "medium" ',
                    '[class.a-rating_large]': 'size === "large" '
                },
                templateUrl: './rating-like.component.html',
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { disabled: [{
            type: Input
        }], onChange: [{
            type: Output
        }], ratingValues: [{
            type: Input
        }], point: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], tooltipPlacement: [{
            type: Input
        }], size: [{
            type: Input
        }], disabledList: [{
            type: Input
        }], rate: [{
            type: Input
        }] }); })();

const _c0$a = function (a0) { return { "d-icon-thumb_up_adapt": a0 }; };
const _c1$9 = function (a0) { return { "d-icon-thumb_down_adapt": a0 }; };
function AdaptRatingBinaryComponent_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "button", 4);
    i0.ɵɵlistener("click", function AdaptRatingBinaryComponent_div_1_ng_container_2_Template_button_click_2_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(2); return ctx_r4.handleClick($event, "like"); });
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementStart(4, "span");
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n    ");
    i0.ɵɵelementStart(8, "button", 4);
    i0.ɵɵlistener("click", function AdaptRatingBinaryComponent_div_1_ng_container_2_Template_button_click_8_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r6 = i0.ɵɵnextContext(2); return ctx_r6.handleClick($event, "dislike"); });
    i0.ɵɵtext(9, "\n      ");
    i0.ɵɵelementStart(10, "span");
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(8, _c0$a, ctx_r2.type === "icon"));
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("sr-only", ctx_r2.type === "icon");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r2.btnTextLeft);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(10, _c1$9, ctx_r2.type === "icon"));
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("sr-only", ctx_r2.type === "icon");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r2.btnTextRight);
} }
function AdaptRatingBinaryComponent_div_1_div_4_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r7.showMessage);
} }
function AdaptRatingBinaryComponent_div_1_div_4_span_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementStart(2, "span", 6);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵprojection(5);
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r8.textMessage, " ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate3("", ctx_r8.quotesLeft, "", ctx_r8.showBtnValue, "", ctx_r8.quotesRight, ". ");
} }
function AdaptRatingBinaryComponent_div_1_div_4_a_6_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 7);
    i0.ɵɵlistener("click", function AdaptRatingBinaryComponent_div_1_div_4_a_6_Template_a_click_0_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(3); return ctx_r10.handleClick($event, ""); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r9.undoButton);
} }
function AdaptRatingBinaryComponent_div_1_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptRatingBinaryComponent_div_1_div_4_span_2_Template, 2, 1, "span", 3);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptRatingBinaryComponent_div_1_div_4_span_4_Template, 7, 4, "span", 3);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵtemplate(6, AdaptRatingBinaryComponent_div_1_div_4_a_6_Template, 2, 1, "a", 5);
    i0.ɵɵtext(7, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.type === "icon");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.type === "text");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.undoButton !== "");
} }
function AdaptRatingBinaryComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 2);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptRatingBinaryComponent_div_1_ng_container_2_Template, 14, 12, "ng-container", 3);
    i0.ɵɵtext(3, "\n\n  ");
    i0.ɵɵtemplate(4, AdaptRatingBinaryComponent_div_1_div_4_Template, 8, 3, "div", 3);
    i0.ɵɵtext(5, "\n\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.toggle);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r0.toggle);
} }
function AdaptRatingBinaryComponent_div_3_button_11_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 14);
    i0.ɵɵlistener("click", function AdaptRatingBinaryComponent_div_3_button_11_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r15); const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.changeValue("decrease"); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 10);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r12.btnTextRight);
} }
function AdaptRatingBinaryComponent_div_3_div_13_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r18 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 7);
    i0.ɵɵlistener("click", function AdaptRatingBinaryComponent_div_3_div_13_a_2_Template_a_click_0_listener($event) { i0.ɵɵrestoreView(_r18); const ctx_r17 = i0.ɵɵnextContext(3); return ctx_r17.cancelValue($event); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r16 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r16.undoButton);
} }
function AdaptRatingBinaryComponent_div_3_div_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptRatingBinaryComponent_div_3_div_13_a_2_Template, 2, 1, "a", 5);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r13.undoButton !== "");
} }
function AdaptRatingBinaryComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r20 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 8);
    i0.ɵɵtext(1, "\n\n    ");
    i0.ɵɵelementStart(2, "button", 9);
    i0.ɵɵlistener("click", function AdaptRatingBinaryComponent_div_3_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r20); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.changeValue("increase"); });
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementStart(4, "span", 10);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n    ");
    i0.ɵɵelementStart(8, "div", 11);
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵtemplate(11, AdaptRatingBinaryComponent_div_3_button_11_Template, 5, 1, "button", 12);
    i0.ɵɵtext(12, "\n\n    ");
    i0.ɵɵtemplate(13, AdaptRatingBinaryComponent_div_3_div_13_Template, 4, 1, "div", 13);
    i0.ɵɵtext(14, "\n\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("a-rating_btn-hidden", !ctx_r1.toggle);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r1.btnTextLeft);
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("font-weight-semibold", !ctx_r1.toggle);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.value);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r1.toggle);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r1.toggle);
} }
const _c2$8 = ["*"];
const RATING_BINARY_TYPE = ['icon', 'text', 'count'];
class RatingBinaryTypeError extends Error {
    constructor(type) {
        super(`Rating binary type "${type}" isn't supported (allowed: 'icon', 'text', 'count').`);
    }
}
class AdaptRatingBinaryComponent extends AdaptRadarGenericDirective {
    constructor(_element, _renderer, ts, _adaptRadarService) {
        super(_adaptRadarService, _element, AdaptRadarAngularCustomEventName.AdaptRatingBinary);
        this._element = _element;
        this._renderer = _renderer;
        this.ts = ts;
        this.toggle = true;
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix, @angular-eslint/no-output-rename
        this.onChangeValue = new EventEmitter();
        this._type = 'text';
        this._value = 12;
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get type() {
        return this._type;
    }
    set type(t) {
        this._type = t;
    }
    get likeMessage() {
        return this._likeMessage;
    }
    set likeMessage(message) {
        this._likeMessage = message;
    }
    get dislikeMessage() {
        return this._dislikeMessage;
    }
    set dislikeMessage(message) {
        this._dislikeMessage = message;
    }
    get textMessage() {
        return this._textMessage;
    }
    set textMessage(v) {
        this._textMessage = v;
    }
    get value() {
        return this._value;
    }
    set value(v) {
        this._value = v;
    }
    setDefaultTexts(translation) {
        this.btnTextLeft = translation['adapt.rating.binary.left'];
        this.btnTextRight = translation['adapt.rating.binary.right'];
        this.undoButton = translation['adapt.common.undo'];
        this.quotesLeft = translation['adapt.common.doubleQuotesLeft'];
        this.quotesRight = translation['adapt.common.doubleQuotesRight'];
        this._likeMessage = translation['adapt.rating.binary.like'];
        this._dislikeMessage = translation['adapt.rating.binary.dislike'];
        this._textMessage = translation['adapt.rating.binary.confirm'];
    }
    handleClick(e, type = '') {
        e.preventDefault();
        this._setHostStyles();
        this._toggleState();
        switch (type) {
            case 'like':
                this.showMessage = this.likeMessage;
                this.showBtnValue = this.btnTextLeft;
                this.onChangeValue.emit({ value: this.btnTextLeft });
                break;
            case 'dislike':
                this.showMessage = this.dislikeMessage;
                this.showBtnValue = this.btnTextRight;
                this.onChangeValue.emit({ value: this.btnTextRight });
                break;
            default:
                this.onChangeValue.emit({ value: this.undoButton });
                break;
        }
    }
    changeValue(action) {
        this._setHostStyles();
        this._toggleState();
        switch (action) {
            case 'increase':
                this.savedValue = this.value;
                this.value++;
                this.onChangeValue.emit({ value: this.value });
                break;
            case 'decrease':
                this.savedValue = this.value;
                this.value--;
                this.onChangeValue.emit({ value: this.value });
                break;
        }
    }
    cancelValue(e) {
        e.preventDefault();
        this.reset();
    }
    reset() {
        this.value = this.savedValue;
        this.onChangeValue.emit({ value: this.undoButton });
        this._toggleState();
    }
    ngOnChanges() {
        if (this.type && RATING_BINARY_TYPE.indexOf(this.type) === -1) {
            throw new RatingBinaryTypeError(this.type);
        }
    }
    _setHostStyles() {
        if (this._element) {
            const { nativeElement } = this._element;
            const { offsetHeight } = nativeElement;
            this._renderer.setStyle(nativeElement, 'minHeight', `${offsetHeight}px`);
            this._renderer.addClass(nativeElement, 'a-rating-center');
        }
    }
    _toggleState() {
        this.toggle = !this.toggle;
    }
}
AdaptRatingBinaryComponent.ɵfac = function AdaptRatingBinaryComponent_Factory(t) { return new (t || AdaptRatingBinaryComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService)); };
AdaptRatingBinaryComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRatingBinaryComponent, selectors: [["adapt-rating-binary"]], hostVars: 2, hostBindings: function AdaptRatingBinaryComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("a-rating-binary", true);
    } }, inputs: { btnTextLeft: "btnTextLeft", btnTextRight: "btnTextRight", undoButton: "undoButton", type: "type", likeMessage: "likeMessage", dislikeMessage: "dislikeMessage", textMessage: "textMessage", value: "value" }, outputs: { onChangeValue: "change-value" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2$8, decls: 5, vars: 2, consts: [["class", "btn-group", 4, "ngIf"], ["class", "btn-group a-rating-group", 4, "ngIf"], [1, "btn-group"], [4, "ngIf"], ["type", "button", 1, "btn", "btn-secondary", 3, "ngClass", "click"], ["href", "#", 3, "click", 4, "ngIf"], [1, "font-weight-semibold"], ["href", "#", 3, "click"], [1, "btn-group", "a-rating-group"], ["type", "button", 1, "btn", "btn-secondary", "d-icon-triangle_up", 3, "click"], [1, "sr-only"], [1, "a-rating-group__value"], ["type", "button", "class", "btn btn-secondary d-icon-triangle_down", 3, "click", 4, "ngIf"], ["class", "a-rating__undo-container", 4, "ngIf"], ["type", "button", 1, "btn", "btn-secondary", "d-icon-triangle_down", 3, "click"], [1, "a-rating__undo-container"]], template: function AdaptRatingBinaryComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtext(0, "\n");
        i0.ɵɵtemplate(1, AdaptRatingBinaryComponent_div_1_Template, 6, 2, "div", 0);
        i0.ɵɵtext(2, "\n\n");
        i0.ɵɵtemplate(3, AdaptRatingBinaryComponent_div_3_Template, 15, 8, "div", 1);
        i0.ɵɵtext(4, "\n\n\n\n\n");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.type !== "count");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.type === "count");
    } }, directives: [i3.NgIf, i3.NgClass], styles: ["\n    /* Hot fix for IE 11 */\n    .a-rating-center::after {\n      content: '';\n      display: inline-block;\n      min-height: inherit;\n      font-size: 0;\n    }\n  "], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRatingBinaryComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rating-binary',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.a-rating-binary]': 'true'
                },
                templateUrl: './rating-binary.component.html',
                encapsulation: ViewEncapsulation.None,
                styles: [`
    /* Hot fix for IE 11 */
    .a-rating-center::after {
      content: '';
      display: inline-block;
      min-height: inherit;
      font-size: 0;
    }
  `]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }]; }, { btnTextLeft: [{
            type: Input
        }], btnTextRight: [{
            type: Input
        }], undoButton: [{
            type: Input
        }], onChangeValue: [{
            type: Output,
            args: ['change-value']
        }], type: [{
            type: Input
        }], likeMessage: [{
            type: Input
        }], dislikeMessage: [{
            type: Input
        }], textMessage: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();

class AdaptRatingModule {
}
AdaptRatingModule.ɵfac = function AdaptRatingModule_Factory(t) { return new (t || AdaptRatingModule)(); };
AdaptRatingModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptRatingModule });
AdaptRatingModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule, AdaptTooltipModule, AdaptIconModule, FormsModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRatingModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, AdaptTooltipModule, AdaptIconModule, FormsModule],
                exports: [AdaptRatingComponent, AdaptRatingVotingComponent, AdaptRatingLikeComponent, AdaptRatingBinaryComponent],
                declarations: [AdaptRatingComponent, AdaptRatingVotingComponent, AdaptRatingLikeComponent, AdaptRatingBinaryComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptRatingModule, { declarations: [AdaptRatingComponent, AdaptRatingVotingComponent, AdaptRatingLikeComponent, AdaptRatingBinaryComponent], imports: [CommonModule, AdaptTooltipModule, AdaptIconModule, FormsModule], exports: [AdaptRatingComponent, AdaptRatingVotingComponent, AdaptRatingLikeComponent, AdaptRatingBinaryComponent] }); })();

const _c0$9 = ["search"];
const _c1$8 = function (a0, a1) { return { "adapt-search-active": a0, "adapt-search-dirty": a1 }; };
const _c2$7 = function (a0) { return { "sr-only": a0 }; };
const _c3$5 = function (a0) { return { "adapt-search-clear-visible": a0 }; };
function AdaptSearchComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 2);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelement(2, "div", 3);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementStart(4, "div", 4);
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵelementStart(6, "label", 5);
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementStart(8, "span", 6);
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵelementStart(11, "span", 7);
    i0.ɵɵtext(12);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n        ");
    i0.ɵɵelementStart(15, "input", 8, 9);
    i0.ɵɵlistener("ngModelChange", function AdaptSearchComponent_div_1_Template_input_ngModelChange_15_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.value = $event; })("blur", function AdaptSearchComponent_div_1_Template_input_blur_15_listener() { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.onBlur(); })("focus", function AdaptSearchComponent_div_1_Template_input_focus_15_listener() { i0.ɵɵrestoreView(_r4); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.onFocus(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n      ");
    i0.ɵɵelementStart(19, "button", 10);
    i0.ɵɵlistener("click", function AdaptSearchComponent_div_1_Template_button_click_19_listener() { i0.ɵɵrestoreView(_r4); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.clear(); });
    i0.ɵɵtext(20, "\n        ");
    i0.ɵɵelementStart(21, "span", 11);
    i0.ɵɵtext(22);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(10, _c1$8, ctx_r0.isActive, ctx_r0.canClear || ctx_r0.initialAlign === "left"));
    i0.ɵɵadvance(6);
    i0.ɵɵpropertyInterpolate("for", ctx_r0.id);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(13, _c2$7, ctx_r0.label || ctx_r0.placeholder));
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r0.label || ctx_r0.placeholder);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r0.placeholder);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("id", ctx_r0.id)("ngModel", ctx_r0.value)("placeholder", ctx_r0.placeholder);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(15, _c3$5, ctx_r0.canClear));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r0.btnClearText);
} }
function AdaptSearchComponent_div_3_span_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 19);
} }
const _c4$3 = function (a0) { return { "adapt-search-dirty": a0 }; };
const _c5$3 = function (a0) { return [a0]; };
function AdaptSearchComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 12);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "div", 13);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "div", 14);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementStart(6, "input", 15, 9);
    i0.ɵɵlistener("ngModelChange", function AdaptSearchComponent_div_3_Template_input_ngModelChange_6_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.value = $event; })("blur", function AdaptSearchComponent_div_3_Template_input_blur_6_listener() { i0.ɵɵrestoreView(_r11); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.onBlur(); })("focus", function AdaptSearchComponent_div_3_Template_input_focus_6_listener() { i0.ɵɵrestoreView(_r11); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.onFocus(); })("keyup.enter", function AdaptSearchComponent_div_3_Template_input_keyup_enter_6_listener() { i0.ɵɵrestoreView(_r11); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.setValue(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementStart(9, "button", 10);
    i0.ɵɵlistener("click", function AdaptSearchComponent_div_3_Template_button_click_9_listener() { i0.ɵɵrestoreView(_r11); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.clear(); });
    i0.ɵɵtext(10, "\n            ");
    i0.ɵɵelementStart(11, "span", 11);
    i0.ɵɵtext(12);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n        ");
    i0.ɵɵelementStart(16, "div", 16);
    i0.ɵɵtext(17, "\n          ");
    i0.ɵɵelementStart(18, "button", 17);
    i0.ɵɵlistener("click", function AdaptSearchComponent_div_3_Template_button_click_18_listener() { i0.ɵɵrestoreView(_r11); const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.setValue(); });
    i0.ɵɵtext(19, "\n            ");
    i0.ɵɵtemplate(20, AdaptSearchComponent_div_3_span_20_Template, 1, 0, "span", 18);
    i0.ɵɵtext(21, "\n            ");
    i0.ɵɵelementStart(22, "span");
    i0.ɵɵtext(23);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(26, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(27, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(17, _c4$3, ctx_r1.canClear || ctx_r1.initialAlign === "left"));
    i0.ɵɵadvance(6);
    i0.ɵɵclassProp("form-control-sm", ctx_r1.size === "small")("form-control-lg", ctx_r1.size === "large");
    i0.ɵɵproperty("id", ctx_r1.id)("ngModel", ctx_r1.value)("placeholder", ctx_r1.placeholder);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(19, _c3$5, ctx_r1.canClear));
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r1.btnClearText);
    i0.ɵɵadvance(6);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("ngClass", i0.ɵɵpureFunction1(21, _c5$3, ctx_r1.explicitSearchBtn ? "explicit-search-btn" : "adapt-search-button"))("size", ctx_r1.size);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r1.explicitSearchBtn);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("sr-only", !ctx_r1.explicitSearchBtn);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.btnSearchText);
} }
let nextId$1 = 0;
class AdaptSearchComponent extends AdaptRadarGenericDirective {
    constructor(ts, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptSearch);
        this.ts = ts;
        this.label = '';
        this.debounceTime = 300;
        this.id = `adapt-search-unique-${nextId$1++}`;
        this.triggerableSearch = false;
        this.size = null;
        this.explicitSearchBtn = false;
        this.value = '';
        this.initialAlign = 'centre';
        this.valueChanged = new EventEmitter();
        this.focusChanged = new EventEmitter();
        this._isActive = false;
        const translation = ts.getCurrentLanguage();
        this.placeholder = translation['adapt.common.search'];
        this.btnClearText = translation['adapt.common.clear'];
        this.btnSearchText = translation['adapt.common.search'];
    }
    set searchValue(searchVal) {
        this.value = searchVal;
    }
    get searchValue() {
        return this.value;
    }
    onClick(event) {
        const target = event.target;
        if (!this.triggerableSearch || (this.triggerableSearch && target.classList.contains('adapt-search-clear'))) {
            this.setActive();
        }
    }
    setActive() {
        this.search.nativeElement.focus();
        this._changeActive(true);
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (!this.triggerableSearch) {
            fromEvent(this.search.nativeElement, 'input')
                .pipe(debounceTime(this.debounceTime)).subscribe(() => this.valueChanged.emit(this.value));
        }
    }
    get isActive() {
        return this._isActive;
    }
    get isAdaptSearchDirty() {
        // only check canClear or create separate class with aligning left
        return this.canClear || this.initialAlign === 'left';
    }
    get canClear() {
        return !!this.value;
    }
    onBlur() {
        this._changeActive(false);
    }
    onFocus() {
        this._changeActive(true);
    }
    setValue() {
        if (this.triggerableSearch) {
            this.valueChanged.emit(this.value);
        }
    }
    clear() {
        this.value = '';
        this.valueChanged.emit(this.value);
        this.focusChanged.emit(this._isActive);
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _changeActive(value) {
        this._isActive = toBoolean(value);
        this.focusChanged.emit(this._isActive);
    }
}
AdaptSearchComponent.ɵfac = function AdaptSearchComponent_Factory(t) { return new (t || AdaptSearchComponent)(i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptSearchComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSearchComponent, selectors: [["adapt-search"]], viewQuery: function AdaptSearchComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$9, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.search = _t.first);
    } }, hostBindings: function AdaptSearchComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("click", function AdaptSearchComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, inputs: { placeholder: "placeholder", btnClearText: "btnClearText", btnSearchText: "btnSearchText", label: "label", debounceTime: "debounceTime", id: "id", triggerableSearch: "triggerableSearch", size: "size", explicitSearchBtn: "explicitSearchBtn", searchValue: "searchValue", initialAlign: "initialAlign" }, outputs: { valueChanged: "valueChanged", focusChanged: "focusChanged" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 5, vars: 2, consts: [["class", "adapt-search", 3, "ngClass", 4, "ngIf"], ["class", "adapt-search-triggerable", 3, "ngClass", 4, "ngIf"], [1, "adapt-search", 3, "ngClass"], [1, "adapt-search-icon", "d-icon-search"], [1, "adapt-search-field-wrapper"], [1, "adapt-search-field-layout", "adapt-search-field-ellipsis", 3, "for"], [3, "ngClass"], [2, "visibility", "hidden"], ["type", "search", 1, "adapt-search-field", "adapt-search-field-ellipsis", 3, "id", "ngModel", "placeholder", "ngModelChange", "blur", "focus"], ["search", ""], ["type", "button", 1, "adapt-search-clear", "d-icon-cross_adapt", "btn", "btn-link", 3, "ngClass", "click"], [1, "sr-only"], [1, "adapt-search-triggerable", 3, "ngClass"], [1, "input-group", "flex-nowrap"], [2, "position", "relative", "width", "100%"], ["type", "search", 1, "form-control", "adapt-search-field-ellipsis", 3, "id", "ngModel", "placeholder", "ngModelChange", "blur", "focus", "keyup.enter"], [1, "input-group-append"], ["adapt-button", "", "btn-type", "secondary", "type", "button", 3, "adaptRadarDisableEventSending", "ngClass", "size", "click"], ["class", "d-icon-search", 4, "ngIf"], [1, "d-icon-search"]], template: function AdaptSearchComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵtemplate(1, AdaptSearchComponent_div_1_Template, 25, 17, "div", 0);
        i0.ɵɵtext(2, "\n\n    ");
        i0.ɵɵtemplate(3, AdaptSearchComponent_div_3_Template, 28, 23, "div", 1);
        i0.ɵɵtext(4, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.triggerableSearch);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.triggerableSearch);
    } }, directives: [i3.NgIf, i3.NgClass, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i6.NgControlStatus, i6.NgModel, i1.AdaptButtonComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSearchComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-search',
                template: `
    <div *ngIf="!triggerableSearch" class="adapt-search"
         [ngClass]="{'adapt-search-active': isActive, 'adapt-search-dirty': canClear || initialAlign === 'left'}">
      <div class="adapt-search-icon d-icon-search"></div>
      <div class="adapt-search-field-wrapper">
        <label class="adapt-search-field-layout adapt-search-field-ellipsis" for="{{id}}">
          <span [ngClass]="{'sr-only': label || placeholder}">{{label || placeholder}}</span>
          <span style="visibility: hidden">{{placeholder}}</span>
        </label>
        <input #search class="adapt-search-field adapt-search-field-ellipsis"
               type="search"
               [id]="id"
               [(ngModel)]="value"
               [placeholder]="placeholder"
               (blur)="onBlur()"
               (focus)="onFocus()"/>
      </div>
      <button class="adapt-search-clear d-icon-cross_adapt btn btn-link"
              (click)="clear()"
              [ngClass]="{'adapt-search-clear-visible': canClear}"
              type="button">
        <span class="sr-only">{{btnClearText}}</span>
      </button>
    </div>

    <div *ngIf="triggerableSearch" class="adapt-search-triggerable"
         [ngClass]="{'adapt-search-dirty': canClear || initialAlign === 'left'}">
      <div class="input-group flex-nowrap">
        <div style="position: relative; width: 100%;">
          <input class="form-control adapt-search-field-ellipsis"
                 [class.form-control-sm]="size === 'small'"
                 [class.form-control-lg]="size === 'large'"
                 type="search"
                 #search
                 [id]="id"
                 [(ngModel)]="value"
                 [placeholder]="placeholder"
                 (blur)="onBlur()"
                 (focus)="onFocus()"
                 (keyup.enter)="setValue()"/>
          <button class="adapt-search-clear d-icon-cross_adapt btn btn-link"
                  (click)="clear()"
                  [ngClass]="{'adapt-search-clear-visible': canClear}"
                  type="button">
            <span class="sr-only">{{btnClearText}}</span>
          </button>
        </div>
        <div class="input-group-append">
          <button adapt-button
                  [adaptRadarDisableEventSending]="true"
                  btn-type="secondary"
                  [ngClass]="[explicitSearchBtn ? 'explicit-search-btn' : 'adapt-search-button']"
                  (click)="setValue()"
                  [size]="size"
                  type="button">
            <span *ngIf="!explicitSearchBtn" class="d-icon-search"></span>
            <span [class.sr-only]="!explicitSearchBtn">{{ btnSearchText }}</span>
          </button>
        </div>
      </div>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { search: [{
            type: ViewChild,
            args: ['search', { static: false }]
        }], placeholder: [{
            type: Input
        }], btnClearText: [{
            type: Input
        }], btnSearchText: [{
            type: Input
        }], label: [{
            type: Input
        }], debounceTime: [{
            type: Input
        }], id: [{
            type: Input
        }], triggerableSearch: [{
            type: Input
        }], size: [{
            type: Input
        }], explicitSearchBtn: [{
            type: Input
        }], searchValue: [{
            type: Input
        }], initialAlign: [{
            type: Input
        }], valueChanged: [{
            type: Output
        }], focusChanged: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

class AdaptSearchModule {
}
AdaptSearchModule.ɵfac = function AdaptSearchModule_Factory(t) { return new (t || AdaptSearchModule)(); };
AdaptSearchModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptSearchModule });
AdaptSearchModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule, FormsModule, AdaptDragonInputHandlerModule, AdaptButtonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSearchModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, FormsModule, AdaptDragonInputHandlerModule, AdaptButtonModule],
                declarations: [AdaptSearchComponent],
                exports: [AdaptSearchComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptSearchModule, { declarations: [AdaptSearchComponent], imports: [CommonModule, FormsModule, AdaptDragonInputHandlerModule, AdaptButtonModule], exports: [AdaptSearchComponent] }); })();

const _c0$8 = ["button"];
function AdaptTimeSlotComponent_div_2_span_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 7);
} }
function AdaptTimeSlotComponent_div_2_adapt_icon_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 8);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", ctx_r3.tooltipIcon)("adaptTooltip", ctx_r3.tooltipText);
} }
function AdaptTimeSlotComponent_div_2_adapt_icon_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 9);
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("name", ctx_r4.popoverIcon)("adaptRadarDisableEventSending", true)("placement", ctx_r4.popoverPlacement)("adaptPopover", ctx_r4.popoverContent)("triggers", ctx_r4.popoverTriggers);
} }
function AdaptTimeSlotComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 3);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "span");
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵtemplate(5, AdaptTimeSlotComponent_div_2_span_5_Template, 1, 0, "span", 4);
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵtemplate(7, AdaptTimeSlotComponent_div_2_adapt_icon_7_Template, 1, 3, "adapt-icon", 5);
    i0.ɵɵtext(8, "\n    ");
    i0.ɵɵtemplate(9, AdaptTimeSlotComponent_div_2_adapt_icon_9_Template, 1, 5, "adapt-icon", 6);
    i0.ɵɵtext(10, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r0.label);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.tooltipIcon || ctx_r0.popoverIcon);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.tooltipIcon && !ctx_r0.popoverIcon);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.popoverIcon);
} }
function AdaptTimeSlotComponent_div_4_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 12, 13);
    i0.ɵɵlistener("click", function AdaptTimeSlotComponent_div_4_button_2_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r10); const i_r7 = restoredCtx.index; const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.isSelected(i_r7); });
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const s_r6 = ctx.$implicit;
    const i_r7 = ctx.index;
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("active", ctx_r5.selectedSlot !== null && ctx_r5.selectedSlot === i_r7);
    i0.ɵɵproperty("@slotsAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate1("\n      ", s_r6, "\n    ");
} }
function AdaptTimeSlotComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 10);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptTimeSlotComponent_div_4_button_2_Template, 3, 4, "button", 11);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r1.slot);
} }
class AdaptTimeSlotComponent extends AdaptRadarGenericDirective {
    constructor(_renderer, ts, _ngZone, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptTimeSlot);
        this._renderer = _renderer;
        this.ts = ts;
        this._ngZone = _ngZone;
        this.popoverPlacement = 'top';
        this.popoverTriggers = 'click';
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any, @angular-eslint/no-output-rename */
        this.selectedSlotChanged = new EventEmitter();
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._slot = [];
        this._selectedSlot = null;
        const translation = ts.getCurrentLanguage();
        this._label = translation['adapt.timeSlot.available'];
    }
    get label() {
        return this._label;
    }
    set label(v) {
        this._label = v;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    get slot() {
        return this._slot;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set slot(v) {
        this._slot = v;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    get selectedSlot() {
        return this._selectedSlot;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set selectedSlot(slot) {
        this._selectedSlot = toNumber(slot);
    }
    isSelected(index) {
        if (this.selectedSlot === index) {
            this.selectedSlot = null;
            this.selectedSlotChanged.emit({ index: null, slot: null });
        }
        else {
            this.selectedSlot = index;
            this.selectedSlotChanged.emit({ index: this.selectedSlot, slot: this.slot[this.selectedSlot] });
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._setSlotMaxWidth();
    }
    ngOnChanges(changes) {
        if (changes.slot) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this._setSlotMaxWidth();
            });
        }
    }
    _setSlotMaxWidth() {
        const btn = this.button.toArray();
        if (btn) {
            const arr = btn.map(item => item.nativeElement.clientWidth);
            const max = Math.round(Math.max(...arr));
            btn.map(_ => this._renderer.setStyle(_.nativeElement, 'width', `${max}px`));
        }
    }
}
AdaptTimeSlotComponent.ɵfac = function AdaptTimeSlotComponent_Factory(t) { return new (t || AdaptTimeSlotComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptTimeSlotComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTimeSlotComponent, selectors: [["adapt-time-slot"]], viewQuery: function AdaptTimeSlotComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$8, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.button = _t);
    } }, inputs: { tooltipIcon: "tooltipIcon", tooltipText: "tooltipText", popoverIcon: "popoverIcon", popoverPlacement: "popoverPlacement", popoverTriggers: "popoverTriggers", popoverContent: "popoverContent", label: "label", slot: "slot", selectedSlot: "selectedSlot" }, outputs: { selectedSlotChanged: "selected-slot-changed" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 7, vars: 2, consts: [[1, "a-slot"], ["class", "a-slot__label form-control-label", 4, "ngIf"], ["class", "a-slot__list", 4, "ngIf"], [1, "a-slot__label", "form-control-label"], ["class", "icon-space", 4, "ngIf"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip", 4, "ngIf"], [3, "name", "adaptRadarDisableEventSending", "placement", "adaptPopover", "triggers", 4, "ngIf"], [1, "icon-space"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip"], [3, "name", "adaptRadarDisableEventSending", "placement", "adaptPopover", "triggers"], [1, "a-slot__list"], ["type", "button", "role", "button", "tabindex", "0", "aria-disabled", "false", "class", "btn btn-secondary btn-sm", 3, "active", "click", 4, "ngFor", "ngForOf"], ["type", "button", "role", "button", "tabindex", "0", "aria-disabled", "false", 1, "btn", "btn-secondary", "btn-sm", 3, "click"], ["button", ""]], template: function AdaptTimeSlotComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵtemplate(2, AdaptTimeSlotComponent_div_2_Template, 11, 4, "div", 1);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵtemplate(4, AdaptTimeSlotComponent_div_4_Template, 4, 1, "div", 2);
        i0.ɵɵtext(5, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.label !== "");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.slot && ctx.slot.length > 0);
    } }, directives: [i3.NgIf, i1.AdaptIconComponent, i1.AdaptTooltipDirective, i1.AdaptPopoverDirective, i3.NgForOf], encapsulation: 2, data: { animation: [
            trigger('slotsAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.opacity, {
                        params: {
                            duration: ANIMATION_DURATION.medium
                        }
                    })
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTimeSlotComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-time-slot',
                templateUrl: './time-slot.component.html',
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('slotsAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.opacity, {
                                params: {
                                    duration: ANIMATION_DURATION.medium
                                }
                            })
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i1.AdaptTranslateService }, { type: i0.NgZone }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { tooltipIcon: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], popoverIcon: [{
            type: Input
        }], popoverPlacement: [{
            type: Input
        }], popoverTriggers: [{
            type: Input
        }], popoverContent: [{
            type: Input
        }], selectedSlotChanged: [{
            type: Output,
            args: ['selected-slot-changed']
        }], button: [{
            type: ViewChildren,
            args: ['button']
        }], label: [{
            type: Input
        }], slot: [{
            type: Input
        }], selectedSlot: [{
            type: Input
        }] }); })();

class AdaptTimeSlotModule {
}
AdaptTimeSlotModule.ɵfac = function AdaptTimeSlotModule_Factory(t) { return new (t || AdaptTimeSlotModule)(); };
AdaptTimeSlotModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptTimeSlotModule });
AdaptTimeSlotModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule, AdaptButtonModule, AdaptIconModule, AdaptTooltipModule, AdaptPopoverModule.forRoot()]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTimeSlotModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, AdaptButtonModule, AdaptIconModule, AdaptTooltipModule, AdaptPopoverModule.forRoot()],
                exports: [AdaptTimeSlotComponent],
                declarations: [AdaptTimeSlotComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptTimeSlotModule, { declarations: [AdaptTimeSlotComponent], imports: [CommonModule, AdaptButtonModule, AdaptIconModule, AdaptTooltipModule, i1.AdaptPopoverModule], exports: [AdaptTimeSlotComponent] }); })();

// TODO update types
function AdaptCheckbox2Component_ng_container_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelement(2, "span", 11);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "span", 12);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r1.context.requiredLabel);
} }
function AdaptCheckbox2Component_span_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 13);
} }
function AdaptCheckbox2Component_adapt_icon_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 14);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r3.context.tooltipText);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", ctx_r3.context.tooltipIconCls);
} }
function AdaptCheckbox2Component_adapt_icon_27_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 15);
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("name", ctx_r4.context.popoverIcon)("adaptRadarDisableEventSending", true)("placement", ctx_r4.context.popoverPlacement)("adaptPopover", ctx_r4.context.popoverContent)("triggers", ctx_r4.context.popoverTriggers);
} }
function AdaptCheckbox2Component_div_32_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementStart(2, "p", 16);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r5.displayMessage);
} }
const _c0$7 = [[["", 8, "checkbox-before"]], [["", 8, "checkbox-after"]]];
const _c1$7 = function (a0) { return { "checkbox__item_no-label": a0 }; };
const _c2$6 = function (a0) { return { "sr-only": a0 }; };
const _c3$4 = [".checkbox-before", ".checkbox-after"];
const noop$2 = () => {
    return;
};
let nextUniqueId$2 = 0;
class AdaptCheckbox2Component extends FormComponent {
    constructor(injector, _element, _renderer, _changeDetectorRef, ts, _adaptRadarService, _entityName) {
        super(injector, ts, _adaptRadarService, _element, _entityName ? _entityName : AdaptRadarAngularCustomEventName.AdaptCheckbox2);
        this._element = _element;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.context = this;
        /**
         * An unique id for each checkbox/switcher
         */
        this._uniqueId = `adapt-checkbox-${++nextUniqueId$2}`;
        this._label = '';
        this.class = ''; // override the standard class attr with a new one
        /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */
        this.id = this._uniqueId;
        /** Name value will be applied to the input element if present */
        this.name = null;
        /** The tabindex attribute of the native input element */
        this.tabindex = null;
        this.stopPropagation = true;
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        // eslint-disable-next-line @typescript-eslint/typedef
        this.ariaLabel = '';
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        /**
         * Control [aria-describedby] attribute text
         */
        this.ariaDescribedBy = null;
        /** the displayMessage attribute allows to show the additional info for the user */
        this.displayMessage = 'Please fill out this field';
        /** the toggleMessage attribute will toggle the additional messages */
        this.toggleMessage = false;
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        /** Event emitted when the switcher value changes. */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
        /** Event emitted when the checkbox's `indeterminate` value changes. */
        this.indeterminateChange = new EventEmitter();
        this._onTouchedCallback = noop$2;
        this._onChangeCallback = noop$2;
        /**
         * Private variables of checkbox/switcher component
         */
        this._checked = false;
        /**
         * An indeterminate state of checkbox component - by default is false;
         */
        this._indeterminate = false;
        this._el = _element.nativeElement;
    }
    get hostClasses() {
        return [
            this.class,
            this.mainCls,
            'checkbox',
            this.readonly ? 'readonly' : '',
        ].join(' ');
    }
    /** The input/switcher element's value. */
    get checked() {
        return this._checked;
    }
    set checked(checked) {
        this._updateCheckedValue(checked, false);
    }
    get indeterminate() {
        return this._indeterminate;
    }
    set indeterminate(indeterminate) {
        const changed = indeterminate !== this._indeterminate;
        this._indeterminate = indeterminate;
        if (changed) {
            this.indeterminateChange.emit(this._indeterminate);
        }
    }
    get inputId() {
        return `${this.id || this._uniqueId}-input`;
    }
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * The label text of the checkbox component
     */
    get label() {
        return this._label;
    }
    set label(v) {
        this._label = v;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    validate() {
        return null;
    }
    /**
     *
     * @returns "true" | "false" | "mixed"
     */
    _getAriaChecked() {
        return this.checked ? 'true' : (this.indeterminate ? 'mixed' : 'false');
    }
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(checked) {
        this._updateCheckedValue(!!checked, true);
    }
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * setDisabledState(isDisabled: boolean)?: void
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    /**
     * Set focus state of the input changes
     */
    onFocus() {
        this._renderer.addClass(this._el, 'is-focused');
    }
    /**
     * Remove focus state of the input changes
     */
    onBlur() {
        this._renderer.removeClass(this._el, 'is-focused');
        this._onTouchedCallback();
    }
    /**
     * Toggle the state of input element on user action
     */
    onInputClick(e) {
        if (this.stopPropagation) {
            e.stopPropagation();
        }
        if (!(this.disabled || this.readonly)) {
            if (this.indeterminate) {
                this.indeterminate = false;
                this.indeterminateChange.emit(this.indeterminate);
            }
            this._toggle();
        }
        else {
            e.preventDefault();
        }
    }
    onInteractionEvent(e) {
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        e.stopPropagation();
    }
    /**
     * Toggle checked/unchecked states in checkbox/switcher component
     */
    _toggle() {
        this.checked = !this.checked;
    }
    _updateCheckedValue(checked, fromOuterComponent) {
        if (checked !== this.checked) {
            this._checked = toBoolean(checked);
            if (!fromOuterComponent) {
                this.change.emit(checked);
            }
            this._onChangeCallback(checked);
            SafeCdr.markForCheck(this._changeDetectorRef);
        }
    }
}
AdaptCheckbox2Component.ɵfac = function AdaptCheckbox2Component_Factory(t) { return new (t || AdaptCheckbox2Component)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i1.AdaptRadarAngularCustomEventName, 8)); };
AdaptCheckbox2Component.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptCheckbox2Component, selectors: [["adapt-checkbox2"], ["div", "adapt-checkbox2", ""], ["adapt-checkbox"]], hostVars: 2, hostBindings: function AdaptCheckbox2Component_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { class: "class", id: "id", name: "name", tabindex: "tabindex", stopPropagation: "stopPropagation", value: "value", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: "ariaDescribedBy", displayMessage: "displayMessage", toggleMessage: "toggleMessage", indeterminate: "indeterminate", label: "label" }, outputs: { focus: "focus", blur: "blur", change: "change", indeterminateChange: "indeterminateChange" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptCheckbox2Component),
            createFormControlValidator(AdaptCheckbox2Component)
        ]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c3$4, decls: 34, vars: 26, consts: [[1, "checkbox__label"], ["type", "checkbox", 1, "checkbox__input", 3, "id", "disabled", "readOnly", "checked", "required", "tabIndex", "indeterminate", "focus", "blur", "change", "click"], ["input", ""], [1, "checkbox__item", 3, "ngClass"], [1, "icon-indeterminate"], [1, "font-weight-normal", "form-control-label"], [3, "ngClass"], [4, "ngIf"], ["class", "icon-space", 4, "ngIf"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip", 4, "ngIf"], [3, "name", "adaptRadarDisableEventSending", "placement", "adaptPopover", "triggers", 4, "ngIf"], [1, "letter-space"], [1, "form-control-required"], [1, "icon-space"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip"], [3, "name", "adaptRadarDisableEventSending", "placement", "adaptPopover", "triggers"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2", "adapt-counter-error"]], template: function AdaptCheckbox2Component_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c0$7);
        i0.ɵɵprojection(0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵelementStart(2, "span", 0);
        i0.ɵɵtext(3, "\n  ");
        i0.ɵɵelementStart(4, "label");
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementStart(6, "input", 1, 2);
        i0.ɵɵlistener("focus", function AdaptCheckbox2Component_Template_input_focus_6_listener() { return ctx.onFocus(); })("blur", function AdaptCheckbox2Component_Template_input_blur_6_listener() { return ctx.onBlur(); })("change", function AdaptCheckbox2Component_Template_input_change_6_listener($event) { return ctx.onInteractionEvent($event); })("click", function AdaptCheckbox2Component_Template_input_click_6_listener($event) { return ctx.onInputClick($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n    ");
        i0.ɵɵelementStart(9, "div", 3);
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵelement(11, "span", 4);
        i0.ɵɵtext(12, "\n      ");
        i0.ɵɵelementStart(13, "span", 5);
        i0.ɵɵtext(14, "\n        ");
        i0.ɵɵelementStart(15, "span", 6);
        i0.ɵɵtext(16);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n        ");
        i0.ɵɵtemplate(18, AdaptCheckbox2Component_ng_container_18_Template, 7, 1, "ng-container", 7);
        i0.ɵɵtext(19, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(21, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n\n  ");
        i0.ɵɵtemplate(23, AdaptCheckbox2Component_span_23_Template, 1, 0, "span", 8);
        i0.ɵɵtext(24, "\n\n  ");
        i0.ɵɵtemplate(25, AdaptCheckbox2Component_adapt_icon_25_Template, 1, 3, "adapt-icon", 9);
        i0.ɵɵtext(26, "\n\n\n  ");
        i0.ɵɵtemplate(27, AdaptCheckbox2Component_adapt_icon_27_Template, 1, 5, "adapt-icon", 10);
        i0.ɵɵtext(28, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(29, "\n\n");
        i0.ɵɵprojection(30, 1);
        i0.ɵɵtext(31, "\n\n");
        i0.ɵɵtemplate(32, AdaptCheckbox2Component_div_32_Template, 5, 2, "div", 7);
        i0.ɵɵtext(33, "\n\n\n");
    } if (rf & 2) {
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("id", ctx.inputId)("disabled", ctx.context.disabled)("readOnly", ctx.context.readonly)("checked", ctx.checked)("required", ctx.context.required)("tabIndex", ctx.tabindex)("indeterminate", ctx.indeterminate);
        i0.ɵɵattribute("value", ctx.value)("name", ctx.context.name)("aria-readonly", ctx.readonly)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy)("aria-checked", ctx._getAriaChecked());
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(22, _c1$7, !ctx.context.label));
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(24, _c2$6, !ctx.context.label));
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.context.label);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.required);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.context.tooltipIconCls || ctx.context.popoverIcon);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.tooltipIconCls && !ctx.context.popoverIcon);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.popoverIcon);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.toggleMessage);
    } }, directives: [i3.NgClass, i3.NgIf, i1.AdaptIconComponent, i1.AdaptTooltipDirective, i1.AdaptPopoverDirective], styles: [".checkbox__item .adapt-icon { bottom: 0; }"], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptCheckbox2Component, [{
        type: Component,
        args: [{
                selector: 'adapt-checkbox2, div[adapt-checkbox2], adapt-checkbox',
                templateUrl: './checkbox2.component.html',
                providers: [
                    createFormControlValueAccessor(AdaptCheckbox2Component),
                    createFormControlValidator(AdaptCheckbox2Component)
                ],
                styles: ['.checkbox__item .adapt-icon { bottom: 0; }'],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i0.Injector }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i1.AdaptRadarAngularCustomEventName, decorators: [{
                type: Optional
            }] }]; }, { class: [{
            type: Input
        }], id: [{
            type: Input
        }], name: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], stopPropagation: [{
            type: Input
        }], value: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input
        }], displayMessage: [{
            type: Input
        }], toggleMessage: [{
            type: Input
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], change: [{
            type: Output
        }], indeterminateChange: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], indeterminate: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();

class AdaptCheckbox2Module {
}
AdaptCheckbox2Module.ɵfac = function AdaptCheckbox2Module_Factory(t) { return new (t || AdaptCheckbox2Module)(); };
AdaptCheckbox2Module.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptCheckbox2Module });
AdaptCheckbox2Module.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[FormsModule, CommonModule, AdaptIconModule, AdaptTooltipModule, AdaptPopoverModule.forRoot()]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptCheckbox2Module, [{
        type: NgModule,
        args: [{
                imports: [FormsModule, CommonModule, AdaptIconModule, AdaptTooltipModule, AdaptPopoverModule.forRoot()],
                exports: [AdaptCheckbox2Component],
                declarations: [AdaptCheckbox2Component]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptCheckbox2Module, { declarations: [AdaptCheckbox2Component], imports: [FormsModule, CommonModule, AdaptIconModule, AdaptTooltipModule, i1.AdaptPopoverModule], exports: [AdaptCheckbox2Component] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
function AdaptSwitcherComponent_span_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.context.label);
} }
function AdaptSwitcherComponent_span_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 11);
} }
function AdaptSwitcherComponent_span_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 12);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r3.context.requiredLabel);
} }
function AdaptSwitcherComponent_span_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 13);
} }
function AdaptSwitcherComponent_adapt_icon_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 14);
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r5.context.tooltipText);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("ngClass", ctx_r5.labelPosition === "after" ? "m-start-1" : "m-end-1")("name", ctx_r5.context.tooltipIconCls);
} }
function AdaptSwitcherComponent_adapt_icon_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 15);
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("name", ctx_r6.context.popoverIcon)("adaptRadarDisableEventSending", true)("ngClass", ctx_r6.labelPosition === "after" ? "m-start-1" : "m-end-1")("placement", ctx_r6.context.popoverPlacement)("adaptPopover", ctx_r6.context.popoverContent)("triggers", ctx_r6.context.popoverTriggers);
} }
const _c0$6 = [[["", 8, "switcher-before"]], [["", 8, "switcher-after"]]];
const _c1$6 = [".switcher-before", ".switcher-after"];
let nextUniqueId$1 = 0;
class AdaptSwitcherComponent extends AdaptCheckbox2Component {
    constructor(injector, element, renderer, changeDetectorRef, ts, _adaptRadarService) {
        super(injector, element, renderer, changeDetectorRef, ts, _adaptRadarService, AdaptRadarAngularCustomEventName.AdaptSwitcher);
        this.context = this;
        this._label = '';
        this._uniqueId = `adapt-checkbox-${++nextUniqueId$1}`;
        this.labelPosition = 'after';
        /**
         * sizes - lg and sm
         */
        this.size = '';
        /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */
        this.id = this._uniqueId;
        /** Name value will be applied to the input element if present */
        this.name = null;
        /** The tabindex attribute of the native input element */
        this.tabindex = null;
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        this.ariaLabel = '';
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        this.ariaDescribedBy = null;
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        /** Event emitted when the switcher value changes. */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
    }
    get hostClasses() {
        return [
            'switcher',
            this.labelPosition === 'before' ? 'switcher__before' : ''
        ].join(' ');
    }
    get inputId() {
        return `${this.id || this._uniqueId}-input`;
    }
    /**
     * The label text of the checkbox component
     */
    get label() {
        return this._label;
    }
    set label(v) {
        this._label = v;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    onInputClick(e) {
        super.onInputClick(e);
    }
}
AdaptSwitcherComponent.ɵfac = function AdaptSwitcherComponent_Factory(t) { return new (t || AdaptSwitcherComponent)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService)); };
AdaptSwitcherComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSwitcherComponent, selectors: [["adapt-switcher"], ["div", "adapt-switcher", ""]], hostVars: 6, hostBindings: function AdaptSwitcherComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
        i0.ɵɵclassProp("is-checked", ctx.context.checked)("is-disabled", ctx.context.disabled);
    } }, inputs: { labelPosition: "labelPosition", size: "size", hostClasses: "hostClasses", id: "id", name: "name", tabindex: "tabindex", label: "label", value: "value", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: "ariaDescribedBy" }, outputs: { focus: "focus", blur: "blur", change: "change" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptSwitcherComponent),
            createFormControlValidator(AdaptSwitcherComponent),
        ]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1$6, decls: 30, vars: 22, consts: [[3, "ngClass"], ["type", "checkbox", 3, "id", "disabled", "checked", "required", "tabIndex", "focus", "blur", "change", "click"], ["input", ""], [1, "switch__slider"], [1, "switch__item", "form-control-label", "font-weight-normal", 3, "ngClass"], [4, "ngIf"], ["class", "letter-space", 4, "ngIf"], ["class", "form-control-required", 4, "ngIf"], ["class", "icon-space", 4, "ngIf"], ["placement", "top", 3, "adaptRadarDisableEventSending", "ngClass", "name", "adaptTooltip", 4, "ngIf"], [3, "name", "adaptRadarDisableEventSending", "ngClass", "placement", "adaptPopover", "triggers", 4, "ngIf"], [1, "letter-space"], [1, "form-control-required"], [1, "icon-space"], ["placement", "top", 3, "adaptRadarDisableEventSending", "ngClass", "name", "adaptTooltip"], [3, "name", "adaptRadarDisableEventSending", "ngClass", "placement", "adaptPopover", "triggers"]], template: function AdaptSwitcherComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c0$6);
        i0.ɵɵprojection(0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵelementStart(2, "div", 0);
        i0.ɵɵtext(3, "\n  ");
        i0.ɵɵelementStart(4, "label");
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementStart(6, "input", 1, 2);
        i0.ɵɵlistener("focus", function AdaptSwitcherComponent_Template_input_focus_6_listener() { return ctx.context.onFocus(); })("blur", function AdaptSwitcherComponent_Template_input_blur_6_listener() { return ctx.context.onBlur(); })("change", function AdaptSwitcherComponent_Template_input_change_6_listener($event) { return ctx.context.onInteractionEvent($event); })("click", function AdaptSwitcherComponent_Template_input_click_6_listener($event) { return ctx.context.onInputClick($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n    ");
        i0.ɵɵelement(9, "span", 3);
        i0.ɵɵtext(10, "\n\n    ");
        i0.ɵɵelementStart(11, "span", 4);
        i0.ɵɵtext(12, "\n      ");
        i0.ɵɵtemplate(13, AdaptSwitcherComponent_span_13_Template, 2, 1, "span", 5);
        i0.ɵɵtext(14, "\n      ");
        i0.ɵɵtemplate(15, AdaptSwitcherComponent_span_15_Template, 1, 0, "span", 6);
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵtemplate(17, AdaptSwitcherComponent_span_17_Template, 2, 1, "span", 7);
        i0.ɵɵtext(18, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(19, "\n\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n  ");
        i0.ɵɵtemplate(21, AdaptSwitcherComponent_span_21_Template, 1, 0, "span", 8);
        i0.ɵɵtext(22, "\n  ");
        i0.ɵɵtemplate(23, AdaptSwitcherComponent_adapt_icon_23_Template, 1, 4, "adapt-icon", 9);
        i0.ɵɵtext(24, "\n\n  ");
        i0.ɵɵtemplate(25, AdaptSwitcherComponent_adapt_icon_25_Template, 1, 6, "adapt-icon", 10);
        i0.ɵɵtext(26, "\n\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(27, "\n\n");
        i0.ɵɵprojection(28, 1);
        i0.ɵɵtext(29, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("readonly", ctx.context.readonly);
        i0.ɵɵproperty("ngClass", ctx.size ? "switch switch-" + ctx.size : "switch");
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("id", ctx.context.inputId)("disabled", ctx.context.disabled)("checked", ctx.context.checked)("required", ctx.context.required)("tabIndex", ctx.context.tabindex);
        i0.ɵɵattribute("value", ctx.context.value)("name", ctx.context.name)("aria-label", ctx.context.ariaLabel || null)("aria-labelledby", ctx.context.ariaLabelledby)("aria-describedby", ctx.context.ariaDescribedBy || null)("aria-checked", ctx.context._getAriaChecked())("aria-required", ctx.context.required);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngClass", ctx.labelPosition === "after" ? "m-start-1-5" : "m-end-1-5");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.label);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.required);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.required);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.context.tooltipIconCls || ctx.context.popoverIcon);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.tooltipIconCls && !ctx.context.popoverIcon);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.popoverIcon);
    } }, directives: [i3.NgClass, i3.NgIf, i1.AdaptIconComponent, i1.AdaptTooltipDirective, i1.AdaptPopoverDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSwitcherComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-switcher, div[adapt-switcher]',
                providers: [
                    createFormControlValueAccessor(AdaptSwitcherComponent),
                    createFormControlValidator(AdaptSwitcherComponent),
                ],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.is-checked]': 'context.checked',
                    '[class.is-disabled]': 'context.disabled'
                },
                templateUrl: './switcher.component.html',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i0.Injector }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }]; }, { labelPosition: [{
            type: Input
        }], size: [{
            type: Input
        }], hostClasses: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class']
        }], id: [{
            type: Input
        }], name: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], label: [{
            type: Input
        }], value: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], change: [{
            type: Output
        }] }); })();

class AdaptSwitcherModule {
}
AdaptSwitcherModule.ɵfac = function AdaptSwitcherModule_Factory(t) { return new (t || AdaptSwitcherModule)(); };
AdaptSwitcherModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptSwitcherModule });
AdaptSwitcherModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            FormsModule,
            CommonModule,
            AdaptIconModule,
            AdaptTooltipModule,
            AdaptCheckbox2Module,
            AdaptPopoverModule.forRoot()
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSwitcherModule, [{
        type: NgModule,
        args: [{
                imports: [
                    FormsModule,
                    CommonModule,
                    AdaptIconModule,
                    AdaptTooltipModule,
                    AdaptCheckbox2Module,
                    AdaptPopoverModule.forRoot()
                ],
                exports: [AdaptSwitcherComponent],
                declarations: [AdaptSwitcherComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptSwitcherModule, { declarations: [AdaptSwitcherComponent], imports: [FormsModule,
        CommonModule,
        AdaptIconModule,
        AdaptTooltipModule,
        AdaptCheckbox2Module, i1.AdaptPopoverModule], exports: [AdaptSwitcherComponent] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$5 = ["inlineList"];
function AdaptSelectInlineComponent_adapt_rx_control_label_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-rx-control-label", 8);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("label", ctx_r0.label)("requiredLabel", ctx_r0.texts.requiredText)("showRequiredLabel", ctx_r0.required)("subLabel", ctx_r0.subLabel)("tooltip", ctx_r0.tooltipConfig);
} }
function AdaptSelectInlineComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementStart(2, "p", 9);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r1.displayMessage);
} }
function AdaptSelectInlineComponent_div_4_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 13);
    i0.ɵɵlistener("click", function AdaptSelectInlineComponent_div_4_button_4_Template_button_click_0_listener($event) { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(2); return ctx_r8.clearSearchFilter($event); });
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("@searchAnim", undefined);
} }
function AdaptSelectInlineComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 10);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelement(2, "input", 11);
    i0.ɵɵtext(3, "\n\n  ");
    i0.ɵɵtemplate(4, AdaptSelectInlineComponent_div_4_button_4_Template, 2, 1, "button", 12);
    i0.ɵɵtext(5, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵpropertyInterpolate("placeholder", ctx_r2.texts.searchPlaceholder);
    i0.ɵɵproperty("formControl", ctx_r2.searchFilterText);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r2.searchFilterText.value.length > 0);
} }
function AdaptSelectInlineComponent_div_9_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r10.getHeaderText(), "\n    ");
} }
function AdaptSelectInlineComponent_div_9_div_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "span", 18);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelement(5, "adapt-custom-actions", 19);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("@openClose", ctx_r12.rtl ? ctx_r12.searchFilterText.value ? "showRTL" : "hideRTL" : ctx_r12.searchFilterText.value ? "show" : "hide");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate2("\n            ", ctx_r12.texts.filteredTo, " ", ctx_r12.getFilteredItems().length, "\n        ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("actions", ctx_r12.customActions);
} }
function AdaptSelectInlineComponent_div_9_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 17);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptSelectInlineComponent_div_9_div_4_ng_container_2_Template, 7, 4, "ng-container", 1);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r11.displayedOptions && ctx_r11.displayedOptions.length !== 0 && (ctx_r11.settings.showCheckAll || ctx_r11.settings.showUncheckAll));
} }
function AdaptSelectInlineComponent_div_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptSelectInlineComponent_div_9_div_2_Template, 2, 1, "div", 14);
    i0.ɵɵtext(3, "\n\n    ");
    i0.ɵɵtemplate(4, AdaptSelectInlineComponent_div_9_div_4_Template, 4, 1, "div", 15);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.showHeader());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !(ctx_r4.disabled || ctx_r4.readonly || ctx_r4.allOptionsDisabled()));
} }
function AdaptSelectInlineComponent_li_13_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li", 20);
    i0.ɵɵlistener("keydown.space", function AdaptSelectInlineComponent_li_13_Template_li_keydown_space_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r17); const option_r13 = restoredCtx.$implicit; const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.setSelected($event, option_r13); })("keyup.enter", function AdaptSelectInlineComponent_li_13_Template_li_keyup_enter_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r17); const option_r13 = restoredCtx.$implicit; const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.setSelected($event, option_r13); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "div", 21);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "label", 22);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementStart(6, "input", 23);
    i0.ɵɵlistener("click", function AdaptSelectInlineComponent_li_13_Template_input_click_6_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r17); const option_r13 = restoredCtx.$implicit; const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.setSelected($event, option_r13); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementStart(8, "span", 24, 25);
    i0.ɵɵtext(10);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r13 = ctx.$implicit;
    const i_r14 = ctx.index;
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("adaptFocusMonitor", option_r13.id);
    i0.ɵɵadvance(6);
    i0.ɵɵproperty("disabled", ctx_r5.isDisabled(option_r13))("checked", ctx_r5.isSelected(option_r13));
    i0.ɵɵattribute("data-testid", ctx_r5.testID + "_select_item_" + i_r14);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(option_r13.name);
} }
function AdaptSelectInlineComponent_div_16_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 26);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelement(2, "adapt-empty-state", 27);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("label", ctx_r6.texts.notFound);
} }
const _c1$5 = function (a0) { return { "a-select-inline__list_search-enabled": a0 }; };
const _c2$5 = function (a0) { return { "height": a0 }; };
/**
 * VALUE_ACCESSOR for the select inline
 */
const SELECT_INLINE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptSelectInlineComponent),
    multi: true
};
/** In a list menu 6 rows by default only visible - also it might be redefine on he devs end */
const MENU_MAX_HEIGHT = 234;
class AdaptSelectInlineComponent extends AdaptSelectComponent {
    constructor(filterSearch, _renderer, detection, element, _focusHandle, _scrollService, _changeDetectorRef, _ngZone, _layerService, _router, _differs, _eventManager, dir, _resizeService, _injector, ts, _adaptRadarService) {
        super(filterSearch, _renderer, detection, element, _focusHandle, _scrollService, _changeDetectorRef, _ngZone, _layerService, _router, _differs, _eventManager, dir, _resizeService, _injector, ts, _adaptRadarService, AdaptRadarAngularCustomEventName.AdaptSelectInline);
        this.filterSearch = filterSearch;
        this._renderer = _renderer;
        this.detection = detection;
        this.element = element;
        this._focusHandle = _focusHandle;
        this._scrollService = _scrollService;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this._router = _router;
        /**
         * Need to redefine the default setting due to new requirements
         */
        this.defaultSettings = {
            pullRight: false,
            enableSearch: true,
            checkedStyle: 'checkbox',
            buttonClasses: '',
            selectionLimit: 0,
            closeOnSelect: false,
            autoUnselect: false,
            showCheckAll: true,
            showUncheckAll: true,
            showTooltip: false,
            dynamicTitleMaxItems: 1,
            maxHeight: ' ',
            showCheckedAll: false,
            hideLabel: false,
            cancelBtn: true,
            doneBtn: true,
            titleMobile: true,
            modelFormat: SelectModelFormat.number
        };
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /* new error behave for the selection - by default false */
        this.isErrorExist = false;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.menuHeight = MENU_MAX_HEIGHT;
        this.simpleView = false;
        this.single = false;
    }
    get customActions() {
        return [
            {
                name: this.searchFilterText.value ? this.texts.checkAllFilter : this.texts.checkAll,
                visible: !this.isHiddenSelectFilteredButton(),
                onClick: this.checkAll.bind(this)
            },
            {
                name: this.searchFilterText.value ? this.texts.uncheckAllFilter : this.texts.uncheckAll,
                visible: !this.isHiddenUncheckFilteredButton(),
                onClick: this.uncheckAll.bind(this)
            }
        ];
    }
    ngOnInit() {
        super.ngOnInit();
        this.settings = Object.assign(Object.assign({}, this.defaultSettings), this.settings);
        this.texts = Object.assign(Object.assign({}, this.defaultTexts), this.texts);
        if (this.tooltipInputIcon && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipInputIcon,
                content: this.tooltipInputText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    trackByForOptions(index, option) {
        return option.id || index;
    }
}
AdaptSelectInlineComponent.ɵfac = function AdaptSelectInlineComponent_Factory(t) { return new (t || AdaptSelectInlineComponent)(i0.ɵɵdirectiveInject(AdaptSelectSearchFilter), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.AdaptFocusMonitorService), i0.ɵɵdirectiveInject(i1.ScrollManageService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.LayerService), i0.ɵɵdirectiveInject(i3$1.Router, 8), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i4.EventManager), i0.ɵɵdirectiveInject(i2$1.Directionality), i0.ɵɵdirectiveInject(i1.ResizeService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService)); };
AdaptSelectInlineComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSelectInlineComponent, selectors: [["adapt-select-inline"], ["div", "select-inline", ""]], viewQuery: function AdaptSelectInlineComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$5, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inlineList = _t.first);
    } }, hostVars: 6, hostBindings: function AdaptSelectInlineComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("a-select-inline", true)("is-error", ctx.isErrorExist)("a-select-inline_simple-view", ctx.simpleView);
    } }, inputs: { isErrorExist: "isErrorExist", subLabel: ["sub-label", "subLabel"], menuHeight: ["menu-height", "menuHeight"], simpleView: "simpleView" }, features: [i0.ɵɵProvidersFeature([
            SELECT_INLINE_VALUE_ACCESSOR,
            AdaptSelectSearchFilter,
            AdaptFocusMonitorService
        ]), i0.ɵɵInheritDefinitionFeature], decls: 19, vars: 13, consts: [[3, "label", "requiredLabel", "showRequiredLabel", "subLabel", "tooltip", 4, "ngIf"], [4, "ngIf"], ["class", "a-select-inline__form form-group d-icon-search ", "tabindex", "-1", 4, "ngIf"], [1, "a-select-inline__list", 3, "ngClass", "ngStyle"], ["inlineList", ""], [1, "list-unstyled", "a-select-inline__list-items"], ["class", "a-select-inline__item focusable", "role", "option", "tabindex", "0", 3, "adaptFocusMonitor", "keydown.space", "keyup.enter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "presentation", "class", "a-select-inline__header is-helper-text", 4, "ngIf"], [3, "label", "requiredLabel", "showRequiredLabel", "subLabel", "tooltip"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"], ["tabindex", "-1", 1, "a-select-inline__form", "form-group", "d-icon-search"], ["type", "text", "adaptFocusMonitor", "", 1, "a-select-inline__input", "form-control", 3, "formControl", "placeholder"], ["type", "button", "class", "a-select-inline__close d-icon-cross_adapt", "adaptFocusMonitor", "", 3, "click", 4, "ngIf"], ["type", "button", "adaptFocusMonitor", "", 1, "a-select-inline__close", "d-icon-cross_adapt", 3, "click"], ["class", "dropdown-header", 4, "ngIf"], ["class", "select-inline__select-buttons", 4, "ngIf"], [1, "dropdown-header"], [1, "select-inline__select-buttons"], [1, "select-inline__counter"], [3, "actions"], ["role", "option", "tabindex", "0", 1, "a-select-inline__item", "focusable", 3, "adaptFocusMonitor", "keydown.space", "keyup.enter"], [1, "checkbox"], [1, "checkbox__label"], ["type", "checkbox", "tabindex", "-1", 1, "checkbox__input", 3, "disabled", "checked", "click"], [1, "checkbox__item"], ["dropdownItem", ""], ["role", "presentation", 1, "a-select-inline__header", "is-helper-text"], ["type", "search", 3, "adaptRadarDisableEventSending", "label"]], template: function AdaptSelectInlineComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptSelectInlineComponent_adapt_rx_control_label_0_Template, 1, 5, "adapt-rx-control-label", 0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptSelectInlineComponent_div_2_Template, 5, 2, "div", 1);
        i0.ɵɵtext(3, "\n\n");
        i0.ɵɵtemplate(4, AdaptSelectInlineComponent_div_4_Template, 6, 3, "div", 2);
        i0.ɵɵtext(5, "\n\n");
        i0.ɵɵelementStart(6, "div", 3, 4);
        i0.ɵɵtext(8, "\n  ");
        i0.ɵɵtemplate(9, AdaptSelectInlineComponent_div_9_Template, 6, 2, "div", 1);
        i0.ɵɵtext(10, "\n\n  ");
        i0.ɵɵelementStart(11, "ul", 5);
        i0.ɵɵtext(12, "\n    ");
        i0.ɵɵtemplate(13, AdaptSelectInlineComponent_li_13_Template, 14, 5, "li", 6);
        i0.ɵɵtext(14, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(15, "\n\n  ");
        i0.ɵɵtemplate(16, AdaptSelectInlineComponent_div_16_Template, 4, 2, "div", 7);
        i0.ɵɵtext(17, "\n\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", !ctx.settings.hideLabel);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.isErrorExist && ctx.displayMessage && ctx.displayMessage.length > 0);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.settings.enableSearch && !ctx.simpleView);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(9, _c1$5, ctx.settings.enableSearch))("ngStyle", i0.ɵɵpureFunction1(11, _c2$5, ctx.menuHeight + "px"));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.simpleView);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngForOf", ctx.displayedOptions)("ngForTrackBy", ctx.trackByForOptions);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.displayedOptions && ctx.displayedOptions.length === 0);
    } }, directives: [i3.NgIf, i3.NgClass, i3.NgStyle, i3.NgForOf, i1.AdaptRxControlLabelComponent, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i1.AdaptFocusMonitorDirective, i6.NgControlStatus, i6.FormControlDirective, i1.AdaptCustomActionsComponent, i1.AdaptEmptyStateComponent], styles: ["\n    .a-select-inline__list .dropdown-header {\n      padding: .875rem .875rem .1875rem;\n    }\n\n    .select-inline__select-buttons {\n      padding: 0 14px;\n    }\n\n    .select-inline__counter {\n      display: inline-flex;\n      overflow: hidden;\n      color: #959799;\n      white-space: nowrap;\n      opacity: 0;\n      align-self: center;\n    }\n  "], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ]),
            trigger('validationFeedbackChangeAnimation', [
                transition('* => *', [
                    useAnimation(ANIMATION_NAME.opacity)
                ])
            ]),
            trigger('searchAnim', [
                transition('void => *', [
                    style({ visibility: 'hidden', opacity: 0 }),
                    animate(`.25s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: .6 }))
                ]),
                transition('* => void', [
                    style({ visibility: 'visible', opacity: .6 }),
                    animate(`.25s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0 }))
                ])
            ]),
            trigger('shadowAnimation', [
                transition('void => *', [
                    style({ visibility: 'hidden', opacity: 0, height: 0 }),
                    animate(`.25s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: 1, height: '*' }))
                ]),
                transition('* => void', [
                    style({ visibility: 'visible', opacity: 1, height: '*' }),
                    animate(`.25s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0, height: 0 }))
                ])
            ]),
            trigger('openClose', [
                state('show', style({
                    width: '*',
                    marginLeft: '0',
                    marginRight: '.875rem',
                    opacity: 1
                })),
                state('hide', style({
                    marginRight: '0',
                    width: '0px',
                    opacity: 0
                })),
                transition('show => hide', [
                    animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                ]),
                transition('hide => show', [
                    animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                ]),
                state('showRTL', style({
                    width: '*',
                    opacity: 1,
                    marginLeft: '.875rem',
                })),
                state('hideRTL', style({
                    marginLeft: '0',
                    width: '0px',
                    opacity: 0
                })),
                transition('showRTL => hideRTL', [
                    animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                ]),
                transition('hideRTL => showRTL', [
                    animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                ]),
            ]),
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSelectInlineComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-select-inline, div[select-inline]',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.a-select-inline]': 'true',
                    '[class.is-error]': 'isErrorExist'
                },
                templateUrl: './select-inline.component.html',
                encapsulation: ViewEncapsulation.None,
                providers: [
                    SELECT_INLINE_VALUE_ACCESSOR,
                    AdaptSelectSearchFilter,
                    AdaptFocusMonitorService
                ],
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ]),
                    trigger('validationFeedbackChangeAnimation', [
                        transition('* => *', [
                            useAnimation(ANIMATION_NAME.opacity)
                        ])
                    ]),
                    trigger('searchAnim', [
                        transition('void => *', [
                            style({ visibility: 'hidden', opacity: 0 }),
                            animate(`.25s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: .6 }))
                        ]),
                        transition('* => void', [
                            style({ visibility: 'visible', opacity: .6 }),
                            animate(`.25s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0 }))
                        ])
                    ]),
                    trigger('shadowAnimation', [
                        transition('void => *', [
                            style({ visibility: 'hidden', opacity: 0, height: 0 }),
                            animate(`.25s ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ visibility: 'visible', opacity: 1, height: '*' }))
                        ]),
                        transition('* => void', [
                            style({ visibility: 'visible', opacity: 1, height: '*' }),
                            animate(`.25s ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, style({ visibility: 'hidden', opacity: 0, height: 0 }))
                        ])
                    ]),
                    trigger('openClose', [
                        state('show', style({
                            width: '*',
                            marginLeft: '0',
                            marginRight: '.875rem',
                            opacity: 1
                        })),
                        state('hide', style({
                            marginRight: '0',
                            width: '0px',
                            opacity: 0
                        })),
                        transition('show => hide', [
                            animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                        ]),
                        transition('hide => show', [
                            animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                        ]),
                        state('showRTL', style({
                            width: '*',
                            opacity: 1,
                            marginLeft: '.875rem',
                        })),
                        state('hideRTL', style({
                            marginLeft: '0',
                            width: '0px',
                            opacity: 0
                        })),
                        transition('showRTL => hideRTL', [
                            animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`)
                        ]),
                        transition('hideRTL => showRTL', [
                            animate(`${ANIMATION_DURATION.medium} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`)
                        ]),
                    ]),
                ],
                styles: [`
    .a-select-inline__list .dropdown-header {
      padding: .875rem .875rem .1875rem;
    }

    .select-inline__select-buttons {
      padding: 0 14px;
    }

    .select-inline__counter {
      display: inline-flex;
      overflow: hidden;
      color: #959799;
      white-space: nowrap;
      opacity: 0;
      align-self: center;
    }
  `]
            }]
    }], function () { return [{ type: AdaptSelectSearchFilter }, { type: i0.Renderer2 }, { type: i1.AdaptDeviceDetectionService }, { type: i0.ElementRef }, { type: i1.AdaptFocusMonitorService }, { type: i1.ScrollManageService }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.LayerService }, { type: i3$1.Router, decorators: [{
                type: Optional
            }] }, { type: i0.IterableDiffers }, { type: i4.EventManager }, { type: i2$1.Directionality }, { type: i1.ResizeService }, { type: i0.Injector }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }]; }, { isErrorExist: [{
            type: Input
        }], subLabel: [{
            type: Input,
            args: ['sub-label']
        }], menuHeight: [{
            type: Input,
            args: ['menu-height']
        }], simpleView: [{
            type: HostBinding,
            args: ['class.a-select-inline_simple-view']
        }, {
            type: Input
        }], inlineList: [{
            type: ViewChild,
            args: ['inlineList', { static: true }]
        }] }); })();

class AdaptSelectInlineModule {
}
AdaptSelectInlineModule.ɵfac = function AdaptSelectInlineModule_Factory(t) { return new (t || AdaptSelectInlineModule)(); };
AdaptSelectInlineModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptSelectInlineModule });
AdaptSelectInlineModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            FormsModule,
            ReactiveFormsModule,
            AdaptIconModule,
            AdaptTooltipModule,
            AdaptPopoverModule.forRoot(),
            AdaptEmptyStateModule,
            AdaptSelectSearchFilterModule,
            AdaptFocusMonitorDirectiveModule,
            AdaptDragonInputHandlerModule,
            AdaptRxLabelModule,
            AdaptCustomActionsModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSelectInlineModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AdaptIconModule,
                    AdaptTooltipModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptEmptyStateModule,
                    AdaptSelectSearchFilterModule,
                    AdaptFocusMonitorDirectiveModule,
                    AdaptDragonInputHandlerModule,
                    AdaptRxLabelModule,
                    AdaptCustomActionsModule
                ],
                declarations: [AdaptSelectInlineComponent],
                exports: [AdaptSelectInlineComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptSelectInlineModule, { declarations: [AdaptSelectInlineComponent], imports: [CommonModule,
        FormsModule,
        FormsModule,
        ReactiveFormsModule,
        AdaptIconModule,
        AdaptTooltipModule, i1.AdaptPopoverModule, AdaptEmptyStateModule,
        AdaptSelectSearchFilterModule,
        AdaptFocusMonitorDirectiveModule,
        AdaptDragonInputHandlerModule,
        AdaptRxLabelModule,
        AdaptCustomActionsModule], exports: [AdaptSelectInlineComponent] }); })();

// TODO update types
const _c0$4 = ["input"];
function AdaptRadioButtonComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelement(2, "span", 7);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "span", 8);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r1.context.requiredLabel);
} }
function AdaptRadioButtonComponent_adapt_icon_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-icon", 9);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r2.context.tooltipText);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", ctx_r2.context.tooltipIconCls);
} }
const _c1$4 = [[["", 8, "radio-before"]], [["", 8, "radio-after"]]];
const _c2$4 = function (a0) { return { "is-focused": a0 }; };
const _c3$3 = function (a0) { return { "radio__item_no-label": a0 }; };
const _c4$2 = function (a0) { return { "sr-only": a0 }; };
const _c5$2 = [".radio-before", ".radio-after"];
const noop$1 = () => {
    return;
};
let nextUniqueId = 0;
class AdaptRadioButtonComponent extends FormComponent {
    constructor(injector, _changeDetectorRef, ts, _adaptRadarService, _elem) {
        super(injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRadioButton);
        this._changeDetectorRef = _changeDetectorRef;
        // Need for using inherited properties in the template
        this.context = this;
        this.isValid = true;
        /** Name value will be applied to the input element if present */
        this.name = null;
        /** The tabindex attribute of the native input element */
        this.tabindex = null;
        this.label = '';
        this.styleClass = '';
        this.class = ''; // override the standard class attr with a new one
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        // eslint-disable-next-line @typescript-eslint/typedef
        this.ariaLabel = '';
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        /**
         * Control [aria-describedby] attribute text
         */
        this.ariaDescribedBy = null;
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onClick = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        this._uniqueId = `adapt-radiobutton-${++nextUniqueId}`;
        /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.testID = this._uniqueId;
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.id = this._uniqueId;
        this._onTouchedCallback = noop$1;
        this._onChangeCallback = noop$1;
    }
    get inputId() {
        return `${this.id || this._uniqueId}-input`;
    }
    get hostClasses() {
        return [
            this.class,
            'radio',
            this.disabled ? 'disabled' : '',
            this.readonly ? 'readonly' : '',
        ].join(' ');
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Add a focus state on key-down/tabbing
     */
    onFocus() {
        this.focused = true;
    }
    /**
     * Remove a focus state on blur event
     */
    onBlur() {
        this.focused = false;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    /**
     * The method from an Abstract class
     */
    validate() {
        return null;
    }
    onInputClick(e) {
        e.stopPropagation();
        if (!(this.disabled || this.readonly)) {
            this.onClick.emit(null);
            this.inputElement.nativeElement.checked = true;
            this.checked = true;
            this._onChangeCallback(this.value);
        }
        else {
            e.preventDefault();
        }
    }
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(v) {
        this.checked = (v === this.value);
        if (this.inputElement.nativeElement) {
            this.inputElement.nativeElement.checked = this.checked;
        }
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * setDisabledState(isDisabled: boolean)?: void
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    _onInputChange(e) {
        if (this.readonly || this.disabled) {
            e.preventDefault();
        }
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        e.stopPropagation();
    }
}
AdaptRadioButtonComponent.ɵfac = function AdaptRadioButtonComponent_Factory(t) { return new (t || AdaptRadioButtonComponent)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRadioButtonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRadioButtonComponent, selectors: [["adapt-radiobutton"], ["div", "adapt-radiobutton", ""]], viewQuery: function AdaptRadioButtonComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$4, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    } }, hostVars: 2, hostBindings: function AdaptRadioButtonComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { value: "value", name: "name", tabindex: "tabindex", label: "label", styleClass: "styleClass", class: "class", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: "ariaDescribedBy", testID: "testID", id: "id" }, outputs: { onClick: "onClick", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptRadioButtonComponent),
            createFormControlValidator(AdaptRadioButtonComponent)
        ]), i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c5$2, decls: 23, vars: 29, consts: [[1, "radio__label"], ["type", "radio", 3, "disabled", "readOnly", "required", "id", "tabIndex", "checked", "ngClass", "change", "focus", "blur", "click"], ["input", ""], [1, "radio__item", "form-control-label", "font-weight-normal", 3, "ngClass"], [3, "ngClass"], [4, "ngIf"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip", 4, "ngIf"], [1, "letter-space"], [1, "form-control-required"], ["placement", "top", 3, "adaptRadarDisableEventSending", "name", "adaptTooltip"]], template: function AdaptRadioButtonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c1$4);
        i0.ɵɵprojection(0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵelementStart(2, "span", 0);
        i0.ɵɵtext(3, "\n  ");
        i0.ɵɵelementStart(4, "span");
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementStart(6, "input", 1, 2);
        i0.ɵɵlistener("change", function AdaptRadioButtonComponent_Template_input_change_6_listener($event) { return ctx._onInputChange($event); })("focus", function AdaptRadioButtonComponent_Template_input_focus_6_listener() { return ctx.onFocus(); })("blur", function AdaptRadioButtonComponent_Template_input_blur_6_listener() { return ctx.onBlur(); })("click", function AdaptRadioButtonComponent_Template_input_click_6_listener($event) { return ctx.onInputClick($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n    ");
        i0.ɵɵelementStart(9, "label", 3);
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵelementStart(11, "span", 4);
        i0.ɵɵtext(12);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n      ");
        i0.ɵɵtemplate(14, AdaptRadioButtonComponent_ng_container_14_Template, 7, 1, "ng-container", 5);
        i0.ɵɵtext(15, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n\n  ");
        i0.ɵɵtemplate(18, AdaptRadioButtonComponent_adapt_icon_18_Template, 2, 3, "adapt-icon", 6);
        i0.ɵɵtext(19, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n\n");
        i0.ɵɵprojection(21, 1);
        i0.ɵɵtext(22, "\n\n");
    } if (rf & 2) {
        i0.ɵɵadvance(4);
        i0.ɵɵclassMapInterpolate1("radio__label ", ctx.styleClass, "");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("disabled", ctx.context.disabled)("readOnly", ctx.readonly)("required", ctx.context.required)("id", ctx.inputId)("tabIndex", ctx.tabindex)("checked", ctx.checked)("ngClass", i0.ɵɵpureFunction1(23, _c2$4, ctx.focused));
        i0.ɵɵattribute("value", ctx.value)("data-testid", ctx.testID)("name", ctx.context.name)("aria-readonly", ctx.readonly)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(25, _c3$3, !ctx.context.label));
        i0.ɵɵattribute("for", ctx.inputId);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(27, _c4$2, !ctx.context.label));
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.context.label);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.context.required);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.context.tooltipIconCls);
    } }, directives: [i3.NgClass, i3.NgIf, i1.AdaptIconComponent, i1.AdaptTooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRadioButtonComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-radiobutton, div[adapt-radiobutton]',
                templateUrl: './radiobutton.component.html',
                providers: [
                    createFormControlValueAccessor(AdaptRadioButtonComponent),
                    createFormControlValidator(AdaptRadioButtonComponent)
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.Injector }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }, { type: i0.ElementRef }]; }, { value: [{
            type: Input
        }], name: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], label: [{
            type: Input
        }], styleClass: [{
            type: Input
        }], class: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input
        }], onClick: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], inputElement: [{
            type: ViewChild,
            args: ['input', { static: true }]
        }], testID: [{
            type: Input
        }], id: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class AdaptRadioButtonModule {
}
AdaptRadioButtonModule.ɵfac = function AdaptRadioButtonModule_Factory(t) { return new (t || AdaptRadioButtonModule)(); };
AdaptRadioButtonModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptRadioButtonModule });
AdaptRadioButtonModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule, FormsModule, AdaptIconModule, AdaptTooltipModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRadioButtonModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, FormsModule, AdaptIconModule, AdaptTooltipModule],
                exports: [AdaptRadioButtonComponent],
                declarations: [AdaptRadioButtonComponent],
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptRadioButtonModule, { declarations: [AdaptRadioButtonComponent], imports: [CommonModule, FormsModule, AdaptIconModule, AdaptTooltipModule], exports: [AdaptRadioButtonComponent] }); })();

/* eslint-disable @typescript-eslint/no-explicit-any */
const _c0$3 = ["fileInput"];
const _c1$3 = ["fileList"];
const _c2$3 = ["dropEnter"];
const _c3$2 = ["dnd"];
const _c4$1 = ["drop"];
const _c5$1 = ["droppableAreaBlock"];
function AdaptUploaderComponent_ng_template_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
} }
function AdaptUploaderComponent_adapt_alert_23_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "div", 21);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r19 = i0.ɵɵreference(4);
    const ctx_r18 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptPopover", _r19)("adaptRadarDisableEventSending", true)("placement", "auto")("maxWidth", 600);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r18.texts.remainingFilesListLabel, "\n            ");
} }
function AdaptUploaderComponent_adapt_alert_23_ng_template_2_ng_template_3_ng_template_1_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r25 = i0.ɵɵnextContext(5);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r25.texts.comma, " ");
} }
function AdaptUploaderComponent_adapt_alert_23_ng_template_2_ng_template_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n              ");
    i0.ɵɵelementStart(1, "span", 23);
    i0.ɵɵtext(2);
    i0.ɵɵtemplate(3, AdaptUploaderComponent_adapt_alert_23_ng_template_2_ng_template_3_ng_template_1_span_3_Template, 2, 1, "span", 11);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n            ");
} if (rf & 2) {
    const file_r22 = ctx.$implicit;
    const last_r24 = ctx.last;
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(file_r22.name);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !last_r24);
} }
function AdaptUploaderComponent_adapt_alert_23_ng_template_2_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n            ");
    i0.ɵɵtemplate(1, AdaptUploaderComponent_adapt_alert_23_ng_template_2_ng_template_3_ng_template_1_Template, 5, 2, "ng-template", 22);
    i0.ɵɵtext(2, "\n          ");
} if (rf & 2) {
    const msg_r15 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", msg_r15.files);
} }
function AdaptUploaderComponent_adapt_alert_23_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0);
    i0.ɵɵtemplate(1, AdaptUploaderComponent_adapt_alert_23_ng_template_2_ng_container_1_Template, 5, 5, "ng-container", 11);
    i0.ɵɵtext(2, "\n\n          ");
    i0.ɵɵtemplate(3, AdaptUploaderComponent_adapt_alert_23_ng_template_2_ng_template_3_Template, 3, 1, "ng-template", null, 20, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n        ");
} if (rf & 2) {
    const msg_r15 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵtextInterpolate1("\n          ", msg_r15.text, "\n          ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", msg_r15.files && msg_r15.files.length);
} }
const _c6$1 = function (a0, a1, a3) { return { title: a0, content: a1, type: "inline", variant: a3, icon: false }; };
function AdaptUploaderComponent_adapt_alert_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-alert", 18);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptUploaderComponent_adapt_alert_23_ng_template_2_Template, 6, 2, "ng-template", null, 19, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const msg_r15 = ctx.$implicit;
    const _r16 = i0.ɵɵreference(3);
    i0.ɵɵproperty("config", i0.ɵɵpureFunction3(1, _c6$1, msg_r15.title ? msg_r15.title : "", _r16, msg_r15.variant));
} }
const _c7$1 = function (a0, a1) { return { title: a0, content: a1, type: "inline", variant: "danger", icon: false }; };
function AdaptUploaderComponent_ng_container_25_adapt_alert_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-alert", 18);
} if (rf & 2) {
    const error_r29 = ctx.$implicit;
    i0.ɵɵproperty("config", i0.ɵɵpureFunction2(1, _c7$1, error_r29.name, error_r29.text));
} }
function AdaptUploaderComponent_ng_container_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptUploaderComponent_ng_container_25_adapt_alert_2_Template, 1, 4, "adapt-alert", 10);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r5.context.errors);
} }
function AdaptUploaderComponent_div_29_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 30);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "p", 27);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelement(5, "span", 28);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementStart(7, "p", 27);
    i0.ɵɵtext(8);
    i0.ɵɵpipe(9, "fileTypes");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r30 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r30.texts.allowedTypes);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(9, 2, ctx_r30.allowedTypes, ctx_r30.texts.fileTypesDivider));
} }
function AdaptUploaderComponent_div_29_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 24);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptUploaderComponent_div_29_div_2_Template, 11, 5, "div", 25);
    i0.ɵɵtext(3, "\n\n      ");
    i0.ɵɵelementStart(4, "div", 26);
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵelementStart(6, "p", 27);
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n        ");
    i0.ɵɵelement(9, "span", 28);
    i0.ɵɵtext(10, "\n        ");
    i0.ɵɵelementStart(11, "p", 27);
    i0.ɵɵtext(12);
    i0.ɵɵpipe(13, "fileSize");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n\n      ");
    i0.ɵɵelementStart(16, "div", 29);
    i0.ɵɵtext(17, "\n        ");
    i0.ɵɵelementStart(18, "p", 27);
    i0.ɵɵtext(19);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n        ");
    i0.ɵɵelement(21, "span", 28);
    i0.ɵɵtext(22, "\n        ");
    i0.ɵɵelementStart(23, "p", 27);
    i0.ɵɵtext(24);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(26, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.allowedTypes.length);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r6.texts.maxFileSize);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(13, 5, ctx_r6.maxFileSize));
    i0.ɵɵadvance(7);
    i0.ɵɵtextInterpolate(ctx_r6.texts.filesCount);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r6.filesCount);
} }
function AdaptUploaderComponent_div_32_p_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 42);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r31 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r31.filesAddedCount);
} }
function AdaptUploaderComponent_div_32_p_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 42);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r32 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("text-info", ctx_r32.maxFileCountUploaded);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r32.filesUploadedCount);
} }
function AdaptUploaderComponent_div_32_button_10_Template(rf, ctx) { if (rf & 1) {
    const _r39 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 43);
    i0.ɵɵlistener("click", function AdaptUploaderComponent_div_32_button_10_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r39); const ctx_r38 = i0.ɵɵnextContext(2); return ctx_r38.cancelAllUploads(); });
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelement(2, "span", 44);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "span");
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r33 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r33.texts.btnCancelAllUploads);
} }
function AdaptUploaderComponent_div_32_adapt_uploader_item_13_Template(rf, ctx) { if (rf & 1) {
    const _r43 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-uploader-item", 45);
    i0.ɵɵlistener("afterFileRemove", function AdaptUploaderComponent_div_32_adapt_uploader_item_13_Template_adapt_uploader_item_afterFileRemove_0_listener($event) { i0.ɵɵrestoreView(_r43); const ctx_r42 = i0.ɵɵnextContext(2); return ctx_r42.removedFromQueue($event); })("fileDeleted", function AdaptUploaderComponent_div_32_adapt_uploader_item_13_Template_adapt_uploader_item_fileDeleted_0_listener($event) { i0.ɵɵrestoreView(_r43); const ctx_r44 = i0.ɵɵnextContext(2); return ctx_r44.fileDeleted($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r40 = ctx.$implicit;
    const id_r41 = ctx.index;
    const ctx_r34 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", ctx_r34.disabled)("readonly", ctx_r34.readonly)("collapseBlock", false)("reusable", ctx_r34.reusable)("indeterminateFileLoader", ctx_r34.indeterminateFileLoader)("url", ctx_r34.url)("deleteUrl", ctx_r34.deleteUrl)("chunkSize", ctx_r34.chunkSize)("customErrors", ctx_r34.customErrors)("file", file_r40)("id", id_r41)("texts", ctx_r34.texts);
} }
function AdaptUploaderComponent_div_32_adapt_uploader_item_19_Template(rf, ctx) { if (rf & 1) {
    const _r48 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-uploader-item", 46);
    i0.ɵɵlistener("afterFileRemove", function AdaptUploaderComponent_div_32_adapt_uploader_item_19_Template_adapt_uploader_item_afterFileRemove_0_listener($event) { i0.ɵɵrestoreView(_r48); const ctx_r47 = i0.ɵɵnextContext(2); return ctx_r47.removedFromQueue($event); })("fileDeleted", function AdaptUploaderComponent_div_32_adapt_uploader_item_19_Template_adapt_uploader_item_fileDeleted_0_listener($event) { i0.ɵɵrestoreView(_r48); const ctx_r49 = i0.ɵɵnextContext(2); return ctx_r49.fileDeleted($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r45 = ctx.$implicit;
    const id_r46 = ctx.index;
    const ctx_r36 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", ctx_r36.disabled)("readonly", ctx_r36.readonly)("reusable", ctx_r36.reusable)("indeterminateFileLoader", ctx_r36.indeterminateFileLoader)("url", ctx_r36.url)("deleteUrl", ctx_r36.deleteUrl)("chunkSize", ctx_r36.chunkSize)("customErrors", ctx_r36.customErrors)("file", file_r45)("id", id_r46 + ctx_r36.visibleFiles)("texts", ctx_r36.texts);
} }
function AdaptUploaderComponent_div_32_div_23_Template(rf, ctx) { if (rf & 1) {
    const _r51 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 47);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "button", 48);
    i0.ɵɵlistener("click", function AdaptUploaderComponent_div_32_div_23_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r51); i0.ɵɵnextContext(); const _r35 = i0.ɵɵreference(17); return _r35.toggle(); });
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "span");
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r35 = i0.ɵɵreference(17);
    const ctx_r37 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("aria-expanded", !_r35.isCollapsed);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(_r35.isCollapsed ? ctx_r37.texts.showMore : ctx_r37.texts.showLess);
} }
function AdaptUploaderComponent_div_32_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 31);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "div", 32);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "div", 33);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵtemplate(6, AdaptUploaderComponent_div_32_p_6_Template, 2, 1, "p", 34);
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵtemplate(8, AdaptUploaderComponent_div_32_p_8_Template, 2, 3, "p", 35);
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵtemplate(10, AdaptUploaderComponent_div_32_button_10_Template, 7, 2, "button", 36);
    i0.ɵɵtext(11, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n        ");
    i0.ɵɵtemplate(13, AdaptUploaderComponent_div_32_adapt_uploader_item_13_Template, 1, 12, "adapt-uploader-item", 37);
    i0.ɵɵpipe(14, "slice");
    i0.ɵɵtext(15, "\n\n        ");
    i0.ɵɵelementStart(16, "div", 38, 39);
    i0.ɵɵtext(18, "\n          ");
    i0.ɵɵtemplate(19, AdaptUploaderComponent_div_32_adapt_uploader_item_19_Template, 1, 11, "adapt-uploader-item", 40);
    i0.ɵɵpipe(20, "slice");
    i0.ɵɵtext(21, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n\n        ");
    i0.ɵɵtemplate(23, AdaptUploaderComponent_div_32_div_23_Template, 8, 2, "div", 41);
    i0.ɵɵtext(24, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵadvance(6);
    i0.ɵɵproperty("ngIf", ctx_r7.isManualMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r7.isManualMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r7.isUploadingProcess);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind3(14, 6, ctx_r7.files, 0, ctx_r7.visibleFiles));
    i0.ɵɵadvance(6);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind2(20, 10, ctx_r7.files, ctx_r7.visibleFiles));
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r7.files.length > ctx_r7.visibleFiles);
} }
const _c8$1 = function (a1) { return { title: "Folders uploading", content: a1, type: "inline", variant: "warning" }; };
function AdaptUploaderComponent_adapt_alert_35_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-alert", 49);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵproperty("config", i0.ɵɵpureFunction1(1, _c8$1, ctx_r8.folderUploadingForbiddenMsg));
} }
function AdaptUploaderComponent_ng_template_39_Template(rf, ctx) { }
function AdaptUploaderComponent_ng_template_42_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "adapt-empty-state", 50);
    i0.ɵɵtext(2, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n");
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("type", "objects")("label", ctx_r12.texts.notFound);
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_div_7_Template(rf, ctx) { if (rf & 1) {
    const _r63 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 61);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "button", 62);
    i0.ɵɵlistener("click", function AdaptUploaderComponent_ng_template_45_ng_container_1_div_7_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r63); const ctx_r62 = i0.ɵɵnextContext(3); return ctx_r62.openFileDialog(false); });
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelement(4, "span", 63);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r55 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r55.selectFilesButtonTooltip)("placement", "auto");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("disabled", ctx_r55.isDisabledSelectBtn);
    i0.ɵɵattribute("aria-label", ctx_r55.texts.fileBtn)("aria-describedby", ctx_r55.context.ariaDescribedBy || null);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r55.texts.fileBtn, "\n          ");
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_div_9_Template(rf, ctx) { if (rf & 1) {
    const _r65 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 64);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "button", 62);
    i0.ɵɵlistener("click", function AdaptUploaderComponent_ng_template_45_ng_container_1_div_9_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r65); const ctx_r64 = i0.ɵɵnextContext(3); return ctx_r64.openFileDialog(true); });
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelement(4, "span", 65);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r56 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r56.selectFilesButtonTooltip)("placement", "auto");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("disabled", ctx_r56.isDisabledSelectBtn);
    i0.ɵɵattribute("aria-label", ctx_r56.texts.folderBtn)("aria-describedby", ctx_r56.context.ariaDescribedBy || null);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r56.texts.folderBtn, "\n          ");
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_11_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 68);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r66 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r66.texts.fileMode, "\n              ");
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_11_span_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 68);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r67 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r67.texts.dirMode, "\n              ");
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_11_span_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 68);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r68 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r68.texts.mixMode, "\n              ");
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0, 66);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵtemplate(2, AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_11_span_2_Template, 2, 1, "span", 67);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵtemplate(4, AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_11_span_4_Template, 2, 1, "span", 67);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵtemplate(6, AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_11_span_6_Template, 2, 1, "span", 67);
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r57 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("ngSwitch", ctx_r57.selectionMode);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", ctx_r57.fileMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", ctx_r57.dirMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", ctx_r57.mixMode());
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "div", 69);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(4, "svg", 70);
    i0.ɵɵtext(5, "\n                ");
    i0.ɵɵelement(6, "path", 71);
    i0.ɵɵtext(7, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n              ");
    i0.ɵɵelementStart(9, "svg", 72);
    i0.ɵɵtext(10, "\n                ");
    i0.ɵɵelement(11, "path", 73);
    i0.ɵɵtext(12, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n            ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(15, "p", 68);
    i0.ɵɵtext(16);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r59 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(16);
    i0.ɵɵtextInterpolate(ctx_r59.texts.dragAndDrop);
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "div", 74);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(4, "svg", 75);
    i0.ɵɵtext(5, "\n                        ");
    i0.ɵɵelement(6, "path", 76);
    i0.ɵɵtext(7, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n            ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(10, "span", 77);
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r60 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(11);
    i0.ɵɵtextInterpolate(ctx_r60.uploadLimitExceed);
} }
function AdaptUploaderComponent_ng_template_45_ng_container_1_div_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 78);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "div", 79);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(4, "svg", 80);
    i0.ɵɵtext(5, "\n              ");
    i0.ɵɵelement(6, "path", 81);
    i0.ɵɵtext(7, "\n              ");
    i0.ɵɵelement(8, "path", 82);
    i0.ɵɵtext(9, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n            ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(11, "div", 83);
    i0.ɵɵtext(12, "\n              ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(13, "svg", 84);
    i0.ɵɵtext(14, "\n                ");
    i0.ɵɵelement(15, "path", 85);
    i0.ɵɵtext(16, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(19, "\n          ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(20, "p", 68);
    i0.ɵɵtext(21);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r61 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(21);
    i0.ɵɵtextInterpolate(ctx_r61.directorySearch);
} }
const _c9 = function (a0, a1, a2, a3) { return { leftStart: a0, rightStart: a1, leftEnd: a2, rightEnd: a3 }; };
const _c10 = function (a0) { return { params: a0 }; };
function AdaptUploaderComponent_ng_template_45_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "div", 51);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementStart(4, "div", 52, 53);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵtemplate(7, AdaptUploaderComponent_ng_template_45_ng_container_1_div_7_Template, 7, 8, "div", 54);
    i0.ɵɵtext(8, "\n\n        ");
    i0.ɵɵtemplate(9, AdaptUploaderComponent_ng_template_45_ng_container_1_div_9_Template, 7, 8, "div", 55);
    i0.ɵɵtext(10, "\n\n        ");
    i0.ɵɵtemplate(11, AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_11_Template, 8, 4, "ng-container", 56);
    i0.ɵɵtext(12, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n\n      ");
    i0.ɵɵelementStart(14, "div", 57, 58);
    i0.ɵɵtext(16, "\n        ");
    i0.ɵɵelementStart(17, "div", 59);
    i0.ɵɵtext(18, "\n          ");
    i0.ɵɵtemplate(19, AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_19_Template, 18, 1, "ng-container", 11);
    i0.ɵɵtext(20, "\n\n          ");
    i0.ɵɵtemplate(21, AdaptUploaderComponent_ng_template_45_ng_container_1_ng_container_21_Template, 13, 1, "ng-container", 11);
    i0.ɵɵtext(22, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n\n        ");
    i0.ɵɵtemplate(24, AdaptUploaderComponent_ng_template_45_ng_container_1_div_24_Template, 23, 1, "div", 60);
    i0.ɵɵtext(25, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(26, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(27, "\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r52 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("@uploaderInitStateAnim", i0.ɵɵpureFunction1(14, _c10, i0.ɵɵpureFunction4(9, _c9, ctx_r52.isRtl ? "auto" : "15%", ctx_r52.isRtl ? "15%" : "auto", ctx_r52.isRtl ? "auto" : "0px", ctx_r52.isRtl ? "0px" : "auto")));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r52.allowFileUploading());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r52.allowDirUploading());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r52.enableDnD);
    i0.ɵɵadvance(6);
    i0.ɵɵclassProp("hidden", ctx_r52.readFolder);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r52.isUploadLimitExceed);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r52.isUploadLimitExceed);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r52.readFolder);
} }
function AdaptUploaderComponent_ng_template_45_ng_container_3_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r72 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 61);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "button", 86);
    i0.ɵɵlistener("click", function AdaptUploaderComponent_ng_template_45_ng_container_3_div_4_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r72); const ctx_r71 = i0.ɵɵnextContext(3); return ctx_r71.openFileDialog(false); });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r69 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r69.selectFilesButtonTooltip)("placement", "auto");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("disabled", ctx_r69.isDisabledSelectBtn);
    i0.ɵɵattribute("aria-label", ctx_r69.texts.fileBtn)("aria-describedby", ctx_r69.context.ariaDescribedBy || null);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", ctx_r69.texts.fileBtn, "\n        ");
} }
function AdaptUploaderComponent_ng_template_45_ng_container_3_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r74 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 64);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "button", 87);
    i0.ɵɵlistener("click", function AdaptUploaderComponent_ng_template_45_ng_container_3_div_6_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r74); const ctx_r73 = i0.ɵɵnextContext(3); return ctx_r73.openFileDialog(true); });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r70 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r70.selectFilesButtonTooltip)("placement", "auto");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("disabled", ctx_r70.isDisabledSelectBtn);
    i0.ɵɵattribute("aria-label", ctx_r70.texts.folderBtn)("aria-describedby", ctx_r70.context.ariaDescribedBy || null);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", ctx_r70.texts.folderBtn, "\n        ");
} }
function AdaptUploaderComponent_ng_template_45_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "div", 52);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, AdaptUploaderComponent_ng_template_45_ng_container_3_div_4_Template, 5, 8, "div", 54);
    i0.ɵɵtext(5, "\n\n      ");
    i0.ɵɵtemplate(6, AdaptUploaderComponent_ng_template_45_ng_container_3_div_6_Template, 5, 8, "div", 55);
    i0.ɵɵtext(7, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r53 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r53.allowFileUploading());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r53.allowDirUploading());
} }
function AdaptUploaderComponent_ng_template_45_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵtemplate(1, AdaptUploaderComponent_ng_template_45_ng_container_1_Template, 28, 16, "ng-container", 11);
    i0.ɵɵtext(2, "\n\n  ");
    i0.ɵɵtemplate(3, AdaptUploaderComponent_ng_template_45_ng_container_3_Template, 9, 2, "ng-container", 11);
    i0.ɵɵtext(4, "\n");
} if (rf & 2) {
    const ctx_r14 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r14.enableDnD);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r14.enableDnD);
} }
const _c11 = ["*"];
let count$1 = 0;
class AdaptUploaderComponent extends FormComponent {
    constructor(fileManager, iconService, _renderer, _elRef, _dir, _animationBuilder, _injector, _differs, cd, ts, _adaptRadarService) {
        super(_injector, ts, _adaptRadarService, _elRef, AdaptRadarAngularCustomEventName.AdaptUploader);
        this.fileManager = fileManager;
        this.iconService = iconService;
        this._renderer = _renderer;
        this._elRef = _elRef;
        this._dir = _dir;
        this._animationBuilder = _animationBuilder;
        this._injector = _injector;
        this._differs = _differs;
        this.cd = cd;
        this._adaptRadarService = _adaptRadarService;
        /* begin text configurations **/
        this.uploaderTextsDefault = {
            fileStatus: {}
        };
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        this.mode = UploaderMode.Auto;
        this.selectionMode = UploaderSelectionMode.Both;
        this.enableDnD = true;
        this.enableFileDialog = true;
        this.allowedTypes = [];
        this.forbiddenTypes = [];
        this.suppressParallel = false;
        this.filesCount = 1000;
        this.allowDuplicates = true;
        this.showUploadFolderAlert = true;
        this.icons = {};
        this.visibleFiles = 3;
        this.reusable = true;
        this.indeterminateFileLoader = false;
        this.ariaDescribedBy = null;
        this.allowDeletion = true;
        this.customErrors = false;
        /* uploader outputs */
        this.beforeFileDialogOpen = new EventEmitter();
        this.afterFileDialogOpen = new EventEmitter();
        this.beforeFilesAdded = new EventEmitter();
        this.afterFilesAdded = new EventEmitter();
        this.dropArea = new EventEmitter();
        this.dragOver = new EventEmitter();
        this.startFileUploading = new EventEmitter();
        this.endFileUploading = new EventEmitter();
        this.errorFileUploading = new EventEmitter();
        this.finishedFileUploading = new EventEmitter();
        this.removedFileFromQueue = new EventEmitter();
        this.deletedFile = new EventEmitter();
        this.cancelUploading = new EventEmitter();
        /**
         * Event on ngModel change
         */
        this.valueChange = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.focus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.blur = new EventEmitter();
        // Need for using inherited properties in the template
        this.context = this;
        this.statusMessages = [];
        this.uploaded = [];
        this.folderUploadingForbiddenMsg = 'Your browser does not support folders uploading.';
        this.isFoldersNotAllowed = false;
        this.readFolder = false;
        this.isDragOverMask = false;
        this.isRtl = false;
        this.isUploadLimitExceed = false;
        this._droppable = 0;
        this._alreadyUsed = false;
        this._positioned = false;
        this._defaultCloudColor = '#D9D9D9';
        this._activeCloudColor = '#1BB1A8';
        this._animationPlayers = {
            visibleDnd: null,
            hiddenDnd: null,
            visibleDrop: null,
            hiddenDrop: null
        };
        this._isTouched = false;
        this._showFiles = [];
        this._destroyed$ = new ReplaySubject(1);
        this._chunkSize = FileSize.MB;
        this._maxFileSize = FileSize.MB * 20;
        this._onTouchedCallback = () => {
            return;
        };
        this.isRtl = this._dir.value === 'rtl';
        this.id = count$1.toString();
        count$1++;
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get showFiles() {
        return this._showFiles;
    }
    set showFiles(v) {
        this._showFiles = v;
        this.fileManager.resetFilesStorage();
        this._updateUploadedFiles();
    }
    get files() {
        return this.fileManager.getFiles();
    }
    get maxFileCountUploaded() {
        return this.uploaded.length >= this.filesCount;
    }
    get hasMaxFileCountSelected() {
        return this.filesCount <= this.files.length;
    }
    get selectFilesButtonTooltip() {
        return this.hasMaxFileCountSelected ? formatString(this.texts.btnMaxFilesTooltip, this.filesCount) : '';
    }
    get isDisabledSelectBtn() {
        return this.disabled || this.disableFileDialog() || !this.allowedUploading() || this.maxFileCountUploaded
            || this.hasMaxFileCountSelected;
    }
    get isUploadingProcess() {
        return this.files.some(file => file.inUploading);
    }
    get filesAddedCount() {
        return formatString(this.texts.filesAddedCount, this.files.length);
    }
    get filesUploadedCount() {
        return formatString(this.texts.filesUploadedCount, this.uploaded.length, this.files.length);
    }
    get directorySearch() {
        return formatString(this.texts.directorySearch, this.currentFolder);
    }
    get chunkSize() {
        return isNil(this._chunkSize) ? this._chunkSize : this._chunkSize.toString();
    }
    set chunkSize(value) {
        this._chunkSize = isNil(value) ? value : retrieveFileSize(value);
    }
    get maxFileSize() {
        return this._maxFileSize.toString();
    }
    set maxFileSize(value) {
        this._maxFileSize = retrieveFileSize(value);
    }
    get hostClasses() {
        return [
            this.mainCls,
            'adapt-uploader',
            this.enableDnD ? '' : 'is-no-dnd',
            this.isErrorExist ? 'has-danger' : '',
            this.isWarningExist ? 'has-warning' : '',
            this.disabled ? 'disabled' : '',
            this.readonly ? 'readonly' : '',
            this.suppressIcons ? 'prevent-success-icon' : ''
        ].join(' ');
    }
    get isErrorExist() {
        return this.required && !this.files.length && (this.customFormControl ? this.control.touched : this._isTouched);
    }
    get isWarningExist() {
        return !!this.statusMessages.length && this.statusMessages.some(message => message.variant === MessageStatus.Warning);
    }
    get uploadLimitExceed() {
        return formatString(this.texts.uploadFilesLimit, this.filesCount - this.files.length);
    }
    set value(v) {
        this._value = v;
    }
    get value() {
        return this._value;
    }
    ngOnInit() {
        // Sending radar event directly to avoid issues with the premature invocation of "initControl" in parent ngOnInit()
        // ERROR NullInjectorError: R3InjectorError(AppModule)[NgControl -> NgControl -> NgControl]:
        // So do not call super.ngOnInit() here
        // TODO: ?
        this._adaptRadarService.sendGenericComponentEvent(AdaptRadarAngularCustomEventName.AdaptUploader);
        if (this.customFormControl) {
            this.initControl();
        }
        this.initTextsValues();
        this.initFileErrors();
        this._customErrorTexts = Object.assign({ required: {
                name: '',
                text: this.texts.required
            } }, this._customErrorTexts);
        this.iconService.init(this.icons);
        this.fileManager.messagesSubject
            .pipe(takeUntil(this._destroyed$))
            .subscribe((msg) => {
            this.statusMessages.push(msg);
        });
        this.fileManager.uploadingStartSubject.pipe(takeUntil(this._destroyed$)).subscribe(({ file }) => {
            const fileEvent = Object.assign(Object.assign({}, file), { 
                // Perhaps always id === 1, because it is the first chunk or file,
                // but just in case this algorithm
                id: this.fileManager.getFileRequestId(this.fileManager.getChunkStart(INITIAL_CHUNK_NUMBER, this._chunkSize), this._chunkSize) });
            this.startFileUploading.emit(fileEvent);
        });
        this.fileManager.uploadedSubject.pipe(takeUntil(this._destroyed$)).subscribe((file) => {
            this.uploaded.push(file);
            this.endFileUploading.emit(file);
        });
        this.fileManager.canceledSubject.pipe(takeUntil(this._destroyed$)).subscribe((files) => {
            this.cancelUploading.emit(files);
        });
        this.fileManager.errorUploadingSubject.pipe(takeUntil(this._destroyed$))
            .subscribe((data) => {
            this.errorFileUploading.emit(data);
        });
        this.fileManager.uploadingFinishedSubject.pipe(takeUntil(this._destroyed$)).subscribe((files) => {
            this.finishedFileUploading.emit(files);
        });
        this.cloudColor = this._defaultCloudColor;
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        this._filesListDiffer = this._differs.find(this.showFiles).create();
        if (this.tooltipIconCls && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIconCls,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    setDefaultTexts(translation) {
        this.uploaderTextsDefault.fileBtn = translation['adapt.uploader.attachFiles'];
        this.uploaderTextsDefault.folderBtn = translation['adapt.uploader.attachFolder'];
        this.uploaderTextsDefault.allowedTypes = translation['adapt.uploader.allowedTypes'];
        this.uploaderTextsDefault.fileTypesDivider = translation['adapt.uploader.fileTypesDivider'];
        this.uploaderTextsDefault.maxFileSize = translation['adapt.uploader.maxFileSize'];
        this.uploaderTextsDefault.filesCount = translation['adapt.uploader.filesCount'];
        this.uploaderTextsDefault.fileMode = translation['adapt.uploader.fileMode'];
        this.uploaderTextsDefault.dirMode = translation['adapt.uploader.dirMode'];
        this.uploaderTextsDefault.mixMode = translation['adapt.uploader.mixMode'];
        this.uploaderTextsDefault.dragAndDrop = translation['adapt.uploader.dragAndDrop'];
        this.uploaderTextsDefault.uploadFilesLimit = translation['adapt.uploader.uploadFilesLimit'];
        this.uploaderTextsDefault.required = translation['adapt.uploader.required'];
        this.uploaderTextsDefault.showMore = translation['adapt.uploader.showMore'];
        this.uploaderTextsDefault.showLess = translation['adapt.uploader.showLess'];
        this.uploaderTextsDefault.btnMaxFilesTooltip = translation['adapt.uploader.maxFilesTooltip'];
        this.uploaderTextsDefault.btnCancelUploading = translation['adapt.uploader.cancelUploading'];
        this.uploaderTextsDefault.btnRemoveFile = translation['adapt.uploader.removeFile'];
        this.uploaderTextsDefault.btnDeleteFile = translation['adapt.uploader.deleteFile'];
        this.uploaderTextsDefault.btnRemoveCanceled = translation['adapt.uploader.removeCanceled'];
        this.uploaderTextsDefault.btnDownloadFile = translation['adapt.uploader.downloadFile'];
        this.uploaderTextsDefault.fileStatus.canceled = translation['adapt.uploader.fileStatus.canceled'];
        this.uploaderTextsDefault.fileStatus.uploaded = translation['adapt.uploader.fileStatus.uploaded'];
        this.uploaderTextsDefault.fileStatus.uploading = translation['adapt.uploader.fileStatus.uploading'];
        this.uploaderTextsDefault.filesAddedCount = translation['adapt.uploader.filesAddedCount'];
        this.uploaderTextsDefault.filesUploadedCount = translation['adapt.uploader.filesUploadedCount'];
        this.uploaderTextsDefault.directorySearch = translation['adapt.uploader.directorySearch'];
        this.uploaderTextsDefault.remainingFilesListLabel = translation['adapt.uploader.remainingFilesListLabel'];
        this.uploaderTextsDefault.btnCancelAllUploads = translation['adapt.uploader.cancelAllUploads'];
        this.uploaderTextsDefault.notFound = translation['adapt.uploader.notFound'];
        this.uploaderTextsDefault.comma = translation['adapt.common.comma'];
    }
    setFilesList(files) {
        const changes = this._filesListDiffer.diff(files);
        if (changes) {
            changes.forEachAddedItem(file => {
                this.showFiles.push(file.item);
                this.fileManager.updateFilesStorage(file.item, true);
            });
            changes.forEachRemovedItem(file => {
                const index = this.showFiles.indexOf(file.item);
                if (index >= 0) {
                    this.showFiles.splice(index, 1);
                }
                this.fileManager.decreaseFilesStorage(file.item);
            });
            this._markComponentTouched();
            this._propagateChanges();
            this._componentEmptyState();
        }
    }
    writeValue(value) {
        if (value && value.length) {
            this.showFiles = value;
            this.fileManager.updateFilesStorage(value);
            this.clearWarningMessages();
        }
        else {
            this.fileManager.resetFilesStorage();
        }
        this._propagateChanges();
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    validate() {
        return null;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (!this.droppableArea) {
            this.droppableArea = this.droppableAreaBlock.nativeElement;
        }
        if (isUndefined(this.fileInput.nativeElement.webkitdirectory)) {
            adaptWarn(this.folderUploadingForbiddenMsg);
            this.isFoldersNotAllowed = true;
            this.selectionMode = UploaderSelectionMode.File;
            SafeCdr.detectChanges(this.cd);
        }
        if (this.enableDnD) {
            this.addDragEvents();
        }
        fromEvent(this.fileInput.nativeElement, 'change')
            .pipe(takeUntil(this._destroyed$))
            .subscribe((e) => {
            this.onChangeFileInput(e);
        });
    }
    addDragEvents() {
        this._onDragEnter = this.ondragEnter.bind(this);
        this.droppableArea.addEventListener('dragenter', this._onDragEnter);
        this._onDragOver = this.ondragOver.bind(this);
        this.droppableArea.addEventListener('dragover', this._onDragOver);
        this._onDragLeave = this.ondragLeave.bind(this);
        this.droppableArea.addEventListener('dragleave', this._onDragLeave);
        this._onDragDrop = this.ondragDrop.bind(this);
        this.droppableArea.addEventListener('drop', this._onDragDrop);
        document.addEventListener('dragover', this._preventDefault);
        document.addEventListener('drop', this._preventDefault);
    }
    initFileErrors() {
        if (this.fileErrors) {
            this.fileManager.fileErrors = Object.assign(Object.assign({}, this.fileManager.fileErrors), this.fileErrors);
            Object.keys(this.fileManager.fileErrors).forEach((key) => this.fileManager.messages[key] = {
                errorMessage: '',
                files: []
            });
        }
    }
    initTextsValues() {
        this.texts = Object.assign(Object.assign({}, this.uploaderTextsDefault), this.texts);
    }
    ngOnChanges(changes) {
        if (changes.texts && !isUndefined(changes.texts.previousValue)) {
            this.initTextsValues();
        }
        if (changes.fileErrors && !isUndefined(changes.fileErrors.previousValue)) {
            this.initFileErrors();
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (!this.disabled && this.enableDnD) {
            this.droppableArea.removeEventListener('dragenter', this._onDragEnter);
            this.droppableArea.removeEventListener('dragover', this._onDragOver);
            this.droppableArea.removeEventListener('dragleave', this._onDragLeave);
            this.droppableArea.removeEventListener('drop', this._onDragDrop);
            document.removeEventListener('dragover', this._preventDefault);
            document.removeEventListener('drop', this._preventDefault);
        }
        this.cancelAllUploads();
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    cancelAllUploads() {
        if (this.files.every(file => !file.inUploading)) {
            return;
        }
        const uploadInputs = {
            chunkSize: this._chunkSize,
            uploadUrl: this.url,
            customErrors: this.customErrors
        };
        this.fileManager.abortUploading(uploadInputs);
    }
    ondragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.disabled || this.readonly || this._droppable || !this.dataHasFiles(e) || this.hasMaxFileCountSelected) {
            return;
        }
        // check if the upload files limit exceeded
        // event.dataTransfer.items is not available in Internet Explorer and Safari
        // Mime types or number of dragged files can therefore not be determined in drag events, only on drop
        // so we explicitly set the value to 0
        const dndFilesCount = e.dataTransfer.items ? e.dataTransfer.items.length : 0;
        this.isUploadLimitExceed = dndFilesCount > (this.filesCount - this.files.length);
        this.isDragOverMask = true;
        this._renderer.addClass(this.droppableArea, 'adapt-drop-wrp');
        this._renderer.addClass(this.dropEnter.nativeElement, 'pointer-events');
        this._droppable++;
        this._createAnimationPlayers();
        this._animateDndChange();
    }
    ondragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.disabled || this.readonly || this.isUploadLimitExceed) {
            e.dataTransfer.dropEffect = 'none';
        }
        this.dragOver.emit(null);
    }
    ondragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        if (e.target !== this.droppableArea) {
            return;
        }
        this._droppable--;
        if (!this._droppable) {
            this.isDragOverMask = false;
            this._animateDndChange();
            this._renderer.removeClass(this.dropEnter.nativeElement, 'pointer-events');
            this._renderer.removeClass(this.droppableArea, 'adapt-drop-wrp');
            this._markComponentTouched();
            this._componentEmptyState();
        }
    }
    ondragDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        this.clearWarningMessages();
        this._markComponentTouched();
        if (this.hasMaxFileCountSelected) {
            return;
        }
        if (isUndefined(this.fileInput.nativeElement.webkitdirectory)) {
            const files = toArray(e.dataTransfer.files);
            this.addFilesEmission(files);
            this._componentEmptyState();
            return;
        }
        const items = toArray(e.dataTransfer.items);
        this.resolveDroppedItems(items).then((values) => {
            this.addFilesEmission(values);
            this._componentEmptyState();
        }, (err) => {
            this.statusMessages.push({ title: err.name, text: err.message, variant: MessageStatus.Warning });
            this.addFilesEmission([]);
            this._componentEmptyState();
        });
    }
    resolveDroppedItems(items) {
        return new Promise((resolve, reject) => {
            const promises = [];
            let files = [];
            items.forEach((item) => {
                const itemEntry = item.webkitGetAsEntry();
                if (itemEntry.isDirectory) {
                    // Allowed to upload directories and browser know about directories
                    if (this.allowDirUploading()) {
                        this.readFolder = true;
                        promises.push(this.getDirectory(itemEntry));
                        return;
                    }
                    // check if folderSuppress error is already added to the statusMessages array
                    const messageIndex = this.statusMessages
                        .map(message => message.text)
                        .indexOf(this.fileManager.fileErrors.folderSuppress);
                    if (messageIndex === -1) {
                        this.statusMessages.push({
                            text: this.fileManager.fileErrors.folderSuppress,
                            variant: MessageStatus.Warning
                        });
                    }
                }
                if (itemEntry.isFile) {
                    if (this.selectionMode === UploaderSelectionMode.Directory) {
                        // check if fileSuppress error is already added to the statusMessages array
                        const messageIndex = this.statusMessages
                            .map(message => message.text)
                            .indexOf(this.fileManager.fileErrors.fileSuppress);
                        if (messageIndex === -1) {
                            this.statusMessages.push({
                                text: this.fileManager.fileErrors.fileSuppress,
                                variant: MessageStatus.Warning
                            });
                        }
                        return;
                    }
                    promises.push(this.getFile(itemEntry));
                }
            });
            Promise.all(promises).then((values) => {
                files = values.reduce((acc, item) => {
                    return acc.concat(item);
                }, files);
                this.readFolder = false;
                resolve(files);
            }, (err) => {
                this.statusMessages.push({ title: err.name, text: err.message, variant: MessageStatus.Warning });
                this.readFolder = false;
                reject(err);
            });
        });
    }
    /**
     * Manages ability to select files via file dialog window
     */
    disableFileDialog() {
        return !this.enableFileDialog;
    }
    /**
     * Allows/Forbids to select multiple files for uploading
     */
    isMultipleAllowed() {
        return this.filesCount > 1;
    }
    /**
     * Opens file dialog window for files selection, fires appropriate events
     */
    openFileDialog(isDir) {
        if (!isUndefined(this.fileInput.nativeElement.webkitdirectory)) {
            this.fileInput.nativeElement.webkitdirectory = !!isDir;
        }
        this.beforeFileDialogOpen.emit(null);
        this.fileInput.nativeElement.click();
        this.afterFileDialogOpen.emit(null);
    }
    onChangeFileInput(e) {
        const files = toArray(e.target.files);
        if (files.length) {
            this.addFiles(files);
        }
        this._markComponentTouched();
        this._componentEmptyState();
    }
    isManualMode() {
        return this.mode === UploaderMode.Manual;
    }
    allowFileUploading() {
        return this.selectionMode === UploaderSelectionMode.File || this.selectionMode === UploaderSelectionMode.Both;
    }
    allowDirUploading() {
        return this.selectionMode === UploaderSelectionMode.Directory || this.selectionMode === UploaderSelectionMode.Both;
    }
    fileMode() {
        return UploaderSelectionMode.File;
    }
    dirMode() {
        return UploaderSelectionMode.Directory;
    }
    mixMode() {
        return UploaderSelectionMode.Both;
    }
    allowedUploading() {
        return this.reusable || !this._alreadyUsed;
    }
    startUploading() {
        if (this.readonly || this.disabled) {
            return;
        }
        this._markComponentTouched();
        if (this.isErrorExist) {
            if (!this.customFormControl) {
                // check if required error is already added to the statusMessages array
                const messageIndex = this.statusMessages
                    .map(message => message.text)
                    .indexOf(this.texts.required);
                if (messageIndex === -1) {
                    this.statusMessages.push({ text: this.texts.required, variant: MessageStatus.Danger });
                }
            }
            return;
        }
        if (this.allowedUploading()) {
            const uploadInputs = {
                chunkSize: this._chunkSize,
                uploadUrl: this.url,
                customErrors: this.customErrors
            };
            this.fileManager.startUploading(uploadInputs);
            if (!this.reusable) {
                this._alreadyUsed = true;
            }
        }
    }
    removedFromQueue(file) {
        const index = this.uploaded.indexOf(file);
        if (index >= 0) {
            this.uploaded.splice(index, 1);
        }
        if (!file.canceled) {
            this.removedFileFromQueue.emit(file);
        }
        this._markComponentTouched();
        this._propagateChanges();
        this._componentEmptyState();
    }
    fileDeleted(file) {
        const index = this.uploaded.indexOf(file);
        if (index >= 0) {
            this.uploaded.splice(index, 1);
        }
        this.deletedFile.emit(file);
        this._markComponentTouched();
        this._propagateChanges();
        this._componentEmptyState();
    }
    clearWarningMessages() {
        this.statusMessages = [];
    }
    /**
     * Adds files to uploader service
     */
    addFiles(files) {
        this.clearWarningMessages();
        if (this.allowedUploading()) {
            if (this.mode === UploaderMode.Auto && !this.reusable) {
                this._alreadyUsed = true;
            }
            this.beforeFilesAdded.emit(files);
            this.fileManager.addFiles(files, this.allowDeletion, this.mode, this.suppressParallel, this.allowDuplicates, this._maxFileSize, this._chunkSize, this.allowedTypes, this.forbiddenTypes, this.filesCount, this.customErrors, this.url);
            this.afterFilesAdded.emit(files);
            this._propagateChanges();
            // don't do "value = ''" due to secondary event firing in IE with 0 files
            // thus statusMessages are cleared
            // uncomment selection - we need to clear input element, so input change event would fire
            // for the IE we have validation for the files array length
            this.fileInput.nativeElement.value = '';
            this._positioned = false;
        }
    }
    _updateStorageWithUploadedFiles() {
        if (this.showFiles) {
            this.fileManager.updateFilesStorage(this.showFiles, true);
        }
    }
    /**
     * Checks if the dragged data has files
     */
    dataHasFiles(e) {
        const types = Array.prototype.slice.call(e.dataTransfer.types);
        return types.indexOf('Files') !== -1;
    }
    getFile(item, dirName = '') {
        return new Promise((resolve, reject) => {
            item.file((f) => {
                f.fullPath = dirName ? `${dirName}/${f.name}` : f.name;
                resolve(f);
            }, (err) => {
                reject(err);
            });
        });
    }
    getDirectory(item) {
        this.currentFolder = item.name;
        return new Promise((resolve, reject) => {
            const promises = [];
            const reader = item.createReader();
            reader.readEntries((entries) => {
                entries.forEach((entry) => {
                    let promise;
                    if (entry.isDirectory) {
                        promise = this.getDirectory(entry);
                    }
                    else if (entry.isFile) {
                        promise = this.getFile(entry, item.fullPath.slice(1));
                    }
                    if (promise) {
                        promises.push(promise);
                    }
                });
                Promise.all(promises).then((values) => {
                    let dirFiles = [];
                    dirFiles = values.reduce((acc, value) => {
                        return acc.concat(value);
                    }, dirFiles);
                    resolve(dirFiles);
                }, (err) => {
                    reject(err);
                });
            });
        });
    }
    addFilesEmission(files) {
        this.dropArea.emit(null);
        if (files.length) {
            this.addFiles(files);
        }
        this._droppable = 0;
        this.isDragOverMask = false;
        this._animateDndChange();
        this._renderer.removeClass(this.droppableArea, 'adapt-drop-wrp');
        this._renderer.removeClass(this.dropEnter.nativeElement, 'pointer-events');
    }
    _preventDefault(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    _animateDndChange() {
        this._animationPlayers.hiddenDnd.reset();
        this._animationPlayers.visibleDnd.reset();
        this._animationPlayers.hiddenDrop.reset();
        this._animationPlayers.visibleDrop.reset();
        const currentPlayerDnd = this.isDragOverMask ? this._animationPlayers.hiddenDnd : this._animationPlayers.visibleDnd;
        const currentPlayerDrop = this.isDragOverMask ? this._animationPlayers.visibleDrop : this._animationPlayers.hiddenDrop;
        currentPlayerDnd.play();
        currentPlayerDrop.play();
        currentPlayerDrop.onDone(() => {
            if (!this._droppable) {
                this.isUploadLimitExceed = false;
            }
        });
    }
    _createAnimationPlayers() {
        const players = Object.keys(this._animationPlayers);
        players.forEach((player) => {
            if (this._animationPlayers[player]) {
                this._animationPlayers[player].destroy();
            }
        });
        this._animationPlayers.hiddenDnd = this._animationBuilder.build(ANIMATION_DND.hidden[this._dir.value])
            .create(this.dnd.nativeElement);
        this._animationPlayers.visibleDnd = this._animationBuilder.build(ANIMATION_DND.visible[this._dir.value])
            .create(this.dnd.nativeElement);
        this._animationPlayers.hiddenDrop = this._animationBuilder.build(ANIMATION_DROP.hidden[this._dir.value])
            .create(this.drop.nativeElement);
        this._animationPlayers.visibleDrop = this._animationBuilder.build(ANIMATION_DROP.visible[this._dir.value])
            .create(this.drop.nativeElement);
    }
    _componentEmptyState() {
        if (this.files.length) {
            return;
        }
        if (this.isErrorExist && !this.customFormControl) {
            // check if required error is already added to the statusMessages array
            const messageIndex = this.statusMessages
                .map(message => message.text)
                .indexOf(this.texts.required);
            if (messageIndex === -1) {
                this.statusMessages.push({ text: this.texts.required, variant: MessageStatus.Danger });
            }
        }
    }
    _markComponentTouched() {
        this._isTouched = true;
        this._onTouchedCallback();
    }
    _propagateChanges() {
        this.propagateChange(this.files);
        this.valueChange.emit(this.files);
    }
    _updateUploadedFiles() {
        this.uploaded = [];
        if (this.showFiles.length) {
            this.showFiles.forEach(file => {
                if (file.uploaded === FILE_IS_UPLOADED_PERCENTAGE && !file.canceled && !file.error) {
                    this.uploaded.push(file);
                }
            });
        }
        this._updateStorageWithUploadedFiles();
    }
}
AdaptUploaderComponent.ɵfac = function AdaptUploaderComponent_Factory(t) { return new (t || AdaptUploaderComponent)(i0.ɵɵdirectiveInject(i1.FileManager), i0.ɵɵdirectiveInject(i1.IconManager), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2$1.Directionality), i0.ɵɵdirectiveInject(i1$1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService)); };
AdaptUploaderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptUploaderComponent, selectors: [["adapt-uploader"]], viewQuery: function AdaptUploaderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$3, 5);
        i0.ɵɵviewQuery(_c1$3, 5);
        i0.ɵɵviewQuery(_c2$3, 5);
        i0.ɵɵviewQuery(_c3$2, 5);
        i0.ɵɵviewQuery(_c4$1, 5);
        i0.ɵɵviewQuery(_c5$1, 5);
        i0.ɵɵviewQuery(AdaptUploaderItemComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fileInput = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fileList = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropEnter = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dnd = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.drop = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.droppableAreaBlock = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filesList = _t);
    } }, hostVars: 2, hostBindings: function AdaptUploaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { mode: "mode", selectionMode: "selectionMode", enableDnD: "enableDnD", enableFileDialog: "enableFileDialog", allowedTypes: "allowedTypes", forbiddenTypes: "forbiddenTypes", suppressParallel: "suppressParallel", filesCount: "filesCount", allowDuplicates: "allowDuplicates", label: "label", showUploadFolderAlert: "showUploadFolderAlert", url: "url", deleteUrl: "deleteUrl", icons: "icons", visibleFiles: "visibleFiles", reusable: "reusable", indeterminateFileLoader: "indeterminateFileLoader", ariaDescribedBy: "ariaDescribedBy", allowDeletion: "allowDeletion", texts: "texts", showFiles: "showFiles", fileErrors: "fileErrors", droppableArea: "droppableArea", customErrors: "customErrors", name: "name", customFormControl: "customFormControl", chunkSize: "chunkSize", maxFileSize: "maxFileSize" }, outputs: { beforeFileDialogOpen: "beforeFileDialogOpen", afterFileDialogOpen: "afterFileDialogOpen", beforeFilesAdded: "beforeFilesAdded", afterFilesAdded: "afterFilesAdded", dropArea: "dropArea", dragOver: "dragOver", startFileUploading: "startFileUploading", endFileUploading: "endFileUploading", errorFileUploading: "errorFileUploading", finishedFileUploading: "finishedFileUploading", removedFileFromQueue: "removedFileFromQueue", deletedFile: "deletedFile", cancelUploading: "cancelUploading", valueChange: "valueChange", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptUploaderComponent),
            createFormControlValidator(AdaptUploaderComponent),
            FileManager,
            IconManager
        ]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c11, decls: 48, vars: 12, consts: [["type", "file", "hidden", "", 3, "multiple"], ["fileInput", ""], [1, "adapt-uploader__wrp"], ["droppableAreaBlock", ""], [1, "adapt-uploader__content"], ["dropEnter", ""], [3, "label", "requiredLabel", "showRequiredLabel", "tooltip"], [1, "adapt-uploader-dnd-animation__wrp"], [3, "ngTemplateOutlet"], [1, "adapt-uploader-block-level-text"], ["class", "adapt-uploader-messages", 3, "config", 4, "ngFor", "ngForOf"], [4, "ngIf"], ["class", "adapt-uploader-restrict", 4, "ngIf"], ["class", "adapt-uploader-list-files-wrapper", 4, "ngIf"], [3, "config", 4, "ngIf"], ["emptyTmpl", ""], ["emptyReadonly", ""], ["controlsData", ""], [1, "adapt-uploader-messages", 3, "config"], ["errorMessageTemplate", ""], ["remainingFileListTemplate", ""], [1, "remaining-files-list", 3, "adaptPopover", "adaptRadarDisableEventSending", "placement", "maxWidth"], ["ngFor", "", 3, "ngForOf"], [1, "file-name"], [1, "adapt-uploader-restrict"], ["class", "adapt-uploader-restrict-types", 4, "ngIf"], [1, "adapt-uploader-restrict-size"], [1, "d-inline-block", "mb-0"], [1, "letter-space"], [1, "adapt-uploader-restrict-files-count"], [1, "adapt-uploader-restrict-types"], [1, "adapt-uploader-list-files-wrapper"], [1, "adapt-uploader-list-files-zone"], [1, "adapt-uploader-list-files-zone__header"], ["class", "adapt-uploader-list-title p-start-3", 4, "ngIf"], ["class", "adapt-uploader-list-title p-start-3", 3, "text-info", 4, "ngIf"], ["adapt-button", "", "type", "button", "btn-type", "tertiary", "class", "adapt-uploader-cancel", 3, "adaptRadarDisableEventSending", "click", 4, "ngIf"], [3, "disabled", "readonly", "collapseBlock", "reusable", "indeterminateFileLoader", "url", "deleteUrl", "chunkSize", "customErrors", "file", "id", "texts", "afterFileRemove", "fileDeleted", 4, "ngFor", "ngForOf"], [3, "collapse"], ["fileList", "collapse"], [3, "disabled", "readonly", "reusable", "indeterminateFileLoader", "url", "deleteUrl", "chunkSize", "customErrors", "file", "id", "texts", "afterFileRemove", "fileDeleted", 4, "ngFor", "ngForOf"], ["class", "d-flex justify-content-end mt-1", 4, "ngIf"], [1, "adapt-uploader-list-title", "p-start-3"], ["adapt-button", "", "type", "button", "btn-type", "tertiary", 1, "adapt-uploader-cancel", 3, "adaptRadarDisableEventSending", "click"], [1, "d-icon-cross_adapt", "pr-1"], [3, "disabled", "readonly", "collapseBlock", "reusable", "indeterminateFileLoader", "url", "deleteUrl", "chunkSize", "customErrors", "file", "id", "texts", "afterFileRemove", "fileDeleted"], [3, "disabled", "readonly", "reusable", "indeterminateFileLoader", "url", "deleteUrl", "chunkSize", "customErrors", "file", "id", "texts", "afterFileRemove", "fileDeleted"], [1, "d-flex", "justify-content-end", "mt-1"], ["type", "button", "aria-controls", "collapseExample1", 1, "btn", "btn-link", "btn-uploader-collapse-btn", 3, "click"], [3, "config"], [3, "type", "label"], [1, "adapt-uploader-dnd-animation"], [1, "adapt-uploader-dnd"], ["dnd", ""], ["class", "d-inline-block adapt-uploader-attach-file-btn-wrap", 3, "adaptRadarDisableEventSending", "adaptTooltip", "placement", 4, "ngIf"], ["class", "d-inline-block adapt-uploader-attach-folder-btn-wrap", 3, "adaptRadarDisableEventSending", "adaptTooltip", "placement", 4, "ngIf"], [3, "ngSwitch", 4, "ngIf"], [1, "adapt-uploader-drop"], ["drop", ""], [1, "adapt-uploader-drop-animation"], ["class", "adapt-uploader-search-animation", 4, "ngIf"], [1, "d-inline-block", "adapt-uploader-attach-file-btn-wrap", 3, "adaptRadarDisableEventSending", "adaptTooltip", "placement"], ["type", "button", "adapt-button", "", "btn-type", "secondary", 1, "adapt-uploader-attach-btn", 3, "adaptRadarDisableEventSending", "disabled", "click"], [1, "btn-icon", "d-icon-file_o"], [1, "d-inline-block", "adapt-uploader-attach-folder-btn-wrap", 3, "adaptRadarDisableEventSending", "adaptTooltip", "placement"], [1, "btn-icon", "d-icon-folder_o"], [3, "ngSwitch"], ["class", "adapt-uploader-dnd-text m-start-2", 4, "ngSwitchCase"], [1, "adapt-uploader-dnd-text", "m-start-2"], [1, "adapt-uploader-drop__icon"], ["aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "45", "height", "32", "viewBox", "0 0 72 48", 0, "xml", "space", "preserve", 1, "clound-icon", 2, "enable-background", "new 0 0 72 48"], ["fill", "#D9D9D9", "d", "M72,36c0,6.63-5.37,12-12,12H12C5.37,48,0,42.63,0,36c0-5.98,4.39-10.9,10.12-11.81C9.41,22.26,9,20.18,9,18  C9,8.06,17.06,0,27,0c6.01,0,11.32,2.96,14.59,7.49C43.54,6.56,45.7,6,48,6c8.28,0,15,6.72,15,15c0,1.14-0.15,2.24-0.39,3.3  C67.98,25.5,72,30.27,72,36z", 1, "st0"], ["aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "45", "height", "32", "viewBox", "0 0 72 48", 0, "xml", "space", "preserve", 1, "arrow-icon", 2, "enable-background", "new 0 0 72 48"], ["fill", "#FBFBFB", "d", "M33,48V36H21l15-18l15,18H39v12H33z", 1, "st0"], [1, "adapt-uploader-drop__icon", "adapt-uploader-drop__icon-forbidden"], ["aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "45", "height", "32", "viewBox", "0 0 64 44", 0, "xml", "space", "preserve", 1, "clound-icon__forbidden", 2, "enable-background", "new 0 0 64 44"], ["fill", "#FA7A59", "d", "M54.91,21.93c0.21-0.9,0.34-1.86,0.34-2.84c0-7.13-5.79-12.92-12.92-12.92c-1.99,0-3.85,0.49-5.53,1.29\nC33.99,3.56,29.42,1,24.25,1C15.7,1,8.75,7.95,8.75,16.5c0,1.89,0.36,3.67,0.96,5.32C4.77,22.62,1,26.86,1,32\n\tc0,5.71,4.62,10.33,10.33,10.33h41.33C58.38,42.33,63,37.71,63,32C63,27.07,59.54,22.96,54.91,21.93z M41.14,33.4\n\tc-4.75,4.73-12.22,5.01-17.31,0.85c-0.34-0.26-0.67-0.54-0.98-0.85c-0.31-0.31-0.59-0.65-0.85-0.98\n\tc-4.16-5.09-3.88-12.55,0.85-17.31c4.75-4.73,12.22-5.01,17.31-0.85c0.34,0.26,0.67,0.54,0.98,0.85s0.59,0.65,0.85,0.98\n\tC46.16,21.18,45.87,28.64,41.14,33.4z M25.67,32.41c4.06,3.15,9.92,2.87,13.64-0.85c3.72-3.72,4-9.58,0.85-13.64L25.67,32.41z\n\t M24.69,16.94c-3.72,3.72-4,9.58-0.85,13.64l14.49-14.49C34.27,12.94,28.41,13.22,24.69,16.94z"], [1, "adapt-uploader-dnd-text", "adapt-uploader-dnd-text-forbidden", "m-start-2"], [1, "adapt-uploader-search-animation"], [1, "adapt-uploader-submask-center-inner-read"], ["fill", "#fbfbfb", "aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "50", "height", "38", "viewBox", "0 0 32 32", 1, "adapt-uploader-img-read"], ["fill", "#999999", "d", "M11.983 3.982h-7.981l-4.017 4.017v17.751c0 0.614 0.227 1.134 0.681 1.588s0.988 0.681 1.588 0.681h27.64c0.587 0 1.094-0.2 1.508-0.614s0.614-0.921 0.614-1.508v-15.896c0-0.534-0.2-1.001-0.601-1.401-0.414-0.4-0.867-0.601-1.401-0.601h-14.014l-4.017-4.017z"], ["fill", "#f2f2f2", "d", "M10.888 6.651l3.23 3.23 0.774 0.787h14.454v14.694h-26.693v-16.256l2.442-2.442h5.792z"], [1, "floating"], ["aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "18", "height", "18", "viewBox", "0 0 32 32", 1, "adapt-uploader-img-search", "inner"], ["fill", "#666666", "d", "M31.65 28.686l-8.629-8.627c3.541-4.959 3.090-11.892-1.36-16.342-2.477-2.481-5.725-3.719-8.971-3.719-3.451 0-6.902 1.398-9.428 4.196-4.327 4.792-4.327 12.201 0 16.994 2.527 2.798 5.978 4.196 9.428 4.196 2.583 0 5.168-0.788 7.364-2.358l8.629 8.627c0.35 0.35 0.92 0.35 1.27 0l1.698-1.698c0.35-0.349 0.35-0.918 0-1.269zM6.090 19.292c-3.639-3.639-3.639-9.563 0-13.201 1.762-1.764 4.106-2.734 6.598-2.734s4.834 0.972 6.598 2.734c3.639 3.639 3.639 9.563 0 13.201-1.762 1.764-4.106 2.734-6.598 2.734s-4.837-0.972-6.598-2.734z"], ["type", "button", "adapt-button", "", "btn-type", "secondary", 1, "adapt-uploader-attach-btn", "adapt-uploader-attach-file-btn", 3, "adaptRadarDisableEventSending", "disabled", "click"], ["type", "button", "adapt-button", "", "btn-type", "secondary", 1, "adapt-uploader-attach-btn", "adapt-uploader-attach-folder-btn", 3, "adaptRadarDisableEventSending", "disabled", "click"]], template: function AdaptUploaderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵelement(0, "input", 0, 1);
        i0.ɵɵtext(2, "\n\n");
        i0.ɵɵelementStart(3, "div", 2, 3);
        i0.ɵɵtext(5, "\n  ");
        i0.ɵɵelementStart(6, "div", 4, 5);
        i0.ɵɵtext(8, "\n    ");
        i0.ɵɵtext(9, "\n    ");
        i0.ɵɵelement(10, "adapt-rx-control-label", 6);
        i0.ɵɵtext(11, "\n    ");
        i0.ɵɵtext(12, "\n\n    ");
        i0.ɵɵprojection(13);
        i0.ɵɵtext(14, "\n\n    ");
        i0.ɵɵelementStart(15, "div", 7);
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵtemplate(17, AdaptUploaderComponent_ng_template_17_Template, 1, 0, "ng-template", 8);
        i0.ɵɵtext(18, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(19, "\n\n    ");
        i0.ɵɵtext(20, "\n    ");
        i0.ɵɵelementStart(21, "div", 9);
        i0.ɵɵtext(22, "\n      ");
        i0.ɵɵtemplate(23, AdaptUploaderComponent_adapt_alert_23_Template, 5, 5, "adapt-alert", 10);
        i0.ɵɵtext(24, "\n\n      ");
        i0.ɵɵtemplate(25, AdaptUploaderComponent_ng_container_25_Template, 4, 1, "ng-container", 11);
        i0.ɵɵtext(26, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(27, "\n\n    ");
        i0.ɵɵtext(28, "\n    ");
        i0.ɵɵtemplate(29, AdaptUploaderComponent_div_29_Template, 27, 7, "div", 12);
        i0.ɵɵtext(30, "\n\n    ");
        i0.ɵɵtext(31, "\n    ");
        i0.ɵɵtemplate(32, AdaptUploaderComponent_div_32_Template, 26, 13, "div", 13);
        i0.ɵɵtext(33, "\n    ");
        i0.ɵɵtext(34, "\n\n    ");
        i0.ɵɵtemplate(35, AdaptUploaderComponent_adapt_alert_35_Template, 2, 3, "adapt-alert", 14);
        i0.ɵɵtext(36, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(37, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(38, "\n\n");
        i0.ɵɵtemplate(39, AdaptUploaderComponent_ng_template_39_Template, 0, 0, "ng-template", null, 15, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(41, "\n\n");
        i0.ɵɵtemplate(42, AdaptUploaderComponent_ng_template_42_Template, 4, 2, "ng-template", null, 16, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(44, "\n\n");
        i0.ɵɵtemplate(45, AdaptUploaderComponent_ng_template_45_Template, 5, 2, "ng-template", null, 17, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(47, "\n");
    } if (rf & 2) {
        const _r9 = i0.ɵɵreference(40);
        const _r11 = i0.ɵɵreference(43);
        const _r13 = i0.ɵɵreference(46);
        i0.ɵɵproperty("multiple", ctx.isMultipleAllowed());
        i0.ɵɵattribute("aria-label", "File Control");
        i0.ɵɵadvance(10);
        i0.ɵɵproperty("label", ctx.label)("requiredLabel", ctx.context.requiredLabel)("showRequiredLabel", ctx.context.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngTemplateOutlet", ctx.readonly ? ctx.files.length ? _r9 : _r11 : _r13);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngForOf", ctx.statusMessages);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.customFormControl && ctx.context.errors && ctx.context.errors.length && ctx.context.control.touched);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", !ctx.readonly);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.files.length);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.isFoldersNotAllowed && ctx.showUploadFolderAlert);
    } }, directives: [i1.AdaptRxControlLabelComponent, i3.NgTemplateOutlet, i3.NgForOf, i3.NgIf, i1.AdaptAlertComponent, i1.AdaptPopoverDirective, i1.AdaptCollapseDirective, i1.AdaptButtonComponent, i1.AdaptUploaderItemComponent, i1.AdaptEmptyStateComponent, i1.AdaptTooltipDirective, i3.NgSwitch, i3.NgSwitchCase], pipes: [i1.FileSizePipe, i1.FileTypesPipe, i3.SlicePipe], encapsulation: 2, data: { animation: [ANIMATION_INIT_STATE] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptUploaderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-uploader',
                templateUrl: './uploader.component.html',
                providers: [
                    createFormControlValueAccessor(AdaptUploaderComponent),
                    createFormControlValidator(AdaptUploaderComponent),
                    FileManager,
                    IconManager
                ],
                encapsulation: ViewEncapsulation.None,
                animations: [ANIMATION_INIT_STATE]
            }]
    }], function () { return [{ type: i1.FileManager }, { type: i1.IconManager }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i2$1.Directionality }, { type: i1$1.AnimationBuilder }, { type: i0.Injector }, { type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }]; }, { fileInput: [{
            type: ViewChild,
            args: ['fileInput']
        }], fileList: [{
            type: ViewChild,
            args: ['fileList']
        }], dropEnter: [{
            type: ViewChild,
            args: ['dropEnter']
        }], dnd: [{
            type: ViewChild,
            args: ['dnd']
        }], drop: [{
            type: ViewChild,
            args: ['drop']
        }], droppableAreaBlock: [{
            type: ViewChild,
            args: ['droppableAreaBlock']
        }], filesList: [{
            type: ViewChildren,
            args: [AdaptUploaderItemComponent]
        }], mode: [{
            type: Input
        }], selectionMode: [{
            type: Input
        }], enableDnD: [{
            type: Input
        }], enableFileDialog: [{
            type: Input
        }], allowedTypes: [{
            type: Input
        }], forbiddenTypes: [{
            type: Input
        }], suppressParallel: [{
            type: Input
        }], filesCount: [{
            type: Input
        }], allowDuplicates: [{
            type: Input
        }], label: [{
            type: Input
        }], showUploadFolderAlert: [{
            type: Input
        }], url: [{
            type: Input
        }], deleteUrl: [{
            type: Input
        }], icons: [{
            type: Input
        }], visibleFiles: [{
            type: Input
        }], reusable: [{
            type: Input
        }], indeterminateFileLoader: [{
            type: Input
        }], ariaDescribedBy: [{
            type: Input
        }], allowDeletion: [{
            type: Input
        }], texts: [{
            type: Input
        }], showFiles: [{
            type: Input
        }], fileErrors: [{
            type: Input
        }], droppableArea: [{
            type: Input
        }], customErrors: [{
            type: Input
        }], name: [{
            type: Input
        }], customFormControl: [{
            type: Input
        }], beforeFileDialogOpen: [{
            type: Output
        }], afterFileDialogOpen: [{
            type: Output
        }], beforeFilesAdded: [{
            type: Output
        }], afterFilesAdded: [{
            type: Output
        }], dropArea: [{
            type: Output
        }], dragOver: [{
            type: Output
        }], startFileUploading: [{
            type: Output
        }], endFileUploading: [{
            type: Output
        }], errorFileUploading: [{
            type: Output
        }], finishedFileUploading: [{
            type: Output
        }], removedFileFromQueue: [{
            type: Output
        }], deletedFile: [{
            type: Output
        }], cancelUploading: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], chunkSize: [{
            type: Input
        }], maxFileSize: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

const _c0$2 = ["fileInput"];
const _c1$2 = ["dropEnter"];
const _c2$2 = ["dnd"];
const _c3$1 = ["drop"];
const _c4 = ["droppableAreaBlock"];
function AdaptSingleUploaderComponent_ng_template_15_ng_container_5_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                ");
    i0.ɵɵelementStart(2, "div", 19);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(4, "svg", 20);
    i0.ɵɵtext(5, "\n                ");
    i0.ɵɵelement(6, "path", 21);
    i0.ɵɵtext(7, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n                  ");
    i0.ɵɵelementStart(9, "svg", 22);
    i0.ɵɵtext(10, "\n                ");
    i0.ɵɵelement(11, "path", 23);
    i0.ɵɵtext(12, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n                ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n                ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(15, "span", 24);
    i0.ɵɵtext(16);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r16 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(16);
    i0.ɵɵtextInterpolate(ctx_r16.texts.dragAndDrop);
} }
function AdaptSingleUploaderComponent_ng_template_15_ng_container_5_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                ");
    i0.ɵɵelementStart(2, "div", 25);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(4, "svg", 26);
    i0.ɵɵtext(5, "\n                        ");
    i0.ɵɵelement(6, "path", 27);
    i0.ɵɵtext(7, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n                ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n                ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(10, "span", 28);
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(11);
    i0.ɵɵtextInterpolate(ctx_r17.texts.uploadFilesLimit);
} }
function AdaptSingleUploaderComponent_ng_template_15_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "div", 17, 18);
    i0.ɵɵtext(4, "\n              ");
    i0.ɵɵtemplate(5, AdaptSingleUploaderComponent_ng_template_15_ng_container_5_ng_container_5_Template, 18, 1, "ng-container", 9);
    i0.ɵɵtext(6, "\n\n              ");
    i0.ɵɵtemplate(7, AdaptSingleUploaderComponent_ng_template_15_ng_container_5_ng_container_7_Template, 13, 1, "ng-container", 9);
    i0.ɵɵtext(8, "\n\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r14 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", !ctx_r14.isUploadLimitExceed);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r14.isUploadLimitExceed);
} }
function AdaptSingleUploaderComponent_ng_template_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelementStart(1, "div", 15);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵelementContainer(3, 16);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵtemplate(5, AdaptSingleUploaderComponent_ng_template_15_ng_container_5_Template, 10, 2, "ng-container", 9);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n      ");
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    const _r10 = i0.ɵɵreference(37);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngTemplateOutlet", _r10);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.enableDnD);
} }
function AdaptSingleUploaderComponent_ng_container_18_adapt_uploader_item_2_Template(rf, ctx) { if (rf & 1) {
    const _r22 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-uploader-item", 30);
    i0.ɵɵlistener("afterFileRemove", function AdaptSingleUploaderComponent_ng_container_18_adapt_uploader_item_2_Template_adapt_uploader_item_afterFileRemove_0_listener($event) { i0.ɵɵrestoreView(_r22); const ctx_r21 = i0.ɵɵnextContext(2); return ctx_r21.removedFromQueue($event); })("fileDeleted", function AdaptSingleUploaderComponent_ng_container_18_adapt_uploader_item_2_Template_adapt_uploader_item_fileDeleted_0_listener($event) { i0.ɵɵrestoreView(_r22); const ctx_r23 = i0.ɵɵnextContext(2); return ctx_r23.fileDeleted($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r19 = ctx.$implicit;
    const id_r20 = ctx.index;
    const ctx_r18 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("disabled", ctx_r18.disabled)("readonly", ctx_r18.readonly)("url", ctx_r18.url)("deleteUrl", ctx_r18.deleteUrl)("chunkSize", ctx_r18.chunkSize)("customErrors", ctx_r18.customErrors)("file", file_r19)("id", id_r20)("texts", ctx_r18.texts)("componentAnimation", false);
} }
function AdaptSingleUploaderComponent_ng_container_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptSingleUploaderComponent_ng_container_18_adapt_uploader_item_2_Template, 1, 10, "adapt-uploader-item", 29);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r5.files);
} }
function AdaptSingleUploaderComponent_ng_container_20_ng_template_2_Template(rf, ctx) { }
function AdaptSingleUploaderComponent_ng_container_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptSingleUploaderComponent_ng_container_20_ng_template_2_Template, 0, 0, "ng-template", 16);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    const _r12 = i0.ɵɵreference(40);
    const _r3 = i0.ɵɵreference(16);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r6.readonly ? _r12 : _r3);
} }
function AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "div", 34);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r29 = i0.ɵɵreference(4);
    const ctx_r28 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptPopover", _r29)("adaptRadarDisableEventSending", true)("placement", "auto")("maxWidth", 600);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n              ", ctx_r28.texts.remainingFilesListLabel, "\n            ");
} }
function AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_ng_template_3_ng_template_1_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r35 = i0.ɵɵnextContext(5);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r35.texts.comma, " ");
} }
function AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_ng_template_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n              ");
    i0.ɵɵelementStart(1, "span", 36);
    i0.ɵɵtext(2);
    i0.ɵɵtemplate(3, AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_ng_template_3_ng_template_1_span_3_Template, 2, 1, "span", 9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n            ");
} if (rf & 2) {
    const file_r32 = ctx.$implicit;
    const last_r34 = ctx.last;
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(file_r32.name);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", !last_r34);
} }
function AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n            ");
    i0.ɵɵtemplate(1, AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_ng_template_3_ng_template_1_Template, 5, 2, "ng-template", 35);
    i0.ɵɵtext(2, "\n          ");
} if (rf & 2) {
    const msg_r25 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", msg_r25.files);
} }
function AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0);
    i0.ɵɵtemplate(1, AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_ng_container_1_Template, 5, 5, "ng-container", 9);
    i0.ɵɵtext(2, "\n\n          ");
    i0.ɵɵtemplate(3, AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_ng_template_3_Template, 3, 1, "ng-template", null, 33, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n        ");
} if (rf & 2) {
    const msg_r25 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵtextInterpolate1("\n          ", msg_r25.text, "\n          ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", msg_r25.files && msg_r25.files.length);
} }
const _c5 = function (a0, a1, a3) { return { title: a0, content: a1, type: "inline", variant: a3, icon: false }; };
function AdaptSingleUploaderComponent_adapt_alert_26_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-alert", 31);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptSingleUploaderComponent_adapt_alert_26_ng_template_2_Template, 6, 2, "ng-template", null, 32, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const msg_r25 = ctx.$implicit;
    const _r26 = i0.ɵɵreference(3);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("config", i0.ɵɵpureFunction3(2, _c5, msg_r25.title ? msg_r25.title : "", _r26, msg_r25.variant));
} }
const _c6 = function (a0, a1) { return { title: a0, content: a1, type: "inline", variant: "danger", icon: false }; };
function AdaptSingleUploaderComponent_ng_container_28_adapt_alert_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-alert", 31);
} if (rf & 2) {
    const error_r39 = ctx.$implicit;
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("config", i0.ɵɵpureFunction2(2, _c6, error_r39.name, error_r39.text));
} }
function AdaptSingleUploaderComponent_ng_container_28_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptSingleUploaderComponent_ng_container_28_adapt_alert_2_Template, 1, 5, "adapt-alert", 11);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r8.context.errors);
} }
function AdaptSingleUploaderComponent_div_32_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 42);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "p", 40);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelement(5, "span", 41);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementStart(7, "p", 40);
    i0.ɵɵtext(8);
    i0.ɵɵpipe(9, "fileTypes");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r40 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r40.texts.allowedTypes);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind2(9, 2, ctx_r40.allowedTypes, ctx_r40.texts.fileTypesDivider));
} }
function AdaptSingleUploaderComponent_div_32_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 37);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptSingleUploaderComponent_div_32_div_2_Template, 11, 5, "div", 38);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementStart(4, "div", 39);
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵelementStart(6, "p", 40);
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n        ");
    i0.ɵɵelement(9, "span", 41);
    i0.ɵɵtext(10, "\n        ");
    i0.ɵɵelementStart(11, "p", 40);
    i0.ɵɵtext(12);
    i0.ɵɵpipe(13, "fileSize");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r9.allowedTypes.length);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r9.texts.maxFileSize);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(13, 3, ctx_r9.maxFileSize));
} }
function AdaptSingleUploaderComponent_ng_template_36_span_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 24);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r42 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r42.texts.fileMode, "\n          ");
} }
const _c7 = function (a0, a1, a2, a3) { return { leftStart: a0, rightStart: a1, leftEnd: a2, rightEnd: a3 }; };
const _c8 = function (a0) { return { params: a0 }; };
function AdaptSingleUploaderComponent_ng_template_36_Template(rf, ctx) { if (rf & 1) {
    const _r44 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 43, 44);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementStart(4, "button", 45);
    i0.ɵɵlistener("click", function AdaptSingleUploaderComponent_ng_template_36_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r44); const ctx_r43 = i0.ɵɵnextContext(); return ctx_r43.openFileDialog(); });
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelement(6, "span", 46);
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n\n    ");
    i0.ɵɵtemplate(9, AdaptSingleUploaderComponent_ng_template_36_span_9_Template, 2, 1, "span", 47);
    i0.ɵɵtext(10, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n");
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("@uploaderInitStateAnim", i0.ɵɵpureFunction1(11, _c8, i0.ɵɵpureFunction4(6, _c7, ctx_r11.isRtl ? "auto" : "15%", ctx_r11.isRtl ? "15%" : "auto", ctx_r11.isRtl ? "auto" : "0px", ctx_r11.isRtl ? "0px" : "auto")));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("disabled", ctx_r11.disabled);
    i0.ɵɵattribute("aria-label", ctx_r11.texts.fileBtn);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r11.texts.fileBtn, "\n    ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r11.enableDnD);
} }
function AdaptSingleUploaderComponent_ng_template_39_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "adapt-empty-state", 48);
    i0.ɵɵtext(2, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n");
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("type", "objects")("adaptRadarDisableEventSending", true)("label", ctx_r13.texts.notFound);
} }
let count = 0;
class AdaptSingleUploaderComponent extends FormComponent {
    constructor(fileManager, iconManager, _renderer, _elRef, _dir, _animationBuilder, _injector, ts, _adaptRadarService) {
        super(_injector, ts, _adaptRadarService, _elRef, AdaptRadarAngularCustomEventName.AdaptSingleUploader);
        this.fileManager = fileManager;
        this.iconManager = iconManager;
        this._renderer = _renderer;
        this._elRef = _elRef;
        this._dir = _dir;
        this._animationBuilder = _animationBuilder;
        this._injector = _injector;
        this._adaptRadarService = _adaptRadarService;
        /* text configurations */
        this.uploaderTextsDefault = {
            fileStatus: {}
        };
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * Unique id of the element.
         */
        this.id = `adapt-single-uploader-${count}`;
        this.mode = UploaderMode.Manual;
        this.enableDnD = true;
        this.allowedTypes = [];
        this.forbiddenTypes = [];
        this.icons = {};
        this.allowDeletion = true;
        this.customErrors = false;
        this.allowDrop = false;
        /* uploader outputs */
        this.beforeFileDialogOpen = new EventEmitter();
        this.afterFileDialogOpen = new EventEmitter();
        this.beforeFileAdded = new EventEmitter();
        this.afterFileAdded = new EventEmitter();
        this.startFileUploading = new EventEmitter();
        this.endFileUploading = new EventEmitter();
        this.errorFileUploading = new EventEmitter();
        this.finishedFileUploading = new EventEmitter();
        this.removedFileFromQueue = new EventEmitter();
        this.deletedFile = new EventEmitter();
        this.cancelUploading = new EventEmitter();
        /**
         * Event on ngModel change
         */
        this.valueChange = new EventEmitter();
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any, @angular-eslint/no-output-native */
        this.focus = new EventEmitter();
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any, @angular-eslint/no-output-native */
        this.blur = new EventEmitter();
        // Need for using inherited properties in the template
        this.context = this;
        this.statusMessages = [];
        this.allowDuplicates = false;
        this.filesCount = 1;
        this.suppressParallel = false;
        this.isDragOverMask = false;
        this.isRtl = false;
        this.isUploadLimitExceed = false;
        // we'll get a drop enter for the child and then a drop leave for the target!
        this._droppable = 0;
        this._animationPlayers = {
            visibleDnd: null,
            hiddenDnd: null,
            visibleDrop: null,
            hiddenDrop: null
        };
        this._isTouched = false;
        this._chunkSize = FileSize.MB;
        this._destroyed$ = new ReplaySubject(1);
        this._maxFileSize = FileSize.MB * 20;
        this._onTouchedCallback = () => {
            return;
        };
        this.isRtl = this._dir.value === 'rtl';
        count++;
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    get chunkSize() {
        return isNil(this._chunkSize) ? this._chunkSize : this._chunkSize.toString();
    }
    set chunkSize(value) {
        this._chunkSize = isNil(value) ? value : retrieveFileSize(value);
    }
    get maxFileSize() {
        return this._maxFileSize.toString();
    }
    set maxFileSize(value) {
        this._maxFileSize = retrieveFileSize(value);
    }
    get files() {
        return this.fileManager.getFiles();
    }
    get hostClasses() {
        return [
            this.mainCls,
            'adapt-single-uploader',
            this.enableDnD ? '' : 'is-no-dnd',
            this.isErrorExist ? 'has-danger' : '',
            this.isWarningExist ? 'has-warning' : '',
            this.disabled ? 'disabled' : '',
            this.suppressIcons ? 'prevent-success-icon' : ''
        ].join(' ');
    }
    get isErrorExist() {
        return this.required && !this.files.length && (this.customFormControl ? this.control.touched : this._isTouched);
    }
    get isWarningExist() {
        return !!this.statusMessages.length && this.statusMessages.some(message => message.variant === MessageStatus.Warning);
    }
    set value(v) {
        this._value = v;
    }
    get value() {
        return this._value;
    }
    ngOnInit() {
        // Sending radar event directly to avoid issues with the premature invocation of "initControl" in parent ngOnInit()
        // ERROR NullInjectorError: R3InjectorError(AppModule)[NgControl -> NgControl -> NgControl]:
        // So do not call super.ngOnInit() here
        // TODO ?
        this._adaptRadarService.sendGenericComponentEvent(AdaptRadarAngularCustomEventName.AdaptSingleUploader);
        if (this.customFormControl) {
            this.initControl();
        }
        this.texts = Object.assign(Object.assign({}, this.uploaderTextsDefault), this.texts);
        this.initFileErrors();
        this._customErrorTexts = Object.assign({ required: {
                name: '',
                text: this.texts.required
            } }, this._customErrorTexts);
        this.iconManager.init(this.icons);
        this.fileManager.messagesSubject
            .pipe(takeUntil(this._destroyed$))
            .subscribe((msg) => {
            this.statusMessages.push(msg);
        });
        this.fileManager.uploadingStartSubject.pipe(takeUntil(this._destroyed$)).subscribe(({ file }) => {
            const fileEvent = Object.assign(Object.assign({}, file), { 
                // Perhaps always id === 1, because it is the first chunk or file,
                // but just in case this algorithm
                id: this.fileManager.getFileRequestId(this.fileManager.getChunkStart(INITIAL_CHUNK_NUMBER, this._chunkSize), this._chunkSize) });
            this.startFileUploading.emit(fileEvent);
        });
        this.fileManager.uploadedSubject.pipe(takeUntil(this._destroyed$)).subscribe((file) => {
            this.endFileUploading.emit(file);
        });
        this.fileManager.canceledSubject.pipe(takeUntil(this._destroyed$)).subscribe((files) => {
            this.cancelUploading.emit(files);
        });
        this.fileManager.errorUploadingSubject.pipe(takeUntil(this._destroyed$))
            .subscribe((data) => {
            this.errorFileUploading.emit(data);
        });
        this.fileManager.uploadingFinishedSubject.pipe(takeUntil(this._destroyed$)).subscribe((files) => {
            this.finishedFileUploading.emit(files);
        });
        this._updateStorageWithUploadedFile();
        for (const prop in this._customErrorTexts) {
            if (prop) {
                this.overrideBuildInValidatorMessage(prop, () => this._customErrorTexts[prop]);
            }
        }
        if (this.tooltipIconCls && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIconCls,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    setDefaultTexts(translation) {
        this.uploaderTextsDefault.fileBtn = translation['adapt.uploaderSingle.attachFiles'];
        this.uploaderTextsDefault.allowedTypes = translation['adapt.uploader.allowedTypes'];
        this.uploaderTextsDefault.fileTypesDivider = translation['adapt.uploader.fileTypesDivider'];
        this.uploaderTextsDefault.maxFileSize = translation['adapt.uploader.maxFileSize'];
        this.uploaderTextsDefault.fileMode = translation['adapt.uploaderSingle.fileMode'];
        this.uploaderTextsDefault.dragAndDrop = translation['adapt.uploaderSingle.dragAndDrop'];
        this.uploaderTextsDefault.uploadFilesLimit = translation['adapt.uploaderSingle.uploadFilesLimit'];
        this.uploaderTextsDefault.required = translation['adapt.uploader.required'];
        this.uploaderTextsDefault.btnCancelUploading = translation['adapt.uploader.cancelUploading'];
        this.uploaderTextsDefault.btnRemoveFile = translation['adapt.uploader.removeFile'];
        this.uploaderTextsDefault.btnDeleteFile = translation['adapt.uploader.deleteFile'];
        this.uploaderTextsDefault.btnRemoveCanceled = translation['adapt.uploader.removeCanceled'];
        this.uploaderTextsDefault.btnDownloadFile = translation['adapt.uploader.downloadFile'];
        this.uploaderTextsDefault.fileStatus.canceled = translation['adapt.uploader.fileStatus.canceled'];
        this.uploaderTextsDefault.fileStatus.uploaded = translation['adapt.uploader.fileStatus.uploaded'];
        this.uploaderTextsDefault.fileStatus.uploading = translation['adapt.uploader.fileStatus.uploading'];
        this.uploaderTextsDefault.remainingFilesListLabel = translation['adapt.uploader.remainingFilesListLabel'];
        this.uploaderTextsDefault.notFound = translation['adapt.uploader.notFound'];
        this.uploaderTextsDefault.comma = translation['adapt.common.comma'];
    }
    writeValue(value) {
        if (value) {
            this.fileManager.updateFilesStorage([value]);
            this.clearWarningMessages();
        }
        else {
            this.fileManager.resetFilesStorage();
        }
        this._propagateChanges();
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    validate() {
        return null;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (!this.droppableArea) {
            this.droppableArea = this.droppableAreaBlock.nativeElement;
        }
        if (this.enableDnD) {
            this.addDragEvents();
        }
        fromEvent(this.fileInput.nativeElement, 'change')
            .pipe(takeUntil(this._destroyed$))
            .subscribe((e) => {
            this.onChangeFileInput(e);
            this._markComponentTouched();
            this._componentEmptyState();
        });
    }
    ngOnChanges(changes) {
        if (changes.texts && !isUndefined$1(changes.texts.previousValue)) {
            this.texts = Object.assign(Object.assign({}, this.uploaderTextsDefault), this.texts);
        }
        if (changes.fileErrors && !isUndefined$1(changes.fileErrors.previousValue)) {
            this.initFileErrors();
        }
    }
    onChangeFileInput(event) {
        let files = [];
        // since we call onChangeFileInput method on both
        // input.onchange and dragDrop
        // we should first check the event.type to
        // correctly handle the files derivation
        if (event.type === 'drop') {
            // event comes from the dragDrop operation
            files = toArray$1(event.dataTransfer.files);
        }
        if (event.type === 'change') {
            // event comes from input.onchange
            files = toArray$1(event.target.files);
        }
        if (files.length) {
            this.addFiles(files);
        }
        if (this.files.length) {
            this._renderer.addClass(this._elRef.nativeElement, 'dropped');
        }
    }
    initFileErrors() {
        if (this.fileErrors) {
            this.fileManager.fileErrors = Object.assign(Object.assign({}, this.fileManager.fileErrors), this.fileErrors);
            Object.keys(this.fileManager.fileErrors).forEach((key) => this.fileManager.messages[key] = {
                errorMessage: '',
                files: []
            });
        }
    }
    addDragEvents() {
        this._onDragEnter = this.ondragEnter.bind(this);
        this.droppableArea.addEventListener('dragenter', this._onDragEnter);
        this._onDragOver = this.ondragOver.bind(this);
        this.droppableArea.addEventListener('dragover', this._onDragOver);
        this._onDragLeave = this.ondragLeave.bind(this);
        this.droppableArea.addEventListener('dragleave', this._onDragLeave);
        this._onDragDrop = this.ondragDrop.bind(this);
        this.droppableArea.addEventListener('drop', this._onDragDrop);
        document.addEventListener('dragover', this._preventDefault);
        document.addEventListener('drop', this._preventDefault);
    }
    removedFromQueue(file) {
        this._renderer.removeClass(this._elRef.nativeElement, 'dropped');
        if (!file.canceled) {
            this.removedFileFromQueue.emit(file);
        }
        this._markComponentTouched();
        this._propagateChanges();
        this._componentEmptyState();
    }
    fileDeleted(file) {
        this._renderer.removeClass(this._elRef.nativeElement, 'dropped');
        this.deletedFile.emit(file);
        this._markComponentTouched();
        this._propagateChanges();
        this._componentEmptyState();
    }
    ondragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.disabled || this.readonly || this._droppable || !this.dataHasFiles(e) || this.files.length) {
            return;
        }
        this.isDragOverMask = true;
        // check if the upload files limit exceeded
        // event.dataTransfer.items is not available in Internet Explorer and Safari
        // Mime types or number of dragged files can therefore not be determined in drag events, only on drop
        // so we explicitly set the value to 0
        const dndFilesCount = e.dataTransfer.items ? e.dataTransfer.items.length : 0;
        this.isUploadLimitExceed = dndFilesCount > this.filesCount;
        this._renderer.addClass(this.droppableArea, 'adapt-drop-wrp');
        this._renderer.addClass(this.dropEnter.nativeElement, 'pointer-events');
        this._droppable++;
        this._createAnimationPlayers();
        this._animateDndChange();
    }
    ondragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.disabled || this.readonly || this.isUploadLimitExceed) {
            e.dataTransfer.dropEffect = 'none';
        }
    }
    ondragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        if (e.target !== this.droppableArea) {
            return;
        }
        this._droppable--;
        if (!this._droppable) {
            this.isDragOverMask = false;
            this._animateDndChange();
            this._renderer.removeClass(this.dropEnter.nativeElement, 'pointer-events');
            this._renderer.removeClass(this.droppableArea, 'adapt-drop-wrp');
            this._markComponentTouched();
            this._componentEmptyState();
        }
    }
    ondragDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        this.clearWarningMessages();
        if (isUndefined$1(this.fileInput.nativeElement.webkitdirectory)) {
            const files = toArray$1(e.dataTransfer.files);
            if (files.length) {
                this.addFiles(files);
            }
            if (this.files.length) {
                this._renderer.addClass(this._elRef.nativeElement, 'dropped');
            }
        }
        else {
            const items = toArray$1(e.dataTransfer.items);
            const isDirectoryDropped = items.some((item) => {
                const itemEntry = item.webkitGetAsEntry();
                return itemEntry.isDirectory;
            });
            if (isDirectoryDropped) {
                // check if folderSuppress error is already added to the statusMessages array
                const messageIndex = this.statusMessages
                    .map(message => message.text)
                    .indexOf(this.fileManager.fileErrors.folderSuppress);
                if (messageIndex === -1) {
                    this.statusMessages.push({ text: this.fileManager.fileErrors.folderSuppress, variant: MessageStatus.Warning });
                }
            }
            else {
                this.onChangeFileInput(e);
            }
        }
        this._markComponentTouched();
        this._componentEmptyState();
        this.isDragOverMask = false;
        this._droppable = 0;
        this._renderer.removeClass(this.droppableArea, 'adapt-drop-wrp');
        this._renderer.removeClass(this.dropEnter.nativeElement, 'pointer-events');
        this._animateDndChange();
    }
    /**
     * Opens file dialog window for file selection, fires appropriate events
     */
    openFileDialog() {
        this.beforeFileDialogOpen.emit(null);
        this.fileInput.nativeElement.click();
        this.afterFileDialogOpen.emit(null);
    }
    startUploading() {
        if (this.readonly || this.disabled) {
            return;
        }
        this._markComponentTouched();
        if (this.isErrorExist) {
            if (!this.customFormControl) {
                // check if required error is already added to the statusMessages array
                const messageIndex = this.statusMessages
                    .map(message => message.text)
                    .indexOf(this.texts.required);
                if (messageIndex === -1) {
                    this.statusMessages.push({ text: this.texts.required, variant: MessageStatus.Danger });
                }
            }
            return;
        }
        const uploadInputs = {
            chunkSize: this._chunkSize,
            uploadUrl: this.url,
            customErrors: this.customErrors
        };
        this.fileManager.startUploading(uploadInputs);
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (!this.disabled && this.enableDnD) {
            this.isDragOverMask = false;
            this.droppableArea.removeEventListener('dragenter', this._onDragEnter);
            this.droppableArea.removeEventListener('dragover', this._onDragOver);
            this.droppableArea.removeEventListener('dragleave', this._onDragLeave);
            this.droppableArea.removeEventListener('drop', this._onDragDrop);
            document.removeEventListener('dragover', this._preventDefault);
            document.removeEventListener('drop', this._preventDefault);
        }
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    clearWarningMessages() {
        this.statusMessages = [];
    }
    /**
     * Adds files to uploader service
     */
    addFiles(files) {
        if (this.files.length) {
            return;
        }
        this.clearWarningMessages();
        this.beforeFileAdded.emit(files);
        this.fileManager.addFiles(files, this.allowDeletion, this.mode, this.suppressParallel, this.allowDuplicates, this._maxFileSize, this._chunkSize, this.allowedTypes, this.forbiddenTypes, this.filesCount, this.customErrors, this.url);
        this.afterFileAdded.emit(files);
        this._propagateChanges();
        // uncomment selection - we need to clear input element, so input change event would fire
        // for the IE we have validation for the files array length
        this.fileInput.nativeElement.value = '';
    }
    _updateStorageWithUploadedFile() {
        if (this.showFile) {
            this.fileManager.updateFilesStorage([this.showFile]);
            this._renderer.addClass(this._elRef.nativeElement, 'dropped');
        }
    }
    dataHasFiles(e) {
        const types = Array.prototype.slice.call(e.dataTransfer.types);
        return types.indexOf('Files') !== -1;
    }
    _preventDefault(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    _animateDndChange() {
        this._animationPlayers.hiddenDnd.reset();
        this._animationPlayers.visibleDnd.reset();
        this._animationPlayers.hiddenDrop.reset();
        this._animationPlayers.visibleDrop.reset();
        const currentPlayerDnd = this.isDragOverMask ? this._animationPlayers.hiddenDnd : this._animationPlayers.visibleDnd;
        const currentPlayerDrop = this.isDragOverMask ? this._animationPlayers.visibleDrop : this._animationPlayers.hiddenDrop;
        currentPlayerDnd.play();
        currentPlayerDrop.play();
        currentPlayerDnd.onDone(() => {
            if (!this._droppable) {
                this.isUploadLimitExceed = false;
            }
        });
    }
    _createAnimationPlayers() {
        const players = Object.keys(this._animationPlayers);
        players.forEach((player) => {
            if (this._animationPlayers[player]) {
                this._animationPlayers[player].destroy();
            }
        });
        this._animationPlayers.hiddenDnd = this._animationBuilder.build(ANIMATION_DND.hidden[this._dir.value])
            .create(this.dnd.nativeElement);
        this._animationPlayers.visibleDnd = this._animationBuilder.build(ANIMATION_DND.visible[this._dir.value])
            .create(this.dnd.nativeElement);
        this._animationPlayers.hiddenDrop = this._animationBuilder.build(ANIMATION_DROP.hidden[this._dir.value])
            .create(this.drop.nativeElement);
        this._animationPlayers.visibleDrop = this._animationBuilder.build(ANIMATION_DROP.visible[this._dir.value])
            .create(this.drop.nativeElement);
    }
    _componentEmptyState() {
        if (this.files.length) {
            return;
        }
        if (this.isErrorExist && !this.customFormControl) {
            // check if required error is already added to the statusMessages array
            const messageIndex = this.statusMessages
                .map(message => message.text)
                .indexOf(this.texts.required);
            if (messageIndex === -1) {
                this.statusMessages.push({ text: this.texts.required, variant: MessageStatus.Danger });
            }
        }
    }
    _markComponentTouched() {
        this._isTouched = true;
        this._onTouchedCallback();
    }
    _propagateChanges() {
        this.propagateChange(this.files);
        this.valueChange.emit(this.files);
    }
}
AdaptSingleUploaderComponent.ɵfac = function AdaptSingleUploaderComponent_Factory(t) { return new (t || AdaptSingleUploaderComponent)(i0.ɵɵdirectiveInject(i1.FileManager), i0.ɵɵdirectiveInject(i1.IconManager), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2$1.Directionality), i0.ɵɵdirectiveInject(i1$1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarService)); };
AdaptSingleUploaderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSingleUploaderComponent, selectors: [["adapt-single-uploader"]], viewQuery: function AdaptSingleUploaderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$2, 5);
        i0.ɵɵviewQuery(_c1$2, 5);
        i0.ɵɵviewQuery(_c2$2, 5);
        i0.ɵɵviewQuery(_c3$1, 5);
        i0.ɵɵviewQuery(_c4, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fileInput = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dropEnter = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dnd = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.drop = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.droppableAreaBlock = _t.first);
    } }, hostVars: 3, hostBindings: function AdaptSingleUploaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵhostProperty("id", ctx.id);
        i0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { id: "id", mode: "mode", enableDnD: "enableDnD", allowedTypes: "allowedTypes", forbiddenTypes: "forbiddenTypes", label: "label", url: "url", deleteUrl: "deleteUrl", icons: "icons", allowDeletion: "allowDeletion", texts: "texts", showFile: "showFile", fileErrors: "fileErrors", customErrors: "customErrors", droppableArea: "droppableArea", allowDrop: "allowDrop", name: "name", customFormControl: "customFormControl", chunkSize: "chunkSize", maxFileSize: "maxFileSize" }, outputs: { beforeFileDialogOpen: "beforeFileDialogOpen", afterFileDialogOpen: "afterFileDialogOpen", beforeFileAdded: "beforeFileAdded", afterFileAdded: "afterFileAdded", startFileUploading: "startFileUploading", endFileUploading: "endFileUploading", errorFileUploading: "errorFileUploading", finishedFileUploading: "finishedFileUploading", removedFileFromQueue: "removedFileFromQueue", deletedFile: "deletedFile", cancelUploading: "cancelUploading", valueChange: "valueChange", focus: "focus", blur: "blur" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptSingleUploaderComponent),
            createFormControlValidator(AdaptSingleUploaderComponent),
            FileManager,
            IconManager
        ]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 42, vars: 10, consts: [["type", "file", "hidden", ""], ["fileInput", ""], [1, "adapt-single-uploader__wrp"], ["droppableAreaBlock", ""], [1, "adapt-single-uploader__content"], ["dropEnter", ""], [3, "label", "requiredLabel", "showRequiredLabel", "tooltip"], [1, "adapt-single-uploader-inner"], ["data", ""], [4, "ngIf"], [1, "adapt-single-uploader__warning-text", "mt-1"], ["class", "adapt-uploader-messages", 3, "adaptRadarDisableEventSending", "config", 4, "ngFor", "ngForOf"], ["class", "adapt-uploader-restrict", 4, "ngIf"], ["dragAndDrop", ""], ["readonlyEmpty", ""], [1, "adapt-single-uploader-dnd-animation"], [3, "ngTemplateOutlet"], [1, "adapt-uploader-drop"], ["drop", ""], [1, "adapt-uploader-drop__icon"], ["aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "45", "height", "32", "viewBox", "0 0 72 48", 0, "xml", "space", "preserve", 1, "clound-icon", 2, "enable-background", "new 0 0 72 48"], ["fill", "#D9D9D9", "d", "M72,36c0,6.63-5.37,12-12,12H12C5.37,48,0,42.63,0,36c0-5.98,4.39-10.9,10.12-11.81C9.41,22.26,9,20.18,9,18  C9,8.06,17.06,0,27,0c6.01,0,11.32,2.96,14.59,7.49C43.54,6.56,45.7,6,48,6c8.28,0,15,6.72,15,15c0,1.14-0.15,2.24-0.39,3.3  C67.98,25.5,72,30.27,72,36z", 1, "st0"], ["aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "45", "height", "32", "viewBox", "0 0 72 48", 0, "xml", "space", "preserve", 1, "arrow-icon", 2, "enable-background", "new 0 0 72 48"], ["fill", "#FBFBFB", "d", "M33,48V36H21l15-18l15,18H39v12H33z", 1, "st0"], [1, "adapt-uploader-dnd-text", "m-start-2"], [1, "adapt-uploader-drop__icon", "adapt-uploader-drop__icon-forbidden"], ["aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "45", "height", "32", "viewBox", "0 0 64 44", 0, "xml", "space", "preserve", 1, "clound-icon__forbidden", 2, "enable-background", "new 0 0 64 44"], ["fill", "#FA7A59", "d", "M54.91,21.93c0.21-0.9,0.34-1.86,0.34-2.84c0-7.13-5.79-12.92-12.92-12.92c-1.99,0-3.85,0.49-5.53,1.29\nC33.99,3.56,29.42,1,24.25,1C15.7,1,8.75,7.95,8.75,16.5c0,1.89,0.36,3.67,0.96,5.32C4.77,22.62,1,26.86,1,32\n\tc0,5.71,4.62,10.33,10.33,10.33h41.33C58.38,42.33,63,37.71,63,32C63,27.07,59.54,22.96,54.91,21.93z M41.14,33.4\n\tc-4.75,4.73-12.22,5.01-17.31,0.85c-0.34-0.26-0.67-0.54-0.98-0.85c-0.31-0.31-0.59-0.65-0.85-0.98\n\tc-4.16-5.09-3.88-12.55,0.85-17.31c4.75-4.73,12.22-5.01,17.31-0.85c0.34,0.26,0.67,0.54,0.98,0.85s0.59,0.65,0.85,0.98\n\tC46.16,21.18,45.87,28.64,41.14,33.4z M25.67,32.41c4.06,3.15,9.92,2.87,13.64-0.85c3.72-3.72,4-9.58,0.85-13.64L25.67,32.41z\n\t M24.69,16.94c-3.72,3.72-4,9.58-0.85,13.64l14.49-14.49C34.27,12.94,28.41,13.22,24.69,16.94z"], [1, "adapt-uploader-dnd-text", "adapt-uploader-dnd-text-forbidden", "m-start-2"], [3, "disabled", "readonly", "url", "deleteUrl", "chunkSize", "customErrors", "file", "id", "texts", "componentAnimation", "afterFileRemove", "fileDeleted", 4, "ngFor", "ngForOf"], [3, "disabled", "readonly", "url", "deleteUrl", "chunkSize", "customErrors", "file", "id", "texts", "componentAnimation", "afterFileRemove", "fileDeleted"], [1, "adapt-uploader-messages", 3, "adaptRadarDisableEventSending", "config"], ["errorMessageTemplate", ""], ["remainingFileListTemplate", ""], [1, "remaining-files-list", 3, "adaptPopover", "adaptRadarDisableEventSending", "placement", "maxWidth"], ["ngFor", "", 3, "ngForOf"], [1, "file-name"], [1, "adapt-uploader-restrict"], ["class", "adapt-uploader-restrict-types", 4, "ngIf"], [1, "adapt-uploader-restrict-size"], [1, "d-inline-block", "mb-0"], [1, "letter-space"], [1, "adapt-uploader-restrict-types"], [1, "adapt-uploader-dnd"], ["dnd", ""], ["type", "button", "adapt-button", "", "btn-type", "secondary", 1, "adapt-uploader-attach-btn", 3, "adaptRadarDisableEventSending", "disabled", "click"], [1, "btn-icon", "d-icon-file_o"], ["class", "adapt-uploader-dnd-text m-start-2", 4, "ngIf"], [3, "type", "adaptRadarDisableEventSending", "label"]], template: function AdaptSingleUploaderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelement(0, "input", 0, 1);
        i0.ɵɵtext(2, "\n\n");
        i0.ɵɵelementStart(3, "div", 2, 3);
        i0.ɵɵtext(5, "\n  ");
        i0.ɵɵelementStart(6, "div", 4, 5);
        i0.ɵɵtext(8, "\n\n    ");
        i0.ɵɵtext(9, "\n    ");
        i0.ɵɵelement(10, "adapt-rx-control-label", 6);
        i0.ɵɵtext(11, "\n    ");
        i0.ɵɵtext(12, "\n\n    ");
        i0.ɵɵelementStart(13, "div", 7);
        i0.ɵɵtext(14, "\n\n      ");
        i0.ɵɵtemplate(15, AdaptSingleUploaderComponent_ng_template_15_Template, 8, 2, "ng-template", null, 8, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(17, "\n\n      ");
        i0.ɵɵtemplate(18, AdaptSingleUploaderComponent_ng_container_18_Template, 4, 1, "ng-container", 9);
        i0.ɵɵtext(19, "\n\n      ");
        i0.ɵɵtemplate(20, AdaptSingleUploaderComponent_ng_container_20_Template, 4, 1, "ng-container", 9);
        i0.ɵɵtext(21, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n\n    ");
        i0.ɵɵelementStart(23, "div", 10);
        i0.ɵɵtext(24, "\n      ");
        i0.ɵɵtext(25, "\n      ");
        i0.ɵɵtemplate(26, AdaptSingleUploaderComponent_adapt_alert_26_Template, 5, 6, "adapt-alert", 11);
        i0.ɵɵtext(27, "\n\n      ");
        i0.ɵɵtemplate(28, AdaptSingleUploaderComponent_ng_container_28_Template, 4, 1, "ng-container", 9);
        i0.ɵɵtext(29, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(30, "\n\n    ");
        i0.ɵɵtext(31, "\n    ");
        i0.ɵɵtemplate(32, AdaptSingleUploaderComponent_div_32_Template, 16, 5, "div", 12);
        i0.ɵɵtext(33, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(34, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(35, "\n\n");
        i0.ɵɵtemplate(36, AdaptSingleUploaderComponent_ng_template_36_Template, 12, 13, "ng-template", null, 13, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(38, "\n\n");
        i0.ɵɵtemplate(39, AdaptSingleUploaderComponent_ng_template_39_Template, 4, 3, "ng-template", null, 14, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(41, "\n\n\n");
    } if (rf & 2) {
        i0.ɵɵattribute("aria-label", "File Control");
        i0.ɵɵadvance(10);
        i0.ɵɵproperty("label", ctx.label)("requiredLabel", ctx.context.requiredLabel)("showRequiredLabel", ctx.context.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(8);
        i0.ɵɵproperty("ngIf", !!ctx.files.length);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.files.length);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngForOf", ctx.statusMessages);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.customFormControl && ctx.context.errors && ctx.context.errors.length && ctx.context.control.touched);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", !ctx.readonly);
    } }, directives: [i1.AdaptRxControlLabelComponent, i3.NgIf, i3.NgForOf, i3.NgTemplateOutlet, i1.AdaptUploaderItemComponent, i1.AdaptAlertComponent, i1.AdaptPopoverDirective, i1.AdaptButtonComponent, i1.AdaptEmptyStateComponent], pipes: [i1.FileSizePipe, i1.FileTypesPipe], styles: ["adapt-uploader-item[_ngcontent-%COMP%] {\n      padding: 13px 0 !important;\n    }"], data: { animation: [ANIMATION_INIT_STATE] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSingleUploaderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-single-uploader',
                templateUrl: './single-uploader.component.html',
                animations: [ANIMATION_INIT_STATE],
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[id]': 'id'
                },
                styles: [`
    adapt-uploader-item {
      padding: 13px 0 !important;
    }
  `],
                providers: [
                    createFormControlValueAccessor(AdaptSingleUploaderComponent),
                    createFormControlValidator(AdaptSingleUploaderComponent),
                    FileManager,
                    IconManager
                ]
            }]
    }], function () { return [{ type: i1.FileManager }, { type: i1.IconManager }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i2$1.Directionality }, { type: i1$1.AnimationBuilder }, { type: i0.Injector }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarService }]; }, { fileInput: [{
            type: ViewChild,
            args: ['fileInput']
        }], dropEnter: [{
            type: ViewChild,
            args: ['dropEnter']
        }], dnd: [{
            type: ViewChild,
            args: ['dnd']
        }], drop: [{
            type: ViewChild,
            args: ['drop']
        }], droppableAreaBlock: [{
            type: ViewChild,
            args: ['droppableAreaBlock']
        }], id: [{
            type: Input
        }], mode: [{
            type: Input
        }], enableDnD: [{
            type: Input
        }], allowedTypes: [{
            type: Input
        }], forbiddenTypes: [{
            type: Input
        }], label: [{
            type: Input
        }], url: [{
            type: Input
        }], deleteUrl: [{
            type: Input
        }], icons: [{
            type: Input
        }], allowDeletion: [{
            type: Input
        }], texts: [{
            type: Input
        }], showFile: [{
            type: Input
        }], fileErrors: [{
            type: Input
        }], customErrors: [{
            type: Input
        }], droppableArea: [{
            type: Input
        }], allowDrop: [{
            type: Input
        }], name: [{
            type: Input
        }], customFormControl: [{
            type: Input
        }], beforeFileDialogOpen: [{
            type: Output
        }], afterFileDialogOpen: [{
            type: Output
        }], beforeFileAdded: [{
            type: Output
        }], afterFileAdded: [{
            type: Output
        }], startFileUploading: [{
            type: Output
        }], endFileUploading: [{
            type: Output
        }], errorFileUploading: [{
            type: Output
        }], finishedFileUploading: [{
            type: Output
        }], removedFileFromQueue: [{
            type: Output
        }], deletedFile: [{
            type: Output
        }], cancelUploading: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], chunkSize: [{
            type: Input
        }], maxFileSize: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

class AdaptUploadModule {
    static forRoot(config) {
        return {
            ngModule: AdaptUploadModule,
            providers: [
                (config && config.uploader) ? config.uploader : { provide: 'UploaderService', useClass: SendFileService },
                { provide: SendFileService, useClass: SendFileService }
            ]
        };
    }
}
AdaptUploadModule.ɵfac = function AdaptUploadModule_Factory(t) { return new (t || AdaptUploadModule)(); };
AdaptUploadModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptUploadModule });
AdaptUploadModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            AdaptButtonModule,
            AdaptAlertModule.forRoot(),
            AdaptCollapseModule,
            AdaptTooltipModule,
            AdaptPopoverModule.forRoot(),
            AdaptIconModule,
            AdaptBusyModule,
            AdaptTruncateFileNameModule,
            AdaptUploadItemModule,
            AdaptFileSizePipeModule,
            AdaptFileTypesPipeModule,
            AdaptEmptyStateModule,
            AdaptRxLabelModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptUploadModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AdaptButtonModule,
                    AdaptAlertModule.forRoot(),
                    AdaptCollapseModule,
                    AdaptTooltipModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptIconModule,
                    AdaptBusyModule,
                    AdaptTruncateFileNameModule,
                    AdaptUploadItemModule,
                    AdaptFileSizePipeModule,
                    AdaptFileTypesPipeModule,
                    AdaptEmptyStateModule,
                    AdaptRxLabelModule
                ],
                declarations: [
                    AdaptUploaderComponent,
                    AdaptSingleUploaderComponent
                ],
                exports: [AdaptUploaderComponent, AdaptSingleUploaderComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptUploadModule, { declarations: [AdaptUploaderComponent,
        AdaptSingleUploaderComponent], imports: [CommonModule,
        FormsModule,
        AdaptButtonModule, i1.AdaptAlertModule, AdaptCollapseModule,
        AdaptTooltipModule, i1.AdaptPopoverModule, AdaptIconModule,
        AdaptBusyModule,
        AdaptTruncateFileNameModule,
        AdaptUploadItemModule,
        AdaptFileSizePipeModule,
        AdaptFileTypesPipeModule,
        AdaptEmptyStateModule,
        AdaptRxLabelModule], exports: [AdaptUploaderComponent, AdaptSingleUploaderComponent] }); })();

// TODO update types
const _c0$1 = ["input"];
const _c1$1 = ["inputTextWidthEl"];
function AdaptTextFieldFormBuilderComponent_adapt_textfield_icons_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-textfield-icons", 11);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("error", ctx_r0.control.invalid)("success", !ctx_r0.control.invalid)("iconValid", ctx_r0.iconValid && ctx_r0.validState)("iconInvalid", ctx_r0.iconInvalid);
} }
function AdaptTextFieldFormBuilderComponent_textarea_11_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "textarea", 12);
    i0.ɵɵlistener("focus", function AdaptTextFieldFormBuilderComponent_textarea_11_Template_textarea_focus_0_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(); return ctx_r7.onFocus($event); })("blur", function AdaptTextFieldFormBuilderComponent_textarea_11_Template_textarea_blur_0_listener($event) { i0.ɵɵrestoreView(_r8); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.onBlur($event); });
    i0.ɵɵtext(1, "  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r1.customClass, "");
    i0.ɵɵclassProp("form-control-disabled-look", ctx_r1.readonly && ctx_r1.disabledStyleForReadonlyState);
    i0.ɵɵproperty("rows", ctx_r1.rows)("formControl", ctx_r1.control)("required", ctx_r1.required)("autofocus", ctx_r1.autofocus)("readonly", ctx_r1.readonly)("placeholder", ctx_r1.placeholder ? ctx_r1.placeholder : "");
    i0.ɵɵattribute("name", ctx_r1.name)("id", ctx_r1.id)("maxlength", ctx_r1.maxlength)("minlength", ctx_r1.minlength)("tabindex", ctx_r1.tabindex)("aria-label", ctx_r1.ariaLabel)("aria-labelledby", ctx_r1.ariaLabelledby)("aria-describedby", ctx_r1.ariaDescribedBy);
} }
function AdaptTextFieldFormBuilderComponent_input_13_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "input", 13, 14);
    i0.ɵɵlistener("keyup", function AdaptTextFieldFormBuilderComponent_input_13_Template_input_keyup_0_listener() { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.onKeyup(); })("focus", function AdaptTextFieldFormBuilderComponent_input_13_Template_input_focus_0_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.onFocus($event); })("blur", function AdaptTextFieldFormBuilderComponent_input_13_Template_input_blur_0_listener($event) { i0.ɵɵrestoreView(_r12); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.onBlur($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r2.customClass, "");
    i0.ɵɵclassProp("textfield-padding-transition", ctx_r2.overflowText)("pl-0", ctx_r2.isTextOverflow && !ctx_r2.isRtl)("pr-0", ctx_r2.isTextOverflow && ctx_r2.isRtl)("form-control-disabled-look", ctx_r2.readonly && ctx_r2.disabledStyleForReadonlyState);
    i0.ɵɵproperty("formControl", ctx_r2.control)("type", ctx_r2.type)("required", ctx_r2.required)("autofocus", ctx_r2.autofocus)("readonly", ctx_r2.readonly)("autocomplete", ctx_r2.autocomplete ? ctx_r2.autocomplete : "on")("placeholder", ctx_r2.placeholder ? ctx_r2.placeholder : "");
    i0.ɵɵattribute("name", ctx_r2.name)("id", ctx_r2.id)("maxlength", ctx_r2.maxlength)("minlength", ctx_r2.minlength)("min", ctx_r2.min)("max", ctx_r2.max)("step", ctx_r2.step)("tabindex", ctx_r2.tabindex)("aria-label", ctx_r2.ariaLabel)("aria-labelledby", ctx_r2.ariaLabelledby)("aria-describedby", ctx_r2.ariaDescribedBy);
} }
function AdaptTextFieldFormBuilderComponent_div_15_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 18);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r15 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r15.nestedSettings.addOnTextLeft);
} }
function AdaptTextFieldFormBuilderComponent_div_15_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 20);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r17 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("z-index", "34");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r17.nestedSettings.addOnTextRight);
} }
function AdaptTextFieldFormBuilderComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    const _r19 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptTextFieldFormBuilderComponent_div_15_div_2_Template, 5, 1, "div", 16);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementStart(4, "input", 13, 14);
    i0.ɵɵlistener("keyup", function AdaptTextFieldFormBuilderComponent_div_15_Template_input_keyup_4_listener() { i0.ɵɵrestoreView(_r19); const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.onKeyup(); })("focus", function AdaptTextFieldFormBuilderComponent_div_15_Template_input_focus_4_listener($event) { i0.ɵɵrestoreView(_r19); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.onFocus($event); })("blur", function AdaptTextFieldFormBuilderComponent_div_15_Template_input_blur_4_listener($event) { i0.ɵɵrestoreView(_r19); const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.onBlur($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵtemplate(7, AdaptTextFieldFormBuilderComponent_div_15_div_7_Template, 5, 3, "div", 17);
    i0.ɵɵtext(8, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.nestedSettings.addOnLeft);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("form-control ", ctx_r3.customClass, "");
    i0.ɵɵclassProp("textfield-padding-transition", ctx_r3.overflowText)("pl-0", ctx_r3.isTextOverflow && !ctx_r3.isRtl)("pr-0", ctx_r3.isTextOverflow && ctx_r3.isRtl);
    i0.ɵɵproperty("formControl", ctx_r3.control)("type", ctx_r3.type)("required", ctx_r3.required)("autofocus", ctx_r3.autofocus)("readonly", ctx_r3.readonly)("autocomplete", ctx_r3.autocomplete ? ctx_r3.autocomplete : "on")("placeholder", ctx_r3.placeholder ? ctx_r3.placeholder : "");
    i0.ɵɵattribute("name", ctx_r3.name)("id", ctx_r3.id)("maxlength", ctx_r3.maxlength)("minlength", ctx_r3.minlength)("min", ctx_r3.min)("max", ctx_r3.max)("step", ctx_r3.step)("tabindex", ctx_r3.tabindex)("aria-label", ctx_r3.ariaLabel)("aria-labelledby", ctx_r3.ariaLabelledby)("aria-describedby", ctx_r3.ariaDescribedBy);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r3.nestedSettings.addOnRight);
} }
function AdaptTextFieldFormBuilderComponent_div_18_div_4_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 24);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r23 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n        ", ctx_r23.displayMessage, "\n      ");
} }
function AdaptTextFieldFormBuilderComponent_div_18_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTextFieldFormBuilderComponent_div_18_div_4_p_2_Template, 2, 1, "p", 23);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r22 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r22.displayMessage && ctx_r22.displayMessage !== "");
} }
function AdaptTextFieldFormBuilderComponent_div_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelementStart(2, "div", 22);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptTextFieldFormBuilderComponent_div_18_div_4_Template, 4, 2, "div", 8);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n  ");
    i0.ɵɵprojection(7, 2);
    i0.ɵɵtext(8, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r4.control && ctx_r4.control.touched && ctx_r4.control.invalid && !ctx_r4.validState);
} }
function AdaptTextFieldFormBuilderComponent_div_20_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 24);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@validationFeedbackChangeAnimation", ctx_r24.control.invalid);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r24.displayMessage);
} }
function AdaptTextFieldFormBuilderComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTextFieldFormBuilderComponent_div_20_p_2_Template, 2, 2, "p", 23);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.displayMessage && ctx_r5.displayMessage !== "");
} }
function AdaptTextFieldFormBuilderComponent_div_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 25, 26);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", ctx_r6.inputStyles);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r6.value);
} }
const _c2$1 = [[["", 8, "label-count"]], "*", [["", 8, "label-count-bottom"]]];
const _c3 = [".label-count", "*", ".label-count-bottom"];
let nextId = 0;
const noop = () => {
    return;
};
const cssTextFieldClasses = {
    FOCUS: 'is-focus',
    // REQUIRED: 'is-required',       // not used yet
    // DIRTY: 'is-dirty',
    // PRISTINE: 'is-pristine',
    // FORM_SUCCESS: 'has-success',
    // FORM_DANGER: 'has-danger',
    // VALID: 'form-control-success',
    // IN_VALID: 'form-control-danger'
};
const ADAPT_TEXTFIELD_FORMBUILDER_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AdaptTextFieldFormBuilderComponent),
    multi: true
};
class AdaptTextFieldFormBuilderComponent extends AdaptRadarGenericDirective {
    constructor(elemRef, renderer, _dir, _ngZone, _resizeService, _adaptRadarService) {
        super(_adaptRadarService, elemRef, AdaptRadarAngularCustomEventName.AdaptTextFieldFormBuilder);
        this.elemRef = elemRef;
        this.renderer = renderer;
        this._dir = _dir;
        this._ngZone = _ngZone;
        this._resizeService = _resizeService;
        this.nestedSettingsDefault = {
            addOnLeft: true,
            addOnRight: false,
            addOnTextLeft: '@'
        };
        this.inputStyles = null;
        this.isTextOverflow = false;
        this.isRtl = false;
        this.overflowText = true;
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        /**
         * The input element type {bs4 view}.
         */
        this.nested = false;
        /**
         * The input element type; by default is 'text'
         */
        this.type = 'text';
        /**
         * Unique id of the element.
         */
        this.id = `adapt-textfield-${nextId++}`;
        /**
         * Whether the input is with success icon
         */
        this.iconValid = false;
        /**
         * Whether the input is with error icon
         */
        this.iconInvalid = true;
        /**
         * TabIndex attribute of the element
         */
        this.tabindex = null;
        /**
         * Maxlength attribute of the element
         */
        this.maxlength = null;
        /**
         * Minlength attribute of the element
         */
        this.minlength = 0;
        /**
         * Whether the input is valid
         */
        this.validState = false;
        /**
         * Whether the input is required. The plain text 'requiredLabel' for the input element
         */
        this.requiredLabel = '(required)';
        this.popoverPlacement = 'top';
        this.popoverTriggers = 'click';
        /**
         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
         * take precedence so this may be omitted.
         */
        this.ariaLabel = null;
        /**
         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
         */
        this.ariaLabelledby = null;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.ariaDescribedBy = null;
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.focusEmitter = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-native, @angular-eslint/no-output-rename
        this.blurEmitter = new EventEmitter();
        /**
         * Use disabled style for the control if [readonly]=true
         */
        this.disabledStyleForReadonlyState = false;
        this._readonly = false;
        this._rows = null;
        this._maxrows = -1;
        this._autofocus = false;
        this.hasFocus = false;
        this.onTouchedCallback = noop;
        this.onChangeCallback = noop;
        this._destroyed$ = new ReplaySubject(1);
        /**
         * Private variables of textfield component
         */
        this._required = false;
        this.renderer = renderer;
        this.isRtl = _dir.value === 'rtl';
    }
    /** Whether the element is required. */
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = toBoolean(value);
    }
    /** Whether the element is readonly. */
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        this._readonly = toBoolean(value);
    }
    /** Whether the element is textarea. */
    get rows() {
        return this._rows;
    }
    set rows(value) {
        this._rows = toNumber(value);
    }
    /** Whether the element has maxrows. */
    get maxrows() {
        return this._maxrows;
    }
    set maxrows(value) {
        this._maxrows = toNumber(value);
    }
    /** Whether the element has autofocus. */
    get autofocus() {
        return this._autofocus;
    }
    set autofocus(value) {
        this._autofocus = toBoolean(value);
    }
    /** The input element's value. */
    get value() {
        return this._value;
    }
    set value(v) {
        if (v !== this._value) {
            this._value = v;
            this.onChangeCallback(v);
        }
    }
    set toggleStateValidation(value) {
        if (this.control) {
            if (value) {
                this.control.markAsDirty();
                this.control.markAsTouched();
            }
            else {
                this.control.markAsPristine();
                this.control.markAsUntouched();
            }
        }
    }
    /**
     * interface ControlValueAccessor
     * writeValue(obj: any): void
     */
    writeValue(value) {
        if (this._value !== value) {
            this._value = value;
            this._applyTextOverflow();
        }
    }
    /**
     * interface ControlValueAccessor
     * registerOnChange(fn: any): void
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * interface ControlValueAccessor
     * registerOnTouched(fn: any): void
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    ngOnInit() {
        this.nestedSettings = Object.assign(Object.assign({}, this.nestedSettingsDefault), this.nestedSettings);
        if (this.tooltipIcon && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIcon,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (this.inputElement && this.overflowText) {
            this._ngZone.onStable
                .pipe(take(1))
                .subscribe(() => {
                this.inputStyles = Object.assign({}, getElementStyles(this.inputElement.nativeElement));
            });
            this._resizeService.addResizeEventListener(this.elemRef.nativeElement, debounce(this._applyTextOverflow.bind(this), 100));
            fromEvent(this.inputElement.nativeElement, 'input')
                .pipe(debounceTime(300), distinctUntilChanged(), takeUntil(this._destroyed$))
                .subscribe(() => {
                this._applyTextOverflow();
            });
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._resizeService.removeResizeEventListener(this.elemRef.nativeElement);
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    /**
     * Control disabled state from component
     */
    ngOnChanges(changes) {
        const disableControl = changes.disableControl;
        if (disableControl) {
            disableControl.currentValue ? this.control.disable() : this.control.enable();
        }
    }
    /**
     * Callback for the cases where the focused state of the input changes
     */
    onFocus(event) {
        this.hasFocus = true;
        this.renderer.addClass(this.elemRef.nativeElement, cssTextFieldClasses.FOCUS);
        this.focusEmitter.emit(event);
    }
    /**
     * Callback for the cases where the focused state is out of input element
     */
    onBlur(event) {
        this.hasFocus = false;
        this.renderer.addClass(this.elemRef.nativeElement, cssTextFieldClasses.FOCUS);
        this.onTouchedCallback();
        this.blurEmitter.emit(event);
    }
    onKeyup() {
        this.value = this.inputElement.nativeElement.value;
    }
    _applyTextOverflow() {
        if (this.overflowText && this.inputTextWidthEl && this.inputElement) {
            const div = this.inputTextWidthEl.nativeElement;
            const input = this.inputElement.nativeElement;
            this.isTextOverflow = div.clientWidth > input.clientWidth;
        }
    }
}
AdaptTextFieldFormBuilderComponent.ɵfac = function AdaptTextFieldFormBuilderComponent_Factory(t) { return new (t || AdaptTextFieldFormBuilderComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i2$1.Directionality), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.ResizeService), i0.ɵɵdirectiveInject(i2.AdaptRadarService)); };
AdaptTextFieldFormBuilderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTextFieldFormBuilderComponent, selectors: [["adapt-textfield-formbuilder"]], viewQuery: function AdaptTextFieldFormBuilderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$1, 5);
        i0.ɵɵviewQuery(_c1$1, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputTextWidthEl = _t.first);
    } }, hostVars: 12, hostBindings: function AdaptTextFieldFormBuilderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("form-group", true)("textfield", true)("is-counting", ctx.labelCount)("has-danger", ctx.control.touched && ctx.control.invalid)("has-success", !ctx.control.invalid && ctx.validState)("is-icons", ctx.iconValid && !ctx.control.invalid && ctx.validState || ctx.iconInvalid && ctx.control.touched && ctx.control.invalid);
    } }, inputs: { overflowText: "overflowText", nested: "nested", nestedSettings: "nestedSettings", customClass: "customClass", label: "label", type: "type", id: "id", icon: "icon", iconValid: "iconValid", iconInvalid: "iconInvalid", tabindex: "tabindex", maxlength: "maxlength", minlength: "minlength", placeholder: "placeholder", autocomplete: "autocomplete", pattern: "pattern", min: "min", max: "max", step: "step", name: "name", control: "control", disableControl: "disableControl", displayMessage: "displayMessage", validState: "validState", requiredLabel: "requiredLabel", tooltipIcon: "tooltipIcon", tooltipText: "tooltipText", popoverIcon: "popoverIcon", popoverPlacement: "popoverPlacement", popoverTriggers: "popoverTriggers", popoverContent: "popoverContent", labelCount: "labelCount", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedBy: ["aria-describedby", "ariaDescribedBy"], required: "required", readonly: "readonly", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", rows: "rows", maxrows: "maxrows", autofocus: "autofocus", toggleStateValidation: "toggleStateValidation" }, outputs: { focusEmitter: "focus", blurEmitter: "blur" }, features: [i0.ɵɵProvidersFeature([ADAPT_TEXTFIELD_FORMBUILDER_ACCESSOR]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c3, decls: 29, vars: 12, consts: [[1, "adapt-counter-label-wrapper"], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [1, "textfield__wrapper"], [3, "error", "success", "iconValid", "iconInvalid", 4, "ngIf"], [3, "rows", "formControl", "class", "required", "autofocus", "readonly", "form-control-disabled-look", "placeholder", "focus", "blur", 4, "ngIf"], [3, "class", "formControl", "textfield-padding-transition", "pl-0", "pr-0", "type", "required", "autofocus", "form-control-disabled-look", "readonly", "autocomplete", "placeholder", "keyup", "focus", "blur", 4, "ngIf"], ["class", "input-group", 4, "ngIf"], ["class", "form-control-flex pt-0", 4, "ngIf"], [4, "ngIf"], [1, "textfield-input-wrapper"], ["class", "textfield-input-element-copy", 3, "ngStyle", 4, "ngIf"], [3, "error", "success", "iconValid", "iconInvalid"], [3, "rows", "formControl", "required", "autofocus", "readonly", "placeholder", "focus", "blur"], [3, "formControl", "type", "required", "autofocus", "readonly", "autocomplete", "placeholder", "keyup", "focus", "blur"], ["input", ""], [1, "input-group"], ["class", "input-group-prepend", 4, "ngIf"], ["class", "input-group-append", 3, "zIndex", 4, "ngIf"], [1, "input-group-prepend"], [1, "input-group-text"], [1, "input-group-append"], [1, "form-control-flex", "pt-0"], [1, "form-control-flex__feedback"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngIf"], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"], [1, "textfield-input-element-copy", 3, "ngStyle"], ["inputTextWidthEl", ""]], template: function AdaptTextFieldFormBuilderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c2$1);
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelement(2, "adapt-rx-control-label", 1);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵprojection(4);
        i0.ɵɵtext(5, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n\n");
        i0.ɵɵelementStart(7, "div", 2);
        i0.ɵɵtext(8, "\n  ");
        i0.ɵɵtemplate(9, AdaptTextFieldFormBuilderComponent_adapt_textfield_icons_9_Template, 1, 4, "adapt-textfield-icons", 3);
        i0.ɵɵtext(10, "\n  ");
        i0.ɵɵtemplate(11, AdaptTextFieldFormBuilderComponent_textarea_11_Template, 2, 19, "textarea", 4);
        i0.ɵɵtext(12, "\n\n  ");
        i0.ɵɵtemplate(13, AdaptTextFieldFormBuilderComponent_input_13_Template, 2, 29, "input", 5);
        i0.ɵɵtext(14, "\n\n  ");
        i0.ɵɵtemplate(15, AdaptTextFieldFormBuilderComponent_div_15_Template, 9, 29, "div", 6);
        i0.ɵɵtext(16, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n\n");
        i0.ɵɵtemplate(18, AdaptTextFieldFormBuilderComponent_div_18_Template, 9, 1, "div", 7);
        i0.ɵɵtext(19, "\n\n");
        i0.ɵɵtemplate(20, AdaptTextFieldFormBuilderComponent_div_20_Template, 4, 2, "div", 8);
        i0.ɵɵtext(21, "\n\n");
        i0.ɵɵelementStart(22, "div", 9);
        i0.ɵɵtext(23, "\n  ");
        i0.ɵɵtemplate(24, AdaptTextFieldFormBuilderComponent_div_24_Template, 3, 2, "div", 10);
        i0.ɵɵtext(25, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(26, "\n\n");
        i0.ɵɵprojection(27, 1);
        i0.ɵɵtext(28, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngIf", ctx.iconValid || ctx.iconInvalid);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.rows);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.rows && !ctx.nested);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.rows && ctx.nested);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.validState);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.control && ctx.control.touched && ctx.validState);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.overflowText);
    } }, directives: [i1.AdaptRxControlLabelComponent, i3.NgIf, AdaptTextfieldIconsComponent, i1.AdaptDragonInputHandlerDirective, i6.DefaultValueAccessor, i6.NgControlStatus, i6.FormControlDirective, i6.RequiredValidator, i6.MaxLengthValidator, i6.MinLengthValidator, i3.NgStyle], styles: ["\n    .textfield .label-count,\n    .textfield .label-count-bottom {\n      color: #999;\n      font-weight: 500;\n    }\n\n    .textfield.has-danger .label-count,\n    .textfield.has-danger .label-count-bottom {\n      color: #f83200;\n    }\n\n    .form-control-flex {\n      display: flex;\n      flex-flow: row nowrap;\n      justify-content: space-between;\n      padding-top: .25rem;\n      transition: all .3s;\n    }\n\n    .form-control-flex .form-control-feedback {\n      padding-top: 0 !important;\n      padding-bottom: 0 !important;\n    }\n\n    .form-control-flex__feedback {\n      flex: 0 1 auto;\n    }\n\n    .label-count-bottom {\n      text-align: right;\n      flex: 0 0 auto;\n    }\n\n  "], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ]),
            trigger('validationFeedbackChangeAnimation', [
                transition('* => *', [
                    useAnimation(ANIMATION_NAME.opacity)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextFieldFormBuilderComponent, [{
        type: Component,
        args: [{
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.form-group]': 'true',
                    '[class.textfield]': 'true',
                    '[class.is-counting]': 'labelCount',
                    '[class.has-danger]': 'control.touched && control.invalid',
                    '[class.has-success]': '!control.invalid && validState',
                    '[class.is-icons]': '(iconValid && !control.invalid && validState) || (iconInvalid && control.touched && control.invalid)'
                },
                selector: 'adapt-textfield-formbuilder',
                providers: [ADAPT_TEXTFIELD_FORMBUILDER_ACCESSOR],
                templateUrl: './textfield-formbuilder.component.html',
                styles: [`
    .textfield .label-count,
    .textfield .label-count-bottom {
      color: #999;
      font-weight: 500;
    }

    .textfield.has-danger .label-count,
    .textfield.has-danger .label-count-bottom {
      color: #f83200;
    }

    .form-control-flex {
      display: flex;
      flex-flow: row nowrap;
      justify-content: space-between;
      padding-top: .25rem;
      transition: all .3s;
    }

    .form-control-flex .form-control-feedback {
      padding-top: 0 !important;
      padding-bottom: 0 !important;
    }

    .form-control-flex__feedback {
      flex: 0 1 auto;
    }

    .label-count-bottom {
      text-align: right;
      flex: 0 0 auto;
    }

  `],
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ]),
                    trigger('validationFeedbackChangeAnimation', [
                        transition('* => *', [
                            useAnimation(ANIMATION_NAME.opacity)
                        ])
                    ])
                ],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i2$1.Directionality }, { type: i0.NgZone }, { type: i1.ResizeService }, { type: i2.AdaptRadarService }]; }, { inputElement: [{
            type: ViewChild,
            args: ['input', { static: false }]
        }], inputTextWidthEl: [{
            type: ViewChild,
            args: ['inputTextWidthEl', { static: false }]
        }], overflowText: [{
            type: Input
        }], nested: [{
            type: Input
        }], nestedSettings: [{
            type: Input
        }], customClass: [{
            type: Input
        }], label: [{
            type: Input
        }], type: [{
            type: Input
        }], id: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconValid: [{
            type: Input
        }], iconInvalid: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], maxlength: [{
            type: Input
        }], minlength: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], autocomplete: [{
            type: Input
        }], pattern: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], step: [{
            type: Input
        }], name: [{
            type: Input
        }], control: [{
            type: Input
        }], disableControl: [{
            type: Input
        }], displayMessage: [{
            type: Input
        }], validState: [{
            type: Input
        }], requiredLabel: [{
            type: Input
        }], tooltipIcon: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], popoverIcon: [{
            type: Input
        }], popoverPlacement: [{
            type: Input
        }], popoverTriggers: [{
            type: Input
        }], popoverContent: [{
            type: Input
        }], labelCount: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaDescribedBy: [{
            type: Input,
            args: ['aria-describedby']
        }], focusEmitter: [{
            type: Output,
            args: ['focus']
        }], blurEmitter: [{
            type: Output,
            args: ['blur']
        }], required: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], rows: [{
            type: Input
        }], maxrows: [{
            type: Input
        }], autofocus: [{
            type: Input
        }], toggleStateValidation: [{
            type: Input
        }] }); })();

class AdaptTextFieldFormBuilderModule {
}
AdaptTextFieldFormBuilderModule.ɵfac = function AdaptTextFieldFormBuilderModule_Factory(t) { return new (t || AdaptTextFieldFormBuilderModule)(); };
AdaptTextFieldFormBuilderModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptTextFieldFormBuilderModule });
AdaptTextFieldFormBuilderModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            FormsModule,
            CommonModule,
            ReactiveFormsModule,
            AdaptTextFieldIconsModule,
            AdaptIconModule,
            AdaptTooltipModule,
            AdaptPopoverModule.forRoot(),
            AdaptDragonInputHandlerModule,
            AdaptRxLabelModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextFieldFormBuilderModule, [{
        type: NgModule,
        args: [{
                imports: [
                    FormsModule,
                    CommonModule,
                    ReactiveFormsModule,
                    AdaptTextFieldIconsModule,
                    AdaptIconModule,
                    AdaptTooltipModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptDragonInputHandlerModule,
                    AdaptRxLabelModule
                ],
                exports: [AdaptTextFieldFormBuilderComponent],
                declarations: [AdaptTextFieldFormBuilderComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptTextFieldFormBuilderModule, { declarations: [AdaptTextFieldFormBuilderComponent], imports: [FormsModule,
        CommonModule,
        ReactiveFormsModule,
        AdaptTextFieldIconsModule,
        AdaptIconModule,
        AdaptTooltipModule, i1.AdaptPopoverModule, AdaptDragonInputHandlerModule,
        AdaptRxLabelModule], exports: [AdaptTextFieldFormBuilderComponent] }); })();

const _c0 = ["list"];
const _c1 = ["caretPositionDiv"];
function AdaptMentionListComponent_ng_container_3_ng_template_2_Template(rf, ctx) { }
const _c2 = function (a0) { return { "$implicit": a0 }; };
function AdaptMentionListComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptMentionListComponent_ng_container_3_ng_template_2_Template, 0, 0, "ng-template", 8);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r1.topSideTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c2, ctx_r1.items));
} }
function AdaptMentionListComponent_li_7_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r10 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(item_r6[ctx_r10.searchKey]);
} }
function AdaptMentionListComponent_li_7_ng_container_2_span_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(item_r6);
} }
function AdaptMentionListComponent_li_7_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptMentionListComponent_li_7_ng_container_2_span_2_Template, 2, 1, "span", 2);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵtemplate(4, AdaptMentionListComponent_li_7_ng_container_2_span_4_Template, 2, 1, "span", 2);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r8.searchKey);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r8.searchKey);
} }
function AdaptMentionListComponent_li_7_ng_container_4_ng_template_2_Template(rf, ctx) { }
function AdaptMentionListComponent_li_7_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptMentionListComponent_li_7_ng_container_4_ng_template_2_Template, 0, 0, "ng-template", 8);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r6 = i0.ɵɵnextContext().$implicit;
    const ctx_r9 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r9.itemTemplate)("ngTemplateOutletContext", ctx_r9.getTempalteParams(item_r6));
} }
function AdaptMentionListComponent_li_7_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li", 9);
    i0.ɵɵlistener("click", function AdaptMentionListComponent_li_7_Template_li_click_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r17); const i_r7 = restoredCtx.index; const ctx_r16 = i0.ɵɵnextContext(); return ctx_r16.onClick($event, i_r7); })("mousedown", function AdaptMentionListComponent_li_7_Template_li_mousedown_0_listener($event) { return $event.preventDefault(); });
    i0.ɵɵtext(1, "\n\n      ");
    i0.ɵɵtemplate(2, AdaptMentionListComponent_li_7_ng_container_2_Template, 6, 2, "ng-container", 2);
    i0.ɵɵtext(3, "\n\n      ");
    i0.ɵɵtemplate(4, AdaptMentionListComponent_li_7_ng_container_4_Template, 4, 2, "ng-container", 2);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const i_r7 = ctx.index;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("active", ctx_r2.activeItem === i_r7);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r2.itemTemplate);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r2.itemTemplate);
} }
function AdaptMentionListComponent_div_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 10);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "div", 11);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelement(4, "div", 12);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n  ");
    i0.ɵɵelementEnd();
} }
class AdaptMentionListComponent {
    constructor(_deviceDetection, _renderer, _elementRef, _dir) {
        this._deviceDetection = _deviceDetection;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._dir = _dir;
        this.mentionStyleConfig = {
            width: '200px',
            maxHeight: '360px'
        };
        this.hidden = true;
        this.showMentionLoader = false;
        this.activeItem = 0;
        this.caretUpdated$ = new Subject();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onItemClick = new EventEmitter();
        this._isMobile = false;
        this._isRtl = false;
        this._appendToBody = false;
    }
    set appendToBody(v) {
        if (Boolean(v) !== this._appendToBody) {
            this._appendToBody = Boolean(v);
            if (this._appendToBody) {
                this._renderer.appendChild(document.body, this.list.nativeElement);
            }
            else {
                this._renderer.appendChild(this._elementRef.nativeElement, this.list.nativeElement);
            }
        }
    }
    get appendToBody() {
        return this._appendToBody;
    }
    ngOnDestroy() {
        if (this.appendToBody) {
            this._renderer.removeChild(document.body, this.list.nativeElement);
        }
    }
    initializeConfig(inputEl, mentionStyleConfig) {
        this.inputStyles = Object.assign({}, this._getElementStyles(inputEl));
        this._isMobile = this._deviceDetection.isMobile();
        this._isRtl = this._dir.value === 'rtl';
        this._inputEl = inputEl;
        if (mentionStyleConfig) {
            this.mentionStyleConfig = mentionStyleConfig;
            if (this._isMobile) {
                this.mentionStyleConfig.width = '100%';
            }
        }
        this.caretUpdated$.subscribe(index => {
            this.activeItem = 0;
            this._setListPosition(this._inputEl, index);
        });
    }
    onClick(event, index) {
        event.preventDefault();
        this.activeItem = index;
        this.onItemClick.emit(index);
    }
    focusNext() {
        if (this.items.length - 1 !== this.activeItem) {
            this.activeItem++;
        }
    }
    focusPrev() {
        if (this.activeItem !== 0) {
            this.activeItem--;
        }
    }
    trackByIndex(index) {
        return index;
    }
    hideList() {
        this.hidden = true;
    }
    showList() {
        this.hidden = false;
    }
    getTempalteParams(value) {
        return isString(value) ? { '$implicit': value } : Object.assign({}, value);
    }
    setTemplates(itemTemplate, topSideTemplate) {
        this.itemTemplate = itemTemplate;
        this.topSideTemplate = topSideTemplate;
    }
    getActiveValue() {
        return this.items[this.activeItem];
    }
    setLoaderState(state) {
        this.showMentionLoader = state;
    }
    setListItems(items) {
        this.items = items;
    }
    setActiveIndex(index) {
        this.activeItem = index;
    }
    setSearchKey(searchKey) {
        this.searchKey = searchKey;
    }
    _setListPosition(element, caretPosition) {
        this._renderer.setStyle(this.list.nativeElement, 'zIndex', this.appendToBody ? '1070' : '1');
        const ltrPlacement = [
            'bottom-left',
            'bottom',
            'bottom-right',
            'top-left',
            'top',
            'top-right',
            'bottom-left',
            'bottom',
            'bottom-right',
        ];
        const placement = this._isRtl ? convertPlacement(ltrPlacement) : ltrPlacement;
        positionElements(this._getCaretPositionElement(element, caretPosition), this.list.nativeElement, placement, this.appendToBody);
    }
    _getElementStyles(element) {
        const isFirefox = this._deviceDetection.isFirefox();
        const isInput = element.nodeName === 'INPUT';
        const computed = window.getComputedStyle(element);
        const properties = [
            'direction',
            'boxSizing',
            'width',
            'height',
            'overflowX',
            'overflowY',
            'borderTopWidth',
            'borderRightWidth',
            'borderBottomWidth',
            'borderLeftWidth',
            'borderStyle',
            'paddingTop',
            'paddingRight',
            'paddingBottom',
            'paddingLeft',
            // https://developer.mozilla.org/en-US/docs/Web/CSS/font
            'fontStyle',
            'fontVariant',
            'fontWeight',
            'fontStretch',
            'fontSize',
            'fontSizeAdjust',
            'lineHeight',
            'fontFamily',
            'textAlign',
            'textTransform',
            'textIndent',
            'textDecoration',
            'letterSpacing',
            'wordSpacing',
            'tabSize',
        ];
        const div = this.caretPositionDiv.nativeElement;
        return this._calculateElementStyles(div, properties, computed, isInput, isFirefox);
    }
    _getCaretPositionElement(element, position) {
        const isInput = element.nodeName === 'INPUT';
        const div = this.caretPositionDiv.nativeElement;
        div.textContent = element.value.substring(0, position);
        // The second special handling for input type="text" vs textarea:
        // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037
        if (isInput) {
            div.textContent = div.textContent.replace(/\s/g, '\u00a0');
        }
        // Create span which will be used for the mention list positioning
        const caretSpan = this._renderer.createElement('span');
        caretSpan.textContent = '';
        this._renderer.appendChild(div, caretSpan);
        // Wrapping must be replicated *exactly*, including when a long word gets
        // onto the next line, with whitespace at the end of the line before.
        // The  *only* reliable way to do that is to copy the *entire* rest of the
        // textarea's content into the <span> created at the caret position.
        const restContentSpan = this._renderer.createElement('span');
        restContentSpan.textContent = element.value.substring(position);
        this._renderer.appendChild(div, restContentSpan);
        // INPUT: Apply the same scrollLeft for case if scroll exist
        div.scrollLeft = element.scrollLeft + caretSpan.offsetWidth + parseInt(div.style.paddingRight, 10);
        // TEXTAREA: Apply the same scrollTop for case if scroll exist
        div.scrollTop = element.scrollTop;
        return caretSpan;
    }
    _calculateElementStyles(element, properties, computedStyles, isInput, isFirefox) {
        const styles = {};
        if (isInput) {
            styles.whiteSpace = 'nowrap';
        }
        else {
            // Default textarea styles
            styles.whiteSpace = 'pre-wrap';
            styles.wordWrap = 'break-word';
        }
        // Position off-screen
        styles.position = 'absolute'; // required to return coordinates properly
        styles.top = '0'; // need to place it at the same position as input element
        styles.visibility = 'hidden'; // not 'display: none' because we want rendering
        // Transfer the element's properties to the div
        properties.forEach((prop) => {
            styles[prop] = computedStyles[prop];
        });
        if (isFirefox) {
            // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275
            if (element.scrollHeight > parseInt(computedStyles.height, 10)) {
                styles.overflowY = 'scroll';
            }
        }
        else {
            styles.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'
        }
        return styles;
    }
}
AdaptMentionListComponent.ɵfac = function AdaptMentionListComponent_Factory(t) { return new (t || AdaptMentionListComponent)(i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2$1.Directionality)); };
AdaptMentionListComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptMentionListComponent, selectors: [["adapt-mention-list"]], viewQuery: function AdaptMentionListComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.list = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.caretPositionDiv = _t.first);
    } }, inputs: { appendToBody: "appendToBody" }, outputs: { onItemClick: "onItemClick" }, features: [i0.ɵɵProvidersFeature([AdaptDeviceDetectionService])], decls: 16, vars: 10, consts: [[1, "mention-list-container", "position-absolute", 3, "hidden"], ["list", ""], [4, "ngIf"], [1, "mention-list"], ["class", "mention-list-item", 3, "active", "click", "mousedown", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "mention-loader-container", 4, "ngIf"], [3, "ngStyle"], ["caretPositionDiv", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "mention-list-item", 3, "click", "mousedown"], [1, "mention-loader-container"], [1, "loader-container"], [1, "loader-section"]], template: function AdaptMentionListComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵtemplate(3, AdaptMentionListComponent_ng_container_3_Template, 4, 4, "ng-container", 2);
        i0.ɵɵtext(4, "\n  ");
        i0.ɵɵelementStart(5, "ul", 3);
        i0.ɵɵtext(6, "\n    ");
        i0.ɵɵtemplate(7, AdaptMentionListComponent_li_7_Template, 6, 4, "li", 4);
        i0.ɵɵtext(8, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(9, "\n\n  ");
        i0.ɵɵtemplate(10, AdaptMentionListComponent_div_10_Template, 7, 0, "div", 5);
        i0.ɵɵtext(11, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(12, "\n\n");
        i0.ɵɵelement(13, "div", 6, 7);
        i0.ɵɵtext(15, "\n");
    } if (rf & 2) {
        i0.ɵɵstyleProp("width", ctx.mentionStyleConfig.width)("max-height", ctx.mentionStyleConfig.maxHeight);
        i0.ɵɵproperty("hidden", ctx.hidden);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.topSideTemplate);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngForOf", ctx.items)("ngForTrackBy", ctx.trackByIndex);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.showMentionLoader);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngStyle", ctx.inputStyles);
    } }, directives: [i3.NgIf, i3.NgForOf, i3.NgStyle, i3.NgTemplateOutlet], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMentionListComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-mention-list',
                templateUrl: './mention-list.component.html',
                providers: [AdaptDeviceDetectionService]
            }]
    }], function () { return [{ type: i1.AdaptDeviceDetectionService }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i2$1.Directionality }]; }, { appendToBody: [{
            type: Input
        }], list: [{
            type: ViewChild,
            args: ['list', { static: true }]
        }], caretPositionDiv: [{
            type: ViewChild,
            args: ['caretPositionDiv', { static: true }]
        }], onItemClick: [{
            type: Output
        }] }); })();

// eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
// eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
class AdaptMentionDirective extends AdaptRadarGenericDirective {
    constructor(_element, _componentFactory, _differs, _renderer, _injector, _appRef, _ngZone, _adaptRadarService) {
        super(_adaptRadarService, _element, AdaptRadarAngularCustomEventName.AdaptMention);
        this._element = _element;
        this._componentFactory = _componentFactory;
        this._differs = _differs;
        this._renderer = _renderer;
        this._injector = _injector;
        this._appRef = _appRef;
        this._ngZone = _ngZone;
        this.appendToBody = false;
        this.mentionItemSelected = new EventEmitter();
        this.mentionTriggerCharPressed = new EventEmitter();
        this.mentionSearchValueEntered = new EventEmitter();
        this._triggerCharsList = {};
        this._showMentionLoader = false;
        this._modelDiffer = [];
    }
    get showMentionLoader() {
        return this._showMentionLoader;
    }
    set showMentionLoader(state) {
        this._showMentionLoader = state;
        if (this._mentionList) {
            this._mentionList.setLoaderState(state);
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._inputElement = this._element.nativeElement.querySelector('input') || this._element.nativeElement.querySelector('textarea');
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngOnChanges(changes) {
        if (changes.mentionConfig) {
            if (this.mentionConfig) {
                this.mentionConfig.forEach(config => {
                    this._triggerCharsList[config.triggerChar] = config;
                    this._modelDiffer = [];
                    this._modelDiffer.push(this._differs.find([]).create());
                });
            }
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngDoCheck() {
        // need for lazy loading
        if (this._modelDiffer.length && this.mentionConfig) {
            const isArrayChanged = this._modelDiffer.some((differ, index) => {
                return differ.diff(this.mentionConfig[index].items);
            });
            if (isArrayChanged) {
                this._updateMentionList();
            }
        }
    }
    // eslint-disable-next-line @angular-eslint/no-conflicting-lifecycle
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this._mentionListComponentRef) {
            this._mentionList.onItemClick.unsubscribe();
            this._appRef.detachView(this._mentionListComponentRef.hostView);
            this._mentionListComponentRef.destroy();
            this._mentionListComponentRef = null;
        }
    }
    onKeyDown(event) {
        this._createMentionList();
        if (this._mentionList && !this._mentionList.hidden) {
            if (hasKeyboardKeyCode(event, 'ArrowDown', DOWN_ARROW) ||
                hasKeyboardKeyCode(event, 'ArrowUp', UP_ARROW) ||
                hasKeyboardKeyCode(event, 'Tab', TAB) ||
                hasKeyboardKeyCode(event, 'Enter', ENTER)) {
                event.preventDefault();
                return;
            }
        }
    }
    onKeyUp(event) {
        this._createMentionList();
        const { key } = event;
        let config;
        this._currentCaretPosition = this._getCaretPosition(this._inputElement);
        this._isComandKeyPress(event);
        if (this._isInteractionKeyPressed(event) || this._currentCaretPosition === 0) {
            config = this._triggerCharsList[key];
        }
        else {
            config = this._triggerCharsList[this._inputElement.value[this._currentCaretPosition - 1]];
        }
        if (config) {
            const inputVal = this._inputElement.value;
            // don't show list if 'triggerChar' is a part of word. For example somemail@somedomain.com
            const preCaret = inputVal[this._currentCaretPosition - 2];
            if ((this._currentCaretPosition > 1 &&
                ((preCaret === ' ') || (preCaret === '\n') || (preCaret === '\r'))) || this._currentCaretPosition <= 1) {
                this._initConfig(config);
            }
        }
        if (!config) {
            if (hasKeyboardKeyCode(event, 'Backspace', BACKSPACE)) {
                this._reopenList();
            }
        }
        if (!config && this._startPosition >= 0 && this._searching) {
            if (this._currentCaretPosition < this._startPosition) {
                this._stopSearching();
            }
            else {
                if (!this._mentionList.hidden) {
                    if (hasKeyboardKeyCode(event, 'Tab', TAB) || hasKeyboardKeyCode(event, 'Enter', ENTER)) {
                        event.preventDefault();
                        this._updateInputValue();
                        // fire input event so angular bindings are updated
                        const inputEvent = new Event('input', {
                            bubbles: true,
                            cancelable: true,
                        });
                        this._inputElement.dispatchEvent(inputEvent);
                        return;
                    }
                    if (hasKeyboardKeyCode(event, 'Escape', ESCAPE)) {
                        event.preventDefault();
                        this._stopSearching();
                        return;
                    }
                    if (hasKeyboardKeyCode(event, 'ArrowDown', DOWN_ARROW)) {
                        event.preventDefault();
                        this._mentionList.focusNext();
                        return;
                    }
                    if (hasKeyboardKeyCode(event, 'ArrowUp', UP_ARROW)) {
                        event.preventDefault();
                        this._mentionList.focusPrev();
                        return;
                    }
                }
                if (this._searching) {
                    const inputValue = this._inputElement.value;
                    const searchValue = inputValue.substring(this._startPosition, this._currentCaretPosition);
                    this._searchValue = searchValue;
                    this.mentionSearchValueEntered.emit(this._searchValue);
                    this._updateMentionList();
                }
            }
        }
        this._ngZone.onStable
            .pipe(take(1))
            .subscribe(() => {
            this._updatePosition();
        });
    }
    onBlur() {
        this._stopSearching();
    }
    _getLastCharIndex(str, char) {
        return str.toLowerCase().lastIndexOf(char);
    }
    _isComandKeyPress(event) {
        if (hasKeyboardKeyCode(event, 'Shift', SHIFT) ||
            hasKeyboardKeyCode(event, 'Alt', ALT) ||
            hasKeyboardKeyCode(event, 'Control', CONTROL)) {
            return;
        }
    }
    _initConfig(config) {
        this._currentConfig = config;
        this._searchValue = null;
        this._searching = true;
        this._startPosition = this._currentCaretPosition;
        this._updateMentionList();
        this._mentionList.setTemplates(this._currentConfig.itemTemplate, this._currentConfig.topSideTemplate);
        this.mentionTriggerCharPressed.emit(config.triggerChar);
    }
    _reopenList() {
        const value = this._inputElement.value;
        const leftPart = value.substring(0, this._currentCaretPosition);
        let triggerCharConfig = null;
        const newLineReg = /\r|\n/g; // regexp for new line in texture
        // well looks like IE doesn't support matchAll, have to fallback for regexp exec(); Need to replace when deprecate IE11
        // const newLinesMatch = [...leftPart.matchAll(newLineReg)].pop(); // it returns iterator, let convert it to array and grab the last one
        let newLinesMatch = null;
        let result = newLineReg.exec(leftPart);
        while (result) {
            result = newLineReg.exec(leftPart);
            newLinesMatch = result;
        }
        let oneLine;
        let cutOffIndex = 0;
        // if we have a new line, let’s get substring from caret position to its start
        if (newLinesMatch) {
            cutOffIndex = newLinesMatch.index + 1;
            oneLine = leftPart.substring(newLinesMatch.index + 1);
        }
        else {
            oneLine = leftPart;
        }
        // Now we have one line of the text which may contain triggerChars or may not
        let found = false;
        if (this.mentionConfig) {
            for (let stringIndex = oneLine.length - 1; stringIndex >= 0; stringIndex--) {
                const char = oneLine[stringIndex];
                const preChar = oneLine[stringIndex - 1] || ' ';
                for (const config of this.mentionConfig) {
                    if ((config.triggerChar === char) && (preChar === ' ')) {
                        triggerCharConfig = { index: stringIndex + cutOffIndex, char: config.triggerChar };
                        found = true;
                        break;
                    }
                }
                if (found) {
                    break;
                }
            }
        }
        if (triggerCharConfig) {
            this._startPosition = triggerCharConfig.index + 1;
            this._searching = true;
            this._currentConfig = this._triggerCharsList[triggerCharConfig.char];
            this._mentionList.setTemplates(this._currentConfig.itemTemplate, this._currentConfig.topSideTemplate);
        }
    }
    _updateInputValue() {
        const selectedConfig = this._mentionList.getActiveValue();
        if (selectedConfig) {
            const selectedValue = this._mentionList.searchKey ? selectedConfig[this._mentionList.searchKey] : selectedConfig;
            this._pasteValue(selectedValue + ' ', this._startPosition, this._currentCaretPosition);
            this.mentionItemSelected.emit(selectedConfig);
        }
        this._stopSearching();
    }
    _updateMentionList() {
        let matches = [];
        let searchKey;
        if (this._currentConfig) {
            const configItems = this._currentConfig.items;
            searchKey = this._currentConfig.searchKey;
            if (this._searchValue) {
                if (searchKey) {
                    matches = configItems.filter(item => item[searchKey].toLowerCase().indexOf(this._searchValue.toLowerCase()) !== -1);
                }
                else {
                    matches = configItems.filter(item => item.toLowerCase().indexOf(this._searchValue.toLowerCase()) !== -1);
                }
            }
            if (this._searchValue === null || this._searchValue.length === 0) {
                matches = configItems;
            }
        }
        if (this._mentionList) {
            this._mentionList.setListItems(matches);
            // Show list if results exist or isLoading state
            if (matches.length > 0 || this.showMentionLoader) {
                this._mentionList.appendToBody = this.appendToBody;
                this._mentionList.showList();
            }
            else {
                this._mentionList.hideList();
            }
            this._mentionList.setActiveIndex(0);
            this._mentionList.setSearchKey(searchKey);
        }
    }
    _createMentionList() {
        if (!this._mentionList) {
            const componentFactory = this._componentFactory.resolveComponentFactory(AdaptMentionListComponent);
            this._mentionListComponentRef = componentFactory.create(this._injector);
            this._appRef.attachView(this._mentionListComponentRef.hostView);
            this._renderer.appendChild(this._inputElement.parentNode, this._mentionListComponentRef.location.nativeElement);
            this._mentionList = this._mentionListComponentRef.instance;
            this._mentionList.initializeConfig(this._inputElement, this.mentionStyleConfig);
            this._mentionList.onItemClick.subscribe(() => {
                this._updateInputValue();
            });
        }
    }
    _hideMentionList() {
        if (this._mentionList) {
            this._mentionList.hideList();
        }
    }
    _updatePosition() {
        this._mentionList.caretUpdated$.next(this._startPosition);
    }
    _stopSearching() {
        this._hideMentionList();
        this._currentConfig = null;
        this._searching = false;
    }
    _getCaretPosition(element) {
        return element.value.slice(0, element.selectionStart).length;
    }
    _pasteValue(text, startPosition, endPosition) {
        const inputValue = this._inputElement.value;
        const value = inputValue.substr(0, startPosition) + text + inputValue.substr(endPosition);
        this._inputElement.value = value;
        const caretPosition = startPosition + text.length;
        this._inputElement.setSelectionRange(caretPosition, caretPosition);
    }
    _isInteractionKeyPressed(event) {
        return hasKeyboardKeyCode(event, 'Backspace', BACKSPACE) || hasKeyboardKeyCode(event, 'Escape', ESCAPE) ||
            hasKeyboardKeyCode(event, 'Tab', TAB) || hasKeyboardKeyCode(event, 'Enter', ENTER) ||
            hasKeyboardKeyCode(event, 'ArrowLeft', LEFT_ARROW) || hasKeyboardKeyCode(event, 'ArrowRight', RIGHT_ARROW) ||
            hasKeyboardKeyCode(event, 'ArrowDown', DOWN_ARROW) || hasKeyboardKeyCode(event, 'ArrowUp', UP_ARROW);
    }
}
AdaptMentionDirective.ɵfac = function AdaptMentionDirective_Factory(t) { return new (t || AdaptMentionDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptRadarService)); };
AdaptMentionDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptMentionDirective, selectors: [["", "adaptMention", ""]], hostBindings: function AdaptMentionDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("keydown", function AdaptMentionDirective_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); })("keyup", function AdaptMentionDirective_keyup_HostBindingHandler($event) { return ctx.onKeyUp($event); })("blur", function AdaptMentionDirective_blur_HostBindingHandler() { return ctx.onBlur(); });
    } }, inputs: { mentionConfig: ["adaptMention", "mentionConfig"], mentionStyleConfig: "mentionStyleConfig", showMentionLoader: "showMentionLoader", appendToBody: "appendToBody" }, outputs: { mentionItemSelected: "mentionItemSelected", mentionTriggerCharPressed: "mentionTriggerCharPressed", mentionSearchValueEntered: "mentionSearchValueEntered" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMentionDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptMention]'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ComponentFactoryResolver }, { type: i0.IterableDiffers }, { type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ApplicationRef }, { type: i0.NgZone }, { type: i2.AdaptRadarService }]; }, { mentionConfig: [{
            type: Input,
            args: ['adaptMention']
        }], mentionStyleConfig: [{
            type: Input
        }], showMentionLoader: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], mentionItemSelected: [{
            type: Output
        }], mentionTriggerCharPressed: [{
            type: Output
        }], mentionSearchValueEntered: [{
            type: Output
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], onKeyUp: [{
            type: HostListener,
            args: ['keyup', ['$event']]
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();

class AdaptMentionModule {
}
AdaptMentionModule.ɵfac = function AdaptMentionModule_Factory(t) { return new (t || AdaptMentionModule)(); };
AdaptMentionModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptMentionModule });
AdaptMentionModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            FormsModule,
            CommonModule,
            AdaptDropdownModule.forRoot()
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMentionModule, [{
        type: NgModule,
        args: [{
                imports: [
                    FormsModule,
                    CommonModule,
                    AdaptDropdownModule.forRoot()
                ],
                exports: [AdaptMentionDirective],
                declarations: [AdaptMentionDirective, AdaptMentionListComponent],
                entryComponents: [AdaptMentionListComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptMentionModule, { declarations: [AdaptMentionDirective, AdaptMentionListComponent], imports: [FormsModule,
        CommonModule, i1.AdaptDropdownModule], exports: [AdaptMentionDirective] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const ADAPT_OBSOLETE_VERSION = new Version('12.22.0');

const ADAPT_MODULES = [
    AdaptCounterModule,
    AdaptDatetime2Module,
    AdaptDropdownEditableModule,
    AdaptListBuilderModule,
    AdaptListSelectorModule,
    AdaptRatingModule,
    AdaptSearchModule,
    AdaptTimeSlotModule,
    AdaptCheckbox2Module,
    AdaptSwitcherModule,
    AdaptSelectModule,
    AdaptSelectInlineModule,
    AdaptRadioButtonModule,
    AdaptUploadModule,
    AdaptTextFieldModule,
    AdaptTextFieldFormBuilderModule,
    AdaptMentionModule,
    AdaptTypeaheadModule
];
class AdaptObsoleteRootModule {
}
AdaptObsoleteRootModule.ɵfac = function AdaptObsoleteRootModule_Factory(t) { return new (t || AdaptObsoleteRootModule)(); };
AdaptObsoleteRootModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptObsoleteRootModule });
AdaptObsoleteRootModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            AdaptCounterModule,
            AdaptDatetime2Module,
            AdaptDropdownEditableModule,
            AdaptListBuilderModule.forRoot(),
            AdaptListSelectorModule,
            AdaptRatingModule,
            AdaptSearchModule,
            AdaptTimeSlotModule,
            AdaptCheckbox2Module,
            AdaptSwitcherModule,
            AdaptSelectModule,
            AdaptSelectInlineModule,
            AdaptRadioButtonModule,
            AdaptUploadModule.forRoot(),
            AdaptTextFieldModule,
            AdaptTextFieldFormBuilderModule,
            AdaptMentionModule,
            AdaptTypeaheadModule.forRoot(),
        ], AdaptCounterModule,
        AdaptDatetime2Module,
        AdaptDropdownEditableModule,
        AdaptListBuilderModule,
        AdaptListSelectorModule,
        AdaptRatingModule,
        AdaptSearchModule,
        AdaptTimeSlotModule,
        AdaptCheckbox2Module,
        AdaptSwitcherModule,
        AdaptSelectModule,
        AdaptSelectInlineModule,
        AdaptRadioButtonModule,
        AdaptUploadModule,
        AdaptTextFieldModule,
        AdaptTextFieldFormBuilderModule,
        AdaptMentionModule,
        AdaptTypeaheadModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptObsoleteRootModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AdaptCounterModule,
                    AdaptDatetime2Module,
                    AdaptDropdownEditableModule,
                    AdaptListBuilderModule.forRoot(),
                    AdaptListSelectorModule,
                    AdaptRatingModule,
                    AdaptSearchModule,
                    AdaptTimeSlotModule,
                    AdaptCheckbox2Module,
                    AdaptSwitcherModule,
                    AdaptSelectModule,
                    AdaptSelectInlineModule,
                    AdaptRadioButtonModule,
                    AdaptUploadModule.forRoot(),
                    AdaptTextFieldModule,
                    AdaptTextFieldFormBuilderModule,
                    AdaptMentionModule,
                    AdaptTypeaheadModule.forRoot(),
                ],
                exports: ADAPT_MODULES
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptObsoleteRootModule, { imports: [CommonModule,
        FormsModule,
        AdaptCounterModule,
        AdaptDatetime2Module,
        AdaptDropdownEditableModule, AdaptListBuilderModule, AdaptListSelectorModule,
        AdaptRatingModule,
        AdaptSearchModule,
        AdaptTimeSlotModule,
        AdaptCheckbox2Module,
        AdaptSwitcherModule,
        AdaptSelectModule,
        AdaptSelectInlineModule,
        AdaptRadioButtonModule, AdaptUploadModule, AdaptTextFieldModule,
        AdaptTextFieldFormBuilderModule,
        AdaptMentionModule, AdaptTypeaheadModule], exports: [AdaptCounterModule,
        AdaptDatetime2Module,
        AdaptDropdownEditableModule,
        AdaptListBuilderModule,
        AdaptListSelectorModule,
        AdaptRatingModule,
        AdaptSearchModule,
        AdaptTimeSlotModule,
        AdaptCheckbox2Module,
        AdaptSwitcherModule,
        AdaptSelectModule,
        AdaptSelectInlineModule,
        AdaptRadioButtonModule,
        AdaptUploadModule,
        AdaptTextFieldModule,
        AdaptTextFieldFormBuilderModule,
        AdaptMentionModule,
        AdaptTypeaheadModule] }); })();
class AdaptObsoleteModule {
    static forRoot() {
        return { ngModule: AdaptObsoleteRootModule };
    }
}
AdaptObsoleteModule.ɵfac = function AdaptObsoleteModule_Factory(t) { return new (t || AdaptObsoleteModule)(); };
AdaptObsoleteModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptObsoleteModule });
AdaptObsoleteModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [ADAPT_MODULES, AdaptCounterModule,
        AdaptDatetime2Module,
        AdaptDropdownEditableModule,
        AdaptListBuilderModule,
        AdaptListSelectorModule,
        AdaptRatingModule,
        AdaptSearchModule,
        AdaptTimeSlotModule,
        AdaptCheckbox2Module,
        AdaptSwitcherModule,
        AdaptSelectModule,
        AdaptSelectInlineModule,
        AdaptRadioButtonModule,
        AdaptUploadModule,
        AdaptTextFieldModule,
        AdaptTextFieldFormBuilderModule,
        AdaptMentionModule,
        AdaptTypeaheadModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptObsoleteModule, [{
        type: NgModule,
        args: [{
                imports: ADAPT_MODULES,
                exports: ADAPT_MODULES
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptObsoleteModule, { imports: [AdaptCounterModule,
        AdaptDatetime2Module,
        AdaptDropdownEditableModule,
        AdaptListBuilderModule,
        AdaptListSelectorModule,
        AdaptRatingModule,
        AdaptSearchModule,
        AdaptTimeSlotModule,
        AdaptCheckbox2Module,
        AdaptSwitcherModule,
        AdaptSelectModule,
        AdaptSelectInlineModule,
        AdaptRadioButtonModule,
        AdaptUploadModule,
        AdaptTextFieldModule,
        AdaptTextFieldFormBuilderModule,
        AdaptMentionModule,
        AdaptTypeaheadModule], exports: [AdaptCounterModule,
        AdaptDatetime2Module,
        AdaptDropdownEditableModule,
        AdaptListBuilderModule,
        AdaptListSelectorModule,
        AdaptRatingModule,
        AdaptSearchModule,
        AdaptTimeSlotModule,
        AdaptCheckbox2Module,
        AdaptSwitcherModule,
        AdaptSelectModule,
        AdaptSelectInlineModule,
        AdaptRadioButtonModule,
        AdaptUploadModule,
        AdaptTextFieldModule,
        AdaptTextFieldFormBuilderModule,
        AdaptMentionModule,
        AdaptTypeaheadModule] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { ADAPT_OBSOLETE_VERSION, ADAPT_RATING_ACCESSOR, ADAPT_TEXTFIELD_ACCESSOR, ADAPT_TEXTFIELD_FORMBUILDER_ACCESSOR, AdaptCheckbox2Component, AdaptCheckbox2Module, AdaptCounterComponent, AdaptCounterModule, AdaptDatetime2CalendarComponent, AdaptDatetime2ClockComponent, AdaptDatetime2Component, AdaptDatetime2Module, AdaptDatetime2MonthPickerComponent, AdaptDatetime2PickerComponent, AdaptDatetime2YearPickerComponent, AdaptDatetimeRange2Component, AdaptDropDownEditableComponent, AdaptDropdownEditableModule, AdaptListBuilderComponent, AdaptListBuilderModule, AdaptListComponent, AdaptListSelectorModule, AdaptMentionDirective, AdaptMentionModule, AdaptObsoleteModule, AdaptRadioButtonComponent, AdaptRadioButtonModule, AdaptRatingBinaryComponent, AdaptRatingComponent, AdaptRatingLikeComponent, AdaptRatingModule, AdaptRatingVotingComponent, AdaptSearchComponent, AdaptSearchModule, AdaptSelectComponent, AdaptSelectInlineComponent, AdaptSelectInlineModule, AdaptSelectModule, AdaptSelectSearchFilter, AdaptSelectSearchFilterAsync, AdaptSelectSearchFilterModule, AdaptSingleUploaderComponent, AdaptSwitcherComponent, AdaptSwitcherModule, AdaptTextFieldComponent, AdaptTextFieldFormBuilderComponent, AdaptTextFieldFormBuilderModule, AdaptTextFieldIconsModule, AdaptTextFieldModule, AdaptTextfieldIconsComponent, AdaptTimeSlotComponent, AdaptTimeSlotModule, AdaptTypeaheadComponent, AdaptTypeaheadConfig, AdaptTypeaheadDirective, AdaptTypeaheadModel, AdaptTypeaheadModule, AdaptTypeaheadSubModule, AdaptTypeaheadWindowComponent, AdaptUploadModule, AdaptUploaderComponent, Calendar2, Calendar2Day, Clock2FaceUnit, DISABLE_NATIVE_VALIDITY_CHECKING, MENU_MAX_HEIGHT, RatingBinaryTypeError, RatingLikeEnum, RatingLikeTypes, RatingLikeValuesError, RatingVotingTypeError, SelectModelFormat, TYPEAHEAD_VALUE_ACCESSOR };
//# sourceMappingURL=bmc-ux-adapt-obsolete.js.map
