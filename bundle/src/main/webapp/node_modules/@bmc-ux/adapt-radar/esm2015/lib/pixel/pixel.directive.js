import { Directive, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import { isFunction } from 'lodash-es';
import * as i0 from "@angular/core";
/**
 * Radar Pixel directive is used to detect elements visibility on the screen.
 * Directive will emit an event if element was intersected
 *
 * Directive is based on `IntersectionObserver` API
 * More information can be found here - https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 */
export class AdaptRadarPixelDirective {
    constructor(_elem) {
        this._elem = _elem;
        /**
         * The element that is used as the viewport for checking visibility of the target.
         * Must be the ancestor of the target.
         * Defaults to the browser viewport if not specified or if null.
         */
        this.adaptRadarPixelRootContainer = null;
        /**
         * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the
         * observer's callback should be executed.
         * If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5.
         * If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1].
         * The default is 0 (meaning as soon as even one pixel is visible, the callback will be run).
         * A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.
         */
        this.adaptRadarPixelThreshold = 0;
        /**
         * Margin around the root.
         * Can have values similar to the CSS margin property, e.g. "10px 20px 30px 40px" (top, right, bottom, left).
         * The values can be percentages.
         * This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections.
         * Defaults to all zeros.
         */
        this.adaptRadarPixelRootContainerMargin = '0px 0px 0px 0px';
        /**
         * Output will emit `AdaptRadarPixelIntersectionObserverEntry` data each time element will be intersected.
         * Value emitting can be control by `adaptRadarPixelTriggerResolver`
         */
        this.adaptRadarPixelIntersect = new EventEmitter();
    }
    get radarPixelOptions() {
        return {
            root: this.adaptRadarPixelRootContainer,
            threshold: this.adaptRadarPixelThreshold,
            rootMargin: this.adaptRadarPixelRootContainerMargin
        };
    }
    ngAfterViewInit() {
        this._observer = new IntersectionObserver(([entry]) => {
            if (entry.isIntersecting) {
                const elementOffsetTop = this._elem.nativeElement.offsetTop;
                if (isFunction(this.adaptRadarPixelTriggerResolver)) {
                    if (this.adaptRadarPixelTriggerResolver(entry)) {
                        this.adaptRadarPixelIntersect.emit({ entry, elementOffsetTop });
                    }
                }
                else {
                    this.adaptRadarPixelIntersect.emit({ entry, elementOffsetTop });
                }
            }
        }, this.radarPixelOptions);
        this._observer.observe(this._elem.nativeElement);
    }
    ngOnDestroy() {
        this._observer.disconnect();
        this._observer = null;
    }
}
AdaptRadarPixelDirective.ɵfac = function AdaptRadarPixelDirective_Factory(t) { return new (t || AdaptRadarPixelDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRadarPixelDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptRadarPixelDirective, selectors: [["", "adaptRadarPixel", ""]], inputs: { adaptRadarPixelRootContainer: "adaptRadarPixelRootContainer", adaptRadarPixelThreshold: "adaptRadarPixelThreshold", adaptRadarPixelRootContainerMargin: "adaptRadarPixelRootContainerMargin", adaptRadarPixelTriggerResolver: "adaptRadarPixelTriggerResolver" }, outputs: { adaptRadarPixelIntersect: "adaptRadarPixelIntersect" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRadarPixelDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptRadarPixel]'
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, { adaptRadarPixelRootContainer: [{
            type: Input
        }], adaptRadarPixelThreshold: [{
            type: Input
        }], adaptRadarPixelRootContainerMargin: [{
            type: Input
        }], adaptRadarPixelTriggerResolver: [{
            type: Input
        }], adaptRadarPixelIntersect: [{
            type: Output
        }] }); })();
//# sourceMappingURL=pixel.directive.js.map