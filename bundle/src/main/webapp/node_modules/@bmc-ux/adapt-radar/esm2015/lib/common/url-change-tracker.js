import { Injectable, NgZone } from '@angular/core';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
/**
 * Service used to track url changes
 */
export class AdaptRadarURLChangeTracker {
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        this._previousLocation = Object.assign({}, location);
        this._startTime = performance.now();
        this._urlChangeCallbackBind = this._urlChangeCallback.bind(this);
    }
    urlChange() {
        if (this._urlChange$) {
            return this._urlChange$;
        }
        else {
            this._urlChange$ = new Subject();
        }
        this._ngZone.runOutsideAngular(() => {
            document.addEventListener('click', this._urlChangeCallbackBind, true);
        });
        return this._urlChange$;
    }
    unsubscribeFromURLChange() {
        document.removeEventListener('click', this._urlChangeCallbackBind);
        this._urlChange$ = null;
    }
    ngOnDestroy() {
        this.unsubscribeFromURLChange();
    }
    _msToTime(duration) {
        const milliseconds = Math.floor((duration % 1000) / 100);
        const seconds = Math.floor((duration / 1000) % 60);
        const minutes = Math.floor((duration / (1000 * 60)) % 60);
        const hours = Math.floor((duration / (1000 * 60 * 60)) % 24);
        return {
            timeInSeconds: seconds,
            fullTime: `${(hours < 10) ? '0' + hours : hours}:${(minutes < 10) ? '0' + minutes : minutes}:${(seconds < 10) ? '0' + seconds : seconds}.${milliseconds}`,
        };
    }
    _urlChangeCallback() {
        if (this._previousLocation.href !== location.href) {
            this._endTime = performance.now();
            const locationCopy = Object.assign({}, location);
            const timeOnPage = this._endTime - this._startTime;
            const msToTime = this._msToTime(timeOnPage);
            this._urlChange$.next({
                PreviousLocation: Object.assign({}, this._previousLocation),
                CurrentLocation: locationCopy,
                PageTitle: document.title,
                TimeOnPageInMilliseconds: timeOnPage,
                TimeOnPageInSeconds: msToTime === null || msToTime === void 0 ? void 0 : msToTime.timeInSeconds,
                TimeOnPage: msToTime === null || msToTime === void 0 ? void 0 : msToTime.fullTime
            });
            this._previousLocation = locationCopy;
            this._startTime = performance.now();
        }
    }
}
AdaptRadarURLChangeTracker.ɵfac = function AdaptRadarURLChangeTracker_Factory(t) { return new (t || AdaptRadarURLChangeTracker)(i0.ɵɵinject(i0.NgZone)); };
AdaptRadarURLChangeTracker.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptRadarURLChangeTracker, factory: AdaptRadarURLChangeTracker.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRadarURLChangeTracker, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: i0.NgZone }]; }, null); })();
//# sourceMappingURL=url-change-tracker.js.map