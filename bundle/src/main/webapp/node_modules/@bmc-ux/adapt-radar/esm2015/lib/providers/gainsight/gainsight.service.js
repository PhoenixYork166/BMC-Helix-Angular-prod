/**
 * Gainsight provider
 * API docs - https://support.gainsight.com/PX/API_for_Developers
 */
import { Injectable } from '@angular/core';
import { isNil, isNull } from 'lodash-es';
import { BehaviorSubject, ReplaySubject } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import { AdaptRadarCustomEventName, AdaptRadarStorageKey, } from '../../adapt-radar.model';
import { injectInitScript } from '../../adapt-radar.utils';
import { AdaptRadarGlobal } from '../../common/global-data';
import { AdaptRadarURLChangeTracker } from '../../common/url-change-tracker';
import { gainsightInitScript } from '../providers-scripts';
import { AdaptRadarGainsightConfigName, AdaptRadarGainsightEventName, AdaptRadarGainsightIdentifyActionName } from './gainsight.model';
import { adaptError } from '../../common/logger';
import { flattenProductInfo } from '../../adapt-radar-products.model';
import * as i0 from "@angular/core";
import * as i1 from "../../common/global-data";
import * as i2 from "../../common/url-change-tracker";
export class AdaptRadarGainsightProvider {
    constructor(_adaptRadarGlobal, _adaptRadarURLChangeTracker) {
        this._adaptRadarGlobal = _adaptRadarGlobal;
        this._adaptRadarURLChangeTracker = _adaptRadarURLChangeTracker;
        this._isIdentifyEventSent = false;
        this._destroyed$ = new ReplaySubject(1);
        this._initSource = new BehaviorSubject(false);
        // Observable that can be used to check Gainsight script initialization state
        this.init$ = this._initSource.asObservable();
    }
    static getInitScript(id, customInitScript, customSourceScript) {
        return customInitScript || gainsightInitScript(id, customSourceScript);
    }
    get initProcess$() {
        return this.init$.pipe(take(1), takeUntil(this._destroyed$));
    }
    ngOnDestroy() {
        this._adaptRadarURLChangeTracker.unsubscribeFromURLChange();
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    /**
     * The method is used to start collecting the data for the current provider
     * It allows controlling the data collecting process on the customer side.
     * For instance to turn on data collecting in run time when it needed based on user preferences or project business logic
     *
     * @param providerConfig - config for provider that need to be initialized
     * @param radarConfig - main RADAR config
     */
    startDataCollecting(providerConfig, radarConfig) {
        this._providerConfig = providerConfig;
        this._radarConfig = radarConfig;
        this.initProcess$
            .subscribe(isInitialized => {
            if (isInitialized) {
                this.toggleUserTracking(true);
                return;
            }
            if (this._providerConfig.initScript !== false) {
                injectInitScript(AdaptRadarGainsightProvider.getInitScript(this._providerConfig.id, this._providerConfig.initScript, this._providerConfig.sourceScript));
            }
            // Check if Gainsight script initialized
            let counter = 0;
            const interval = setInterval(() => {
                // timeout is 5min
                // 300 * 1000 = 300000ms = 300sec = 5min
                if (counter < 1000) {
                    if (aptrinsic && aptrinsic['init']) {
                        clearInterval(interval);
                        this._initSource.next(true);
                        this.sendGlobalData(AdaptRadarCustomEventName.AdaptGlobalData, this._adaptRadarGlobal.getGlobalData());
                        this._subscribeOnURLChange();
                    }
                    counter++;
                }
                else {
                    clearInterval(interval);
                    adaptError('ADAPT RADAR: Gainsight provider initialization timeout error');
                }
            }, 300);
        });
    }
    /**
     * The method is used to stop collecting the data for the current provider
     * It allows controlling the data collecting process on the customer side.
     * For instance to turn off data collecting in run time when it needed based on user preferences or project business logic
     */
    stopDataCollecting() {
        this.initProcess$.subscribe(isInitialized => {
            if (isInitialized) {
                this.toggleUserTracking(false);
            }
        });
    }
    /**
     * Method is used to send 'identify' event for correct work of 'Gainsight' provider
     * The "identify" call should be made during the authorization/login area of your web application
     * More information can be found here - https://support.gainsight.com/PX/API_for_Developers/01About/Track_your_Users_and_Accounts
     *
     * @param userData - list of attributes that will be logged in Gainsight analytics system.
     * `id` is required for logged-in user. By default, `id` is - `bmc-not-authorized-user`
     * @param accountData - list of attributes that will be logged in Gainsight analytics system.
     * `id` is required for logged-in user. There is no default value for account id so pay attention to correctly set it if needed
     *
     * @example
     * sendIdentifyEvent({id: "user-id"}, {id: "account-id"});
     * converted to ->
     * aptrinsic('identify', {"id": "user-id"}, {"id": "account-id"});
     */
    sendIdentifyEvent(userData, accountData) {
        this.initProcess$.subscribe(isInitialized => {
            if (isInitialized) {
                aptrinsic(AdaptRadarGainsightEventName.Identify, Object.assign({ 'id': (userData === null || userData === void 0 ? void 0 : userData.id) ? userData.id : AdaptRadarGainsightProvider.notAuthorizedUserId }, userData), accountData);
                this._isIdentifyEventSent = true;
            }
        });
    }
    /**
     * Method is used to send custom events into Gainsight analytics system.
     *
     * @param customEventName - name of the event that will be logged into Gainsight analytics system
     * @param customEventData - custom data that need to be collect and associate with `customEventName`
     *
     * @example
     * sendCustomEvent(AdaptRadarCustomEventName.PagePath, {url: "some/url/path"})
     * converted to ->
     * aptrinsic('track', 'page_path', {"url": "some/url/path"})
     */
    sendCustomEvent(customEventName, customEventData) {
        this.initProcess$.subscribe(isInitialized => {
            if (isInitialized) {
                // Try to send identify event based on 'oneTimeActions' property from 'providerConfig'
                // This can be useful if customer don't want to send gainsight event manually, so it will be done automatically with first customer event
                if (!this._isIdentifyEventSent) {
                    this._processIdentifyAction();
                }
                aptrinsic(AdaptRadarGainsightEventName.Track, customEventName, customEventData);
            }
        });
    }
    /**
     * Method is used to send global data(browser version, os version, localization settings, etc.)
     * Check if data was sent for current session and avoid double sending
     *
     * @param customEventName - name of the event that will be logged into Gainsight analytics system
     * @param customEventData - custom data that need to be collect and associate with `customEventName`
     */
    sendGlobalData(customEventName, customEventData) {
        const isGlobalDataSent = sessionStorage.getItem(AdaptRadarStorageKey.GainsightGlobalDataSent);
        this.initProcess$.subscribe(isInitialized => {
            if (isInitialized && isGlobalDataSent !== 'true') {
                this.sendCustomEvent(customEventName, customEventData);
                sessionStorage.setItem(AdaptRadarStorageKey.GainsightGlobalDataSent, 'true');
            }
        });
    }
    /**
     * Method is used to set "global context"
     *
     * More info can be found here - https://support.gainsight.com/PX/Engagements/02Engagement_Configuration/Use_Global_Context
     *
     * @param contextData - custom data that need to be collect and associate with "globalContext".
     * Global context data will be automatically extended with "AdaptRadarProductInfo" passed as "productInfo" property on "AdaptRadarConfig";
     *
     * @param once - flag that used to send "SetOnce" instead of "Set" for a "globalContext"
     *
     * @example
     * setGlobalContext({'projectId' : 67890})
     * converted to ->
     * aptrinsic('set', 'globalContext', {
     *   'projectId' : 67890,
     *   'productAreaName': 'Discovery',
     *   'productAreaVersion': '11.22.33',
     *   'mainProductHostingType': 'SaaS'
     * });
     *
     * setGlobalContext({'projectId' : 45673}, true)
     * converted to ->
     * aptrinsic('setOnce', 'globalContext', {
     *   'projectId' : 45673,
     *   'productAreaName': 'Discovery',
     *   'productAreaVersion': '11.22.33',
     *   'productAreaHosting': 'SaaS'
     * });
     */
    setGlobalContext(contextData, once = false) {
        this.initProcess$.subscribe(isInitialized => {
            if (isInitialized) {
                const eventName = once ? AdaptRadarGainsightEventName.SetOnce : AdaptRadarGainsightEventName.Set;
                const productInfoFlat = flattenProductInfo(this._radarConfig.productInfo);
                const contextDataExtended = !isNull(productInfoFlat) ? Object.assign(Object.assign({}, contextData), productInfoFlat) : contextData;
                aptrinsic(eventName, AdaptRadarCustomEventName.GlobalContext, contextDataExtended);
            }
        });
    }
    /**
     * Method is used to remove "global context"
     *
     * More info can be found here - https://support.gainsight.com/PX/Engagements/02Engagement_Configuration/Use_Global_Context
     *
     * @param dataToRemove - array of string keys to remove
     *
     * @example
     * removeGlobalContext(["projectId"])
     * converted to ->
     * aptrinsic('remove', 'globalContext', ["projectId"])
     */
    removeGlobalContext(dataToRemove) {
        this.initProcess$.subscribe(isInitialized => {
            if (isInitialized) {
                aptrinsic(AdaptRadarGainsightEventName.Remove, AdaptRadarCustomEventName.GlobalContext, dataToRemove);
            }
        });
    }
    /**
     * Method is used to send information when URL changed
     *
     * @param customEventName - name of the event that will be logged into Gainsight analytics system
     * @param customEventData - custom data that need to be collect and associate with `customEventName`
     */
    sendURLChangeEvent(customEventName, customEventData) {
        this.sendCustomEvent(customEventName, customEventData);
    }
    /**
     * Opt-Out User Tracking
     * Use Config API to opt-out from tracking the current user.
     * This API allows the admin to easily make the call for any users for whom they do not want cookies stored or
     * network calls made back to PX, essentially never hitting the PX Server.
     * The selected users will not view any active engagements or Knowledge Center Bot.
     *
     * Gainsight docs: https://support.gainsight.com/PX/API_for_Developers/02Usage_of_Different_APIs/Use_Config_API
     *
     * @param isEnabled - tracking state (true for Out-In, false for Opt-Out)
     */
    toggleUserTracking(isEnabled) {
        aptrinsic(AdaptRadarGainsightEventName.Config, AdaptRadarGainsightConfigName.EnableTag, isEnabled);
        this._initSource.next(isEnabled);
    }
    _subscribeOnURLChange() {
        this._adaptRadarURLChangeTracker.unsubscribeFromURLChange();
        this._adaptRadarURLChangeTracker.urlChange()
            .pipe(takeUntil(this._destroyed$))
            .subscribe(urlChangeData => {
            this.sendURLChangeEvent(AdaptRadarCustomEventName.AdaptURLChanged, {
                PageTitle: urlChangeData.PageTitle,
                TimeOnPageInMilliseconds: urlChangeData.TimeOnPageInMilliseconds,
                TimeOnPageInSeconds: urlChangeData.TimeOnPageInSeconds,
                TimeOnPage: urlChangeData.TimeOnPage
            });
        });
    }
    _processIdentifyAction() {
        var _a;
        if ((_a = this._providerConfig.oneTimeActions) === null || _a === void 0 ? void 0 : _a.length) {
            const userInfoAction = this._providerConfig.oneTimeActions.find(action => action.name === AdaptRadarGainsightIdentifyActionName.UserIdentify);
            const userData = userInfoAction === null || userInfoAction === void 0 ? void 0 : userInfoAction.data;
            if (!isNil(userData)) {
                this.sendIdentifyEvent(userData.userData, userData.accountData);
            }
        }
    }
}
AdaptRadarGainsightProvider.notAuthorizedUserId = 'bmc-not-authorized-user';
AdaptRadarGainsightProvider.ɵfac = function AdaptRadarGainsightProvider_Factory(t) { return new (t || AdaptRadarGainsightProvider)(i0.ɵɵinject(i1.AdaptRadarGlobal), i0.ɵɵinject(i2.AdaptRadarURLChangeTracker)); };
AdaptRadarGainsightProvider.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptRadarGainsightProvider, factory: AdaptRadarGainsightProvider.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRadarGainsightProvider, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: i1.AdaptRadarGlobal }, { type: i2.AdaptRadarURLChangeTracker }]; }, null); })();
//# sourceMappingURL=gainsight.service.js.map