import { ApplicationRef, Inject, isDevMode, NgModule, Optional } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AdaptRadarDirective } from './adapt-radar.directive';
import { AdaptRadarService } from './adapt-radar.service';
import { AdaptRadarPixelDirective } from './pixel/pixel.directive';
import { ADAPT_RADAR_MODULE_CONFIG_TOKEN } from './adapt-radar.token';
import { adaptWarn } from './common/logger';
import { isNil } from 'lodash-es';
import * as i0 from "@angular/core";
export class AdaptRadarModule {
    constructor(_applicationRef, moduleConfig) {
        this._applicationRef = _applicationRef;
        if (!moduleConfig) {
            adaptWarn('ADAPT RADAR: Please provide RADAR module configuration');
            return;
        }
        if (isNil(moduleConfig.versions)) {
            adaptWarn('ADAPT RADAR: Please provide "versions" property for an easier ADAPT versions targeting');
        }
        this._setVersionsInfo(moduleConfig);
    }
    static forRoot(moduleConfig) {
        return {
            ngModule: AdaptRadarModule,
            providers: [
                { provide: ADAPT_RADAR_MODULE_CONFIG_TOKEN, useValue: moduleConfig },
                AdaptRadarService
            ]
        };
    }
    /**
     * Set versions info as attributes to the root element. Can be useful for debug. The same way as angular doing with its version
     */
    _setVersionsInfo(moduleConfig) {
        const bmcUxPackagesInfo = moduleConfig.versions;
        if (!isDevMode() || !bmcUxPackagesInfo || Object.entries(bmcUxPackagesInfo).length === 0) {
            return;
        }
        this._applicationRef.isStable.subscribe(stable => {
            var _a, _b;
            if (stable) {
                const components = this._applicationRef.components;
                const rootComponent = components ? (_b = (_a = this._applicationRef.components[0]) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.nativeElement : null;
                if (rootComponent) {
                    const bmcUxPackagesInfoEntries = Object.entries(bmcUxPackagesInfo);
                    bmcUxPackagesInfoEntries.forEach(entry => {
                        rootComponent.setAttribute(entry[0].toLowerCase().replace(/_/g, '-'), entry[1].full);
                    });
                }
            }
        });
    }
}
AdaptRadarModule.ɵfac = function AdaptRadarModule_Factory(t) { return new (t || AdaptRadarModule)(i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(ADAPT_RADAR_MODULE_CONFIG_TOKEN, 8)); };
AdaptRadarModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptRadarModule });
AdaptRadarModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRadarModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [AdaptRadarDirective, AdaptRadarPixelDirective],
                exports: [AdaptRadarDirective, AdaptRadarPixelDirective]
            }]
    }], function () { return [{ type: i0.ApplicationRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [ADAPT_RADAR_MODULE_CONFIG_TOKEN]
            }, {
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptRadarModule, { declarations: [AdaptRadarDirective, AdaptRadarPixelDirective], imports: [CommonModule], exports: [AdaptRadarDirective, AdaptRadarPixelDirective] }); })();
//# sourceMappingURL=adapt-radar.module.js.map