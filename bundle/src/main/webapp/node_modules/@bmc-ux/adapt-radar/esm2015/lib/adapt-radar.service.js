import { ApplicationRef, Injectable } from '@angular/core';
import { isNil } from 'lodash-es';
import { AdaptRadarCustomEventName, AdaptRadarCustomEventType, AdaptRadarSupportedProviders, } from './adapt-radar.model';
import { AdaptRadarGainsightProvider } from './providers/gainsight/gainsight.service';
import { AdaptRadarGoogleGlobalSiteTagProvider } from './providers/google-global-site-tag/google-global-site-tag.service';
import { AdaptRadarGoogleTagManagerProvider } from './providers/google-tag-manager/google-tag-manager.service';
import { adaptError } from './common/logger';
import * as i0 from "@angular/core";
import * as i1 from "./providers/google-global-site-tag/google-global-site-tag.service";
import * as i2 from "./providers/google-tag-manager/google-tag-manager.service";
import * as i3 from "./providers/gainsight/gainsight.service";
export class AdaptRadarService {
    constructor(_adaptRadarGGSTProvider, _adaptRadarGTMProvider, _adaptRadarGainsightProvider, _applicationRef) {
        this._adaptRadarGGSTProvider = _adaptRadarGGSTProvider;
        this._adaptRadarGTMProvider = _adaptRadarGTMProvider;
        this._adaptRadarGainsightProvider = _adaptRadarGainsightProvider;
        this._applicationRef = _applicationRef;
        this.enabledProvidersHashMap = new Map();
    }
    set config(conf) {
        this._config = conf;
    }
    get config() {
        return this._config;
    }
    /**
     * The method is used to start collecting the data for all enabled providers
     * It allows controlling the data collecting process on the customer side.
     * For instance to turn on data collecting in run time when it needed based on user preferences or project business logic
     *
     * In case there is a requirement to toggle data collecting for a specific provider it can be done by calling the "startDataCollecting" method for the needed provider
     */
    startDataCollecting(config) {
        this.config = config;
        if (isNil(this.config)) {
            adaptError('ADAPT RADAR: For correct work of RADAR service please provide a config');
            return;
        }
        if (isNil(this.config.providers)) {
            adaptError('ADAPT RADAR: Please provide "providers" property for a correct work of RADAR Module');
            return;
        }
        this.enabledProvidersHashMap.clear();
        this.config.providers
            .filter(provider => !provider.disabled)
            .forEach(provider => {
            if (!provider.id) {
                throw new Error(`ADAPT RADAR: Please provide correct "ID" for "${provider.name}" provider`);
            }
            this.enabledProvidersHashMap.set(provider.name, provider);
            this.getProviderByName(provider.name).startDataCollecting(provider, this.config);
        });
    }
    /**
     * The method is used to stop collecting the data for all enabled providers
     * It allows controlling the data collecting process on the customer side.
     * For instance to turn off data collecting in run time when it needed based on user preferences or project business logic
     */
    stopDataCollecting() {
        if (isNil(this.config)) {
            adaptError('ADAPT RADAR: For correct work of RADAR service please provide a config');
            return;
        }
        this.config.providers
            .filter(provider => !provider.disabled)
            .forEach(provider => {
            if (!provider.id) {
                throw new Error(`ADAPT RADAR: Please provide correct "ID" for "${provider.name}" provider`);
            }
            this.getProviderByName(provider.name).stopDataCollecting(provider);
        });
    }
    /**
     * Method is used to send a custom event for all enabled providers
     *
     * @param customEventName - name of the event that will be logged into analytics system
     * @param customEventData - custom data that need to be collect and associate with `customEventName`
     * @param disableEventSending - if set to true restrict event sending atomically(for some specific places). Can be useful when event need to be send only based on some condition(eg. disable event sending for button components on weekends)
     */
    sendCustomEventForAllProviders(customEventName, customEventData, disableEventSending) {
        if (this.enabledProvidersHashMap.size > 0 && !disableEventSending) {
            this.enabledProvidersHashMap.forEach(provider => {
                this.getProviderByName(provider.name).sendCustomEvent(customEventName, customEventData);
            });
        }
    }
    /**
     * Method is used to send "Generic" event for all ADAPT components on Init.
     *
     * @param entityName {AdaptRadarCustomEventName} The name on the class of the component/directive
     */
    sendGenericComponentEvent(entityName) {
        const d = new Date();
        const isoDate = d.toISOString();
        const timestamp = d.valueOf();
        this.sendCustomEventForAllProviders(AdaptRadarCustomEventName.AdaptGenericComponent, {
            EventType: AdaptRadarCustomEventType.Init,
            ComponentName: entityName,
            PageTitle: document.title,
            Date: d,
            ISODate: isoDate,
            Timestamp: timestamp
        });
    }
    /**
     * Method is used to get an instance of injected provider by its name
     *
     * @param name - the name of supported provider
     *
     * @return - instance of provider by its name
     */
    getProviderByName(name) {
        switch (name) {
            case AdaptRadarSupportedProviders.GoogleGlobalSiteTag:
                return this._adaptRadarGGSTProvider;
            case AdaptRadarSupportedProviders.GoogleTagManager:
                return this._adaptRadarGTMProvider;
            case AdaptRadarSupportedProviders.Gainsight:
                return this._adaptRadarGainsightProvider;
            default:
                throw new Error('ADAPT RADAR: No supported provider found');
        }
    }
    subscribeOnElementIntersect(adaptRadarDisableEventSending, element, entityName) {
        if (adaptRadarDisableEventSending || !(element === null || element === void 0 ? void 0 : element.nativeElement)) {
            return null;
        }
        const elementIntersectObserver = new IntersectionObserver(([entry]) => {
            if (entry.isIntersecting) {
                this.sendGenericComponentEvent(entityName);
                elementIntersectObserver.disconnect();
            }
        }, { root: null, threshold: 0, rootMargin: '0px 0px 0px 0px' });
        elementIntersectObserver.observe(element.nativeElement);
        return elementIntersectObserver;
    }
}
AdaptRadarService.ɵfac = function AdaptRadarService_Factory(t) { return new (t || AdaptRadarService)(i0.ɵɵinject(i1.AdaptRadarGoogleGlobalSiteTagProvider), i0.ɵɵinject(i2.AdaptRadarGoogleTagManagerProvider), i0.ɵɵinject(i3.AdaptRadarGainsightProvider), i0.ɵɵinject(i0.ApplicationRef)); };
AdaptRadarService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptRadarService, factory: AdaptRadarService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRadarService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: i1.AdaptRadarGoogleGlobalSiteTagProvider }, { type: i2.AdaptRadarGoogleTagManagerProvider }, { type: i3.AdaptRadarGainsightProvider }, { type: i0.ApplicationRef }]; }, null); })();
//# sourceMappingURL=adapt-radar.service.js.map