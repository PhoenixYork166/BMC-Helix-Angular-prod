{"version":3,"file":"pixel.directive.js","sourceRoot":"","sources":["../../../../../../libs/adapt-radar/src/lib/pixel/pixel.directive.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgB,SAAS,EAAE,UAAU,EAAE,YAAY,EAAE,KAAK,EAAa,MAAM,EAAC,MAAM,eAAe,CAAC;AAC3G,OAAO,EAAC,UAAU,EAAC,MAAM,WAAW,CAAC;;AAOrC;;;;;;GAMG;AAIH,MAAM,OAAO,wBAAwB;IAoDnC,YAAoB,KAA8B;QAA9B,UAAK,GAAL,KAAK,CAAyB;QAnDlD;;;;WAIG;QACM,iCAA4B,GAAmB,IAAI,CAAC;QAE7D;;;;;;;WAOG;QACM,6BAAwB,GAAsB,CAAC,CAAC;QAEzD;;;;;;WAMG;QACM,uCAAkC,GAAW,iBAAiB,CAAC;QAUxE;;;WAGG;QACgB,6BAAwB,GAA2D,IAAI,YAAY,EAA4C,CAAC;IAcnK,CAAC;IAXD,IAAI,iBAAiB;QACnB,OAAO;YACL,IAAI,EAAE,IAAI,CAAC,4BAA4B;YACvC,SAAS,EAAE,IAAI,CAAC,wBAAwB;YACxC,UAAU,EAAE,IAAI,CAAC,kCAAkC;SACpD,CAAC;IACJ,CAAC;IAOD,eAAe;QACb,IAAI,CAAC,SAAS,GAAG,IAAI,oBAAoB,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,EAAE;YACpD,IAAI,KAAK,CAAC,cAAc,EAAE;gBACxB,MAAM,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,SAAS,CAAC;gBAE5D,IAAI,UAAU,CAAC,IAAI,CAAC,8BAA8B,CAAC,EAAE;oBACnD,IAAI,IAAI,CAAC,8BAA8B,CAAC,KAAK,CAAC,EAAE;wBAC9C,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,gBAAgB,EAAC,CAAC,CAAC;qBAC/D;iBACF;qBAAM;oBACL,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,gBAAgB,EAAC,CAAC,CAAC;iBAC/D;aACF;QACH,CAAC,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAE3B,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;IACnD,CAAC;IAED,WAAW;QACT,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC;QAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;;gGA5EU,wBAAwB;2EAAxB,wBAAwB;uFAAxB,wBAAwB;cAHpC,SAAS;eAAC;gBACT,QAAQ,EAAE,mBAAmB;aAC9B;6DAOU,4BAA4B;kBAApC,KAAK;YAUG,wBAAwB;kBAAhC,KAAK;YASG,kCAAkC;kBAA1C,KAAK;YAQG,8BAA8B;kBAAtC,KAAK;YAMa,wBAAwB;kBAA1C,MAAM","sourcesContent":["import {AfterViewInit, Directive, ElementRef, EventEmitter, Input, OnDestroy, Output} from '@angular/core';\nimport {isFunction} from 'lodash-es';\nimport {\n  AdaptRadarPixelIntersectionObserverEntry,\n  AdaptRadarPixelTriggerResolver\n} from './pixel.model';\n\n\n/**\n * Radar Pixel directive is used to detect elements visibility on the screen.\n * Directive will emit an event if element was intersected\n *\n * Directive is based on `IntersectionObserver` API\n * More information can be found here - https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n */\n@Directive({\n  selector: '[adaptRadarPixel]'\n})\nexport class AdaptRadarPixelDirective implements AfterViewInit, OnDestroy {\n  /**\n   * The element that is used as the viewport for checking visibility of the target.\n   * Must be the ancestor of the target.\n   * Defaults to the browser viewport if not specified or if null.\n   */\n  @Input() adaptRadarPixelRootContainer: Element | null = null;\n\n  /**\n   * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the\n   * observer's callback should be executed.\n   * If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5.\n   * If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1].\n   * The default is 0 (meaning as soon as even one pixel is visible, the callback will be run).\n   * A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.\n   */\n  @Input() adaptRadarPixelThreshold: number | number[] = 0;\n\n  /**\n   * Margin around the root.\n   * Can have values similar to the CSS margin property, e.g. \"10px 20px 30px 40px\" (top, right, bottom, left).\n   * The values can be percentages.\n   * This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections.\n   * Defaults to all zeros.\n   */\n  @Input() adaptRadarPixelRootContainerMargin: string = '0px 0px 0px 0px';\n\n  /**\n   * Resolver function that will be invoked each time element is intersect.\n   * The function should return boolean value.\n   * In case of true the `adaptRadarPixelIntersect` event will be emitted.\n   * If function wasn't pass `adaptRadarPixelIntersect` event will be emitted each time element is intersecting.\n   */\n  @Input() adaptRadarPixelTriggerResolver: AdaptRadarPixelTriggerResolver;\n\n  /**\n   * Output will emit `AdaptRadarPixelIntersectionObserverEntry` data each time element will be intersected.\n   * Value emitting can be control by `adaptRadarPixelTriggerResolver`\n   */\n  @Output() readonly adaptRadarPixelIntersect: EventEmitter<AdaptRadarPixelIntersectionObserverEntry> = new EventEmitter<AdaptRadarPixelIntersectionObserverEntry>();\n\n\n  get radarPixelOptions(): IntersectionObserverInit {\n    return {\n      root: this.adaptRadarPixelRootContainer,\n      threshold: this.adaptRadarPixelThreshold,\n      rootMargin: this.adaptRadarPixelRootContainerMargin\n    };\n  }\n\n  private _observer: IntersectionObserver;\n\n  constructor(private _elem: ElementRef<HTMLElement>) {\n  }\n\n  ngAfterViewInit(): void {\n    this._observer = new IntersectionObserver(([entry]) => {\n      if (entry.isIntersecting) {\n        const elementOffsetTop = this._elem.nativeElement.offsetTop;\n\n        if (isFunction(this.adaptRadarPixelTriggerResolver)) {\n          if (this.adaptRadarPixelTriggerResolver(entry)) {\n            this.adaptRadarPixelIntersect.emit({entry, elementOffsetTop});\n          }\n        } else {\n          this.adaptRadarPixelIntersect.emit({entry, elementOffsetTop});\n        }\n      }\n    }, this.radarPixelOptions);\n\n    this._observer.observe(this._elem.nativeElement);\n  }\n\n  ngOnDestroy(): void {\n    this._observer.disconnect();\n    this._observer = null;\n  }\n}\n"]}