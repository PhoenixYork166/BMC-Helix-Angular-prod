import { Directive, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import { ResizeService } from '@bmc-ux/adapt-angular';
import { isEmpty } from 'lodash-es';
import { AdaptTableComponent } from '../adapt-table.component';
import { RenderingColumnType, SortMode, StorageType } from '../adapt-table.models';
import { AdaptTableStorageService } from './adapt-table-storage.service';
import { ReplaySubject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../adapt-table.component";
import * as i2 from "./adapt-table-storage.service";
import * as i3 from "@bmc-ux/adapt-angular";
export class AdaptTableStateDirective {
    constructor(_element, _table, _adaptTableStorageService, _resizeService) {
        this._element = _element;
        this._table = _table;
        this._adaptTableStorageService = _adaptTableStorageService;
        this._resizeService = _resizeService;
        this.stateRestore = new EventEmitter();
        this._destroyed$ = new ReplaySubject(1);
    }
    ngOnInit() {
        this._subscribeOnTableEvents();
        this._restoreTableState();
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    _subscribeOnSort() {
        this._table.onSort
            .pipe(takeUntil(this._destroyed$))
            .subscribe(data => {
            if (this._table.isSingleSortMode) {
                this._adaptTableStorageService.updateData(this.stateKey, { singleSortMeta: data }, StorageType.Local);
            }
            else {
                this._adaptTableStorageService.updateData(this.stateKey, { multiSortMeta: data.multisortmeta }, StorageType.Local);
            }
        });
    }
    _subscribeOnColumnReorder() {
        this._table.onColReorder
            .pipe(takeUntil(this._destroyed$))
            .subscribe(data => {
            const columnOrder = data.columns.map(column => column.field);
            this._adaptTableStorageService.updateData(this.stateKey, { columnOrder: columnOrder }, StorageType.Local);
        });
    }
    _subscribeOnColumnsResize() {
        this._table.onColResize
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            const widthMap = this._table.dataHeaderCells.map(cell => {
                return {
                    fields: cell.data.renderingColumn.columnsConfigs.map(col => col.field),
                    width: cell.element.nativeElement.offsetWidth
                };
            });
            const mergedColumns = this._table.mergeColumns && this._table.dataHeaderCells
                .filter(cell => cell.data.renderingColumn.type === RenderingColumnType.Merged);
            // Need to save merged columns in separate property to correctly restore columns and merged columns
            this._adaptTableStorageService.updateData(this.stateKey, { [mergedColumns && mergedColumns.length ? 'columnMergedWidths' : 'columnWidths']: widthMap }, StorageType.Local);
        });
    }
    _subscribeOnFilter() {
        this._table.onFilter
            .pipe(takeUntil(this._destroyed$))
            .subscribe(data => {
            this._adaptTableStorageService.updateData(this.stateKey, { filters: data.filters }, StorageType.Session);
        });
    }
    _subscribeOnColumnVisibilityChange() {
        this._table.columnsVisibilityChange
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            const columnsVisibility = this._table.columns.map(col => ({ fields: [col.field], hidden: !this._table.isColumnVisible(col) }));
            this._adaptTableStorageService.updateData(this.stateKey, { columnsVisibility }, StorageType.Session);
        });
    }
    _restoreSingleSorting(state) {
        const sortingColumn = this._table.columns.find(column => column.field === state.singleSortMeta.field);
        // Apply only for columns that are sortable and not hidden
        if (this._table.isSortableColumn(sortingColumn) && this._table.isColumnVisible(sortingColumn)) {
            this._table.sortField = state.singleSortMeta.field;
            this._table.sortOrder = state.singleSortMeta.order;
        }
    }
    _restoreMultipleSorting(state) {
        // Apply only for columns that are sortable and not hidden
        const multiSortMetaToRestore = state.multiSortMeta.filter(sortMeta => {
            return this._table.columns.some(column => this._table.isSortableColumn(column)
                && this._table.isColumnVisible(column)
                && column.field === sortMeta.field);
        });
        this._table.updateMultiSortMeta(multiSortMetaToRestore);
    }
    _restoreColumnsOrder(state) {
        // TODO: Changing of reference doesn't trigger columns reordering
        this._table.columns.sort((a, b) => {
            return state.columnOrder.indexOf(a.field) - state.columnOrder.indexOf(b.field);
        });
    }
    _restoreColumnsWidth(state) {
        const columns = [...this._table.columns];
        const columnsForRendering = this._table.getColumnsForRendering(this._table.columns);
        const isMergedColumnsPresent = columnsForRendering.some(column => column.type === RenderingColumnType.Merged);
        const columnWidthState = isMergedColumnsPresent && state.columnMergedWidths ? state.columnMergedWidths : state.columnWidths;
        columns.forEach(column => {
            const columnWithSavedWidth = columnWidthState && columnWidthState.find(columnWidth => columnWidth.fields[0] === column.field);
            column.width = columnWithSavedWidth && columnWithSavedWidth.width.toString() + 'px';
        });
        this._table.columns = columns;
    }
    _restoreFiltering(state) {
        const restoredFilters = {};
        for (const columnName in state.filters) {
            if (Object.prototype.hasOwnProperty.call(state.filters, columnName)) {
                this._table.columns.forEach(column => {
                    if (this._table.isFilterableColumn(column) && column.field === columnName) {
                        restoredFilters[columnName] = state.filters[columnName];
                    }
                });
            }
        }
        // TODO: Check do we need restoringFilter property!!!
        this._table.restoringFilter = true;
        this._table.filters = restoredFilters;
        // Need to call _filter() method manually after changing "filters" property
        // because filtering inside primeng table called only on "value" property change
        this._table._filter();
    }
    _restoreColumnsVisibility(state) {
        this._table.columns.forEach(column => {
            state.columnsVisibility.forEach(visibilityState => {
                if (column.field === visibilityState.fields[0]) {
                    column.hidden = visibilityState.hidden;
                }
            });
        });
    }
    _subscribeOnTableEvents() {
        this._subscribeOnSort();
        this._subscribeOnColumnReorder();
        this._subscribeOnColumnsResize();
        this._subscribeOnFilter();
        this._subscribeOnColumnVisibilityChange();
    }
    _restoreTableState() {
        const localState = this._adaptTableStorageService.getData(this.stateKey, StorageType.Local);
        const sessionState = this._adaptTableStorageService.getData(this.stateKey, StorageType.Session);
        if (localState) {
            if (this._table.sortMode === SortMode.Single && localState.singleSortMeta) {
                this._restoreSingleSorting(localState);
            }
            if (this._table.sortMode === SortMode.Multiple && localState.multiSortMeta) {
                this._restoreMultipleSorting(localState);
            }
            if (this._table.reorderableColumns && localState.columnOrder) {
                this._restoreColumnsOrder(localState);
            }
            if (this._table.resizableColumns && (localState.columnWidths || localState.columnMergedWidths)) {
                this._restoreColumnsWidth(localState);
            }
        }
        if (sessionState) {
            if (this._table.filterable && sessionState.filters) {
                this._restoreFiltering(sessionState);
            }
            if (sessionState.columnsVisibility) {
                this._restoreColumnsVisibility(sessionState);
            }
        }
        const tableState = Object.assign(Object.assign({}, localState), sessionState);
        this.stateRestore.emit(isEmpty(tableState) ? null : tableState);
    }
}
AdaptTableStateDirective.ɵfac = function AdaptTableStateDirective_Factory(t) { return new (t || AdaptTableStateDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.AdaptTableComponent), i0.ɵɵdirectiveInject(i2.AdaptTableStorageService), i0.ɵɵdirectiveInject(i3.ResizeService)); };
AdaptTableStateDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTableStateDirective, selectors: [["adapt-table", "adaptTableState", ""]], inputs: { stateKey: ["adaptTableState", "stateKey"] }, outputs: { stateRestore: "stateRestore" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableStateDirective, [{
        type: Directive,
        args: [{
                selector: 'adapt-table[adaptTableState]'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i1.AdaptTableComponent }, { type: i2.AdaptTableStorageService }, { type: i3.ResizeService }]; }, { stateKey: [{
            type: Input,
            args: ['adaptTableState']
        }], stateRestore: [{
            type: Output
        }] }); })();
//# sourceMappingURL=adapt-table-state.directive.js.map