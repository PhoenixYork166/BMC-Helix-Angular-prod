import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgZone, Output, ViewChild } from '@angular/core';
import { TableService } from './table.service';
import { FilterService } from 'primeng/api';
import { DomHandler } from 'primeng/dom';
import { ObjectUtils } from 'primeng/utils';
import { AdaptTableEventSource, } from '../../adapt-table.models';
import { getValueOrFunc, isDefined, SafeCdr } from '@bmc-ux/adapt-angular';
import { isNil } from 'lodash-es';
import * as i0 from "@angular/core";
import * as i1 from "./table.service";
import * as i2 from "primeng/api";
const _c0 = ["container"];
const _c1 = ["resizeHelper"];
const _c2 = ["reorderIndicatorUp"];
const _c3 = ["reorderIndicatorDown"];
const _c4 = ["table"];
// eslint-disable-next-line @angular-eslint/component-class-suffix
export class Table {
    constructor(el, zone, tableService, cd, filterService) {
        this.el = el;
        this.zone = zone;
        this.tableService = tableService;
        this.cd = cd;
        this.filterService = filterService;
        /**
         * Number of page links to display in paginator
         * @docs-default 5
         */
        this.pageLinks = 5;
        /**
         * Whether to show pagination even there is only one page
         * @docs-default true
         */
        this.alwaysShowPaginator = true;
        // TODO: use type instead of string (type PaginatorPosition = "top" | "bottom" | "both")
        /**
         * Position of the paginator, options are "top","bottom" or "both"
         * @docs-default 'bottom'
         */
        this.paginatorPosition = 'bottom';
        /**
         * Paginator dropdown height of the viewport in pixels, a scrollbar is defined if height of list exceeds this value
         * @docs-default '200px'
         */
        this.paginatorDropdownScrollHeight = '200px';
        /**
         * Template of the current page report element.
         * Available placeholders are {currentPage},{totalPages},{rows},{first},{last} and {totalRecords}
         * @docs-default '{currentPage} of {totalPages}'
         */
        this.currentPageReportTemplate = '{currentPage} of {totalPages}';
        // TODO: Use enum instead number (SortOrder {ASC: 1, DESC: -1})
        /**
         * Sort order to use when an unsorted column gets sorted by user interaction
         * @docs-default 1
         */
        this.defaultSortOrder = 1;
        // TODO: Use type instead number (type SortMode = 'single' | 'multiple')
        /**
         * Defines whether sorting works on single column or on multiple columns, valid values are "single" and "multiple"
         * @docs-default 'single'
         */
        this.sortMode = 'single';
        /**
         * When true, resets paginator to first page after sorting. Available only when sortMode is set to single
         * @docs-default true
         */
        this.resetPageOnSort = true;
        /**
         * Defines the behavior of context menu selection, in "separate" mode context menu updates contextMenuSelection propertty whereas in joint mode selection property is used instead so that when row selection is enabled, both row selection and context menu selection use the same property
         *
         * @deprecated since 12.18.0
         * Not used anymore
         *
         * @docs-default 'separate'
         */
        this.contextMenuSelectionMode = 'separate';
        /**
         * Defines if data is loaded and interacted with in lazy manner
         * @docs-default false
         */
        this.lazy = false;
        /**
         * Whether to call lazy loading on initialization
         * @docs-default true
         */
        this.lazyLoadOnInit = true;
        // TODO: Use type instead number (type ComparisonType = 'equals' | 'deepEquals')
        /**
         * Algorithm to define if a row is selected, valid values are "equals" that compares by reference and "deepEquals" that compares all fields
         * @docs-default 'deepEquals'
         */
        this.compareSelectionBy = 'deepEquals';
        /**
         * The map of FilterMetadata objects to provide external filters
         * The key of the map should be a "field" property from ColumnsConfig
         * @docs-default {}
         */
        this.filters = {};
        /**
         * Delay in milliseconds before filtering the data
         * @docs-default 300
         */
        this.filterDelay = 300;
        /**
         * Total records in filtering mode.
         * Used to separate total records in filtering and non-filtering modes
         * @docs-default null
         * @since 11.10.0
         */
        this.filteredTotalRecords = null;
        /**
         * Map instance to keep the expanded rows where key of the map is the data key of the row
         * @docs-default {}
         */
        this.expandedRowKeys = {};
        /**
         * Map instance to keep the rows being edited where key of the map is the data key of the row
         * @docs-default {}
         */
        this.editingRowKeys = {};
        // TODO: Use type instead number (type ExpandMode = 'single' | 'multiple')
        /**
         * Whether multiple rows can be expanded at any time. Valid values are "multiple" and "single"
         * @docs-default 'multiple'
         */
        this.rowExpandMode = 'multiple';
        /**
         * Threshold in milliseconds to delay lazy loading during scrolling
         * @docs-default 250
         */
        this.virtualScrollDelay = 250;
        /**
         * Height of a row to use in calculations of virtual scrolling
         * Additional information https://material.angular.io/cdk/scrolling/api
         * @docs-default 37
         */
        this.virtualRowHeight = 37;
        // TODO: Use "ResizeMode" enum instead string
        /**
         * Defines whether the overall table width should change on column resize, valid values are "fit" and "expand"
         * @docs-default 'fit'
         */
        this.columnResizeMode = 'fit';
        /**
         * The icon to show while indicating data load is in progress
         * @docs-default 'pi pi-spinner'
         */
        this.loadingIcon = 'pi pi-spinner';
        /**
         * Whether to show the loading mask when loading property is true
         * @docs-default true
         */
        this.showLoader = true;
        /**
         * Defines where a stateful table keeps its state, valid values are "session" for sessionStorage and "local" for localStorage
         *
         * @deprecated since 12.18.0
         * Not used anymore
         *
         * @docs-default 'session'
         */
        this.stateStorage = 'session';
        // TODO: Use type instead string (EditMode = 'cell' | 'row')
        /**
         * Defines the editing mode, valid values are "cell" and "row"
         * @docs-default 'cell'
         */
        this.editMode = 'cell';
        /**
         * Don't emit onLazyLoad event when changes Input value of 'sortField', 'sortOrder', 'multiSortMeta'.
         * Needs for avoiding double onLazyLoad event emitting in some cases
         *
         * @docs-default 'multiple'
         */
        this.dontEmitLazyLoadOnInputChange = true;
        /**
         * Triggered when "selection" changed. Means user selected or unselect rows
         */
        this.selectionChange = new EventEmitter();
        // TODO: Refactor this if possible
        /* eslint-disable @angular-eslint/no-output-on-prefix */
        /**
         * Callback to invoke when a row is selected
         */
        this.onRowSelect = new EventEmitter();
        /**
         * Callback to invoke when a row is unselected
         */
        this.onRowUnselect = new EventEmitter();
        /**
         * Callback to invoke when pagination occurs
         */
        this.onPage = new EventEmitter();
        /**
         * Callback to invoke when a column gets sorted
         */
        this.onSort = new EventEmitter();
        /**
         * Callback to invoke when data is filtered
         */
        this.onFilter = new EventEmitter();
        /**
         * Callback to invoke when paging, sorting or filtering happens in lazy mode
         */
        this.onLazyLoad = new EventEmitter();
        /**
         * Callback to invoke when a row is expanded
         */
        this.onRowExpand = new EventEmitter();
        /**
         * Callback to invoke when a row is collapsed
         */
        this.onRowCollapse = new EventEmitter();
        /**
         * Callback to invoke when a column is resized
         */
        this.onColResize = new EventEmitter();
        /**
         * Callback to invoke when a column is reordered
         */
        this.onColReorder = new EventEmitter();
        /**
         * Callback to invoke when state of header checkbox changes
         */
        this.onHeaderCheckboxToggle = new EventEmitter();
        /**
         * In case if [customSort] is set to true "sortFunction" output will be emitted.
         * Useful for custom sorting implementation
         */
        this.sortFunction = new EventEmitter();
        /**
         * Emit each time when [first] value changed
         */
        this.firstChange = new EventEmitter();
        /**
         * Emit each time when [rows] value changed
         */
        this.rowsChange = new EventEmitter();
        this._value = [];
        this._totalRecords = null;
        this._first = 0;
        this.selectionKeys = {};
        this._sortOrder = 1;
        /**
         * Angular trackBy function for table rows
         * @docs-default (index: number, item: RowData) => item
         */
        this.rowTrackBy = (index, item) => item;
    }
    /**
     * An array of objects to display
     * @docs-default []
     */
    get value() {
        return this._value;
    }
    set value(val) {
        this._value = val;
    }
    /**
     * An array of objects to represent dynamic columns
     * @docs-default
     */
    get columns() {
        return this._columns;
    }
    set columns(cols) {
        this._columns = cols;
    }
    /**
     * Index of the first row to be displayed
     * @docs-default 0
     */
    get first() {
        return this._first;
    }
    set first(val) {
        this._first = val;
    }
    /**
     * Number of rows to display per page
     * @docs-default
     */
    get rows() {
        return this._rows;
    }
    set rows(val) {
        this._rows = val;
    }
    // Used to separate totalRecords in filtering case and not
    get allTotalRecords() {
        /**
         * When there is no totalRecords info available(means that for some reasons customer doesn't know how many records are in the table)
         * we assume that totalRecords are at least on one record more than loaded records length until customer can set correct totalRecords value.
         *
         * This allows correctly calculate visibility of items in selection menu
         */
        if (isNil(this._totalRecords) && this.value) {
            return this.value.length + 1;
        }
        return this._totalRecords;
    }
    /**
     * Number of total records in the table
     * @docs-default null
     */
    get totalRecords() {
        var _a;
        return this.hasFilter() ? ((_a = this.filteredTotalRecords) !== null && _a !== void 0 ? _a : this._totalRecords) : this._totalRecords;
    }
    set totalRecords(val) {
        this._totalRecords = val;
        this.tableService.onTotalRecordsChange(this._totalRecords);
    }
    /**
     * Name of the field to sort data by default
     * @docs-default
     */
    get sortField() {
        return this._sortField;
    }
    set sortField(val) {
        this._sortField = val;
    }
    // TODO: Use enum instead number (SortOrder {ASC: 1, DESC: -1})
    /**
     * Order to sort when default sorting is enabled
     * 1 for ASC and -1 for DEC
     * @docs-default 1
     */
    get sortOrder() {
        return this._sortOrder;
    }
    set sortOrder(val) {
        this._sortOrder = val;
    }
    /**
     * An array of SortMeta objects to sort the data by default in multiple sort mode
     *
     * SortMeta {
     *     // The "field" property from the ColumnConfig
     *     field: string;
     *     // 1 for ASC and -1 for DEC
     *     order: number;
     * }
     *
     * @docs-default
     */
    get multiSortMeta() {
        return this._multiSortMeta;
    }
    set multiSortMeta(val) {
        this._multiSortMeta = val;
    }
    /**
     * Selected row in single mode or an array of values in multiple mode
     * @docs-default
     */
    get selection() {
        return this._selection;
    }
    set selection(val) {
        this._selection = val;
    }
    /* --- LIFECYCLES START --- */
    ngOnInit() {
        if (this.lazy && this.lazyLoadOnInit) {
            if (!this.virtualScroll) {
                this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.LazyOnInit));
            }
            if (this.restoringFilter) {
                this.restoringFilter = false;
            }
        }
        this.initialized = true;
    }
    ngOnChanges(simpleChange) {
        if (simpleChange.value) {
            this._value = simpleChange.value.currentValue;
            if (!this.lazy) {
                this.totalRecords = (this._value ? this._value.length : 0);
                if (this.sortMode === 'single' && this.sortField) {
                    this.sortSingle();
                }
                else if (this.sortMode === 'multiple' && this.multiSortMeta) {
                    this.sortMultiple();
                    // sort already filters
                }
                else if (this.hasFilter()) {
                    this._filter();
                }
            }
            this.tableService.onValueChange(simpleChange.value.currentValue);
        }
        if (simpleChange.columns) {
            this._columns = simpleChange.columns.currentValue;
            this.tableService.onColumnsChange(simpleChange.columns.currentValue);
        }
        if (simpleChange.sortField) {
            this._sortField = simpleChange.sortField.currentValue;
            // avoid triggering lazy load prior to lazy initialization at onInit
            if (!this.dontEmitLazyLoadOnInputChange && (!this.lazy || this.initialized)) {
                if (this.sortMode === 'single') {
                    this.sortSingle();
                }
            }
        }
        if (simpleChange.sortOrder) {
            this._sortOrder = simpleChange.sortOrder.currentValue;
            // avoid triggering lazy load prior to lazy initialization at onInit
            if (!this.dontEmitLazyLoadOnInputChange && (!this.lazy || this.initialized)) {
                if (this.sortMode === 'single') {
                    this.sortSingle();
                }
            }
        }
        if (simpleChange.multiSortMeta) {
            this._multiSortMeta = simpleChange.multiSortMeta.currentValue;
            if (!this.dontEmitLazyLoadOnInputChange && (this.sortMode === 'multiple')) {
                this.sortMultiple();
            }
        }
        if (simpleChange.selection) {
            this._selection = simpleChange.selection.currentValue;
            if (!this.preventSelectionSetterPropagation) {
                this.updateSelectionKeys();
                this.tableService.onSelectionChange(this._selection);
            }
            this.preventSelectionSetterPropagation = false;
        }
    }
    ngOnDestroy() {
        this.initialized = null;
    }
    /* --- LIFECYCLES END --- */
    /* ------------------------------------------------------------------ */
    toggleRowWithCheckbox(event, rowData) {
        this.selection = this.selection || [];
        const selected = this.isSelected(rowData);
        const dataKeyValue = this.dataKey ? String(ObjectUtils.resolveFieldData(rowData, this.dataKey)) : null;
        this.preventSelectionSetterPropagation = true;
        if (selected) {
            const selectionIndex = this.findIndexInSelection(rowData);
            this._selection = this.selection.filter((val, i) => i !== selectionIndex);
            this.selectionChange.emit(this.selection);
            this.onRowUnselect.emit({
                originalEvent: event.originalEvent,
                index: event.rowIndex,
                data: rowData,
                type: 'checkbox'
            });
            if (dataKeyValue) {
                delete this.selectionKeys[dataKeyValue];
            }
        }
        else {
            this._selection = this.selection ? [...this.selection, rowData] : [rowData];
            this.selectionChange.emit(this.selection);
            this.onRowSelect.emit({
                originalEvent: event.originalEvent,
                index: event.rowIndex,
                data: rowData,
                type: 'checkbox'
            });
            if (dataKeyValue) {
                this.selectionKeys[dataKeyValue] = 1;
            }
        }
        this.tableService.onSelectionChange(this._selection);
    }
    toggleRow(rowData, event) {
        if (!this.dataKey) {
            throw new Error('dataKey must be defined to use row expansion');
        }
        const dataKeyValue = String(ObjectUtils.resolveFieldData(rowData, this.dataKey));
        if (this.expandedRowKeys[dataKeyValue] != null) {
            delete this.expandedRowKeys[dataKeyValue];
            this.onRowCollapse.emit({
                originalEvent: event,
                data: rowData
            });
        }
        else {
            if (this.rowExpandMode === 'single') {
                this.expandedRowKeys = {};
            }
            this.expandedRowKeys[dataKeyValue] = true;
            this.onRowExpand.emit({
                originalEvent: event,
                data: rowData
            });
        }
        if (event) {
            event.preventDefault();
        }
        /*if (this.isStateful()) {
          this.saveState();
        }*/
    }
    /* --- ROW CLICK TOGGLE END --- */
    /* ------------------------------------------------------------------ */
    /* --- SELECTION START --- */
    isSingleSelectionMode() {
        return this.selectionMode === 'single';
    }
    isMultipleSelectionMode() {
        return this.selectionMode === 'multiple';
    }
    isSelected(rowData) {
        if (rowData && this.selection) {
            if (this.dataKey) {
                return this.selectionKeys[ObjectUtils.resolveFieldData(rowData, this.dataKey)] !== undefined;
            }
            else {
                if (this.selection instanceof Array) {
                    return this.findIndexInSelection(rowData) > -1;
                }
                else {
                    return this.equals(rowData, this.selection);
                }
            }
        }
        return false;
    }
    findIndexInSelection(rowData) {
        let index = -1;
        if (this.selection && this.selection.length) {
            for (let i = 0; i < this.selection.length; i++) {
                if (this.equals(rowData, this.selection[i])) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    }
    /* --- SELECTION START --- */
    /* ------------------------------------------------------------------ */
    /* --- SORTING START --- */
    sort(event) {
        const originalEvent = event.originalEvent;
        if (this.sortMode === 'single') {
            this._sortOrder = (this.sortField === event.field) ? this.sortOrder * -1 : this.defaultSortOrder;
            this._sortField = event.field;
            this.sortSingle();
            if (this.resetPageOnSort) {
                this._first = 0;
                this.firstChange.emit(this._first);
            }
        }
        if (this.sortMode === 'multiple') {
            const metaKey = originalEvent.metaKey || originalEvent.ctrlKey;
            const sortMeta = this.getSortMeta(event.field);
            if (sortMeta) {
                if (!metaKey) {
                    this._multiSortMeta = [{ field: event.field, order: sortMeta.order * -1 }];
                    if (this.resetPageOnSort) {
                        this._first = 0;
                        this.firstChange.emit(this._first);
                    }
                }
                else {
                    sortMeta.order = sortMeta.order * -1;
                }
            }
            else {
                if (!metaKey || !this.multiSortMeta) {
                    this._multiSortMeta = [];
                    if (this.resetPageOnSort) {
                        this._first = 0;
                        this.firstChange.emit(this._first);
                    }
                }
                this._multiSortMeta.push({ field: event.field, order: this.defaultSortOrder });
            }
            this.sortMultiple();
        }
        /*if (this.isStateful()) {
          this.saveState();
        }*/
        this.anchorRowIndex = null;
    }
    sortSingle() {
        if (this.sortField && this.sortOrder) {
            if (this.lazy) {
                this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.SingleSortChange));
            }
            else if (this.value) {
                if (this.customSort) {
                    this.sortFunction.emit({
                        data: this.value,
                        mode: this.sortMode,
                        field: this.sortField,
                        order: this.sortOrder
                    });
                }
                else {
                    this.value.sort((data1, data2) => {
                        const value1 = ObjectUtils.resolveFieldData(data1, this.sortField);
                        const value2 = ObjectUtils.resolveFieldData(data2, this.sortField);
                        let result = null;
                        if (value1 == null && value2 != null) {
                            result = -1;
                        }
                        else if (value1 != null && value2 == null) {
                            result = 1;
                        }
                        else if (value1 == null && value2 == null) {
                            result = 0;
                        }
                        else if (typeof value1 === 'string' && typeof value2 === 'string') {
                            result = value1.localeCompare(value2);
                        }
                        else {
                            result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
                        }
                        return (this.sortOrder * result);
                    });
                }
                if (this.hasFilter()) {
                    this._filter();
                }
            }
            const sortMeta = {
                field: this.sortField,
                order: this.sortOrder
            };
            this.onSort.emit(sortMeta);
            this.tableService.onSort(sortMeta);
        }
    }
    sortMultiple() {
        if (this.multiSortMeta) {
            if (this.lazy) {
                this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.MultipleSortChange));
            }
            else if (this.value) {
                if (this.customSort) {
                    this.sortFunction.emit({
                        data: this.value,
                        mode: this.sortMode,
                        multiSortMeta: this.multiSortMeta
                    });
                }
                else {
                    this.value.sort((data1, data2) => {
                        return this.multisortField(data1, data2, this.multiSortMeta, 0);
                    });
                }
                if (this.hasFilter()) {
                    this._filter();
                }
            }
            this.onSort.emit({
                multisortmeta: this.multiSortMeta
            });
            this.tableService.onSort(this.multiSortMeta);
        }
    }
    multisortField(data1, data2, multiSortMeta, index) {
        const value1 = ObjectUtils.resolveFieldData(data1, multiSortMeta[index].field);
        const value2 = ObjectUtils.resolveFieldData(data2, multiSortMeta[index].field);
        let result = null;
        if (value1 == null && value2 != null) {
            result = -1;
        }
        else if (value1 != null && value2 == null) {
            result = 1;
        }
        else if (value1 == null && value2 == null) {
            result = 0;
            // eslint-disable-next-line eqeqeq
        }
        else if (typeof value1 == 'string' || value1 instanceof String) {
            // eslint-disable-next-line eqeqeq
            if (value1.localeCompare && (value1 != value2)) {
                return (multiSortMeta[index].order * value1.localeCompare(value2));
            }
        }
        else {
            result = (value1 < value2) ? -1 : 1;
        }
        // eslint-disable-next-line eqeqeq
        if (value1 == value2) {
            return (multiSortMeta.length - 1) > (index) ? (this.multisortField(data1, data2, multiSortMeta, index + 1)) : 0;
        }
        return (multiSortMeta[index].order * result);
    }
    getSortMeta(field) {
        if (this.multiSortMeta && this.multiSortMeta.length) {
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (let i = 0; i < this.multiSortMeta.length; i++) {
                if (this.multiSortMeta[i].field === field) {
                    return this.multiSortMeta[i];
                }
            }
        }
        return null;
    }
    isSorted(field) {
        if (this.sortMode === 'single') {
            return (this.sortField && this.sortField === field);
        }
        else if (this.sortMode === 'multiple') {
            let sorted = false;
            if (this.multiSortMeta) {
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (let i = 0; i < this.multiSortMeta.length; i++) {
                    // eslint-disable-next-line eqeqeq
                    if (this.multiSortMeta[i].field == field) {
                        sorted = true;
                        break;
                    }
                }
            }
            return sorted;
        }
    }
    /* --- SORTING END --- */
    /* ------------------------------------------------------------------ */
    /* --- FILTERING START --- */
    // matchMode can't be FilterMatchMode enum because matchMode can be custom filtering mode string
    filter(value, field, matchMode) {
        if (this.filterTimeout) {
            clearTimeout(this.filterTimeout);
        }
        if (!this.isFilterBlank(value)) {
            this.filters[field] = { value: value, matchMode: matchMode };
        }
        else if (this.filters[field]) {
            delete this.filters[field];
        }
        this.filterTimeout = window.setTimeout(() => {
            this._filter();
            this.filterTimeout = null;
        }, this.filterDelay);
        this.anchorRowIndex = null;
    }
    filterGlobal(value, matchMode) {
        this.filter(value, 'global', matchMode);
    }
    isFilterBlank(filter) {
        if (filter !== null && filter !== undefined) {
            if ((typeof filter === 'string' && filter.trim().length === 0) || (filter instanceof Array && filter.length === 0)) {
                return true;
            }
            else {
                return false;
            }
        }
        return true;
    }
    _filter() {
        // TODO: Check do we need restoringFilter property!!!
        if (!this.restoringFilter) {
            this.first = 0;
            this.firstChange.emit(this.first);
        }
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.FilterChange));
        }
        else {
            if (!this.value) {
                return;
            }
            if (!this.hasFilter()) {
                this.filteredValue = null;
                this.totalRecords = this.value ? this.value.length : 0;
            }
            else {
                let globalFilterFieldsArray;
                if (this.filters.global) {
                    if (!this.columns && !this.globalFilterFields) {
                        throw new Error('Global filtering requires dynamic columns or globalFilterFields to be defined.');
                    }
                    else {
                        globalFilterFieldsArray = this.globalFilterFields || this.columns;
                    }
                }
                this.filteredValue = [];
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (let i = 0; i < this.value.length; i++) {
                    let localMatch = true;
                    let globalMatch = false;
                    let localFiltered = false;
                    for (const prop in this.filters) {
                        if (Object.prototype.hasOwnProperty.call(this.filters, prop) && prop !== 'global') {
                            localFiltered = true;
                            const filterMeta = this.filters[prop];
                            const filterField = prop;
                            const filterValue = filterMeta.value;
                            const filterMatchMode = filterMeta.matchMode || 'startsWith';
                            const dataFieldValue = ObjectUtils.resolveFieldData(this.value[i], filterField);
                            const filterConstraint = this.filterService.filters[filterMatchMode];
                            if (!filterConstraint(dataFieldValue, filterValue)) {
                                localMatch = false;
                            }
                            if (!localMatch) {
                                break;
                            }
                        }
                    }
                    if (this.filters['global'] && !globalMatch && globalFilterFieldsArray) {
                        // eslint-disable-next-line @typescript-eslint/prefer-for-of
                        for (let j = 0; j < globalFilterFieldsArray.length; j++) {
                            const globalFilterField = globalFilterFieldsArray[j].field || globalFilterFieldsArray[j];
                            globalMatch = this.filterService.filters[this.filters['global'].matchMode](ObjectUtils.resolveFieldData(this.value[i], globalFilterField), this.filters['global'].value);
                            if (globalMatch) {
                                break;
                            }
                        }
                    }
                    let matches;
                    if (this.filters['global']) {
                        matches = localFiltered ? (localFiltered && localMatch && globalMatch) : globalMatch;
                    }
                    else {
                        matches = localFiltered && localMatch;
                    }
                    if (matches) {
                        this.filteredValue.push(this.value[i]);
                    }
                }
                if (this.filteredValue.length === this.value.length) {
                    this.filteredValue = null;
                }
                this.filteredTotalRecords = this.filteredValue ? this.filteredValue.length : this.value ? this.value.length : 0;
            }
        }
        this.onFilter.emit({
            filters: this.filters,
            filteredValue: this.filteredValue || this.value
        });
        this.tableService.onValueChange(this.value);
        if (this.restoringFilter) {
            this.restoringFilter = false;
        }
        SafeCdr.markForCheck(this.cd);
    }
    hasFilter() {
        let empty = true;
        for (const prop in this.filters) {
            if (Object.prototype.hasOwnProperty.call(this.filters, prop)) {
                empty = false;
                break;
            }
        }
        return !empty;
    }
    /* --- FILTERING END --- */
    /* ------------------------------------------------------------------ */
    /* --- ROW EDITING START --- */
    initRowEdit(rowData) {
        const dataKeyValue = String(ObjectUtils.resolveFieldData(rowData, this.dataKey));
        this.editingRowKeys[dataKeyValue] = true;
    }
    saveRowEdit(rowData, rowElement) {
        if (DomHandler.find(rowElement, '.ng-invalid.ng-dirty').length === 0) {
            const dataKeyValue = String(ObjectUtils.resolveFieldData(rowData, this.dataKey));
            delete this.editingRowKeys[dataKeyValue];
        }
    }
    cancelRowEdit(rowData) {
        const dataKeyValue = String(ObjectUtils.resolveFieldData(rowData, this.dataKey));
        delete this.editingRowKeys[dataKeyValue];
    }
    isRowExpanded(rowData) {
        return this.expandedRowKeys[String(ObjectUtils.resolveFieldData(rowData, this.dataKey))] === true;
    }
    isRowEditing(rowData) {
        return this.editingRowKeys[String(ObjectUtils.resolveFieldData(rowData, this.dataKey))] === true;
    }
    /* --- ROW EDITING END --- */
    /* ------------------------------------------------------------------ */
    /* --- COLUMN RESIZE START --- */
    onColumnResizeBegin(event) {
        const containerLeft = DomHandler.getOffset(this.containerViewChild.nativeElement).left;
        this.lastResizerHelperX = (event.pageX - containerLeft + this.containerViewChild.nativeElement.scrollLeft);
        this.onColumnResize(event);
        event.preventDefault();
    }
    onColumnResize(event) {
        const containerLeft = DomHandler.getOffset(this.containerViewChild.nativeElement).left;
        DomHandler.addClass(this.containerViewChild.nativeElement, 'ui-unselectable-text');
        this.resizeHelperViewChild.nativeElement.style.height = this.containerViewChild.nativeElement.offsetHeight + 'px';
        this.resizeHelperViewChild.nativeElement.style.top = 0 + 'px';
        this.resizeHelperViewChild.nativeElement.style.left = (event.pageX - containerLeft + this.containerViewChild.nativeElement.scrollLeft) + 'px';
        this.resizeHelperViewChild.nativeElement.style.display = 'block';
    }
    /* --- COLUMN RESIZE END --- */
    /* ------------------------------------------------------------------ */
    /* --- COLUMN DRAG START --- */
    onColumnDragStart(event, columnElement) {
        this.reorderIconWidth = DomHandler.getHiddenElementOuterWidth(this.reorderIndicatorUpViewChild.nativeElement);
        this.reorderIconHeight = DomHandler.getHiddenElementOuterHeight(this.reorderIndicatorDownViewChild.nativeElement);
        this.draggedColumn = columnElement;
        event.dataTransfer.setData('text', 'b'); // For firefox
    }
    onColumnDragEnter(event, dropHeader) {
        if (this.reorderableColumns && this.draggedColumn && dropHeader && this.containerViewChild) {
            event.preventDefault();
            const containerOffset = DomHandler.getOffset(this.containerViewChild.nativeElement);
            const dropHeaderOffset = DomHandler.getOffset(dropHeader);
            // eslint-disable-next-line eqeqeq
            if (this.draggedColumn != dropHeader) {
                const dragIndex = DomHandler.indexWithinGroup(this.draggedColumn, 'preorderablecolumn');
                const dropIndex = DomHandler.indexWithinGroup(dropHeader, 'preorderablecolumn');
                const targetLeft = dropHeaderOffset.left - containerOffset.left;
                const columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
                this.reorderIndicatorUpViewChild.nativeElement.style.top
                    = dropHeaderOffset.top - containerOffset.top - (this.reorderIconHeight - 1) + 'px';
                this.reorderIndicatorDownViewChild.nativeElement.style.top
                    = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 'px';
                if (event.pageX > columnCenter) {
                    this.reorderIndicatorUpViewChild.nativeElement.style.left
                        = (targetLeft + dropHeader.offsetWidth - Math.ceil(this.reorderIconWidth / 2)) + 'px';
                    this.reorderIndicatorDownViewChild.nativeElement.style.left
                        = (targetLeft + dropHeader.offsetWidth - Math.ceil(this.reorderIconWidth / 2)) + 'px';
                    this.dropPosition = 1;
                }
                else {
                    this.reorderIndicatorUpViewChild.nativeElement.style.left = (targetLeft - Math.ceil(this.reorderIconWidth / 2)) + 'px';
                    this.reorderIndicatorDownViewChild.nativeElement.style.left = (targetLeft - Math.ceil(this.reorderIconWidth / 2)) + 'px';
                    this.dropPosition = -1;
                }
                if ((dropIndex - dragIndex === 1 && this.dropPosition === -1) || (dropIndex - dragIndex === -1 && this.dropPosition === 1)) {
                    this.reorderIndicatorUpViewChild.nativeElement.style.display = 'none';
                    this.reorderIndicatorDownViewChild.nativeElement.style.display = 'none';
                }
                else {
                    this.reorderIndicatorUpViewChild.nativeElement.style.display = 'block';
                    this.reorderIndicatorDownViewChild.nativeElement.style.display = 'block';
                }
            }
            else {
                event.dataTransfer.dropEffect = 'none';
            }
        }
    }
    onColumnDragLeave(event) {
        if (this.reorderableColumns && this.draggedColumn) {
            event.preventDefault();
            this.reorderIndicatorUpViewChild.nativeElement.style.display = 'none';
            this.reorderIndicatorDownViewChild.nativeElement.style.display = 'none';
        }
    }
    onColumnDrop(event, dropColumn) {
        event.preventDefault();
        if (this.draggedColumn) {
            const dragIndex = DomHandler.indexWithinGroup(this.draggedColumn, 'preorderablecolumn');
            let dropIndex = DomHandler.indexWithinGroup(dropColumn, 'preorderablecolumn');
            let allowDrop = (dragIndex !== dropIndex);
            if (allowDrop && ((dropIndex - dragIndex === 1 && this.dropPosition === -1)
                || (dragIndex - dropIndex === 1 && this.dropPosition === 1))) {
                allowDrop = false;
            }
            if (allowDrop && ((dropIndex < dragIndex && this.dropPosition === 1))) {
                dropIndex = dropIndex + 1;
            }
            if (allowDrop && ((dropIndex > dragIndex && this.dropPosition === -1))) {
                dropIndex = dropIndex - 1;
            }
            if (allowDrop) {
                // Because we can hide columns and dragging is used html elements,
                // we can have situation when column is hidden and indexes for columns object and columns html nodes are do not match.
                // To solve this issue sort columns object by visible columns Map and all hidden columns got to the end of array.
                const visibleColumns = this.columns.filter(c => !getValueOrFunc(c.hidden));
                ObjectUtils.reorderArray(visibleColumns, dragIndex, dropIndex);
                const visibleColumnsSortMap = new Map();
                visibleColumns.forEach((col, index) => {
                    visibleColumnsSortMap.set(col.field, index);
                });
                this.columns.sort((a, b) => {
                    const aIndex = isDefined(visibleColumnsSortMap.get(a.field))
                        ? visibleColumnsSortMap.get(a.field)
                        : visibleColumnsSortMap.size;
                    const bIndex = isDefined(visibleColumnsSortMap.get(b.field))
                        ? visibleColumnsSortMap.get(b.field)
                        : visibleColumnsSortMap.size;
                    return aIndex - bIndex;
                });
                this.onColReorder.emit({
                    dragIndex,
                    dropIndex,
                    columns: this.columns
                });
            }
            this.reorderIndicatorUpViewChild.nativeElement.style.display = 'none';
            this.reorderIndicatorDownViewChild.nativeElement.style.display = 'none';
            this.draggedColumn.draggable = false;
            this.draggedColumn = null;
            this.dropPosition = null;
        }
    }
    /* --- COLUMN DRAG END --- */
    /* ------------------------------------------------------------------ */
    /* --- OTHER START --- */
    isEmpty() {
        const data = this.filteredValue || this.value;
        // eslint-disable-next-line eqeqeq
        return data == null || data.length == 0;
    }
    getBlockableElement() {
        return this.el.nativeElement.children[0];
    }
    updateSelectionKeys() {
        if (this.dataKey && this._selection) {
            this.selectionKeys = {};
            if (Array.isArray(this._selection)) {
                for (const data of this._selection) {
                    this.selectionKeys[String(ObjectUtils.resolveFieldData(data, this.dataKey))] = 1;
                }
            }
            else {
                this.selectionKeys[String(ObjectUtils.resolveFieldData(this._selection, this.dataKey))] = 1;
            }
        }
    }
    onPageChange(event) {
        this.first = event.first;
        this.rows = event.rows;
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.PageChange));
        }
        this.onPage.emit({
            first: this.first,
            rows: this.rows
        });
        this.firstChange.emit(this.first);
        this.rowsChange.emit(this.rows);
        this.tableService.onValueChange(this.value);
        this.anchorRowIndex = null;
    }
    equals(data1, data2) {
        // TODO: Maybe there is a sense to use lodash isEqualWith instead of ObjectUtils.equals
        return this.compareSelectionBy === 'equals' ? (data1 === data2) : ObjectUtils.equals(data1, data2, this.dataKey);
    }
    createLazyLoadMetadata(eventSource) {
        return {
            eventSource,
            first: this.first,
            rows: this.rows,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            filters: this.filters,
            globalFilter: this.filters && this.filters['global'] ? this.filters['global'].value : null,
            multiSortMeta: this.multiSortMeta
        };
    }
    reset() {
        this._sortField = null;
        this._sortOrder = this.defaultSortOrder;
        this._multiSortMeta = null;
        this.tableService.onSort(null);
        this.filteredValue = null;
        this.filters = {};
        this.first = 0;
        this.firstChange.emit(this.first);
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.Reset));
        }
        else {
            this.totalRecords = (this._value ? this._value.length : 0);
        }
    }
    findParentScrollableView(column) {
        if (column) {
            let parent = column.parentElement;
            while (parent && !DomHandler.hasClass(parent, 'ui-table-scrollable-view')) {
                parent = parent.parentElement;
            }
            return parent;
        }
        else {
            return null;
        }
    }
}
Table.ɵfac = function Table_Factory(t) { return new (t || Table)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.TableService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.FilterService)); };
Table.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: Table, selectors: [["p-table"]], viewQuery: function Table_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 5);
        i0.ɵɵviewQuery(_c2, 5);
        i0.ɵɵviewQuery(_c3, 5);
        i0.ɵɵviewQuery(_c4, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.containerViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeHelperViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.reorderIndicatorUpViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.reorderIndicatorDownViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableViewChild = _t.first);
    } }, inputs: { value: "value", columns: "columns", first: "first", rows: "rows", totalRecords: "totalRecords", sortField: "sortField", sortOrder: "sortOrder", multiSortMeta: "multiSortMeta", selection: "selection", frozenColumns: "frozenColumns", frozenValue: "frozenValue", frozenWidth: "frozenWidth", style: "style", styleClass: "styleClass", tableStyle: "tableStyle", tableStyleClass: "tableStyleClass", paginator: "paginator", pageLinks: "pageLinks", rowsPerPageOptions: "rowsPerPageOptions", alwaysShowPaginator: "alwaysShowPaginator", paginatorPosition: "paginatorPosition", paginatorDropdownAppendTo: "paginatorDropdownAppendTo", paginatorDropdownScrollHeight: "paginatorDropdownScrollHeight", currentPageReportTemplate: "currentPageReportTemplate", showCurrentPageReport: "showCurrentPageReport", defaultSortOrder: "defaultSortOrder", sortMode: "sortMode", resetPageOnSort: "resetPageOnSort", selectionMode: "selectionMode", contextMenuSelectionMode: "contextMenuSelectionMode", dataKey: "dataKey", metaKeySelection: "metaKeySelection", lazy: "lazy", lazyLoadOnInit: "lazyLoadOnInit", compareSelectionBy: "compareSelectionBy", filters: "filters", globalFilterFields: "globalFilterFields", filterDelay: "filterDelay", filteredTotalRecords: "filteredTotalRecords", expandedRowKeys: "expandedRowKeys", editingRowKeys: "editingRowKeys", rowExpandMode: "rowExpandMode", scrollable: "scrollable", scrollHeight: "scrollHeight", virtualScroll: "virtualScroll", virtualScrollDelay: "virtualScrollDelay", virtualRowHeight: "virtualRowHeight", responsive: "responsive", resizableColumns: "resizableColumns", columnResizeMode: "columnResizeMode", reorderableColumns: "reorderableColumns", loadingIcon: "loadingIcon", showLoader: "showLoader", rowHover: "rowHover", customSort: "customSort", autoLayout: "autoLayout", exportFunction: "exportFunction", stateKey: "stateKey", stateStorage: "stateStorage", editMode: "editMode", dontEmitLazyLoadOnInputChange: "dontEmitLazyLoadOnInputChange", rowTrackBy: "rowTrackBy" }, outputs: { selectionChange: "selectionChange", onRowSelect: "onRowSelect", onRowUnselect: "onRowUnselect", onPage: "onPage", onSort: "onSort", onFilter: "onFilter", onLazyLoad: "onLazyLoad", onRowExpand: "onRowExpand", onRowCollapse: "onRowCollapse", onColResize: "onColResize", onColReorder: "onColReorder", onHeaderCheckboxToggle: "onHeaderCheckboxToggle", sortFunction: "sortFunction", firstChange: "firstChange", rowsChange: "rowsChange" }, features: [i0.ɵɵProvidersFeature([FilterService]), i0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function Table_Template(rf, ctx) { }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(Table, [{
        type: Component,
        args: [{
                // eslint-disable-next-line @angular-eslint/component-selector
                selector: 'p-table',
                template: '',
                changeDetection: ChangeDetectionStrategy.Default,
                providers: [FilterService]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.TableService }, { type: i0.ChangeDetectorRef }, { type: i2.FilterService }]; }, { value: [{
            type: Input
        }], columns: [{
            type: Input
        }], first: [{
            type: Input
        }], rows: [{
            type: Input
        }], totalRecords: [{
            type: Input
        }], sortField: [{
            type: Input
        }], sortOrder: [{
            type: Input
        }], multiSortMeta: [{
            type: Input
        }], selection: [{
            type: Input
        }], frozenColumns: [{
            type: Input
        }], frozenValue: [{
            type: Input
        }], frozenWidth: [{
            type: Input
        }], style: [{
            type: Input
        }], styleClass: [{
            type: Input
        }], tableStyle: [{
            type: Input
        }], tableStyleClass: [{
            type: Input
        }], paginator: [{
            type: Input
        }], pageLinks: [{
            type: Input
        }], rowsPerPageOptions: [{
            type: Input
        }], alwaysShowPaginator: [{
            type: Input
        }], paginatorPosition: [{
            type: Input
        }], paginatorDropdownAppendTo: [{
            type: Input
        }], paginatorDropdownScrollHeight: [{
            type: Input
        }], currentPageReportTemplate: [{
            type: Input
        }], showCurrentPageReport: [{
            type: Input
        }], defaultSortOrder: [{
            type: Input
        }], sortMode: [{
            type: Input
        }], resetPageOnSort: [{
            type: Input
        }], selectionMode: [{
            type: Input
        }], contextMenuSelectionMode: [{
            type: Input
        }], dataKey: [{
            type: Input
        }], metaKeySelection: [{
            type: Input
        }], lazy: [{
            type: Input
        }], lazyLoadOnInit: [{
            type: Input
        }], compareSelectionBy: [{
            type: Input
        }], filters: [{
            type: Input
        }], globalFilterFields: [{
            type: Input
        }], filterDelay: [{
            type: Input
        }], filteredTotalRecords: [{
            type: Input
        }], expandedRowKeys: [{
            type: Input
        }], editingRowKeys: [{
            type: Input
        }], rowExpandMode: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], scrollHeight: [{
            type: Input
        }], virtualScroll: [{
            type: Input
        }], virtualScrollDelay: [{
            type: Input
        }], virtualRowHeight: [{
            type: Input
        }], responsive: [{
            type: Input
        }], resizableColumns: [{
            type: Input
        }], columnResizeMode: [{
            type: Input
        }], reorderableColumns: [{
            type: Input
        }], loadingIcon: [{
            type: Input
        }], showLoader: [{
            type: Input
        }], rowHover: [{
            type: Input
        }], customSort: [{
            type: Input
        }], autoLayout: [{
            type: Input
        }], exportFunction: [{
            type: Input
        }], stateKey: [{
            type: Input
        }], stateStorage: [{
            type: Input
        }], editMode: [{
            type: Input
        }], dontEmitLazyLoadOnInputChange: [{
            type: Input
        }], selectionChange: [{
            type: Output
        }], onRowSelect: [{
            type: Output
        }], onRowUnselect: [{
            type: Output
        }], onPage: [{
            type: Output
        }], onSort: [{
            type: Output
        }], onFilter: [{
            type: Output
        }], onLazyLoad: [{
            type: Output
        }], onRowExpand: [{
            type: Output
        }], onRowCollapse: [{
            type: Output
        }], onColResize: [{
            type: Output
        }], onColReorder: [{
            type: Output
        }], onHeaderCheckboxToggle: [{
            type: Output
        }], sortFunction: [{
            type: Output
        }], firstChange: [{
            type: Output
        }], rowsChange: [{
            type: Output
        }], containerViewChild: [{
            type: ViewChild,
            args: ['container', { static: false }]
        }], resizeHelperViewChild: [{
            type: ViewChild,
            args: ['resizeHelper', { static: false }]
        }], reorderIndicatorUpViewChild: [{
            type: ViewChild,
            args: ['reorderIndicatorUp', { static: false }]
        }], reorderIndicatorDownViewChild: [{
            type: ViewChild,
            args: ['reorderIndicatorDown', { static: false }]
        }], tableViewChild: [{
            type: ViewChild,
            args: ['table', { static: false }]
        }], rowTrackBy: [{
            type: Input
        }] }); })();
//# sourceMappingURL=table.js.map