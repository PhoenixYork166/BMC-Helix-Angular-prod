import { Directive, ElementRef, HostListener, Input, NgZone } from '@angular/core';
import { AdaptTableComponent } from '../../adapt-table.component';
import { DomHandler } from 'primeng/dom';
import { isFunction } from 'lodash-es';
import * as i0 from "@angular/core";
import * as i1 from "../../adapt-table.component";
// eslint-disable-next-line @angular-eslint/directive-class-suffix
export class ReorderableColumn {
    constructor(dt, el, zone) {
        this.dt = dt;
        this.el = el;
        this.zone = zone;
    }
    ngAfterViewInit() {
        if (this.isEnabled()) {
            this.bindEvents();
        }
    }
    bindEvents() {
        this.zone.runOutsideAngular(() => {
            this.mouseDownListener = this.onMouseDown.bind(this);
            this.el.nativeElement.addEventListener('mousedown', this.mouseDownListener);
            this.dragStartListener = this.onDragStart.bind(this);
            this.el.nativeElement.addEventListener('dragstart', this.dragStartListener);
            this.dragOverListener = this.onDragEnter.bind(this);
            this.el.nativeElement.addEventListener('dragover', this.dragOverListener);
            this.dragEnterListener = this.onDragEnter.bind(this);
            this.el.nativeElement.addEventListener('dragenter', this.dragEnterListener);
            this.dragLeaveListener = this.onDragLeave.bind(this);
            this.el.nativeElement.addEventListener('dragleave', this.dragLeaveListener);
        });
    }
    unbindEvents() {
        if (this.mouseDownListener) {
            document.removeEventListener('mousedown', this.mouseDownListener);
            this.mouseDownListener = null;
        }
        if (this.dragOverListener) {
            document.removeEventListener('dragover', this.dragOverListener);
            this.dragOverListener = null;
        }
        if (this.dragEnterListener) {
            document.removeEventListener('dragenter', this.dragEnterListener);
            this.dragEnterListener = null;
        }
        if (this.dragEnterListener) {
            document.removeEventListener('dragenter', this.dragEnterListener);
            this.dragEnterListener = null;
        }
        if (this.dragLeaveListener) {
            document.removeEventListener('dragleave', this.dragLeaveListener);
            this.dragLeaveListener = null;
        }
    }
    onMouseDown(event) {
        if (event.target.nodeName === 'INPUT'
            || event.target.nodeName === 'TEXTAREA'
            || DomHandler.hasClass(event.target, 'ui-column-resizer')) {
            this.el.nativeElement.draggable = false;
        }
        else {
            this.el.nativeElement.draggable = true;
        }
    }
    onDragStart(event) {
        this.dt.onColumnDragStart(event, this.el.nativeElement);
    }
    onDragOver(event) {
        event.preventDefault();
    }
    onDragEnter(event) {
        this.onColumnDragEnter(event, this.el.nativeElement);
    }
    onDragLeave(event) {
        this.dt.onColumnDragLeave(event);
    }
    onDrop(event) {
        if (this.isEnabled()) {
            this.dt.onColumnDrop(event, this.el.nativeElement);
        }
    }
    onColumnDragEnter(event, dropHeader) {
        if (!isFunction(this.dt.allowColumnReorderingResolver)) {
            this.dt.onColumnDragEnter(event, dropHeader);
        }
        else {
            const draggedHeaderColumn = this.dt.dataHeaderCells.find(headerCell => headerCell.element.nativeElement === this.dt.draggedColumn);
            const droppedHeaderColumn = this.dt.dataHeaderCells.find(headerCell => headerCell.element.nativeElement === dropHeader);
            const allowColumnsReordering = draggedHeaderColumn && droppedHeaderColumn
                && this.dt.allowColumnReorderingResolver(draggedHeaderColumn, droppedHeaderColumn);
            if (allowColumnsReordering) {
                this.dt.onColumnDragEnter(event, dropHeader);
            }
            else {
                event.dataTransfer.dropEffect = 'none';
            }
        }
    }
    isEnabled() {
        return this.pReorderableColumnDisabled !== true;
    }
    ngOnDestroy() {
        this.unbindEvents();
    }
}
ReorderableColumn.ɵfac = function ReorderableColumn_Factory(t) { return new (t || ReorderableColumn)(i0.ɵɵdirectiveInject(i1.AdaptTableComponent), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone)); };
ReorderableColumn.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ReorderableColumn, selectors: [["", "pReorderableColumn", ""]], hostBindings: function ReorderableColumn_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("drop", function ReorderableColumn_drop_HostBindingHandler($event) { return ctx.onDrop($event); });
    } }, inputs: { pReorderableColumnDisabled: "pReorderableColumnDisabled" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ReorderableColumn, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[pReorderableColumn]'
            }]
    }], function () { return [{ type: i1.AdaptTableComponent }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, { pReorderableColumnDisabled: [{
            type: Input
        }], onDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }] }); })();
//# sourceMappingURL=reordarable-column.directive.js.map