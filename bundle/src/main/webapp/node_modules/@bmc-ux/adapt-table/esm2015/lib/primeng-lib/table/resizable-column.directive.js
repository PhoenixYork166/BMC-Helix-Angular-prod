import { Directive, ElementRef, EventEmitter, Input, NgZone, Output, Renderer2 } from '@angular/core';
import { round } from 'lodash-es';
import { AdaptTableComponent } from '../../adapt-table.component';
import { DomHandler } from 'primeng/dom';
import { AdaptTableClasses, ResizeDirection, ResizeMode } from '../../adapt-table.models';
import { adaptError } from '@bmc-ux/adapt-angular';
import { calculateScrollbarWidth } from './utils';
import * as i0 from "@angular/core";
import * as i1 from "../../adapt-table.component";
// eslint-disable-next-line @angular-eslint/directive-class-suffix
export class ResizableColumn {
    constructor(dt, el, zone, _renderer) {
        this.dt = dt;
        this.el = el;
        this.zone = zone;
        this._renderer = _renderer;
        this.columnResized = new EventEmitter();
        this._minColResizeWidth = 15; // in pixels
    }
    ngAfterViewInit() {
        if (this.isEnabled()) {
            DomHandler.addClass(this.el.nativeElement, 'ui-resizable-column');
            this.resizer = document.createElement('span');
            this.resizer.className = 'ui-column-resizer ui-clickable';
            this.el.nativeElement.appendChild(this.resizer);
            this.zone.runOutsideAngular(() => {
                this.resizerMouseDownListener = this.onMouseDown.bind(this);
                this.resizer.addEventListener('mousedown', this.resizerMouseDownListener);
            });
        }
    }
    bindDocumentEvents() {
        this.zone.runOutsideAngular(() => {
            this.documentMouseMoveListener = this.onDocumentMouseMove.bind(this);
            document.addEventListener('mousemove', this.documentMouseMoveListener);
            this.documentMouseUpListener = this.onDocumentMouseUp.bind(this);
            document.addEventListener('mouseup', this.documentMouseUpListener);
        });
    }
    unbindDocumentEvents() {
        if (this.documentMouseMoveListener) {
            document.removeEventListener('mousemove', this.documentMouseMoveListener);
            this.documentMouseMoveListener = null;
        }
        if (this.documentMouseUpListener) {
            document.removeEventListener('mouseup', this.documentMouseUpListener);
            this.documentMouseUpListener = null;
        }
    }
    onMouseDown(event) {
        if (event.which === 1) {
            this.dt.onColumnResizeBegin(event);
            this.bindDocumentEvents();
        }
    }
    onDocumentMouseMove(event) {
        this.dt.onColumnResize(event);
    }
    onDocumentMouseUp(event) {
        this.onColumnResizeEnd(event, this.el.nativeElement);
        this.unbindDocumentEvents();
    }
    isEnabled() {
        return this.pResizableColumnDisabled !== true;
    }
    ngOnDestroy() {
        if (this.resizerMouseDownListener) {
            this.resizer.removeEventListener('mousedown', this.resizerMouseDownListener);
        }
        this.unbindDocumentEvents();
    }
    onColumnResizeEnd(event, column) {
        if (this.dt.columnResizeMode === ResizeMode.Fit) {
            this._handleFitModeResize(event, column);
        }
        else if (this.dt.columnResizeMode === ResizeMode.Expand) {
            this._handleExpandModeResize(event, column);
        }
        this.dt.resizeHelperViewChild.nativeElement.style.display = 'none';
        DomHandler.removeClass(this.dt.containerViewChild.nativeElement, 'ui-unselectable-text');
    }
    _checkIfOverlapLeftSibling(event, column) {
        const containerLeft = DomHandler.getOffset(this.dt.containerViewChild.nativeElement).left;
        return this.dt.isRtl
            ? event.pageX - containerLeft < column.nextElementSibling.offsetLeft
            : event.pageX - containerLeft < column.offsetLeft;
    }
    _checkIfOverlapRightSibling(event, column) {
        const containerLeft = DomHandler.getOffset(this.dt.containerViewChild.nativeElement).left;
        return this.dt.isRtl
            ? event.pageX - containerLeft > column.offsetLeft + column.offsetWidth
            : event.pageX - containerLeft > column.offsetLeft
                + column.offsetWidth + column.nextElementSibling.offsetWidth;
    }
    _handleExpandModeResize(event, column) {
        const delta = this._getColumnResizeDelta(event, column);
        const columnWidth = column.offsetWidth;
        const newColumnWidth = columnWidth + delta;
        // Logic copied from PrimeNG. Changed the way how delta calculating
        if (this.dt.scrollable) {
            this._setScrollableItemsWidthOnExpandResize(column, newColumnWidth, delta);
        }
        else {
            this.dt.tableViewChild.nativeElement.style.width =
                this.dt.tableViewChild.nativeElement.offsetWidth + delta + 'px';
            column.style.width = newColumnWidth + 'px';
            const containerWidth = this.dt.tableViewChild.nativeElement.style.width;
            this.dt.containerViewChild.nativeElement.style.width = containerWidth + 'px';
        }
        this._emitOnColResize(column, delta);
    }
    _setScrollableItemsWidthOnExpandResize(column, newColumnWidth, delta) {
        const scrollableView = column ? this.dt.findParentScrollableView(column) : this.dt.containerViewChild.nativeElement;
        const scrollableBody = DomHandler.findSingle(scrollableView, this.dt.virtualScroll ? `.${AdaptTableClasses.TableVirtualScrollableBody}` : `.${AdaptTableClasses.TableScrollableBody}`);
        const scrollableHeader = DomHandler.findSingle(scrollableView, `.${AdaptTableClasses.TableScrollableHeader}`);
        const scrollableFooter = DomHandler.findSingle(scrollableView, `.${AdaptTableClasses.TableScrollableFooter}`);
        const scrollableBodyTable = DomHandler.findSingle(scrollableBody, `table.${AdaptTableClasses.TableScrollableBodyTable}`);
        const scrollableHeaderTable = DomHandler.findSingle(scrollableHeader, `table.${AdaptTableClasses.TableScrollableHeaderTable}`);
        const scrollableFooterTable = DomHandler.findSingle(scrollableFooter, `table.${AdaptTableClasses.TableScrollableFooterTable}`);
        const scrollableBodyTableWidth = column ? scrollableBodyTable.offsetWidth + delta : newColumnWidth;
        const scrollableHeaderTableWidth = column ? scrollableHeaderTable.offsetWidth + delta : newColumnWidth;
        const isContainerInViewport = this.dt.containerViewChild.nativeElement.offsetWidth >= scrollableBodyTableWidth;
        const setWidth = (container, table, width, isContainerInViewport) => {
            if (container && table) {
                container.style.width = isContainerInViewport ? width + calculateScrollbarWidth(scrollableBody) + 'px' : 'auto';
                table.style.width = width + 'px';
            }
        };
        setWidth(scrollableBody, scrollableBodyTable, scrollableBodyTableWidth, isContainerInViewport);
        setWidth(scrollableHeader, scrollableHeaderTable, scrollableHeaderTableWidth, isContainerInViewport);
        setWidth(scrollableFooter, scrollableFooterTable, scrollableHeaderTableWidth, isContainerInViewport);
        if (column) {
            const resizeColumnIndex = DomHandler.index(column);
            this._resizeColGroup(scrollableHeaderTable, resizeColumnIndex, newColumnWidth, null);
            this._resizeColGroup(scrollableBodyTable, resizeColumnIndex, newColumnWidth, null);
            this._resizeColGroup(scrollableFooterTable, resizeColumnIndex, newColumnWidth, null);
        }
    }
    _resizeColGroup(table, resizeColumnIndex, newColumnWidth, nextColumnWidth) {
        if (table) {
            const colGroup = table.children[0].nodeName === 'COLGROUP' ? table.children[0] : null;
            if (colGroup) {
                const col = colGroup.children[resizeColumnIndex];
                const nextCol = col.nextElementSibling;
                this._renderer.setStyle(col, 'width', newColumnWidth + 'px');
                this._renderer.setAttribute(col, 'data-resized-width', newColumnWidth + 'px');
                if (nextCol && nextColumnWidth) {
                    this._renderer.setStyle(nextCol, 'width', nextColumnWidth + 'px');
                    this._renderer.setAttribute(nextCol, 'data-resized-width', nextColumnWidth + 'px');
                }
            }
            else {
                throw new Error('Scrollable tables require a colgroup to support resizable columns');
            }
        }
    }
    _getColumnSiblingsWidths(column, resizeDirection) {
        let columnSibling = resizeDirection === ResizeDirection.Left
            ? column.previousElementSibling
            : column.nextElementSibling;
        const allPrevColumnSiblings = [columnSibling];
        function getSibling(columnRef) {
            return resizeDirection === ResizeDirection.Left
                ? columnRef.previousElementSibling
                : columnRef.nextElementSibling;
        }
        while (columnSibling && getSibling(columnSibling)) {
            allPrevColumnSiblings.push(getSibling(columnSibling));
            columnSibling = getSibling(columnSibling);
        }
        const allResizablePrevColumnSiblings = allPrevColumnSiblings.filter(col => col && col.classList.contains('ui-resizable-column'));
        return allResizablePrevColumnSiblings.map((item) => item && item.offsetWidth);
    }
    _getColumnResizeDelta(event, column) {
        const containerLeft = DomHandler.getOffset(this.dt.containerViewChild.nativeElement).left;
        return this.dt.isRtl
            ? containerLeft + column.offsetLeft - event.pageX
            : event.pageX - (containerLeft + column.offsetLeft + column.offsetWidth);
    }
    _handleFitModeResize(event, column) {
        const isLeftSiblingOverlap = this._checkIfOverlapLeftSibling(event, column);
        const isRightSiblingOverlap = this._checkIfOverlapRightSibling(event, column);
        if (!isLeftSiblingOverlap && !isRightSiblingOverlap) {
            this._noSiblingOverlapResize(event, column);
        }
        else if (isLeftSiblingOverlap) {
            if (this.dt.isRtl) {
                this._handleRightSiblingOverlapResize(event, column);
            }
            else {
                this._handleLeftSiblingOverlapResize(event, column);
            }
        }
        else if (isRightSiblingOverlap) {
            if (this.dt.isRtl) {
                this._handleLeftSiblingOverlapResize(event, column);
            }
            else {
                this._handleRightSiblingOverlapResize(event, column);
            }
        }
    }
    // Logic copied from PrimeNG. Changed the way how delta calculating
    _noSiblingOverlapResize(event, column) {
        const resizeColumnIndex = DomHandler.index(column);
        let nextColumn = column.nextElementSibling;
        while (!nextColumn.offsetParent) {
            nextColumn = nextColumn.nextElementSibling;
        }
        if (nextColumn) {
            const delta = this._getColumnResizeDelta(event, column);
            const nextColumnWidth = nextColumn.offsetWidth - delta;
            const columnWidth = column.offsetWidth;
            const newColumnWidth = columnWidth + delta;
            if (this.dt.scrollable) {
                const scrollableView = this.dt.findParentScrollableView(column);
                const scrollableBodyTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableBodyTable}`);
                const scrollableHeaderTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableHeaderTable}`);
                const scrollableFooterTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableFooterTable}`);
                this._resizeColGroup(scrollableHeaderTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
                this._resizeColGroup(scrollableBodyTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
                this._resizeColGroup(scrollableFooterTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
            }
            else {
                this._resizeColGroup(this.dt.tableViewChild.nativeElement, resizeColumnIndex, newColumnWidth, nextColumnWidth);
            }
            this._emitOnColResize(column, delta);
        }
    }
    _handleLeftSiblingOverlapResize(event, column) {
        const delta = Math.abs(this._getColumnResizeDelta(event, column));
        // Pass resizeColumnIndex + 1 to include current column in columns which be resized
        const resizeColumnIndex = DomHandler.index(column) + 1;
        const columnSiblingsWidths = [column.offsetWidth, ...this._getColumnSiblingsWidths(column, ResizeDirection.Left)];
        const newColumnWidth = column.nextElementSibling.offsetWidth + delta;
        this._resizeTableSections(column, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, ResizeDirection.Left);
        // Pass column.nextElementSibling because we resize not current column but it next sibling
        this._emitOnColResize(column.nextElementSibling, delta);
    }
    _handleRightSiblingOverlapResize(event, column) {
        const delta = Math.abs(this._getColumnResizeDelta(event, column));
        const resizeColumnIndex = DomHandler.index(column);
        const columnSiblingsWidths = this._getColumnSiblingsWidths(column, ResizeDirection.Right);
        const newColumnWidth = column.offsetWidth + delta;
        this._resizeTableSections(column, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, ResizeDirection.Right);
        this._emitOnColResize(column, delta);
    }
    _resizeTableSections(column, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection) {
        if (this.dt.scrollable) {
            const scrollableView = this.dt.findParentScrollableView(column);
            const scrollableBodyTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableBodyTable}`);
            const scrollableHeaderTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableHeaderTable}`);
            const scrollableFooterTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableFooterTable}`);
            this._resizeColGroupForSiblings(scrollableHeaderTable, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection);
            this._resizeColGroupForSiblings(scrollableBodyTable, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection);
            this._resizeColGroupForSiblings(scrollableFooterTable, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection);
        }
        else {
            this._resizeColGroupForSiblings(this.dt.tableViewChild.nativeElement, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection);
        }
    }
    _resizeColGroupForSiblings(table, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection) {
        if (table) {
            const colGroup = table.children[0].nodeName === 'COLGROUP' ? table.children[0] : null;
            if (colGroup) {
                const col = colGroup.children[resizeColumnIndex];
                let siblingCol = resizeDirection === ResizeDirection.Left
                    ? col.previousElementSibling
                    : col.nextElementSibling;
                const colWidthsData = this._recalculateColumnSiblingsWidths(delta, columnSiblingsWidths);
                const colWidths = colWidthsData.newWidths;
                const newWidth = newColumnWidth - colWidthsData.leftOver;
                const widthValue = (newWidth > this._minColResizeWidth ? newWidth : this._minColResizeWidth) + 'px';
                this._renderer.setStyle(col, 'width', widthValue);
                this._renderer.setAttribute(col, 'data-resized-width', widthValue);
                if (colWidths && colWidths.length) {
                    colWidths.forEach((width) => {
                        if (siblingCol) {
                            this._renderer.setStyle(siblingCol, 'width', (width > this._minColResizeWidth ? width : this._minColResizeWidth) + 'px');
                            this._renderer.setAttribute(siblingCol, 'data-resized-width', (width > this._minColResizeWidth ? width : this._minColResizeWidth) + 'px');
                            siblingCol = resizeDirection === ResizeDirection.Left
                                ? siblingCol.previousElementSibling
                                : siblingCol.nextElementSibling;
                        }
                    });
                }
            }
            else {
                adaptError('Scrollable tables require a colgroup to support resizable columns');
            }
        }
    }
    _recalculateColumnSiblingsWidths(delta, columnSiblingsWidths) {
        let leftOver = 0;
        const widthsSum = columnSiblingsWidths.reduce((prev, next) => prev + next, 0);
        const newWidths = columnSiblingsWidths.map(width => {
            const widthInPercents = width * 100 / widthsSum;
            const partFromDelta = delta * widthInPercents / 100;
            const newWidth = width - partFromDelta;
            if (newWidth > this._minColResizeWidth) {
                return newWidth;
            }
            else {
                leftOver += partFromDelta;
                return width;
            }
        });
        return { leftOver, newWidths };
    }
    _emitOnColResize(column, delta) {
        const widthMap = this.dt.dataHeaderCells.map(cell => {
            return {
                fields: cell.data.renderingColumn.columnsConfigs.map(col => col.field),
                width: round((cell.element.nativeElement.offsetWidth / this.dt.tableInnerContainer.nativeElement.offsetWidth) * 100, 2)
            };
        });
        this.columnResized.emit({
            element: column,
            delta: delta,
            columnsConfigState: widthMap
        });
    }
}
ResizableColumn.ɵfac = function ResizableColumn_Factory(t) { return new (t || ResizableColumn)(i0.ɵɵdirectiveInject(i1.AdaptTableComponent), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2)); };
ResizableColumn.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ResizableColumn, selectors: [["", "pResizableColumn", ""]], inputs: { pResizableColumnDisabled: "pResizableColumnDisabled" }, outputs: { columnResized: "columnResized" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ResizableColumn, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[pResizableColumn]'
            }]
    }], function () { return [{ type: i1.AdaptTableComponent }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }]; }, { pResizableColumnDisabled: [{
            type: Input
        }], columnResized: [{
            type: Output
        }] }); })();
//# sourceMappingURL=resizable-column.directive.js.map