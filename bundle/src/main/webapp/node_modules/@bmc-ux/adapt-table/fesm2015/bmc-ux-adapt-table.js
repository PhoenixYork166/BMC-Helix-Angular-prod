import { trigger, transition, style, animate, useAnimation } from '@angular/animations';
import * as i3 from '@angular/cdk/bidi';
import * as i3$1 from '@angular/cdk/drag-drop';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import { ENTER, ESCAPE, DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW, SPACE, TAB } from '@angular/cdk/keycodes';
import { ComponentPortal } from '@angular/cdk/portal';
import * as i0 from '@angular/core';
import { Injectable, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, ViewChild, Directive, ViewContainerRef, ElementRef, ViewEncapsulation, ViewChildren, HostBinding, Pipe, HostListener, NgModule, Version } from '@angular/core';
import * as i1 from '@bmc-ux/adapt-angular';
import { SafeCdr, getValueOrFunc, isDefined, adaptWarn, getOverlayConnectedPositions, adaptError, trueOrNull, hasKeyboardKeyCode, AdaptTooltipComponent, ANIMATION_DURATION, ANIMATION_TIMING_FUNCTION, isArray, AdaptRxSelectComponent, AdaptRxSelectConfigService, formatString, toNumber as toNumber$1, getEventKeyCode, AdaptFocusMonitorService, LoaderInOutType, AdaptBusyModule, ANIMATION_NAME, AdaptTooltipModule, AdaptRxSearchModule, AdaptRxSelectModule, AdaptDropdownModule, AdaptRxTextfieldModule, AdaptRxRadiobuttonModule, AdaptPopoverModule, AdaptEmptyStateModule, AdaptFocusHolderModule, AdaptAccordionModule, AdaptTagModule, AdaptRxCheckboxModule, AdaptResizeModule, AdaptListKeyManagerModule, AdaptButtonModule } from '@bmc-ux/adapt-angular';
import { isNil, isEmpty, isNull, debounce, flatten, isNumber, isFunction, merge, isUndefined, isArray as isArray$1, isString, toString, toNumber, round } from 'lodash-es';
import * as i2 from 'primeng/api';
import { FilterService } from 'primeng/api';
import { Subject, ReplaySubject, fromEvent, Observable, merge as merge$1, asyncScheduler } from 'rxjs';
import { takeUntil, take, debounceTime, switchMap, throttleTime, map, distinctUntilChanged } from 'rxjs/operators';
import { DomHandler } from 'primeng/dom';
import { ObjectUtils as ObjectUtils$1 } from 'primeng/utils';
import * as i2$1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i5 from '@angular/forms';
import { FormsModule } from '@angular/forms';
import * as i4 from '@angular/platform-browser';
import * as i2$2 from '@angular/cdk/a11y';
import * as i2$3 from '@angular/cdk/scrolling';
import { CdkVirtualScrollViewport, CdkVirtualForOf, ScrollingModule } from '@angular/cdk/scrolling';
import { PaginatorModule, Paginator } from 'primeng/paginator';

// TODO: Use Enum instead
class AdaptTableFilters {
}
AdaptTableFilters.SELECT_FILTER = 'selectFilter';
AdaptTableFilters.TEXT_FILTER = 'textFilter';
AdaptTableFilters.DEFAULT_FILTER = AdaptTableFilters.TEXT_FILTER;
/* Enums */
/**
 * The visibility priority of toolbar parts.
 * It is used to control which toolbar part will be hidden to the dropdown first in case there is no space for all of them.
 * The lowest number will be hidden last.
 */
var ToolbarItemsByPriority;
(function (ToolbarItemsByPriority) {
    /**
     * Global table search input
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["SEARCH"] = 0] = "SEARCH";
    /**
     * Selection limit that is based on "selectionLimit" property from the "ToolbarConfig"
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["SELECTION_LIMIT"] = 1] = "SELECTION_LIMIT";
    /**
     * Counter text(ex. "Records from 1 to 10 of 23")
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["COUNTER"] = 2] = "COUNTER";
    /**
     * Refresh button
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["REFRESH"] = 3] = "REFRESH";
    /**
     * Columns visibility control
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["VISIBLE_COLUMNS"] = 4] = "VISIBLE_COLUMNS";
    /**
     * Section for the custom filter(eg. for Advanced filter controlled by customer)
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["FILTER"] = 5] = "FILTER";
    /**
     * Section for the custom filtering results
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["FILTER_RESULTS"] = 6] = "FILTER_RESULTS";
    /**
     * Custom section from the left side
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["LEFT_CUSTOM"] = 7] = "LEFT_CUSTOM";
    /**
     * Custom section from the right side
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["RIGHT_CUSTOM"] = 8] = "RIGHT_CUSTOM";
    /**
     * Export control
     */
    ToolbarItemsByPriority[ToolbarItemsByPriority["EXPORT"] = 9] = "EXPORT";
})(ToolbarItemsByPriority || (ToolbarItemsByPriority = {}));
/**
 * Possible variants for the checkbox selection state
 */
var CheckboxState;
(function (CheckboxState) {
    /**
     * Row is not selected
     */
    CheckboxState[CheckboxState["Unselected"] = 0] = "Unselected";
    /**
     * Row is selected
     */
    CheckboxState[CheckboxState["Selected"] = 1] = "Selected";
    /**
     * Some rows are selected. This is used to show the selection state of the group or table itself
     */
    CheckboxState[CheckboxState["Indeterminate"] = 2] = "Indeterminate";
})(CheckboxState || (CheckboxState = {}));
/**
 * Represents the event source type for the [lazy] table
 * Can be useful to differentiate between the event source inside (onLazyLoad) to provide different behavior
 */
var AdaptTableEventSource;
(function (AdaptTableEventSource) {
    /**
     * Triggered when the lazy load is triggered on initialization. Depending on the "lazyLoadOnInit" property
     */
    AdaptTableEventSource["LazyOnInit"] = "lazyOnInit";
    /**
     * Triggered when single sorting is happening
     */
    AdaptTableEventSource["SingleSortChange"] = "singleSortChange";
    /**
     * Triggered when multi sorting is happening
     */
    AdaptTableEventSource["MultipleSortChange"] = "multipleSortChange";
    /**
     * Triggered when filtering is happening
     */
    AdaptTableEventSource["FilterChange"] = "filterChange";
    /**
     * @deprecated Not used anymore
     */
    AdaptTableEventSource["VirtualScroll"] = "virtualScroll";
    /**
     * Triggered when the page is changed
     */
    AdaptTableEventSource["PageChange"] = "pageChange";
    /**
     * Triggered when table "resetting"
     */
    AdaptTableEventSource["Reset"] = "reset";
    /**
     * Triggered when the table data can be loaded(ex. when user scrolls to the bottom of the table)
     */
    AdaptTableEventSource["LoadMore"] = "loadMore";
    /**
     * Triggered when the table is refreshing(ex. user click on the toolbar refresh button)
     */
    AdaptTableEventSource["Refresh"] = "refresh";
})(AdaptTableEventSource || (AdaptTableEventSource = {}));
var FilterMatchMode;
(function (FilterMatchMode) {
    /**
     * Check that the data is starts with the filter value
     */
    FilterMatchMode["startsWith"] = "startsWith";
    /**
     * Check that the data contains filter value
     */
    FilterMatchMode["contains"] = "contains";
    /**
     * Check that the data is ends with the filter value
     */
    FilterMatchMode["endsWith"] = "endsWith";
    /**
     * Check that the data is equal to the filter value
     * For the "date" type data comparing by the "getTime" method
     * For all other types comparing by the "toString" method
     */
    FilterMatchMode["equals"] = "equals";
    /**
     * Check that the data is not equal to the filter value
     * Opposite to "equals"
     */
    FilterMatchMode["notEquals"] = "notEquals";
    /**
     * Check that the data array contains the filter value by applying "equals" comparison from https://github.com/primefaces/primeng/blob/master/src/app/components/utils/objectutils.ts
     */
    FilterMatchMode["in"] = "in";
    /**
     * Check that the data is lower than the filter value
     */
    FilterMatchMode["lt"] = "lt";
    /**
     * Check that the data is lower than or equal to the filter value
     */
    FilterMatchMode["lte"] = "lte";
    /**
     * Check that the data is greater than the filter value
     */
    FilterMatchMode["gt"] = "gt";
    /**
     * Check that the data is greater than or equal to the filter value
     */
    FilterMatchMode["gte"] = "gte";
})(FilterMatchMode || (FilterMatchMode = {}));
/**
 * Represents allowed sorting directions
 */
var SortOrder;
(function (SortOrder) {
    /**
     * Sort in ascending order
     */
    SortOrder[SortOrder["Asc"] = 1] = "Asc";
    /**
     * Sort in descending order
     */
    SortOrder[SortOrder["Desc"] = -1] = "Desc";
})(SortOrder || (SortOrder = {}));
/**
 * Represents allowed storage types
 */
var StorageType;
(function (StorageType) {
    /**
     * Local storage
     */
    StorageType["Local"] = "local";
    /**
     * Session storage
     */
    StorageType["Session"] = "session";
})(StorageType || (StorageType = {}));
/**
 * Represents allowed sorting modes
 */
var SortMode;
(function (SortMode) {
    /**
     * Sort by single column
     */
    SortMode["Single"] = "single";
    /**
     * Sort by multiple columns
     */
    SortMode["Multiple"] = "multiple";
})(SortMode || (SortMode = {}));
/**
 * Represents allowed column resize modes
 */
var ResizeMode;
(function (ResizeMode) {
    /**
     * Change only width of 2 sibling columns by increasing one column and decreasing the other one
     */
    ResizeMode["Fit"] = "fit";
    /**
     * Change width of one column only and also increase the width of the table itself
     */
    ResizeMode["Expand"] = "expand";
})(ResizeMode || (ResizeMode = {}));
/**
 * Represents allowed column resize directions
 */
var ResizeDirection;
(function (ResizeDirection) {
    /**
     * Resize column to the left
     */
    ResizeDirection["Left"] = "left";
    /**
     * Resize column to the right
     */
    ResizeDirection["Right"] = "right";
})(ResizeDirection || (ResizeDirection = {}));
/**
 * List of html classes used in the table.
 *
 * Please be aware that class names can be changed so can't be used as constants while interacting with the table template
 */
var AdaptTableClasses;
(function (AdaptTableClasses) {
    /**
     * Always applied to the table host element(<adapt-table>)
     */
    AdaptTableClasses["Main"] = "adapt-grid";
    /**
     * Always applied to the table host element(<adapt-table>)
     */
    AdaptTableClasses["AdaptTable"] = "adapt-table";
    /**
     * Applied to the table host element(<adapt-table>) when the table has border, [bordered] is set to true
     */
    AdaptTableClasses["Bordered"] = "adapt-grid-bordered";
    /**
     * Applied to the table host element(<adapt-table>) when the table pagination is enabled, [paginator] is set to true
     */
    AdaptTableClasses["Pageable"] = "adapt-table-pageable";
    /**
     * Applied to the table host element(<adapt-table>) when the table has scrollable body, [scrollable] is set to true
     */
    AdaptTableClasses["Scrollable"] = "adapt-table-scrollable";
    /**
     * Applied to the table host element(<adapt-table>) when the table has striped rows, [striped] is set to true
     */
    AdaptTableClasses["Striped"] = "adapt-table--striped";
    /**
     * Applied to the table host element(<adapt-table>) when the table is empty, [value] is null or an empty array
     */
    AdaptTableClasses["IsEmptyState"] = "adapt-table--empty-state";
    /**
     * Applied to the table host element(<adapt-table>) when the table has no scrollable body, [scrollable] is set to false
     */
    AdaptTableClasses["NotScrollable"] = "adapt-table-not-scrollable";
    /**
     * ???
     */
    AdaptTableClasses["HasNotVerticalBodyOverflow"] = "adapt-table--has-not-overflow";
    /**
     * Applied to the table host element(<adapt-table>) when the table loading state is true, [loading] is set to true
     */
    AdaptTableClasses["LoadingFullTable"] = "adapt-grid--loading";
    /**
     * Applied to the table cell element for the column with actions
     */
    AdaptTableClasses["ActionsCell"] = "at-actions-cell";
    /**
     * Applied to the table cell element if column is editable
     */
    AdaptTableClasses["EditingCell"] = "at-cell--editing";
    /**
     * Always applied to the table element inside the table header element
     */
    AdaptTableClasses["HeaderContainer"] = "c-header-container";
    /**
     * Always applied to the table element inside the table header element
     */
    AdaptTableClasses["HeaderTitle"] = "c-header__title";
    /**
     * Always applied to the table header element
     */
    AdaptTableClasses["HeaderDataCell"] = "at-header-data-cell";
    /**
     * Always applied for scrollable body table parent container (in non-virtual scroll mode)
     */
    AdaptTableClasses["TableScrollableBody"] = "ui-table-scrollable-body";
    /**
     * Always applied for "cdk-virtual-scroll-viewport" (in virtual scroll mode)
     */
    AdaptTableClasses["TableVirtualScrollableBody"] = "ui-table-virtual-scrollable-body";
    /**
     * Always applied for scrollable header table parent container (in both modes, virtual scroll and non-virtual scroll)
     */
    AdaptTableClasses["TableScrollableHeader"] = "ui-table-scrollable-header";
    /**
     * Always applied for scrollable footer table parent container (in both modes, virtual scroll and non-virtual scroll)
     */
    AdaptTableClasses["TableScrollableFooter"] = "ui-table-scrollable-footer";
    /**
     * Always applied for scrollable body table element (in both modes, virtual scroll and non-virtual scroll)
     */
    AdaptTableClasses["TableScrollableBodyTable"] = "ui-table-scrollable-body-table";
    /**
     * Always applied for scrollable header table element (in both modes, virtual scroll and non-virtual scroll)
     */
    AdaptTableClasses["TableScrollableHeaderTable"] = "ui-table-scrollable-header-table";
    /**
     * Always applied for scrollable footer table element (in both modes, virtual scroll and non-virtual scroll)
     */
    AdaptTableClasses["TableScrollableFooterTable"] = "ui-table-scrollable-footer-table";
})(AdaptTableClasses || (AdaptTableClasses = {}));
/**
 * Represent if the column merged with other column or not
 */
var RenderingColumnType;
(function (RenderingColumnType) {
    /**
     * The column is not merged with other column
     */
    RenderingColumnType[RenderingColumnType["Simple"] = 1] = "Simple";
    /**
     * The column is merged with other column
     */
    RenderingColumnType[RenderingColumnType["Merged"] = 2] = "Merged";
})(RenderingColumnType || (RenderingColumnType = {}));
var AdaptTableHeaderCheckboxToggleSource;
(function (AdaptTableHeaderCheckboxToggleSource) {
    /**
     * The source of the event is "Select all" item
     */
    AdaptTableHeaderCheckboxToggleSource["SelectAll"] = "selectAll";
    /**
     * The source of the event is "Deselect all" item
     */
    AdaptTableHeaderCheckboxToggleSource["DeselectAll"] = "deselectAll";
    /**
     * The source of the event is "Select on page" item
     */
    AdaptTableHeaderCheckboxToggleSource["SelectOnPage"] = "selectOnPage";
    /**
     * @deprecated since 12.18.0
     * Not used anymore
     */
    AdaptTableHeaderCheckboxToggleSource["SelectVisible"] = "selectVisible";
})(AdaptTableHeaderCheckboxToggleSource || (AdaptTableHeaderCheckboxToggleSource = {}));
/**
 * @deprecated since 12.18.0
 * Not used anymore
 */
var AdaptTableSelectionMachineState;
(function (AdaptTableSelectionMachineState) {
    AdaptTableSelectionMachineState["unselected"] = "unselected";
    AdaptTableSelectionMachineState["selected"] = "selected";
    AdaptTableSelectionMachineState["indeterminate"] = "indeterminate";
})(AdaptTableSelectionMachineState || (AdaptTableSelectionMachineState = {}));
/**
 * Allowed values for the [headerSelectionMode] input
 */
var AdaptTableHeaderSelectionMode;
(function (AdaptTableHeaderSelectionMode) {
    /**
     * Allows to use both type of selection: "Select on page" and "Select all in table"
     */
    AdaptTableHeaderSelectionMode["Both"] = "both";
    /**
     * Allows to use only "Select on page" type of selection
     */
    AdaptTableHeaderSelectionMode["Chunk"] = "chunk";
    /**
     * Allows to use only "Select all in table" type of selection
     */
    AdaptTableHeaderSelectionMode["All"] = "all";
})(AdaptTableHeaderSelectionMode || (AdaptTableHeaderSelectionMode = {}));
/**
 * Allowed export formats
 */
var ExportType;
(function (ExportType) {
    /**
     * Export to CSV format
     */
    ExportType["CSV"] = "CSV";
    /**
     * Export to PDF format
     */
    ExportType["PDF"] = "PDF";
})(ExportType || (ExportType = {}));

class TableService {
    constructor() {
        this.sortSource = new Subject();
        this.selectionSource = new Subject();
        this.valueSource = new Subject();
        this.totalRecordsSource = new Subject();
        this.columnsSource = new Subject();
        this.viewRelatedDataSource = new Subject();
        this.sortSource$ = this.sortSource.asObservable();
        this.selectionSource$ = this.selectionSource.asObservable();
        this.valueSource$ = this.valueSource.asObservable();
        this.totalRecordsSource$ = this.totalRecordsSource.asObservable();
        this.columnsSource$ = this.columnsSource.asObservable();
        // The idea under the viewRelatedDataSource is to be triggered each time when the table view related data has changed
        this.viewRelatedDataSource$ = this.viewRelatedDataSource.asObservable();
    }
    onSort(sortMeta) {
        this.sortSource.next(sortMeta);
        this.onViewRelatedDataChange();
    }
    onSelectionChange(selection) {
        this.selectionSource.next(selection);
    }
    onValueChange(value) {
        this.valueSource.next(value);
        this.onViewRelatedDataChange();
    }
    onTotalRecordsChange(value) {
        this.totalRecordsSource.next(value);
    }
    onColumnsChange(columns) {
        this.columnsSource.next(columns);
        this.onViewRelatedDataChange();
    }
    onViewRelatedDataChange() {
        this.viewRelatedDataSource.next();
    }
}
TableService.ɵfac = function TableService_Factory(t) { return new (t || TableService)(); };
TableService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TableService, factory: TableService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TableService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

const _c0$d = ["container"];
const _c1$9 = ["resizeHelper"];
const _c2$7 = ["reorderIndicatorUp"];
const _c3$4 = ["reorderIndicatorDown"];
const _c4$3 = ["table"];
// eslint-disable-next-line @angular-eslint/component-class-suffix
class Table {
    constructor(el, zone, tableService, cd, filterService) {
        this.el = el;
        this.zone = zone;
        this.tableService = tableService;
        this.cd = cd;
        this.filterService = filterService;
        /**
         * Number of page links to display in paginator
         * @docs-default 5
         */
        this.pageLinks = 5;
        /**
         * Whether to show pagination even there is only one page
         * @docs-default true
         */
        this.alwaysShowPaginator = true;
        // TODO: use type instead of string (type PaginatorPosition = "top" | "bottom" | "both")
        /**
         * Position of the paginator, options are "top","bottom" or "both"
         * @docs-default 'bottom'
         */
        this.paginatorPosition = 'bottom';
        /**
         * Paginator dropdown height of the viewport in pixels, a scrollbar is defined if height of list exceeds this value
         * @docs-default '200px'
         */
        this.paginatorDropdownScrollHeight = '200px';
        /**
         * Template of the current page report element.
         * Available placeholders are {currentPage},{totalPages},{rows},{first},{last} and {totalRecords}
         * @docs-default '{currentPage} of {totalPages}'
         */
        this.currentPageReportTemplate = '{currentPage} of {totalPages}';
        // TODO: Use enum instead number (SortOrder {ASC: 1, DESC: -1})
        /**
         * Sort order to use when an unsorted column gets sorted by user interaction
         * @docs-default 1
         */
        this.defaultSortOrder = 1;
        // TODO: Use type instead number (type SortMode = 'single' | 'multiple')
        /**
         * Defines whether sorting works on single column or on multiple columns, valid values are "single" and "multiple"
         * @docs-default 'single'
         */
        this.sortMode = 'single';
        /**
         * When true, resets paginator to first page after sorting. Available only when sortMode is set to single
         * @docs-default true
         */
        this.resetPageOnSort = true;
        /**
         * Defines the behavior of context menu selection, in "separate" mode context menu updates contextMenuSelection propertty whereas in joint mode selection property is used instead so that when row selection is enabled, both row selection and context menu selection use the same property
         *
         * @deprecated since 12.18.0
         * Not used anymore
         *
         * @docs-default 'separate'
         */
        this.contextMenuSelectionMode = 'separate';
        /**
         * Defines if data is loaded and interacted with in lazy manner
         * @docs-default false
         */
        this.lazy = false;
        /**
         * Whether to call lazy loading on initialization
         * @docs-default true
         */
        this.lazyLoadOnInit = true;
        // TODO: Use type instead number (type ComparisonType = 'equals' | 'deepEquals')
        /**
         * Algorithm to define if a row is selected, valid values are "equals" that compares by reference and "deepEquals" that compares all fields
         * @docs-default 'deepEquals'
         */
        this.compareSelectionBy = 'deepEquals';
        /**
         * The map of FilterMetadata objects to provide external filters
         * The key of the map should be a "field" property from ColumnsConfig
         * @docs-default {}
         */
        this.filters = {};
        /**
         * Delay in milliseconds before filtering the data
         * @docs-default 300
         */
        this.filterDelay = 300;
        /**
         * Total records in filtering mode.
         * Used to separate total records in filtering and non-filtering modes
         * @docs-default null
         * @since 11.10.0
         */
        this.filteredTotalRecords = null;
        /**
         * Map instance to keep the expanded rows where key of the map is the data key of the row
         * @docs-default {}
         */
        this.expandedRowKeys = {};
        /**
         * Map instance to keep the rows being edited where key of the map is the data key of the row
         * @docs-default {}
         */
        this.editingRowKeys = {};
        // TODO: Use type instead number (type ExpandMode = 'single' | 'multiple')
        /**
         * Whether multiple rows can be expanded at any time. Valid values are "multiple" and "single"
         * @docs-default 'multiple'
         */
        this.rowExpandMode = 'multiple';
        /**
         * Threshold in milliseconds to delay lazy loading during scrolling
         * @docs-default 250
         */
        this.virtualScrollDelay = 250;
        /**
         * Height of a row to use in calculations of virtual scrolling
         * Additional information https://material.angular.io/cdk/scrolling/api
         * @docs-default 37
         */
        this.virtualRowHeight = 37;
        // TODO: Use "ResizeMode" enum instead string
        /**
         * Defines whether the overall table width should change on column resize, valid values are "fit" and "expand"
         * @docs-default 'fit'
         */
        this.columnResizeMode = 'fit';
        /**
         * The icon to show while indicating data load is in progress
         * @docs-default 'pi pi-spinner'
         */
        this.loadingIcon = 'pi pi-spinner';
        /**
         * Whether to show the loading mask when loading property is true
         * @docs-default true
         */
        this.showLoader = true;
        /**
         * Defines where a stateful table keeps its state, valid values are "session" for sessionStorage and "local" for localStorage
         *
         * @deprecated since 12.18.0
         * Not used anymore
         *
         * @docs-default 'session'
         */
        this.stateStorage = 'session';
        // TODO: Use type instead string (EditMode = 'cell' | 'row')
        /**
         * Defines the editing mode, valid values are "cell" and "row"
         * @docs-default 'cell'
         */
        this.editMode = 'cell';
        /**
         * Don't emit onLazyLoad event when changes Input value of 'sortField', 'sortOrder', 'multiSortMeta'.
         * Needs for avoiding double onLazyLoad event emitting in some cases
         *
         * @docs-default 'multiple'
         */
        this.dontEmitLazyLoadOnInputChange = true;
        /**
         * Triggered when "selection" changed. Means user selected or unselect rows
         */
        this.selectionChange = new EventEmitter();
        // TODO: Refactor this if possible
        /* eslint-disable @angular-eslint/no-output-on-prefix */
        /**
         * Callback to invoke when a row is selected
         */
        this.onRowSelect = new EventEmitter();
        /**
         * Callback to invoke when a row is unselected
         */
        this.onRowUnselect = new EventEmitter();
        /**
         * Callback to invoke when pagination occurs
         */
        this.onPage = new EventEmitter();
        /**
         * Callback to invoke when a column gets sorted
         */
        this.onSort = new EventEmitter();
        /**
         * Callback to invoke when data is filtered
         */
        this.onFilter = new EventEmitter();
        /**
         * Callback to invoke when paging, sorting or filtering happens in lazy mode
         */
        this.onLazyLoad = new EventEmitter();
        /**
         * Callback to invoke when a row is expanded
         */
        this.onRowExpand = new EventEmitter();
        /**
         * Callback to invoke when a row is collapsed
         */
        this.onRowCollapse = new EventEmitter();
        /**
         * Callback to invoke when a column is resized
         */
        this.onColResize = new EventEmitter();
        /**
         * Callback to invoke when a column is reordered
         */
        this.onColReorder = new EventEmitter();
        /**
         * Callback to invoke when state of header checkbox changes
         */
        this.onHeaderCheckboxToggle = new EventEmitter();
        /**
         * In case if [customSort] is set to true "sortFunction" output will be emitted.
         * Useful for custom sorting implementation
         */
        this.sortFunction = new EventEmitter();
        /**
         * Emit each time when [first] value changed
         */
        this.firstChange = new EventEmitter();
        /**
         * Emit each time when [rows] value changed
         */
        this.rowsChange = new EventEmitter();
        this._value = [];
        this._totalRecords = null;
        this._first = 0;
        this.selectionKeys = {};
        this._sortOrder = 1;
        /**
         * Angular trackBy function for table rows
         * @docs-default (index: number, item: RowData) => item
         */
        this.rowTrackBy = (index, item) => item;
    }
    /**
     * An array of objects to display
     * @docs-default []
     */
    get value() {
        return this._value;
    }
    set value(val) {
        this._value = val;
    }
    /**
     * An array of objects to represent dynamic columns
     * @docs-default
     */
    get columns() {
        return this._columns;
    }
    set columns(cols) {
        this._columns = cols;
    }
    /**
     * Index of the first row to be displayed
     * @docs-default 0
     */
    get first() {
        return this._first;
    }
    set first(val) {
        this._first = val;
    }
    /**
     * Number of rows to display per page
     * @docs-default
     */
    get rows() {
        return this._rows;
    }
    set rows(val) {
        this._rows = val;
    }
    // Used to separate totalRecords in filtering case and not
    get allTotalRecords() {
        /**
         * When there is no totalRecords info available(means that for some reasons customer doesn't know how many records are in the table)
         * we assume that totalRecords are at least on one record more than loaded records length until customer can set correct totalRecords value.
         *
         * This allows correctly calculate visibility of items in selection menu
         */
        if (isNil(this._totalRecords) && this.value) {
            return this.value.length + 1;
        }
        return this._totalRecords;
    }
    /**
     * Number of total records in the table
     * @docs-default null
     */
    get totalRecords() {
        var _a;
        return this.hasFilter() ? ((_a = this.filteredTotalRecords) !== null && _a !== void 0 ? _a : this._totalRecords) : this._totalRecords;
    }
    set totalRecords(val) {
        this._totalRecords = val;
        this.tableService.onTotalRecordsChange(this._totalRecords);
    }
    /**
     * Name of the field to sort data by default
     * @docs-default
     */
    get sortField() {
        return this._sortField;
    }
    set sortField(val) {
        this._sortField = val;
    }
    // TODO: Use enum instead number (SortOrder {ASC: 1, DESC: -1})
    /**
     * Order to sort when default sorting is enabled
     * 1 for ASC and -1 for DEC
     * @docs-default 1
     */
    get sortOrder() {
        return this._sortOrder;
    }
    set sortOrder(val) {
        this._sortOrder = val;
    }
    /**
     * An array of SortMeta objects to sort the data by default in multiple sort mode
     *
     * SortMeta {
     *     // The "field" property from the ColumnConfig
     *     field: string;
     *     // 1 for ASC and -1 for DEC
     *     order: number;
     * }
     *
     * @docs-default
     */
    get multiSortMeta() {
        return this._multiSortMeta;
    }
    set multiSortMeta(val) {
        this._multiSortMeta = val;
    }
    /**
     * Selected row in single mode or an array of values in multiple mode
     * @docs-default
     */
    get selection() {
        return this._selection;
    }
    set selection(val) {
        this._selection = val;
    }
    /* --- LIFECYCLES START --- */
    ngOnInit() {
        if (this.lazy && this.lazyLoadOnInit) {
            if (!this.virtualScroll) {
                this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.LazyOnInit));
            }
            if (this.restoringFilter) {
                this.restoringFilter = false;
            }
        }
        this.initialized = true;
    }
    ngOnChanges(simpleChange) {
        if (simpleChange.value) {
            this._value = simpleChange.value.currentValue;
            if (!this.lazy) {
                this.totalRecords = (this._value ? this._value.length : 0);
                if (this.sortMode === 'single' && this.sortField) {
                    this.sortSingle();
                }
                else if (this.sortMode === 'multiple' && this.multiSortMeta) {
                    this.sortMultiple();
                    // sort already filters
                }
                else if (this.hasFilter()) {
                    this._filter();
                }
            }
            this.tableService.onValueChange(simpleChange.value.currentValue);
        }
        if (simpleChange.columns) {
            this._columns = simpleChange.columns.currentValue;
            this.tableService.onColumnsChange(simpleChange.columns.currentValue);
        }
        if (simpleChange.sortField) {
            this._sortField = simpleChange.sortField.currentValue;
            // avoid triggering lazy load prior to lazy initialization at onInit
            if (!this.dontEmitLazyLoadOnInputChange && (!this.lazy || this.initialized)) {
                if (this.sortMode === 'single') {
                    this.sortSingle();
                }
            }
        }
        if (simpleChange.sortOrder) {
            this._sortOrder = simpleChange.sortOrder.currentValue;
            // avoid triggering lazy load prior to lazy initialization at onInit
            if (!this.dontEmitLazyLoadOnInputChange && (!this.lazy || this.initialized)) {
                if (this.sortMode === 'single') {
                    this.sortSingle();
                }
            }
        }
        if (simpleChange.multiSortMeta) {
            this._multiSortMeta = simpleChange.multiSortMeta.currentValue;
            if (!this.dontEmitLazyLoadOnInputChange && (this.sortMode === 'multiple')) {
                this.sortMultiple();
            }
        }
        if (simpleChange.selection) {
            this._selection = simpleChange.selection.currentValue;
            if (!this.preventSelectionSetterPropagation) {
                this.updateSelectionKeys();
                this.tableService.onSelectionChange(this._selection);
            }
            this.preventSelectionSetterPropagation = false;
        }
    }
    ngOnDestroy() {
        this.initialized = null;
    }
    /* --- LIFECYCLES END --- */
    /* ------------------------------------------------------------------ */
    toggleRowWithCheckbox(event, rowData) {
        this.selection = this.selection || [];
        const selected = this.isSelected(rowData);
        const dataKeyValue = this.dataKey ? String(ObjectUtils$1.resolveFieldData(rowData, this.dataKey)) : null;
        this.preventSelectionSetterPropagation = true;
        if (selected) {
            const selectionIndex = this.findIndexInSelection(rowData);
            this._selection = this.selection.filter((val, i) => i !== selectionIndex);
            this.selectionChange.emit(this.selection);
            this.onRowUnselect.emit({
                originalEvent: event.originalEvent,
                index: event.rowIndex,
                data: rowData,
                type: 'checkbox'
            });
            if (dataKeyValue) {
                delete this.selectionKeys[dataKeyValue];
            }
        }
        else {
            this._selection = this.selection ? [...this.selection, rowData] : [rowData];
            this.selectionChange.emit(this.selection);
            this.onRowSelect.emit({
                originalEvent: event.originalEvent,
                index: event.rowIndex,
                data: rowData,
                type: 'checkbox'
            });
            if (dataKeyValue) {
                this.selectionKeys[dataKeyValue] = 1;
            }
        }
        this.tableService.onSelectionChange(this._selection);
    }
    toggleRow(rowData, event) {
        if (!this.dataKey) {
            throw new Error('dataKey must be defined to use row expansion');
        }
        const dataKeyValue = String(ObjectUtils$1.resolveFieldData(rowData, this.dataKey));
        if (this.expandedRowKeys[dataKeyValue] != null) {
            delete this.expandedRowKeys[dataKeyValue];
            this.onRowCollapse.emit({
                originalEvent: event,
                data: rowData
            });
        }
        else {
            if (this.rowExpandMode === 'single') {
                this.expandedRowKeys = {};
            }
            this.expandedRowKeys[dataKeyValue] = true;
            this.onRowExpand.emit({
                originalEvent: event,
                data: rowData
            });
        }
        if (event) {
            event.preventDefault();
        }
        /*if (this.isStateful()) {
          this.saveState();
        }*/
    }
    /* --- ROW CLICK TOGGLE END --- */
    /* ------------------------------------------------------------------ */
    /* --- SELECTION START --- */
    isSingleSelectionMode() {
        return this.selectionMode === 'single';
    }
    isMultipleSelectionMode() {
        return this.selectionMode === 'multiple';
    }
    isSelected(rowData) {
        if (rowData && this.selection) {
            if (this.dataKey) {
                return this.selectionKeys[ObjectUtils$1.resolveFieldData(rowData, this.dataKey)] !== undefined;
            }
            else {
                if (this.selection instanceof Array) {
                    return this.findIndexInSelection(rowData) > -1;
                }
                else {
                    return this.equals(rowData, this.selection);
                }
            }
        }
        return false;
    }
    findIndexInSelection(rowData) {
        let index = -1;
        if (this.selection && this.selection.length) {
            for (let i = 0; i < this.selection.length; i++) {
                if (this.equals(rowData, this.selection[i])) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    }
    /* --- SELECTION START --- */
    /* ------------------------------------------------------------------ */
    /* --- SORTING START --- */
    sort(event) {
        const originalEvent = event.originalEvent;
        if (this.sortMode === 'single') {
            this._sortOrder = (this.sortField === event.field) ? this.sortOrder * -1 : this.defaultSortOrder;
            this._sortField = event.field;
            this.sortSingle();
            if (this.resetPageOnSort) {
                this._first = 0;
                this.firstChange.emit(this._first);
            }
        }
        if (this.sortMode === 'multiple') {
            const metaKey = originalEvent.metaKey || originalEvent.ctrlKey;
            const sortMeta = this.getSortMeta(event.field);
            if (sortMeta) {
                if (!metaKey) {
                    this._multiSortMeta = [{ field: event.field, order: sortMeta.order * -1 }];
                    if (this.resetPageOnSort) {
                        this._first = 0;
                        this.firstChange.emit(this._first);
                    }
                }
                else {
                    sortMeta.order = sortMeta.order * -1;
                }
            }
            else {
                if (!metaKey || !this.multiSortMeta) {
                    this._multiSortMeta = [];
                    if (this.resetPageOnSort) {
                        this._first = 0;
                        this.firstChange.emit(this._first);
                    }
                }
                this._multiSortMeta.push({ field: event.field, order: this.defaultSortOrder });
            }
            this.sortMultiple();
        }
        /*if (this.isStateful()) {
          this.saveState();
        }*/
        this.anchorRowIndex = null;
    }
    sortSingle() {
        if (this.sortField && this.sortOrder) {
            if (this.lazy) {
                this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.SingleSortChange));
            }
            else if (this.value) {
                if (this.customSort) {
                    this.sortFunction.emit({
                        data: this.value,
                        mode: this.sortMode,
                        field: this.sortField,
                        order: this.sortOrder
                    });
                }
                else {
                    this.value.sort((data1, data2) => {
                        const value1 = ObjectUtils$1.resolveFieldData(data1, this.sortField);
                        const value2 = ObjectUtils$1.resolveFieldData(data2, this.sortField);
                        let result = null;
                        if (value1 == null && value2 != null) {
                            result = -1;
                        }
                        else if (value1 != null && value2 == null) {
                            result = 1;
                        }
                        else if (value1 == null && value2 == null) {
                            result = 0;
                        }
                        else if (typeof value1 === 'string' && typeof value2 === 'string') {
                            result = value1.localeCompare(value2);
                        }
                        else {
                            result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
                        }
                        return (this.sortOrder * result);
                    });
                }
                if (this.hasFilter()) {
                    this._filter();
                }
            }
            const sortMeta = {
                field: this.sortField,
                order: this.sortOrder
            };
            this.onSort.emit(sortMeta);
            this.tableService.onSort(sortMeta);
        }
    }
    sortMultiple() {
        if (this.multiSortMeta) {
            if (this.lazy) {
                this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.MultipleSortChange));
            }
            else if (this.value) {
                if (this.customSort) {
                    this.sortFunction.emit({
                        data: this.value,
                        mode: this.sortMode,
                        multiSortMeta: this.multiSortMeta
                    });
                }
                else {
                    this.value.sort((data1, data2) => {
                        return this.multisortField(data1, data2, this.multiSortMeta, 0);
                    });
                }
                if (this.hasFilter()) {
                    this._filter();
                }
            }
            this.onSort.emit({
                multisortmeta: this.multiSortMeta
            });
            this.tableService.onSort(this.multiSortMeta);
        }
    }
    multisortField(data1, data2, multiSortMeta, index) {
        const value1 = ObjectUtils$1.resolveFieldData(data1, multiSortMeta[index].field);
        const value2 = ObjectUtils$1.resolveFieldData(data2, multiSortMeta[index].field);
        let result = null;
        if (value1 == null && value2 != null) {
            result = -1;
        }
        else if (value1 != null && value2 == null) {
            result = 1;
        }
        else if (value1 == null && value2 == null) {
            result = 0;
            // eslint-disable-next-line eqeqeq
        }
        else if (typeof value1 == 'string' || value1 instanceof String) {
            // eslint-disable-next-line eqeqeq
            if (value1.localeCompare && (value1 != value2)) {
                return (multiSortMeta[index].order * value1.localeCompare(value2));
            }
        }
        else {
            result = (value1 < value2) ? -1 : 1;
        }
        // eslint-disable-next-line eqeqeq
        if (value1 == value2) {
            return (multiSortMeta.length - 1) > (index) ? (this.multisortField(data1, data2, multiSortMeta, index + 1)) : 0;
        }
        return (multiSortMeta[index].order * result);
    }
    getSortMeta(field) {
        if (this.multiSortMeta && this.multiSortMeta.length) {
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (let i = 0; i < this.multiSortMeta.length; i++) {
                if (this.multiSortMeta[i].field === field) {
                    return this.multiSortMeta[i];
                }
            }
        }
        return null;
    }
    isSorted(field) {
        if (this.sortMode === 'single') {
            return (this.sortField && this.sortField === field);
        }
        else if (this.sortMode === 'multiple') {
            let sorted = false;
            if (this.multiSortMeta) {
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (let i = 0; i < this.multiSortMeta.length; i++) {
                    // eslint-disable-next-line eqeqeq
                    if (this.multiSortMeta[i].field == field) {
                        sorted = true;
                        break;
                    }
                }
            }
            return sorted;
        }
    }
    /* --- SORTING END --- */
    /* ------------------------------------------------------------------ */
    /* --- FILTERING START --- */
    // matchMode can't be FilterMatchMode enum because matchMode can be custom filtering mode string
    filter(value, field, matchMode) {
        if (this.filterTimeout) {
            clearTimeout(this.filterTimeout);
        }
        if (!this.isFilterBlank(value)) {
            this.filters[field] = { value: value, matchMode: matchMode };
        }
        else if (this.filters[field]) {
            delete this.filters[field];
        }
        this.filterTimeout = window.setTimeout(() => {
            this._filter();
            this.filterTimeout = null;
        }, this.filterDelay);
        this.anchorRowIndex = null;
    }
    filterGlobal(value, matchMode) {
        this.filter(value, 'global', matchMode);
    }
    isFilterBlank(filter) {
        if (filter !== null && filter !== undefined) {
            if ((typeof filter === 'string' && filter.trim().length === 0) || (filter instanceof Array && filter.length === 0)) {
                return true;
            }
            else {
                return false;
            }
        }
        return true;
    }
    _filter() {
        // TODO: Check do we need restoringFilter property!!!
        if (!this.restoringFilter) {
            this.first = 0;
            this.firstChange.emit(this.first);
        }
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.FilterChange));
        }
        else {
            if (!this.value) {
                return;
            }
            if (!this.hasFilter()) {
                this.filteredValue = null;
                this.totalRecords = this.value ? this.value.length : 0;
            }
            else {
                let globalFilterFieldsArray;
                if (this.filters.global) {
                    if (!this.columns && !this.globalFilterFields) {
                        throw new Error('Global filtering requires dynamic columns or globalFilterFields to be defined.');
                    }
                    else {
                        globalFilterFieldsArray = this.globalFilterFields || this.columns;
                    }
                }
                this.filteredValue = [];
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (let i = 0; i < this.value.length; i++) {
                    let localMatch = true;
                    let globalMatch = false;
                    let localFiltered = false;
                    for (const prop in this.filters) {
                        if (Object.prototype.hasOwnProperty.call(this.filters, prop) && prop !== 'global') {
                            localFiltered = true;
                            const filterMeta = this.filters[prop];
                            const filterField = prop;
                            const filterValue = filterMeta.value;
                            const filterMatchMode = filterMeta.matchMode || 'startsWith';
                            const dataFieldValue = ObjectUtils$1.resolveFieldData(this.value[i], filterField);
                            const filterConstraint = this.filterService.filters[filterMatchMode];
                            if (!filterConstraint(dataFieldValue, filterValue)) {
                                localMatch = false;
                            }
                            if (!localMatch) {
                                break;
                            }
                        }
                    }
                    if (this.filters['global'] && !globalMatch && globalFilterFieldsArray) {
                        // eslint-disable-next-line @typescript-eslint/prefer-for-of
                        for (let j = 0; j < globalFilterFieldsArray.length; j++) {
                            const globalFilterField = globalFilterFieldsArray[j].field || globalFilterFieldsArray[j];
                            globalMatch = this.filterService.filters[this.filters['global'].matchMode](ObjectUtils$1.resolveFieldData(this.value[i], globalFilterField), this.filters['global'].value);
                            if (globalMatch) {
                                break;
                            }
                        }
                    }
                    let matches;
                    if (this.filters['global']) {
                        matches = localFiltered ? (localFiltered && localMatch && globalMatch) : globalMatch;
                    }
                    else {
                        matches = localFiltered && localMatch;
                    }
                    if (matches) {
                        this.filteredValue.push(this.value[i]);
                    }
                }
                if (this.filteredValue.length === this.value.length) {
                    this.filteredValue = null;
                }
                this.filteredTotalRecords = this.filteredValue ? this.filteredValue.length : this.value ? this.value.length : 0;
            }
        }
        this.onFilter.emit({
            filters: this.filters,
            filteredValue: this.filteredValue || this.value
        });
        this.tableService.onValueChange(this.value);
        if (this.restoringFilter) {
            this.restoringFilter = false;
        }
        SafeCdr.markForCheck(this.cd);
    }
    hasFilter() {
        let empty = true;
        for (const prop in this.filters) {
            if (Object.prototype.hasOwnProperty.call(this.filters, prop)) {
                empty = false;
                break;
            }
        }
        return !empty;
    }
    /* --- FILTERING END --- */
    /* ------------------------------------------------------------------ */
    /* --- ROW EDITING START --- */
    initRowEdit(rowData) {
        const dataKeyValue = String(ObjectUtils$1.resolveFieldData(rowData, this.dataKey));
        this.editingRowKeys[dataKeyValue] = true;
    }
    saveRowEdit(rowData, rowElement) {
        if (DomHandler.find(rowElement, '.ng-invalid.ng-dirty').length === 0) {
            const dataKeyValue = String(ObjectUtils$1.resolveFieldData(rowData, this.dataKey));
            delete this.editingRowKeys[dataKeyValue];
        }
    }
    cancelRowEdit(rowData) {
        const dataKeyValue = String(ObjectUtils$1.resolveFieldData(rowData, this.dataKey));
        delete this.editingRowKeys[dataKeyValue];
    }
    isRowExpanded(rowData) {
        return this.expandedRowKeys[String(ObjectUtils$1.resolveFieldData(rowData, this.dataKey))] === true;
    }
    isRowEditing(rowData) {
        return this.editingRowKeys[String(ObjectUtils$1.resolveFieldData(rowData, this.dataKey))] === true;
    }
    /* --- ROW EDITING END --- */
    /* ------------------------------------------------------------------ */
    /* --- COLUMN RESIZE START --- */
    onColumnResizeBegin(event) {
        const containerLeft = DomHandler.getOffset(this.containerViewChild.nativeElement).left;
        this.lastResizerHelperX = (event.pageX - containerLeft + this.containerViewChild.nativeElement.scrollLeft);
        this.onColumnResize(event);
        event.preventDefault();
    }
    onColumnResize(event) {
        const containerLeft = DomHandler.getOffset(this.containerViewChild.nativeElement).left;
        DomHandler.addClass(this.containerViewChild.nativeElement, 'ui-unselectable-text');
        this.resizeHelperViewChild.nativeElement.style.height = this.containerViewChild.nativeElement.offsetHeight + 'px';
        this.resizeHelperViewChild.nativeElement.style.top = 0 + 'px';
        this.resizeHelperViewChild.nativeElement.style.left = (event.pageX - containerLeft + this.containerViewChild.nativeElement.scrollLeft) + 'px';
        this.resizeHelperViewChild.nativeElement.style.display = 'block';
    }
    /* --- COLUMN RESIZE END --- */
    /* ------------------------------------------------------------------ */
    /* --- COLUMN DRAG START --- */
    onColumnDragStart(event, columnElement) {
        this.reorderIconWidth = DomHandler.getHiddenElementOuterWidth(this.reorderIndicatorUpViewChild.nativeElement);
        this.reorderIconHeight = DomHandler.getHiddenElementOuterHeight(this.reorderIndicatorDownViewChild.nativeElement);
        this.draggedColumn = columnElement;
        event.dataTransfer.setData('text', 'b'); // For firefox
    }
    onColumnDragEnter(event, dropHeader) {
        if (this.reorderableColumns && this.draggedColumn && dropHeader && this.containerViewChild) {
            event.preventDefault();
            const containerOffset = DomHandler.getOffset(this.containerViewChild.nativeElement);
            const dropHeaderOffset = DomHandler.getOffset(dropHeader);
            // eslint-disable-next-line eqeqeq
            if (this.draggedColumn != dropHeader) {
                const dragIndex = DomHandler.indexWithinGroup(this.draggedColumn, 'preorderablecolumn');
                const dropIndex = DomHandler.indexWithinGroup(dropHeader, 'preorderablecolumn');
                const targetLeft = dropHeaderOffset.left - containerOffset.left;
                const columnCenter = dropHeaderOffset.left + dropHeader.offsetWidth / 2;
                this.reorderIndicatorUpViewChild.nativeElement.style.top
                    = dropHeaderOffset.top - containerOffset.top - (this.reorderIconHeight - 1) + 'px';
                this.reorderIndicatorDownViewChild.nativeElement.style.top
                    = dropHeaderOffset.top - containerOffset.top + dropHeader.offsetHeight + 'px';
                if (event.pageX > columnCenter) {
                    this.reorderIndicatorUpViewChild.nativeElement.style.left
                        = (targetLeft + dropHeader.offsetWidth - Math.ceil(this.reorderIconWidth / 2)) + 'px';
                    this.reorderIndicatorDownViewChild.nativeElement.style.left
                        = (targetLeft + dropHeader.offsetWidth - Math.ceil(this.reorderIconWidth / 2)) + 'px';
                    this.dropPosition = 1;
                }
                else {
                    this.reorderIndicatorUpViewChild.nativeElement.style.left = (targetLeft - Math.ceil(this.reorderIconWidth / 2)) + 'px';
                    this.reorderIndicatorDownViewChild.nativeElement.style.left = (targetLeft - Math.ceil(this.reorderIconWidth / 2)) + 'px';
                    this.dropPosition = -1;
                }
                if ((dropIndex - dragIndex === 1 && this.dropPosition === -1) || (dropIndex - dragIndex === -1 && this.dropPosition === 1)) {
                    this.reorderIndicatorUpViewChild.nativeElement.style.display = 'none';
                    this.reorderIndicatorDownViewChild.nativeElement.style.display = 'none';
                }
                else {
                    this.reorderIndicatorUpViewChild.nativeElement.style.display = 'block';
                    this.reorderIndicatorDownViewChild.nativeElement.style.display = 'block';
                }
            }
            else {
                event.dataTransfer.dropEffect = 'none';
            }
        }
    }
    onColumnDragLeave(event) {
        if (this.reorderableColumns && this.draggedColumn) {
            event.preventDefault();
            this.reorderIndicatorUpViewChild.nativeElement.style.display = 'none';
            this.reorderIndicatorDownViewChild.nativeElement.style.display = 'none';
        }
    }
    onColumnDrop(event, dropColumn) {
        event.preventDefault();
        if (this.draggedColumn) {
            const dragIndex = DomHandler.indexWithinGroup(this.draggedColumn, 'preorderablecolumn');
            let dropIndex = DomHandler.indexWithinGroup(dropColumn, 'preorderablecolumn');
            let allowDrop = (dragIndex !== dropIndex);
            if (allowDrop && ((dropIndex - dragIndex === 1 && this.dropPosition === -1)
                || (dragIndex - dropIndex === 1 && this.dropPosition === 1))) {
                allowDrop = false;
            }
            if (allowDrop && ((dropIndex < dragIndex && this.dropPosition === 1))) {
                dropIndex = dropIndex + 1;
            }
            if (allowDrop && ((dropIndex > dragIndex && this.dropPosition === -1))) {
                dropIndex = dropIndex - 1;
            }
            if (allowDrop) {
                // Because we can hide columns and dragging is used html elements,
                // we can have situation when column is hidden and indexes for columns object and columns html nodes are do not match.
                // To solve this issue sort columns object by visible columns Map and all hidden columns got to the end of array.
                const visibleColumns = this.columns.filter(c => !getValueOrFunc(c.hidden));
                ObjectUtils$1.reorderArray(visibleColumns, dragIndex, dropIndex);
                const visibleColumnsSortMap = new Map();
                visibleColumns.forEach((col, index) => {
                    visibleColumnsSortMap.set(col.field, index);
                });
                this.columns.sort((a, b) => {
                    const aIndex = isDefined(visibleColumnsSortMap.get(a.field))
                        ? visibleColumnsSortMap.get(a.field)
                        : visibleColumnsSortMap.size;
                    const bIndex = isDefined(visibleColumnsSortMap.get(b.field))
                        ? visibleColumnsSortMap.get(b.field)
                        : visibleColumnsSortMap.size;
                    return aIndex - bIndex;
                });
                this.onColReorder.emit({
                    dragIndex,
                    dropIndex,
                    columns: this.columns
                });
            }
            this.reorderIndicatorUpViewChild.nativeElement.style.display = 'none';
            this.reorderIndicatorDownViewChild.nativeElement.style.display = 'none';
            this.draggedColumn.draggable = false;
            this.draggedColumn = null;
            this.dropPosition = null;
        }
    }
    /* --- COLUMN DRAG END --- */
    /* ------------------------------------------------------------------ */
    /* --- OTHER START --- */
    isEmpty() {
        const data = this.filteredValue || this.value;
        // eslint-disable-next-line eqeqeq
        return data == null || data.length == 0;
    }
    getBlockableElement() {
        return this.el.nativeElement.children[0];
    }
    updateSelectionKeys() {
        if (this.dataKey && this._selection) {
            this.selectionKeys = {};
            if (Array.isArray(this._selection)) {
                for (const data of this._selection) {
                    this.selectionKeys[String(ObjectUtils$1.resolveFieldData(data, this.dataKey))] = 1;
                }
            }
            else {
                this.selectionKeys[String(ObjectUtils$1.resolveFieldData(this._selection, this.dataKey))] = 1;
            }
        }
    }
    onPageChange(event) {
        this.first = event.first;
        this.rows = event.rows;
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.PageChange));
        }
        this.onPage.emit({
            first: this.first,
            rows: this.rows
        });
        this.firstChange.emit(this.first);
        this.rowsChange.emit(this.rows);
        this.tableService.onValueChange(this.value);
        this.anchorRowIndex = null;
    }
    equals(data1, data2) {
        // TODO: Maybe there is a sense to use lodash isEqualWith instead of ObjectUtils.equals
        return this.compareSelectionBy === 'equals' ? (data1 === data2) : ObjectUtils$1.equals(data1, data2, this.dataKey);
    }
    createLazyLoadMetadata(eventSource) {
        return {
            eventSource,
            first: this.first,
            rows: this.rows,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            filters: this.filters,
            globalFilter: this.filters && this.filters['global'] ? this.filters['global'].value : null,
            multiSortMeta: this.multiSortMeta
        };
    }
    reset() {
        this._sortField = null;
        this._sortOrder = this.defaultSortOrder;
        this._multiSortMeta = null;
        this.tableService.onSort(null);
        this.filteredValue = null;
        this.filters = {};
        this.first = 0;
        this.firstChange.emit(this.first);
        if (this.lazy) {
            this.onLazyLoad.emit(this.createLazyLoadMetadata(AdaptTableEventSource.Reset));
        }
        else {
            this.totalRecords = (this._value ? this._value.length : 0);
        }
    }
    findParentScrollableView(column) {
        if (column) {
            let parent = column.parentElement;
            while (parent && !DomHandler.hasClass(parent, 'ui-table-scrollable-view')) {
                parent = parent.parentElement;
            }
            return parent;
        }
        else {
            return null;
        }
    }
}
Table.ɵfac = function Table_Factory(t) { return new (t || Table)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(TableService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.FilterService)); };
Table.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: Table, selectors: [["p-table"]], viewQuery: function Table_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$d, 5);
        i0.ɵɵviewQuery(_c1$9, 5);
        i0.ɵɵviewQuery(_c2$7, 5);
        i0.ɵɵviewQuery(_c3$4, 5);
        i0.ɵɵviewQuery(_c4$3, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.containerViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeHelperViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.reorderIndicatorUpViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.reorderIndicatorDownViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableViewChild = _t.first);
    } }, inputs: { value: "value", columns: "columns", first: "first", rows: "rows", totalRecords: "totalRecords", sortField: "sortField", sortOrder: "sortOrder", multiSortMeta: "multiSortMeta", selection: "selection", frozenColumns: "frozenColumns", frozenValue: "frozenValue", frozenWidth: "frozenWidth", style: "style", styleClass: "styleClass", tableStyle: "tableStyle", tableStyleClass: "tableStyleClass", paginator: "paginator", pageLinks: "pageLinks", rowsPerPageOptions: "rowsPerPageOptions", alwaysShowPaginator: "alwaysShowPaginator", paginatorPosition: "paginatorPosition", paginatorDropdownAppendTo: "paginatorDropdownAppendTo", paginatorDropdownScrollHeight: "paginatorDropdownScrollHeight", currentPageReportTemplate: "currentPageReportTemplate", showCurrentPageReport: "showCurrentPageReport", defaultSortOrder: "defaultSortOrder", sortMode: "sortMode", resetPageOnSort: "resetPageOnSort", selectionMode: "selectionMode", contextMenuSelectionMode: "contextMenuSelectionMode", dataKey: "dataKey", metaKeySelection: "metaKeySelection", lazy: "lazy", lazyLoadOnInit: "lazyLoadOnInit", compareSelectionBy: "compareSelectionBy", filters: "filters", globalFilterFields: "globalFilterFields", filterDelay: "filterDelay", filteredTotalRecords: "filteredTotalRecords", expandedRowKeys: "expandedRowKeys", editingRowKeys: "editingRowKeys", rowExpandMode: "rowExpandMode", scrollable: "scrollable", scrollHeight: "scrollHeight", virtualScroll: "virtualScroll", virtualScrollDelay: "virtualScrollDelay", virtualRowHeight: "virtualRowHeight", responsive: "responsive", resizableColumns: "resizableColumns", columnResizeMode: "columnResizeMode", reorderableColumns: "reorderableColumns", loadingIcon: "loadingIcon", showLoader: "showLoader", rowHover: "rowHover", customSort: "customSort", autoLayout: "autoLayout", exportFunction: "exportFunction", stateKey: "stateKey", stateStorage: "stateStorage", editMode: "editMode", dontEmitLazyLoadOnInputChange: "dontEmitLazyLoadOnInputChange", rowTrackBy: "rowTrackBy" }, outputs: { selectionChange: "selectionChange", onRowSelect: "onRowSelect", onRowUnselect: "onRowUnselect", onPage: "onPage", onSort: "onSort", onFilter: "onFilter", onLazyLoad: "onLazyLoad", onRowExpand: "onRowExpand", onRowCollapse: "onRowCollapse", onColResize: "onColResize", onColReorder: "onColReorder", onHeaderCheckboxToggle: "onHeaderCheckboxToggle", sortFunction: "sortFunction", firstChange: "firstChange", rowsChange: "rowsChange" }, features: [i0.ɵɵProvidersFeature([FilterService]), i0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function Table_Template(rf, ctx) { }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(Table, [{
        type: Component,
        args: [{
                // eslint-disable-next-line @angular-eslint/component-selector
                selector: 'p-table',
                template: '',
                changeDetection: ChangeDetectionStrategy.Default,
                providers: [FilterService]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: TableService }, { type: i0.ChangeDetectorRef }, { type: i2.FilterService }]; }, { value: [{
            type: Input
        }], columns: [{
            type: Input
        }], first: [{
            type: Input
        }], rows: [{
            type: Input
        }], totalRecords: [{
            type: Input
        }], sortField: [{
            type: Input
        }], sortOrder: [{
            type: Input
        }], multiSortMeta: [{
            type: Input
        }], selection: [{
            type: Input
        }], frozenColumns: [{
            type: Input
        }], frozenValue: [{
            type: Input
        }], frozenWidth: [{
            type: Input
        }], style: [{
            type: Input
        }], styleClass: [{
            type: Input
        }], tableStyle: [{
            type: Input
        }], tableStyleClass: [{
            type: Input
        }], paginator: [{
            type: Input
        }], pageLinks: [{
            type: Input
        }], rowsPerPageOptions: [{
            type: Input
        }], alwaysShowPaginator: [{
            type: Input
        }], paginatorPosition: [{
            type: Input
        }], paginatorDropdownAppendTo: [{
            type: Input
        }], paginatorDropdownScrollHeight: [{
            type: Input
        }], currentPageReportTemplate: [{
            type: Input
        }], showCurrentPageReport: [{
            type: Input
        }], defaultSortOrder: [{
            type: Input
        }], sortMode: [{
            type: Input
        }], resetPageOnSort: [{
            type: Input
        }], selectionMode: [{
            type: Input
        }], contextMenuSelectionMode: [{
            type: Input
        }], dataKey: [{
            type: Input
        }], metaKeySelection: [{
            type: Input
        }], lazy: [{
            type: Input
        }], lazyLoadOnInit: [{
            type: Input
        }], compareSelectionBy: [{
            type: Input
        }], filters: [{
            type: Input
        }], globalFilterFields: [{
            type: Input
        }], filterDelay: [{
            type: Input
        }], filteredTotalRecords: [{
            type: Input
        }], expandedRowKeys: [{
            type: Input
        }], editingRowKeys: [{
            type: Input
        }], rowExpandMode: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], scrollHeight: [{
            type: Input
        }], virtualScroll: [{
            type: Input
        }], virtualScrollDelay: [{
            type: Input
        }], virtualRowHeight: [{
            type: Input
        }], responsive: [{
            type: Input
        }], resizableColumns: [{
            type: Input
        }], columnResizeMode: [{
            type: Input
        }], reorderableColumns: [{
            type: Input
        }], loadingIcon: [{
            type: Input
        }], showLoader: [{
            type: Input
        }], rowHover: [{
            type: Input
        }], customSort: [{
            type: Input
        }], autoLayout: [{
            type: Input
        }], exportFunction: [{
            type: Input
        }], stateKey: [{
            type: Input
        }], stateStorage: [{
            type: Input
        }], editMode: [{
            type: Input
        }], dontEmitLazyLoadOnInputChange: [{
            type: Input
        }], selectionChange: [{
            type: Output
        }], onRowSelect: [{
            type: Output
        }], onRowUnselect: [{
            type: Output
        }], onPage: [{
            type: Output
        }], onSort: [{
            type: Output
        }], onFilter: [{
            type: Output
        }], onLazyLoad: [{
            type: Output
        }], onRowExpand: [{
            type: Output
        }], onRowCollapse: [{
            type: Output
        }], onColResize: [{
            type: Output
        }], onColReorder: [{
            type: Output
        }], onHeaderCheckboxToggle: [{
            type: Output
        }], sortFunction: [{
            type: Output
        }], firstChange: [{
            type: Output
        }], rowsChange: [{
            type: Output
        }], containerViewChild: [{
            type: ViewChild,
            args: ['container', { static: false }]
        }], resizeHelperViewChild: [{
            type: ViewChild,
            args: ['resizeHelper', { static: false }]
        }], reorderIndicatorUpViewChild: [{
            type: ViewChild,
            args: ['reorderIndicatorUp', { static: false }]
        }], reorderIndicatorDownViewChild: [{
            type: ViewChild,
            args: ['reorderIndicatorDown', { static: false }]
        }], tableViewChild: [{
            type: ViewChild,
            args: ['table', { static: false }]
        }], rowTrackBy: [{
            type: Input
        }] }); })();

class AdaptDataDirective {
    constructor(element) {
        this.element = element;
    }
}
AdaptDataDirective.ɵfac = function AdaptDataDirective_Factory(t) { return new (t || AdaptDataDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptDataDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptDataDirective, selectors: [["", "adaptData", ""]], inputs: { data: ["adaptData", "data"] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDataDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptData]',
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, { data: [{
            type: Input,
            args: ['adaptData']
        }] }); })();

class AdaptTableDeprecationMiddleware {
    init(table) {
        this._table = table;
        this._updateTexts();
    }
    _updateTexts() {
        if (this._table.texts) {
            return;
        }
        if (this._table.tableTexts
            || this._table.paginationTexts
            || this._table.toolbarTexts
            || !isEmpty(this._table.filtersTexts)
            || this._table.headerCellMenuTexts) {
            this._table.texts = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this._table.tableTexts), this._table.paginationTexts), this._table.toolbarTexts), this._table.filtersTexts), this._table.headerCellMenuTexts);
            adaptWarn('[paginationTexts], [toolbarTexts], [tableTexts], [filtersTexts], [headerCellMenuTexts] are deprecated from v8.26.1. Use [texts] instead');
        }
    }
}
AdaptTableDeprecationMiddleware.ɵfac = function AdaptTableDeprecationMiddleware_Factory(t) { return new (t || AdaptTableDeprecationMiddleware)(); };
AdaptTableDeprecationMiddleware.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptTableDeprecationMiddleware, factory: AdaptTableDeprecationMiddleware.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableDeprecationMiddleware, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

function hasRowGroupedData(dataItem) {
    return !!(dataItem.groupValue !== undefined && dataItem.items);
}

// TODO: Refactor this if possible
/* eslint-disable @typescript-eslint/no-explicit-any */
const ObjectUtils = {
    // copied logic from primeng utils
    resolveFieldData(data, field) {
        if (data && field) {
            if (typeof field === 'function') {
                return field(data);
            }
            else if (field.indexOf('.') === -1) {
                return data[field];
            }
            else {
                const fields = field.split('.');
                let value = data;
                for (let i = 0, len = fields.length; i < len; ++i) {
                    if (value == null) {
                        return null;
                    }
                    value = value[fields[i]];
                }
                return value;
            }
        }
        else {
            return null;
        }
    }
};
// TODO: use the adapt version after the package update
const HtmlUtils = {
    hasShrunkText(element) {
        return element.offsetWidth < element.scrollWidth;
    },
};

const _c0$c = ["emptyStateTdEl"];
const _c1$8 = ["toolbarComponent"];
const _c2$6 = ["tooltipContainerEl"];
const _c3$3 = ["infiniteScrollingLoaderContainerEl"];
const _c4$2 = ["tableContainer"];
const _c5$2 = ["tableInnerContainer"];
const _c6$2 = ["tableHeader"];
const _c7$2 = ["table"];
const _c8$2 = ["tableBodyTemplateRef"];
const _c9$2 = ["tableHeaderTemplateRef"];
const _c10$2 = ["tableColgroupTemplateRef"];
const _c11$2 = ["tableEmptyMessageTemplateRef"];
const _c12$1 = ["rowExpansionTemplate"];
const _c13 = ["dataRow"];
const _c14 = ["dataCell"];
const _c15 = ["dataHeaderCell"];
const _c16 = ["actionColElement"];
function AdaptTableComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 32);
} }
function AdaptTableComponent_div_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 33);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelement(2, "i");
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassMap("ui-table-loading-icon pi-spin " + ctx_r2.loadingIcon);
} }
function AdaptTableComponent_adapt_table_toolbar_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-table-toolbar", 34, 35);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("config", ctx_r3.toolbarConfig)("texts", ctx_r3.texts);
} }
function AdaptTableComponent_div_19_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptTableComponent_div_19_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptTableComponent_div_19_tfoot_15_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
const _c17 = function (a0) { return { $implicit: a0 }; };
function AdaptTableComponent_div_19_tfoot_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "tfoot", 44);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵtemplate(2, AdaptTableComponent_div_19_tfoot_15_ng_container_2_Template, 1, 0, "ng-container", 39);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r43 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r43.footerTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c17, ctx_r43.columns));
} }
function AdaptTableComponent_div_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 36);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "table", 37, 38);
    i0.ɵɵtext(4, "\n              ");
    i0.ɵɵtemplate(5, AdaptTableComponent_div_19_ng_container_5_Template, 1, 0, "ng-container", 39);
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵelementStart(7, "thead", 40, 41);
    i0.ɵɵtext(9, "\n              ");
    i0.ɵɵtemplate(10, AdaptTableComponent_div_19_ng_container_10_Template, 1, 0, "ng-container", 39);
    i0.ɵɵtext(11, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n              ");
    i0.ɵɵelement(13, "tbody", 42);
    i0.ɵɵtext(14, "\n              ");
    i0.ɵɵtemplate(15, AdaptTableComponent_div_19_tfoot_15_Template, 4, 4, "tfoot", 43);
    i0.ɵɵtext(16, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", ctx_r6.tableStyleClass)("ngStyle", ctx_r6.tableStyle);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r6.colGroupTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(9, _c17, ctx_r6.columns));
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r6.headerTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(11, _c17, ctx_r6.columns));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("pTableBody", ctx_r6.columns)("pTableBodyTemplate", ctx_r6.bodyTemplate);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.footerTemplate);
} }
const _c18 = function (a0) { return { width: a0 }; };
function AdaptTableComponent_div_21_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 48);
} if (rf & 2) {
    const ctx_r45 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("pScrollableView", ctx_r45.frozenColumns)("frozen", true)("ngStyle", i0.ɵɵpureFunction1(4, _c18, ctx_r45.frozenWidth))("scrollHeight", ctx_r45.scrollHeight);
} }
const _c19 = function (a0, a1) { return { left: a0, width: a1 }; };
function AdaptTableComponent_div_21_Template(rf, ctx) { if (rf & 1) {
    const _r47 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 45);
    i0.ɵɵlistener("elementResize", function AdaptTableComponent_div_21_Template_div_elementResize_0_listener() { i0.ɵɵrestoreView(_r47); const ctx_r46 = i0.ɵɵnextContext(); return ctx_r46.handleScrollableWrapperResizing(); });
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptTableComponent_div_21_div_2_Template, 1, 6, "div", 46);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelement(4, "div", 47);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r7.frozenColumns || ctx_r7.frozenBodyTemplate);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("pScrollableView", ctx_r7.columns)("frozen", false)("scrollHeight", ctx_r7.scrollHeight)("ngStyle", i0.ɵɵpureFunction2(5, _c19, ctx_r7.frozenWidth, "calc(100% - " + ctx_r7.frozenWidth + ")"));
} }
const _c20 = function (a0) { return { height: a0 }; };
function AdaptTableComponent_div_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 49);
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(2, _c20, ctx_r8.tableBodyHeight))("@dataRefreshAnimation", undefined);
} }
function AdaptTableComponent_adapt_paginator_27_Template(rf, ctx) { if (rf & 1) {
    const _r49 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-paginator", 50);
    i0.ɵɵlistener("onPageChange", function AdaptTableComponent_adapt_paginator_27_Template_adapt_paginator_onPageChange_0_listener($event) { i0.ɵɵrestoreView(_r49); const ctx_r48 = i0.ɵɵnextContext(); return ctx_r48.onPageChange($event); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext();
    i0.ɵɵproperty("rows", ctx_r9.rows)("first", ctx_r9.first)("totalRecords", ctx_r9.totalRecords)("pageLinkSize", ctx_r9.pageLinks)("alwaysShow", ctx_r9.alwaysShowPaginator)("rowsPerPageOptions", ctx_r9.rowsPerPageOptions)("dropdownAppendTo", ctx_r9.paginatorDropdownAppendTo)("currentPageReportTemplate", ctx_r9.currentPageReportTemplate)("showCurrentPageReport", ctx_r9.showCurrentPageReport)("texts", ctx_r9.texts)("paginatorAlign", ctx_r9.paginatorAlign)("ngClass", ctx_r9.paginatorClass);
} }
function AdaptTableComponent_div_29_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 51, 52);
} }
function AdaptTableComponent_span_31_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 53, 54);
} }
function AdaptTableComponent_span_33_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 55, 56);
} }
function AdaptTableComponent_div_36_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 57);
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngBusy", ctx_r13.busyConfig)("adaptRadarDisableEventSending", true);
} }
function AdaptTableComponent_ng_template_45_col_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "col", 64);
} }
function AdaptTableComponent_ng_template_45_col_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "col", 65);
} }
function AdaptTableComponent_ng_template_45_col_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "col", 66);
} }
function AdaptTableComponent_ng_template_45_col_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "col", 67);
} }
function AdaptTableComponent_ng_template_45_ng_template_11_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
} }
function AdaptTableComponent_ng_template_45_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_45_ng_template_11_ng_template_1_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    const columns_r53 = i0.ɵɵnextContext().$implicit;
    const ctx_r58 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r58.dataColumnsColsTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c17, columns_r53));
} }
function AdaptTableComponent_ng_template_45_ng_template_13_ng_container_1_col_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "col", 72, 73);
} if (rf & 2) {
    const _r67 = i0.ɵɵreference(1);
    const renderingColumn_r64 = i0.ɵɵnextContext().$implicit;
    const ctx_r65 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("ngStyle", ctx_r65.getColumnStyles(renderingColumn_r64.columnsConfigs[0], _r67));
} }
function AdaptTableComponent_ng_template_45_ng_template_13_ng_container_1_col_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "col", 74, 75);
} if (rf & 2) {
    const renderingColumn_r64 = i0.ɵɵnextContext().$implicit;
    const ctx_r66 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("ngStyle", ctx_r66.getColumnStyles(renderingColumn_r64.columnsConfigs[0]));
} }
function AdaptTableComponent_ng_template_45_ng_template_13_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_45_ng_template_13_ng_container_1_col_2_Template, 2, 1, "col", 70);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵtemplate(4, AdaptTableComponent_ng_template_45_ng_template_13_ng_container_1_col_4_Template, 2, 1, "col", 71);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const renderingColumn_r64 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !renderingColumn_r64.columnsConfigs[0].actionsConfig);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !!renderingColumn_r64.columnsConfigs[0].actionsConfig);
} }
function AdaptTableComponent_ng_template_45_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_45_ng_template_13_ng_container_1_Template, 6, 2, "ng-container", 69);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    const columns_r53 = i0.ɵɵnextContext().$implicit;
    const ctx_r60 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r60.getColumnsForRendering(columns_r53))("ngForTrackBy", ctx_r60.trackByForRenderingColumns);
} }
function AdaptTableComponent_ng_template_45_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "colgroup");
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_45_col_3_Template, 1, 0, "col", 58);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵtemplate(5, AdaptTableComponent_ng_template_45_col_5_Template, 1, 0, "col", 59);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵtemplate(7, AdaptTableComponent_ng_template_45_col_7_Template, 1, 0, "col", 60);
    i0.ɵɵtext(8, "\n        ");
    i0.ɵɵtemplate(9, AdaptTableComponent_ng_template_45_col_9_Template, 1, 0, "col", 61);
    i0.ɵɵtext(10, "\n\n        ");
    i0.ɵɵtemplate(11, AdaptTableComponent_ng_template_45_ng_template_11_Template, 3, 4, "ng-template", 62);
    i0.ɵɵtext(12, "\n\n        ");
    i0.ɵɵtemplate(13, AdaptTableComponent_ng_template_45_ng_template_13_Template, 3, 2, "ng-template", null, 63, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(15, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n    ");
} if (rf & 2) {
    const _r59 = i0.ɵɵreference(14);
    const ctx_r17 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r17.enableReorderableRows);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r17.isSingleSelectionMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r17.hasExpandingBtn);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r17.isMultipleSelectionMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r17.dataColumnsColsTemplate)("ngIfElse", _r59);
} }
function AdaptTableComponent_ng_template_49_ng_template_1_ng_template_3_Template(rf, ctx) { }
function AdaptTableComponent_ng_template_49_ng_template_1_ng_template_5_Template(rf, ctx) { }
function AdaptTableComponent_ng_template_49_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelementStart(1, "tr", 77);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_49_ng_template_1_ng_template_3_Template, 0, 0, "ng-template", 79);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵtemplate(5, AdaptTableComponent_ng_template_49_ng_template_1_ng_template_5_Template, 0, 0, "ng-template", 68);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n      ");
} if (rf & 2) {
    const columns_r72 = i0.ɵɵnextContext().$implicit;
    const ctx_r73 = i0.ɵɵnextContext();
    const _r22 = i0.ɵɵreference(56);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("at-header-row_bordered", ctx_r73.bordered);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r22);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r73.headerGroupsTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(5, _c17, ctx_r73.getColumnsForRendering(columns_r72)));
} }
function AdaptTableComponent_ng_template_49_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
} }
function AdaptTableComponent_ng_template_49_ng_template_7_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
} }
function AdaptTableComponent_ng_template_49_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_49_ng_template_7_ng_template_1_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    const columns_r72 = i0.ɵɵnextContext().$implicit;
    const ctx_r75 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r75.dataColumnsHeaderTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c17, columns_r72));
} }
function AdaptTableComponent_ng_template_49_ng_template_9_ng_container_1_th_2_Template(rf, ctx) { if (rf & 1) {
    const _r90 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "th", 82, 83);
    i0.ɵɵlistener("columnResized", function AdaptTableComponent_ng_template_49_ng_template_9_ng_container_1_th_2_Template_th_columnResized_0_listener($event) { i0.ɵɵrestoreView(_r90); const ctx_r89 = i0.ɵɵnextContext(4); return ctx_r89.handleColumnResized($event); });
    i0.ɵɵtext(2, "\n              ");
    i0.ɵɵelement(3, "adapt-table-header-cell", 84);
    i0.ɵɵtext(4, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r91 = i0.ɵɵnextContext();
    const renderingColumn_r84 = ctx_r91.$implicit;
    const index_r85 = ctx_r91.index;
    const ctx_r86 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate1("at-header-cell ", ctx_r86.tableClasses.HeaderDataCell, "");
    i0.ɵɵproperty("pResizableColumnDisabled", !ctx_r86.resizableColumns || ctx_r86.isColumnFrozen(renderingColumn_r84.columnsConfigs[0]))("pReorderableColumnDisabled", !ctx_r86.reorderableColumns || ctx_r86.isColumnFrozen(renderingColumn_r84.columnsConfigs[0]))("adaptFrozen", ctx_r86.isColumnFrozen(renderingColumn_r84.columnsConfigs[0]))("adaptData", ctx_r86.getHeaderDataCellDirectiveParams(renderingColumn_r84, index_r85))("ngClass", ctx_r86.getHeaderClass(renderingColumn_r84.columnsConfigs[0]));
    i0.ɵɵattribute("data-testid", renderingColumn_r84.columnsConfigs[0].testId || renderingColumn_r84.columnsConfigs[0].columnAdaptID);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("renderingColumn", renderingColumn_r84)("index", index_r85)("texts", ctx_r86.texts);
} }
function AdaptTableComponent_ng_template_49_ng_template_9_ng_container_1_th_4_Template(rf, ctx) { if (rf & 1) {
    const _r94 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "th", 85, 83);
    i0.ɵɵlistener("columnResized", function AdaptTableComponent_ng_template_49_ng_template_9_ng_container_1_th_4_Template_th_columnResized_0_listener($event) { i0.ɵɵrestoreView(_r94); const ctx_r93 = i0.ɵɵnextContext(4); return ctx_r93.handleColumnResized($event); });
    i0.ɵɵtext(2, "\n              ");
    i0.ɵɵelement(3, "adapt-table-header-cell", 84);
    i0.ɵɵtext(4, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r95 = i0.ɵɵnextContext();
    const renderingColumn_r84 = ctx_r95.$implicit;
    const index_r85 = ctx_r95.index;
    const ctx_r87 = i0.ɵɵnextContext(3);
    i0.ɵɵclassMapInterpolate1("at-header-cell ", ctx_r87.tableClasses.HeaderDataCell, "");
    i0.ɵɵproperty("pResizableColumnDisabled", !ctx_r87.resizableColumns)("pReorderableColumnDisabled", !ctx_r87.reorderableColumns)("adaptData", ctx_r87.getHeaderDataCellDirectiveParams(renderingColumn_r84, index_r85))("ngClass", ctx_r87.getMergedHeaderClass(renderingColumn_r84.columnsConfigs));
    i0.ɵɵattribute("data-testid", renderingColumn_r84.columnsConfigs[0].testId || renderingColumn_r84.columnsConfigs[0].columnAdaptID);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("renderingColumn", renderingColumn_r84)("index", index_r85)("texts", ctx_r87.texts);
} }
function AdaptTableComponent_ng_template_49_ng_template_9_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_49_ng_template_9_ng_container_1_th_2_Template, 5, 12, "th", 80);
    i0.ɵɵtext(3, "\n\n\n            ");
    i0.ɵɵtemplate(4, AdaptTableComponent_ng_template_49_ng_template_9_ng_container_1_th_4_Template, 5, 11, "th", 81);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const renderingColumn_r84 = ctx.$implicit;
    const ctx_r83 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", renderingColumn_r84.type === ctx_r83.RenderingColumnType.Simple);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", renderingColumn_r84.type === ctx_r83.RenderingColumnType.Merged);
} }
function AdaptTableComponent_ng_template_49_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_49_ng_template_9_ng_container_1_Template, 6, 2, "ng-container", 69);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    const columns_r72 = i0.ɵɵnextContext().$implicit;
    const ctx_r77 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r77.getColumnsForRendering(columns_r72))("ngForTrackBy", ctx_r77.trackByForRenderingColumns);
} }
function AdaptTableComponent_ng_template_49_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_49_ng_template_1_Template, 8, 7, "ng-template", 76);
    i0.ɵɵtext(2, "\n\n\n      ");
    i0.ɵɵelementStart(3, "tr", 77);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵtemplate(5, AdaptTableComponent_ng_template_49_ng_template_5_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(6, "\n\n        ");
    i0.ɵɵtemplate(7, AdaptTableComponent_ng_template_49_ng_template_7_Template, 3, 4, "ng-template", 62);
    i0.ɵɵtext(8, "\n\n        ");
    i0.ɵɵtemplate(9, AdaptTableComponent_ng_template_49_ng_template_9_Template, 3, 2, "ng-template", null, 78, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(11, "\n\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n\n    ");
} if (rf & 2) {
    const _r76 = i0.ɵɵreference(10);
    const ctx_r19 = i0.ɵɵnextContext();
    const _r22 = i0.ɵɵreference(56);
    const _r20 = i0.ɵɵreference(53);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r19.headerGroupsTemplate);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("at-header-row_bordered", ctx_r19.bordered);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r22)("ngTemplateOutletContext", i0.ɵɵpureFunction1(7, _c17, _r20));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r19.dataColumnsHeaderTemplate)("ngIfElse", _r76);
} }
function AdaptTableComponent_ng_template_52_adapt_header_selection_checkbox_2_Template(rf, ctx) { if (rf & 1) {
    const _r100 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-header-selection-checkbox", 88);
    i0.ɵɵlistener("headerCheckboxToggle", function AdaptTableComponent_ng_template_52_adapt_header_selection_checkbox_2_Template_adapt_header_selection_checkbox_headerCheckboxToggle_0_listener($event) { i0.ɵɵrestoreView(_r100); const ctx_r99 = i0.ɵɵnextContext(2); return ctx_r99.handleHeaderCheckboxToggle($event); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r97 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("texts", ctx_r97.texts);
} }
function AdaptTableComponent_ng_template_52_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r102 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 89);
    i0.ɵɵlistener("click", function AdaptTableComponent_ng_template_52_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r102); const ctx_r101 = i0.ɵɵnextContext(2); return ctx_r101.unselectAllSelected(); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r98 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("placement", "top")("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r98.texts.unselectAllSelectedTitle);
    i0.ɵɵattribute("aria-label", ctx_r98.texts.unselectAllSelectedTitle);
} }
function AdaptTableComponent_ng_template_52_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_52_adapt_header_selection_checkbox_2_Template, 2, 1, "adapt-header-selection-checkbox", 86);
    i0.ɵɵtext(3, "\n\n      ");
    i0.ɵɵtemplate(4, AdaptTableComponent_ng_template_52_button_4_Template, 2, 4, "button", 87);
    i0.ɵɵtext(5, "\n    ");
} if (rf & 2) {
    const ctx_r21 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r21.hasSelectionLimit);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r21.hasSelectionLimit && ctx_r21.getRowSelectionArray().length);
} }
function AdaptTableComponent_ng_template_55_th_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "th", 94);
} if (rf & 2) {
    const ctx_r104 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptFrozen", ctx_r104.hasAtLeastOneFrozenColumn());
} }
function AdaptTableComponent_ng_template_55_th_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "th", 95);
} if (rf & 2) {
    const ctx_r105 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptFrozen", ctx_r105.hasAtLeastOneFrozenColumn());
} }
function AdaptTableComponent_ng_template_55_th_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "th", 96);
} if (rf & 2) {
    const ctx_r106 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptFrozen", ctx_r106.hasAtLeastOneFrozenColumn());
} }
function AdaptTableComponent_ng_template_55_th_7_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
const _c21 = function (a0) { return { "at-selection-cell--limited": a0 }; };
function AdaptTableComponent_ng_template_55_th_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "th", 97);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_55_th_7_ng_container_2_Template, 1, 0, "ng-container", 98);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const multipleSelectionTemplate_r103 = i0.ɵɵnextContext().$implicit;
    const ctx_r107 = i0.ɵɵnextContext();
    i0.ɵɵproperty("adaptFrozen", ctx_r107.hasAtLeastOneFrozenColumn())("ngClass", i0.ɵɵpureFunction1(3, _c21, ctx_r107.hasSelectionLimit));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", multipleSelectionTemplate_r103);
} }
function AdaptTableComponent_ng_template_55_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_55_th_1_Template, 1, 1, "th", 90);
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_55_th_3_Template, 1, 1, "th", 91);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵtemplate(5, AdaptTableComponent_ng_template_55_th_5_Template, 1, 1, "th", 92);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵtemplate(7, AdaptTableComponent_ng_template_55_th_7_Template, 4, 5, "th", 93);
    i0.ɵɵtext(8, "\n    ");
} if (rf & 2) {
    const ctx_r23 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r23.enableReorderableRows);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r23.isSingleSelectionMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r23.hasExpandingBtn);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r23.isMultipleSelectionMode());
} }
function AdaptTableComponent_ng_template_59_tr_2_td_3_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 115);
} }
function AdaptTableComponent_ng_template_59_tr_2_td_3_Template(rf, ctx) { if (rf & 1) {
    const _r125 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "td", 113);
    i0.ɵɵlistener("mousedown", function AdaptTableComponent_ng_template_59_tr_2_td_3_Template_td_mousedown_0_listener() { i0.ɵɵrestoreView(_r125); i0.ɵɵnextContext(); const _r117 = i0.ɵɵreference(1); const renderRowData_r110 = i0.ɵɵnextContext().$implicit; const ctx_r124 = i0.ɵɵnextContext(); return ctx_r124.onReordarableRowMouseDown(_r117, renderRowData_r110.isGroup); });
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_59_tr_2_td_3_span_2_Template, 1, 0, "span", 114);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const renderRowData_r110 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r118 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r118.hasNotRowNestingLevel(renderRowData_r110));
} }
function AdaptTableComponent_ng_template_59_tr_2_td_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "td", 116);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementEnd();
} }
function AdaptTableComponent_ng_template_59_tr_2_td_22_Template(rf, ctx) { if (rf & 1) {
    const _r130 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "td", 117);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "adapt-rx-checkbox", 118);
    i0.ɵɵlistener("ngModelChange", function AdaptTableComponent_ng_template_59_tr_2_td_22_Template_adapt_rx_checkbox_ngModelChange_2_listener($event) { i0.ɵɵrestoreView(_r130); const renderRowData_r110 = i0.ɵɵnextContext(2).$implicit; const ctx_r128 = i0.ɵɵnextContext(); return ctx_r128.onGroupSelectionChanged($event, renderRowData_r110.rowData); });
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const renderRowData_r110 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r121 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", ctx_r121.getCellStyle(renderRowData_r110));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngModel", ctx_r121.isSelectedGroupCheckbox(renderRowData_r110.rowData))("adaptRadarDisableEventSending", true)("indeterminate", ctx_r121.isGroupSelectionIndeterminate(renderRowData_r110.rowData))("disabled", ctx_r121.isGroupCheckboxDisabled(renderRowData_r110.rowData))("ariaLabel", ctx_r121.rowAriaDataResolver ? ctx_r121.rowAriaDataResolver(renderRowData_r110.rowData).rowSelectionAriaLabel || ctx_r121.getRowGroupTitle(renderRowData_r110.rowData) : ctx_r121.getRowGroupTitle(renderRowData_r110.rowData));
} }
function AdaptTableComponent_ng_template_59_tr_2_ng_template_27_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n            ");
} }
const _c22 = function (a0) { return { "at-expansion-icon--expanded": a0 }; };
function AdaptTableComponent_ng_template_59_tr_2_Template(rf, ctx) { if (rf & 1) {
    const _r133 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "tr", 101, 102);
    i0.ɵɵlistener("cdkDragStarted", function AdaptTableComponent_ng_template_59_tr_2_Template_tr_cdkDragStarted_0_listener($event) { i0.ɵɵrestoreView(_r133); const ctx_r132 = i0.ɵɵnextContext(2); return ctx_r132.onRowDragStarted($event); })("cdkDragDropped", function AdaptTableComponent_ng_template_59_tr_2_Template_tr_cdkDragDropped_0_listener($event) { i0.ɵɵrestoreView(_r133); const _r117 = i0.ɵɵreference(1); const ctx_r134 = i0.ɵɵnextContext(2); return ctx_r134.onRowDragDropped($event, _r117); })("cdkDragEnded", function AdaptTableComponent_ng_template_59_tr_2_Template_tr_cdkDragEnded_0_listener($event) { i0.ɵɵrestoreView(_r133); const ctx_r135 = i0.ɵɵnextContext(2); return ctx_r135.onRowDragEnded($event); })("cdkDragReleased", function AdaptTableComponent_ng_template_59_tr_2_Template_tr_cdkDragReleased_0_listener($event) { i0.ɵɵrestoreView(_r133); const ctx_r136 = i0.ɵɵnextContext(2); return ctx_r136.onRowDragReleased($event); });
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_59_tr_2_td_3_Template, 4, 1, "td", 103);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵtemplate(5, AdaptTableComponent_ng_template_59_tr_2_td_5_Template, 2, 0, "td", 104);
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementStart(7, "td", 105, 106);
    i0.ɵɵtext(9, "\n            ");
    i0.ɵɵelementStart(10, "button", 107);
    i0.ɵɵlistener("click", function AdaptTableComponent_ng_template_59_tr_2_Template_button_click_10_listener() { i0.ɵɵrestoreView(_r133); const renderRowData_r110 = i0.ɵɵnextContext().$implicit; const ctx_r137 = i0.ɵɵnextContext(); return ctx_r137.onGroupToggleClick(renderRowData_r110.rowData); });
    i0.ɵɵtext(11, "\n              ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(12, "svg", 108);
    i0.ɵɵtext(13, "\n                ");
    i0.ɵɵelement(14, "path", 109);
    i0.ɵɵtext(15, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n              ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(17, "span", 110);
    i0.ɵɵtext(18);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(19, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(21, "\n\n          ");
    i0.ɵɵtemplate(22, AdaptTableComponent_ng_template_59_tr_2_td_22_Template, 5, 6, "td", 111);
    i0.ɵɵtext(23, "\n\n          ");
    i0.ɵɵtext(24, "\n          ");
    i0.ɵɵelementStart(25, "td", 112);
    i0.ɵɵtext(26, "\n            ");
    i0.ɵɵtemplate(27, AdaptTableComponent_ng_template_59_tr_2_ng_template_27_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(28, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(29, "\n\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r139 = i0.ɵɵnextContext();
    const renderRowData_r110 = ctx_r139.$implicit;
    const columns_r111 = ctx_r139.columns;
    const ctx_r114 = i0.ɵɵnextContext();
    const _r30 = i0.ɵɵreference(72);
    i0.ɵɵproperty("cdkDragData", renderRowData_r110)("ngClass", ctx_r114.getGroupRowClass(renderRowData_r110));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r114.enableReorderableRows);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r114.isSingleSelectionMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngStyle", ctx_r114.getCellStyle(renderRowData_r110));
    i0.ɵɵadvance(3);
    i0.ɵɵattribute("aria-expanded", ctx_r114.isExpandedGroup(renderRowData_r110.rowData));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(13, _c22, ctx_r114.isExpandedGroup(renderRowData_r110.rowData)));
    i0.ɵɵadvance(6);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r114.isExpandedGroup(renderRowData_r110.rowData) ? ctx_r114.rowAriaDataResolver && ctx_r114.rowAriaDataResolver(renderRowData_r110.rowData).rowCollapseAriaLabel || ctx_r114.texts.collapseRowText : ctx_r114.rowAriaDataResolver && ctx_r114.rowAriaDataResolver(renderRowData_r110.rowData).rowExpandAriaLabel || ctx_r114.texts.expandRowText, "\n              ");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r114.isMultipleSelectionMode() && !ctx_r114.hasSelectionLimit);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngStyle", ctx_r114.getCellStyle(renderRowData_r110));
    i0.ɵɵattribute("colspan", ctx_r114.getColumnsForRendering(columns_r111).length + (ctx_r114.hasSelectionLimit ? 1 : 0));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r114.groupValueDataCellTemplate || _r30)("ngTemplateOutletContext", ctx_r114.getGroupValueDataCellTemplateParams(renderRowData_r110));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_td_4_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 115);
} }
function AdaptTableComponent_ng_template_59_ng_template_5_td_4_Template(rf, ctx) { if (rf & 1) {
    const _r151 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "td", 127);
    i0.ɵɵlistener("mousedown", function AdaptTableComponent_ng_template_59_ng_template_5_td_4_Template_td_mousedown_0_listener() { i0.ɵɵrestoreView(_r151); i0.ɵɵnextContext(); const _r140 = i0.ɵɵreference(2); const ctx_r150 = i0.ɵɵnextContext(2); return ctx_r150.onReordarableRowMouseDown(_r140, null); });
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_59_ng_template_5_td_4_span_2_Template, 1, 0, "span", 114);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const renderRowData_r110 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r141 = i0.ɵɵnextContext();
    i0.ɵɵproperty("adaptFrozen", ctx_r141.hasAtLeastOneFrozenColumn());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r141.hasNotRowNestingLevel(renderRowData_r110));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_td_6_Template(rf, ctx) { if (rf & 1) {
    const _r155 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "td", 128);
    i0.ɵɵtext(1, "\n\n              ");
    i0.ɵɵtext(2, "\n              ");
    i0.ɵɵelementStart(3, "adapt-rx-radiobutton", 129);
    i0.ɵɵlistener("click", function AdaptTableComponent_ng_template_59_ng_template_5_td_6_Template_adapt_rx_radiobutton_click_3_listener() { i0.ɵɵrestoreView(_r155); const renderRowData_r110 = i0.ɵɵnextContext(2).$implicit; const ctx_r153 = i0.ɵɵnextContext(); return ctx_r153.onRadiobuttonModelChange(renderRowData_r110.rowData); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const renderRowData_r110 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r142 = i0.ɵɵnextContext();
    i0.ɵɵproperty("adaptFrozen", ctx_r142.hasAtLeastOneFrozenColumn());
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("name", ctx_r142.rowSelectionRadiobuttonName)("adaptRadarDisableEventSending", true)("value", ctx_r142.getPrimaryKey(renderRowData_r110.rowData))("checked", ctx_r142.isSingleSelectionRowSelected(renderRowData_r110.rowData))("label", ctx_r142.rowAriaDataResolver && ctx_r142.rowAriaDataResolver(renderRowData_r110.rowData).rowSelectionAriaLabel)("ariaLabel", ctx_r142.rowAriaDataResolver && ctx_r142.rowAriaDataResolver(renderRowData_r110.rowData).rowSelectionAriaLabel)("disabled", ctx_r142.isRowSelectionDisabled(renderRowData_r110.rowData));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_td_8_button_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "button", 132);
    i0.ɵɵtext(1, "\n                ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(2, "svg", 108);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelement(4, "path", 133);
    i0.ɵɵtext(5, "\n                ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n                ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(7, "span", 110);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const renderRowData_r110 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r158 = i0.ɵɵnextContext();
    i0.ɵɵproperty("pRowToggler", renderRowData_r110.rowData);
    i0.ɵɵattribute("aria-expanded", renderRowData_r110.rowExpanded);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(4, _c22, renderRowData_r110.rowExpanded));
    i0.ɵɵadvance(6);
    i0.ɵɵtextInterpolate(renderRowData_r110.rowExpanded ? ctx_r158.rowAriaDataResolver && ctx_r158.rowAriaDataResolver(renderRowData_r110.rowData).rowCollapseAriaLabel || ctx_r158.texts.collapseRowText : ctx_r158.rowAriaDataResolver && ctx_r158.rowAriaDataResolver(renderRowData_r110.rowData).rowExpandAriaLabel || ctx_r158.texts.expandRowText);
} }
const _c23 = function (a0) { return { "at-expansion-cell_no-children": a0 }; };
function AdaptTableComponent_ng_template_59_ng_template_5_td_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "td", 130, 106);
    i0.ɵɵtext(2, "\n\n              ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_59_ng_template_5_td_8_button_3_Template, 10, 6, "button", 131);
    i0.ɵɵtext(4, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const renderRowData_r110 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r143 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", ctx_r143.getCellStyle(renderRowData_r110))("ngClass", i0.ɵɵpureFunction1(4, _c23, ctx_r143.nestingStructureData && !ctx_r143.isChildrenExist(renderRowData_r110.rowData)))("adaptFrozen", ctx_r143.hasAtLeastOneFrozenColumn());
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r143.shouldShowExpandingButton(renderRowData_r110));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_td_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "td", 134);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵelementStart(2, "adapt-row-selection-checkbox", 135);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const renderRowData_r110 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r144 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", ctx_r144.getCellStyle(renderRowData_r110))("adaptFrozen", ctx_r144.hasAtLeastOneFrozenColumn());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("renderRowData", renderRowData_r110)("value", renderRowData_r110.rowData)("rowAriaDataResolver", ctx_r144.rowAriaDataResolver)("disabled", ctx_r144.isRowSelectionCheckboxDisabled(renderRowData_r110.rowData));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_13_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n              ");
} }
const _c24 = function (a0, a1, a2) { return { columns: a0, renderRowData: a1, rowIndex: a2 }; };
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n              ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_13_ng_template_1_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(2, "\n            ");
} if (rf & 2) {
    const ctx_r163 = i0.ɵɵnextContext(2);
    const columns_r111 = ctx_r163.columns;
    const renderRowData_r110 = ctx_r163.$implicit;
    const rowIndex_r112 = ctx_r163.rowIndex;
    const ctx_r145 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r145.dataColumnsDataCellsTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction3(2, _c24, columns_r111, renderRowData_r110, rowIndex_r112));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_3_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n                  ");
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_3_Template(rf, ctx) { if (rf & 1) {
    const _r173 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "td", 138, 139);
    i0.ɵɵlistener("dblclick", function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_3_Template_td_dblclick_0_listener() { i0.ɵɵrestoreView(_r173); const renderRowData_r110 = i0.ɵɵnextContext(4).$implicit; const ctx_r171 = i0.ɵɵnextContext(); return ctx_r171.onTableCellDoubleClick(renderRowData_r110.rowData); });
    i0.ɵɵtext(2, "\n\n                  ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_3_ng_template_3_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(4, "\n                ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r169 = i0.ɵɵreference(1);
    const ctx_r175 = i0.ɵɵnextContext();
    const index_r166 = ctx_r175.index;
    const renderingColumn_r165 = ctx_r175.$implicit;
    const renderRowData_r110 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r167 = i0.ɵɵnextContext();
    const _r36 = i0.ɵɵreference(84);
    i0.ɵɵproperty("ngStyle", ctx_r167.getCellStyle(renderRowData_r110, index_r166, renderingColumn_r165.columnsConfigs[0]))("adaptFrozen", ctx_r167.isColumnFrozen(renderingColumn_r165.columnsConfigs[0]))("adaptData", ctx_r167.getDataCellDirectiveParams(renderingColumn_r165, renderRowData_r110))("ngClass", ctx_r167.getDataCellClass(renderingColumn_r165.columnsConfigs[0], renderRowData_r110, _r169))("tabindex", ctx_r167.getDataCellTabIndex(renderingColumn_r165.columnsConfigs[0], renderRowData_r110));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngTemplateOutlet", _r36)("ngTemplateOutletContext", ctx_r167.getDataCellTemplateParams(renderingColumn_r165.columnsConfigs[0], renderRowData_r110));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_6_div_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n                    ");
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_6_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 142);
    i0.ɵɵtext(1, "\n\n                    ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_6_div_3_ng_template_2_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(3, "\n                  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const columnConfig_r178 = ctx.$implicit;
    const renderRowData_r110 = i0.ɵɵnextContext(5).$implicit;
    const ctx_r177 = i0.ɵɵnextContext();
    const _r36 = i0.ɵɵreference(84);
    i0.ɵɵattribute("data-merged-column-field", columnConfig_r178.field);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r36)("ngTemplateOutletContext", ctx_r177.getDataCellTemplateParams(columnConfig_r178, renderRowData_r110));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_6_Template(rf, ctx) { if (rf & 1) {
    const _r183 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "td", 140, 139);
    i0.ɵɵlistener("dblclick", function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_6_Template_td_dblclick_0_listener() { i0.ɵɵrestoreView(_r183); const renderRowData_r110 = i0.ɵɵnextContext(4).$implicit; const ctx_r181 = i0.ɵɵnextContext(); return ctx_r181.onTableCellDoubleClick(renderRowData_r110.rowData); });
    i0.ɵɵtext(2, "\n                  ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_6_div_3_Template, 4, 3, "div", 141);
    i0.ɵɵtext(4, "\n                ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r176 = i0.ɵɵreference(1);
    const ctx_r185 = i0.ɵɵnextContext();
    const index_r166 = ctx_r185.index;
    const renderingColumn_r165 = ctx_r185.$implicit;
    const renderRowData_r110 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r168 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngStyle", ctx_r168.getMergedCellStyle(renderRowData_r110, index_r166, renderingColumn_r165.columnsConfigs))("adaptData", ctx_r168.getDataCellDirectiveParams(renderingColumn_r165, renderRowData_r110))("ngClass", ctx_r168.getMergedDataCellClass(renderingColumn_r165.columnsConfigs, renderRowData_r110, _r176))("tabindex", ctx_r168.getMergedDataCellTabIndex(renderingColumn_r165.columnsConfigs, renderRowData_r110));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", renderingColumn_r165.columnsConfigs)("ngForTrackBy", ctx_r168.trackByForColumns);
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n\n                ");
    i0.ɵɵtext(2, "\n                ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_3_Template, 5, 7, "td", 136);
    i0.ɵɵtext(4, "\n\n                ");
    i0.ɵɵtext(5, "\n                ");
    i0.ɵɵtemplate(6, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_td_6_Template, 5, 6, "td", 137);
    i0.ɵɵtext(7, "\n              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const renderingColumn_r165 = ctx.$implicit;
    const ctx_r164 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", renderingColumn_r165.type === ctx_r164.RenderingColumnType.Simple);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", renderingColumn_r165.type === ctx_r164.RenderingColumnType.Merged);
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n              ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_ng_container_1_Template, 8, 2, "ng-container", 69);
    i0.ɵɵtext(2, "\n            ");
} if (rf & 2) {
    const columns_r111 = i0.ɵɵnextContext(2).columns;
    const ctx_r147 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r147.getColumnsForRendering(columns_r111))("ngForTrackBy", ctx_r147.trackByForRenderingColumns);
} }
function AdaptTableComponent_ng_template_59_ng_template_5_ng_container_20_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n            ");
} }
const _c25 = function (a0, a1, a2) { return { $implicit: a0, rowIndex: a1, columns: a2 }; };
function AdaptTableComponent_ng_template_59_ng_template_5_ng_container_20_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_59_ng_template_5_ng_container_20_ng_template_2_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r188 = i0.ɵɵnextContext(2);
    const renderRowData_r110 = ctx_r188.$implicit;
    const rowIndex_r112 = ctx_r188.rowIndex;
    const columns_r111 = ctx_r188.columns;
    i0.ɵɵnextContext();
    const _r26 = i0.ɵɵreference(64);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r26)("ngTemplateOutletContext", i0.ɵɵpureFunction3(2, _c25, renderRowData_r110.rowData, rowIndex_r112, columns_r111));
} }
function AdaptTableComponent_ng_template_59_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    const _r190 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵelementStart(1, "tr", 119, 120);
    i0.ɵɵlistener("cdkDragStarted", function AdaptTableComponent_ng_template_59_ng_template_5_Template_tr_cdkDragStarted_1_listener($event) { i0.ɵɵrestoreView(_r190); const ctx_r189 = i0.ɵɵnextContext(2); return ctx_r189.onRowDragStarted($event); })("cdkDragDropped", function AdaptTableComponent_ng_template_59_ng_template_5_Template_tr_cdkDragDropped_1_listener($event) { i0.ɵɵrestoreView(_r190); const _r140 = i0.ɵɵreference(2); const ctx_r191 = i0.ɵɵnextContext(2); return ctx_r191.onRowDragDropped($event, _r140); })("cdkDragEnded", function AdaptTableComponent_ng_template_59_ng_template_5_Template_tr_cdkDragEnded_1_listener($event) { i0.ɵɵrestoreView(_r190); const ctx_r192 = i0.ɵɵnextContext(2); return ctx_r192.onRowDragEnded($event); })("cdkDragReleased", function AdaptTableComponent_ng_template_59_ng_template_5_Template_tr_cdkDragReleased_1_listener($event) { i0.ɵɵrestoreView(_r190); const ctx_r193 = i0.ɵɵnextContext(2); return ctx_r193.onRowDragReleased($event); });
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵtemplate(4, AdaptTableComponent_ng_template_59_ng_template_5_td_4_Template, 4, 2, "td", 121);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵtemplate(6, AdaptTableComponent_ng_template_59_ng_template_5_td_6_Template, 5, 8, "td", 122);
    i0.ɵɵtext(7, "\n            ");
    i0.ɵɵtemplate(8, AdaptTableComponent_ng_template_59_ng_template_5_td_8_Template, 5, 6, "td", 123);
    i0.ɵɵtext(9, "\n            ");
    i0.ɵɵtemplate(10, AdaptTableComponent_ng_template_59_ng_template_5_td_10_Template, 5, 6, "td", 124);
    i0.ɵɵtext(11, "\n\n            ");
    i0.ɵɵtext(12, "\n            ");
    i0.ɵɵtemplate(13, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_13_Template, 3, 6, "ng-template", 62);
    i0.ɵɵtext(14, "\n\n            ");
    i0.ɵɵtemplate(15, AdaptTableComponent_ng_template_59_ng_template_5_ng_template_15_Template, 3, 2, "ng-template", null, 125, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(17, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n\n          ");
    i0.ɵɵtext(19, "\n          ");
    i0.ɵɵtemplate(20, AdaptTableComponent_ng_template_59_ng_template_5_ng_container_20_Template, 4, 6, "ng-container", 126);
    i0.ɵɵtext(21, "\n\n        ");
} if (rf & 2) {
    const _r146 = i0.ɵɵreference(16);
    const ctx_r194 = i0.ɵɵnextContext();
    const renderRowData_r110 = ctx_r194.$implicit;
    const primengExpanded_r113 = ctx_r194.expanded;
    const ctx_r116 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("pEditableRow", renderRowData_r110.rowData)("adaptData", ctx_r116.getDataRowDirectiveParams(renderRowData_r110))("ngClass", ctx_r116.getDataRowClass(renderRowData_r110))("cdkDragData", renderRowData_r110);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r116.enableReorderableRows);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r116.isSingleSelectionMode());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r116.hasExpandingBtn);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r116.isMultipleSelectionMode());
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r116.dataColumnsDataCellsTemplate)("ngIfElse", _r146);
    i0.ɵɵadvance(7);
    i0.ɵɵproperty("ngIf", !primengExpanded_r113 && renderRowData_r110.rowExpanded && ctx_r116.expandedRowTemplate);
} }
function AdaptTableComponent_ng_template_59_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n\n        ");
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_59_tr_2_Template, 30, 15, "tr", 99);
    i0.ɵɵtext(3, "\n\n        ");
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵtemplate(5, AdaptTableComponent_ng_template_59_ng_template_5_Template, 22, 11, "ng-template", null, 100, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(7, "\n    ");
} if (rf & 2) {
    const renderRowData_r110 = ctx.$implicit;
    const _r115 = i0.ɵɵreference(6);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", renderRowData_r110.isGroup)("ngIfElse", _r115);
} }
function AdaptTableComponent_ng_template_63_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
} }
function AdaptTableComponent_ng_template_63_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "tr", 143);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "td", 144);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵtemplate(5, AdaptTableComponent_ng_template_63_ng_template_5_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n    ");
} if (rf & 2) {
    const dataItem_r195 = ctx.$implicit;
    const columns_r196 = ctx.columns;
    const rowIndex_r197 = ctx.rowIndex;
    const ctx_r27 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngClass", ctx_r27.expandedCellClass);
    i0.ɵɵattribute("colspan", ctx_r27.getCurrentTableColumnsCount(columns_r196));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r27.expandedRowTemplate)("ngTemplateOutletContext", ctx_r27.getExpandedRowTemplateParams(dataItem_r195, columns_r196, rowIndex_r197));
} }
function AdaptTableComponent_ng_template_67_tr_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "tr", 146);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "td", 147, 148);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelement(5, "adapt-empty-state", 149);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const columns_r199 = i0.ɵɵnextContext().$implicit;
    const ctx_r200 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("colspan", ctx_r200.getCurrentTableColumnsCount(columns_r199));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("type", "grid")("adaptRadarDisableEventSending", true)("label", ctx_r200.getEmptyStateLabelText());
} }
function AdaptTableComponent_ng_template_67_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_67_tr_1_Template, 8, 4, "tr", 145);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const ctx_r29 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r29.hasEmptyState && !ctx_r29.loading);
} }
function AdaptTableComponent_ng_template_71_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0);
} if (rf & 2) {
    const renderRowData_r203 = ctx.$implicit;
    const ctx_r31 = i0.ɵɵnextContext();
    i0.ɵɵtextInterpolate1("\n      ", ctx_r31.getRowGroupTitle(renderRowData_r203.rowData), "\n    ");
} }
function AdaptTableComponent_ng_template_75_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "adapt-table-actions", 150);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r211 = i0.ɵɵnextContext();
    const column_r204 = ctx_r211.column;
    const dataItem_r205 = ctx_r211.dataItem;
    const rowIndex_r206 = ctx_r211.rowIndex;
    const expanded_r207 = ctx_r211.expanded;
    const editing_r208 = ctx_r211.editing;
    const ctx_r209 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("column", column_r204)("dataItem", dataItem_r205)("rowIndex", rowIndex_r206)("expanded", expanded_r207)("editing", editing_r208)("texts", ctx_r209.texts);
} }
function AdaptTableComponent_ng_template_75_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r212 = i0.ɵɵnextContext();
    const dataItem_r205 = ctx_r212.dataItem;
    const column_r204 = ctx_r212.column;
    const ctx_r210 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n        ", ctx_r210.getColumnData(dataItem_r205, column_r204), "\n      ");
} }
function AdaptTableComponent_ng_template_75_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_75_ng_container_1_Template, 5, 6, "ng-container", 126);
    i0.ɵɵtext(2, "\n\n      ");
    i0.ɵɵtemplate(3, AdaptTableComponent_ng_template_75_ng_container_3_Template, 2, 1, "ng-container", 126);
    i0.ɵɵtext(4, "\n    ");
} if (rf & 2) {
    const column_r204 = ctx.column;
    const ctx_r33 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r33.getActionConfig(column_r204));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r33.getActionConfig(column_r204));
} }
function AdaptTableComponent_ng_template_79_Template(rf, ctx) { if (rf & 1) {
    const _r219 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "adapt-rx-textfield", 151, 152);
    i0.ɵɵlistener("ngModelChange", function AdaptTableComponent_ng_template_79_Template_adapt_rx_textfield_ngModelChange_1_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r219); const dataItem_r214 = restoredCtx.dataItem; const column_r213 = restoredCtx.column; const ctx_r218 = i0.ɵɵnextContext(); return (ctx_r218.getEditableClonedRow(dataItem_r214)[column_r213.field] = $event); })("keydown", function AdaptTableComponent_ng_template_79_Template_adapt_rx_textfield_keydown_1_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r219); const dataItem_r214 = restoredCtx.dataItem; const ctx_r220 = i0.ɵɵnextContext(); return ctx_r220.onTextfieldKeydown(dataItem_r214, $event); });
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
} if (rf & 2) {
    const column_r213 = ctx.column;
    const dataItem_r214 = ctx.dataItem;
    const ctx_r35 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("size", "sm")("adaptRadarDisableEventSending", true)("ngModel", ctx_r35.getEditableClonedRow(dataItem_r214)[column_r213.field]);
} }
function AdaptTableComponent_ng_template_83_ng_container_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r231 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n\n          ");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "div", 154);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "button", 155);
    i0.ɵɵlistener("click", function AdaptTableComponent_ng_template_83_ng_container_1_ng_template_2_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r231); const renderRowData_r222 = i0.ɵɵnextContext(2).renderRowData; const ctx_r229 = i0.ɵɵnextContext(); return ctx_r229.cancelRowEditing(renderRowData_r222.rowData); });
    i0.ɵɵtext(5, "\n              ");
    i0.ɵɵelementStart(6, "span", 110);
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n            ");
    i0.ɵɵelementStart(10, "button", 156);
    i0.ɵɵlistener("click", function AdaptTableComponent_ng_template_83_ng_container_1_ng_template_2_Template_button_click_10_listener() { i0.ɵɵrestoreView(_r231); const renderRowData_r222 = i0.ɵɵnextContext(2).renderRowData; const ctx_r232 = i0.ɵɵnextContext(); return ctx_r232.saveRowEditing(renderRowData_r222.rowData); });
    i0.ɵɵtext(11, "\n              ");
    i0.ɵɵelementStart(12, "span", 110);
    i0.ɵɵtext(13);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n\n        ");
} if (rf & 2) {
    const ctx_r228 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r228.texts.cancelRowEditingButtonLabel);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r228.texts.saveRowEditingButtonLabel);
} }
function AdaptTableComponent_ng_template_83_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_83_ng_container_1_ng_template_2_Template, 17, 4, "ng-template", 62);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const column_r221 = i0.ɵɵnextContext().column;
    const _r226 = i0.ɵɵreference(10);
    const ctx_r223 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r223.getActionConfig(column_r221).enableRowEditingButtons)("ngIfElse", _r226);
} }
function AdaptTableComponent_ng_template_83_ng_container_4_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
} }
function AdaptTableComponent_ng_template_83_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_83_ng_container_4_ng_template_2_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r236 = i0.ɵɵnextContext();
    const column_r221 = ctx_r236.column;
    const renderRowData_r222 = ctx_r236.renderRowData;
    const ctx_r224 = i0.ɵɵnextContext();
    const _r34 = i0.ɵɵreference(80);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", column_r221.editTemplate || _r34)("ngTemplateOutletContext", ctx_r224.getColumnTemplateParams(column_r221, renderRowData_r222));
} }
function AdaptTableComponent_ng_template_83_ng_container_6_ng_template_2_Template(rf, ctx) { }
function AdaptTableComponent_ng_template_83_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptTableComponent_ng_template_83_ng_container_6_ng_template_2_Template, 0, 0, "ng-template", 79);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r226 = i0.ɵɵreference(10);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r226);
} }
function AdaptTableComponent_ng_template_83_ng_template_9_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
} }
function AdaptTableComponent_ng_template_83_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_83_ng_template_9_ng_template_1_Template, 1, 0, "ng-template", 68);
    i0.ɵɵtext(2, "\n      ");
} if (rf & 2) {
    const ctx_r239 = i0.ɵɵnextContext();
    const column_r221 = ctx_r239.column;
    const renderRowData_r222 = ctx_r239.renderRowData;
    const ctx_r227 = i0.ɵɵnextContext();
    const _r32 = i0.ɵɵreference(76);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", column_r221.cellTemplate || _r32)("ngTemplateOutletContext", ctx_r227.getColumnTemplateParams(column_r221, renderRowData_r222));
} }
function AdaptTableComponent_ng_template_83_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n\n      ");
    i0.ɵɵtemplate(1, AdaptTableComponent_ng_template_83_ng_container_1_Template, 4, 2, "ng-container", 126);
    i0.ɵɵtext(2, "\n\n      ");
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, AdaptTableComponent_ng_template_83_ng_container_4_Template, 4, 2, "ng-container", 126);
    i0.ɵɵtext(5, "\n\n      ");
    i0.ɵɵtemplate(6, AdaptTableComponent_ng_template_83_ng_container_6_Template, 4, 1, "ng-container", 126);
    i0.ɵɵtext(7, "\n\n      ");
    i0.ɵɵtext(8, "\n      ");
    i0.ɵɵtemplate(9, AdaptTableComponent_ng_template_83_ng_template_9_Template, 3, 2, "ng-template", null, 153, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(11, "\n    ");
} if (rf & 2) {
    const column_r221 = ctx.column;
    const renderRowData_r222 = ctx.renderRowData;
    const ctx_r37 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r37.isEditableColumn(column_r221) && renderRowData_r222.editing && ctx_r37.getActionConfig(column_r221));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r37.isEditableColumn(column_r221) && renderRowData_r222.editing && !ctx_r37.getActionConfig(column_r221));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !renderRowData_r222.editing || renderRowData_r222.editing && !ctx_r37.isEditableColumn(column_r221));
} }
const _c26 = function (a0, a1, a2, a3) { return { "ui-table-flex-scrollable": a0, "at-has-paginator": a1, "at-has-toolbar": a2, "at-columns-reorderable": a3 }; };
const _c27 = function (a0, a1) { return { "at-table-reordable": a0, "at-wrap-cell-text": a1 }; };
const _c28 = function (a1, a2, a3, a4, a5) { return { "ui-table ui-widget": true, "ui-table-responsive": a1, "ui-table-resizable": a2, "ui-table-resizable-fit": a3, "ui-table-hoverable-rows": a4, "ui-table-auto-layout": a5 }; };
const _c29 = function (a0) { return { "at-table-scroll-wrapper": a0 }; };
const _c30 = function (a0) { return { "width": a0 }; };
/** @deprecated from v8.26.1 Use AdaptTableClasses Enum instead */
class AdaptGridClasses {
}
AdaptGridClasses.MAIN = 'adapt-grid';
AdaptGridClasses.ADAPT_TABLE = 'adapt-table';
AdaptGridClasses.BORDERED = 'adapt-grid-bordered';
AdaptGridClasses.PAGEABLE = 'adapt-table-pageable';
AdaptGridClasses.SCROLLABLE = 'adapt-table-scrollable';
AdaptGridClasses.STRIPED = 'adapt-table--striped';
AdaptGridClasses.IS_EMPTY_STATE = 'adapt-table--empty-state';
AdaptGridClasses.NOT_SCROLLABLE = 'adapt-table-not-scrollable';
AdaptGridClasses.FULL_HEIGHT_STRETCH = 'adapt-table-full-height-stretch';
AdaptGridClasses.HAS_NOT_VERTICAL_BODY_OVERFLOW = 'adapt-table--has-not-overflow';
AdaptGridClasses.LOADING_FULL_TABLE = 'adapt-grid--loading';
AdaptGridClasses.CELL = {
    ACTIONS_CELL: 'at-actions-cell',
    EDITING: 'at-cell--editing',
};
class AdaptTableComponent extends Table {
    constructor(el, zone, tableService, cd, filterService, _dir, _renderer, _adaptDeviceDetectionService, _ts, _deprecationMiddleware, _overlayService, _injector) {
        super(el, zone, tableService, cd, filterService);
        this._dir = _dir;
        this._renderer = _renderer;
        this._adaptDeviceDetectionService = _adaptDeviceDetectionService;
        this._ts = _ts;
        this._deprecationMiddleware = _deprecationMiddleware;
        this._overlayService = _overlayService;
        this._injector = _injector;
        this.loadingToggle = new EventEmitter();
        this.currentEditingRows = {};
        this.isMobile = false;
        this.rowSelectionRadiobuttonName = null;
        this.RenderingColumnType = RenderingColumnType;
        this.tableBodyHeight = '';
        this.isRtl = false;
        /** Is used for multiple range selection with shiftKey. Is set on checkbox click and `space` click on a focused cell */
        this.lastSelectedRowId = null;
        this.columnIndex = 0;
        this.tableClasses = AdaptTableClasses;
        /**
         * Enables table sorting
         * @docs-default 'false'
         */
        this.sortable = false;
        /**
         * Enables table filtering
         * @docs-default 'false'
         */
        this.filterable = false;
        /**
         * Enables triggerable search on filters
         * @docs-default 'false'
         */
        this.triggerableFilters = false;
        /**
         * Show explicit search button
         * @docs-default 'false'
         */
        this.explicitSearchBtn = false;
        /**
         * Enables table rows reordering
         * @docs-default 'false'
         */
        this.enableReorderableRows = false;
        /**
         * Hide tooltips in the entire table
         * @docs-default 'false'
         */
        this.suppressTooltip = false;
        /**
         * The hash map that is used to control the expansion state of the groups
         * @docs-default {}
         */
        this.expandedGroupsKeys = {};
        /**
         * Padding of the nested group in pixels. Useful when you want to control padding value for a table group.
         * With a big nesting level, there is still a possibility that table data will be overlapped.
         * In such a case, you can change the control table columns width.
         * @docs-default 31
         */
        this.nestedGroupPadding = 31; // in pixels
        /**
         * Initial padding of nested group in pixels
         * @docs-default 13
         */
        this.expandindCellInitialPadding = 13; // pixels. Or get dynamically
        /**
         * The delay to showing tooltip for table header and for the table cell
         * @docs-default 900
         */
        this.tooltipInitialDelayMs = 900;
        /**
         * Used to set custom class on the AdaptTooltipComponent which is used to show tooltip
         * @docs-default ''
         */
        this.tooltipClass = '';
        /**
         * Align pagination block to the left or right.
         * @docs-default 'left'
         */
        this.paginatorAlign = 'left';
        /**
         * Used to toggle the visibility of the empty state visualization(AdaptEmptyStateComponent) for the empty
         * table(table is empty the [value] is null or have 0 length)
         * @docs-default true
         */
        this.hasEmptyState = true;
        /**
         * Used to turn on "infinite scroll" mode.In combination with [lazy]="true" allow to load the
         * data when the user scrolls to the bottom of the table. This is alternative to the per page pagination.
         * @docs-default false
         */
        this.enableInfiniteScrolling = false;
        /**
         * Config of full table loader that is used AdaptBusyDirective under the hood
         * @docs-default {busy: null, backdrop: true, sticky: true, message: '', loaderType: 'section'}
         */
        this.busyConfig = this._getBusyConfig();
        /**
         * Default 'FilterMatchMode' for all filters
         * @docs-default FilterMatchMode.contains
         */
        this.defaultFiltersMatchMode = FilterMatchMode.contains;
        /**
         * Wraps long text on a new line instead of truncating
         * @docs-default false
         */
        this.wrapCellText = false;
        /**
         * Unique attribute test-id for QA
         * @since 11.14.0
         * @docs-default 'adapt-table'
         */
        this.testID = 'adapt-table';
        /**
         * Based on chosen mode customer will see different variants of selection.<br/>There are 3 possible variants:<br /><b>Both</b> - allows to use both type of selection: "Select on page" and "Select all in table"<br /><b>Chunk</b> - allows to use only "Select on page" type<br /><b>All</b> - allows to use only "Select all in table" type
         * @since 11.10.0
         * @docs-default AdaptTableHeaderSelectionMode.Both
         */
        this.headerSelectionMode = AdaptTableHeaderSelectionMode.Both;
        /**
         * Number of disabled rows that are selected. Used to calculate header selection menu actions visibility and checkbox state in lazy mode
         * @since 11.10.0
         * @docs-default 0
         */
        this.disabledSelectedRowsCount = 0;
        /**
         * Number of disabled rows that are not selected. Used to calculate header selection menu actions visibility and checkbox state in lazy mode
         * @since 11.10.0
         * @docs-default 0
         */
        this.disabledNotSelectedRowsCount = 0;
        /**
         * Number of disabled rows that are selected in filtering mode. Used to calculate header selection menu actions visibility and checkbox state in lazy mode while filtering
         * @since 11.10.0
         * @docs-default 0
         */
        this.disabledSelectedFilteredRowsCount = 0;
        /**
         Number of disabled rows that are not selected in filtering mode. Used to calculate header selection menu actions visibility and checkbox state in lazy mode while filtering
         * @since 11.10.0
         * @docs-default 0
         */
        this.disabledNotSelectedFilteredRowsCount = 0;
        /**
         Number of selected rows in filtering mode. Used to calculate header selection menu actions visibility and checkbox state in lazy mode while filtering
         * @since 11.10.0
         * @docs-default 0
         */
        this.selectedFilteredRowsCount = 0;
        /**
         Total amount of records inside group. Used to calculate header selection menu actions visibility and checkbox state in lazy mode
         * @since 11.10.0
         * @docs-default 0
         */
        this.totalRecordsInGroup = 0;
        /**
         * Disabling possibility to select rows if set to true
         * @docs-default false
         */
        this.disableRowSelection = false;
        /**
         * Flag that should be set to true if table data has nesting structure. Used to show/hide expansion icon
         * @docs-default false
         */
        this.nestingStructureData = false;
        /**
         * In case when table should have nesting view 'nestingKey' property allow to configure name of property where children elements are located. Used to show/hide expansion icon
         * @docs-default 'children'
         */
        this.nestingKey = 'children';
        /**
         * Enables row editing on 'Enter' keydown when cell is in focus
         * @docs-default false
         */
        this.enableRowEditing = false;
        /**
         * @docs-default false
         */
        this.autoScrollToTop = false;
        /**
         * @docs-default
         *
         * @deprecated from v8.26.1 Use 'texts' instead
         */
        this.filtersTexts = {};
        /**
         * Used to set static width for table. By default, table is flexible and try to change width depends on viewport
         * @docs-default null
         */
        this.tableWidthConfig = null;
        /**
         * Toggle table borders visibility
         * @docs-default false
         */
        this.bordered = false;
        /**
         * Toggle "striped" rows mode. If true, every other row will have different background
         * @docs-default false
         */
        this.striped = false;
        /**
         * Emits on refresh button click
         */
        this.rowDataRefresh = new EventEmitter();
        /**
         * Emits the event on saving of row editing
         */
        this.savedRowEditing = new EventEmitter();
        /**
         * Emits the event on cancel of row editing
         */
        this.canceledRowEditing = new EventEmitter();
        /**
         * Emits the event when user clicks on checkbox of group
         */
        this.groupSelection = new EventEmitter();
        /**
         * Emits the event on click on a checkbox in the header of the table when groups present
         */
        this.allGroupedRowsSelection = new EventEmitter();
        /**
         * Emits the event on group expansion
         */
        this.groupExpansion = new EventEmitter();
        /**
         * Emits when column visibility changed
         */
        this.columnsVisibilityChange = new EventEmitter();
        /**
         * Emits when the user starts dragging the item
         */
        this.rowDragStart = new EventEmitter();
        /**
         * Emits when the user has released a drag item, before any animations have started
         */
        this.rowDragRelease = new EventEmitter();
        /**
         * Emits when the user stops dragging an item in the container
         */
        this.rowDragEnd = new EventEmitter();
        /**
         * Emits when the user drops the item inside a container
         */
        this.rowDragDrop = new EventEmitter();
        /**
         * Emits when the user click on any export button. Usage: listen to this event to be notified when to handle table data export <adapt-table (export)="function($event)"></adapt-table>
         * @since 12.10.0
         */
        this.export = new EventEmitter();
        /**
         * Emits when popupAnimationDone event triggered on toolbar dropdown item
         * Can be useful when you want to handle custom logic after dropdown opened/closed(for example register items from custom template for a correct work of keyboard navigation)
         * @since 12.18.0
         */
        this.toolbarPopupAnimationDone = new EventEmitter();
        this.mainClass = true;
        this.adaptTableClass = true;
        this._loading = false;
        this._hasVerticalBodyOverflow = false;
        this._dontEmitInfiniteScroll = false;
        this._instanceId = ++AdaptTableComponent.LAST_TABLE_INSTANCE_ID;
        this._isRefreshingRowData = false;
        this._destroyed$ = new ReplaySubject(1);
        this._defaultTexts = {
            textFilterTexts: {},
            selectFilterTexts: {},
            mergedFiltersTexts: {}
        };
        this._defaultMinColWidth = 45;
        this.editMode = 'row';
        this.paginatorPosition = 'none';
        this.reorderableColumns = true;
        this.rowTrackBy = this.trackByForRowsData.bind(this);
        this.trackByForRenderingRows = this.trackByForRenderingRows.bind(this);
        this.trackByForRenderingColumns = this.trackByForRenderingColumns.bind(this);
        this.trackByForColumns = this.trackByForColumns.bind(this);
        this.trackByForRowsData = this.trackByForRowsData.bind(this);
        this.isRtl = this._dir.value === 'rtl';
        this.setDefaultTexts(_ts.getCurrentLanguage());
        this._tooltipOverlayPlacements = getOverlayConnectedPositions(this._dir.value);
    }
    /**
     * Template that will be shown when row expanded. If not set, the expansion icon will be hidden
     * @docs-default
     */
    set expandedRowTemplate(template) {
        this._expandedRowTemplate = template;
        this.expandedRowTemplateRef = isDefined(template) ? this.rowExpansionTemplate : null;
    }
    get expandedRowTemplate() {
        return this._expandedRowTemplate;
    }
    /**
     * Show/hide row data refreshing state
     * @docs-default
     */
    get isRefreshingRowData() {
        return this._isRefreshingRowData;
    }
    set isRefreshingRowData(value) {
        if (value) {
            this.zone.onStable
                .pipe(takeUntil(this._destroyed$), take(1))
                .subscribe(() => {
                const tableHeaderHeight = this.scrollable ?
                    this.scrollableView.scrollHeaderViewChild.nativeElement.offsetHeight :
                    this.tableHeader.nativeElement.offsetHeight + 2;
                this.tableBodyHeight = `calc(100% - ${tableHeaderHeight}px)`;
                // never detectChanges in a subscription to `onStable` without reattaching to the NgZone
                // (onStable always emits outside the NgZone)
                this.zone.run(() => SafeCdr.detectChanges(this.cd));
            });
        }
        this._isRefreshingRowData = value;
    }
    /**
     * Rows data
     * @docs-default []
     */
    set value(value) {
        this._value = value;
        if (this.autoScrollToTop && value && this.lazy && value.length <= this.rows && !this.enableInfiniteScrolling) {
            this.tryScrollToTopTableBody();
        }
    }
    get value() {
        return this._value;
    }
    get scrollableClass() {
        return this.scrollable;
    }
    get notScrollableClass() {
        return !this.scrollableClass;
    }
    get isEmptyState() {
        return this.isEmpty();
    }
    get hasSelection() {
        return !!this.selectionMode;
    }
    get hasExpandingBtn() {
        return !!(this.expandedRowTemplate || this.hasAtLeastOneRowGroupedData());
    }
    get canShowFullLoader() {
        return this.showLoader && !this.loadingMore;
    }
    get paginatorClass() {
        return this.paginatorAlign === 'right' ? 'at-paginator--right' : '';
    }
    get loading() {
        return this._loading;
    }
    /**
     * Control loading state
     * @docs-default false
     */
    set loading(val) {
        this.setIsLoadingState(val);
    }
    get selectionLimit() {
        return this.toolbarConfig && this.toolbarConfig.selectionLimit;
    }
    get hasSelectionLimit() {
        return !this.isSingleSelectionMode() && Boolean(this.selectionLimit);
    }
    get isSingleSortMode() {
        return this.sortMode === SortMode.Single;
    }
    get isMultipleSortMode() {
        return this.sortMode === SortMode.Multiple;
    }
    /* Lifecycles START */
    ngOnInit() {
        if (this.virtualScroll && !this.scrollable) {
            adaptError('ADAPT TABLE: Seems like you are trying to use "virtualScroll" for non scrollable table. Please set "scrollable" to "true" or remove "virtualScroll"');
        }
        super.ngOnInit();
        this._deprecationMiddleware.init(this);
        this.primengTable = this;
        this.bodyTemplate = this.tableBodyTemplateRef;
        this.headerTemplate = this.tableHeaderTemplateRef;
        this.colGroupTemplate = this.tableColgroupTemplateRef;
        this.emptyMessageTemplate = this.tableEmptyMessageTemplateRef;
        this.isMobile = this._adaptDeviceDetectionService.isMobile();
        this.texts = Object.assign(Object.assign({}, this._defaultTexts), this.texts);
        this.rowSelectionRadiobuttonName = `rowSelectionGroup${this._instanceId}`;
        this.columns.forEach((col) => {
            /*
             * Generate property columnAdaptID to assign [attr.data-testid] in QA purposes.
             * Column index must be static number during reordering columns.
             */
            col.columnAdaptID = 'adapt-table-' + this._instanceId + '-th-' + this.columnIndex++;
        });
        this._autoScrollTopOnValueSourceChangeForNotLazy();
        // If totalRecords is null we assume that all other inputs also can't be calculated
        if (isNull(this.totalRecords)) {
            this.disabledSelectedRowsCount = null;
            this.disabledNotSelectedRowsCount = null;
            this.disabledSelectedFilteredRowsCount = null;
            this.disabledNotSelectedFilteredRowsCount = null;
            this.selectedFilteredRowsCount = null;
            this.totalRecordsInGroup = null;
        }
    }
    ngAfterViewInit() {
        this._setHostClassHasNotScroll();
        this.zone.runOutsideAngular(() => {
            this.zone.onStable.asObservable().pipe(takeUntil(this._destroyed$)).subscribe(() => {
                // !TODO: Potential performance bottleneck
                this.updateHasBodyScroll();
            });
        });
        this.updateFirstHeaderCellWidth();
        this._showInstantiatedTooltipDelayed = debounce(this._showInstantiatedTooltip, this.tooltipInitialDelayMs);
        this.zone.runOutsideAngular(() => {
            fromEvent(this.el.nativeElement, 'mousemove').pipe(debounceTime(100), takeUntil(this._destroyed$)).subscribe((e) => this._onTableMouseMoveDebounced(e));
            fromEvent(this.el.nativeElement, 'mouseleave')
                .pipe(takeUntil(this._destroyed$))
                .subscribe((e) => this._onTableMouseLeave(e));
            fromEvent(this.el.nativeElement, 'mousemove').pipe(takeUntil(this._destroyed$))
                .subscribe((e) => this._onTableMouseMove(e));
            fromEvent(this.el.nativeElement, 'click').pipe(takeUntil(this._destroyed$))
                .subscribe((e) => this._onTableClick(e));
        });
        this._enableKeyboardNavigation();
        this.subscribeOnTableBodyScroll();
        this._recalculateActionColWidth();
        this.tableService.viewRelatedDataSource$
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            this._recalculateActionColWidth();
        });
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this._docListener) {
            this._docListener();
        }
        this._hideTooltip();
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes.rows && !changes.rows.firstChange && this.virtualScroll) {
            this.cd.detectChanges();
        }
        if (changes.texts && !changes.texts.firstChange) {
            this.texts = Object.assign(Object.assign({}, this._defaultTexts), this.texts);
        }
    }
    /* Lifecycles END */
    /* ------------------------------------------------------------------------------------------------ */
    /* Getters START */
    getTableService() {
        return this.tableService;
    }
    getScrollableBodyElement() {
        if (this.virtualScroll) {
            return this.scrollableView && this.scrollableView.virtualScrollBody
                && this.scrollableView.virtualScrollBody.elementRef.nativeElement;
        }
        return this.scrollableView && this.scrollableView.scrollBodyViewChild.nativeElement;
    }
    getColumnData(dataItem, column) {
        return this.resolveFieldData(dataItem, column.field);
    }
    getCurrentTableColumnsCount(columns) {
        return this.getColumnsForRendering(columns).length + (+!!this.isMultipleSelectionMode()) + (+!!this.isSingleSelectionMode()) +
            (+!!this.hasExpandingBtn) + (+this.enableReorderableRows);
    }
    getVisibleColumns(columns) {
        return (columns || this.columns).filter(c => this.isColumnVisible(c));
    }
    getColumnsForRendering(columns) {
        const visibleColumns = this.getVisibleColumns(columns);
        if (!this.mergeColumns) {
            return visibleColumns.map(column => {
                return {
                    columnsConfigs: [column],
                    type: RenderingColumnType.Simple
                };
            });
        }
        const columnsOrder = {};
        visibleColumns.forEach((col, i) => {
            columnsOrder[col.field] = i;
        });
        const currentViewportWidth = window.innerWidth;
        const mergedColumnPairs = this.mergeColumns ? this.mergeColumns
            .filter(item => item.viewportWidth > currentViewportWidth
            && [this._getColumnByField(visibleColumns, item.field1), this._getColumnByField(visibleColumns, item.field2)]
                .every(column => isDefined(column)))
            .map(pair => {
            return {
                columnsConfigs: [this._getColumnByField(visibleColumns, pair.field1), this._getColumnByField(visibleColumns, pair.field2)]
                    .sort((a, b) => columnsOrder[a.field] - columnsOrder[b.field]),
                type: RenderingColumnType.Merged
            };
        }) : [];
        const singleColumns = visibleColumns.filter(column => {
            return !mergedColumnPairs.some(item => item.columnsConfigs[0].field === column.field
                || item.columnsConfigs[1] && item.columnsConfigs[1].field === column.field);
        }).map(item => {
            return {
                columnsConfigs: [item],
                type: RenderingColumnType.Simple
            };
        });
        return [...singleColumns, ...mergedColumnPairs]
            .sort((a, b) => columnsOrder[a.columnsConfigs[0].field] - columnsOrder[b.columnsConfigs[0].field]);
    }
    getColumnWidth(column, minWidth, colEl) {
        if (!column.width && this.scrollable && this.isMobile) {
            return `${Math.floor(this.tableContainer.nativeElement.offsetWidth * .9)}px`;
        }
        const minWidthNumber = parseInt(minWidth, 10);
        if (column.width
            && (column.width.includes('px') && parseInt(column.width) > minWidthNumber
                || (colEl === null || colEl === void 0 ? void 0 : colEl.offsetParent) && (colEl === null || colEl === void 0 ? void 0 : colEl.clientWidth) > minWidthNumber)) {
            return column.width;
        }
        // To avoid situations when column has 0 width and can't be visible for the user set "width" property equal "min-width".
        // We need to do that because min-width not always work correctly for table columns.
        // Additional details can be found here - https://github.bmc.com/bmc-ux/adapt-angular/issues/7833
        if ((colEl === null || colEl === void 0 ? void 0 : colEl.offsetParent) && (colEl === null || colEl === void 0 ? void 0 : colEl.clientWidth) <= minWidthNumber) {
            return minWidth;
        }
        return null;
    }
    getColumnStyles(column, colEl) {
        const minWidth = isDefined(column.minWidth) ? getValueOrFunc(column.minWidth) : `${this._defaultMinColWidth}px`;
        // If columns was resized take width info from the data attribute "resizedWidth" where saved correct width after resize
        const width = (this.resizableColumns ? colEl === null || colEl === void 0 ? void 0 : colEl.dataset['resizedWidth'] : null) || this.getColumnWidth(column, minWidth, colEl);
        return { width, minWidth };
    }
    getRowGroupTitle(dataItem) {
        var _a;
        return (_a = dataItem.groupTitle) !== null && _a !== void 0 ? _a : dataItem.groupValue;
    }
    getPlainExpandedRenderingRows(rowsData, withNotExpanded = false) {
        if (isNil(rowsData)) {
            return [];
        }
        let rootGroupDataItemsCount = 0;
        let hasGroup = false;
        const getPlainExpandedRenderingRowsRec = (dataItem, nestingLevel, primengRowIndex) => {
            if (isDefined(dataItem) && hasRowGroupedData(dataItem)) {
                hasGroup = true;
                if (withNotExpanded || this.isExpandedGroup(dataItem)) {
                    const expItems = [{
                            nestingLevel,
                            rowData: dataItem,
                            isGroup: true,
                            rowIndexForRootGroup: 0,
                            editing: false,
                            groupExpanded: true,
                            rowExpanded: false,
                        }];
                    for (const item of dataItem.items) {
                        expItems.push(...getPlainExpandedRenderingRowsRec(item, nestingLevel + 1, primengRowIndex));
                    }
                    return expItems;
                }
                return [{
                        nestingLevel,
                        rowData: dataItem,
                        isGroup: true,
                        rowIndexForRootGroup: 0,
                        editing: false,
                        groupExpanded: false,
                        rowExpanded: false,
                    }];
            }
            else {
                const rowIndexForRootGroup = hasGroup ? (rootGroupDataItemsCount++) : primengRowIndex;
                return [{
                        nestingLevel,
                        rowData: dataItem,
                        isGroup: false,
                        rowIndexForRootGroup,
                        editing: this.isRowEditing(dataItem),
                        groupExpanded: false,
                        rowExpanded: this.isRowExpanded(dataItem),
                    }];
            }
        };
        return flatten(rowsData.map((rowData, i) => getPlainExpandedRenderingRowsRec(rowData, 0, i)));
    }
    getCellStyle(renderRowData, dataColumnIndex, column) {
        const nl = renderRowData.nestingLevel;
        let baseStyles;
        if (nl > 0 && (!dataColumnIndex || dataColumnIndex === 0)) {
            if (!this.isRtl) {
                baseStyles = {
                    paddingLeft: `${this.nestedGroupPadding * nl + this.expandindCellInitialPadding}px`,
                };
            }
            else {
                baseStyles = {
                    paddingRight: `${this.nestedGroupPadding * nl + this.expandindCellInitialPadding}px`,
                };
            }
        }
        if (column && column.dataCellStyle) {
            const param = {
                dataItem: renderRowData.rowData,
                rowIndex: renderRowData.rowIndexForRootGroup,
                column,
                expanded: renderRowData.rowExpanded,
                editing: renderRowData.editing,
            };
            const custom = getValueOrFunc(column.dataCellStyle, param);
            if (custom) {
                return baseStyles ? Object.assign({}, custom, baseStyles) : custom;
            }
        }
        return baseStyles;
    }
    getMergedCellStyle(renderRowData, dataColumnIndex, columns) {
        return columns.reduce((styles, column) => {
            return Object.assign(styles, this.getCellStyle(renderRowData, dataColumnIndex, column));
        }, {});
    }
    /** Returns reference for filteredValue || value || [] */
    getAllCurrentRows() {
        return this.filteredValue || this.value || [];
    }
    getEmptyStateLabelText() {
        return this.hasFilter()
            ? this.texts.emptyStateWithFilterLabelText
            : this.texts.emptyStateLabelText;
    }
    getDataCellClass(column, renderRowData, element) {
        const classes = this.getActionConfig(column) ? [AdaptTableClasses.ActionsCell] : [];
        if (renderRowData.editing && this.isEditableColumn(column)) {
            classes.push(AdaptTableClasses.EditingCell);
        }
        if (column.dataCellClass) {
            const param = {
                dataItem: renderRowData.rowData,
                rowIndex: renderRowData.rowIndexForRootGroup,
                column,
                expanded: renderRowData.rowExpanded,
                editing: renderRowData.editing,
            };
            const customClass = getValueOrFunc(column.dataCellClass, param);
            if (customClass) {
                classes.push(customClass);
            }
        }
        if (element && this._hasCellFocus(element)) {
            classes.push('at-cell-focus');
        }
        return classes.join(' ');
    }
    getMergedDataCellClass(columns, renderRowData, element) {
        return columns.map(column => this.getDataCellClass(column, renderRowData, element)).join(' ');
    }
    getHeaderClass(column) {
        if (column.headerClass) {
            return getValueOrFunc(column.headerClass);
        }
        return '';
    }
    getMergedHeaderClass(columns) {
        return columns.map(column => this.getHeaderClass(column)).join(' ');
    }
    getDataRowClass(renderingRowData) {
        const classes = renderingRowData.rowExpanded ? ['at-row--expanded'] : [];
        if (this.rowsCustomClass) {
            const customClass = getValueOrFunc(this.rowsCustomClass, renderingRowData);
            if (customClass) {
                classes.push(customClass);
            }
        }
        if (this.isRowSelected(renderingRowData.rowData)) {
            classes.push('ui-state-highlight'); // primeng class
        }
        if (!this.isRowSelectionDisabled(renderingRowData.rowData) && this.isSingleSelectionMode()) {
            classes.push('ui-selectable-row'); // primeng class
        }
        return classes.join(' ');
    }
    getGroupRowClass(renderingRowData) {
        const classes = renderingRowData.groupExpanded ? ['at-group-row--expanded'] : [];
        if (this.rowsCustomClass) {
            const customClass = getValueOrFunc(this.rowsCustomClass, renderingRowData);
            if (customClass) {
                classes.push(customClass);
            }
        }
        return classes.join(' ');
    }
    getColumnTemplateParams(column, renderRowData) {
        return {
            column,
            dataItem: renderRowData.rowData,
            rowIndex: renderRowData.rowIndexForRootGroup,
            expanded: renderRowData.rowExpanded,
            editing: renderRowData.editing,
        };
    }
    getGroupValueDataCellTemplateParams(renderingRowData) {
        return { $implicit: renderingRowData };
    }
    getCurrentPageDisplayingRows() {
        if (this.paginator && !this.lazy) {
            return this.getAllCurrentRows().slice(this.first, this.first + this.rows);
        }
        else {
            return this.getAllCurrentRows();
        }
    }
    getCurrentPageDisplayingRowsItems() {
        return this.getRowsItems(this.getCurrentPageDisplayingRows());
    }
    getRowsItems(rows) {
        const rowDataItems = [];
        this.goRecursivelyByItemsInGroups(rows, (row) => {
            rowDataItems.push(row);
        });
        return rowDataItems;
    }
    getCurrentPageRenderingDataRows(withNotExpanded = false) {
        return this.getPlainExpandedRenderingRows(this.getCurrentPageDisplayingRows(), withNotExpanded);
    }
    getDataCellTabIndex(column, renderRowData) {
        return this.getActionConfig(column) || this.isEditableColumn(column) && renderRowData.editing ? -1 : 0;
    }
    getMergedDataCellTabIndex(columns, renderRowData) {
        return columns.every(column => {
            return this.getActionConfig(column) || this.isEditableColumn(column) && renderRowData.editing;
        }) ? -1 : 0;
    }
    getDataRowDirectiveParams(renderingRowData) {
        return {
            dataItem: renderingRowData.rowData,
            rowIndex: renderingRowData.rowIndexForRootGroup,
            expanded: renderingRowData.rowExpanded,
            editing: renderingRowData.editing,
        };
    }
    getHeaderDataCellDirectiveParams(renderingColumn, index) {
        return {
            renderingColumn,
            column: renderingColumn.columnsConfigs[0],
            index
        };
    }
    getDataCellDirectiveParams(renderingColumn, renderRowData) {
        return {
            column: renderingColumn.columnsConfigs[0],
            renderingColumn,
            dataItem: renderRowData.rowData,
            rowIndex: renderRowData.rowIndexForRootGroup,
            expanded: renderRowData.rowExpanded,
            editing: renderRowData.editing,
        };
    }
    getExpandedRowTemplateParams(dataItem, columns, rowIndex) {
        return {
            dataItem,
            rowIndex,
            columns,
        };
    }
    getDataCellTemplateParams(column, renderRowData) {
        return {
            column,
            renderRowData
        };
    }
    getPrimaryKey(data) {
        return this.resolveFieldData(data, this.dataKey);
    }
    getActionConfig(column) {
        return column.actionsConfig;
    }
    getTableWidth(tableWidthConfig, isMobile) {
        if (tableWidthConfig) {
            return isMobile
                ? tableWidthConfig.mobile === 'auto' ? 'auto' : `${tableWidthConfig.mobile}`
                : tableWidthConfig.desktop === 'auto' ? 'auto' : `${tableWidthConfig.desktop}`;
        }
        return 'auto';
    }
    /* Getters END */
    /* ------------------------------------------------------------------------------------------------ */
    /* Checkers START */
    hasNotRowNestingLevel(renderRowData) {
        return !renderRowData.nestingLevel;
    }
    hasReachedTotalRecords() {
        const totalRecords = this.totalRecords;
        return (totalRecords != null || totalRecords !== 0) && totalRecords === this.value.length;
    }
    /**
     * In case if user send us `totalRecords` as `null` we assume that there is no possibility to calculate
     * such data on customer side(for example server restrictions)
     */
    isTotalRecordsInfoAvailable() {
        return isNumber(this.totalRecords);
    }
    hasAtLeastOneRowGroupedData() {
        const rowsData = this.getAllCurrentRows();
        for (const row of rowsData) {
            if (isDefined(row) && hasRowGroupedData(row)) {
                return true;
            }
        }
        return false;
    }
    shouldShowExpandingButton(renderRowData) {
        if (!isDefined(this.expandedRowTemplate)) {
            return false;
        }
        const isExpandingDisabled = isFunction(this.disableRowExpandingResolver)
            ? this.disableRowExpandingResolver(renderRowData.rowData)
            : false;
        return !isExpandingDisabled;
    }
    isColumnVisible(column) {
        return !getValueOrFunc(column.hidden);
    }
    isExpandedGroup(groupedRowData) {
        const fieldGroup = this.expandedGroupsKeys[groupedRowData.groupField];
        return fieldGroup ? fieldGroup[groupedRowData.groupValue] != null : false;
    }
    isGroupCheckboxDisabled(grd) {
        return !!this.isRowSelectionDisabled(grd) || this._hasAllChildItemsDisabledForSelection(grd);
    }
    isChildrenExist(rowData) {
        return !!(rowData[this.nestingKey] && rowData[this.nestingKey].length);
    }
    isFilterableColumn(column) {
        if (!this.filterable || column.actionsConfig) {
            return false;
        }
        const filterableCol = column.filterable;
        return trueOrNull(filterableCol);
    }
    isColumnFrozen(column) {
        return getValueOrFunc(column.frozen);
    }
    hasAtLeastOneFrozenColumn() {
        return this.columns.some(column => getValueOrFunc(column.frozen));
    }
    /* Checkers END */
    /* ------------------------------------------------------------------------------------------------ */
    /* Common START */
    setDefaultTexts(translation) {
        this._defaultTexts.emptyStateLabelText = translation['adapt.table.emptyState'];
        this._defaultTexts.emptyStateWithFilterLabelText = translation['adapt.table.emptyStateWithFilter'];
        this._defaultTexts.actionButtonDefaultLabel = translation['adapt.table.actionButtonDefaultLabel'];
        this._defaultTexts.unselectAllSelectedTitle = translation['adapt.table.unselectAllSelectedTitle'];
        this._defaultTexts.saveRowEditingButtonLabel = translation['adapt.common.save'];
        this._defaultTexts.cancelRowEditingButtonLabel = translation['adapt.common.cancel'];
        this._defaultTexts.fromToOfTextTemplate = translation['adapt.table.toolbar.fromToOfTextTemplate'];
        this._defaultTexts.fromToTextTemplate = translation['adapt.table.toolbar.fromToTextTemplate'];
        this._defaultTexts.totalCountTextTemplate = translation['adapt.table.toolbar.totalCountTextTemplate'];
        this._defaultTexts.totalCountTextTemplatePlural = translation['adapt.table.toolbar.totalCountTextTemplatePlural'];
        this._defaultTexts.noRecordsText = translation['adapt.table.toolbar.noRecordsText'];
        this._defaultTexts.outOfShownTextTemplate = translation['adapt.table.toolbar.outOfShownTextTemplate'];
        this._defaultTexts.recordsCountShownTextTemplate = translation['adapt.table.toolbar.recordsCountShownTextTemplate'];
        this._defaultTexts.recordsCountShownTextTemplatePlural = translation['adapt.table.toolbar.recordsCountShownTextTemplatePlural'];
        this._defaultTexts.searchPlaceholder = translation['adapt.common.search'];
        this._defaultTexts.searchLabel = translation['adapt.common.search'];
        this._defaultTexts.visibleColumnsMenuLabel = translation['adapt.table.toolbar.visibleColumnsMenuLabel'];
        this._defaultTexts.filterButtonLabel = translation['adapt.common.filter'];
        this._defaultTexts.selected = translation['adapt.table.toolbar.selected'];
        this._defaultTexts.showAllSelected = translation['adapt.table.toolbar.showAllSelected'];
        this._defaultTexts.headerSelectRowsArialLabel = translation['adapt.table.headerSelectRowsArialLabel'];
        this._defaultTexts.refresh = translation['adapt.table.toolbar.refresh'];
        this._defaultTexts.clearButtonText = translation['adapt.common.clear'];
        this._defaultTexts.textFilterTexts.placeholder = translation['adapt.common.filter'];
        this._defaultTexts.textFilterTexts.label = translation['adapt.common.filter'];
        this._defaultTexts.selectFilterTexts.defaultTitle = translation['adapt.common.filter'];
        this._defaultTexts.mergedFiltersTexts.buttonNoAppliedFilters = translation['adapt.common.filter'];
        this._defaultTexts.mergedFiltersTexts.buttonAppliedFilter = translation['adapt.table.filters.mergedFilters.appliedFilter'];
        this._defaultTexts.mergedFiltersTexts.buttonAppliedFilters = translation['adapt.table.filters.mergedFilters.appliedFilters'];
        this._defaultTexts.mergedFiltersTexts.appliedFiltersLabel = translation['adapt.table.filters.mergedFilters.appliedFiltersLabel'];
        this._defaultTexts.goBtnText = translation['adapt.table.pagination.go'];
        this._defaultTexts.pageNumberText = translation['adapt.table.pagination.pageNumber'];
        this._defaultTexts.orderLabelSort = translation['adapt.common.sort'];
        this._defaultTexts.orderLabelAddToSort = translation['adapt.table.headerCellMenu.orderLabelAddToSort'];
        this._defaultTexts.orderAscBtn = translation['adapt.table.headerCellMenu.orderAsc'];
        this._defaultTexts.orderDescBtn = translation['adapt.table.headerCellMenu.orderDesc'];
        this._defaultTexts.selectSortOrderLabel = translation['adapt.table.headerCellMenu.selectSortOrderLabel'];
        this._defaultTexts.selectSortOrderOption = translation['adapt.table.headerCellMenu.selectSortOrderOption'];
        this._defaultTexts.removeCurrentFromSortingBtn = translation['adapt.table.headerCellMenu.removeCurrentFromSorting'];
        this._defaultTexts.clearAllSortingBtn = translation['adapt.table.headerCellMenu.clearAllSorting'];
        this._defaultTexts.recordsPerPage = translation['adapt.table.paginator.recordsPerPage'];
        this._defaultTexts.expandRowText = translation['adapt.table.expandRow'];
        this._defaultTexts.collapseRowText = translation['adapt.table.collapseRow'];
        this._defaultTexts.prevPageBtnText = translation['adapt.common.previous'];
        this._defaultTexts.nextPageBtnText = translation['adapt.common.next'];
        this._defaultTexts.selectAllItemsOnPageHeaderLabel = translation['adapt.table.selectAllItemsOnPageHeaderLabel'];
        this._defaultTexts.selectAllFilteredItemsOnPageHeaderLabel = translation['adapt.table.selectAllFilteredItemsOnPageHeaderLabel'];
        this._defaultTexts.selectAllPossibleItemsOnPageHeaderLabel = translation['adapt.table.selectAllPossibleItemsOnPageHeaderLabel'];
        this._defaultTexts.selectAllPossibleFilteredItemsOnPageHeaderLabel = translation['adapt.table.selectAllPossibleFilteredItemsOnPageHeaderLabel'];
        this._defaultTexts.selectAllVisibleItemsHeaderLabel = translation['adapt.table.selectAllVisibleItemsHeaderLabel'];
        this._defaultTexts.selectAllFilteredVisibleItemsHeaderLabel = translation['adapt.table.selectAllFilteredVisibleItemsHeaderLabel'];
        this._defaultTexts.selectAllPossibleVisibleItemsHeaderLabel = translation['adapt.table.selectAllPossibleVisibleItemsHeaderLabel'];
        this._defaultTexts.selectAllPossibleFilteredVisibleItemsHeaderLabel = translation['adapt.table.selectAllPossibleFilteredVisibleItemsHeaderLabel'];
        this._defaultTexts.selectAllItemsInTableHeaderLabel = translation['adapt.table.selectAllItemsInTableHeaderLabel'];
        this._defaultTexts.selectAllItemsInTableHeaderLabelForUnknownTotalRecords = translation['adapt.table.selectAllItemsInTableHeaderLabelForUnknownTotalRecords'];
        this._defaultTexts.selectAllFilteredItemsInTableHeaderLabel = translation['adapt.table.selectAllFilteredItemsInTableHeaderLabel'];
        this._defaultTexts.selectAllPossibleItemsInTableHeaderLabel = translation['adapt.table.selectAllPossibleItemsInTableHeaderLabel'];
        this._defaultTexts.selectAllPossibleFilteredItemsInTableHeaderLabel = translation['adapt.table.selectAllPossibleFilteredItemsInTableHeaderLabel'];
        this._defaultTexts.deselectAllItemsInTableHeaderLabel = translation['adapt.table.deselectAllItemsInTableHeaderLabel'];
        this._defaultTexts.deselectAllFilteredItemsInTableHeaderLabel = translation['adapt.table.deselectAllFilteredItemsInTableHeaderLabel'];
        this._defaultTexts.deselectAllPossibleItemsInTableHeaderLabel = translation['adapt.table.deselectAllPossibleItemsInTableHeaderLabel'];
        this._defaultTexts.deselectAllPossibleFilteredItemsInTableHeaderLabel = translation['adapt.table.deselectAllPossibleFilteredItemsInTableHeaderLabel'];
        this._defaultTexts.export = translation['adapt.table.toolbar.export'];
        this._defaultTexts.exportEntireDocument = translation['adapt.table.toolbar.exportEntireDocument'];
        this._defaultTexts.exportSelected = translation['adapt.table.toolbar.exportSelected'];
    }
    onRadiobuttonModelChange(rowDataItem) {
        this.toggleRowSelection(rowDataItem);
    }
    updateHasBodyScroll() {
        if (!this.scrollable) {
            return;
        }
        const hasVerticalBodyOverflow = this.scrollableView.hasVerticalOverflow();
        if (this._hasVerticalBodyOverflow === hasVerticalBodyOverflow) {
            return;
        }
        this._hasVerticalBodyOverflow = hasVerticalBodyOverflow;
        if (hasVerticalBodyOverflow) {
            this.el.nativeElement.classList.remove(AdaptTableClasses.HasNotVerticalBodyOverflow);
        }
        else {
            this._setHostClassHasNotScroll();
        }
        this.scrollableView.alignScrollBar();
    }
    handleColumnResized(event) {
        this.onColResize.emit(event);
        SafeCdr.detectChanges(this.cd);
    }
    onGroupToggleClick(groupedRowData) {
        let fieldGroup = this.expandedGroupsKeys[groupedRowData.groupField];
        if (!fieldGroup) {
            fieldGroup = this.expandedGroupsKeys[groupedRowData.groupField] = {};
        }
        const oldIsExpanded = this.isExpandedGroup(groupedRowData);
        if (oldIsExpanded) {
            delete fieldGroup[groupedRowData.groupValue];
        }
        else {
            fieldGroup[groupedRowData.groupValue] = true;
        }
        this.groupExpansion.emit({
            expanded: !oldIsExpanded,
            groupedRowData,
        });
        this.zone.onStable.asObservable().pipe(takeUntil(this._destroyed$), take(1)).subscribe(() => {
            this.updateFirstHeaderCellWidth();
        });
    }
    updateFirstHeaderCellWidth() {
        const firstColDirective = this.dataHeaderCells.first;
        const firstCol = firstColDirective && firstColDirective.element;
        if (firstCol && Object.keys(this.expandedGroupsKeys).length > 0 && this.dataRows) {
            firstCol.nativeElement.style.width = null;
            let maxWidth = 0;
            this.dataRows.forEach(data => {
                const firstTd = data.element.nativeElement.querySelector('.at-data-cell');
                if (firstTd && firstTd.scrollWidth > firstTd.clientWidth && firstTd.scrollWidth > maxWidth) {
                    maxWidth = firstTd.scrollWidth;
                }
            });
            if (maxWidth) {
                if (this.updateFirstColumnWidth) {
                    this.updateFirstColumnWidth(maxWidth, firstCol.nativeElement);
                }
            }
        }
    }
    goRecursivelyByItemsInAllGroups(cb) {
        const allRows = this.getAllCurrentRows();
        allRows.forEach(row => this.goRecursivelyByItemsInGroup(row, cb));
    }
    goRecursivelyByItemsInGroups(rows, cb) {
        rows.forEach(row => this.goRecursivelyByItemsInGroup(row, cb));
    }
    goRecursivelyByItemsInGroup(rowData, cb) {
        if (isDefined(rowData) && hasRowGroupedData(rowData)) {
            rowData.items.forEach(item => {
                this.goRecursivelyByItemsInGroup(item, cb);
            });
        }
        else {
            cb(rowData);
        }
    }
    resolveFieldData(data, field) {
        return ObjectUtils.resolveFieldData(data, field);
    }
    createLazyLoadMetadata(eventSource) {
        return {
            eventSource,
            first: this.first,
            rows: this.rows,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            filters: this.filters,
            globalFilter: this.filters && this.filters.global ? this.filters.global.value : null,
            multiSortMeta: this.multiSortMeta,
            loadMore: false,
            infiniteScrollingFirst: null
        };
    }
    subscribeOnTableBodyScroll() {
        const scrollToEndMargin = 2; // in pixels
        const scrollBody = this.getScrollableBodyElement();
        if (scrollBody) {
            this.zone.runOutsideAngular(() => {
                fromEvent(scrollBody, 'scroll').pipe(takeUntil(this._destroyed$)).subscribe(() => {
                    if (!this.enableInfiniteScrolling || this.loading || this._dontEmitInfiniteScroll
                        || scrollBody.scrollHeight > scrollBody.scrollTop + scrollBody.offsetHeight + scrollToEndMargin) {
                        return;
                    }
                    if (this.hasReachedTotalRecords()) {
                        return;
                    }
                    const lazyLoadEvent = Object.assign(Object.assign({}, this.createLazyLoadMetadata(AdaptTableEventSource.LoadMore)), { loadMore: true, infiniteScrollingFirst: this.value.length });
                    this.zone.run(() => {
                        this._emitLazyLoadEvent(lazyLoadEvent);
                    });
                });
            });
        }
    }
    detectChangesForTooltip() {
        this.zone.runOutsideAngular(() => {
            setTimeout(() => {
                if (this._tooltipOverlayWithPortal) {
                    SafeCdr.detectChanges(this._tooltipOverlayWithPortal.componentRef.changeDetectorRef);
                }
            });
        });
    }
    setIsLoadingState(value) {
        this._loading = value;
        const busyConfigCopy = Object.assign({}, this.busyConfig);
        if (value) {
            if (this.busyConfig.busy) {
                this.busyConfig.busy.unsubscribe();
            }
            busyConfigCopy.busy = new Observable().pipe(takeUntil(this._destroyed$)).subscribe();
            this.busyConfig = busyConfigCopy;
        }
        else {
            if (this.busyConfig.busy) {
                this.busyConfig.busy.unsubscribe();
                busyConfigCopy.busy = null;
                this.busyConfig = busyConfigCopy;
            }
        }
        this.loadingToggle.emit(value);
    }
    tryScrollToTopTableBody() {
        const scrollableBodyElement = this.getScrollableBodyElement();
        if (scrollableBodyElement) {
            scrollableBodyElement.scrollTop = 0;
        }
    }
    onPageChange(event) {
        super.onPageChange(event);
        if (this.scrollable) {
            this.resetScrollTop();
        }
        SafeCdr.detectChanges(this.cd);
    }
    resetScrollTop() {
        if (this.virtualScroll) {
            this.scrollToVirtualIndex(0);
        }
        else {
            this.scrollTo({ top: 0 });
        }
    }
    scrollToVirtualIndex(index) {
        if (this.scrollableView) {
            this.scrollableView.scrollToVirtualIndex(index);
        }
    }
    handleScrollableWrapperResizing() {
        if (this.virtualScroll && this.scrollableView.virtualScrollBody) {
            // Because dimensions of scrollable wrapper can be changed in runtime
            // need to call checkViewportSize() method that update the viewport dimensions and re-render
            this.scrollableView.virtualScrollBody.checkViewportSize();
        }
    }
    scrollTo(options) {
        if (this.scrollableView) {
            this.scrollableView.scrollTo(options);
        }
    }
    setDefaultActionColWidth() {
        var _a, _b, _c, _d;
        const tableElement = this.scrollable
            ? (_b = (_a = this.scrollableView) === null || _a === void 0 ? void 0 : _a.scrollTableViewChild) === null || _b === void 0 ? void 0 : _b.nativeElement
            : (_c = this.nonScrollableTable) === null || _c === void 0 ? void 0 : _c.nativeElement;
        if (!tableElement || !((_d = this.actionColElements) === null || _d === void 0 ? void 0 : _d.length)) {
            return null;
        }
        const actionCols = this.actionColElements.toArray();
        const tableLayout = tableElement.style.tableLayout;
        // Set table layout to auto and actions column width to 1% to get the width of the action column based on its content
        const actionColsWidth = actionCols.map(actionCol => {
            this._renderer.setStyle(tableElement, 'tableLayout', 'auto');
            this._renderer.setStyle(actionCol.nativeElement, 'width', '1%');
            const width = actionCol.nativeElement.clientWidth;
            // Reset styles to previous values after action column width was calculated
            this._renderer.setStyle(tableElement, 'tableLayout', tableLayout);
            this._renderer.setStyle(actionCol.nativeElement, 'width', '');
            return width;
        });
        this.zone.run(() => {
            // Find maximum column width and set it to the action column
            actionCols.forEach(actionCol => {
                this._renderer.setStyle(actionCol.nativeElement, 'width', `${Math.max(...actionColsWidth)}px`);
            });
        });
    }
    /* Common END */
    /* ------------------------------------------------------------------------------------------------ */
    /* TrackBy START */
    trackByForRenderingRows(index, renderRowData) {
        // by primary key or index
        if (renderRowData.isGroup) {
            const grd = renderRowData.rowData;
            return `groupValue_${grd.groupField}:${grd.groupValue}`;
        }
        else {
            return this.getPrimaryKey(renderRowData.rowData) || index;
        }
    }
    trackByForRowsData(index, row) {
        return this.getPrimaryKey(row) || index;
    }
    trackByForRenderingColumns(index, renderingColumn) {
        // by primary key or index
        return renderingColumn.columnsConfigs.map(column => column.field).join('-') || index;
    }
    trackByForColumns(index, column) {
        return column.field || index;
    }
    /* TrackBy END */
    /* ------------------------------------------------------------------------------------------------ */
    /* Selection feature START */
    getGroupSelectionState(grd) {
        if (this.getRowSelectionArray().length === 0) {
            return CheckboxState.Unselected;
        }
        let childrenCount = 0;
        let selectedChildrenCount = 0;
        this.goRecursivelyByItemsInGroup(grd, (item) => {
            childrenCount++;
            if (this.isRowSelected(item)) {
                selectedChildrenCount++;
            }
        });
        if (childrenCount === 0 || selectedChildrenCount === 0) {
            return CheckboxState.Unselected;
        }
        return childrenCount === selectedChildrenCount ? CheckboxState.Selected : CheckboxState.Indeterminate;
    }
    getRowSelectionArray() {
        const selection = this.selection;
        return selection ? (Array.isArray(selection) ? selection : [selection]) : [];
    }
    getRowSelectionKeys() {
        return this.selectionKeys || {};
    }
    getSelectableRowsItems(rows) {
        const result = [];
        this.goRecursivelyByItemsInGroups(rows, (row) => {
            if (!this.isRowSelectionDisabled(row)) {
                result.push(row);
            }
        });
        return result;
    }
    isSingleSelectionRowSelected(data) {
        const selection = this.getRowSelectionArray();
        return selection.length
            ? this.getPrimaryKey(selection[0]) === this.resolveFieldData(data, this.dataKey)
            : false;
    }
    isRowSelected(rowDataItem) {
        // const rowId = this.getPrimaryKey(rowDataItem);
        // return rowId == null ? false : this.getRowSelectionKeys()[rowId];
        if (typeof rowDataItem === 'object' && rowDataItem) {
            return this.isSelected(rowDataItem);
        }
        // row Id
        return this.getRowSelectionKeys()[rowDataItem];
    }
    isRowSelectionCheckboxDisabled(data) {
        return this.isRowSelectionDisabled(data)
            || (this.selectionLimit === (this.getRowSelectionArray().length)
                && !Object.keys(this.selectionKeys).find(key => key === data[this.dataKey]));
    }
    isRowSelectionDisabled(rowData) {
        if (isFunction(this.disabledRowSelectionResolver)) {
            return this.disableRowSelection || this.disabledRowSelectionResolver(rowData);
        }
        else {
            return this.disableRowSelection;
        }
    }
    isSelectedGroupCheckbox(grd) {
        return grd && !this.isRowSelectionDisabled(grd)
            && (this.getGroupSelectionState(grd) === CheckboxState.Selected || this.getGroupSelectionState(grd) === CheckboxState.Indeterminate);
    }
    isGroupSelectionIndeterminate(grd) {
        return this.getGroupSelectionState(grd) === CheckboxState.Indeterminate;
    }
    onGroupSelectionChanged(checked, grd) {
        this.onToogleGroupedRowsSelection(checked, [grd]);
        this.groupSelection.emit({
            groupedRowData: grd,
            selected: checked,
        });
    }
    addToRowSelection(dataItems) {
        if (Array.isArray(dataItems) && dataItems.length === 0) {
            return;
        }
        if (this.isMultipleSelectionMode()) {
            const newSelection = this.getRowSelectionArray().slice();
            const dataItemsToAdd = [];
            dataItems.forEach(di => {
                if (!this.isRowSelected(di)) {
                    dataItemsToAdd.push(di);
                }
            });
            newSelection.push(...dataItemsToAdd);
            this._updateRowSelection(newSelection);
        }
        else {
            this._updateRowSelection(dataItems);
        }
    }
    toggleRowSelection(dataItem, event = null) {
        if (this.isRowSelectionDisabled(dataItem)) {
            return false;
        }
        const dataItemToToggleKey = this.getPrimaryKey(dataItem);
        const oldSelection = this.getRowSelectionArray().slice();
        let newSelection = [];
        let addedToSelection = false;
        if (this.isMultipleSelectionMode()) {
            let hasRemovedDataItem = false;
            oldSelection.forEach(di => {
                if (this.getPrimaryKey(di) === dataItemToToggleKey) {
                    hasRemovedDataItem = true;
                }
                else {
                    newSelection.push(di);
                }
            });
            addedToSelection = !hasRemovedDataItem;
            if (addedToSelection) {
                newSelection.push(dataItem);
            }
        }
        else {
            const shouldRemoveDataItem = oldSelection.some(di => this.getPrimaryKey(di) === dataItemToToggleKey);
            addedToSelection = !shouldRemoveDataItem;
            if (addedToSelection) {
                newSelection = [dataItem];
            }
        }
        this._updateRowSelection(newSelection);
        if (addedToSelection) {
            this.onRowSelect.emit({ originalEvent: event, index: null, data: dataItem, type: 'row' });
        }
        else {
            this.onRowUnselect.emit({ originalEvent: event, index: null, data: dataItem, type: 'row' });
        }
        return addedToSelection;
    }
    removeFromRowSelection(dataItems) {
        if (dataItems.length === 0) {
            return;
        }
        const oldSelection = this.getRowSelectionArray();
        const newSelection = [];
        oldSelection.forEach(di => {
            const selectedDiKey = this.getPrimaryKey(di);
            for (const item of dataItems) {
                const tempDiKey = this.getPrimaryKey(item);
                if (selectedDiKey === tempDiKey) {
                    return;
                }
            }
            newSelection.push(di);
        });
        this._updateRowSelection(newSelection);
    }
    // TODO: what if selected row is disabled for selection
    unselectAllSelected() {
        this._updateRowSelection([]);
    }
    onToogleGroupedRowsSelection(checked, rows) {
        const dataItemsToChangeSelection = this.getSelectableRowsItems(rows);
        if (checked) {
            this.addToRowSelection(dataItemsToChangeSelection);
        }
        else {
            this.removeFromRowSelection(dataItemsToChangeSelection);
        }
    }
    handleHeaderCheckboxToggle(event) {
        this.onHeaderCheckboxToggle.emit({
            originalEvent: event.originalEvent,
            checked: event.checked,
            eventSource: event.eventSource,
            filters: event.filters,
            globalFilter: event.globalFilter
        });
        this.allGroupedRowsSelection.emit({
            rowsData: this.getRowSelectionArray(),
            selected: event.checked,
        });
    }
    /* Selection feature END */
    /* ------------------------------------------------------------------------------------------------ */
    /* Row reordering START */
    onReordarableRowMouseDown(elem, isGroup) {
        if (!isGroup) {
            this.setColumnsWidth(elem);
        }
    }
    setColumnsWidth(row) {
        const theadElements = Array.from(this.el.nativeElement.querySelectorAll('tr th'));
        const currWidth = theadElements.map((elem) => elem.offsetWidth);
        const draggableRow = Array.from(row.cells);
        draggableRow.forEach((item, ind) => {
            this._renderer.setStyle(item, 'maxWidth', `${currWidth[ind]}px`);
            this._renderer.setStyle(item, 'width', `${currWidth[ind]}px`);
            if (this.bordered && item.classList.contains('at-data-cell')) {
                if (this.isRtl) {
                    this._renderer.setStyle(item, 'borderLeft', '1px solid #d9dada');
                }
                else {
                    this._renderer.setStyle(item, 'borderRight', '1px solid #d9dada');
                }
            }
        });
    }
    setColumnsWidthToAuto(row) {
        const draggableRow = Array.from(row.cells);
        draggableRow.forEach((item) => {
            this._renderer.setStyle(item, 'maxWidth', 'auto');
            this._renderer.setStyle(item, 'width', 'auto');
            if (this.bordered && item.classList.contains('at-data-cell')) {
                if (this.isRtl) {
                    this._renderer.removeStyle(item, 'borderLeft');
                }
                else {
                    this._renderer.removeStyle(item, 'borderRight');
                }
            }
        });
    }
    onCdkDropListSortedRow(event) {
        const currentRowData = event.item.data.rowData;
        const allCurrentRows = this.getAllCurrentRows();
        const indexOfRowData = allCurrentRows.findIndex(row => row === currentRowData);
        moveItemInArray(allCurrentRows, indexOfRowData, indexOfRowData + event.currentIndex - event.previousIndex);
    }
    onRowDragStarted(event) {
        this.rowDragStart.emit({ cdkDragStartEvent: event });
    }
    onRowDragDropped(event, elem) {
        this.rowDragDrop.emit({ cdkDragDropEvent: event });
        this.setColumnsWidthToAuto(elem);
    }
    onRowDragEnded(event) {
        this.rowDragEnd.emit({ cdkDragEndEvent: event });
    }
    onRowDragReleased(event) {
        this.rowDragRelease.emit({ cdkDragReleaseEvent: event });
    }
    /* Row reordering END */
    /* ------------------------------------------------------------------------------------------------ */
    /* Row editing START */
    getEditableClonedRow(dataItem) {
        return this.currentEditingRows[this.getPrimaryKey(dataItem)].editingDataItem;
    }
    isEditableColumn(column) {
        return trueOrNull(column.editable);
    }
    initRowEditing(dataItem) {
        this.currentEditingRows[this.getPrimaryKey(dataItem)] = {
            originalDataItem: Object.assign({}, dataItem),
            editingDataItem: Object.assign({}, dataItem),
            dataItemReference: dataItem,
        };
        this.initRowEdit(dataItem);
    }
    saveRowEditing(dataItem) {
        const id = this.getPrimaryKey(dataItem);
        const currentEditingRow = this.currentEditingRows[id];
        if (!currentEditingRow) {
            return;
        }
        const trData = this.dataRows.find(dataRow => dataRow.data.editing &&
            this.getPrimaryKey(dataRow.data.dataItem) === id);
        this.saveRowEdit(dataItem, trData.element.nativeElement);
        // saveRowEdit not always remove editing
        if (this.isRowEditing(dataItem)) {
            return;
        }
        delete this.currentEditingRows[id];
        merge(dataItem, currentEditingRow.editingDataItem);
        this.savedRowEditing.emit({ editingRow: currentEditingRow });
    }
    cancelRowEditing(dataItem) {
        const id = this.getPrimaryKey(dataItem);
        const currentEditingRow = this.currentEditingRows[id];
        if (!currentEditingRow) {
            return;
        }
        delete this.currentEditingRows[id];
        this.cancelRowEdit(dataItem);
        this.canceledRowEditing.emit({ editingRow: currentEditingRow });
    }
    onTableCellDoubleClick(rowData) {
        if (this.enableRowEditing) {
            this.initRowEditing(rowData);
        }
    }
    onTextfieldKeydown(dataItem, event) {
        const enableEditingButtons = this.getVisibleColumns()
            .some(column => this.getActionConfig(column) && this.getActionConfig(column).enableRowEditingButtons);
        if (!enableEditingButtons) {
            if (hasKeyboardKeyCode(event, 'Enter', ENTER)) {
                this.saveRowEditing(dataItem);
            }
            else if (hasKeyboardKeyCode(event, 'Escape', ESCAPE)) {
                this.cancelRowEditing(dataItem);
            }
        }
    }
    /* Row editing END */
    /* ------------------------------------------------------------------------------------------------ */
    /* Sorting START */
    getSortedDataRows() {
        const allRowsItems = this.getCurrentPageDisplayingRowsItems();
        const mapOfRows = new Map(allRowsItems.map((row, index) => [row, index]));
        return this.dataRows.toArray().sort((dataRow1, dataRow2) => {
            const index1 = mapOfRows.get(dataRow1.data.dataItem);
            const index2 = mapOfRows.get(dataRow2.data.dataItem);
            return index1 - index2;
        });
    }
    getColumnSortOrder(field) {
        if (this.sortMode === 'single') {
            return this.sortOrder;
        }
        const sortData = this.getSortMeta(field);
        return sortData ? sortData.order : null;
    }
    isColumnSortOrderAsc(field) {
        return this.getColumnSortOrder(field) === SortOrder.Asc;
    }
    isSortableColumn(column) {
        if (!this.sortable || column.actionsConfig) {
            return false;
        }
        const sortableCol = column.sortable;
        return trueOrNull(sortableCol);
    }
    isSortableRenderingColumn(renderingColumn) {
        return renderingColumn.columnsConfigs.some(column => this.isSortableColumn(column));
    }
    updateMultiSortMeta(multiSortMeta) {
        this.multiSortMeta = multiSortMeta;
        this._multiSortMeta = multiSortMeta;
        if (multiSortMeta === null) {
            if (this.lazy) {
                this._emitLazyLoadEvent(this.createLazyLoadMetadata(AdaptTableEventSource.MultipleSortChange));
            }
            this._emitOnSortForMultiSorting();
        }
        else {
            this.sortMultiple();
        }
    }
    onTableRefresh() {
        if (this.lazy) {
            this._emitLazyLoadEvent(this.createLazyLoadMetadata(AdaptTableEventSource.Refresh));
        }
    }
    setQuickFilter(value) {
        this.filterGlobal(value, this.toolbarConfig.quickFilterMatchMode || 'contains');
    }
    /* Sorting END */
    /* ------------------------------------------------------------------------------------------------ */
    _emitLazyLoadEvent(lazyLoadEvent) {
        this.onLazyLoad.emit(lazyLoadEvent);
    }
    _emitOnSortForMultiSorting() {
        this.onSort.emit({
            multisortmeta: this.multiSortMeta
        });
        this.getTableService().onSort(this.multiSortMeta);
    }
    _getColumnByField(columns, field) {
        return columns.find(column => column.field === field);
    }
    _autoScrollTopOnValueSourceChangeForNotLazy() {
        this.getTableService().valueSource$.pipe(takeUntil(this._destroyed$)).subscribe(() => {
            if (!this.lazy && this.autoScrollToTop) {
                this.tryScrollToTopTableBody();
            }
        });
    }
    _setHostClassHasNotScroll() {
        const hostEl = this.el.nativeElement;
        if (!hostEl.classList.contains(AdaptTableClasses.HasNotVerticalBodyOverflow)) {
            hostEl.classList.add(AdaptTableClasses.HasNotVerticalBodyOverflow);
        }
    }
    _updateRowSelection(selection) {
        if (this.isSingleSelectionMode()) {
            if (Array.isArray(selection)) {
                selection = selection.length ? selection[0] : null;
            }
        }
        else {
            // filter disabled items
            // TODO: maybe disallow rows deselecting and add to 'selection' var already selected and disabled rows
            selection = selection.filter(row => {
                const alreadyRowSelected = this.isRowSelected(row);
                return !this.isRowSelectionCheckboxDisabled(row) || alreadyRowSelected;
            });
            // check selection limit
            if (this.hasSelectionLimit && selection.length > this.selectionLimit) {
                selection = selection.slice(0, this.selectionLimit);
            }
        }
        this._selection = this._selection = selection;
        this.updateSelectionKeys();
        this.selectionChange.emit(selection);
        this.getTableService().onSelectionChange(this._selection);
    }
    _onTableMouseMoveDebounced(e) {
        if (this.suppressTooltip) {
            return;
        }
        const target = e.target;
        // While columns merged, there are 2 block with data where need to use tooltip. Added new class "at-tooltip-el" for that task.
        // TODO: Better to use element reference instead query by class name
        const cellTarget = target.closest('.at-tooltip-el');
        const isSameCell = this._lastTooltipTargetCell === cellTarget;
        if (cellTarget) {
            // Tooltip for data cell
            this._lastTooltipTargetCell = cellTarget;
            const tooltipValue = this._getCellTooltipData(cellTarget);
            if (tooltipValue && !isSameCell) {
                this._showTooltip(cellTarget, tooltipValue);
                return;
            }
        }
        else {
            // Tooltip for header cell
            // TODO: Better to use element reference instead query by class name
            const headerDataCellContainerEl = target.closest(`.${AdaptTableClasses.HeaderContainer}`);
            // TODO: Better to use element reference instead query by class name
            const headerDataCellTarget = target.closest(`.${AdaptTableClasses.HeaderDataCell} `);
            if (headerDataCellContainerEl && headerDataCellTarget) {
                // TODO: Better to use element reference instead query by class name
                const headerDataCellNameEl = headerDataCellContainerEl.querySelector(`.${AdaptTableClasses.HeaderTitle}`);
                this._lastTooltipTargetCell = headerDataCellTarget;
                const tooltipValue = this._getHeaderDataCellTooltipData(headerDataCellTarget, headerDataCellNameEl);
                if (tooltipValue) {
                    this._showTooltip(headerDataCellTarget, tooltipValue);
                    return;
                }
            }
        }
        this._lastTooltipTargetCell = null;
        this._hideTooltip();
    }
    _getCellTooltipData(cellTarget) {
        const mergedColumnField = cellTarget.getAttribute('data-merged-column-field');
        const tableCell = cellTarget.closest('td');
        const cellData = this.dataCells.find(dc => dc.element.nativeElement === tableCell);
        if (!cellData) {
            return null;
        }
        const column = mergedColumnField ?
            this._getColumnByField(cellData.data.renderingColumn.columnsConfigs, mergedColumnField) : cellData.data.column;
        const tooltipValue = getValueOrFunc(column.cellTooltip, cellData.data);
        if (tooltipValue) {
            return tooltipValue;
        }
        if (tooltipValue === false) {
            return null;
        }
        if (!HtmlUtils.hasShrunkText(cellTarget) && !this.alwaysShowCellTooltip) {
            return null;
        }
        return cellTarget.innerText || this.getColumnData(cellData.data.dataItem, column) || null;
    }
    _getHeaderDataCellTooltipData(headerDataCellEl, headerDataCellNameEl) {
        const dataHeaderCellData = this.dataHeaderCells.find(dc => dc.element.nativeElement === headerDataCellEl);
        if (!dataHeaderCellData) {
            return null;
        }
        const column = dataHeaderCellData.data.column;
        const tooltipValue = getValueOrFunc(column.headerTooltip);
        if (tooltipValue) {
            return tooltipValue;
        }
        if (tooltipValue === false) {
            return null;
        }
        if (!headerDataCellNameEl || !HtmlUtils.hasShrunkText(headerDataCellNameEl) && !this.alwaysShowHeaderTooltip) {
            return null;
        }
        return headerDataCellNameEl.innerText || column.header || null;
    }
    _showTooltip(target, content) {
        this.zone.run(() => {
            if (this.tooltipInitialDelayMs && !this._showedTooltipAfterGridMouseLeave) {
                this._showInstantiatedTooltipDelayed(target, content);
            }
            else {
                this._showInstantiatedTooltip(target, content);
            }
        });
    }
    _showInstantiatedTooltip(target, content) {
        var _a;
        // Don't show tooltip if moved mouse out of grid
        if (!this._lastTooltipTargetCell ||
            // if mouse leave viewport
            (this._lastGridMouseEvent.type === 'mouseleave' && !this._lastGridMouseEvent.relatedTarget) ||
            // if mouse leave current cell with tooltip or grid
            (this._lastGridMouseEvent.relatedTarget &&
                !this._lastTooltipTargetCell.contains(this._lastGridMouseEvent.relatedTarget))) {
            this._lastTooltipTargetCell = null;
            return;
        }
        // Don't show tooltip if body doesn't contain target
        if (!document.body.contains(target)) {
            return;
        }
        (_a = this._tooltipOverlayWithPortal) === null || _a === void 0 ? void 0 : _a.destroy();
        this._tooltipOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptTooltipComponent, null, this._injector), {
            origin: target,
            positionStrategy: 'connected',
            scrollStrategy: 'close',
            connectedPositions: [
                this._tooltipOverlayPlacements.top,
                this._tooltipOverlayPlacements.bottom,
                this._tooltipOverlayPlacements.left,
                this._tooltipOverlayPlacements.right
            ]
        });
        this._showedTooltipAfterGridMouseLeave = true;
        this._tooltipOverlayWithPortal.componentRef.instance.placement = 'auto';
        this._tooltipOverlayWithPortal.componentRef.instance.content = content;
        this._tooltipOverlayWithPortal.componentRef.instance.visible = true;
        this._tooltipOverlayWithPortal.componentRef.instance.customCls = this.tooltipClass;
        this._tooltipOverlayWithPortal.overlayRef.updatePosition();
        this.detectChangesForTooltip();
    }
    _hideTooltip() {
        var _a;
        (_a = this._tooltipOverlayWithPortal) === null || _a === void 0 ? void 0 : _a.destroy();
        this._tooltipOverlayWithPortal = null;
    }
    _onTableMouseLeave(event) {
        this._lastGridMouseEvent = event;
        this._showedTooltipAfterGridMouseLeave = false;
        this._hideTooltip();
    }
    _onTableMouseMove(e) {
        this._lastGridMouseEvent = e;
        const target = e.target;
        // Hide tooltip after moving mouse to another cell
        if (this._lastTooltipTargetCell && !this._lastTooltipTargetCell.contains(target)) {
            this._hideTooltip();
        }
    }
    _getCurrentFocusedCellData() {
        const activeElement = document.activeElement;
        return this._getCellData(activeElement);
    }
    _getCellData(targetElement) {
        if (!targetElement || !targetElement.matches('td')) {
            return null;
        }
        return this.dataCells.find(dataCell => dataCell.element.nativeElement === targetElement);
    }
    _enableKeyboardNavigation() {
        this.zone.runOutsideAngular(() => {
            fromEvent(this.el.nativeElement, 'keydown').pipe(takeUntil(this._destroyed$))
                .subscribe((e) => this._onTableKeydown(e));
        });
    }
    _onTableKeydown(event) {
        if (hasKeyboardKeyCode(event, 'ArrowDown', DOWN_ARROW, 'Down')) {
            this._focusOnCellByNavigation(event, 1, 0);
            return;
        }
        if (hasKeyboardKeyCode(event, 'ArrowUp', UP_ARROW, 'Up')) {
            this._focusOnCellByNavigation(event, -1, 0);
            return;
        }
        if (hasKeyboardKeyCode(event, 'ArrowLeft', LEFT_ARROW, 'Left')) {
            this._focusOnCellByNavigation(event, 0, -1);
            return;
        }
        if (hasKeyboardKeyCode(event, 'ArrowRight', RIGHT_ARROW, 'Right')) {
            this._focusOnCellByNavigation(event, 0, 1);
            return;
        }
        if (hasKeyboardKeyCode(event, ' ', SPACE, 'Spacebar')) {
            this._toggleRowSelectionOfFocusedCell(event);
            return;
        }
        if (hasKeyboardKeyCode(event, 'Enter', ENTER)) {
            this._initRowEditingOfFocusedCell();
        }
    }
    _onTableClick(event) {
        if (!this.enableRowEditing) {
            return;
        }
        const target = event.target;
        const clickedCell = target.closest('td.at-data-cell');
        const clickedCellData = this._getCellData(clickedCell);
        if (clickedCellData && this.isRowEditing(clickedCellData.data.dataItem)) {
            return;
        }
        this._saveAllEditingRows();
    }
    _initRowEditingOfFocusedCell() {
        let currentFocusedCellData;
        if (!this.enableRowEditing || !(currentFocusedCellData = this._getCurrentFocusedCellData())) {
            return;
        }
        if (this.isRowEditing(currentFocusedCellData.data.dataItem)) {
            this.saveRowEditing(currentFocusedCellData.data.dataItem);
        }
        else {
            this._saveAllEditingRows();
            this.initRowEditing(currentFocusedCellData.data.dataItem);
        }
    }
    _saveAllEditingRows() {
        for (const key in this.currentEditingRows) {
            if (Object.prototype.hasOwnProperty.call(this.currentEditingRows, key)) {
                this.saveRowEditing(this.currentEditingRows[key].dataItemReference);
            }
        }
    }
    _toggleRowSelectionOfFocusedCell(event) {
        const currentFocusedCellData = this._getCurrentFocusedCellData();
        if (currentFocusedCellData) {
            event.preventDefault();
        }
        else {
            return;
        }
        if (!this.hasSelection) {
            return;
        }
        const addedToSelection = this.toggleRowSelection(currentFocusedCellData.data.dataItem, event);
        if (addedToSelection) {
            this.lastSelectedRowId = this.getPrimaryKey(currentFocusedCellData.data.dataItem);
        }
    }
    _focusOnCellByNavigation(event, rowNavigate, cellNavigate) {
        const currentFocusedCellData = this._getCurrentFocusedCellData();
        if (!currentFocusedCellData) {
            return;
        }
        const rowElemOfFocusedCell = currentFocusedCellData.element.nativeElement.closest('tr');
        if (!rowElemOfFocusedCell) {
            return;
        }
        const dataRows = this.getSortedDataRows();
        const dataRowIndex = dataRows.findIndex(dr => dr.element.nativeElement === rowElemOfFocusedCell);
        const nextDataRowForFocus = dataRows[dataRowIndex + rowNavigate];
        if (dataRowIndex !== -1 && nextDataRowForFocus) {
            let indexOfFocusedCellInRow = Array.prototype.findIndex.call(rowElemOfFocusedCell.children, (td) => td === currentFocusedCellData.element.nativeElement);
            const rowChildren = nextDataRowForFocus.element.nativeElement.children;
            indexOfFocusedCellInRow += cellNavigate;
            indexOfFocusedCellInRow = indexOfFocusedCellInRow < rowChildren.length ?
                indexOfFocusedCellInRow : rowChildren.length - 1;
            if (indexOfFocusedCellInRow === -1) {
                indexOfFocusedCellInRow = 0;
            }
            if (rowChildren.length > 0) {
                rowChildren[indexOfFocusedCellInRow].focus();
                event.preventDefault();
            }
        }
    }
    _hasCellFocus(element) {
        return document.activeElement === element;
    }
    _getBusyConfig() {
        return {
            busy: null,
            backdrop: true,
            sticky: true,
            message: '',
            loaderType: 'section',
        };
    }
    _hasAllChildItemsDisabledForSelection(grd) {
        const enabledItems = this.getSelectableRowsItems([grd]);
        return !enabledItems.length;
    }
    // For the "action" columns set default with if it has not been passed.
    // The width calculated by the finding max width from all action columns
    _recalculateActionColWidth() {
        var _a, _b;
        if (((_a = this.actionColElements) === null || _a === void 0 ? void 0 : _a.length) && isNil((_b = this.columns.find(col => col.actionsConfig)) === null || _b === void 0 ? void 0 : _b.width)) {
            this.zone.onStable.asObservable()
                .pipe(debounceTime(100), take(1), takeUntil(this._destroyed$))
                .subscribe(() => {
                this.zone.runOutsideAngular(() => {
                    this.setDefaultActionColWidth();
                });
            });
        }
    }
}
AdaptTableComponent.LAST_TABLE_INSTANCE_ID = 0;
AdaptTableComponent.ɵfac = function AdaptTableComponent_Factory(t) { return new (t || AdaptTableComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(TableService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.FilterService), i0.ɵɵdirectiveInject(i3.Directionality), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(AdaptTableDeprecationMiddleware), i0.ɵɵdirectiveInject(i1.AdaptOverlayService), i0.ɵɵdirectiveInject(i0.Injector)); };
AdaptTableComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTableComponent, selectors: [["adapt-table"]], viewQuery: function AdaptTableComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$c, 5);
        i0.ɵɵviewQuery(_c1$8, 5);
        i0.ɵɵviewQuery(_c2$6, 7, ViewContainerRef);
        i0.ɵɵviewQuery(_c3$3, 7, ViewContainerRef);
        i0.ɵɵviewQuery(_c4$2, 7);
        i0.ɵɵviewQuery(_c5$2, 7);
        i0.ɵɵviewQuery(_c6$2, 5);
        i0.ɵɵviewQuery(_c7$2, 5);
        i0.ɵɵviewQuery(_c8$2, 7);
        i0.ɵɵviewQuery(_c9$2, 7);
        i0.ɵɵviewQuery(_c10$2, 7);
        i0.ɵɵviewQuery(_c11$2, 7);
        i0.ɵɵviewQuery(_c12$1, 7);
        i0.ɵɵviewQuery(_c13, 5, AdaptDataDirective);
        i0.ɵɵviewQuery(_c14, 5, AdaptDataDirective);
        i0.ɵɵviewQuery(_c15, 5, AdaptDataDirective);
        i0.ɵɵviewQuery(_c16, 5, ElementRef);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.emptyStateTdEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipViewContainerRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.infiniteScrollingLoaderContainerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableInnerContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableHeader = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nonScrollableTable = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableBodyTemplateRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableHeaderTemplateRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableColgroupTemplateRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tableEmptyMessageTemplateRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rowExpansionTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dataRows = _t);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dataCells = _t);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dataHeaderCells = _t);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionColElements = _t);
    } }, hostVars: 18, hostBindings: function AdaptTableComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("adapt-grid-bordered", ctx.bordered)("adapt-table-pageable", ctx.paginator)("adapt-table--striped", ctx.striped)("adapt-grid", ctx.mainClass)("adapt-table", ctx.adaptTableClass)("adapt-table-scrollable", ctx.scrollableClass)("adapt-table-not-scrollable", ctx.notScrollableClass)("adapt-table--empty-state", ctx.isEmptyState)("adapt-grid--loading", ctx.loading);
    } }, inputs: { sortable: "sortable", filterable: "filterable", triggerableFilters: "triggerableFilters", explicitSearchBtn: "explicitSearchBtn", enableReorderableRows: "enableReorderableRows", suppressTooltip: "suppressTooltip", toolbarConfig: "toolbarConfig", dataColumnsColsTemplate: "dataColumnsColsTemplate", dataColumnsHeaderTemplate: "dataColumnsHeaderTemplate", dataColumnsDataCellsTemplate: "dataColumnsDataCellsTemplate", headerGroupsTemplate: "headerGroupsTemplate", alwaysShowHeaderTooltip: "alwaysShowHeaderTooltip", alwaysShowCellTooltip: "alwaysShowCellTooltip", expandedCellClass: "expandedCellClass", expandedGroupsKeys: "expandedGroupsKeys", nestedGroupPadding: "nestedGroupPadding", expandindCellInitialPadding: "expandindCellInitialPadding", groupValueDataCellTemplate: "groupValueDataCellTemplate", tooltipInitialDelayMs: "tooltipInitialDelayMs", tooltipClass: "tooltipClass", rowsCustomClass: "rowsCustomClass", paginatorAlign: "paginatorAlign", hasEmptyState: "hasEmptyState", enableInfiniteScrolling: "enableInfiniteScrolling", updateFirstColumnWidth: "updateFirstColumnWidth", busyConfig: "busyConfig", defaultFiltersMatchMode: "defaultFiltersMatchMode", wrapCellText: "wrapCellText", minBufferPx: "minBufferPx", maxBufferPx: "maxBufferPx", testID: "testID", headerSelectionMode: "headerSelectionMode", disabledSelectedRowsCount: "disabledSelectedRowsCount", disabledNotSelectedRowsCount: "disabledNotSelectedRowsCount", disabledSelectedFilteredRowsCount: "disabledSelectedFilteredRowsCount", disabledNotSelectedFilteredRowsCount: "disabledNotSelectedFilteredRowsCount", selectedFilteredRowsCount: "selectedFilteredRowsCount", totalRecordsInGroup: "totalRecordsInGroup", disableRowSelection: "disableRowSelection", nestingStructureData: "nestingStructureData", nestingKey: "nestingKey", enableRowEditing: "enableRowEditing", autoScrollToTop: "autoScrollToTop", paginationTexts: "paginationTexts", toolbarTexts: "toolbarTexts", tableTexts: "tableTexts", filtersTexts: "filtersTexts", headerCellMenuTexts: "headerCellMenuTexts", texts: "texts", loadingMore: "loadingMore", mergeColumns: "mergeColumns", disabledRowSelectionResolver: "disabledRowSelectionResolver", allowColumnReorderingResolver: "allowColumnReorderingResolver", disableRowExpandingResolver: "disableRowExpandingResolver", rowAriaDataResolver: "rowAriaDataResolver", tableWidthConfig: "tableWidthConfig", expandedRowTemplate: "expandedRowTemplate", isRefreshingRowData: "isRefreshingRowData", value: "value", bordered: "bordered", paginator: "paginator", striped: "striped", loading: "loading" }, outputs: { onLazyLoad: "onLazyLoad", rowDataRefresh: "rowDataRefresh", savedRowEditing: "savedRowEditing", canceledRowEditing: "canceledRowEditing", groupSelection: "groupSelection", allGroupedRowsSelection: "allGroupedRowsSelection", groupExpansion: "groupExpansion", columnsVisibilityChange: "columnsVisibilityChange", rowDragStart: "rowDragStart", rowDragRelease: "rowDragRelease", rowDragEnd: "rowDragEnd", rowDragDrop: "rowDragDrop", export: "export", toolbarPopupAnimationDone: "toolbarPopupAnimationDone" }, features: [i0.ɵɵProvidersFeature([TableService]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 88, vars: 39, consts: [[3, "ngClass"], ["cdkDropList", "", 1, "at-table-primeng-component", 3, "ngClass", "cdkDropListData", "cdkDropListDisabled", "cdkDropListSorted"], [3, "ngStyle", "ngClass"], ["container", ""], ["class", "ui-table-loading ui-widget-overlay", 4, "ngIf"], ["class", "ui-table-loading-content", 4, "ngIf"], [3, "config", "texts", 4, "ngIf"], [1, "ui-table-container", 3, "ngClass"], ["tableContainer", ""], [1, "h-100", 3, "ngStyle"], ["tableInnerContainer", ""], ["class", "ui-table-wrapper", 4, "ngIf"], ["class", "ui-table-scrollable-wrapper", 3, "adaptResize", "elementResize", 4, "ngIf"], ["class", "ui-table-container-loader", 3, "ngStyle", 4, "ngIf"], [3, "rows", "first", "totalRecords", "pageLinkSize", "alwaysShow", "rowsPerPageOptions", "dropdownAppendTo", "currentPageReportTemplate", "showCurrentPageReport", "texts", "paginatorAlign", "ngClass", "onPageChange", 4, "ngIf"], ["class", "ui-column-resizer-helper ui-state-highlight", "style", "display:none;", 4, "ngIf"], ["class", "pi pi-arrow-down ui-table-reorder-indicator-up", "style", "display:none;", 4, "ngIf"], ["class", "pi pi-arrow-up ui-table-reorder-indicator-down", "style", "display:none;", 4, "ngIf"], ["class", "full-loading-wrap", 3, "ngBusy", "adaptRadarDisableEventSending", 4, "ngIf"], ["tooltipContainerEl", ""], ["infiniteScrollingLoaderContainerEl", ""], ["tableColgroupTemplateRef", ""], ["tableHeaderTemplateRef", ""], ["headerMultipleSelectionTemplate", ""], ["headerControlsTemplate", ""], ["tableBodyTemplateRef", ""], ["rowExpansionTemplate", ""], ["tableEmptyMessageTemplateRef", ""], ["groupValueDataCellDefTemplate", ""], ["dataCellDefTemplate", ""], ["editDataCellDefTemplate", ""], ["dataCellTemplate", ""], [1, "ui-table-loading", "ui-widget-overlay"], [1, "ui-table-loading-content"], [3, "config", "texts"], ["toolbarComponent", ""], [1, "ui-table-wrapper"], ["role", "grid", 3, "ngClass", "ngStyle"], ["table", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "ui-table-thead"], ["tableHeader", ""], [1, "ui-table-tbody", 3, "pTableBody", "pTableBodyTemplate"], ["class", "ui-table-tfoot", 4, "ngIf"], [1, "ui-table-tfoot"], [1, "ui-table-scrollable-wrapper", 3, "adaptResize", "elementResize"], ["class", "ui-table-scrollable-view ui-table-frozen-view", 3, "pScrollableView", "frozen", "ngStyle", "scrollHeight", 4, "ngIf"], [1, "ui-table-scrollable-view", "w-100", 3, "pScrollableView", "frozen", "scrollHeight", "ngStyle"], [1, "ui-table-scrollable-view", "ui-table-frozen-view", 3, "pScrollableView", "frozen", "ngStyle", "scrollHeight"], [1, "ui-table-container-loader", 3, "ngStyle"], [3, "rows", "first", "totalRecords", "pageLinkSize", "alwaysShow", "rowsPerPageOptions", "dropdownAppendTo", "currentPageReportTemplate", "showCurrentPageReport", "texts", "paginatorAlign", "ngClass", "onPageChange"], [1, "ui-column-resizer-helper", "ui-state-highlight", 2, "display", "none"], ["resizeHelper", ""], [1, "pi", "pi-arrow-down", "ui-table-reorder-indicator-up", 2, "display", "none"], ["reorderIndicatorUp", ""], [1, "pi", "pi-arrow-up", "ui-table-reorder-indicator-down", 2, "display", "none"], ["reorderIndicatorDown", ""], [1, "full-loading-wrap", 3, "ngBusy", "adaptRadarDisableEventSending"], ["class", "at-reordarable-cell", 4, "ngIf"], ["class", "at-radiobutton-cell", 4, "ngIf"], ["class", "at-expansion-cell", 4, "ngIf"], ["class", "adapt-selection-cell", 4, "ngIf"], [3, "ngIf", "ngIfElse"], ["dataColumnsColsDefTemplate", ""], [1, "at-reordarable-cell"], [1, "at-radiobutton-cell"], [1, "at-expansion-cell"], [1, "adapt-selection-cell"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "at-col", 3, "ngStyle", 4, "ngIf"], ["class", "at-col at-action-col", 3, "ngStyle", 4, "ngIf"], [1, "at-col", 3, "ngStyle"], ["colEl", ""], [1, "at-col", "at-action-col", 3, "ngStyle"], ["actionColElement", ""], [3, "ngIf"], [1, "at-header-row"], ["dataColumnsHeaderDefTemplate", ""], [3, "ngTemplateOutlet"], ["pResizableColumn", "", "pReorderableColumn", "", 3, "pResizableColumnDisabled", "pReorderableColumnDisabled", "class", "adaptFrozen", "adaptData", "ngClass", "columnResized", 4, "ngIf"], ["pResizableColumn", "", "pReorderableColumn", "", 3, "pResizableColumnDisabled", "pReorderableColumnDisabled", "class", "adaptData", "ngClass", "columnResized", 4, "ngIf"], ["pResizableColumn", "", "pReorderableColumn", "", 3, "pResizableColumnDisabled", "pReorderableColumnDisabled", "adaptFrozen", "adaptData", "ngClass", "columnResized"], ["dataHeaderCell", ""], [3, "renderingColumn", "index", "texts"], ["pResizableColumn", "", "pReorderableColumn", "", 3, "pResizableColumnDisabled", "pReorderableColumnDisabled", "adaptData", "ngClass", "columnResized"], [3, "texts", "headerCheckboxToggle", 4, "ngIf"], ["type", "button", "class", "at-group-selection-unselect-all d-icon-cross_adapt btn", 3, "placement", "adaptRadarDisableEventSending", "adaptTooltip", "click", 4, "ngIf"], [3, "texts", "headerCheckboxToggle"], ["type", "button", 1, "at-group-selection-unselect-all", "d-icon-cross_adapt", "btn", 3, "placement", "adaptRadarDisableEventSending", "adaptTooltip", "click"], ["class", "at-header-cell at-reordarable-cell", 3, "adaptFrozen", 4, "ngIf"], ["class", "at-header-cell at-radiobutton-cell", 3, "adaptFrozen", 4, "ngIf"], ["class", "at-header-cell at-expansion-cell", 3, "adaptFrozen", 4, "ngIf"], ["class", "at-header-cell adapt-selection-cell", 3, "adaptFrozen", "ngClass", 4, "ngIf"], [1, "at-header-cell", "at-reordarable-cell", 3, "adaptFrozen"], [1, "at-header-cell", "at-radiobutton-cell", 3, "adaptFrozen"], [1, "at-header-cell", "at-expansion-cell", 3, "adaptFrozen"], [1, "at-header-cell", "adapt-selection-cell", 3, "adaptFrozen", "ngClass"], [4, "ngTemplateOutlet"], ["cdkDrag", "", "cdkDragLockAxis", "y", "class", "at-row at-group-row", 3, "cdkDragData", "ngClass", "cdkDragStarted", "cdkDragDropped", "cdkDragEnded", "cdkDragReleased", 4, "ngIf", "ngIfElse"], ["dataRowTemplate", ""], ["cdkDrag", "", "cdkDragLockAxis", "y", 1, "at-row", "at-group-row", 3, "cdkDragData", "ngClass", "cdkDragStarted", "cdkDragDropped", "cdkDragEnded", "cdkDragReleased"], ["groupRow", ""], ["cdkDragHandle", "", "class", "at-cell at-reordarable-cell p-start-3", 3, "mousedown", 4, "ngIf"], ["class", "at-cell at-radiobutton-cell", 4, "ngIf"], [1, "at-expansion-cell", "at-cell", 3, "ngStyle"], ["expansionCell", ""], ["type", "button", "role", "button", 1, "expansion-btn", 3, "click"], ["aria-hidden", "true", "xmlns", "http://www.w3.org/2000/svg", "width", "6", "height", "10", "viewBox", "0 0 7 11", "fill", "currentColor", 1, "at-expansion-icon", "d-icon-p", 3, "ngClass"], ["d", "M1.9,0L0.6,1.2l4.2,4.3L0.6,9.8L1.9,11l5.5-5.5L1.9,0z"], [1, "sr-only"], ["class", "adapt-selection-cell at-cell", 3, "ngStyle", 4, "ngIf"], [1, "at-cell", 3, "ngStyle"], ["cdkDragHandle", "", 1, "at-cell", "at-reordarable-cell", "p-start-3", 3, "mousedown"], ["class", "d-icon-dots adapt-list-drag", 4, "ngIf"], [1, "d-icon-dots", "adapt-list-drag"], [1, "at-cell", "at-radiobutton-cell"], [1, "adapt-selection-cell", "at-cell", 3, "ngStyle"], [1, "checkbox-inline", "at-group-selection-checkbox", 3, "ngModel", "adaptRadarDisableEventSending", "indeterminate", "disabled", "ariaLabel", "ngModelChange"], ["cdkDrag", "", "cdkDragLockAxis", "y", 1, "at-row", "at-data-row", 3, "pEditableRow", "adaptData", "ngClass", "cdkDragData", "cdkDragStarted", "cdkDragDropped", "cdkDragEnded", "cdkDragReleased"], ["dataRow", ""], ["cdkDragHandle", "", "class", "at-cell at-reordarable-cell p-start-3", 3, "adaptFrozen", "mousedown", 4, "ngIf"], ["class", "at-cell at-radiobutton-cell", 3, "adaptFrozen", 4, "ngIf"], ["class", "at-expansion-cell at-cell", 3, "ngStyle", "ngClass", "adaptFrozen", 4, "ngIf"], ["class", "adapt-selection-cell at-cell", 3, "ngStyle", "adaptFrozen", 4, "ngIf"], ["dataColumnsDataCellsDefTemplate", ""], [4, "ngIf"], ["cdkDragHandle", "", 1, "at-cell", "at-reordarable-cell", "p-start-3", 3, "adaptFrozen", "mousedown"], [1, "at-cell", "at-radiobutton-cell", 3, "adaptFrozen"], [1, "at-radiobutton", 3, "name", "adaptRadarDisableEventSending", "value", "checked", "label", "ariaLabel", "disabled", "click"], [1, "at-expansion-cell", "at-cell", 3, "ngStyle", "ngClass", "adaptFrozen"], ["type", "button", "class", "expansion-btn", 3, "pRowToggler", 4, "ngIf"], ["type", "button", 1, "expansion-btn", 3, "pRowToggler"], ["d", "M1.9,0L0.6,1.2l4.2,4.3L0.6,9.8L1.9,11l5.5-5.5L1.9,0z", 1, "ui-clickable"], [1, "adapt-selection-cell", "at-cell", 3, "ngStyle", "adaptFrozen"], [1, "at-selection-checkbox", 3, "renderRowData", "value", "rowAriaDataResolver", "disabled"], ["class", "at-data-cell at-cell at-data-cell--simple at-tooltip-el", 3, "ngStyle", "adaptFrozen", "adaptData", "ngClass", "tabindex", "dblclick", 4, "ngIf"], ["class", "at-cell at-data-cell ad-data-cell--merged", 3, "ngStyle", "adaptData", "ngClass", "tabindex", "dblclick", 4, "ngIf"], [1, "at-data-cell", "at-cell", "at-data-cell--simple", "at-tooltip-el", 3, "ngStyle", "adaptFrozen", "adaptData", "ngClass", "tabindex", "dblclick"], ["dataCell", ""], [1, "at-cell", "at-data-cell", "ad-data-cell--merged", 3, "ngStyle", "adaptData", "ngClass", "tabindex", "dblclick"], ["class", "at-tooltip-el at-merged-column-data-cell", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "at-tooltip-el", "at-merged-column-data-cell"], [1, "at-row", "at-expansion-row"], [1, "at-cell-expanded", 3, "ngClass"], ["class", "at-empty-state-row", 4, "ngIf"], [1, "at-empty-state-row"], [1, "at-empty-state-cell"], ["emptyStateTdEl", ""], [3, "type", "adaptRadarDisableEventSending", "label"], [3, "column", "dataItem", "rowIndex", "expanded", "editing", "texts"], [1, "at-edit-input-wrap", 3, "size", "adaptRadarDisableEventSending", "ngModel", "ngModelChange", "keydown"], ["textfield", ""], ["dataCellDisplayingTemplate", ""], ["role", "group", 1, "btn-group", "d-flex"], ["type", "button", "adapt-button", "", "btn-type", "secondary", "size", "xtra-small", 1, "btn-reject", 3, "adaptRadarDisableEventSending", "click"], ["type", "button", "adapt-button", "", "btn-type", "secondary", "size", "xtra-small", 1, "btn-approve", 3, "adaptRadarDisableEventSending", "click"]], template: function AdaptTableComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n\n\n  ");
        i0.ɵɵelementStart(2, "div", 1);
        i0.ɵɵlistener("cdkDropListSorted", function AdaptTableComponent_Template_div_cdkDropListSorted_2_listener($event) { return ctx.onCdkDropListSortedRow($event); });
        i0.ɵɵtext(3, "\n    ");
        i0.ɵɵelementStart(4, "div", 2, 3);
        i0.ɵɵtext(6, "\n      ");
        i0.ɵɵtemplate(7, AdaptTableComponent_div_7_Template, 1, 0, "div", 4);
        i0.ɵɵtext(8, "\n      ");
        i0.ɵɵtemplate(9, AdaptTableComponent_div_9_Template, 4, 2, "div", 5);
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵtemplate(11, AdaptTableComponent_adapt_table_toolbar_11_Template, 2, 2, "adapt-table-toolbar", 6);
        i0.ɵɵtext(12, "\n\n      ");
        i0.ɵɵelementStart(13, "div", 7, 8);
        i0.ɵɵtext(15, "\n        ");
        i0.ɵɵelementStart(16, "div", 9, 10);
        i0.ɵɵtext(18, "\n          ");
        i0.ɵɵtemplate(19, AdaptTableComponent_div_19_Template, 18, 13, "div", 11);
        i0.ɵɵtext(20, "\n\n          ");
        i0.ɵɵtemplate(21, AdaptTableComponent_div_21_Template, 6, 8, "div", 12);
        i0.ɵɵtext(22, "\n\n          ");
        i0.ɵɵtemplate(23, AdaptTableComponent_div_23_Template, 1, 4, "div", 13);
        i0.ɵɵtext(24, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(25, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(26, "\n\n      ");
        i0.ɵɵtemplate(27, AdaptTableComponent_adapt_paginator_27_Template, 2, 12, "adapt-paginator", 14);
        i0.ɵɵtext(28, "\n\n      ");
        i0.ɵɵtemplate(29, AdaptTableComponent_div_29_Template, 2, 0, "div", 15);
        i0.ɵɵtext(30, "\n\n      ");
        i0.ɵɵtemplate(31, AdaptTableComponent_span_31_Template, 2, 0, "span", 16);
        i0.ɵɵtext(32, "\n      ");
        i0.ɵɵtemplate(33, AdaptTableComponent_span_33_Template, 2, 0, "span", 17);
        i0.ɵɵtext(34, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(35, "\n\n    ");
        i0.ɵɵtemplate(36, AdaptTableComponent_div_36_Template, 1, 2, "div", 18);
        i0.ɵɵtext(37, "\n\n    ");
        i0.ɵɵelementContainer(38, null, 19);
        i0.ɵɵtext(40, "\n\n    ");
        i0.ɵɵelementContainer(41, null, 20);
        i0.ɵɵtext(43, "\n\n    ");
        i0.ɵɵtext(44, "\n    ");
        i0.ɵɵtemplate(45, AdaptTableComponent_ng_template_45_Template, 17, 6, "ng-template", null, 21, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(47, "\n\n    ");
        i0.ɵɵtext(48, "\n    ");
        i0.ɵɵtemplate(49, AdaptTableComponent_ng_template_49_Template, 13, 9, "ng-template", null, 22, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(51, "\n    ");
        i0.ɵɵtemplate(52, AdaptTableComponent_ng_template_52_Template, 6, 2, "ng-template", null, 23, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(54, "\n    ");
        i0.ɵɵtemplate(55, AdaptTableComponent_ng_template_55_Template, 9, 4, "ng-template", null, 24, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(57, "\n\n    ");
        i0.ɵɵtext(58, "\n    ");
        i0.ɵɵtemplate(59, AdaptTableComponent_ng_template_59_Template, 8, 2, "ng-template", null, 25, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(61, "\n\n    ");
        i0.ɵɵtext(62, "\n    ");
        i0.ɵɵtemplate(63, AdaptTableComponent_ng_template_63_Template, 9, 4, "ng-template", null, 26, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(65, "\n\n    ");
        i0.ɵɵtext(66, "\n    ");
        i0.ɵɵtemplate(67, AdaptTableComponent_ng_template_67_Template, 3, 1, "ng-template", null, 27, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(69, "\n\n    ");
        i0.ɵɵtext(70, "\n    ");
        i0.ɵɵtemplate(71, AdaptTableComponent_ng_template_71_Template, 1, 1, "ng-template", null, 28, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(73, "\n\n    ");
        i0.ɵɵtext(74, "\n    ");
        i0.ɵɵtemplate(75, AdaptTableComponent_ng_template_75_Template, 5, 2, "ng-template", null, 29, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(77, "\n\n    ");
        i0.ɵɵtext(78, "\n    ");
        i0.ɵɵtemplate(79, AdaptTableComponent_ng_template_79_Template, 5, 3, "ng-template", null, 30, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(81, "\n\n    ");
        i0.ɵɵtext(82, "\n    ");
        i0.ɵɵtemplate(83, AdaptTableComponent_ng_template_83_Template, 12, 3, "ng-template", null, 31, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(85, "\n\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(86, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(87, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction4(21, _c26, ctx.scrollable && ctx.scrollHeight === "flex", ctx.paginator, ctx.toolbarConfig, ctx.reorderableColumns));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(26, _c27, ctx.enableReorderableRows, ctx.wrapCellText))("cdkDropListData", ctx.getAllCurrentRows())("cdkDropListDisabled", !ctx.enableReorderableRows);
        i0.ɵɵadvance(2);
        i0.ɵɵclassMap(ctx.styleClass);
        i0.ɵɵproperty("ngStyle", ctx.style)("ngClass", i0.ɵɵpureFunction5(29, _c28, ctx.responsive, ctx.resizableColumns, ctx.resizableColumns && ctx.columnResizeMode === "fit", ctx.rowHover || ctx.selectionMode, ctx.autoLayout));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.loading && ctx.showLoader);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.loading && ctx.showLoader);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.toolbarConfig);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(35, _c29, ctx.tableWidthConfig));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(37, _c30, ctx.getTableWidth(ctx.tableWidthConfig, ctx.isMobile)));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !ctx.scrollable);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.scrollable);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.isRefreshingRowData);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.paginator);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.resizableColumns);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.reorderableColumns);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.reorderableColumns);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.canShowFullLoader);
    } }, encapsulation: 2, data: { animation: [
            trigger('dataRefreshAnimation', [
                transition('void => *', [
                    style({ transform: 'scaleX(.8)', opacity: '0' }),
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ transform: 'scaleX(1)', opacity: '1' }))
                ]),
                transition('* => void', [
                    style({ opacity: '1' }),
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionOut}`, style({ opacity: '0' }))
                ]),
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-table',
                templateUrl: './adapt-table.component.html',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.Default,
                providers: [TableService],
                animations: [
                    trigger('dataRefreshAnimation', [
                        transition('void => *', [
                            style({ transform: 'scaleX(.8)', opacity: '0' }),
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ transform: 'scaleX(1)', opacity: '1' }))
                        ]),
                        transition('* => void', [
                            style({ opacity: '1' }),
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionOut}`, style({ opacity: '0' }))
                        ]),
                    ])
                ]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: TableService }, { type: i0.ChangeDetectorRef }, { type: i2.FilterService }, { type: i3.Directionality }, { type: i0.Renderer2 }, { type: i1.AdaptDeviceDetectionService }, { type: i1.AdaptTranslateService }, { type: AdaptTableDeprecationMiddleware }, { type: i1.AdaptOverlayService }, { type: i0.Injector }]; }, { emptyStateTdEl: [{
            type: ViewChild,
            args: ['emptyStateTdEl', { static: false }]
        }], toolbarComponent: [{
            type: ViewChild,
            args: ['toolbarComponent', { static: false }]
        }], tooltipViewContainerRef: [{
            type: ViewChild,
            args: ['tooltipContainerEl', { read: ViewContainerRef, static: true }]
        }], infiniteScrollingLoaderContainerEl: [{
            type: ViewChild,
            args: ['infiniteScrollingLoaderContainerEl', { read: ViewContainerRef, static: true }]
        }], tableContainer: [{
            type: ViewChild,
            args: ['tableContainer', { static: true }]
        }], tableInnerContainer: [{
            type: ViewChild,
            args: ['tableInnerContainer', { static: true }]
        }], tableHeader: [{
            type: ViewChild,
            args: ['tableHeader', { static: false }]
        }], nonScrollableTable: [{
            type: ViewChild,
            args: ['table', { static: false }]
        }], tableBodyTemplateRef: [{
            type: ViewChild,
            args: ['tableBodyTemplateRef', { static: true }]
        }], tableHeaderTemplateRef: [{
            type: ViewChild,
            args: ['tableHeaderTemplateRef', { static: true }]
        }], tableColgroupTemplateRef: [{
            type: ViewChild,
            args: ['tableColgroupTemplateRef', { static: true }]
        }], tableEmptyMessageTemplateRef: [{
            type: ViewChild,
            args: ['tableEmptyMessageTemplateRef', { static: true }]
        }], rowExpansionTemplate: [{
            type: ViewChild,
            args: ['rowExpansionTemplate', { static: true }]
        }], dataRows: [{
            type: ViewChildren,
            args: ['dataRow', { read: AdaptDataDirective }]
        }], dataCells: [{
            type: ViewChildren,
            args: ['dataCell', { read: AdaptDataDirective }]
        }], dataHeaderCells: [{
            type: ViewChildren,
            args: ['dataHeaderCell', { read: AdaptDataDirective }]
        }], actionColElements: [{
            type: ViewChildren,
            args: ['actionColElement', { read: ElementRef }]
        }], sortable: [{
            type: Input
        }], filterable: [{
            type: Input
        }], triggerableFilters: [{
            type: Input
        }], explicitSearchBtn: [{
            type: Input
        }], enableReorderableRows: [{
            type: Input
        }], suppressTooltip: [{
            type: Input
        }], toolbarConfig: [{
            type: Input
        }], dataColumnsColsTemplate: [{
            type: Input
        }], dataColumnsHeaderTemplate: [{
            type: Input
        }], dataColumnsDataCellsTemplate: [{
            type: Input
        }], headerGroupsTemplate: [{
            type: Input
        }], alwaysShowHeaderTooltip: [{
            type: Input
        }], alwaysShowCellTooltip: [{
            type: Input
        }], expandedCellClass: [{
            type: Input
        }], expandedGroupsKeys: [{
            type: Input
        }], nestedGroupPadding: [{
            type: Input
        }], expandindCellInitialPadding: [{
            type: Input
        }], groupValueDataCellTemplate: [{
            type: Input
        }], tooltipInitialDelayMs: [{
            type: Input
        }], tooltipClass: [{
            type: Input
        }], rowsCustomClass: [{
            type: Input
        }], paginatorAlign: [{
            type: Input
        }], hasEmptyState: [{
            type: Input
        }], enableInfiniteScrolling: [{
            type: Input
        }], updateFirstColumnWidth: [{
            type: Input
        }], busyConfig: [{
            type: Input
        }], defaultFiltersMatchMode: [{
            type: Input
        }], wrapCellText: [{
            type: Input
        }], minBufferPx: [{
            type: Input
        }], maxBufferPx: [{
            type: Input
        }], testID: [{
            type: Input
        }], headerSelectionMode: [{
            type: Input
        }], disabledSelectedRowsCount: [{
            type: Input
        }], disabledNotSelectedRowsCount: [{
            type: Input
        }], disabledSelectedFilteredRowsCount: [{
            type: Input
        }], disabledNotSelectedFilteredRowsCount: [{
            type: Input
        }], selectedFilteredRowsCount: [{
            type: Input
        }], totalRecordsInGroup: [{
            type: Input
        }], disableRowSelection: [{
            type: Input
        }], nestingStructureData: [{
            type: Input
        }], nestingKey: [{
            type: Input
        }], enableRowEditing: [{
            type: Input
        }], autoScrollToTop: [{
            type: Input
        }], paginationTexts: [{
            type: Input
        }], toolbarTexts: [{
            type: Input
        }], tableTexts: [{
            type: Input
        }], filtersTexts: [{
            type: Input
        }], headerCellMenuTexts: [{
            type: Input
        }], texts: [{
            type: Input
        }], loadingMore: [{
            type: Input
        }], mergeColumns: [{
            type: Input
        }], disabledRowSelectionResolver: [{
            type: Input
        }], allowColumnReorderingResolver: [{
            type: Input
        }], disableRowExpandingResolver: [{
            type: Input
        }], rowAriaDataResolver: [{
            type: Input
        }], tableWidthConfig: [{
            type: Input
        }], expandedRowTemplate: [{
            type: Input
        }], isRefreshingRowData: [{
            type: Input
        }], value: [{
            type: Input
        }], bordered: [{
            type: HostBinding,
            args: [`class.${AdaptTableClasses.Bordered}`]
        }, {
            type: Input
        }], paginator: [{
            type: HostBinding,
            args: [`class.${AdaptTableClasses.Pageable}`]
        }, {
            type: Input
        }], striped: [{
            type: HostBinding,
            args: [`class.${AdaptTableClasses.Striped}`]
        }, {
            type: Input
        }], onLazyLoad: [{
            type: Output
        }], rowDataRefresh: [{
            type: Output
        }], savedRowEditing: [{
            type: Output
        }], canceledRowEditing: [{
            type: Output
        }], groupSelection: [{
            type: Output
        }], allGroupedRowsSelection: [{
            type: Output
        }], groupExpansion: [{
            type: Output
        }], columnsVisibilityChange: [{
            type: Output
        }], rowDragStart: [{
            type: Output
        }], rowDragRelease: [{
            type: Output
        }], rowDragEnd: [{
            type: Output
        }], rowDragDrop: [{
            type: Output
        }], export: [{
            type: Output
        }], toolbarPopupAnimationDone: [{
            type: Output
        }], mainClass: [{
            type: HostBinding,
            args: [`class.${AdaptTableClasses.Main}`]
        }], adaptTableClass: [{
            type: HostBinding,
            args: [`class.${AdaptTableClasses.AdaptTable}`]
        }], scrollableClass: [{
            type: HostBinding,
            args: [`class.${AdaptTableClasses.Scrollable}`]
        }], notScrollableClass: [{
            type: HostBinding,
            args: [`class.${AdaptTableClasses.NotScrollable}`]
        }], isEmptyState: [{
            type: HostBinding,
            args: [`class.${AdaptTableClasses.IsEmptyState}`]
        }], loading: [{
            type: Input
        }, {
            type: HostBinding,
            args: [`class.${AdaptTableClasses.LoadingFullTable}`]
        }] }); })();

class AdaptTableFiltersService {
    filterName(column) {
        return column.filterName || AdaptTableFilters.DEFAULT_FILTER;
    }
    getFilterValue(columnField, table) {
        const filters = table.filters;
        if (!filters) {
            return null;
        }
        const filter = filters[columnField];
        return filter ? filter.value : null;
    }
    onSelectModelChange(model, column, table) {
        const arrayModel = isArray(model) ? model : [model];
        this.setFilter(arrayModel, column, table, FilterMatchMode.in);
    }
    setFilter(value, column, table, matchMode) {
        if (!matchMode) {
            const filterParams = this._getFilterParams(column);
            matchMode = (filterParams && filterParams.matchMode) || table.defaultFiltersMatchMode;
        }
        table.filter(value, column.field, matchMode);
    }
    getSelectTexts(column, texts) {
        const filterParams = this.getSelectFilterParams(column);
        if (filterParams && filterParams.selectTexts) {
            return Object.assign(Object.assign({}, texts.selectFilterTexts), filterParams.selectTexts);
        }
        else {
            return texts.selectFilterTexts;
        }
    }
    getSelectFilterParams(column) {
        return column.filterParams;
    }
    getSelectOptions(column) {
        const filterParams = this.getSelectFilterParams(column);
        if (filterParams && filterParams.values) {
            return filterParams.values.map((value) => typeof value === 'string' ? ({ id: value, name: value }) : value);
        }
        else {
            return [];
        }
    }
    _getFilterParams(column) {
        return column.filterParams;
    }
}
AdaptTableFiltersService.ɵfac = function AdaptTableFiltersService_Factory(t) { return new (t || AdaptTableFiltersService)(); };
AdaptTableFiltersService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptTableFiltersService, factory: AdaptTableFiltersService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableFiltersService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

class AdaptSelectMigrationComponent {
    constructor() {
        this.selectModelChange = new EventEmitter();
        this.popupOpenChange = new EventEmitter();
        this.filterValueChange = new EventEmitter();
        this._showWarningMessage();
    }
    set options(opts) {
        this.rxSelectComponent.options = opts || [];
    }
    set multiple(value) {
        this.rxSelectComponent.multiple = !isUndefined(value) && value;
    }
    set optionFormatter(fn) {
        this.rxSelectComponent.optionFormatter = !isUndefined(fn) && fn;
    }
    set settings(value) {
        this._setNewSettings(value);
    }
    set texts(value) {
        this.rxSelectComponent.texts = !isUndefined(value) && value;
    }
    set inline(value) {
        this.rxSelectComponent.inline = !isUndefined(value) && value;
    }
    ngOnInit() {
        if (isArray$1(this.value)) {
            this.selectModel = this.value.map(val => ({ id: val, name: val }));
        }
        else {
            this.selectModel = isNil(this.value)
                ? { id: this.value, name: this.value }
                : [{ id: this.value, name: this.value }];
        }
    }
    handleOnSelectModelChange(value) {
        const model = isArray$1(value)
            ? value.map(option => option.id)
            : value.id;
        this.selectModelChange.emit(model);
    }
    _setNewSettings(value) {
        for (const valueKey in value) {
            if (!isUndefined(value[valueKey])) {
                this.rxSelectComponent[valueKey] = value[valueKey];
            }
        }
    }
    _showWarningMessage() {
        adaptWarn('[settings] property will be changed and will contain properties from rx-select API. Please, check https://github.bmc.com/pages/bmc-ux/adapt-angular/#/components/select and https://github.bmc.com/pages/bmc-ux/adapt-angular/#/components/rx-select to see APIs difference');
    }
}
AdaptSelectMigrationComponent.ɵfac = function AdaptSelectMigrationComponent_Factory(t) { return new (t || AdaptSelectMigrationComponent)(); };
AdaptSelectMigrationComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSelectMigrationComponent, selectors: [["adapt-select-migration"]], viewQuery: function AdaptSelectMigrationComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(AdaptRxSelectComponent, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rxSelectComponent = _t.first);
    } }, inputs: { value: "value", options: "options", multiple: "multiple", optionFormatter: "optionFormatter", settings: "settings", texts: "texts", inline: "inline" }, outputs: { selectModelChange: "selectModelChange", popupOpenChange: "popupOpenChange", filterValueChange: "filterValueChange" }, features: [i0.ɵɵProvidersFeature([AdaptRxSelectConfigService])], decls: 5, vars: 3, consts: [[3, "adaptRadarDisableEventSending", "size", "ngModel", "ngModelChange", "onPopupOpenChange", "onFilterValueChange"], ["rxSelectComponent", ""]], template: function AdaptSelectMigrationComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "adapt-rx-select", 0, 1);
        i0.ɵɵlistener("ngModelChange", function AdaptSelectMigrationComponent_Template_adapt_rx_select_ngModelChange_1_listener($event) { return ctx.selectModel = $event; })("ngModelChange", function AdaptSelectMigrationComponent_Template_adapt_rx_select_ngModelChange_1_listener($event) { return ctx.handleOnSelectModelChange($event); })("onPopupOpenChange", function AdaptSelectMigrationComponent_Template_adapt_rx_select_onPopupOpenChange_1_listener($event) { return ctx.popupOpenChange.emit($event); })("onFilterValueChange", function AdaptSelectMigrationComponent_Template_adapt_rx_select_onFilterValueChange_1_listener($event) { return ctx.filterValueChange.emit($event); });
        i0.ɵɵtext(3, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(4, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("size", "sm")("ngModel", ctx.selectModel);
    } }, directives: [i1.AdaptRxSelectComponent, i5.NgControlStatus, i5.NgModel], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSelectMigrationComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-select-migration',
                template: `
    <adapt-rx-select #rxSelectComponent
                     [adaptRadarDisableEventSending]="true"
                     [size]="'sm'"
                     [(ngModel)]="selectModel"
                     (ngModelChange)="handleOnSelectModelChange($event)"
                     (onPopupOpenChange)="popupOpenChange.emit($event)"
                     (onFilterValueChange)="filterValueChange.emit($event)">
    </adapt-rx-select>
  `,
                providers: [AdaptRxSelectConfigService]
            }]
    }], function () { return []; }, { value: [{
            type: Input
        }], options: [{
            type: Input
        }], multiple: [{
            type: Input
        }], optionFormatter: [{
            type: Input
        }], settings: [{
            type: Input
        }], texts: [{
            type: Input
        }], inline: [{
            type: Input
        }], selectModelChange: [{
            type: Output
        }], popupOpenChange: [{
            type: Output
        }], filterValueChange: [{
            type: Output
        }], rxSelectComponent: [{
            type: ViewChild,
            args: [AdaptRxSelectComponent, { static: true }]
        }] }); })();

function AdaptTableMergedFiltersComponent_adapt_tag_15_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-tag", 8);
    i0.ɵɵlistener("remove", function AdaptTableMergedFiltersComponent_adapt_tag_15_Template_adapt_tag_remove_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r5); const filter_r3 = restoredCtx.$implicit; const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.onRemoveFilterFormApplied(filter_r3); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const filter_r3 = ctx.$implicit;
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("type", "active");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate2("\n          ", filter_r3.header, ": ", filter_r3.value, "\n        ");
} }
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n            ");
} }
const _c0$b = function (a0, a1) { return { column: a0, index: a1 }; };
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_container_2_ng_template_2_Template, 1, 0, "ng-template", 15);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const column_r7 = i0.ɵɵnextContext().$implicit;
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", column_r7.filterTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction2(2, _c0$b, column_r7, ctx_r8.index));
} }
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_adapt_rx_search_3_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-rx-search", 19);
    i0.ɵɵlistener("ngModelChange", function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_adapt_rx_search_3_Template_adapt_rx_search_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r17); const column_r7 = i0.ɵɵnextContext(2).$implicit; const ctx_r15 = i0.ɵɵnextContext(2); return ctx_r15.setFilter($event, column_r7); });
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r7 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r13 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("ngModel", ctx_r13.getFilterValue(column_r7))("placeholder", ctx_r13.texts.textFilterTexts.placeholder)("label", ctx_r13.texts.textFilterTexts.label)("initialAlign", "left")("searchButton", ctx_r13.table.explicitSearchBtn)("size", "sm");
} }
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_ng_container_2_adapt_rx_radiobutton_2_Template(rf, ctx) { if (rf & 1) {
    const _r26 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-rx-radiobutton", 22);
    i0.ɵɵlistener("ngModelChange", function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_ng_container_2_adapt_rx_radiobutton_2_Template_adapt_rx_radiobutton_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r26); const column_r7 = i0.ɵɵnextContext(4).$implicit; const ctx_r24 = i0.ɵɵnextContext(2); return ctx_r24.onSelectModelChange($event, column_r7); });
    i0.ɵɵtext(1, "\n                  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r23 = ctx.$implicit;
    const column_r7 = i0.ɵɵnextContext(4).$implicit;
    const ctx_r22 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("value", option_r23.id)("label", option_r23.name)("ngModel", ctx_r22.getFilterValueForSingleSelect(column_r7));
} }
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n\n                  ");
    i0.ɵɵtemplate(2, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_ng_container_2_adapt_rx_radiobutton_2_Template, 2, 4, "adapt-rx-radiobutton", 21);
    i0.ɵɵtext(3, "\n                ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const column_r7 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r19.getSelectOptions(column_r7))("ngForTrackBy", ctx_r19.trackByForSelectOptions);
} }
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    const _r31 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n                  ");
    i0.ɵɵelementStart(1, "adapt-select-migration", 23);
    i0.ɵɵlistener("selectModelChange", function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_ng_template_4_Template_adapt_select_migration_selectModelChange_1_listener($event) { i0.ɵɵrestoreView(_r31); const column_r7 = i0.ɵɵnextContext(3).$implicit; const ctx_r29 = i0.ɵɵnextContext(2); return ctx_r29.onSelectModelChange($event, column_r7); });
    i0.ɵɵtext(2, "\n                  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n                ");
} if (rf & 2) {
    const column_r7 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r21 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("inline", true)("options", ctx_r21.getSelectOptions(column_r7))("optionFormatter", ctx_r21.selectOptionFormatter)("texts", ctx_r21.getSelectTexts(column_r7))("multiple", !ctx_r21.isSingleSelect(column_r7))("settings", ctx_r21.getSelectSettings(column_r7))("value", ctx_r21.getFilterValue(column_r7));
} }
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n                ");
    i0.ɵɵtemplate(2, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_ng_container_2_Template, 4, 2, "ng-container", 13);
    i0.ɵɵtext(3, "\n\n                ");
    i0.ɵɵtemplate(4, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_ng_template_4_Template, 4, 7, "ng-template", null, 20, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r20 = i0.ɵɵreference(5);
    const column_r7 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r14 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r14.isSingleSelect(column_r7))("ngIfElse", _r20);
} }
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n            ");
    i0.ɵɵelementContainerStart(1, 16);
    i0.ɵɵtext(2, "\n              ");
    i0.ɵɵtemplate(3, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_adapt_rx_search_3_Template, 2, 7, "adapt-rx-search", 17);
    i0.ɵɵtext(4, "\n\n              ");
    i0.ɵɵtemplate(5, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_ng_container_5_Template, 7, 2, "ng-container", 18);
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelementContainerEnd();
    i0.ɵɵtext(7, "\n          ");
} if (rf & 2) {
    const column_r7 = i0.ɵɵnextContext().$implicit;
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngSwitch", ctx_r10.filterName(column_r7));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", "textFilter");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", "selectFilter");
} }
function AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-accordion-tab", 12);
    i0.ɵɵtext(1, "\n\n          ");
    i0.ɵɵtemplate(2, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_container_2_Template, 4, 5, "ng-container", 13);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵtemplate(4, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_ng_template_4_Template, 8, 3, "ng-template", null, 14, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(6, "\n\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r7 = ctx.$implicit;
    const _r9 = i0.ɵɵreference(5);
    i0.ɵɵproperty("title", column_r7.header);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", column_r7.filterTemplate)("ngIfElse", _r9);
} }
function AdaptTableMergedFiltersComponent_div_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "adapt-accordion", 10);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵtemplate(4, AdaptTableMergedFiltersComponent_div_19_adapt_accordion_tab_4_Template, 7, 3, "adapt-accordion-tab", 11);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("bordered", false);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r2.columns)("ngForTrackBy", ctx_r2.table.trackByForColumns);
} }
const _c1$7 = function () { return ["bottom-left", "bottom-right"]; };
class AdaptTableMergedFiltersComponent {
    constructor(table, _adaptTableFiltersService) {
        this.table = table;
        this._adaptTableFiltersService = _adaptTableFiltersService;
    }
    getAppliedFiltersForCurrentColumns(columns) {
        const filters = this.table.filters;
        if (!filters) {
            return [];
        }
        return columns
            .filter(column => !!(filters[column.field] && isDefined(filters[column.field].value)))
            .map(column => {
            const filterValue = filters[column.field].value;
            return {
                header: column.header,
                value: isArray(filterValue) ? filterValue.join(', ') : filterValue,
                columnField: column.field
            };
        });
    }
    onRemoveFilterFormApplied(filter) {
        delete this.table.filters[filter.columnField];
        this.table._filter();
    }
    getDropdownButtonLabel(columns) {
        const filters = this.table.filters;
        if (!filters) {
            return this.texts.mergedFiltersTexts.buttonNoAppliedFilters;
        }
        let counter = 0;
        columns.forEach(column => {
            if (isDefined(filters[column.field])) {
                counter++;
            }
        });
        return counter > 0
            ? counter === 1
                ? formatString(this.texts.mergedFiltersTexts.buttonAppliedFilter, counter)
                : formatString(this.texts.mergedFiltersTexts.buttonAppliedFilters, counter)
            : this.texts.mergedFiltersTexts.buttonNoAppliedFilters;
    }
    filterName(column) {
        return this._adaptTableFiltersService.filterName(column);
    }
    isSingleSelect(column) {
        return this._adaptTableFiltersService.getSelectFilterParams(column).single;
    }
    setFilter(value, column, matchMode) {
        this._adaptTableFiltersService.setFilter(value, column, this.table, matchMode);
    }
    getFilterValue(column) {
        return this._adaptTableFiltersService.getFilterValue(column.field, this.table);
    }
    getFilterValueForSingleSelect(column) {
        const filterValue = this.getFilterValue(column);
        return filterValue ? filterValue[0] : null;
    }
    getSelectSettings(column) {
        const filterOptionsLength = this._getFilterOptionsLength(column);
        const showAdditionalSelectControls = filterOptionsLength > 20;
        return {
            enableFilter: showAdditionalSelectControls,
            selectAllButton: showAdditionalSelectControls,
            deselectAllButton: showAdditionalSelectControls
        };
    }
    getSelectOptions(column) {
        return this._adaptTableFiltersService.getSelectOptions(column);
    }
    getSelectTexts(column) {
        return this._adaptTableFiltersService.getSelectTexts(column, this.texts);
    }
    onSelectModelChange(value, column) {
        this._adaptTableFiltersService.onSelectModelChange(value, column, this.table);
    }
    trackByForSelectOptions(index, option) {
        return option.id || index;
    }
    trackByForAppliedFilters(index, filter) {
        return filter.columnField || index;
    }
    selectOptionFormatter(option) {
        return option.name;
    }
    _getFilterOptionsLength(column) {
        const filterParams = this._adaptTableFiltersService.getSelectFilterParams(column);
        return filterParams && filterParams.values && filterParams.values.length;
    }
}
AdaptTableMergedFiltersComponent.ɵfac = function AdaptTableMergedFiltersComponent_Factory(t) { return new (t || AdaptTableMergedFiltersComponent)(i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(AdaptTableFiltersService)); };
AdaptTableMergedFiltersComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTableMergedFiltersComponent, selectors: [["adapt-table-merged-filters"]], inputs: { columns: "columns", index: "index", texts: "texts" }, decls: 23, vars: 11, consts: [["adaptDropdown", "", 1, "adapt-table-filters", 3, "adaptRadarDisableEventSending", "appendToBody", "autoClose", "closeOnEscape", "placement"], ["filtersDropdown", "adaptDropdown"], ["role", "button", "type", "button", "adaptDropdownAnchor", "", 1, "dropdown-toggle", "btn", "btn-secondary", "table-merged-filters__button", 3, "click"], ["adaptDropdownMenu", "", 1, "dropdown-menu", "table-merged-filters__dropdown"], [1, "table-merged-filters__dropdown-label"], [1, "table-merged-filters__tags"], [3, "adaptRadarDisableEventSending", "type", "remove", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "table-merged-filters__dropdown-container", 4, "ngIf"], [3, "adaptRadarDisableEventSending", "type", "remove"], [1, "table-merged-filters__dropdown-container"], [3, "adaptRadarDisableEventSending", "bordered"], ["class", "advanced-filter__accordion-tab", 3, "title", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "advanced-filter__accordion-tab", 3, "title"], [4, "ngIf", "ngIfElse"], ["noFilterTamplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngSwitch"], [3, "adaptRadarDisableEventSending", "ngModel", "placeholder", "label", "initialAlign", "searchButton", "size", "ngModelChange", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [3, "adaptRadarDisableEventSending", "ngModel", "placeholder", "label", "initialAlign", "searchButton", "size", "ngModelChange"], ["notSingle", ""], ["name", "singleSelectionTypeGroup", "class", "advanced-filter__radiobutton", 3, "adaptRadarDisableEventSending", "value", "label", "ngModel", "ngModelChange", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["name", "singleSelectionTypeGroup", 1, "advanced-filter__radiobutton", 3, "adaptRadarDisableEventSending", "value", "label", "ngModel", "ngModelChange"], [1, "advanced-filter__select-inline", 3, "inline", "options", "optionFormatter", "texts", "multiple", "settings", "value", "selectModelChange"]], template: function AdaptTableMergedFiltersComponent_Template(rf, ctx) { if (rf & 1) {
        const _r35 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵtext(2, "\n\n  ");
        i0.ɵɵelementStart(3, "button", 2);
        i0.ɵɵlistener("click", function AdaptTableMergedFiltersComponent_Template_button_click_3_listener($event) { i0.ɵɵrestoreView(_r35); const _r0 = i0.ɵɵreference(1); return _r0.toggle($event); });
        i0.ɵɵtext(4);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(5, "\n\n  ");
        i0.ɵɵelementStart(6, "div", 3);
        i0.ɵɵtext(7, "\n\n    ");
        i0.ɵɵelementStart(8, "div", 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementStart(10, "label");
        i0.ɵɵtext(11);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(12, "\n      ");
        i0.ɵɵelementStart(13, "div", 5);
        i0.ɵɵtext(14, "\n        ");
        i0.ɵɵtemplate(15, AdaptTableMergedFiltersComponent_adapt_tag_15_Template, 2, 4, "adapt-tag", 6);
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n\n    ");
        i0.ɵɵtemplate(19, AdaptTableMergedFiltersComponent_div_19_Template, 7, 4, "div", 7);
        i0.ɵɵtext(20, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(21, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n");
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(1);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true)("autoClose", false)("closeOnEscape", true)("placement", i0.ɵɵpureFunction0(10, _c1$7));
        i0.ɵɵadvance(4);
        i0.ɵɵtextInterpolate1("\n    ", ctx.getDropdownButtonLabel(ctx.columns), "\n  ");
        i0.ɵɵadvance(7);
        i0.ɵɵtextInterpolate(ctx.texts.mergedFiltersTexts.appliedFiltersLabel);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngForOf", ctx.getAppliedFiltersForCurrentColumns(ctx.columns))("ngForTrackBy", ctx.trackByForAppliedFilters);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", _r0 && _r0.isOpen());
    } }, directives: [i1.AdaptDropdownDirective, i1.AdaptDropdownAnchorDirective, i1.AdaptDropdownMenuDirective, i2$1.NgForOf, i2$1.NgIf, i1.AdaptTagComponent, i1.AdaptAccordionComponent, i1.AdaptAccordionTabComponent, i2$1.NgTemplateOutlet, i2$1.NgSwitch, i2$1.NgSwitchCase, i1.AdaptRxSearchComponent, i5.NgControlStatus, i5.NgModel, i1.AdaptRxRadiobuttonComponent, AdaptSelectMigrationComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableMergedFiltersComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-table-merged-filters',
                templateUrl: './adapt-table-merged-filters.html',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: AdaptTableComponent }, { type: AdaptTableFiltersService }]; }, { columns: [{
            type: Input
        }], index: [{
            type: Input
        }], texts: [{
            type: Input
        }] }); })();

function AdaptTableFiltersComponent_ng_container_0_div_2_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
} }
const _c0$a = function (a0, a1) { return { column: a0, index: a1 }; };
function AdaptTableFiltersComponent_ng_container_0_div_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTableFiltersComponent_ng_container_0_div_2_ng_container_2_ng_template_2_Template, 1, 0, "ng-template", 6);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const column_r3 = i0.ɵɵnextContext().$implicit;
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", column_r3.filterTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction2(2, _c0$a, column_r3, ctx_r4.index));
} }
function AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_adapt_rx_search_3_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-rx-search", 10);
    i0.ɵɵlistener("ngModelChange", function AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_adapt_rx_search_3_Template_adapt_rx_search_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r13); const column_r3 = i0.ɵɵnextContext(2).$implicit; const ctx_r11 = i0.ɵɵnextContext(2); return ctx_r11.setFilter($event, column_r3); });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r3 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r9 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("ngModel", ctx_r9.getFilterValue(column_r3.field))("placeholder", ctx_r9.texts.textFilterTexts.placeholder)("label", ctx_r9.texts.textFilterTexts.label)("initialAlign", "left")("searchButton", ctx_r9.table.explicitSearchBtn)("size", "sm");
} }
function AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_adapt_select_migration_5_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-select-migration", 11);
    i0.ɵɵlistener("selectModelChange", function AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_adapt_select_migration_5_Template_adapt_select_migration_selectModelChange_0_listener($event) { i0.ɵɵrestoreView(_r17); const column_r3 = i0.ɵɵnextContext(2).$implicit; const ctx_r15 = i0.ɵɵnextContext(2); return ctx_r15.onSelectModelChange($event, column_r3); })("popupOpenChange", function AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_adapt_select_migration_5_Template_adapt_select_migration_popupOpenChange_0_listener($event) { i0.ɵɵrestoreView(_r17); const column_r3 = i0.ɵɵnextContext(2).$implicit; const ctx_r18 = i0.ɵɵnextContext(2); return $event ? ctx_r18.fireCallback($event, column_r3, "dropdownOpened") : ctx_r18.fireCallback($event, column_r3, "dropdownClosed"); })("filterValueChange", function AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_adapt_select_migration_5_Template_adapt_select_migration_filterValueChange_0_listener($event) { i0.ɵɵrestoreView(_r17); const column_r3 = i0.ɵɵnextContext(2).$implicit; const ctx_r20 = i0.ɵɵnextContext(2); return ctx_r20.fireCallback($event, column_r3, "filterValueChanged"); });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r3 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("settings", ctx_r10.getSelectSettings(column_r3))("texts", ctx_r10.getSelectTexts(column_r3))("options", ctx_r10.getSelectOptions(column_r3))("multiple", !ctx_r10.isSingleSelect(column_r3))("optionFormatter", ctx_r10.selectOptionFormatter)("value", ctx_r10.getFilterValue(column_r3.field));
} }
function AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementContainerStart(1, 7);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtemplate(3, AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_adapt_rx_search_3_Template, 2, 7, "adapt-rx-search", 8);
    i0.ɵɵtext(4, "\n\n        ");
    i0.ɵɵtemplate(5, AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_adapt_select_migration_5_Template, 2, 6, "adapt-select-migration", 9);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementContainerEnd();
    i0.ɵɵtext(7, "\n    ");
} if (rf & 2) {
    const column_r3 = i0.ɵɵnextContext().$implicit;
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngSwitch", ctx_r6.filterName(column_r3));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", "textFilter");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", "selectFilter");
} }
function AdaptTableFiltersComponent_ng_container_0_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 3);
    i0.ɵɵtext(1, "\n\n    ");
    i0.ɵɵtemplate(2, AdaptTableFiltersComponent_ng_container_0_div_2_ng_container_2_Template, 4, 5, "ng-container", 4);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptTableFiltersComponent_ng_container_0_div_2_ng_template_4_Template, 8, 3, "ng-template", null, 5, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(6, "\n\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r3 = ctx.$implicit;
    const _r5 = i0.ɵɵreference(5);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", column_r3.filterTemplate)("ngIfElse", _r5);
} }
function AdaptTableFiltersComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptTableFiltersComponent_ng_container_0_div_2_Template, 7, 2, "div", 2);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r0.columns)("ngForTrackBy", ctx_r0.table.trackByForColumns);
} }
function AdaptTableFiltersComponent_adapt_table_merged_filters_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-table-merged-filters", 12);
    i0.ɵɵtext(1, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("columns", ctx_r1.columns)("index", ctx_r1.index)("texts", ctx_r1.texts);
} }
class AdaptTableFiltersComponent {
    constructor(table, _adaptTableFiltersService) {
        this.table = table;
        this._adaptTableFiltersService = _adaptTableFiltersService;
        this.selectSettingsForMultiple = {
            multiple: true,
            appendToBody: true,
            placement: 'bottom-left',
        };
        this.selectSettingsForSingle = {
            multiple: false,
            enableFilter: true,
            appendToBody: true,
            placement: 'bottom-left',
        };
    }
    filterName(column) {
        return this._adaptTableFiltersService.filterName(column);
    }
    isSingleSelect(column) {
        return this._adaptTableFiltersService.getSelectFilterParams(column).single;
    }
    setFilter(value, column, matchMode) {
        this._adaptTableFiltersService.setFilter(value, column, this.table, matchMode);
    }
    getFilterValue(columnField) {
        return this._adaptTableFiltersService.getFilterValue(columnField, this.table);
    }
    getSelectOptions(column) {
        return this._adaptTableFiltersService.getSelectOptions(column);
    }
    getSelectSettings(column) {
        const filterParams = this._adaptTableFiltersService.getSelectFilterParams(column);
        if (filterParams.selectSettings) {
            return filterParams.selectSettings;
        }
        else {
            return this.isSingleSelect(column) ? this.selectSettingsForSingle : this.selectSettingsForMultiple;
        }
    }
    getSelectTexts(column) {
        return this._adaptTableFiltersService.getSelectTexts(column, this.texts);
    }
    onSelectModelChange(value, column) {
        this._adaptTableFiltersService.onSelectModelChange(value, column, this.table);
    }
    fireCallback(event, column, callbackName) {
        const callbacks = this._getFilterCallbacks(column);
        if (callbacks && callbacks[callbackName]) {
            callbacks[callbackName](event);
        }
    }
    selectOptionFormatter(option) {
        return option.name;
    }
    _getFilterCallbacks(column) {
        const filterParams = this._adaptTableFiltersService.getSelectFilterParams(column);
        return filterParams.callbacks;
    }
}
AdaptTableFiltersComponent.ɵfac = function AdaptTableFiltersComponent_Factory(t) { return new (t || AdaptTableFiltersComponent)(i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(AdaptTableFiltersService)); };
AdaptTableFiltersComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTableFiltersComponent, selectors: [["adapt-table-filters"]], inputs: { columns: "columns", index: "index", texts: "texts" }, decls: 4, vars: 2, consts: [[4, "ngIf"], [3, "columns", "index", "texts", 4, "ngIf"], ["class", "adapt-table-filters", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "adapt-table-filters"], [4, "ngIf", "ngIfElse"], ["noFilterTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngSwitch"], [3, "adaptRadarDisableEventSending", "ngModel", "placeholder", "label", "initialAlign", "searchButton", "size", "ngModelChange", 4, "ngSwitchCase"], [3, "settings", "texts", "options", "multiple", "optionFormatter", "value", "selectModelChange", "popupOpenChange", "filterValueChange", 4, "ngSwitchCase"], [3, "adaptRadarDisableEventSending", "ngModel", "placeholder", "label", "initialAlign", "searchButton", "size", "ngModelChange"], [3, "settings", "texts", "options", "multiple", "optionFormatter", "value", "selectModelChange", "popupOpenChange", "filterValueChange"], [3, "columns", "index", "texts"]], template: function AdaptTableFiltersComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptTableFiltersComponent_ng_container_0_Template, 4, 2, "ng-container", 0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptTableFiltersComponent_adapt_table_merged_filters_2_Template, 2, 3, "adapt-table-merged-filters", 1);
        i0.ɵɵtext(3, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.columns.length < 2);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.columns.length >= 2);
    } }, directives: [i2$1.NgIf, i2$1.NgForOf, i2$1.NgTemplateOutlet, i2$1.NgSwitch, i2$1.NgSwitchCase, i1.AdaptRxSearchComponent, i5.NgControlStatus, i5.NgModel, AdaptSelectMigrationComponent, AdaptTableMergedFiltersComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableFiltersComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-table-filters',
                templateUrl: './adapt-table-filters.html',
            }]
    }], function () { return [{ type: AdaptTableComponent }, { type: AdaptTableFiltersService }]; }, { columns: [{
            type: Input
        }], index: [{
            type: Input
        }], texts: [{
            type: Input
        }] }); })();

class AdaptTableToolbarItemDirective {
    constructor(_elRef, _renderer, _changeDetectorRef) {
        this._elRef = _elRef;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.recalculateWidth = this._initItem.bind(this);
        this.itemContext = {
            hidden: false,
            collapsed: false
        };
        this.itemAppearanceChange = new Subject();
        this._fixOnToolbar = false;
        this._removeFromToolbar = false;
    }
    set fixOnToolbar(value) {
        if (Boolean(value) !== this._fixOnToolbar) {
            this._fixOnToolbar = Boolean(value);
            this.itemAppearanceChange.next();
        }
    }
    get fixOnToolbar() {
        return this._fixOnToolbar;
    }
    set collapse(value) {
        if (Boolean(value) !== this.itemContext.collapsed) {
            this.itemContext.collapsed = Boolean(value);
            SafeCdr.detectChanges(this._changeDetectorRef);
        }
    }
    get collapse() {
        return this.itemContext.collapsed;
    }
    set hideToPopup(value) {
        if (Boolean(value) !== this.itemContext.hidden) {
            this.itemContext.hidden = Boolean(value);
            this._checkAppearance();
        }
    }
    get hideToPopup() {
        return this.itemContext.hidden;
    }
    set removeFromToolbar(value) {
        if (Boolean(value) !== this._removeFromToolbar) {
            this._removeFromToolbar = Boolean(value);
            this.itemAppearanceChange.next();
        }
    }
    get removeFromToolbar() {
        return this._removeFromToolbar;
    }
    _initItem() {
        this.hideToPopup = false;
        this.collapse = false;
        this._renderer.addClass(this._elRef.nativeElement, 'position-absolute');
        this.width = Math.ceil(this._elRef.nativeElement.offsetWidth);
        this.collapse = true;
        this.collapsedWidth = Math.ceil(this._elRef.nativeElement.offsetWidth);
        this._renderer.removeClass(this._elRef.nativeElement, 'position-absolute');
    }
    _checkAppearance() {
        if (this.itemContext.hidden) {
            this._renderer.addClass(this._elRef.nativeElement, 'adapt-table-toolbar-item_hidden');
        }
        else {
            this._renderer.removeClass(this._elRef.nativeElement, 'adapt-table-toolbar-item_hidden');
        }
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
}
AdaptTableToolbarItemDirective.ɵfac = function AdaptTableToolbarItemDirective_Factory(t) { return new (t || AdaptTableToolbarItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptTableToolbarItemDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTableToolbarItemDirective, selectors: [["", "adaptToolbarItem", ""]], inputs: { adaptToolbarItem: "adaptToolbarItem", fixOnToolbar: "fixOnToolbar", collapse: "collapse", hideToPopup: "hideToPopup", removeFromToolbar: "removeFromToolbar" }, outputs: { itemAppearanceChange: "itemAppearanceChange" }, exportAs: ["adaptToolbarItem"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableToolbarItemDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptToolbarItem]',
                exportAs: 'adaptToolbarItem'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, { adaptToolbarItem: [{
            type: Input
        }], fixOnToolbar: [{
            type: Input
        }], collapse: [{
            type: Input
        }], hideToPopup: [{
            type: Input
        }], removeFromToolbar: [{
            type: Input
        }], itemAppearanceChange: [{
            type: Output
        }] }); })();

class SortByPipe {
    transform(items, comparator, sortType, sortOrder = 'ASC') {
        if (isNil(items)) {
            return items;
        }
        else {
            const itemsCopy = [...items];
            if (isString(comparator)) {
                switch (sortType) {
                    case 'string':
                        itemsCopy.sort((a, b) => {
                            // undefined and null values goes to bottom\top
                            if (isNil(a[comparator])) {
                                return sortOrder === 'DESC' ? -1 : 1;
                            }
                            else if (isNil(b[comparator])) {
                                return sortOrder === 'DESC' ? 1 : -1;
                            }
                            return sortOrder === 'DESC'
                                ? b[comparator].localeCompare(a[comparator])
                                : a[comparator].localeCompare(b[comparator]);
                        });
                        break;
                    case 'number':
                        itemsCopy.sort((a, b) => {
                            // undefined and null values goes to bottom\top
                            if (isNil(a[comparator])) {
                                return sortOrder === 'DESC' ? -1 : 1;
                            }
                            else if (isNil(b[comparator])) {
                                return sortOrder === 'DESC' ? 1 : -1;
                            }
                            return sortOrder === 'DESC'
                                ? b[comparator] - a[comparator]
                                : a[comparator] - b[comparator];
                        });
                        break;
                    case 'boolean':
                        itemsCopy.sort((a, b) => {
                            // undefined and null values goes to bottom\top
                            if (isNil(a[comparator])) {
                                return sortOrder === 'DESC' ? -1 : 1;
                            }
                            else if (isNil(b[comparator])) {
                                return sortOrder === 'DESC' ? 1 : -1;
                            }
                            return sortOrder === 'DESC'
                                ? toNumber(!!a[comparator]) - toNumber(!!b[comparator])
                                : toNumber(!!b[comparator]) - toNumber(!!a[comparator]);
                        });
                        break;
                    default:
                        itemsCopy.sort((a, b) => {
                            if (isNil(a[comparator])) {
                                return sortOrder === 'DESC' ? -1 : 1;
                            }
                            else if (isNil(b[comparator])) {
                                return sortOrder === 'DESC' ? 1 : -1;
                            }
                            else {
                                if (toString(a[comparator]) < toString(b[comparator])) {
                                    return sortOrder === 'DESC' ? 1 : -1;
                                }
                                if (toString(a[comparator]) > toString(b[comparator])) {
                                    return sortOrder === 'DESC' ? -1 : 1;
                                }
                            }
                            return 0;
                        });
                }
            }
            else {
                itemsCopy.sort(comparator);
            }
            return itemsCopy;
        }
    }
}
SortByPipe.ɵfac = function SortByPipe_Factory(t) { return new (t || SortByPipe)(); };
SortByPipe.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: "sortBy", type: SortByPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SortByPipe, [{
        type: Pipe,
        args: [{
                name: 'sortBy'
            }]
    }], null, null); })();

const _c0$9 = ["filterInput"];
const _c1$6 = ["adaptRxSearchComponent"];
const _c2$5 = ["toolbarContainerEl"];
const _c3$2 = ["toolbarSectionsSeparatorEl"];
const _c4$1 = ["toolbarContentSeparatorEl"];
const _c5$1 = ["toolbarControlsEl"];
const _c6$1 = ["adaptListKeyManagerItem"];
const _c7$1 = function (a0) { return { $implicit: a0 }; };
function AdaptTableToolbarComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r27 = i0.ɵɵreference(86);
    const _r1 = i0.ɵɵreference(6);
    i0.ɵɵproperty("ngTemplateOutlet", _r27)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r1.itemContext));
} }
function AdaptTableToolbarComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r29 = i0.ɵɵreference(89);
    const _r3 = i0.ɵɵreference(12);
    i0.ɵɵproperty("ngTemplateOutlet", _r29)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r3.itemContext));
} }
function AdaptTableToolbarComponent_div_17_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r47 = i0.ɵɵreference(1);
    i0.ɵɵnextContext();
    const _r31 = i0.ɵɵreference(92);
    i0.ɵɵproperty("ngTemplateOutlet", _r31)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r47.itemContext));
} }
function AdaptTableToolbarComponent_div_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 38, 39);
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵtemplate(3, AdaptTableToolbarComponent_div_17_ng_container_3_Template, 1, 4, "ng-container", 5);
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r47 = i0.ɵɵreference(1);
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵproperty("adaptToolbarItem", ctx_r5.TOOLBAR_ITEMS_BY_PRIORITY.SELECTION_LIMIT);
    i0.ɵɵattribute("data-testid", ctx_r5.testID + "_limit");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", !(_r47.hideToPopup || _r47.removeFromToolbar));
} }
function AdaptTableToolbarComponent_ng_container_22_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r33 = i0.ɵɵreference(95);
    const _r6 = i0.ɵɵreference(20);
    i0.ɵɵproperty("ngTemplateOutlet", _r33)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r6.itemContext));
} }
function AdaptTableToolbarComponent_ng_container_28_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r35 = i0.ɵɵreference(98);
    const _r8 = i0.ɵɵreference(26);
    i0.ɵɵproperty("ngTemplateOutlet", _r35)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r8.itemContext));
} }
function AdaptTableToolbarComponent_ng_container_34_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r37 = i0.ɵɵreference(101);
    const _r10 = i0.ɵɵreference(32);
    i0.ɵɵproperty("ngTemplateOutlet", _r37)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r10.itemContext));
} }
function AdaptTableToolbarComponent_ng_container_43_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r39 = i0.ɵɵreference(104);
    const _r13 = i0.ɵɵreference(41);
    i0.ɵɵproperty("ngTemplateOutlet", _r39)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r13.itemContext));
} }
function AdaptTableToolbarComponent_ng_container_49_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r25 = i0.ɵɵreference(83);
    const _r15 = i0.ɵɵreference(47);
    i0.ɵɵproperty("ngTemplateOutlet", _r25)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r15.itemContext));
} }
function AdaptTableToolbarComponent_ng_container_55_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r41 = i0.ɵɵreference(107);
    const _r17 = i0.ɵɵreference(53);
    i0.ɵɵproperty("ngTemplateOutlet", _r41)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r17.itemContext));
} }
function AdaptTableToolbarComponent_ng_container_61_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 37);
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r43 = i0.ɵɵreference(110);
    const _r19 = i0.ɵɵreference(59);
    i0.ɵɵproperty("ngTemplateOutlet", _r43)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r19.itemContext));
} }
function AdaptTableToolbarComponent_span_73_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 40);
} }
function AdaptTableToolbarComponent_ng_template_76_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 45);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementContainer(2, 37);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r29 = i0.ɵɵreference(89);
    const _r3 = i0.ɵɵreference(12);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r29)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r3.itemContext));
} }
function AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementContainer(2, 37);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r27 = i0.ɵɵreference(86);
    const _r1 = i0.ɵɵreference(6);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r27)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r1.itemContext));
} }
function AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementContainer(2, 37);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r33 = i0.ɵɵreference(95);
    const _r6 = i0.ɵɵreference(20);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r33)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r6.itemContext));
} }
function AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementContainer(2, 37);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r43 = i0.ɵɵreference(110);
    const _r19 = i0.ɵɵreference(59);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r43)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r19.itemContext));
} }
function AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementContainer(2, 37);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r39 = i0.ɵɵreference(104);
    const _r13 = i0.ɵɵreference(41);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r39)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r13.itemContext));
} }
function AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementContainer(2, 37);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r25 = i0.ɵɵreference(83);
    const _r15 = i0.ɵɵreference(47);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r25)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r15.itemContext));
} }
function AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementContainer(2, 37);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r37 = i0.ɵɵreference(101);
    const _r10 = i0.ɵɵreference(32);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r37)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, _r10.itemContext));
} }
function AdaptTableToolbarComponent_ng_template_76_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 42);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptTableToolbarComponent_ng_template_76_div_1_div_2_Template, 4, 4, "div", 43);
    i0.ɵɵtext(3, "\n\n          ");
    i0.ɵɵtemplate(4, AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_4_Template, 4, 4, "ng-container", 44);
    i0.ɵɵtext(5, "\n\n          ");
    i0.ɵɵtemplate(6, AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_6_Template, 4, 4, "ng-container", 44);
    i0.ɵɵtext(7, "\n\n          ");
    i0.ɵɵtemplate(8, AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_8_Template, 4, 4, "ng-container", 44);
    i0.ɵɵtext(9, "\n\n          ");
    i0.ɵɵtemplate(10, AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_10_Template, 4, 4, "ng-container", 44);
    i0.ɵɵtext(11, "\n\n          ");
    i0.ɵɵtemplate(12, AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_12_Template, 4, 4, "ng-container", 44);
    i0.ɵɵtext(13, "\n\n          ");
    i0.ɵɵtemplate(14, AdaptTableToolbarComponent_ng_template_76_div_1_ng_container_14_Template, 4, 4, "ng-container", 44);
    i0.ɵɵtext(15, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r49 = i0.ɵɵnextContext(2);
    const _r3 = i0.ɵɵreference(12);
    const _r1 = i0.ɵɵreference(6);
    const _r6 = i0.ɵɵreference(20);
    const _r19 = i0.ɵɵreference(59);
    const _r13 = i0.ɵɵreference(41);
    const _r15 = i0.ɵɵreference(47);
    const _r10 = i0.ɵɵreference(32);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r49.config.counter && _r3.hideToPopup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r49.config.refreshButton && _r1.hideToPopup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r49.config.filter && _r6.hideToPopup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r49.config.visibleColumnsMenu && _r19.hideToPopup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r49.config.rightCustomSection && _r13.hideToPopup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", (ctx_r49.config.export == null ? null : ctx_r49.config.export.exportTypes == null ? null : ctx_r49.config.export.exportTypes.length) && _r15.hideToPopup);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r49.config.leftCustomSection && _r10.hideToPopup);
} }
function AdaptTableToolbarComponent_ng_template_76_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵtemplate(1, AdaptTableToolbarComponent_ng_template_76_div_1_Template, 16, 7, "div", 41);
    i0.ɵɵtext(2, "\n      ");
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r24.hasHiddenItems);
} }
function AdaptTableToolbarComponent_ng_template_82_span_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r59 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r59.texts.export);
} }
function AdaptTableToolbarComponent_ng_template_82_ng_template_11_ng_template_8_Template(rf, ctx) { }
function AdaptTableToolbarComponent_ng_template_82_ng_template_11_ng_container_11_ng_template_9_Template(rf, ctx) { }
const _c8$1 = function (a0) { return { exportSelected: a0 }; };
function AdaptTableToolbarComponent_ng_template_82_ng_template_11_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelement(2, "div", 54);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "div", 52);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelementStart(6, "p", 53);
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n            ");
    i0.ɵɵtemplate(9, AdaptTableToolbarComponent_ng_template_82_ng_template_11_ng_container_11_ng_template_9_Template, 0, 0, "ng-template", 37);
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(2);
    const _r61 = i0.ɵɵreference(15);
    const ctx_r64 = i0.ɵɵnextContext();
    i0.ɵɵadvance(7);
    i0.ɵɵtextInterpolate(ctx_r64.texts.exportSelected);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r61)("ngTemplateOutletContext", i0.ɵɵpureFunction1(5, _c7$1, i0.ɵɵpureFunction1(3, _c8$1, ctx_r64.config.export.showExportForSelected)));
} }
const _c9$1 = function () { return { exportSelected: false }; };
function AdaptTableToolbarComponent_ng_template_82_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r67 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 51);
    i0.ɵɵlistener("keydown", function AdaptTableToolbarComponent_ng_template_82_ng_template_11_Template_div_keydown_1_listener($event) { i0.ɵɵrestoreView(_r67); i0.ɵɵnextContext(); const _r58 = i0.ɵɵreference(2); const ctx_r66 = i0.ɵɵnextContext(); return ctx_r66.handleDropdownMenuKeydown($event, ctx_r66.TOOLBAR_ITEMS_BY_PRIORITY.EXPORT, _r58); });
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "div", 52);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "p", 53);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵtemplate(8, AdaptTableToolbarComponent_ng_template_82_ng_template_11_ng_template_8_Template, 0, 0, "ng-template", 37);
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n\n        ");
    i0.ɵɵtemplate(11, AdaptTableToolbarComponent_ng_template_82_ng_template_11_ng_container_11_Template, 12, 7, "ng-container", 44);
    i0.ɵɵtext(12, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n    ");
} if (rf & 2) {
    const context_r57 = i0.ɵɵnextContext().$implicit;
    const _r61 = i0.ɵɵreference(15);
    const ctx_r60 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵattribute("aria-activedescendant", ctx_r60.isActiveDescendant(context_r57.id));
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r60.texts.exportEntireDocument);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r61)("ngTemplateOutletContext", i0.ɵɵpureFunction1(6, _c7$1, i0.ɵɵpureFunction0(5, _c9$1)));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r60.showExportSelected);
} }
function AdaptTableToolbarComponent_ng_template_82_ng_template_14_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r74 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "span");
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "button", 57, 58);
    i0.ɵɵlistener("keydown", function AdaptTableToolbarComponent_ng_template_82_ng_template_14_ng_container_3_Template_button_keydown_4_listener($event) { i0.ɵɵrestoreView(_r74); i0.ɵɵnextContext(2); const _r58 = i0.ɵɵreference(2); const ctx_r73 = i0.ɵɵnextContext(); return ctx_r73.closeMenuOnKeydown($event, _r58); })("click", function AdaptTableToolbarComponent_ng_template_82_ng_template_14_ng_container_3_Template_button_click_4_listener() { const restoredCtx = i0.ɵɵrestoreView(_r74); const exportItem_r71 = restoredCtx.$implicit; const context_r69 = i0.ɵɵnextContext().$implicit; const ctx_r75 = i0.ɵɵnextContext(2); return ctx_r75.exportAs({ type: ctx_r75.exportType[exportItem_r71.type], selectionOnly: context_r69.exportSelected }); });
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelement(7, "span");
    i0.ɵɵtext(8, "\n            ");
    i0.ɵɵelementStart(9, "span");
    i0.ɵɵtext(10);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const exportItem_r71 = ctx.$implicit;
    i0.ɵɵadvance(7);
    i0.ɵɵclassMapInterpolate1("toolbar-export-type-icon d-icon-file_arrow_", exportItem_r71.type.toLowerCase(), "");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(exportItem_r71.type);
} }
function AdaptTableToolbarComponent_ng_template_82_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵelementStart(1, "div", 55);
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵtemplate(3, AdaptTableToolbarComponent_ng_template_82_ng_template_14_ng_container_3_Template, 14, 4, "ng-container", 56);
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n  ");
} if (rf & 2) {
    const ctx_r62 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", ctx_r62.config.export.exportTypes);
} }
const _c10$1 = function () { return ["left-top", "auto"]; };
const _c11$1 = function () { return ["bottom-left", "auto"]; };
function AdaptTableToolbarComponent_ng_template_82_Template(rf, ctx) { if (rf & 1) {
    const _r78 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n\n  ");
    i0.ɵɵelementStart(1, "div", 46, 47);
    i0.ɵɵlistener("popupAnimationDone", function AdaptTableToolbarComponent_ng_template_82_Template_div_popupAnimationDone_1_listener() { i0.ɵɵrestoreView(_r78); const _r58 = i0.ɵɵreference(2); const ctx_r77 = i0.ɵɵnextContext(); return ctx_r77.popupAnimationDone(_r58, ctx_r77.TOOLBAR_ITEMS_BY_PRIORITY.EXPORT); });
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementStart(4, "button", 48);
    i0.ɵɵlistener("keydown", function AdaptTableToolbarComponent_ng_template_82_Template_button_keydown_4_listener($event) { i0.ɵɵrestoreView(_r78); const _r58 = i0.ɵɵreference(2); const ctx_r79 = i0.ɵɵnextContext(); return ctx_r79.anchorKeydownHandler($event, _r58); })("click", function AdaptTableToolbarComponent_ng_template_82_Template_button_click_4_listener($event) { i0.ɵɵrestoreView(_r78); const _r58 = i0.ɵɵreference(2); return _r58.toggle($event); });
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelement(6, "span", 49);
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵtemplate(8, AdaptTableToolbarComponent_ng_template_82_span_8_Template, 2, 1, "span", 44);
    i0.ɵɵtext(9, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n\n    ");
    i0.ɵɵtemplate(11, AdaptTableToolbarComponent_ng_template_82_ng_template_11_Template, 14, 8, "ng-template", 25);
    i0.ɵɵtext(12, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n\n  ");
    i0.ɵɵtemplate(14, AdaptTableToolbarComponent_ng_template_82_ng_template_14_Template, 6, 1, "ng-template", null, 50, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(16, "\n");
} if (rf & 2) {
    const context_r57 = ctx.$implicit;
    const ctx_r26 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("autoClose", "outside")("placement", context_r57.hidden ? i0.ɵɵpureFunction0(10, _c10$1) : i0.ɵɵpureFunction0(11, _c11$1))("appendToBody", true)("restoreFocusAfterClose", ctx_r26.shouldRestoreFocus)("focusNextElementAfterClose", ctx_r26.shouldFocusNext);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngClass", context_r57.hidden ? "list-group-item list-group-item-action caret-right" : "btn btn-link d-icon-right-triangle_down");
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("mr-1", !context_r57.collapsed || context_r57.hidden);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", context_r57.hidden || !context_r57.collapsed);
} }
function AdaptTableToolbarComponent_ng_template_85_Template(rf, ctx) { if (rf & 1) {
    const _r83 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 59);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "button", 60);
    i0.ɵɵlistener("click", function AdaptTableToolbarComponent_ng_template_85_Template_button_click_3_listener($event) { i0.ɵɵrestoreView(_r83); const ctx_r82 = i0.ɵɵnextContext(); return ctx_r82.refreshButtonClick($event); });
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(5, "svg", 61);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelement(7, "path", 62);
    i0.ɵɵtext(8, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n      ");
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementStart(10, "span", 59);
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n");
} if (rf & 2) {
    const context_r81 = ctx.$implicit;
    const ctx_r28 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", !context_r81.hidden ? "p-start-2" : "");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", !context_r81.hidden ? "px-1" : "btn-block align-start list-group-item px-2");
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("animated", ctx_r28.table.isRefreshingRowData);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngClass", !context_r81.hidden ? "sr-only" : "ml-1");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r28.texts.refresh);
} }
function AdaptTableToolbarComponent_ng_template_88_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementContainer(1, 37);
    i0.ɵɵtext(2, "\n");
} if (rf & 2) {
    const context_r84 = ctx.$implicit;
    const ctx_r30 = i0.ɵɵnextContext();
    const _r45 = i0.ɵɵreference(114);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r30.config.counterTemplate || _r45)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, context_r84));
} }
function AdaptTableToolbarComponent_ng_template_91_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 66);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r86 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r86.showSelectionLimitText(0), "\n    ");
} }
function AdaptTableToolbarComponent_ng_template_91_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r90 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 67);
    i0.ɵɵlistener("click", function AdaptTableToolbarComponent_ng_template_91_button_5_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r90); const ctx_r89 = i0.ɵɵnextContext(2); return ctx_r89.showAllSelectedRows(); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r87 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r87.showSelectionLimitText(ctx_r87.table.getRowSelectionArray().length), "\n    ");
} }
function AdaptTableToolbarComponent_ng_template_91_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r92 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 67);
    i0.ɵɵlistener("click", function AdaptTableToolbarComponent_ng_template_91_button_7_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r92); const ctx_r91 = i0.ɵɵnextContext(2); return ctx_r91.showAllRows(); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r88 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r88.texts.showAllSelected, "\n    ");
} }
function AdaptTableToolbarComponent_ng_template_91_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 63);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵtemplate(3, AdaptTableToolbarComponent_ng_template_91_div_3_Template, 2, 1, "div", 64);
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵtemplate(5, AdaptTableToolbarComponent_ng_template_91_button_5_Template, 2, 1, "button", 65);
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵtemplate(7, AdaptTableToolbarComponent_ng_template_91_button_7_Template, 2, 1, "button", 65);
    i0.ɵɵtext(8, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n");
} if (rf & 2) {
    const ctx_r32 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", !ctx_r32.table.getRowSelectionArray().length);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r32.table.getRowSelectionArray().length && !ctx_r32.onlySelectedRowsShown);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r32.onlySelectedRowsShown);
} }
function AdaptTableToolbarComponent_ng_template_94_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementContainer(1, 37);
    i0.ɵɵtext(2, "\n");
} if (rf & 2) {
    const context_r93 = ctx.$implicit;
    const ctx_r34 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r34.config.filterTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, context_r93));
} }
function AdaptTableToolbarComponent_ng_template_97_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementContainer(1, 37);
    i0.ɵɵtext(2, "\n");
} if (rf & 2) {
    const context_r94 = ctx.$implicit;
    const ctx_r36 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r36.config.filterResultsTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, context_r94));
} }
function AdaptTableToolbarComponent_ng_template_100_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementContainer(1, 37);
    i0.ɵɵtext(2, "\n");
} if (rf & 2) {
    const context_r95 = ctx.$implicit;
    const ctx_r38 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r38.config.leftCustomSectionTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, context_r95));
} }
function AdaptTableToolbarComponent_ng_template_103_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementContainer(1, 37);
    i0.ɵɵtext(2, "\n");
} if (rf & 2) {
    const context_r96 = ctx.$implicit;
    const ctx_r40 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r40.config.rightCustomSectionTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c7$1, context_r96));
} }
function AdaptTableToolbarComponent_ng_template_106_Template(rf, ctx) { if (rf & 1) {
    const _r100 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 68);
    i0.ɵɵtext(2, "\n\n    ");
    i0.ɵɵelementStart(3, "adapt-rx-search", 69, 70);
    i0.ɵɵlistener("ngModelChange", function AdaptTableToolbarComponent_ng_template_106_Template_adapt_rx_search_ngModelChange_3_listener($event) { i0.ɵɵrestoreView(_r100); const ctx_r99 = i0.ɵɵnextContext(); return ctx_r99.searchModel = $event; })("ngModelChange", function AdaptTableToolbarComponent_ng_template_106_Template_adapt_rx_search_ngModelChange_3_listener($event) { i0.ɵɵrestoreView(_r100); const ctx_r101 = i0.ɵɵnextContext(); return ctx_r101.table.setQuickFilter($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n");
} if (rf & 2) {
    const ctx_r42 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("adapt-table-search_bordered", ctx_r42.table.bordered);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("ngModel", ctx_r42.searchModel)("searchButton", ctx_r42.config.quickFilterTriggerable)("size", ctx_r42.table.bordered ? "default" : "sm")("placeholder", ctx_r42.texts.searchPlaceholder)("label", ctx_r42.texts.searchLabel);
} }
function AdaptTableToolbarComponent_ng_template_109_span_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 72);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r104 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r104.texts.visibleColumnsMenuLabel);
} }
function AdaptTableToolbarComponent_ng_template_109_ng_template_9_ng_template_5_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r112 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 76, 58);
    i0.ɵɵlistener("keydown", function AdaptTableToolbarComponent_ng_template_109_ng_template_9_ng_template_5_div_1_Template_div_keydown_0_listener($event) { i0.ɵɵrestoreView(_r112); i0.ɵɵnextContext(3); const _r103 = i0.ɵɵreference(2); const ctx_r111 = i0.ɵɵnextContext(); return ctx_r111.closeMenuOnKeydown($event, _r103); });
    i0.ɵɵtext(2, "\n            ");
    i0.ɵɵelementStart(3, "div");
    i0.ɵɵtext(4, "\n              ");
    i0.ɵɵelementStart(5, "adapt-rx-checkbox", 77);
    i0.ɵɵlistener("ngModelChange", function AdaptTableToolbarComponent_ng_template_109_ng_template_9_ng_template_5_div_1_Template_adapt_rx_checkbox_ngModelChange_5_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r112); const col_r109 = restoredCtx.$implicit; const ctx_r113 = i0.ɵɵnextContext(4); return ctx_r113.changeColumnVisibility($event, col_r109); });
    i0.ɵɵtext(6, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r109 = ctx.$implicit;
    const _r110 = i0.ɵɵreference(1);
    const ctx_r108 = i0.ɵɵnextContext(4);
    i0.ɵɵclassProp("ui-state-disabled", ctx_r108.isLastVisibleColumn(col_r109))("text-active", ctx_r108.isActiveDescendant(_r110) && !ctx_r108.isLastVisibleColumn(col_r109));
    i0.ɵɵproperty("label", col_r109.header);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("label", col_r109.header)("disabled", ctx_r108.isLastVisibleColumn(col_r109))("ngModel", ctx_r108.table.isColumnVisible(col_r109));
} }
function AdaptTableToolbarComponent_ng_template_109_ng_template_9_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, AdaptTableToolbarComponent_ng_template_109_ng_template_9_ng_template_5_div_1_Template, 9, 9, "div", 75);
    i0.ɵɵpipe(2, "sortBy");
    i0.ɵɵtext(3, "\n        ");
} if (rf & 2) {
    const ctx_r107 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind2(2, 2, ctx_r107.table.columns, ctx_r107.visibleColumnsFirst))("ngForTrackBy", ctx_r107.table.trackByForColumns);
} }
function AdaptTableToolbarComponent_ng_template_109_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    const _r115 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 73);
    i0.ɵɵlistener("keydown", function AdaptTableToolbarComponent_ng_template_109_ng_template_9_Template_div_keydown_1_listener($event) { i0.ɵɵrestoreView(_r115); i0.ɵɵnextContext(); const _r103 = i0.ɵɵreference(2); const ctx_r114 = i0.ɵɵnextContext(); return ctx_r114.handleDropdownMenuKeydown($event, ctx_r114.TOOLBAR_ITEMS_BY_PRIORITY.VISIBLE_COLUMNS, _r103); });
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementContainer(3, 37);
    i0.ɵɵtext(4, "\n\n        ");
    i0.ɵɵtemplate(5, AdaptTableToolbarComponent_ng_template_109_ng_template_9_ng_template_5_Template, 4, 5, "ng-template", null, 74, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n    ");
} if (rf & 2) {
    const _r106 = i0.ɵɵreference(6);
    const context_r102 = i0.ɵɵnextContext().$implicit;
    const ctx_r105 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵattribute("aria-activedescendant", ctx_r105.isActiveDescendant(context_r102.id));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r105.config.visibleColumnsMenuTemplate || _r106)("ngTemplateOutletContext", i0.ɵɵpureFunction1(3, _c7$1, context_r102));
} }
const _c12 = function () { return ["bottom-right", "auto"]; };
function AdaptTableToolbarComponent_ng_template_109_Template(rf, ctx) { if (rf & 1) {
    const _r118 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 46, 47);
    i0.ɵɵlistener("popupAnimationDone", function AdaptTableToolbarComponent_ng_template_109_Template_div_popupAnimationDone_1_listener() { i0.ɵɵrestoreView(_r118); const _r103 = i0.ɵɵreference(2); const ctx_r117 = i0.ɵɵnextContext(); return ctx_r117.popupAnimationDone(_r103, ctx_r117.TOOLBAR_ITEMS_BY_PRIORITY.VISIBLE_COLUMNS); });
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementStart(4, "button", 48);
    i0.ɵɵlistener("keydown", function AdaptTableToolbarComponent_ng_template_109_Template_button_keydown_4_listener($event) { i0.ɵɵrestoreView(_r118); const _r103 = i0.ɵɵreference(2); const ctx_r119 = i0.ɵɵnextContext(); return ctx_r119.anchorKeydownHandler($event, _r103); })("click", function AdaptTableToolbarComponent_ng_template_109_Template_button_click_4_listener($event) { i0.ɵɵrestoreView(_r118); const _r103 = i0.ɵɵreference(2); return _r103.toggle($event); });
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵtemplate(6, AdaptTableToolbarComponent_ng_template_109_span_6_Template, 2, 1, "span", 71);
    i0.ɵɵtext(7, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n\n    ");
    i0.ɵɵtemplate(9, AdaptTableToolbarComponent_ng_template_109_ng_template_9_Template, 9, 5, "ng-template", 25);
    i0.ɵɵtext(10, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n");
} if (rf & 2) {
    const context_r102 = ctx.$implicit;
    const ctx_r44 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("autoClose", "outside")("placement", context_r102.hidden ? i0.ɵɵpureFunction0(8, _c10$1) : i0.ɵɵpureFunction0(9, _c12))("appendToBody", true)("restoreFocusAfterClose", ctx_r44.shouldRestoreFocus)("focusNextElementAfterClose", ctx_r44.shouldFocusNext);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngClass", ctx_r44.getClassForChangeVisibilityButton(context_r102.hidden));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", context_r102.hidden || !context_r102.collapsed);
} }
function AdaptTableToolbarComponent_ng_template_113_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 78);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n");
} if (rf & 2) {
    const context_r121 = ctx.$implicit;
    const ctx_r46 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngClass", !context_r121.hidden ? "p-start-3 p-end-1" : "");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r46.getToolbarText());
} }
let nextUniqueId = 0;
class AdaptTableToolbarComponent {
    constructor(table, focusMonitorService, resizeService, dir, _ngZone, _eventManager, _cdr) {
        this.table = table;
        this.focusMonitorService = focusMonitorService;
        this.resizeService = resizeService;
        this.dir = dir;
        this._ngZone = _ngZone;
        this._eventManager = _eventManager;
        this._cdr = _cdr;
        this.HIDDEN_ITEMS_BTN_WIDTH = 35;
        this.TOOLBAR_ITEMS_HIDE_TOLERANCE = 10;
        this.TOOLBAR_ITEMS_BY_PRIORITY = ToolbarItemsByPriority;
        this.defaultTexts = {};
        this.hasHiddenItems = false;
        this.searchFullSize = false;
        this.filterFocus = false;
        this.openHiddenItemsMenu = false;
        this.onlySelectedRowsShown = false;
        this.isRTL = false;
        this.firstRecalculationComplete = false;
        this.testID = `adapt-toolbar-${++nextUniqueId}`;
        this.searchModel = '';
        this.exportType = ExportType;
        this.config = {};
        this.toolbarItemsByHidePriority = [];
        this._destroyed$ = new ReplaySubject(1);
        this._shouldRestoreFocus = true;
        this._shouldFocusNext = true;
    }
    ngOnInit() {
        this.isRTL = this.dir.value === 'rtl';
        const tableService = this.table.getTableService();
        tableService.selectionSource$
            .pipe(takeUntil(this._destroyed$))
            .subscribe((selection) => {
            var _a;
            if (this.onlySelectedRowsShown) {
                if (this.table.getRowSelectionArray().length) {
                    this.updateSelectedRowsDisplaying(false);
                }
                else {
                    this.showAllRows(false);
                }
            }
            if ((_a = this.config.export) === null || _a === void 0 ? void 0 : _a.showExportForSelected) {
                this.showExportSelected = !!(selection === null || selection === void 0 ? void 0 : selection.length);
            }
        });
        this.table.onFilter.asObservable()
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            if (this.onlySelectedRowsShown) {
                this.showAllRows(true);
            }
        });
        if (this.config.testID) {
            this.testID = this.config.testID + (++nextUniqueId);
        }
    }
    ngAfterViewInit() {
        this.toolbarItemsByHidePriority = this.getToolbarItemsByHidePriority();
        merge$1(...this.toolbarItemsByHidePriority.map((item) => item.itemAppearanceChange))
            .pipe(takeUntil(this._destroyed$), 
        // switchMap to take the last emitted value
        switchMap(() => this._ngZone.onStable.pipe(takeUntil(this._destroyed$), take(1))))
            .subscribe(() => {
            this.updateToolbarItems();
        });
        const toolbarUIChange$ = new Subject();
        this.resizeService
            .addResizeEventListener(this.toolbarContainerEl.nativeElement, toolbarUIChange$.next.bind(toolbarUIChange$));
        this.resizeService
            .addResizeEventListener(this.toolbarSectionsSeparatorEl.nativeElement, toolbarUIChange$.next.bind(toolbarUIChange$));
        toolbarUIChange$
            .pipe(throttleTime(100, asyncScheduler, { trailing: true }), map((element) => element.offsetWidth), distinctUntilChanged(), takeUntil(this._destroyed$))
            .subscribe(() => {
            this.updateToolbarItems();
            if (!this.firstRecalculationComplete) {
                this._ngZone.run(() => {
                    this.firstRecalculationComplete = true;
                    SafeCdr.markForCheck(this._cdr);
                });
            }
        });
    }
    ngOnDestroy() {
        this.resizeService.removeResizeEventListener(this.toolbarContainerEl.nativeElement);
        this.resizeService.removeResizeEventListener(this.toolbarSectionsSeparatorEl.nativeElement);
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    updateToolbarItems() {
        // Because this code can be invoked outside NgZone, use ngZone.run to be sure that changeDetection fire.
        // https://github.com/angular/angular/blob/5452889aa61a9963f443302d93d8af6c4131aa10/packages/core/src/application_ref.ts#L403
        this._ngZone.run(() => {
            this.recalculateToolbarItemsVisibility();
        });
    }
    /**
     * This method returns not the value of the search model but the value of the search input itself
     * The difference is in case when the model wasn't applied("quickFilterTriggerable"=true and button was not clicked)
     * and you need to take the value of the search and use it somewhere
     * https://github.bmc.com/bmc-ux/adapt-angular/issues/4504
     */
    getQuickFilterInputValue() {
        var _a, _b, _c;
        let value = null;
        if (this.filterInput) {
            value = this.filterInput.nativeElement.value;
        }
        else if (this.adaptRxSearchComponent) {
            value = (_c = (_b = (_a = this.adaptRxSearchComponent) === null || _a === void 0 ? void 0 : _a.inputRef) === null || _b === void 0 ? void 0 : _b.nativeElement) === null || _c === void 0 ? void 0 : _c.value;
        }
        return value;
    }
    setQuickFilterValue(value) {
        this.searchModel = value;
        this.table.setQuickFilter(value);
    }
    changeColumnVisibility(event, column) {
        column.hidden = !event;
        this.table.columnsVisibilityChange.emit([{ column, isHidden: !event }]);
    }
    isLastVisibleColumn(currentColumn) {
        const visibleColumns = this.table.getVisibleColumns();
        return visibleColumns.length === 1 && visibleColumns[0].field === currentColumn.field;
    }
    visibleColumnsFirst(a, b) {
        return toNumber$1(a.hidden) - toNumber$1(b.hidden);
    }
    getToolbarText() {
        const table = this.table;
        if (this.getCurrentRowsCount() === 0) {
            return this.texts.noRecordsText;
        }
        if (table.paginator) {
            if (table.totalRecords) {
                return this.getFromToOfText();
            }
            else {
                return this.getFromToText();
            }
        }
        else {
            if (table.enableInfiniteScrolling) {
                if (table.totalRecords && this.getCurrentRowsCount() < table.totalRecords) {
                    return this.getOutOfRowsShownText();
                }
                else {
                    return this.getCurrentRowsCountText();
                }
            }
            else {
                if (table.totalRecords) {
                    return this.getTotalCountText();
                }
                else {
                    return this.getFromToText();
                }
            }
        }
    }
    getFromToOfText() {
        return this.texts.fromToOfTextTemplate
            .replace('{fromRecords}', this.getFromRecordsCount().toString())
            .replace('{toRecords}', this.getToRecordsCountOrZero().toString())
            .replace('{totalRecords}', this.getTotalRecordsOrZero().toString());
    }
    getFromToText() {
        return this.texts.fromToTextTemplate
            .replace('{fromRecords}', this.getFromRecordsCount().toString())
            .replace('{toRecords}', this.getToRecordsCountOrZero().toString());
    }
    getOutOfRowsShownText() {
        return this.texts.outOfShownTextTemplate
            .replace('{currentRecordsCount}', this.getCurrentRowsCount().toString())
            .replace('{totalRecords}', this.getTotalRecordsOrZero().toString());
    }
    getTotalCountText() {
        const txt = this.getTotalRecords() === 1 ? this.texts.totalCountTextTemplate : this.texts.totalCountTextTemplatePlural;
        return txt.replace('{totalRecords}', this.getTotalRecordsOrZero().toString());
    }
    getCurrentRowsCountText() {
        const txt = this.getTotalRecords() === 1 ? this.texts.recordsCountShownTextTemplate : this.texts.recordsCountShownTextTemplatePlural;
        return txt.replace('{currentRecordsCount}', this.getCurrentRowsCount().toString());
    }
    checkFullSizeSearchMode(event) {
        if (this.toolbarContainerEl.nativeElement.offsetWidth <= 400) {
            this.searchFullSize = this.filterFocus || (event && event.target.classList.contains('adapt-table-search_close-btn'));
        }
        else {
            this.searchFullSize = false;
        }
    }
    getFromRecordsCount() {
        return this.table.first + 1;
    }
    getCurrentRowsCount() {
        const dt = this.table;
        return (dt.filteredValue ? dt.filteredValue : dt.value || []).length;
    }
    getToRecordsCount() {
        const dt = this.table;
        const to = Number(dt.rows) + dt.first;
        const total = dt.totalRecords == null ? dt.value.length : dt.totalRecords;
        return to > total ? total : to;
    }
    getToRecordsCountOrZero() {
        return this.getToRecordsCount() || 0;
    }
    showAllSelectedRows() {
        this.onlySelectedRowsShown = true;
        this.preservedFilteredValue = this.table.filteredValue;
        this.preservedTotalRecords = this.table.totalRecords;
        this.preservedFirst = this.table.first;
        this.updateSelectedRowsDisplaying(true);
    }
    updateSelectedRowsDisplaying(goToFirstPage) {
        const selectedRows = this.table.getRowSelectionArray();
        if (goToFirstPage) {
            this.table.first = 0;
        }
        if (this.table.paginator) {
            this.table.totalRecords = selectedRows.length;
            this.table.getTableService().onTotalRecordsChange(selectedRows.length);
        }
        this.table.filteredValue = selectedRows;
        this.table.getTableService().onValueChange(selectedRows);
    }
    showAllRows(dueToFiltersChange = false) {
        this.onlySelectedRowsShown = false;
        if (dueToFiltersChange) {
            if (this.table.lazy) {
                this.table.filteredValue = null;
                this.table.totalRecords = this.preservedTotalRecords;
                this.table.getTableService().onTotalRecordsChange(this.preservedTotalRecords);
            }
        }
        else {
            this.table.filteredValue = this.preservedFilteredValue;
            this.table.totalRecords = this.preservedTotalRecords;
            this.table.getTableService().onTotalRecordsChange(this.preservedTotalRecords);
            this.table.first = this.preservedFirst;
            this.table.firstChange.emit(this.preservedFirst);
        }
        this.table.getTableService().onValueChange(this.table.value);
        this.preservedFilteredValue = null;
        this.preservedTotalRecords = null;
        this.preservedFirst = null;
    }
    showSelectionLimitText(from) {
        return this.isRTL
            ? `${this.texts.selected} ${this.table.selectionLimit} / ${from}`
            : `${from} / ${this.table.selectionLimit} ${this.texts.selected}`;
    }
    getClassForChangeVisibilityButton(isHidden) {
        const isAllColumnsVisible = this.table.columns.length === this.table.getVisibleColumns().length;
        return (isHidden ? 'list-group-item list-group-item-action caret-right' : 'btn btn-link d-icon-right-triangle_down')
            + (isAllColumnsVisible ? ' d-icon-eye' : ' d-icon-eye_closed');
    }
    refreshButtonClick(event) {
        this.table.rowDataRefresh.emit(event);
        this.table.onTableRefresh();
    }
    popupAnimationDone(dropdown, toolbarItemType) {
        this.table.toolbarPopupAnimationDone.emit({ dropdown, focusMonitorService: this.focusMonitorService });
        if (dropdown.isOpen()) {
            this.initFocusMonitor(dropdown, toolbarItemType);
        }
    }
    anchorKeydownHandler(event, dropdown) {
        if (getEventKeyCode(event) === DOWN_ARROW && !dropdown.isOpen()) {
            event.preventDefault();
            dropdown.open(event);
        }
    }
    handleDropdownMenuKeydown(event, toolbarItemType, dropdown) {
        this.connectKeydownWithFocusMonitor(toolbarItemType, event);
        this.closeMenuOnKeydown(event, dropdown);
    }
    closeMenuOnKeydown(event, dropdown) {
        if (getEventKeyCode(event) === TAB) {
            event.preventDefault();
            dropdown.close();
        }
    }
    set shouldRestoreFocus(value) {
        this._shouldRestoreFocus = value;
    }
    get shouldRestoreFocus() {
        return this._shouldRestoreFocus;
    }
    set shouldFocusNext(value) {
        this._shouldFocusNext = value;
    }
    get shouldFocusNext() {
        return this._shouldFocusNext;
    }
    selectOption(optionToSelect) {
        if (optionToSelect.disabled) {
            return;
        }
        this.focusMonitorService.focusOnElement(this.focusMonitorService.keyManager.activeItemIndex);
    }
    isActiveDescendant(keyManagerItem) {
        return keyManagerItem === this.activeDropdownItem;
    }
    exportAs(event) {
        this.table.export.emit(event);
    }
    changeVisibility() {
        const colIndexInTable = this.table.columns.findIndex(col => col.header === this.activeDropdownItem.getLabel());
        const col = this.table.columns[colIndexInTable];
        if (!this.isLastVisibleColumn(col)) {
            col.hidden = !col.hidden;
        }
    }
    getToolbarItemsByHidePriority() {
        return this.toolbarContentItems
            .toArray()
            .sort((a, b) => a.adaptToolbarItem - b.adaptToolbarItem);
    }
    recalculateToolbarItemsVisibility(shouldUpdateItemsWidth = true) {
        this.checkFullSizeSearchMode();
        if (shouldUpdateItemsWidth) {
            this.toolbarItemsByHidePriority.forEach((item) => {
                if (!(this.openHiddenItemsMenu && item.hideToPopup)) {
                    item.recalculateWidth();
                }
            });
        }
        const itemsContainerWidth = this.toolbarContainerEl.nativeElement.offsetWidth - this.HIDDEN_ITEMS_BTN_WIDTH;
        let hasHiddenItems = false;
        let itemsWidth = this.TOOLBAR_ITEMS_HIDE_TOLERANCE;
        const fixedItems = this.toolbarItemsByHidePriority.filter((toolbarItem) => toolbarItem.fixOnToolbar);
        if (fixedItems.length) {
            fixedItems.forEach((fixedItem) => {
                itemsWidth += fixedItem.width;
            });
        }
        // Apply collapsed width
        this.toolbarItemsByHidePriority.forEach((item) => {
            if (item.removeFromToolbar) {
                item.hideToPopup = true;
            }
            else {
                if (!item.fixOnToolbar) {
                    const nextItemsWidth = itemsWidth + item.collapsedWidth;
                    if (nextItemsWidth > itemsContainerWidth) {
                        hasHiddenItems = true;
                        item.hideToPopup = true;
                    }
                    else {
                        item.hideToPopup = false;
                    }
                    itemsWidth = nextItemsWidth;
                }
            }
        });
        // Apply full width
        if (!hasHiddenItems) {
            this.toolbarItemsByHidePriority
                .slice()
                .reverse()
                .forEach((item) => {
                if (!item.fixOnToolbar) {
                    if (!item.hideToPopup) {
                        const nextItemsWidth = itemsWidth + (item.width - item.collapsedWidth);
                        item.collapse = nextItemsWidth > itemsContainerWidth;
                        itemsWidth = nextItemsWidth;
                    }
                }
            });
        }
        this.hasHiddenItems = hasHiddenItems;
        SafeCdr.markForCheck(this._cdr);
    }
    getTotalRecords() {
        return this.table.totalRecords;
    }
    getTotalRecordsOrZero() {
        return this.getTotalRecords() || 0;
    }
    initFocusMonitor(dropdown, toolbarItemType) {
        // Do not initialize focusMonitorService in case user want to use custom template
        if (toolbarItemType === ToolbarItemsByPriority.VISIBLE_COLUMNS && this.config.visibleColumnsMenuTemplate) {
            return;
        }
        this.focusMonitorService.init(this.toolbarDropdownItems);
        this.focusMonitorService.keyManager.withWrap(false);
        if (dropdown.eventInvokedFrom === 'keyboard') {
            this.focusMonitorService.focusOnFirstElement();
        }
        this.activeDropdownItem = this.focusMonitorService.keyManager.activeItem;
    }
    connectKeydownWithFocusMonitor(toolbarItemType, event) {
        // Do not initialize focusMonitorService in case user want to use custom template
        if (toolbarItemType === ToolbarItemsByPriority.VISIBLE_COLUMNS && this.config.visibleColumnsMenuTemplate) {
            return;
        }
        if (getEventKeyCode(event) === SPACE || getEventKeyCode(event) === ENTER) {
            if (toolbarItemType === ToolbarItemsByPriority.VISIBLE_COLUMNS) {
                event.preventDefault();
                this.changeVisibility();
            }
            this.selectOption(this.focusMonitorService.keyManager.activeItem);
            return;
        }
        this.focusMonitorService.onKeyDown(event);
        this.activeDropdownItem = this.focusMonitorService.keyManager.activeItem;
    }
}
AdaptTableToolbarComponent.ɵfac = function AdaptTableToolbarComponent_Factory(t) { return new (t || AdaptTableToolbarComponent)(i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(i1.AdaptFocusMonitorService), i0.ɵɵdirectiveInject(i1.ResizeService), i0.ɵɵdirectiveInject(i3.Directionality), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i4.EventManager), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptTableToolbarComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTableToolbarComponent, selectors: [["adapt-table-toolbar"]], viewQuery: function AdaptTableToolbarComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$9, 5);
        i0.ɵɵviewQuery(_c1$6, 5);
        i0.ɵɵviewQuery(_c2$5, 5);
        i0.ɵɵviewQuery(_c3$2, 5);
        i0.ɵɵviewQuery(_c4$1, 5);
        i0.ɵɵviewQuery(_c5$1, 5);
        i0.ɵɵviewQuery(AdaptTableToolbarItemDirective, 5);
        i0.ɵɵviewQuery(_c6$1, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.filterInput = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptRxSearchComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarContainerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarSectionsSeparatorEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarContentSeparatorEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarControlsEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarContentItems = _t);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.toolbarDropdownItems = _t);
    } }, inputs: { config: "config", texts: "texts" }, features: [i0.ɵɵProvidersFeature([AdaptFocusMonitorService])], decls: 116, vars: 65, consts: [[1, "adapt-table-toolbar"], ["toolbarContainerEl", ""], [1, "adapt-table-toolbar-items"], [1, "adapt-table-toolbar-item", 3, "adaptToolbarItem", "removeFromToolbar"], ["refreshSection", "adaptToolbarItem"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], ["counterSection", "adaptToolbarItem"], ["class", "adapt-table-toolbar-item", 3, "adaptToolbarItem", 4, "ngIf"], ["filterSection", "adaptToolbarItem"], ["filterResultsSection", "adaptToolbarItem"], [1, "adapt-table-toolbar-item", 3, "adaptToolbarItem", "fixOnToolbar", "removeFromToolbar"], ["leftCustomSection", "adaptToolbarItem"], [1, "flex-grow-1", "flex-shrink-1"], ["toolbarSectionsSeparatorEl", ""], ["rightCustomSection", "adaptToolbarItem"], ["exportToSomeFormat", "adaptToolbarItem"], [1, "adapt-table-toolbar-item", "adapt-table-search-toolbar-container", "justify-content-end", 3, "adaptToolbarItem", "fixOnToolbar", "removeFromToolbar"], ["searchSection", "adaptToolbarItem"], ["visibleColumnsMenuSection", "adaptToolbarItem"], [1, "adapt-table-toolbar-hidden-items-dropdown", "dropdown", "show"], ["toolbarControlsEl", ""], ["adaptDropdown", "", 1, "h-100", 3, "adaptRadarDisableEventSending", "autoClose", "appendToBody", "restoreFocusAfterClose", "focusNextElementAfterClose"], ["hiddenItemsDD", "adaptDropdown"], ["type", "button", "adaptDropdownAnchor", "", 1, "btn", "btn-link", "adapt-table-toolbar-hidden-items-dropdown-btn", 3, "tabIndex", "keydown", "click"], ["class", "d-icon-ellipsis", 4, "ngIf"], ["adaptDropdownMenuTemplate", ""], ["exportToSomeFormatTemplate", ""], ["refreshTemplate", ""], ["counterTemplate", ""], ["selectionLimitTemplate", ""], ["filterTemplate", ""], ["filterResultsTemplate", ""], ["leftCustomSectionTemplate", ""], ["rightCustomSectionTemplate", ""], ["searchTemplate", ""], ["visibleColumnsTemplate", ""], ["counterDefaultTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "adapt-table-toolbar-item", 3, "adaptToolbarItem"], ["limitSection", "adaptToolbarItem"], [1, "d-icon-ellipsis"], ["class", "dropdown-menu list-group p-0", 4, "ngIf"], [1, "dropdown-menu", "list-group", "p-0"], ["class", "list-group-item p-2", 4, "ngIf"], [4, "ngIf"], [1, "list-group-item", "p-2"], ["adaptDropdown", "", 3, "adaptRadarDisableEventSending", "autoClose", "placement", "appendToBody", "restoreFocusAfterClose", "focusNextElementAfterClose", "popupAnimationDone"], ["ddVisibleCols", "adaptDropdown"], ["type", "button", "adaptDropdownAnchor", "", 3, "ngClass", "keydown", "click"], [1, "d-icon-file_arrow_up"], ["exportTypesTemplate", ""], ["tabindex", "0", 1, "dropdown-menu", 3, "keydown"], [1, "toolbar-export-section-wrapper"], [1, "toolbar-export-menu-header"], [1, "dropdown-divider"], [1, "toolbar-export-menu-items"], [4, "ngFor", "ngForOf"], ["type", "button", "adaptListKeyManagerItem", "", 1, "toolbar-export-menu-item", "dropdown-item", 3, "keydown", "click"], ["adaptListKeyManagerItem", "adaptListKeyManagerItem"], [3, "ngClass"], ["type", "button", 1, "btn", "btn-link", 3, "ngClass", "click"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 20 20", "width", "20", "height", "20", "fill", "currentColor", 1, "infinite", "spin-360", "transition-out", "xtra-slow", "animated"], ["d", "M19.7,10l-3.3,3.9L13,10h2.5c0-3.1-2.5-5.6-5.6-5.6S4.4,6.9,4.4,10s2.5,5.6,5.6,5.6v1.7c-4,0-7.2-3.2-7.2-7.2\n\t                 S6,2.8,10,2.8S17.2,6,17.2,10H19.7z"], [1, "d-flex"], ["class", "adapt-table-toolbar__selection-counter", 4, "ngIf"], ["type", "button", "class", "btn btn-link", 3, "click", 4, "ngIf"], [1, "adapt-table-toolbar__selection-counter"], ["type", "button", 1, "btn", "btn-link", 3, "click"], [1, "adapt-table-search"], [3, "adaptRadarDisableEventSending", "ngModel", "searchButton", "size", "placeholder", "label", "ngModelChange"], ["adaptRxSearchComponent", ""], ["class", "px-1", 4, "ngIf"], [1, "px-1"], ["tabindex", "0", 1, "dropdown-menu", "visible-columns-dropdown", 3, "keydown"], ["visibleColumnsDefaultTemplate", ""], ["class", "dropdown-item  adapt-table-toolbar-dropdown-item", "adaptListKeyManagerItem", "", "tabindex", "0", 3, "label", "ui-state-disabled", "text-active", "keydown", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["adaptListKeyManagerItem", "", "tabindex", "0", 1, "dropdown-item", "adapt-table-toolbar-dropdown-item", 3, "label", "keydown"], [1, "adapt-table-toolbar__column-visibility-control", 3, "adaptRadarDisableEventSending", "label", "disabled", "ngModel", "ngModelChange"], ["role", "status", 3, "ngClass"]], template: function AdaptTableToolbarComponent_Template(rf, ctx) { if (rf & 1) {
        const _r122 = i0.ɵɵgetCurrentView();
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵelementStart(3, "div", 2);
        i0.ɵɵtext(4, "\n    ");
        i0.ɵɵelementStart(5, "div", 3, 4);
        i0.ɵɵtext(7, "\n      ");
        i0.ɵɵtemplate(8, AdaptTableToolbarComponent_ng_container_8_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(9, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n\n    ");
        i0.ɵɵelementStart(11, "div", 3, 6);
        i0.ɵɵtext(13, "\n      ");
        i0.ɵɵtemplate(14, AdaptTableToolbarComponent_ng_container_14_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(15, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n\n    ");
        i0.ɵɵtemplate(17, AdaptTableToolbarComponent_div_17_Template, 5, 3, "div", 7);
        i0.ɵɵtext(18, "\n\n    ");
        i0.ɵɵelementStart(19, "div", 3, 8);
        i0.ɵɵtext(21, "\n      ");
        i0.ɵɵtemplate(22, AdaptTableToolbarComponent_ng_container_22_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(23, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(24, "\n\n    ");
        i0.ɵɵelementStart(25, "div", 3, 9);
        i0.ɵɵtext(27, "\n      ");
        i0.ɵɵtemplate(28, AdaptTableToolbarComponent_ng_container_28_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(29, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(30, "\n\n    ");
        i0.ɵɵelementStart(31, "div", 10, 11);
        i0.ɵɵtext(33, "\n      ");
        i0.ɵɵtemplate(34, AdaptTableToolbarComponent_ng_container_34_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(35, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(36, "\n\n    ");
        i0.ɵɵelement(37, "div", 12, 13);
        i0.ɵɵtext(39, "\n\n    ");
        i0.ɵɵelementStart(40, "div", 10, 14);
        i0.ɵɵtext(42, "\n      ");
        i0.ɵɵtemplate(43, AdaptTableToolbarComponent_ng_container_43_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(44, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(45, "\n\n    ");
        i0.ɵɵelementStart(46, "div", 10, 15);
        i0.ɵɵtext(48, "\n      ");
        i0.ɵɵtemplate(49, AdaptTableToolbarComponent_ng_container_49_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(50, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(51, "\n\n    ");
        i0.ɵɵelementStart(52, "div", 16, 17);
        i0.ɵɵtext(54, "\n      ");
        i0.ɵɵtemplate(55, AdaptTableToolbarComponent_ng_container_55_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(56, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(57, "\n\n    ");
        i0.ɵɵelementStart(58, "div", 3, 18);
        i0.ɵɵtext(60, "\n      ");
        i0.ɵɵtemplate(61, AdaptTableToolbarComponent_ng_container_61_Template, 1, 4, "ng-container", 5);
        i0.ɵɵtext(62, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(63, "\n\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(64, "\n\n  ");
        i0.ɵɵelementStart(65, "div", 19, 20);
        i0.ɵɵtext(67, "\n    ");
        i0.ɵɵelementStart(68, "div", 21, 22);
        i0.ɵɵtext(70, "\n      ");
        i0.ɵɵelementStart(71, "button", 23);
        i0.ɵɵlistener("keydown", function AdaptTableToolbarComponent_Template_button_keydown_71_listener($event) { i0.ɵɵrestoreView(_r122); const _r22 = i0.ɵɵreference(69); return ctx.anchorKeydownHandler($event, _r22); })("click", function AdaptTableToolbarComponent_Template_button_click_71_listener($event) { i0.ɵɵrestoreView(_r122); const _r22 = i0.ɵɵreference(69); return _r22.toggle($event); });
        i0.ɵɵtext(72, "\n        ");
        i0.ɵɵtemplate(73, AdaptTableToolbarComponent_span_73_Template, 1, 0, "span", 24);
        i0.ɵɵtext(74, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(75, "\n      ");
        i0.ɵɵtemplate(76, AdaptTableToolbarComponent_ng_template_76_Template, 3, 1, "ng-template", 25);
        i0.ɵɵtext(77, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(78, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(79, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(80, "\n\n");
        i0.ɵɵtext(81, "\n\n");
        i0.ɵɵtemplate(82, AdaptTableToolbarComponent_ng_template_82_Template, 17, 12, "ng-template", null, 26, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(84, "\n\n");
        i0.ɵɵtemplate(85, AdaptTableToolbarComponent_ng_template_85_Template, 15, 6, "ng-template", null, 27, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(87, "\n\n");
        i0.ɵɵtemplate(88, AdaptTableToolbarComponent_ng_template_88_Template, 3, 4, "ng-template", null, 28, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(90, "\n\n");
        i0.ɵɵtemplate(91, AdaptTableToolbarComponent_ng_template_91_Template, 10, 3, "ng-template", null, 29, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(93, "\n\n");
        i0.ɵɵtemplate(94, AdaptTableToolbarComponent_ng_template_94_Template, 3, 4, "ng-template", null, 30, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(96, "\n\n");
        i0.ɵɵtemplate(97, AdaptTableToolbarComponent_ng_template_97_Template, 3, 4, "ng-template", null, 31, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(99, "\n\n");
        i0.ɵɵtemplate(100, AdaptTableToolbarComponent_ng_template_100_Template, 3, 4, "ng-template", null, 32, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(102, "\n\n");
        i0.ɵɵtemplate(103, AdaptTableToolbarComponent_ng_template_103_Template, 3, 4, "ng-template", null, 33, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(105, "\n\n");
        i0.ɵɵtemplate(106, AdaptTableToolbarComponent_ng_template_106_Template, 7, 8, "ng-template", null, 34, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(108, "\n\n");
        i0.ɵɵtemplate(109, AdaptTableToolbarComponent_ng_template_109_Template, 12, 10, "ng-template", null, 35, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(111, "\n\n");
        i0.ɵɵtext(112, "\n\n");
        i0.ɵɵtemplate(113, AdaptTableToolbarComponent_ng_template_113_Template, 4, 2, "ng-template", null, 36, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(115, "\n");
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(6);
        const _r3 = i0.ɵɵreference(12);
        const _r6 = i0.ɵɵreference(20);
        const _r8 = i0.ɵɵreference(26);
        const _r10 = i0.ɵɵreference(32);
        const _r13 = i0.ɵɵreference(41);
        const _r15 = i0.ɵɵreference(47);
        const _r17 = i0.ɵɵreference(53);
        const _r19 = i0.ɵɵreference(59);
        i0.ɵɵclassProp("adapt-table-toolbar_bordered", ctx.table.bordered)("adapt-table-toolbar_loading", !ctx.firstRecalculationComplete);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.REFRESH)("removeFromToolbar", !ctx.config.refreshButton);
        i0.ɵɵattribute("data-testid", ctx.testID + "_refresh");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r1.hideToPopup || _r1.removeFromToolbar));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.COUNTER)("removeFromToolbar", !ctx.config.counter);
        i0.ɵɵattribute("data-testid", ctx.testID + "_counter");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r3.hideToPopup || _r3.removeFromToolbar));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.table.hasSelectionLimit && ctx.config.selectionLimit);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.FILTER)("removeFromToolbar", !ctx.config.filter);
        i0.ɵɵattribute("data-testid", ctx.testID + "_filter");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r6.hideToPopup || _r6.removeFromToolbar));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.FILTER_RESULTS)("removeFromToolbar", !ctx.config.filterResults);
        i0.ɵɵattribute("data-testid", ctx.testID + "_filter_results");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r8.hideToPopup || _r8.removeFromToolbar));
        i0.ɵɵadvance(3);
        i0.ɵɵclassProp("flex-fill", ctx.config.leftCustomSectionFixed);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.LEFT_CUSTOM)("fixOnToolbar", ctx.config.leftCustomSectionFixed)("removeFromToolbar", !ctx.config.leftCustomSection);
        i0.ɵɵattribute("data-testid", ctx.testID + "_left_custom");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r10.hideToPopup || _r10.removeFromToolbar));
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.RIGHT_CUSTOM)("fixOnToolbar", ctx.config.rightCustomSectionFixed)("removeFromToolbar", !ctx.config.rightCustomSection);
        i0.ɵɵattribute("data-testid", ctx.testID + "_right_custom");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r13.hideToPopup || _r13.removeFromToolbar));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.EXPORT)("fixOnToolbar", ctx.config.export == null ? null : ctx.config.export.exportSectionFixed)("removeFromToolbar", !(ctx.config.export == null ? null : ctx.config.export.exportTypes == null ? null : ctx.config.export.exportTypes.length));
        i0.ɵɵattribute("data-testid", ctx.testID + "_export");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r15.hideToPopup || _r15.removeFromToolbar));
        i0.ɵɵadvance(3);
        i0.ɵɵclassProp("flex-fill", ctx.searchFullSize);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.SEARCH)("fixOnToolbar", true)("removeFromToolbar", !ctx.config.quickFilter);
        i0.ɵɵattribute("data-testid", ctx.testID + "_search");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r17.hideToPopup || _r17.removeFromToolbar));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("adaptToolbarItem", ctx.TOOLBAR_ITEMS_BY_PRIORITY.VISIBLE_COLUMNS)("removeFromToolbar", !ctx.config.visibleColumnsMenu);
        i0.ɵɵattribute("data-testid", ctx.testID + "_visible_columns");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(_r19.hideToPopup || _r19.removeFromToolbar));
        i0.ɵɵadvance(4);
        i0.ɵɵstyleProp("max-width", ctx.HIDDEN_ITEMS_BTN_WIDTH, "px");
        i0.ɵɵattribute("data-testid", ctx.testID + "_hidden_buttons");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("autoClose", "outside")("appendToBody", true)("restoreFocusAfterClose", ctx.shouldRestoreFocus)("focusNextElementAfterClose", ctx.shouldFocusNext);
        i0.ɵɵadvance(3);
        i0.ɵɵclassProp("p-0", !ctx.hasHiddenItems)("border-0", !ctx.hasHiddenItems)("px-2", ctx.hasHiddenItems);
        i0.ɵɵproperty("tabIndex", !ctx.hasHiddenItems ? -1 : 0);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.hasHiddenItems);
    } }, directives: [AdaptTableToolbarItemDirective, i2$1.NgIf, i1.AdaptDropdownDirective, i1.AdaptDropdownAnchorDirective, i1.AdaptDropdownMenuTemplateDirective, i2$1.NgTemplateOutlet, i2$1.NgClass, i2$1.NgForOf, i1.AdaptListKeyManagerItemDirective, i1.AdaptRxSearchComponent, i5.NgControlStatus, i5.NgModel, i1.AdaptRxCheckboxComponent], pipes: [SortByPipe], styles: [".adapt-table-toolbar[_ngcontent-%COMP%] {\n      z-index: 2;\n      overflow: hidden;\n    }\n\n    .adapt-table-toolbar-items[_ngcontent-%COMP%] {\n      flex: 1 1 auto;\n      display: flex;\n      overflow: hidden;\n      margin: 0 -3px;\n    }\n\n    .adapt-table-toolbar-hidden-items-dropdown[_ngcontent-%COMP%] {\n      flex: 0 0 auto;\n      text-align: center\n    }\n\n    .adapt-table-toolbar-hidden-items-dropdown-btn[_ngcontent-%COMP%] {\n      font-size: 16px;\n      padding: 0;\n      height: 100%;\n      width: 100%;\n    }\n\n    .adapt-table-toolbar-item[_ngcontent-%COMP%] {\n      overflow: hidden;\n      flex: 0 0 auto;\n      padding: 0 3px;\n    }\n\n    .adapt-table-toolbar-item_hidden[_ngcontent-%COMP%] {\n      position: absolute;\n      visibility: hidden;\n      opacity: 0;\n      z-index: -1;\n    }"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableToolbarComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-table-toolbar',
                templateUrl: './adapt-table-toolbar.html',
                providers: [AdaptFocusMonitorService],
                styles: [`
    .adapt-table-toolbar {
      z-index: 2;
      overflow: hidden;
    }

    .adapt-table-toolbar-items {
      flex: 1 1 auto;
      display: flex;
      overflow: hidden;
      margin: 0 -3px;
    }

    .adapt-table-toolbar-hidden-items-dropdown {
      flex: 0 0 auto;
      text-align: center
    }

    .adapt-table-toolbar-hidden-items-dropdown-btn {
      font-size: 16px;
      padding: 0;
      height: 100%;
      width: 100%;
    }

    .adapt-table-toolbar-item {
      overflow: hidden;
      flex: 0 0 auto;
      padding: 0 3px;
    }

    .adapt-table-toolbar-item_hidden {
      position: absolute;
      visibility: hidden;
      opacity: 0;
      z-index: -1;
    }
  `]
            }]
    }], function () { return [{ type: AdaptTableComponent }, { type: i1.AdaptFocusMonitorService }, { type: i1.ResizeService }, { type: i3.Directionality }, { type: i0.NgZone }, { type: i4.EventManager }, { type: i0.ChangeDetectorRef }]; }, { config: [{
            type: Input
        }], texts: [{
            type: Input
        }], filterInput: [{
            type: ViewChild,
            args: ['filterInput']
        }], adaptRxSearchComponent: [{
            type: ViewChild,
            args: ['adaptRxSearchComponent']
        }], toolbarContainerEl: [{
            type: ViewChild,
            args: ['toolbarContainerEl']
        }], toolbarSectionsSeparatorEl: [{
            type: ViewChild,
            args: ['toolbarSectionsSeparatorEl']
        }], toolbarContentSeparatorEl: [{
            type: ViewChild,
            args: ['toolbarContentSeparatorEl']
        }], toolbarControlsEl: [{
            type: ViewChild,
            args: ['toolbarControlsEl']
        }], toolbarContentItems: [{
            type: ViewChildren,
            args: [AdaptTableToolbarItemDirective]
        }], toolbarDropdownItems: [{
            type: ViewChildren,
            args: ['adaptListKeyManagerItem']
        }] }); })();

const _c0$8 = ["actionsDropdown"];
function AdaptTableActionsComponent_div_0_button_8_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const action_r3 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("ngClass", "at-action-icon " + action_r3.icon);
} }
function AdaptTableActionsComponent_div_0_button_8_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 6, 7);
    i0.ɵɵlistener("click", function AdaptTableActionsComponent_div_0_button_8_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r9); const action_r3 = restoredCtx.$implicit; const ctx_r8 = i0.ɵɵnextContext(2); return ctx_r8.onActionClick(action_r3); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵtemplate(3, AdaptTableActionsComponent_div_0_button_8_span_3_Template, 1, 1, "span", 8);
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const _r5 = i0.ɵɵreference(1);
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("text-active", ctx_r2.isActiveDescendant(_r5));
    i0.ɵɵproperty("id", ctx_r2.actionsParams.rowIndex + "_" + index_r4)("item", action_r3)("adaptListKeyManagerItemDisabled", ctx_r2.isDisabledAction(action_r3))("disabled", ctx_r2.isDisabledAction(action_r3));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", action_r3.icon);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r2.getTitle(action_r3), "\n    ");
} }
function AdaptTableActionsComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 1, 2);
    i0.ɵɵlistener("openChange", function AdaptTableActionsComponent_div_0_Template_div_openChange_0_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(); return ctx_r10.handleOpenChange($event); });
    i0.ɵɵtext(2, "\n  ");
    i0.ɵɵelementStart(3, "button", 3);
    i0.ɵɵlistener("click", function AdaptTableActionsComponent_div_0_Template_button_click_3_listener($event) { i0.ɵɵrestoreView(_r11); const _r1 = i0.ɵɵreference(1); return _r1.toggle($event); })("keydown", function AdaptTableActionsComponent_div_0_Template_button_keydown_3_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r13 = i0.ɵɵnextContext(); return ctx_r13.keydownHandler($event); });
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementStart(6, "div", 4);
    i0.ɵɵlistener("keyManagerStateChange", function AdaptTableActionsComponent_div_0_Template_div_keyManagerStateChange_6_listener($event) { i0.ɵɵrestoreView(_r11); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.keyManagerStateChange($event); });
    i0.ɵɵtext(7, "\n    ");
    i0.ɵɵtemplate(8, AdaptTableActionsComponent_div_0_button_8_Template, 5, 8, "button", 5);
    i0.ɵɵtext(9, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r1 = i0.ɵɵreference(1);
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true)("placement", ctx_r0.dropdownPlacement);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("disabled", ctx_r0.isDisabled());
    i0.ɵɵattribute("aria-expanded", _r1.isOpen())("aria-activedescendant", ctx_r0.activeActionItemId);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n    ", ctx_r0.column.actionsConfig.buttonName || ctx_r0.texts.actionButtonDefaultLabel, "");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngForOf", ctx_r0.getVisibleActions());
} }
class AdaptTableActionsComponent {
    constructor(table) {
        this.table = table;
        this.dropdownPlacement = ['bottom-right', 'top-right', 'auto'];
        this._listKeyManagerDestroy = new Subject();
    }
    get actionsParams() {
        return {
            column: this.column,
            rowIndex: this.rowIndex,
            dataItem: this.dataItem,
            expanded: this.expanded,
            editing: this.editing,
        };
    }
    ngOnDestroy() {
        this._listKeyManagerDestroy.next();
    }
    onActionClick(action) {
        action === null || action === void 0 ? void 0 : action.action(this.actionsParams);
    }
    isHidden() {
        return getValueOrFunc(this.column.actionsConfig.hidden, this.actionsParams);
    }
    isDisabled() {
        return getValueOrFunc(this.column.actionsConfig.disabled, this.actionsParams) ||
            this.getVisibleActions().every(a => this.isDisabledAction(a));
    }
    isDisabledAction(action) {
        return getValueOrFunc(action.disabled, this.actionsParams);
    }
    getTitle(action) {
        return getValueOrFunc(action.title, this.actionsParams);
    }
    getVisibleActions() {
        const params = this.actionsParams;
        return this.column.actionsConfig.actions.filter(a => !getValueOrFunc(a.hidden, params));
    }
    keyManagerStateChange(listKeyManager) {
        this._listKeyManager = listKeyManager;
        if (this._listKeyManager) {
            this._listKeyManager.change
                .pipe(takeUntil(this._listKeyManagerDestroy))
                .subscribe(() => {
                this.activeActionItemId = this._listKeyManager.activeItem;
            });
            this._listKeyManager.tabOut
                .pipe(takeUntil(this._listKeyManagerDestroy))
                .subscribe(() => {
                this.actionsDropdown.close();
            });
        }
        else {
            this._listKeyManagerDestroy.next();
            this.activeActionItemId = null;
        }
    }
    keydownHandler(event) {
        var _a;
        if (!this.actionsDropdown.isOpen() && getEventKeyCode(event) === DOWN_ARROW) {
            event.preventDefault();
            this.actionsDropdown.open();
            return;
        }
        if (this._listKeyManager) {
            this._listKeyManager.onKeydown(event);
            if (getEventKeyCode(event) === ENTER && this.actionsDropdown.isOpen()) {
                this.onActionClick((_a = this._listKeyManager.activeItem) === null || _a === void 0 ? void 0 : _a.item);
            }
        }
    }
    handleOpenChange(isOpen) {
        if (isOpen) {
            this._listKeyManager.setFirstItemActive();
        }
    }
    isActiveDescendant(keyManagerItem) {
        return keyManagerItem === this.activeActionItemId;
    }
}
AdaptTableActionsComponent.ɵfac = function AdaptTableActionsComponent_Factory(t) { return new (t || AdaptTableActionsComponent)(i0.ɵɵdirectiveInject(AdaptTableComponent)); };
AdaptTableActionsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTableActionsComponent, selectors: [["adapt-table-actions"]], viewQuery: function AdaptTableActionsComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$8, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.actionsDropdown = _t.first);
    } }, inputs: { column: "column", rowIndex: "rowIndex", dataItem: "dataItem", expanded: "expanded", editing: "editing", texts: "texts" }, decls: 2, vars: 1, consts: [["class", "dropdown", "adaptDropdown", "", 3, "adaptRadarDisableEventSending", "appendToBody", "placement", "openChange", 4, "ngIf"], ["adaptDropdown", "", 1, "dropdown", 3, "adaptRadarDisableEventSending", "appendToBody", "placement", "openChange"], ["actionsDropdown", ""], ["id", "dropdownMenu", "type", "button", "adaptDropdownAnchor", "", 1, "btn", "btn-secondary", "btn-xs", "at-action-dropdown-toggle", "dropdown-toggle", 3, "disabled", "click", "keydown"], ["aria-labelledby", "dropdownMenu", "adaptDropdownMenu", "", "adaptListKeyManager", "", 1, "dropdown-menu", 3, "keyManagerStateChange"], ["class", "dropdown-item", "type", "button", "tabindex", "-1", "adaptListKeyManagerItem", "", 3, "id", "item", "adaptListKeyManagerItemDisabled", "text-active", "disabled", "click", 4, "ngFor", "ngForOf"], ["type", "button", "tabindex", "-1", "adaptListKeyManagerItem", "", 1, "dropdown-item", 3, "id", "item", "adaptListKeyManagerItemDisabled", "disabled", "click"], ["adaptListKeyManagerItem", "adaptListKeyManagerItem"], [3, "ngClass", 4, "ngIf"], [3, "ngClass"]], template: function AdaptTableActionsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptTableActionsComponent_div_0_Template, 11, 8, "div", 0);
        i0.ɵɵtext(1, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", !ctx.isHidden());
    } }, directives: [i2$1.NgIf, i1.AdaptDropdownDirective, i1.AdaptDropdownAnchorDirective, i1.AdaptDropdownMenuDirective, i1.AdaptListKeyManagerDirective, i2$1.NgForOf, i1.AdaptListKeyManagerItemDirective, i2$1.NgClass], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableActionsComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-table-actions',
                templateUrl: './adapt-table-actions.html',
            }]
    }], function () { return [{ type: AdaptTableComponent }]; }, { column: [{
            type: Input
        }], rowIndex: [{
            type: Input
        }], dataItem: [{
            type: Input
        }], expanded: [{
            type: Input
        }], editing: [{
            type: Input
        }], texts: [{
            type: Input
        }], actionsDropdown: [{
            type: ViewChild,
            args: ['actionsDropdown', { static: false }]
        }] }); })();

const _c0$7 = ["headerRowsSelectionDropdownRef"];
const _c1$5 = ["headerRowsSelectionDropdownAnchorRef"];
const _c2$4 = ["headerRowsSelectionDropdownMenu"];
function AdaptHeaderSelectionCheckboxComponent_ng_container_15_adapt_rx_checkbox_2_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-rx-checkbox", 10, 11);
    i0.ɵɵlistener("ngModelChange", function AdaptHeaderSelectionCheckboxComponent_ng_container_15_adapt_rx_checkbox_2_Template_adapt_rx_checkbox_ngModelChange_0_listener() { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(2); return ctx_r8.onSelectAllRowsOnPage(); });
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r7 = i0.ɵɵreference(1);
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("text-active", _r7 === ctx_r5.activeItem);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("item", ctx_r5.checkboxToggleSource.SelectOnPage)("label", ctx_r5.getSelectAllItemsOnPageHeaderLabel())("indeterminate", ctx_r5.isIndeterminateState())("ngModel", ctx_r5.isCheckedState());
} }
function AdaptHeaderSelectionCheckboxComponent_ng_container_15_adapt_rx_checkbox_4_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-rx-checkbox", 10, 11);
    i0.ɵɵlistener("ngModelChange", function AdaptHeaderSelectionCheckboxComponent_ng_container_15_adapt_rx_checkbox_4_Template_adapt_rx_checkbox_ngModelChange_0_listener() { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(2); return ctx_r11.onSelectAllRowsInTable(); });
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r10 = i0.ɵɵreference(1);
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("text-active", _r10 === ctx_r6.activeItem);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("item", ctx_r6.checkboxToggleSource.SelectAll)("label", ctx_r6.getSelectAllItemsInTableHeaderLabel())("indeterminate", ctx_r6.isIndeterminateState())("ngModel", ctx_r6.isCheckedState());
} }
function AdaptHeaderSelectionCheckboxComponent_ng_container_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptHeaderSelectionCheckboxComponent_ng_container_15_adapt_rx_checkbox_2_Template, 3, 7, "adapt-rx-checkbox", 9);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵtemplate(4, AdaptHeaderSelectionCheckboxComponent_ng_container_15_adapt_rx_checkbox_4_Template, 3, 7, "adapt-rx-checkbox", 9);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.isChunkSelectionAvailable());
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r3.isAllSelectionAvailable());
} }
function AdaptHeaderSelectionCheckboxComponent_adapt_rx_checkbox_17_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-rx-checkbox", 10, 11);
    i0.ɵɵlistener("ngModelChange", function AdaptHeaderSelectionCheckboxComponent_adapt_rx_checkbox_17_Template_adapt_rx_checkbox_ngModelChange_0_listener() { i0.ɵɵrestoreView(_r15); const ctx_r14 = i0.ɵɵnextContext(); return ctx_r14.onDeselectAllRowsInTable(); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r13 = i0.ɵɵreference(1);
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("text-active", _r13 === ctx_r4.activeItem);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("item", ctx_r4.checkboxToggleSource.DeselectAll)("label", ctx_r4.getDeselectAllItemsHeaderLabel())("indeterminate", ctx_r4.isIndeterminateState())("ngModel", ctx_r4.canDeselectRows());
} }
class AdaptHeaderSelectionCheckboxComponent {
    constructor(table, _focusMonitor, _ngZone, _cdr, _overlayService, _adaptDeviceDetectionService) {
        this.table = table;
        this._focusMonitor = _focusMonitor;
        this._ngZone = _ngZone;
        this._cdr = _cdr;
        this._overlayService = _overlayService;
        this._adaptDeviceDetectionService = _adaptDeviceDetectionService;
        this.headerCheckboxToggle = new EventEmitter();
        this._listKeyManagerDestroy = new Subject();
        this._destroyed$ = new ReplaySubject(1);
    }
    get totalRecords() {
        /**
         * When there is no totalRecords info available(means that for some reasons customer doesn't know how many records are in the table)
         * we assume that totalRecords are at least on one record more than loaded records length until customer can set correct totalRecords value.
         *
         * This allows correctly calculate visibility of items in selection menu
         */
        if (!this.table.isTotalRecordsInfoAvailable() && this.table.value) {
            return this.table.value.length + 1;
        }
        return this.table.totalRecords;
    }
    /**
     * If totalRecords was set as null we assume that all other selection related inputs(eg. selectedFilteredRowsCount)
     * was also set as null so can't be used in calculations.
     * But when totalRecords are equal to value length it means that we can use totalRecords in calculations but not selection related inputs(eg. selectedFilteredRowsCount)
     */
    get isAllSelectionInfoAvailable() {
        return this.table.lazy
            && this.table.isTotalRecordsInfoAvailable()
            && isNumber(this.table.disabledSelectedRowsCount)
            && isNumber(this.table.disabledNotSelectedRowsCount)
            && isNumber(this.table.disabledSelectedFilteredRowsCount)
            && isNumber(this.table.disabledNotSelectedFilteredRowsCount)
            && isNumber(this.table.selectedFilteredRowsCount)
            && isNumber(this.table.totalRecordsInGroup);
    }
    ngOnInit() {
        this.checkboxToggleSource = AdaptTableHeaderCheckboxToggleSource;
    }
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            fromEvent(this.headerRowsSelectionDropdownAnchorRef.nativeElement, 'mouseover')
                .pipe(debounceTime(50), takeUntil(this._destroyed$))
                .subscribe((event) => {
                this.showHeaderRowsSelectionDD(event);
            });
            fromEvent(this.headerRowsSelectionDropdownMenu.nativeElement, 'mouseleave')
                .pipe(takeUntil(this._destroyed$))
                .subscribe(() => {
                this.hideHeaderRowsSelectionDD();
            });
        });
    }
    ngOnDestroy() {
        this._listKeyManagerDestroy.next();
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    keyManagerStateChange(listKeyManager) {
        this._listKeyManager = listKeyManager;
        if (this._listKeyManager) {
            this._listKeyManager.change
                .pipe(takeUntil(this._listKeyManagerDestroy))
                .subscribe(() => {
                this._ngZone.onStable.asObservable()
                    .pipe(distinctUntilChanged(), takeUntil(this._destroyed$))
                    .subscribe(() => {
                    this.setActiveItem(this._listKeyManager.activeItem);
                    SafeCdr.markForCheck(this._cdr);
                });
            });
            this._listKeyManager.tabOut
                .pipe(takeUntil(this._listKeyManagerDestroy))
                .subscribe(() => {
                this.hideHeaderRowsSelectionDD();
            });
        }
        else {
            this._listKeyManagerDestroy.next();
            this.setActiveItem(null);
        }
    }
    onPopupAnimationDone(event) {
        if ((event === null || event === void 0 ? void 0 : event.eventInvokedFrom) === 'keyboard') {
            if (this.headerRowsSelectionDropdownRef.isOpen()) {
                this._ngZone.onStable.asObservable()
                    .pipe(take(1), takeUntil(this._destroyed$))
                    .subscribe(() => {
                    this._listKeyManager.setFirstItemActive();
                    this.setActiveItem(this._listKeyManager.activeItem);
                    SafeCdr.detectChanges(this._cdr);
                });
            }
            else {
                this._listKeyManager.setActiveItem(null);
                this.setActiveItem(null);
            }
        }
    }
    onHeaderRowsSelectionMenuOpen(event) {
        var _a;
        // Prevent default behaviour to not toggle header checkbox on mobile on tap(click) event
        if (this._adaptDeviceDetectionService.isMobile()) {
            event.preventDefault();
        }
        const keyCode = getEventKeyCode(event);
        if (keyCode === ENTER || keyCode === SPACE) {
            this.headerRowsSelectionDropdownRef.open(event);
        }
        if (this._listKeyManager) {
            this._listKeyManager.onKeydown(event);
            if (keyCode === ENTER || keyCode === SPACE && this.headerRowsSelectionDropdownRef.isOpen()) {
                switch ((_a = this._listKeyManager.activeItem) === null || _a === void 0 ? void 0 : _a.item) {
                    case AdaptTableHeaderCheckboxToggleSource.DeselectAll: {
                        this.onDeselectAllRowsInTable(true);
                        break;
                    }
                    case AdaptTableHeaderCheckboxToggleSource.SelectOnPage: {
                        this.onSelectAllRowsOnPage(true);
                        break;
                    }
                    case AdaptTableHeaderCheckboxToggleSource.SelectAll: {
                        this.onSelectAllRowsInTable(true);
                        break;
                    }
                }
            }
        }
    }
    onDeselectAllRowsInTable(selectFromKeyboard = false) {
        this._toggleRowSelection(false, this.table.getAllCurrentRows(), AdaptTableHeaderCheckboxToggleSource.DeselectAll, selectFromKeyboard);
        if (this.table.isMobile) {
            this.hideHeaderRowsSelectionDD();
        }
    }
    onSelectAllRowsOnPage(selectFromKeyboard = false) {
        this._toggleRowSelection(true, this.table.getCurrentPageDisplayingRowsItems(), AdaptTableHeaderCheckboxToggleSource.SelectOnPage, selectFromKeyboard);
        if (this.table.isMobile) {
            this.hideHeaderRowsSelectionDD();
        }
    }
    onSelectAllRowsInTable(selectFromKeyboard = false) {
        this._toggleRowSelection(true, this.table.getAllCurrentRows(), AdaptTableHeaderCheckboxToggleSource.SelectAll, selectFromKeyboard);
        if (this.table.isMobile) {
            this.hideHeaderRowsSelectionDD();
        }
    }
    showHeaderRowsSelectionDD(event) {
        if (!this.hasAllItemsDisabledForSelection()) {
            this._ngZone.run(() => {
                this.headerRowsSelectionDropdownRef.open(event);
                if (!this._overlayService.enableCDKOverlayControl) {
                    SafeCdr.markForCheck(this._cdr);
                }
            });
        }
    }
    hideHeaderRowsSelectionDD() {
        this._ngZone.run(() => {
            this.headerRowsSelectionDropdownRef.close();
        });
    }
    getSelectAllItemsOnPageHeaderLabel() {
        const isTableHasDisabledRecords = this._checkOnDisabledRecords();
        const isTableInFilteringState = this.table.hasFilter();
        if (this.table.lazy && this.table.enableInfiniteScrolling) {
            if (isTableInFilteringState && isTableHasDisabledRecords) {
                return this.texts.selectAllPossibleFilteredVisibleItemsHeaderLabel;
            }
            if (isTableInFilteringState && !isTableHasDisabledRecords) {
                return this.texts.selectAllFilteredVisibleItemsHeaderLabel;
            }
            if (!isTableInFilteringState && isTableHasDisabledRecords) {
                return this.texts.selectAllPossibleVisibleItemsHeaderLabel;
            }
            return this.texts.selectAllVisibleItemsHeaderLabel;
        }
        if (isTableInFilteringState && isTableHasDisabledRecords) {
            return this.texts.selectAllPossibleFilteredItemsOnPageHeaderLabel;
        }
        if (isTableInFilteringState && !isTableHasDisabledRecords) {
            return this.texts.selectAllFilteredItemsOnPageHeaderLabel;
        }
        if (!isTableInFilteringState && isTableHasDisabledRecords) {
            return this.texts.selectAllPossibleItemsOnPageHeaderLabel;
        }
        return this.texts.selectAllItemsOnPageHeaderLabel;
    }
    getSelectAllItemsInTableHeaderLabel() {
        const isTableHasDisabledRecords = this._checkOnDisabledRecords();
        const isTableInFilteringState = this.table.hasFilter();
        if (isTableInFilteringState && isTableHasDisabledRecords) {
            return this.texts.selectAllPossibleFilteredItemsInTableHeaderLabel;
        }
        if (!isTableInFilteringState && isTableHasDisabledRecords) {
            return this.texts.selectAllPossibleItemsInTableHeaderLabel;
        }
        if (isTableInFilteringState && !isTableHasDisabledRecords) {
            return this.texts.selectAllFilteredItemsInTableHeaderLabel;
        }
        return this.table.isTotalRecordsInfoAvailable()
            ? formatString(this.texts.selectAllItemsInTableHeaderLabel, this.table.totalRecords)
            : this.texts.selectAllItemsInTableHeaderLabelForUnknownTotalRecords;
    }
    getDeselectAllItemsHeaderLabel() {
        const isTableHasDisabledRecords = this._checkOnDisabledRecords();
        const isTableInFilteringState = this.table.hasFilter();
        if (isTableInFilteringState && isTableHasDisabledRecords) {
            return this.texts.deselectAllPossibleFilteredItemsInTableHeaderLabel;
        }
        if (!isTableInFilteringState && isTableHasDisabledRecords) {
            return this.texts.deselectAllPossibleItemsInTableHeaderLabel;
        }
        if (isTableInFilteringState && !isTableHasDisabledRecords) {
            return this.texts.deselectAllFilteredItemsInTableHeaderLabel;
        }
        return this.texts.deselectAllItemsInTableHeaderLabel;
    }
    isIndeterminateState() {
        if (this.table.hasAtLeastOneRowGroupedData()) {
            return this._getGroupSelectionState(this.table.getRowSelectionArray()) === CheckboxState.Indeterminate;
        }
        return this.isAtLeastOneRowSelected() && !this.isCheckedState();
    }
    isCheckedState() {
        if (this.table.hasAtLeastOneRowGroupedData()) {
            return this._getGroupSelectionState(this.table.getRowSelectionArray()) === CheckboxState.Selected;
        }
        const selectedRowsLength = this.table.getRowSelectionArray().length;
        if (selectedRowsLength === 0) {
            return false;
        }
        return this.table.isTotalRecordsInfoAvailable()
            ? selectedRowsLength === this.table.allTotalRecords
            : this._filterSelectedRows(this.table.getAllCurrentRows()).length === this.table.getAllCurrentRows().length + 1;
    }
    isAtLeastOneRowSelected() {
        return this.table.getRowSelectionArray().length > 0;
    }
    canDeselectRows() {
        if (this.isAllSelectionInfoAvailable) {
            return this.table.hasFilter()
                ? this.table.selectedFilteredRowsCount - this.table.disabledSelectedFilteredRowsCount > 0
                : this.table.getRowSelectionArray().length - this.table.disabledSelectedRowsCount > 0;
        }
        if (this.table.hasFilter()) {
            const selectedFilteredRows = this._filterSelectedRows(this.table.getAllCurrentRows());
            return selectedFilteredRows.length - this._getDisabledSelectedRows(selectedFilteredRows).length > 0;
        }
        return this._getDisabledSelectedRows(this.table.getAllCurrentRows()).length !== this.table.getRowSelectionArray().length;
    }
    showSelectionItems() {
        var _a;
        const selectionArray = this.table.getRowSelectionArray();
        const disabledNotSelectedRowsCount = (_a = this.table.disabledNotSelectedRowsCount) !== null && _a !== void 0 ? _a : this._getDisabledNotSelectedRows(this.table.getAllCurrentRows()).length;
        if (this.table.hasAtLeastOneRowGroupedData()) {
            const allRows = this.table.getRowsItems(this.table.getAllCurrentRows());
            const totalRecordsInGroup = this.isAllSelectionInfoAvailable ? this.table.totalRecordsInGroup : allRows.length;
            if (this.table.hasFilter()) {
                return this.isAllSelectionInfoAvailable
                    ? this.table.totalRecordsInGroup !== this.table.selectedFilteredRowsCount + this.table.disabledNotSelectedFilteredRowsCount
                    : this._filterSelectedRows(allRows).length + disabledNotSelectedRowsCount !== allRows.length;
            }
            return totalRecordsInGroup !== selectionArray.length + disabledNotSelectedRowsCount;
        }
        if (this.table.hasFilter()) {
            return this.isAllSelectionInfoAvailable
                ? this.totalRecords !== this.table.selectedFilteredRowsCount + this.table.disabledNotSelectedFilteredRowsCount
                : this._filterSelectedRows(this.table.getAllCurrentRows()).length + disabledNotSelectedRowsCount !== this.table.getAllCurrentRows().length;
        }
        // Because we can't differentiate is user select all rows on page or in table without totalRecords info
        // we hide both selection items if all loaded rows was selected
        return this.table.isTotalRecordsInfoAvailable()
            ? this.table.allTotalRecords !== selectionArray.length + disabledNotSelectedRowsCount
            : this._filterSelectedRows(this.table.getAllCurrentRows()).length + disabledNotSelectedRowsCount !== this.table.getAllCurrentRows().length;
    }
    isChunkSelectionAvailable() {
        const allSelectableRowsOnPageLength = this._getAllSelectableRowsOnPage().length;
        switch (this.table.headerSelectionMode) {
            case AdaptTableHeaderSelectionMode.All: {
                return false;
            }
            case AdaptTableHeaderSelectionMode.Chunk: {
                return this._getCurrentPageSelectedRows().length !== allSelectableRowsOnPageLength;
            }
            case AdaptTableHeaderSelectionMode.Both: {
                return this.table.rows < this.totalRecords
                    && this._getCurrentPageSelectedRows().length !== allSelectableRowsOnPageLength
                    && (this.table.enableInfiniteScrolling
                        ? this.table.getAllCurrentRows().filter(row => !isNil(row)).length !== this.totalRecords
                        : allSelectableRowsOnPageLength !== this.totalRecords);
            }
        }
    }
    isAllSelectionAvailable() {
        return this.table.headerSelectionMode === AdaptTableHeaderSelectionMode.All
            || this.table.headerSelectionMode === AdaptTableHeaderSelectionMode.Both;
    }
    hasAllItemsDisabledForSelection() {
        return this.table.disableRowSelection
            || (this.isAllSelectionInfoAvailable
                ? this.totalRecords - (this.table.hasFilter() ? this.table.disabledNotSelectedFilteredRowsCount + this.table.disabledSelectedFilteredRowsCount : this.table.disabledNotSelectedRowsCount + this.table.disabledSelectedRowsCount) === 0
                : !this._getAllSelectableRowsInTable().length);
    }
    setActiveItem(keyManagerItem) {
        this.activeItem = keyManagerItem;
    }
    _getAllSelectableRowsInTable() {
        return this.table.getSelectableRowsItems(this.table.getAllCurrentRows()).filter(row => !isNil(row));
    }
    _getAllSelectableRowsOnPage() {
        return this.table.getSelectableRowsItems(this.table.getCurrentPageDisplayingRowsItems()).filter(row => !isNil(row));
    }
    _getCurrentPageSelectedRows() {
        return this._filterSelectedRows(this._getAllSelectableRowsOnPage());
    }
    _getDisabledSelectedRows(rows) {
        const result = [];
        this.table.goRecursivelyByItemsInGroups(rows, (row) => {
            if (this.table.isRowSelectionDisabled(row) && this.table.isRowSelected(row)) {
                result.push(row);
            }
        });
        return result;
    }
    _getDisabledNotSelectedRows(rows) {
        const result = [];
        this.table.goRecursivelyByItemsInGroups(rows, (row) => {
            // Remove items that disabled but already selected
            if (this.table.isRowSelectionDisabled(row) && !this.table.isRowSelected(row)) {
                result.push(row);
            }
        });
        return result;
    }
    _checkOnDisabledRecords() {
        return this.isAllSelectionInfoAvailable
            ? this.table.disabledNotSelectedRowsCount > 0 || this.table.disabledSelectedRowsCount > 0
            : this.table.getAllCurrentRows().some(this.table.isRowSelectionDisabled.bind(this.table));
    }
    _toggleRowSelection(checked, rowsToToggle, eventSource, selectFromKeyboard) {
        this.table.onToogleGroupedRowsSelection(checked, rowsToToggle);
        this.table.handleHeaderCheckboxToggle({
            originalEvent: window.event,
            checked,
            eventSource,
            filters: this.table.filters,
            globalFilter: this.table.filters && this.table.filters.global ? this.table.filters.global.value : null,
        });
        if (selectFromKeyboard) {
            this._ngZone.onStable.asObservable()
                .pipe(take(1), takeUntil(this._destroyed$))
                .subscribe(() => {
                this._listKeyManager.setFirstItemActive();
            });
        }
    }
    _filterSelectedRows(rows) {
        // Check selected rows by "dataKey" because selected row can have custom properties.
        // https://github.bmc.com/bmc-ux/adapt-angular/issues/7497
        return rows.filter(row => this.table.isRowSelected(row));
    }
    _getGroupSelectionState(selection) {
        let dataItemsCount = 0;
        if (selection && !selection.length) {
            return CheckboxState.Unselected;
        }
        if (this.table.lazy && this.table.paginator) {
            let selectedItemsCountInCurrentPage = 0;
            this.table.goRecursivelyByItemsInAllGroups(row => {
                dataItemsCount++;
                if (this.table.isRowSelected(row)) {
                    selectedItemsCountInCurrentPage++;
                }
            });
            if (dataItemsCount === 0 || selectedItemsCountInCurrentPage === 0) {
                return CheckboxState.Unselected;
            }
            return dataItemsCount === selectedItemsCountInCurrentPage ? CheckboxState.Selected : CheckboxState.Indeterminate;
        }
        this.table.goRecursivelyByItemsInAllGroups(() => {
            dataItemsCount++;
        });
        if (dataItemsCount === 0) {
            return CheckboxState.Unselected;
        }
        selection = selection || this.table.getRowSelectionArray();
        return selection.length === dataItemsCount ? CheckboxState.Selected : CheckboxState.Indeterminate;
    }
}
AdaptHeaderSelectionCheckboxComponent.ɵfac = function AdaptHeaderSelectionCheckboxComponent_Factory(t) { return new (t || AdaptHeaderSelectionCheckboxComponent)(i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(i2$2.FocusMonitor), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptOverlayService), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService)); };
AdaptHeaderSelectionCheckboxComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptHeaderSelectionCheckboxComponent, selectors: [["adapt-header-selection-checkbox"]], viewQuery: function AdaptHeaderSelectionCheckboxComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$7, 5);
        i0.ɵɵviewQuery(_c1$5, 5);
        i0.ɵɵviewQuery(_c2$4, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerRowsSelectionDropdownRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerRowsSelectionDropdownAnchorRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerRowsSelectionDropdownMenu = _t.first);
    } }, inputs: { texts: "texts" }, outputs: { headerCheckboxToggle: "headerCheckboxToggle" }, decls: 22, vars: 11, consts: [["adaptDropdown", "", 1, "at-header-selection", 3, "adaptRadarDisableEventSending", "autoClose", "appendToBody", "customClass", "popupAnimationDone"], ["headerRowsSelectionDropdownRef", ""], ["adaptDropdownAnchor", "", "tabIndex", "-1"], ["headerRowsSelectionDropdownAnchorRef", ""], [1, "checkbox-inline", "at-group-selection-checkbox", 3, "ngModel", "adaptRadarDisableEventSending", "indeterminate", "disabled", "ariaLabel", "keydown", "click"], ["adaptListKeyManager", "", "adaptDropdownMenu", "", 1, "dropdown-menu", "at-header-selection__dropdown-menu", 3, "keyManagerStateChange"], ["headerRowsSelectionDropdownMenu", ""], [1, "at-header-selection__dropdown-list"], [4, "ngIf"], ["class", "at-header-selection__dropdown-checkbox", "tabIndex", "-1", "adaptListKeyManagerItem", "", 3, "adaptRadarDisableEventSending", "item", "text-active", "label", "indeterminate", "ngModel", "ngModelChange", 4, "ngIf"], ["tabIndex", "-1", "adaptListKeyManagerItem", "", 1, "at-header-selection__dropdown-checkbox", 3, "adaptRadarDisableEventSending", "item", "label", "indeterminate", "ngModel", "ngModelChange"], ["adaptListKeyManagerItem", "adaptListKeyManagerItem"]], template: function AdaptHeaderSelectionCheckboxComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵlistener("popupAnimationDone", function AdaptHeaderSelectionCheckboxComponent_Template_div_popupAnimationDone_0_listener($event) { return ctx.onPopupAnimationDone($event); });
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵelementStart(3, "div", 2, 3);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementStart(6, "adapt-rx-checkbox", 4);
        i0.ɵɵlistener("keydown", function AdaptHeaderSelectionCheckboxComponent_Template_adapt_rx_checkbox_keydown_6_listener($event) { return ctx.onHeaderRowsSelectionMenuOpen($event); })("click", function AdaptHeaderSelectionCheckboxComponent_Template_adapt_rx_checkbox_click_6_listener($event) { return $event.preventDefault(); });
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(9, "\n  ");
        i0.ɵɵelementStart(10, "div", 5, 6);
        i0.ɵɵlistener("keyManagerStateChange", function AdaptHeaderSelectionCheckboxComponent_Template_div_keyManagerStateChange_10_listener($event) { return ctx.keyManagerStateChange($event); });
        i0.ɵɵtext(12, "\n    ");
        i0.ɵɵelementStart(13, "div", 7);
        i0.ɵɵtext(14, "\n      ");
        i0.ɵɵtemplate(15, AdaptHeaderSelectionCheckboxComponent_ng_container_15_Template, 6, 2, "ng-container", 8);
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵtemplate(17, AdaptHeaderSelectionCheckboxComponent_adapt_rx_checkbox_17_Template, 3, 7, "adapt-rx-checkbox", 9);
        i0.ɵɵtext(18, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(19, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(21, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("autoClose", "outside")("appendToBody", true)("customClass", ctx.table.isMobile ? "at-header-selection__dropdown at-header-selection__dropdown_mobile" : "at-header-selection__dropdown");
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngModel", ctx.isCheckedState())("adaptRadarDisableEventSending", true)("indeterminate", ctx.isIndeterminateState())("disabled", ctx.hasAllItemsDisabledForSelection())("ariaLabel", ctx.texts.headerSelectRowsArialLabel);
        i0.ɵɵadvance(9);
        i0.ɵɵproperty("ngIf", ctx.showSelectionItems());
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.canDeselectRows());
    } }, directives: [i1.AdaptDropdownDirective, i1.AdaptDropdownAnchorDirective, i1.AdaptRxCheckboxComponent, i5.NgControlStatus, i5.NgModel, i1.AdaptListKeyManagerDirective, i1.AdaptDropdownMenuDirective, i2$1.NgIf, i1.AdaptListKeyManagerItemDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptHeaderSelectionCheckboxComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-header-selection-checkbox',
                templateUrl: './header-selection-checkbox.html',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.Default
            }]
    }], function () { return [{ type: AdaptTableComponent }, { type: i2$2.FocusMonitor }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptOverlayService }, { type: i1.AdaptDeviceDetectionService }]; }, { texts: [{
            type: Input
        }], headerCheckboxToggle: [{
            type: Output
        }], headerRowsSelectionDropdownRef: [{
            type: ViewChild,
            args: ['headerRowsSelectionDropdownRef']
        }], headerRowsSelectionDropdownAnchorRef: [{
            type: ViewChild,
            args: ['headerRowsSelectionDropdownAnchorRef']
        }], headerRowsSelectionDropdownMenu: [{
            type: ViewChild,
            args: ['headerRowsSelectionDropdownMenu']
        }] }); })();

// eslint-disable-next-line @angular-eslint/directive-class-suffix
class EditableRow {
    constructor(el) {
        this.el = el;
    }
    isEnabled() {
        return this.pEditableRowDisabled !== true;
    }
}
EditableRow.ɵfac = function EditableRow_Factory(t) { return new (t || EditableRow)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
EditableRow.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: EditableRow, selectors: [["", "pEditableRow", ""]], inputs: { data: ["pEditableRow", "data"], pEditableRowDisabled: "pEditableRowDisabled" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(EditableRow, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[pEditableRow]'
            }]
    }], function () { return [{ type: i0.ElementRef }]; }, { data: [{
            type: Input,
            args: ['pEditableRow']
        }], pEditableRowDisabled: [{
            type: Input
        }] }); })();

// eslint-disable-next-line @angular-eslint/directive-class-suffix
class ReorderableColumn {
    constructor(dt, el, zone) {
        this.dt = dt;
        this.el = el;
        this.zone = zone;
    }
    ngAfterViewInit() {
        if (this.isEnabled()) {
            this.bindEvents();
        }
    }
    bindEvents() {
        this.zone.runOutsideAngular(() => {
            this.mouseDownListener = this.onMouseDown.bind(this);
            this.el.nativeElement.addEventListener('mousedown', this.mouseDownListener);
            this.dragStartListener = this.onDragStart.bind(this);
            this.el.nativeElement.addEventListener('dragstart', this.dragStartListener);
            this.dragOverListener = this.onDragEnter.bind(this);
            this.el.nativeElement.addEventListener('dragover', this.dragOverListener);
            this.dragEnterListener = this.onDragEnter.bind(this);
            this.el.nativeElement.addEventListener('dragenter', this.dragEnterListener);
            this.dragLeaveListener = this.onDragLeave.bind(this);
            this.el.nativeElement.addEventListener('dragleave', this.dragLeaveListener);
        });
    }
    unbindEvents() {
        if (this.mouseDownListener) {
            document.removeEventListener('mousedown', this.mouseDownListener);
            this.mouseDownListener = null;
        }
        if (this.dragOverListener) {
            document.removeEventListener('dragover', this.dragOverListener);
            this.dragOverListener = null;
        }
        if (this.dragEnterListener) {
            document.removeEventListener('dragenter', this.dragEnterListener);
            this.dragEnterListener = null;
        }
        if (this.dragEnterListener) {
            document.removeEventListener('dragenter', this.dragEnterListener);
            this.dragEnterListener = null;
        }
        if (this.dragLeaveListener) {
            document.removeEventListener('dragleave', this.dragLeaveListener);
            this.dragLeaveListener = null;
        }
    }
    onMouseDown(event) {
        if (event.target.nodeName === 'INPUT'
            || event.target.nodeName === 'TEXTAREA'
            || DomHandler.hasClass(event.target, 'ui-column-resizer')) {
            this.el.nativeElement.draggable = false;
        }
        else {
            this.el.nativeElement.draggable = true;
        }
    }
    onDragStart(event) {
        this.dt.onColumnDragStart(event, this.el.nativeElement);
    }
    onDragOver(event) {
        event.preventDefault();
    }
    onDragEnter(event) {
        this.onColumnDragEnter(event, this.el.nativeElement);
    }
    onDragLeave(event) {
        this.dt.onColumnDragLeave(event);
    }
    onDrop(event) {
        if (this.isEnabled()) {
            this.dt.onColumnDrop(event, this.el.nativeElement);
        }
    }
    onColumnDragEnter(event, dropHeader) {
        if (!isFunction(this.dt.allowColumnReorderingResolver)) {
            this.dt.onColumnDragEnter(event, dropHeader);
        }
        else {
            const draggedHeaderColumn = this.dt.dataHeaderCells.find(headerCell => headerCell.element.nativeElement === this.dt.draggedColumn);
            const droppedHeaderColumn = this.dt.dataHeaderCells.find(headerCell => headerCell.element.nativeElement === dropHeader);
            const allowColumnsReordering = draggedHeaderColumn && droppedHeaderColumn
                && this.dt.allowColumnReorderingResolver(draggedHeaderColumn, droppedHeaderColumn);
            if (allowColumnsReordering) {
                this.dt.onColumnDragEnter(event, dropHeader);
            }
            else {
                event.dataTransfer.dropEffect = 'none';
            }
        }
    }
    isEnabled() {
        return this.pReorderableColumnDisabled !== true;
    }
    ngOnDestroy() {
        this.unbindEvents();
    }
}
ReorderableColumn.ɵfac = function ReorderableColumn_Factory(t) { return new (t || ReorderableColumn)(i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone)); };
ReorderableColumn.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ReorderableColumn, selectors: [["", "pReorderableColumn", ""]], hostBindings: function ReorderableColumn_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("drop", function ReorderableColumn_drop_HostBindingHandler($event) { return ctx.onDrop($event); });
    } }, inputs: { pReorderableColumnDisabled: "pReorderableColumnDisabled" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ReorderableColumn, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[pReorderableColumn]'
            }]
    }], function () { return [{ type: AdaptTableComponent }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, { pReorderableColumnDisabled: [{
            type: Input
        }], onDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }] }); })();

function calculateScrollbarWidth(el, recalculateScrollBarWidth) {
    if (el) {
        const style = getComputedStyle(el);
        return (el.offsetWidth - el.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth));
    }
    else {
        // need to get an access to the private property 'calculatedScrollbarWidth'
        const domHandler = DomHandler;
        if ((domHandler['calculatedScrollbarWidth']) !== null && !recalculateScrollBarWidth) {
            return domHandler['calculatedScrollbarWidth'];
        }
        const scrollDiv = document.createElement('div');
        const scrollContent = document.createElement('div');
        scrollDiv.style.width = '100px';
        scrollDiv.style.height = '100px';
        scrollDiv.style.overflow = 'scroll';
        scrollDiv.style.position = 'absolute';
        scrollDiv.style.visibility = 'hidden';
        document.body.appendChild(scrollDiv);
        scrollDiv.appendChild(scrollContent);
        const scrollBarContainerPosition = scrollDiv.getBoundingClientRect();
        const scrollBarContentPosition = scrollContent.getBoundingClientRect();
        const scrollbarWidth = scrollBarContainerPosition.width - scrollBarContentPosition.width;
        domHandler['calculatedScrollbarWidth'] = scrollbarWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
    }
}

// eslint-disable-next-line @angular-eslint/directive-class-suffix
class ResizableColumn {
    constructor(dt, el, zone, _renderer) {
        this.dt = dt;
        this.el = el;
        this.zone = zone;
        this._renderer = _renderer;
        this.columnResized = new EventEmitter();
        this._minColResizeWidth = 15; // in pixels
    }
    ngAfterViewInit() {
        if (this.isEnabled()) {
            DomHandler.addClass(this.el.nativeElement, 'ui-resizable-column');
            this.resizer = document.createElement('span');
            this.resizer.className = 'ui-column-resizer ui-clickable';
            this.el.nativeElement.appendChild(this.resizer);
            this.zone.runOutsideAngular(() => {
                this.resizerMouseDownListener = this.onMouseDown.bind(this);
                this.resizer.addEventListener('mousedown', this.resizerMouseDownListener);
            });
        }
    }
    bindDocumentEvents() {
        this.zone.runOutsideAngular(() => {
            this.documentMouseMoveListener = this.onDocumentMouseMove.bind(this);
            document.addEventListener('mousemove', this.documentMouseMoveListener);
            this.documentMouseUpListener = this.onDocumentMouseUp.bind(this);
            document.addEventListener('mouseup', this.documentMouseUpListener);
        });
    }
    unbindDocumentEvents() {
        if (this.documentMouseMoveListener) {
            document.removeEventListener('mousemove', this.documentMouseMoveListener);
            this.documentMouseMoveListener = null;
        }
        if (this.documentMouseUpListener) {
            document.removeEventListener('mouseup', this.documentMouseUpListener);
            this.documentMouseUpListener = null;
        }
    }
    onMouseDown(event) {
        if (event.which === 1) {
            this.dt.onColumnResizeBegin(event);
            this.bindDocumentEvents();
        }
    }
    onDocumentMouseMove(event) {
        this.dt.onColumnResize(event);
    }
    onDocumentMouseUp(event) {
        this.onColumnResizeEnd(event, this.el.nativeElement);
        this.unbindDocumentEvents();
    }
    isEnabled() {
        return this.pResizableColumnDisabled !== true;
    }
    ngOnDestroy() {
        if (this.resizerMouseDownListener) {
            this.resizer.removeEventListener('mousedown', this.resizerMouseDownListener);
        }
        this.unbindDocumentEvents();
    }
    onColumnResizeEnd(event, column) {
        if (this.dt.columnResizeMode === ResizeMode.Fit) {
            this._handleFitModeResize(event, column);
        }
        else if (this.dt.columnResizeMode === ResizeMode.Expand) {
            this._handleExpandModeResize(event, column);
        }
        this.dt.resizeHelperViewChild.nativeElement.style.display = 'none';
        DomHandler.removeClass(this.dt.containerViewChild.nativeElement, 'ui-unselectable-text');
    }
    _checkIfOverlapLeftSibling(event, column) {
        const containerLeft = DomHandler.getOffset(this.dt.containerViewChild.nativeElement).left;
        return this.dt.isRtl
            ? event.pageX - containerLeft < column.nextElementSibling.offsetLeft
            : event.pageX - containerLeft < column.offsetLeft;
    }
    _checkIfOverlapRightSibling(event, column) {
        const containerLeft = DomHandler.getOffset(this.dt.containerViewChild.nativeElement).left;
        return this.dt.isRtl
            ? event.pageX - containerLeft > column.offsetLeft + column.offsetWidth
            : event.pageX - containerLeft > column.offsetLeft
                + column.offsetWidth + column.nextElementSibling.offsetWidth;
    }
    _handleExpandModeResize(event, column) {
        const delta = this._getColumnResizeDelta(event, column);
        const columnWidth = column.offsetWidth;
        const newColumnWidth = columnWidth + delta;
        // Logic copied from PrimeNG. Changed the way how delta calculating
        if (this.dt.scrollable) {
            this._setScrollableItemsWidthOnExpandResize(column, newColumnWidth, delta);
        }
        else {
            this.dt.tableViewChild.nativeElement.style.width =
                this.dt.tableViewChild.nativeElement.offsetWidth + delta + 'px';
            column.style.width = newColumnWidth + 'px';
            const containerWidth = this.dt.tableViewChild.nativeElement.style.width;
            this.dt.containerViewChild.nativeElement.style.width = containerWidth + 'px';
        }
        this._emitOnColResize(column, delta);
    }
    _setScrollableItemsWidthOnExpandResize(column, newColumnWidth, delta) {
        const scrollableView = column ? this.dt.findParentScrollableView(column) : this.dt.containerViewChild.nativeElement;
        const scrollableBody = DomHandler.findSingle(scrollableView, this.dt.virtualScroll ? `.${AdaptTableClasses.TableVirtualScrollableBody}` : `.${AdaptTableClasses.TableScrollableBody}`);
        const scrollableHeader = DomHandler.findSingle(scrollableView, `.${AdaptTableClasses.TableScrollableHeader}`);
        const scrollableFooter = DomHandler.findSingle(scrollableView, `.${AdaptTableClasses.TableScrollableFooter}`);
        const scrollableBodyTable = DomHandler.findSingle(scrollableBody, `table.${AdaptTableClasses.TableScrollableBodyTable}`);
        const scrollableHeaderTable = DomHandler.findSingle(scrollableHeader, `table.${AdaptTableClasses.TableScrollableHeaderTable}`);
        const scrollableFooterTable = DomHandler.findSingle(scrollableFooter, `table.${AdaptTableClasses.TableScrollableFooterTable}`);
        const scrollableBodyTableWidth = column ? scrollableBodyTable.offsetWidth + delta : newColumnWidth;
        const scrollableHeaderTableWidth = column ? scrollableHeaderTable.offsetWidth + delta : newColumnWidth;
        const isContainerInViewport = this.dt.containerViewChild.nativeElement.offsetWidth >= scrollableBodyTableWidth;
        const setWidth = (container, table, width, isContainerInViewport) => {
            if (container && table) {
                container.style.width = isContainerInViewport ? width + calculateScrollbarWidth(scrollableBody) + 'px' : 'auto';
                table.style.width = width + 'px';
            }
        };
        setWidth(scrollableBody, scrollableBodyTable, scrollableBodyTableWidth, isContainerInViewport);
        setWidth(scrollableHeader, scrollableHeaderTable, scrollableHeaderTableWidth, isContainerInViewport);
        setWidth(scrollableFooter, scrollableFooterTable, scrollableHeaderTableWidth, isContainerInViewport);
        if (column) {
            const resizeColumnIndex = DomHandler.index(column);
            this._resizeColGroup(scrollableHeaderTable, resizeColumnIndex, newColumnWidth, null);
            this._resizeColGroup(scrollableBodyTable, resizeColumnIndex, newColumnWidth, null);
            this._resizeColGroup(scrollableFooterTable, resizeColumnIndex, newColumnWidth, null);
        }
    }
    _resizeColGroup(table, resizeColumnIndex, newColumnWidth, nextColumnWidth) {
        if (table) {
            const colGroup = table.children[0].nodeName === 'COLGROUP' ? table.children[0] : null;
            if (colGroup) {
                const col = colGroup.children[resizeColumnIndex];
                const nextCol = col.nextElementSibling;
                this._renderer.setStyle(col, 'width', newColumnWidth + 'px');
                this._renderer.setAttribute(col, 'data-resized-width', newColumnWidth + 'px');
                if (nextCol && nextColumnWidth) {
                    this._renderer.setStyle(nextCol, 'width', nextColumnWidth + 'px');
                    this._renderer.setAttribute(nextCol, 'data-resized-width', nextColumnWidth + 'px');
                }
            }
            else {
                throw new Error('Scrollable tables require a colgroup to support resizable columns');
            }
        }
    }
    _getColumnSiblingsWidths(column, resizeDirection) {
        let columnSibling = resizeDirection === ResizeDirection.Left
            ? column.previousElementSibling
            : column.nextElementSibling;
        const allPrevColumnSiblings = [columnSibling];
        function getSibling(columnRef) {
            return resizeDirection === ResizeDirection.Left
                ? columnRef.previousElementSibling
                : columnRef.nextElementSibling;
        }
        while (columnSibling && getSibling(columnSibling)) {
            allPrevColumnSiblings.push(getSibling(columnSibling));
            columnSibling = getSibling(columnSibling);
        }
        const allResizablePrevColumnSiblings = allPrevColumnSiblings.filter(col => col && col.classList.contains('ui-resizable-column'));
        return allResizablePrevColumnSiblings.map((item) => item && item.offsetWidth);
    }
    _getColumnResizeDelta(event, column) {
        const containerLeft = DomHandler.getOffset(this.dt.containerViewChild.nativeElement).left;
        return this.dt.isRtl
            ? containerLeft + column.offsetLeft - event.pageX
            : event.pageX - (containerLeft + column.offsetLeft + column.offsetWidth);
    }
    _handleFitModeResize(event, column) {
        const isLeftSiblingOverlap = this._checkIfOverlapLeftSibling(event, column);
        const isRightSiblingOverlap = this._checkIfOverlapRightSibling(event, column);
        if (!isLeftSiblingOverlap && !isRightSiblingOverlap) {
            this._noSiblingOverlapResize(event, column);
        }
        else if (isLeftSiblingOverlap) {
            if (this.dt.isRtl) {
                this._handleRightSiblingOverlapResize(event, column);
            }
            else {
                this._handleLeftSiblingOverlapResize(event, column);
            }
        }
        else if (isRightSiblingOverlap) {
            if (this.dt.isRtl) {
                this._handleLeftSiblingOverlapResize(event, column);
            }
            else {
                this._handleRightSiblingOverlapResize(event, column);
            }
        }
    }
    // Logic copied from PrimeNG. Changed the way how delta calculating
    _noSiblingOverlapResize(event, column) {
        const resizeColumnIndex = DomHandler.index(column);
        let nextColumn = column.nextElementSibling;
        while (!nextColumn.offsetParent) {
            nextColumn = nextColumn.nextElementSibling;
        }
        if (nextColumn) {
            const delta = this._getColumnResizeDelta(event, column);
            const nextColumnWidth = nextColumn.offsetWidth - delta;
            const columnWidth = column.offsetWidth;
            const newColumnWidth = columnWidth + delta;
            if (this.dt.scrollable) {
                const scrollableView = this.dt.findParentScrollableView(column);
                const scrollableBodyTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableBodyTable}`);
                const scrollableHeaderTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableHeaderTable}`);
                const scrollableFooterTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableFooterTable}`);
                this._resizeColGroup(scrollableHeaderTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
                this._resizeColGroup(scrollableBodyTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
                this._resizeColGroup(scrollableFooterTable, resizeColumnIndex, newColumnWidth, nextColumnWidth);
            }
            else {
                this._resizeColGroup(this.dt.tableViewChild.nativeElement, resizeColumnIndex, newColumnWidth, nextColumnWidth);
            }
            this._emitOnColResize(column, delta);
        }
    }
    _handleLeftSiblingOverlapResize(event, column) {
        const delta = Math.abs(this._getColumnResizeDelta(event, column));
        // Pass resizeColumnIndex + 1 to include current column in columns which be resized
        const resizeColumnIndex = DomHandler.index(column) + 1;
        const columnSiblingsWidths = [column.offsetWidth, ...this._getColumnSiblingsWidths(column, ResizeDirection.Left)];
        const newColumnWidth = column.nextElementSibling.offsetWidth + delta;
        this._resizeTableSections(column, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, ResizeDirection.Left);
        // Pass column.nextElementSibling because we resize not current column but it next sibling
        this._emitOnColResize(column.nextElementSibling, delta);
    }
    _handleRightSiblingOverlapResize(event, column) {
        const delta = Math.abs(this._getColumnResizeDelta(event, column));
        const resizeColumnIndex = DomHandler.index(column);
        const columnSiblingsWidths = this._getColumnSiblingsWidths(column, ResizeDirection.Right);
        const newColumnWidth = column.offsetWidth + delta;
        this._resizeTableSections(column, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, ResizeDirection.Right);
        this._emitOnColResize(column, delta);
    }
    _resizeTableSections(column, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection) {
        if (this.dt.scrollable) {
            const scrollableView = this.dt.findParentScrollableView(column);
            const scrollableBodyTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableBodyTable}`);
            const scrollableHeaderTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableHeaderTable}`);
            const scrollableFooterTable = DomHandler.findSingle(scrollableView, `table.${AdaptTableClasses.TableScrollableFooterTable}`);
            this._resizeColGroupForSiblings(scrollableHeaderTable, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection);
            this._resizeColGroupForSiblings(scrollableBodyTable, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection);
            this._resizeColGroupForSiblings(scrollableFooterTable, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection);
        }
        else {
            this._resizeColGroupForSiblings(this.dt.tableViewChild.nativeElement, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection);
        }
    }
    _resizeColGroupForSiblings(table, newColumnWidth, delta, resizeColumnIndex, columnSiblingsWidths, resizeDirection) {
        if (table) {
            const colGroup = table.children[0].nodeName === 'COLGROUP' ? table.children[0] : null;
            if (colGroup) {
                const col = colGroup.children[resizeColumnIndex];
                let siblingCol = resizeDirection === ResizeDirection.Left
                    ? col.previousElementSibling
                    : col.nextElementSibling;
                const colWidthsData = this._recalculateColumnSiblingsWidths(delta, columnSiblingsWidths);
                const colWidths = colWidthsData.newWidths;
                const newWidth = newColumnWidth - colWidthsData.leftOver;
                const widthValue = (newWidth > this._minColResizeWidth ? newWidth : this._minColResizeWidth) + 'px';
                this._renderer.setStyle(col, 'width', widthValue);
                this._renderer.setAttribute(col, 'data-resized-width', widthValue);
                if (colWidths && colWidths.length) {
                    colWidths.forEach((width) => {
                        if (siblingCol) {
                            this._renderer.setStyle(siblingCol, 'width', (width > this._minColResizeWidth ? width : this._minColResizeWidth) + 'px');
                            this._renderer.setAttribute(siblingCol, 'data-resized-width', (width > this._minColResizeWidth ? width : this._minColResizeWidth) + 'px');
                            siblingCol = resizeDirection === ResizeDirection.Left
                                ? siblingCol.previousElementSibling
                                : siblingCol.nextElementSibling;
                        }
                    });
                }
            }
            else {
                adaptError('Scrollable tables require a colgroup to support resizable columns');
            }
        }
    }
    _recalculateColumnSiblingsWidths(delta, columnSiblingsWidths) {
        let leftOver = 0;
        const widthsSum = columnSiblingsWidths.reduce((prev, next) => prev + next, 0);
        const newWidths = columnSiblingsWidths.map(width => {
            const widthInPercents = width * 100 / widthsSum;
            const partFromDelta = delta * widthInPercents / 100;
            const newWidth = width - partFromDelta;
            if (newWidth > this._minColResizeWidth) {
                return newWidth;
            }
            else {
                leftOver += partFromDelta;
                return width;
            }
        });
        return { leftOver, newWidths };
    }
    _emitOnColResize(column, delta) {
        const widthMap = this.dt.dataHeaderCells.map(cell => {
            return {
                fields: cell.data.renderingColumn.columnsConfigs.map(col => col.field),
                width: round((cell.element.nativeElement.offsetWidth / this.dt.tableInnerContainer.nativeElement.offsetWidth) * 100, 2)
            };
        });
        this.columnResized.emit({
            element: column,
            delta: delta,
            columnsConfigState: widthMap
        });
    }
}
ResizableColumn.ɵfac = function ResizableColumn_Factory(t) { return new (t || ResizableColumn)(i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2)); };
ResizableColumn.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ResizableColumn, selectors: [["", "pResizableColumn", ""]], inputs: { pResizableColumnDisabled: "pResizableColumnDisabled" }, outputs: { columnResized: "columnResized" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ResizableColumn, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[pResizableColumn]'
            }]
    }], function () { return [{ type: AdaptTableComponent }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }]; }, { pResizableColumnDisabled: [{
            type: Input
        }], columnResized: [{
            type: Output
        }] }); })();

// eslint-disable-next-line @angular-eslint/directive-class-suffix
class RowToggler {
    constructor(dt) {
        this.dt = dt;
    }
    onClick(event) {
        if (this.isEnabled()) {
            this.dt.toggleRow(this.data, event);
            event.preventDefault();
        }
    }
    isEnabled() {
        return this.pRowTogglerDisabled !== true;
    }
}
RowToggler.ɵfac = function RowToggler_Factory(t) { return new (t || RowToggler)(i0.ɵɵdirectiveInject(AdaptTableComponent)); };
RowToggler.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: RowToggler, selectors: [["", "pRowToggler", ""]], hostBindings: function RowToggler_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("click", function RowToggler_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, inputs: { data: ["pRowToggler", "data"], pRowTogglerDisabled: "pRowTogglerDisabled" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(RowToggler, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[pRowToggler]'
            }]
    }], function () { return [{ type: AdaptTableComponent }]; }, { data: [{
            type: Input,
            args: ['pRowToggler']
        }], pRowTogglerDisabled: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

const _c0$6 = ["scrollHeader"];
const _c1$4 = ["scrollHeaderBox"];
const _c2$3 = ["scrollBody"];
const _c3$1 = ["scrollTable"];
const _c4 = ["scrollFooter"];
const _c5 = ["scrollFooterBox"];
const _c6 = ["scrollableAligner"];
const _c7 = ["pScrollableView", ""];
function ScrollableView_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ScrollableView_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ScrollableView_ng_template_18_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
const _c8 = function (a0, a1, a2) { return { $implicit: a0, rowIndex: a1, columns: a2 }; };
function ScrollableView_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n            ");
    i0.ɵɵtemplate(1, ScrollableView_ng_template_18_ng_container_1_Template, 1, 0, "ng-container", 5);
    i0.ɵɵtext(2, "\n          ");
} if (rf & 2) {
    const rowData_r12 = ctx.$implicit;
    const rowIndex_r13 = ctx.index;
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r4.dt.frozenRowsTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction3(2, _c8, rowData_r12, rowIndex_r13, ctx_r4.columns));
} }
function ScrollableView_ng_container_24_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ScrollableView_ng_container_24_div_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 21, 22);
} }
function ScrollableView_ng_container_24_adapt_table_infinite_scrolling_loader_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-table-infinite-scrolling-loader", 23);
} if (rf & 2) {
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("infiniteScrollLoading", ctx_r19.dt.loadingMore);
} }
const _c9 = function (a0) { return { "height": a0 }; };
const _c10 = function (a0) { return { $implicit: a0 }; };
function ScrollableView_ng_container_24_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "div", 15, 16);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementStart(5, "table", 4, 17);
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵtemplate(8, ScrollableView_ng_container_24_ng_container_8_Template, 1, 0, "ng-container", 5);
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelement(10, "tbody", 18);
    i0.ɵɵtext(11, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n        ");
    i0.ɵɵtemplate(13, ScrollableView_ng_container_24_div_13_Template, 2, 0, "div", 19);
    i0.ɵɵtext(14, "\n        ");
    i0.ɵɵtemplate(15, ScrollableView_ng_container_24_adapt_table_infinite_scrolling_loader_15_Template, 1, 1, "adapt-table-infinite-scrolling-loader", 20);
    i0.ɵɵtext(16, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassMap(ctx_r5.tableClasses.TableScrollableBody);
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(14, _c9, ctx_r5.dt.scrollHeight !== "flex" ? ctx_r5.scrollHeight : undefined));
    i0.ɵɵadvance(3);
    i0.ɵɵclassMap(ctx_r5.tableClasses.TableScrollableBodyTable);
    i0.ɵɵproperty("ngClass", ctx_r5.dt.tableStyleClass)("ngStyle", ctx_r5.dt.tableStyle);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r5.frozen ? ctx_r5.dt.frozenColGroupTemplate || ctx_r5.dt.colGroupTemplate : ctx_r5.dt.colGroupTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(16, _c10, ctx_r5.columns));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("pTableBody", ctx_r5.columns)("pTableBodyTemplate", ctx_r5.frozen ? ctx_r5.dt.frozenBodyTemplate || ctx_r5.dt.bodyTemplate : ctx_r5.dt.bodyTemplate)("frozen", ctx_r5.frozen);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r5.frozen);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.canShowInfiniteScrollingLoader());
} }
function ScrollableView_ng_template_26_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ScrollableView_ng_template_26_div_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 21, 22);
} }
function ScrollableView_ng_template_26_adapt_table_infinite_scrolling_loader_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-table-infinite-scrolling-loader", 23);
} if (rf & 2) {
    const ctx_r24 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("infiniteScrollLoading", ctx_r24.dt.loadingMore);
} }
const _c11 = function (a0) { return { "ui-table-virtual-scrollable-body_empty": a0 }; };
function ScrollableView_ng_template_26_Template(rf, ctx) { if (rf & 1) {
    const _r27 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "cdk-virtual-scroll-viewport", 24);
    i0.ɵɵlistener("scrolledIndexChange", function ScrollableView_ng_template_26_Template_cdk_virtual_scroll_viewport_scrolledIndexChange_1_listener($event) { i0.ɵɵrestoreView(_r27); const ctx_r26 = i0.ɵɵnextContext(); return ctx_r26.onScrollIndexChange($event); });
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "table", 4, 17);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵtemplate(6, ScrollableView_ng_template_26_ng_container_6_Template, 1, 0, "ng-container", 5);
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelement(8, "tbody", 18);
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n        ");
    i0.ɵɵtemplate(11, ScrollableView_ng_template_26_div_11_Template, 2, 0, "div", 19);
    i0.ɵɵtext(12, "\n        ");
    i0.ɵɵtemplate(13, ScrollableView_ng_template_26_adapt_table_infinite_scrolling_loader_13_Template, 1, 1, "adapt-table-infinite-scrolling-loader", 20);
    i0.ɵɵtext(14, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n    ");
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵclassMap(ctx_r7.tableClasses.TableVirtualScrollableBody);
    i0.ɵɵstyleProp("height", ctx_r7.dt.scrollHeight !== "flex" ? ctx_r7.scrollHeight : undefined);
    i0.ɵɵproperty("itemSize", ctx_r7.dt.virtualRowHeight)("minBufferPx", ctx_r7.dt.minBufferPx)("maxBufferPx", ctx_r7.dt.maxBufferPx)("ngClass", i0.ɵɵpureFunction1(19, _c11, ctx_r7.dt.isEmpty()));
    i0.ɵɵadvance(2);
    i0.ɵɵclassMap(ctx_r7.tableClasses.TableScrollableBodyTable);
    i0.ɵɵproperty("ngClass", ctx_r7.dt.tableStyleClass)("ngStyle", ctx_r7.dt.tableStyle);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r7.frozen ? ctx_r7.dt.frozenColGroupTemplate || ctx_r7.dt.colGroupTemplate : ctx_r7.dt.colGroupTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(21, _c10, ctx_r7.columns));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("pTableBody", ctx_r7.columns)("pTableBodyTemplate", ctx_r7.frozen ? ctx_r7.dt.frozenBodyTemplate || ctx_r7.dt.bodyTemplate : ctx_r7.dt.bodyTemplate)("frozen", ctx_r7.frozen);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r7.frozen);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r7.canShowInfiniteScrollingLoader());
} }
function ScrollableView_ng_container_37_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function ScrollableView_ng_container_41_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
// eslint-disable-next-line @angular-eslint/component-class-suffix
class ScrollableView {
    constructor(dt, el, zone, _eventManager) {
        this.dt = dt;
        this.el = el;
        this.zone = zone;
        this._eventManager = _eventManager;
        this.tableClasses = AdaptTableClasses;
        this._visualViewportResizeListenerBind = this._visualViewportResizeListener.bind(this);
        this.subscription = this.dt.tableService.valueSource$.subscribe(() => {
            this.zone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.alignScrollBar();
                }, 50);
            });
        });
        this.initialized = false;
    }
    get scrollHeight() {
        return this._scrollHeight;
    }
    set scrollHeight(val) {
        this._scrollHeight = val;
    }
    ngAfterViewChecked() {
        if (!this.initialized && this.el.nativeElement.offsetParent) {
            this.alignScrollBar();
            this.initialized = true;
        }
    }
    ngAfterViewInit() {
        this.dt.scrollableView = this;
        if (!this.frozen) {
            if (this.dt.frozenColumns || this.dt.frozenBodyTemplate) {
                DomHandler.addClass(this.el.nativeElement, 'ui-table-unfrozen-view');
            }
            const frozenView = this.el.nativeElement.previousElementSibling;
            if (frozenView) {
                if (this.dt.virtualScroll) {
                    this.frozenSiblingBody = DomHandler.findSingle(frozenView, `.${AdaptTableClasses.TableVirtualScrollableBody}`);
                }
                else {
                    this.frozenSiblingBody = DomHandler.findSingle(frozenView, `.${AdaptTableClasses.TableScrollableBody}`);
                }
            }
        }
        else {
            if (this.scrollableAlignerViewChild && this.scrollableAlignerViewChild.nativeElement) {
                this.scrollableAlignerViewChild.nativeElement.style.height = DomHandler.calculateScrollbarHeight() + 'px';
            }
        }
        this.bindEvents();
        this.alignScrollBar();
        this._subscribeOnVisualViewportResize();
    }
    canShowInfiniteScrollingLoader() {
        const table = this.dt;
        const value = table.value;
        return table.enableInfiniteScrolling && table.showLoader && value != null && value.length !== 0 &&
            !table.hasReachedTotalRecords();
    }
    bindEvents() {
        this.zone.runOutsideAngular(() => {
            if (this.scrollHeaderViewChild && this.scrollHeaderViewChild.nativeElement) {
                this.headerScrollListener = this.onHeaderScroll.bind(this);
                this.scrollHeaderViewChild.nativeElement.addEventListener('scroll', this.headerScrollListener);
            }
            if (this.scrollFooterViewChild && this.scrollFooterViewChild.nativeElement) {
                this.footerScrollListener = this.onFooterScroll.bind(this);
                this.scrollFooterViewChild.nativeElement.addEventListener('scroll', this.footerScrollListener);
            }
            if (!this.frozen) {
                this.bodyScrollListener = this.onBodyScroll.bind(this);
                if (this.dt.virtualScroll) {
                    this.virtualScrollBody.getElementRef().nativeElement.addEventListener('scroll', this.bodyScrollListener);
                }
                else {
                    this.scrollBodyViewChild.nativeElement.addEventListener('scroll', this.bodyScrollListener);
                }
            }
        });
    }
    unbindEvents() {
        if (this.scrollHeaderViewChild && this.scrollHeaderViewChild.nativeElement) {
            this.scrollHeaderViewChild.nativeElement.removeEventListener('scroll', this.headerScrollListener);
        }
        if (this.scrollFooterViewChild && this.scrollFooterViewChild.nativeElement) {
            this.scrollFooterViewChild.nativeElement.removeEventListener('scroll', this.footerScrollListener);
        }
        if (this.scrollBodyViewChild && this.scrollBodyViewChild.nativeElement) {
            this.scrollBodyViewChild.nativeElement.removeEventListener('scroll', this.bodyScrollListener);
        }
        if (this.virtualScrollBody && this.virtualScrollBody.getElementRef()) {
            this.virtualScrollBody.getElementRef().nativeElement.removeEventListener('scroll', this.bodyScrollListener);
        }
    }
    onHeaderScroll() {
        const scrollLeft = this.scrollHeaderViewChild.nativeElement.scrollLeft;
        this.scrollBodyViewChild.nativeElement.scrollLeft = scrollLeft;
        if (this.scrollFooterViewChild && this.scrollFooterViewChild.nativeElement) {
            this.scrollFooterViewChild.nativeElement.scrollLeft = scrollLeft;
        }
        this.preventBodyScrollPropagation = true;
    }
    onFooterScroll() {
        const scrollLeft = this.scrollFooterViewChild.nativeElement.scrollLeft;
        this.scrollBodyViewChild.nativeElement.scrollLeft = scrollLeft;
        if (this.scrollHeaderViewChild && this.scrollHeaderViewChild.nativeElement) {
            this.scrollHeaderViewChild.nativeElement.scrollLeft = scrollLeft;
        }
        this.preventBodyScrollPropagation = true;
    }
    onBodyScroll(event) {
        if (this.preventBodyScrollPropagation) {
            this.preventBodyScrollPropagation = false;
            return;
        }
        if (this.scrollHeaderViewChild && this.scrollHeaderViewChild.nativeElement) {
            if (this.dt.isRtl) {
                this.scrollHeaderBoxViewChild.nativeElement.style.marginRight = event.target.scrollLeft + 'px';
            }
            else {
                this.scrollHeaderBoxViewChild.nativeElement.style.marginLeft = -event.target.scrollLeft + 'px';
            }
        }
        if (this.scrollFooterViewChild && this.scrollFooterViewChild.nativeElement) {
            this.scrollFooterBoxViewChild.nativeElement.style.marginLeft = -event.target.scrollLeft + 'px';
        }
        if (this.frozenSiblingBody) {
            this.frozenSiblingBody.scrollTop = event.target.scrollTop;
        }
    }
    // Override
    hasVerticalOverflow() {
        const scrollTablePositionHeight = this.scrollTableViewChild.nativeElement.getBoundingClientRect().height;
        const scrollBodyPositionHeight = this.dt.virtualScroll
            ? this.virtualScrollBody.getViewportSize()
            : this.scrollBodyViewChild.nativeElement.getBoundingClientRect().height;
        return scrollTablePositionHeight > scrollBodyPositionHeight;
    }
    alignScrollBar(recalculateScrollBarWidth) {
        if (!this.frozen) {
            const scrollBarWidth = this.hasVerticalOverflow() ? calculateScrollbarWidth(null, recalculateScrollBarWidth) : 0;
            if (this.dt.isRtl) {
                this.scrollHeaderBoxViewChild.nativeElement.style.marginLeft = scrollBarWidth + 'px';
            }
            else {
                this.scrollHeaderBoxViewChild.nativeElement.style.marginRight = scrollBarWidth + 'px';
            }
            if (this.scrollFooterBoxViewChild && this.scrollFooterBoxViewChild.nativeElement) {
                this.scrollFooterBoxViewChild.nativeElement.style.marginRight = scrollBarWidth + 'px';
            }
        }
        this.initialized = false;
    }
    ngOnDestroy() {
        this.unbindEvents();
        this.frozenSiblingBody = null;
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (window.visualViewport) {
            window.visualViewport.removeEventListener('resize', this._visualViewportResizeListenerBind);
        }
        this.initialized = false;
    }
    getPageCount() {
        const dataToRender = this.dt.filteredValue || this.dt.value;
        const dataLength = dataToRender ? dataToRender.length : 0;
        return Math.ceil(dataLength / this.dt.rows);
    }
    onScrollIndexChange(index) {
        // In case we don't want to emit onLazyLoad event on init
        if (!this.dt.lazyLoadOnInit && index === 0) {
            return;
        }
        if (this.dt.lazy) {
            if (this.virtualScrollTimeout) {
                clearTimeout(this.virtualScrollTimeout);
            }
            this.virtualScrollTimeout = window.setTimeout(() => {
                const page = Math.floor(index / this.dt.rows);
                const virtualScrollOffset = page === 0 ? 0 : (page - 1) * this.dt.rows;
                const virtualScrollChunkSize = page === 0 ? this.dt.rows * 2 : this.dt.rows * 3;
                if (page !== this.virtualPage) {
                    this.virtualPage = page;
                    this.dt.onLazyLoad.emit({
                        eventSource: AdaptTableEventSource.LoadMore,
                        first: virtualScrollOffset,
                        rows: virtualScrollChunkSize,
                        sortField: this.dt.sortField,
                        sortOrder: this.dt.sortOrder,
                        filters: this.dt.filters,
                        globalFilter: this.dt.filters && this.dt.filters.global ? this.dt.filters.global.value : null,
                        multiSortMeta: this.dt.multiSortMeta,
                        loadMore: false,
                        infiniteScrollingFirst: null
                    });
                }
            }, this.dt.virtualScrollDelay);
        }
    }
    scrollToVirtualIndex(index) {
        if (this.virtualScrollBody) {
            this.virtualScrollBody.scrollToIndex(index);
        }
    }
    scrollTo(options) {
        if (this.virtualScrollBody) {
            this.virtualScrollBody.scrollTo(options);
        }
        else {
            if (this.scrollBodyViewChild.nativeElement.scrollTo) {
                this.scrollBodyViewChild.nativeElement.scrollTo(options);
            }
            else {
                this.scrollBodyViewChild.nativeElement.scrollLeft = options.left;
                this.scrollBodyViewChild.nativeElement.scrollTop = options.top;
            }
        }
    }
    _subscribeOnVisualViewportResize() {
        // Firefox Responsive Design Mode have Viewport Zooming disabled by default
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', this._visualViewportResizeListenerBind);
        }
    }
    _visualViewportResizeListener() {
        this.zone.runOutsideAngular(() => {
            this.alignScrollBar(true);
        });
    }
}
ScrollableView.ɵfac = function ScrollableView_Factory(t) { return new (t || ScrollableView)(i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i4.EventManager)); };
ScrollableView.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ScrollableView, selectors: [["", "pScrollableView", ""]], viewQuery: function ScrollableView_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$6, 5);
        i0.ɵɵviewQuery(_c1$4, 5);
        i0.ɵɵviewQuery(_c2$3, 5);
        i0.ɵɵviewQuery(_c3$1, 5);
        i0.ɵɵviewQuery(_c4, 5);
        i0.ɵɵviewQuery(_c5, 5);
        i0.ɵɵviewQuery(_c6, 5);
        i0.ɵɵviewQuery(CdkVirtualScrollViewport, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollHeaderViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollHeaderBoxViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollBodyViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollTableViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollFooterViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollFooterBoxViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollableAlignerViewChild = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtualScrollBody = _t.first);
    } }, inputs: { columns: ["pScrollableView", "columns"], frozen: "frozen", scrollHeight: "scrollHeight" }, attrs: _c7, decls: 47, vars: 32, consts: [[1, "ui-widget-header"], ["scrollHeader", ""], [1, "ui-table-scrollable-header-box"], ["scrollHeaderBox", ""], [3, "ngClass", "ngStyle"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "ui-table-thead"], [1, "ui-table-tbody"], ["ngFor", "", 3, "ngForOf", "ngForTrackBy"], [4, "ngIf", "ngIfElse"], ["virtualScrollTemplate", ""], ["scrollFooter", ""], [1, "ui-table-scrollable-footer-box"], ["scrollFooterBox", ""], [1, "ui-table-tfoot"], [3, "ngStyle"], ["scrollBody", ""], ["scrollTable", ""], [1, "ui-table-tbody", 3, "pTableBody", "pTableBodyTemplate", "frozen"], ["style", "background-color:transparent", 4, "ngIf"], [3, "infiniteScrollLoading", 4, "ngIf"], [2, "background-color", "transparent"], ["scrollableAligner", ""], [3, "infiniteScrollLoading"], [3, "itemSize", "minBufferPx", "maxBufferPx", "ngClass", "scrolledIndexChange"]], template: function ScrollableView_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0, 1);
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelementStart(4, "div", 2, 3);
        i0.ɵɵtext(6, "\n        ");
        i0.ɵɵelementStart(7, "table", 4);
        i0.ɵɵtext(8, "\n          ");
        i0.ɵɵtemplate(9, ScrollableView_ng_container_9_Template, 1, 0, "ng-container", 5);
        i0.ɵɵtext(10, "\n          ");
        i0.ɵɵelementStart(11, "thead", 6);
        i0.ɵɵtext(12, "\n          ");
        i0.ɵɵtemplate(13, ScrollableView_ng_container_13_Template, 1, 0, "ng-container", 5);
        i0.ɵɵtext(14, "\n          ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(15, "\n          ");
        i0.ɵɵelementStart(16, "tbody", 7);
        i0.ɵɵtext(17, "\n          ");
        i0.ɵɵtemplate(18, ScrollableView_ng_template_18_Template, 3, 6, "ng-template", 8);
        i0.ɵɵtext(19, "\n          ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(20, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(21, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(23, "\n    ");
        i0.ɵɵtemplate(24, ScrollableView_ng_container_24_Template, 18, 18, "ng-container", 9);
        i0.ɵɵtext(25, "\n    ");
        i0.ɵɵtemplate(26, ScrollableView_ng_template_26_Template, 16, 23, "ng-template", null, 10, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(28, "\n    ");
        i0.ɵɵelementStart(29, "div", 0, 11);
        i0.ɵɵtext(31, "\n      ");
        i0.ɵɵelementStart(32, "div", 12, 13);
        i0.ɵɵtext(34, "\n        ");
        i0.ɵɵelementStart(35, "table", 4);
        i0.ɵɵtext(36, "\n          ");
        i0.ɵɵtemplate(37, ScrollableView_ng_container_37_Template, 1, 0, "ng-container", 5);
        i0.ɵɵtext(38, "\n          ");
        i0.ɵɵelementStart(39, "tfoot", 14);
        i0.ɵɵtext(40, "\n          ");
        i0.ɵɵtemplate(41, ScrollableView_ng_container_41_Template, 1, 0, "ng-container", 5);
        i0.ɵɵtext(42, "\n          ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(43, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(44, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(45, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(46, "\n  ");
    } if (rf & 2) {
        const _r6 = i0.ɵɵreference(27);
        i0.ɵɵadvance(1);
        i0.ɵɵclassMap(ctx.tableClasses.TableScrollableHeader);
        i0.ɵɵadvance(6);
        i0.ɵɵclassMap(ctx.tableClasses.TableScrollableHeaderTable);
        i0.ɵɵproperty("ngClass", ctx.dt.tableStyleClass)("ngStyle", ctx.dt.tableStyle);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngTemplateOutlet", ctx.frozen ? ctx.dt.frozenColGroupTemplate || ctx.dt.colGroupTemplate : ctx.dt.colGroupTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(24, _c10, ctx.columns));
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngTemplateOutlet", ctx.frozen ? ctx.dt.frozenHeaderTemplate || ctx.dt.headerTemplate : ctx.dt.headerTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(26, _c10, ctx.columns));
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngForOf", ctx.dt.frozenValue)("ngForTrackBy", ctx.dt.rowTrackBy);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", !ctx.dt.virtualScroll)("ngIfElse", _r6);
        i0.ɵɵadvance(5);
        i0.ɵɵclassMap(ctx.tableClasses.TableScrollableFooter);
        i0.ɵɵadvance(6);
        i0.ɵɵclassMap(ctx.tableClasses.TableScrollableFooterTable);
        i0.ɵɵproperty("ngClass", ctx.dt.tableStyleClass)("ngStyle", ctx.dt.tableStyle);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngTemplateOutlet", ctx.frozen ? ctx.dt.frozenColGroupTemplate || ctx.dt.colGroupTemplate : ctx.dt.colGroupTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(28, _c10, ctx.columns));
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngTemplateOutlet", ctx.frozen ? ctx.dt.frozenFooterTemplate || ctx.dt.footerTemplate : ctx.dt.footerTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(30, _c10, ctx.columns));
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ScrollableView, [{
        type: Component,
        args: [{
                // eslint-disable-next-line @angular-eslint/component-selector
                selector: '[pScrollableView]',
                template: `
    <div #scrollHeader
         [class]="tableClasses.TableScrollableHeader"
         class="ui-widget-header">
      <div #scrollHeaderBox class="ui-table-scrollable-header-box">
        <table
          [class]="tableClasses.TableScrollableHeaderTable"
          [ngClass]="dt.tableStyleClass"
          [ngStyle]="dt.tableStyle">
          <ng-container
            *ngTemplateOutlet="frozen ? dt.frozenColGroupTemplate||dt.colGroupTemplate : dt.colGroupTemplate; context {$implicit: columns}"></ng-container>
          <thead class="ui-table-thead">
          <ng-container
            *ngTemplateOutlet="frozen ? dt.frozenHeaderTemplate||dt.headerTemplate : dt.headerTemplate; context {$implicit: columns}"></ng-container>
          </thead>
          <tbody class="ui-table-tbody">
          <ng-template ngFor let-rowData let-rowIndex="index" [ngForOf]="dt.frozenValue" [ngForTrackBy]="dt.rowTrackBy">
            <ng-container
              *ngTemplateOutlet="dt.frozenRowsTemplate; context: {$implicit: rowData, rowIndex: rowIndex, columns: columns}"></ng-container>
          </ng-template>
          </tbody>
        </table>
      </div>
    </div>
    <ng-container *ngIf="!dt.virtualScroll; else virtualScrollTemplate">
      <div #scrollBody
           [class]="tableClasses.TableScrollableBody"
           [ngStyle]="{'height': dt.scrollHeight !== 'flex' ? scrollHeight : undefined}">
        <table #scrollTable
               [ngClass]="dt.tableStyleClass"
               [ngStyle]="dt.tableStyle"
               [class]="tableClasses.TableScrollableBodyTable">
          <ng-container
            *ngTemplateOutlet="frozen ? dt.frozenColGroupTemplate||dt.colGroupTemplate : dt.colGroupTemplate; context {$implicit: columns}"></ng-container>
          <tbody class="ui-table-tbody"
                 [pTableBody]="columns"
                 [pTableBodyTemplate]="frozen ? dt.frozenBodyTemplate||dt.bodyTemplate : dt.bodyTemplate"
                 [frozen]="frozen"></tbody>
        </table>
        <div #scrollableAligner style="background-color:transparent" *ngIf="frozen"></div>
        <adapt-table-infinite-scrolling-loader *ngIf="canShowInfiniteScrollingLoader()"
                                               [infiniteScrollLoading]="dt.loadingMore"></adapt-table-infinite-scrolling-loader>
      </div>
    </ng-container>
    <ng-template #virtualScrollTemplate>
      <cdk-virtual-scroll-viewport [itemSize]="dt.virtualRowHeight"
                                   [style.height]="dt.scrollHeight !== 'flex' ? scrollHeight : undefined"
                                   [minBufferPx]="dt.minBufferPx"
                                   [maxBufferPx]="dt.maxBufferPx"
                                   (scrolledIndexChange)="onScrollIndexChange($event)"
                                   [ngClass]="{'ui-table-virtual-scrollable-body_empty': dt.isEmpty()}"
                                   [class]="tableClasses.TableVirtualScrollableBody">
        <table #scrollTable
               [ngClass]="dt.tableStyleClass"
               [ngStyle]="dt.tableStyle"
               [class]="tableClasses.TableScrollableBodyTable">
          <ng-container
            *ngTemplateOutlet="frozen ? dt.frozenColGroupTemplate||dt.colGroupTemplate : dt.colGroupTemplate; context {$implicit: columns}"></ng-container>
          <tbody class="ui-table-tbody"
                 [pTableBody]="columns"
                 [pTableBodyTemplate]="frozen ? dt.frozenBodyTemplate||dt.bodyTemplate : dt.bodyTemplate"
                 [frozen]="frozen"></tbody>
        </table>
        <div #scrollableAligner style="background-color:transparent" *ngIf="frozen"></div>
        <adapt-table-infinite-scrolling-loader *ngIf="canShowInfiniteScrollingLoader()"
                                               [infiniteScrollLoading]="dt.loadingMore"></adapt-table-infinite-scrolling-loader>
      </cdk-virtual-scroll-viewport>
    </ng-template>
    <div #scrollFooter [class]="tableClasses.TableScrollableFooter" class="ui-widget-header">
      <div #scrollFooterBox class="ui-table-scrollable-footer-box">
        <table
          [class]="tableClasses.TableScrollableFooterTable"
          [ngClass]="dt.tableStyleClass"
          [ngStyle]="dt.tableStyle">
          <ng-container
            *ngTemplateOutlet="frozen ? dt.frozenColGroupTemplate||dt.colGroupTemplate : dt.colGroupTemplate; context {$implicit: columns}"></ng-container>
          <tfoot class="ui-table-tfoot">
          <ng-container
            *ngTemplateOutlet="frozen ? dt.frozenFooterTemplate||dt.footerTemplate : dt.footerTemplate; context {$implicit: columns}"></ng-container>
          </tfoot>
        </table>
      </div>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.Default
            }]
    }], function () { return [{ type: AdaptTableComponent }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i4.EventManager }]; }, { columns: [{
            type: Input,
            args: ['pScrollableView']
        }], frozen: [{
            type: Input
        }], scrollHeaderViewChild: [{
            type: ViewChild,
            args: ['scrollHeader', { static: false }]
        }], scrollHeaderBoxViewChild: [{
            type: ViewChild,
            args: ['scrollHeaderBox', { static: false }]
        }], scrollBodyViewChild: [{
            type: ViewChild,
            args: ['scrollBody', { static: false }]
        }], scrollTableViewChild: [{
            type: ViewChild,
            args: ['scrollTable', { static: false }]
        }], scrollFooterViewChild: [{
            type: ViewChild,
            args: ['scrollFooter', { static: false }]
        }], scrollFooterBoxViewChild: [{
            type: ViewChild,
            args: ['scrollFooterBox', { static: false }]
        }], scrollableAlignerViewChild: [{
            type: ViewChild,
            args: ['scrollableAligner', { static: false }]
        }], virtualScrollBody: [{
            type: ViewChild,
            args: [CdkVirtualScrollViewport, { static: false }]
        }], scrollHeight: [{
            type: Input
        }] }); })();

const _c0$5 = function (a0, a1, a2) { return { "pi-sort-up": a0, "pi-sort-down": a1, "pi-sort": a2 }; };
// eslint-disable-next-line @angular-eslint/component-class-suffix
class SortIcon {
    constructor(dt) {
        this.dt = dt;
        this.subscription = this.dt.tableService.sortSource$.subscribe(() => {
            this.updateSortState();
        });
    }
    ngOnInit() {
        this.updateSortState();
    }
    onClick(event) {
        event.preventDefault();
    }
    updateSortState() {
        if (this.dt.sortMode === 'single') {
            this.sortOrder = this.dt.isSorted(this.field) ? this.dt.sortOrder : 0;
        }
        else if (this.dt.sortMode === 'multiple') {
            const sortMeta = this.dt.getSortMeta(this.field);
            this.sortOrder = sortMeta ? sortMeta.order : 0;
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
SortIcon.ɵfac = function SortIcon_Factory(t) { return new (t || SortIcon)(i0.ɵɵdirectiveInject(Table)); };
SortIcon.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: SortIcon, selectors: [["p-sortIcon"]], inputs: { field: "field" }, decls: 3, vars: 5, consts: [[1, "ui-sortable-column-icon", "pi", "pi-fw", 3, "ngClass"]], template: function SortIcon_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelement(1, "i", 0);
        i0.ɵɵtext(2, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(1, _c0$5, ctx.sortOrder === 1, ctx.sortOrder === -1, ctx.sortOrder === 0));
    } }, directives: [i2$1.NgClass], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SortIcon, [{
        type: Component,
        args: [{
                // eslint-disable-next-line @angular-eslint/component-selector
                selector: 'p-sortIcon',
                template: `
    <i class="ui-sortable-column-icon pi pi-fw"
       [ngClass]="{'pi-sort-up': sortOrder === 1, 'pi-sort-down': sortOrder === -1, 'pi-sort': sortOrder === 0}"></i>
  `
            }]
    }], function () { return [{ type: Table }]; }, { field: [{
            type: Input
        }] }); })();

// eslint-disable-next-line @angular-eslint/directive-class-suffix
class SortableColumn {
    constructor(dt) {
        this.dt = dt;
    }
    ngOnInit() {
        if (this.dt.isSorted(this.field)) {
            this.sortOrder = this.dt.isColumnSortOrderAsc(this.field) ? 'ascending' : 'descending';
        }
        else {
            this.sortOrder = 'none';
        }
        if (this.isEnabled()) {
            this.subscription = this.dt.tableService.sortSource$.subscribe((sortMeta) => {
                // Add timeout to update sorting state after 'sortField' and 'sortOrder' inputs changed
                setTimeout(() => {
                    this.updateSortState(sortMeta);
                });
            });
        }
    }
    updateSortState(sortMeta) {
        this.sorted = this.dt.isSorted(this.field);
        this.sortOrder = 'none';
        if (!sortMeta) {
            return;
        }
        if (this.dt.isMultipleSortMode) {
            sortMeta.forEach(item => {
                if (this.field === item.field) {
                    this.sortOrder = this.sorted ? (item.order === 1 ? 'ascending' : 'descending') : 'none';
                }
            });
        }
        else if (this.dt.isSingleSortMode) {
            this.sortOrder = this.sorted ? (sortMeta.order === 1 ? 'ascending' : 'descending') : 'none';
        }
    }
    onClick(event) {
        if (this.isEnabled()) {
            this.updateSortState();
            this.dt.sort({
                originalEvent: event,
                field: this.field
            });
            DomHandler.clearSelection();
        }
    }
    onEnterKey(event) {
        this.onClick(event);
    }
    isEnabled() {
        return this.pSortableColumnDisabled !== true;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
SortableColumn.ɵfac = function SortableColumn_Factory(t) { return new (t || SortableColumn)(i0.ɵɵdirectiveInject(AdaptTableComponent)); };
SortableColumn.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: SortableColumn, selectors: [["", "pSortableColumn", ""]], hostVars: 7, hostBindings: function SortableColumn_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("click", function SortableColumn_click_HostBindingHandler($event) { return ctx.onClick($event); })("keydown.enter", function SortableColumn_keydown_enter_HostBindingHandler($event) { return ctx.onEnterKey($event); });
    } if (rf & 2) {
        i0.ɵɵattribute("tabindex", ctx.isEnabled() ? "0" : null)("role", "columnheader")("aria-sort", ctx.sortOrder);
        i0.ɵɵclassProp("ui-sortable-column", ctx.isEnabled())("ui-state-highlight", ctx.sorted);
    } }, inputs: { field: ["pSortableColumn", "field"], pSortableColumnDisabled: "pSortableColumnDisabled" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(SortableColumn, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[pSortableColumn]',
                // TODO: Refactor this if possible
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.ui-sortable-column]': 'isEnabled()',
                    '[class.ui-state-highlight]': 'sorted',
                    '[attr.tabindex]': 'isEnabled() ? "0" : null',
                    '[attr.role]': '"columnheader"',
                    '[attr.aria-sort]': 'sortOrder'
                }
            }]
    }], function () { return [{ type: AdaptTableComponent }]; }, { field: [{
            type: Input,
            args: ['pSortableColumn']
        }], pSortableColumnDisabled: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onEnterKey: [{
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }] }); })();

const _c0$4 = ["pTableBody", ""];
function TableBody_ng_container_1_ng_container_2_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function TableBody_ng_container_1_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, TableBody_ng_container_1_ng_container_2_ng_template_2_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    const renderRowData_r7 = ctx.$implicit;
    const rowIndex_r8 = ctx.index;
    const ctx_r6 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r6.pTableBodyTemplate)("ngTemplateOutletContext", ctx_r6.getContext(renderRowData_r7, rowIndex_r8, true));
} }
function TableBody_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, TableBody_ng_container_1_ng_container_2_ng_template_2_Template, 3, 2, "ng-template", 1);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r4.dt.getPlainExpandedRenderingRows(ctx_r4.dt.getCurrentPageDisplayingRows()))("ngForTrackBy", ctx_r4.dt.trackByForRenderingRows);
} }
function TableBody_ng_container_1_ng_container_4_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function TableBody_ng_container_1_ng_container_4_ng_template_2_ng_container_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function TableBody_ng_container_1_ng_container_4_ng_template_2_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, TableBody_ng_container_1_ng_container_4_ng_template_2_ng_container_3_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r16 = i0.ɵɵnextContext();
    const renderRowData_r11 = ctx_r16.$implicit;
    const rowIndex_r12 = ctx_r16.index;
    const ctx_r14 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r14.dt.expandedRowTemplateRef)("ngTemplateOutletContext", ctx_r14.getContext(renderRowData_r11, rowIndex_r12));
} }
function TableBody_ng_container_1_ng_container_4_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, TableBody_ng_container_1_ng_container_4_ng_template_2_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, TableBody_ng_container_1_ng_container_4_ng_template_2_ng_container_3_Template, 4, 2, "ng-container", 0);
    i0.ɵɵtext(4, "\n        ");
} if (rf & 2) {
    const renderRowData_r11 = ctx.$implicit;
    const rowIndex_r12 = ctx.index;
    const ctx_r10 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r10.pTableBodyTemplate)("ngTemplateOutletContext", ctx_r10.getContext(renderRowData_r11, rowIndex_r12, true, true));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r10.dt.isRowExpanded(renderRowData_r11));
} }
function TableBody_ng_container_1_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, TableBody_ng_container_1_ng_container_4_ng_template_2_Template, 5, 3, "ng-template", 1);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r5.dt.getPlainExpandedRenderingRows(ctx_r5.dt.getCurrentPageDisplayingRows()))("ngForTrackBy", ctx_r5.dt.trackByForRenderingRows);
} }
function TableBody_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, TableBody_ng_container_1_ng_container_2_Template, 4, 2, "ng-container", 0);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, TableBody_ng_container_1_ng_container_4_Template, 4, 2, "ng-container", 0);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r0.dt.expandedRowTemplateRef);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.dt.expandedRowTemplateRef);
} }
function TableBody_ng_container_3_ng_container_2_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function TableBody_ng_container_3_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, TableBody_ng_container_3_ng_container_2_ng_template_2_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    const renderRowData_r20 = ctx.$implicit;
    const rowIndex_r21 = ctx.index;
    const ctx_r19 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r19.pTableBodyTemplate)("ngTemplateOutletContext", ctx_r19.getContext(renderRowData_r20, rowIndex_r21, true));
} }
function TableBody_ng_container_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, TableBody_ng_container_3_ng_container_2_ng_template_2_Template, 3, 2, "ng-template", 3);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r17 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("cdkVirtualForOf", ctx_r17.dt.getPlainExpandedRenderingRows(ctx_r17.dt.getCurrentPageDisplayingRows()))("cdkVirtualForTemplateCacheSize", 0)("cdkVirtualForTrackBy", ctx_r17.dt.trackByForRenderingRows);
} }
function TableBody_ng_container_3_ng_container_4_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function TableBody_ng_container_3_ng_container_4_ng_template_2_ng_container_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function TableBody_ng_container_3_ng_container_4_ng_template_2_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, TableBody_ng_container_3_ng_container_4_ng_template_2_ng_container_3_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r29 = i0.ɵɵnextContext();
    const renderRowData_r24 = ctx_r29.$implicit;
    const rowIndex_r25 = ctx_r29.index;
    const ctx_r27 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r27.dt.expandedRowTemplateRef)("ngTemplateOutletContext", ctx_r27.getContext(renderRowData_r24, rowIndex_r25));
} }
function TableBody_ng_container_3_ng_container_4_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, TableBody_ng_container_3_ng_container_4_ng_template_2_ng_container_1_Template, 1, 0, "ng-container", 2);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, TableBody_ng_container_3_ng_container_4_ng_template_2_ng_container_3_Template, 4, 2, "ng-container", 0);
    i0.ɵɵtext(4, "\n        ");
} if (rf & 2) {
    const renderRowData_r24 = ctx.$implicit;
    const rowIndex_r25 = ctx.index;
    const ctx_r23 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r23.pTableBodyTemplate)("ngTemplateOutletContext", ctx_r23.getContext(renderRowData_r24, rowIndex_r25, true, true));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r23.dt.isRowExpanded(renderRowData_r24));
} }
function TableBody_ng_container_3_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, TableBody_ng_container_3_ng_container_4_ng_template_2_Template, 5, 3, "ng-template", 3);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("cdkVirtualForOf", ctx_r18.dt.getPlainExpandedRenderingRows(ctx_r18.dt.getCurrentPageDisplayingRows()))("cdkVirtualForTemplateCacheSize", 0)("cdkVirtualForTrackBy", ctx_r18.dt.trackByForRenderingRows);
} }
function TableBody_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, TableBody_ng_container_3_ng_container_2_Template, 4, 3, "ng-container", 0);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, TableBody_ng_container_3_ng_container_4_Template, 4, 3, "ng-container", 0);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r1.dt.expandedRowTemplateRef);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r1.dt.expandedRowTemplateRef);
} }
function TableBody_ng_container_5_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
const _c1$3 = function (a0, a1) { return { $implicit: a0, frozen: a1 }; };
function TableBody_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, TableBody_ng_container_5_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r2.dt.loadingBodyTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction2(2, _c1$3, ctx_r2.pTableBody, ctx_r2.frozen));
} }
function TableBody_ng_container_7_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function TableBody_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, TableBody_ng_container_7_ng_container_2_Template, 1, 0, "ng-container", 2);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r3.dt.emptyMessageTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction2(2, _c1$3, ctx_r3.pTableBody, ctx_r3.frozen));
} }
// eslint-disable-next-line @angular-eslint/component-class-suffix
class TableBody {
    constructor(dt, cd) {
        this.dt = dt;
        this.cd = cd;
        this._destroyed$ = new ReplaySubject(1);
        this.subscription = this.dt.tableService.valueSource$.subscribe(() => {
            if (this.dt.virtualScroll) {
                this.cd.detectChanges();
            }
        });
    }
    ngAfterViewInit() {
        // Because of the height changes after group expanded the ExpressionChangedAfterItHasBeenCheckedError error is appeared
        // To avoid that issue re-attach virtual scroll
        if (this.dt.virtualScroll) {
            this.dt.groupExpansion
                .pipe(takeUntil(this._destroyed$))
                .subscribe(() => {
                this.dt.scrollableView.virtualScrollBody.detach();
                setTimeout(() => {
                    this.dt.scrollableView.virtualScrollBody.attach(this.cdkVirtualForOf);
                });
            });
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    getContext(renderRowData, rowIndex, isEditable = false, isExpandable = false) {
        const context = {
            $implicit: renderRowData,
            rowIndex: this.dt.paginator ? (this.dt.first + rowIndex) : rowIndex,
            columns: this.pTableBody
        };
        if (isEditable) {
            context.editing = (this.dt.editMode === 'row' && this.dt.isRowEditing(renderRowData));
        }
        if (isExpandable) {
            context.expanded = this.dt.isRowExpanded(renderRowData);
        }
        return context;
    }
}
TableBody.ɵfac = function TableBody_Factory(t) { return new (t || TableBody)(i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
TableBody.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: TableBody, selectors: [["", "pTableBody", ""]], viewQuery: function TableBody_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(CdkVirtualForOf, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.cdkVirtualForOf = _t.first);
    } }, inputs: { pTableBody: "pTableBody", pTableBodyTemplate: "pTableBodyTemplate", frozen: "frozen" }, attrs: _c0$4, decls: 9, vars: 4, consts: [[4, "ngIf"], ["ngFor", "", 3, "ngForOf", "ngForTrackBy"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cdkVirtualFor", "", 3, "cdkVirtualForOf", "cdkVirtualForTemplateCacheSize", "cdkVirtualForTrackBy"]], template: function TableBody_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵtemplate(1, TableBody_ng_container_1_Template, 6, 2, "ng-container", 0);
        i0.ɵɵtext(2, "\n\n    ");
        i0.ɵɵtemplate(3, TableBody_ng_container_3_Template, 6, 2, "ng-container", 0);
        i0.ɵɵtext(4, "\n    ");
        i0.ɵɵtemplate(5, TableBody_ng_container_5_Template, 4, 5, "ng-container", 0);
        i0.ɵɵtext(6, "\n    ");
        i0.ɵɵtemplate(7, TableBody_ng_container_7_Template, 4, 5, "ng-container", 0);
        i0.ɵɵtext(8, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", !ctx.dt.virtualScroll);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.dt.virtualScroll);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.dt.loading);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.dt.isEmpty() && !ctx.dt.loading);
    } }, directives: [i2$1.NgIf, i2$1.NgForOf, i2$1.NgTemplateOutlet, i2$3.CdkVirtualForOf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TableBody, [{
        type: Component,
        args: [{
                selector: '[pTableBody]',
                template: `
    <ng-container *ngIf="!dt.virtualScroll">
      <ng-container *ngIf="!dt.expandedRowTemplateRef">
        <ng-template ngFor
                     let-renderRowData
                     let-rowIndex="index"
                     [ngForOf]="dt.getPlainExpandedRenderingRows(dt.getCurrentPageDisplayingRows())"
                     [ngForTrackBy]="dt.trackByForRenderingRows">
          <ng-container
            *ngTemplateOutlet="pTableBodyTemplate; context: getContext(renderRowData, rowIndex, true)"></ng-container>
        </ng-template>
      </ng-container>
      <ng-container *ngIf="dt.expandedRowTemplateRef">
        <ng-template ngFor
                     let-renderRowData
                     let-rowIndex="index"
                     [ngForOf]="dt.getPlainExpandedRenderingRows(dt.getCurrentPageDisplayingRows())"
                     [ngForTrackBy]="dt.trackByForRenderingRows">
          <ng-container
            *ngTemplateOutlet="pTableBodyTemplate; context: getContext(renderRowData, rowIndex, true, true)"></ng-container>
          <ng-container *ngIf="dt.isRowExpanded(renderRowData)">
            <ng-container
              *ngTemplateOutlet="dt.expandedRowTemplateRef; context: getContext(renderRowData, rowIndex)"></ng-container>
          </ng-container>
        </ng-template>
      </ng-container>
    </ng-container>

    <ng-container *ngIf="dt.virtualScroll">
      <ng-container *ngIf="!dt.expandedRowTemplateRef">
        <ng-template cdkVirtualFor
                     let-renderRowData
                     let-rowIndex="index"
                     [cdkVirtualForOf]="dt.getPlainExpandedRenderingRows(dt.getCurrentPageDisplayingRows())"
                     [cdkVirtualForTemplateCacheSize]="0"
                     [cdkVirtualForTrackBy]="dt.trackByForRenderingRows">
          <ng-container
            *ngTemplateOutlet="pTableBodyTemplate; context: getContext(renderRowData, rowIndex, true)"></ng-container>
        </ng-template>
      </ng-container>
      <ng-container *ngIf="dt.expandedRowTemplateRef">
        <ng-template cdkVirtualFor
                     let-renderRowData
                     let-rowIndex="index"
                     [cdkVirtualForOf]="dt.getPlainExpandedRenderingRows(dt.getCurrentPageDisplayingRows())"
                     [cdkVirtualForTemplateCacheSize]="0"
                     [cdkVirtualForTrackBy]="dt.trackByForRenderingRows">
          <ng-container
            *ngTemplateOutlet="pTableBodyTemplate; context: getContext(renderRowData, rowIndex, true, true)"></ng-container>
          <ng-container *ngIf="dt.isRowExpanded(renderRowData)">
            <ng-container
              *ngTemplateOutlet="dt.expandedRowTemplateRef; context: getContext(renderRowData, rowIndex)"></ng-container>
          </ng-container>
        </ng-template>
      </ng-container>
    </ng-container>
    <ng-container *ngIf="dt.loading">
      <ng-container
        *ngTemplateOutlet="dt.loadingBodyTemplate; context: {$implicit: pTableBody, frozen: frozen}"></ng-container>
    </ng-container>
    <ng-container *ngIf="dt.isEmpty() && !dt.loading">
      <ng-container
        *ngTemplateOutlet="dt.emptyMessageTemplate; context: {$implicit: pTableBody, frozen: frozen}"></ng-container>
    </ng-container>
  `
            }]
    }], function () { return [{ type: AdaptTableComponent }, { type: i0.ChangeDetectorRef }]; }, { pTableBody: [{
            type: Input
        }], pTableBodyTemplate: [{
            type: Input
        }], frozen: [{
            type: Input
        }], cdkVirtualForOf: [{
            type: ViewChild,
            args: [CdkVirtualForOf]
        }] }); })();

class AdaptTableInfiniteScrollingLoaderComponent {
    constructor() {
        this.busyConfig = this.getBusyConfig();
        this._destroyed$ = new ReplaySubject(1);
    }
    set infiniteScrollLoading(value) {
        const busyConfigCopy = Object.assign({}, this.busyConfig);
        if (value) {
            if (this.busyConfig.busy) {
                this.busyConfig.busy.unsubscribe();
            }
            busyConfigCopy.busy = new Observable().pipe(takeUntil(this._destroyed$)).subscribe();
            this.busyConfig = busyConfigCopy;
        }
        else if (this.busyConfig.busy) {
            this.busyConfig.busy.unsubscribe();
            busyConfigCopy.busy = null;
            this.busyConfig = busyConfigCopy;
        }
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    getBusyConfig() {
        return {
            busy: null,
            backdrop: true,
            sticky: true,
            message: '',
            loaderType: 'section',
            inOutType: LoaderInOutType.fade,
        };
    }
}
AdaptTableInfiniteScrollingLoaderComponent.ɵfac = function AdaptTableInfiniteScrollingLoaderComponent_Factory(t) { return new (t || AdaptTableInfiniteScrollingLoaderComponent)(); };
AdaptTableInfiniteScrollingLoaderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTableInfiniteScrollingLoaderComponent, selectors: [["adapt-table-infinite-scrolling-loader"]], inputs: { infiniteScrollLoading: "infiniteScrollLoading" }, decls: 5, vars: 1, consts: [[1, "at-infinite-scrolling-loader"], [3, "ngBusy"]], template: function AdaptTableInfiniteScrollingLoaderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelement(2, "div", 1);
        i0.ɵɵtext(3, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(4, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngBusy", ctx.busyConfig);
    } }, directives: [i1.AdaptBusyDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableInfiniteScrollingLoaderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-table-infinite-scrolling-loader',
                templateUrl: './table-infinite-scrolling-loader.html',
                encapsulation: ViewEncapsulation.None,
            }]
    }], null, { infiniteScrollLoading: [{
            type: Input
        }] }); })();

/*
* This module was copied from https://github.com/primefaces/primeng/releases/tag/9.0.5
* Reason: maintain all needed features and bug fixes on ADAPT side
* */
class TableModule {
}
TableModule.ɵfac = function TableModule_Factory(t) { return new (t || TableModule)(); };
TableModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: TableModule });
TableModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            PaginatorModule,
            ScrollingModule,
            AdaptBusyModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TableModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    PaginatorModule,
                    ScrollingModule,
                    AdaptBusyModule
                ],
                exports: [
                    Table,
                    SortableColumn,
                    RowToggler,
                    ResizableColumn,
                    ReorderableColumn,
                    SortIcon,
                    EditableRow,
                    ScrollableView,
                    TableBody,
                    AdaptTableInfiniteScrollingLoaderComponent
                ],
                declarations: [
                    Table,
                    SortableColumn,
                    RowToggler,
                    ResizableColumn,
                    ReorderableColumn,
                    TableBody,
                    ScrollableView,
                    SortIcon,
                    EditableRow,
                    AdaptTableInfiniteScrollingLoaderComponent,
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(TableModule, { declarations: [Table,
        SortableColumn,
        RowToggler,
        ResizableColumn,
        ReorderableColumn,
        TableBody,
        ScrollableView,
        SortIcon,
        EditableRow,
        AdaptTableInfiniteScrollingLoaderComponent], imports: [CommonModule,
        PaginatorModule,
        ScrollingModule,
        AdaptBusyModule], exports: [Table,
        SortableColumn,
        RowToggler,
        ResizableColumn,
        ReorderableColumn,
        SortIcon,
        EditableRow,
        ScrollableView,
        TableBody,
        AdaptTableInfiniteScrollingLoaderComponent] }); })();
i0.ɵɵsetComponentScope(ScrollableView, [i2$1.NgClass, i2$1.NgStyle, i2$1.NgTemplateOutlet, i2$1.NgForOf, i2$1.NgIf, TableBody,
    AdaptTableInfiniteScrollingLoaderComponent, i2$3.CdkVirtualScrollViewport, i2$3.CdkFixedSizeVirtualScroll], []);

class AdaptTableStorageService {
    getData(stateKey, storageType) {
        if (storageType === StorageType.Local) {
            try {
                return JSON.parse(localStorage.getItem(stateKey));
            }
            catch (error) {
                return null;
            }
        }
        if (storageType === StorageType.Session) {
            try {
                return JSON.parse(sessionStorage.getItem(stateKey));
            }
            catch (error) {
                return null;
            }
        }
    }
    updateData(stateKey, dataToUpdate, storageType) {
        const restoredState = Object.assign(Object.assign({}, this.getData(stateKey, storageType)), dataToUpdate);
        if (restoredState) {
            // Delete empty data from storage
            Object.keys(restoredState).forEach(key => isEmpty(restoredState[key]) && delete restoredState[key]);
            if (storageType === StorageType.Local) {
                localStorage.setItem(stateKey, JSON.stringify(restoredState));
            }
            if (storageType === StorageType.Session) {
                sessionStorage.setItem(stateKey, JSON.stringify(restoredState));
            }
        }
    }
    // TODO: For future, think how to restore table state correctly
    clearData(stateKey) {
        localStorage.removeItem(stateKey);
        sessionStorage.removeItem(stateKey);
    }
}
AdaptTableStorageService.ɵfac = function AdaptTableStorageService_Factory(t) { return new (t || AdaptTableStorageService)(); };
AdaptTableStorageService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptTableStorageService, factory: AdaptTableStorageService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableStorageService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();

class AdaptTableStateDirective {
    constructor(_element, _table, _adaptTableStorageService, _resizeService) {
        this._element = _element;
        this._table = _table;
        this._adaptTableStorageService = _adaptTableStorageService;
        this._resizeService = _resizeService;
        this.stateRestore = new EventEmitter();
        this._destroyed$ = new ReplaySubject(1);
    }
    ngOnInit() {
        this._subscribeOnTableEvents();
        this._restoreTableState();
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    _subscribeOnSort() {
        this._table.onSort
            .pipe(takeUntil(this._destroyed$))
            .subscribe(data => {
            if (this._table.isSingleSortMode) {
                this._adaptTableStorageService.updateData(this.stateKey, { singleSortMeta: data }, StorageType.Local);
            }
            else {
                this._adaptTableStorageService.updateData(this.stateKey, { multiSortMeta: data.multisortmeta }, StorageType.Local);
            }
        });
    }
    _subscribeOnColumnReorder() {
        this._table.onColReorder
            .pipe(takeUntil(this._destroyed$))
            .subscribe(data => {
            const columnOrder = data.columns.map(column => column.field);
            this._adaptTableStorageService.updateData(this.stateKey, { columnOrder: columnOrder }, StorageType.Local);
        });
    }
    _subscribeOnColumnsResize() {
        this._table.onColResize
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            const widthMap = this._table.dataHeaderCells.map(cell => {
                return {
                    fields: cell.data.renderingColumn.columnsConfigs.map(col => col.field),
                    width: cell.element.nativeElement.offsetWidth
                };
            });
            const mergedColumns = this._table.mergeColumns && this._table.dataHeaderCells
                .filter(cell => cell.data.renderingColumn.type === RenderingColumnType.Merged);
            // Need to save merged columns in separate property to correctly restore columns and merged columns
            this._adaptTableStorageService.updateData(this.stateKey, { [mergedColumns && mergedColumns.length ? 'columnMergedWidths' : 'columnWidths']: widthMap }, StorageType.Local);
        });
    }
    _subscribeOnFilter() {
        this._table.onFilter
            .pipe(takeUntil(this._destroyed$))
            .subscribe(data => {
            this._adaptTableStorageService.updateData(this.stateKey, { filters: data.filters }, StorageType.Session);
        });
    }
    _subscribeOnColumnVisibilityChange() {
        this._table.columnsVisibilityChange
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            const columnsVisibility = this._table.columns.map(col => ({ fields: [col.field], hidden: !this._table.isColumnVisible(col) }));
            this._adaptTableStorageService.updateData(this.stateKey, { columnsVisibility }, StorageType.Session);
        });
    }
    _restoreSingleSorting(state) {
        const sortingColumn = this._table.columns.find(column => column.field === state.singleSortMeta.field);
        // Apply only for columns that are sortable and not hidden
        if (this._table.isSortableColumn(sortingColumn) && this._table.isColumnVisible(sortingColumn)) {
            this._table.sortField = state.singleSortMeta.field;
            this._table.sortOrder = state.singleSortMeta.order;
        }
    }
    _restoreMultipleSorting(state) {
        // Apply only for columns that are sortable and not hidden
        const multiSortMetaToRestore = state.multiSortMeta.filter(sortMeta => {
            return this._table.columns.some(column => this._table.isSortableColumn(column)
                && this._table.isColumnVisible(column)
                && column.field === sortMeta.field);
        });
        this._table.updateMultiSortMeta(multiSortMetaToRestore);
    }
    _restoreColumnsOrder(state) {
        // TODO: Changing of reference doesn't trigger columns reordering
        this._table.columns.sort((a, b) => {
            return state.columnOrder.indexOf(a.field) - state.columnOrder.indexOf(b.field);
        });
    }
    _restoreColumnsWidth(state) {
        const columns = [...this._table.columns];
        const columnsForRendering = this._table.getColumnsForRendering(this._table.columns);
        const isMergedColumnsPresent = columnsForRendering.some(column => column.type === RenderingColumnType.Merged);
        const columnWidthState = isMergedColumnsPresent && state.columnMergedWidths ? state.columnMergedWidths : state.columnWidths;
        columns.forEach(column => {
            const columnWithSavedWidth = columnWidthState && columnWidthState.find(columnWidth => columnWidth.fields[0] === column.field);
            column.width = columnWithSavedWidth && columnWithSavedWidth.width.toString() + 'px';
        });
        this._table.columns = columns;
    }
    _restoreFiltering(state) {
        const restoredFilters = {};
        for (const columnName in state.filters) {
            if (Object.prototype.hasOwnProperty.call(state.filters, columnName)) {
                this._table.columns.forEach(column => {
                    if (this._table.isFilterableColumn(column) && column.field === columnName) {
                        restoredFilters[columnName] = state.filters[columnName];
                    }
                });
            }
        }
        // TODO: Check do we need restoringFilter property!!!
        this._table.restoringFilter = true;
        this._table.filters = restoredFilters;
        // Need to call _filter() method manually after changing "filters" property
        // because filtering inside primeng table called only on "value" property change
        this._table._filter();
    }
    _restoreColumnsVisibility(state) {
        this._table.columns.forEach(column => {
            state.columnsVisibility.forEach(visibilityState => {
                if (column.field === visibilityState.fields[0]) {
                    column.hidden = visibilityState.hidden;
                }
            });
        });
    }
    _subscribeOnTableEvents() {
        this._subscribeOnSort();
        this._subscribeOnColumnReorder();
        this._subscribeOnColumnsResize();
        this._subscribeOnFilter();
        this._subscribeOnColumnVisibilityChange();
    }
    _restoreTableState() {
        const localState = this._adaptTableStorageService.getData(this.stateKey, StorageType.Local);
        const sessionState = this._adaptTableStorageService.getData(this.stateKey, StorageType.Session);
        if (localState) {
            if (this._table.sortMode === SortMode.Single && localState.singleSortMeta) {
                this._restoreSingleSorting(localState);
            }
            if (this._table.sortMode === SortMode.Multiple && localState.multiSortMeta) {
                this._restoreMultipleSorting(localState);
            }
            if (this._table.reorderableColumns && localState.columnOrder) {
                this._restoreColumnsOrder(localState);
            }
            if (this._table.resizableColumns && (localState.columnWidths || localState.columnMergedWidths)) {
                this._restoreColumnsWidth(localState);
            }
        }
        if (sessionState) {
            if (this._table.filterable && sessionState.filters) {
                this._restoreFiltering(sessionState);
            }
            if (sessionState.columnsVisibility) {
                this._restoreColumnsVisibility(sessionState);
            }
        }
        const tableState = Object.assign(Object.assign({}, localState), sessionState);
        this.stateRestore.emit(isEmpty(tableState) ? null : tableState);
    }
}
AdaptTableStateDirective.ɵfac = function AdaptTableStateDirective_Factory(t) { return new (t || AdaptTableStateDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(AdaptTableComponent), i0.ɵɵdirectiveInject(AdaptTableStorageService), i0.ɵɵdirectiveInject(i1.ResizeService)); };
AdaptTableStateDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTableStateDirective, selectors: [["adapt-table", "adaptTableState", ""]], inputs: { stateKey: ["adaptTableState", "stateKey"] }, outputs: { stateRestore: "stateRestore" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableStateDirective, [{
        type: Directive,
        args: [{
                selector: 'adapt-table[adaptTableState]'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: AdaptTableComponent }, { type: AdaptTableStorageService }, { type: i1.ResizeService }]; }, { stateKey: [{
            type: Input,
            args: ['adaptTableState']
        }], stateRestore: [{
            type: Output
        }] }); })();

const _c0$3 = function (a0, a1) { return { id: a0, name: a1 }; };
const _c1$2 = function (a0) { return [a0]; };
function AdaptTableHeaderCellMenuComponent_div_12_div_2_div_22_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "div", 17);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementStart(4, "adapt-rx-select", 18);
    i0.ɵɵlistener("ngModelChange", function AdaptTableHeaderCellMenuComponent_div_12_div_2_div_22_Template_adapt_rx_select_ngModelChange_4_listener($event) { i0.ɵɵrestoreView(_r10); const column_r5 = i0.ɵɵnextContext().$implicit; const ctx_r8 = i0.ɵɵnextContext(2); return ctx_r8.changeColumnsSortingOrder($event, column_r5.field); });
    i0.ɵɵtext(5, "\n              ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n\n            ");
    i0.ɵɵelementStart(8, "div", 19);
    i0.ɵɵtext(9, "\n              ");
    i0.ɵɵelementStart(10, "button", 20);
    i0.ɵɵlistener("click", function AdaptTableHeaderCellMenuComponent_div_12_div_2_div_22_Template_button_click_10_listener() { i0.ɵɵrestoreView(_r10); const column_r5 = i0.ɵɵnextContext().$implicit; const ctx_r11 = i0.ɵɵnextContext(2); return ctx_r11.onRemoveCurrentFromSorting(column_r5.field); });
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r5 = i0.ɵɵnextContext().$implicit;
    const ctx_r7 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@menuControlAnimation", undefined);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("options", ctx_r7.getSortOrderOptions())("adaptRadarDisableEventSending", true)("optionFormatter", ctx_r7.optionFormatter)("appendToBody", true)("closeOnSelect", true)("ngModel", i0.ɵɵpureFunction1(12, _c1$2, i0.ɵɵpureFunction2(9, _c0$3, column_r5.field, ctx_r7.getSortOrderSelectModelName(column_r5.field))))("label", ctx_r7.headerCellMenuTexts.selectSortOrderLabel);
    i0.ɵɵadvance(7);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r7.headerCellMenuTexts.removeCurrentFromSortingBtn, "\n              ");
} }
const _c2$2 = function (a0) { return { "adapt-table-sort-menu__block_first": a0 }; };
const _c3 = function (a0) { return { "btn-group-padding adapt-table-sort-menu__btn_active": a0 }; };
function AdaptTableHeaderCellMenuComponent_div_12_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r15 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "div", 10);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "label", 11);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelementStart(6, "span");
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n\n          ");
    i0.ɵɵelementStart(10, "div", 12);
    i0.ɵɵtext(11, "\n            ");
    i0.ɵɵelementStart(12, "div", 13);
    i0.ɵɵtext(13, "\n\n              ");
    i0.ɵɵelementStart(14, "button", 14);
    i0.ɵɵlistener("click", function AdaptTableHeaderCellMenuComponent_div_12_div_2_Template_button_click_14_listener() { const restoredCtx = i0.ɵɵrestoreView(_r15); const column_r5 = restoredCtx.$implicit; const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.onSortDirectionChange(ctx_r14.SortOrder.Asc, column_r5.field); });
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n              ");
    i0.ɵɵelementStart(17, "button", 14);
    i0.ɵɵlistener("click", function AdaptTableHeaderCellMenuComponent_div_12_div_2_Template_button_click_17_listener() { const restoredCtx = i0.ɵɵrestoreView(_r15); const column_r5 = restoredCtx.$implicit; const ctx_r16 = i0.ɵɵnextContext(2); return ctx_r16.onSortDirectionChange(ctx_r16.SortOrder.Desc, column_r5.field); });
    i0.ɵɵtext(18);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(19, "\n\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(21, "\n\n          ");
    i0.ɵɵtemplate(22, AdaptTableHeaderCellMenuComponent_div_12_div_2_div_22_Template, 14, 14, "div", 15);
    i0.ɵɵtext(23, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r5 = ctx.$implicit;
    const firstMenu_r6 = ctx.first;
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(18, _c2$2, firstMenu_r6));
    i0.ɵɵadvance(7);
    i0.ɵɵtextInterpolate(ctx_r3.multiSortMeta ? ctx_r3.headerCellMenuTexts.orderLabelAddToSort : ctx_r3.headerCellMenuTexts.orderLabelSort);
    i0.ɵɵadvance(5);
    i0.ɵɵattribute("role", "radiogroup");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("btn-type", ctx_r3.isButtonActive(ctx_r3.SortOrder.Asc, column_r5.field) ? "primary" : "secondary")("adaptRadarDisableEventSending", true)("ngClass", i0.ɵɵpureFunction1(20, _c3, ctx_r3.isButtonActive(ctx_r3.SortOrder.Asc, column_r5.field)))("tabindex", ctx_r3.table.getColumnSortOrder(column_r5.field) === ctx_r3.SortOrder.Asc ? -1 : 0);
    i0.ɵɵattribute("role", "radio")("aria-checked", ctx_r3.isButtonActive(ctx_r3.SortOrder.Asc, column_r5.field));
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r3.headerCellMenuTexts.orderAscBtn, "\n              ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("btn-type", ctx_r3.isButtonActive(ctx_r3.SortOrder.Desc, column_r5.field) ? "primary" : "secondary")("adaptRadarDisableEventSending", true)("ngClass", i0.ɵɵpureFunction1(22, _c3, ctx_r3.isButtonActive(ctx_r3.SortOrder.Desc, column_r5.field)))("tabindex", ctx_r3.table.getColumnSortOrder(column_r5.field) === ctx_r3.SortOrder.Desc ? -1 : 0);
    i0.ɵɵattribute("role", "radio")("aria-checked", ctx_r3.isButtonActive(ctx_r3.SortOrder.Desc, column_r5.field));
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r3.headerCellMenuTexts.orderDescBtn, "\n              ");
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r3.isCurrentColumnAppliedInSort(column_r5.field));
} }
function AdaptTableHeaderCellMenuComponent_div_12_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r18 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "div", 22);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "button", 20);
    i0.ɵɵlistener("click", function AdaptTableHeaderCellMenuComponent_div_12_div_4_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r18); const ctx_r17 = i0.ɵɵnextContext(2); return ctx_r17.onClearAllSorting(); });
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@menuControlAnimation", undefined);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r4.headerCellMenuTexts.clearAllSortingBtn, "\n          ");
} }
function AdaptTableHeaderCellMenuComponent_div_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTableHeaderCellMenuComponent_div_12_div_2_Template, 25, 24, "div", 7);
    i0.ɵɵtext(3, "\n\n      ");
    i0.ɵɵtemplate(4, AdaptTableHeaderCellMenuComponent_div_12_div_4_Template, 8, 2, "div", 8);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r2.columns)("ngForTrackBy", ctx_r2.table.trackByForColumns);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r2.isSortApplied());
} }
class AdaptTableHeaderCellMenuComponent {
    constructor(_ngZone, ts, _dir) {
        this._ngZone = _ngZone;
        this.ts = ts;
        this._dir = _dir;
        this.SortOrder = SortOrder;
        this.isRtl = false;
    }
    get multiSortMeta() {
        return this.table.multiSortMeta;
    }
    ngOnInit() {
        this.isRtl = this._dir.value === 'rtl';
    }
    isSortApplied() {
        return this._getMultiSortMetaLength() >= 1;
    }
    isCurrentColumnAppliedInSort(sortingColumnField) {
        return this._getMultiSortMetaLength() > 1 && this._isColumnSorted(sortingColumnField);
    }
    getSortButtonsClass(order, sortingColumnField) {
        return this.isButtonActive(order, sortingColumnField)
            ? 'btn-primary adapt-table-sort-menu__btn_active'
            : 'btn-secondary';
    }
    getSortOrderOptions() {
        return this.multiSortMeta.map((sortMeta, index) => {
            return {
                id: sortMeta.field,
                name: formatString(this.headerCellMenuTexts.selectSortOrderOption, index + 1, this.multiSortMeta.length)
            };
        });
    }
    isButtonActive(order, sortingColumnField) {
        return this.table.getColumnSortOrder(sortingColumnField) === order;
    }
    optionFormatter(option) {
        return option.name;
    }
    onSortDirectionChange(order, sortingColumnField) {
        if (this.isButtonActive(order, sortingColumnField)) {
            return;
        }
        if (this._getMultiSortMetaLength()) {
            if (this._isColumnSorted(sortingColumnField)) {
                this.table.updateMultiSortMeta(this.multiSortMeta.map(item => {
                    return {
                        field: item.field,
                        order: item.field === sortingColumnField ? order : item.order
                    };
                }));
            }
            else {
                this.table.updateMultiSortMeta([
                    ...this.multiSortMeta,
                    { field: sortingColumnField, order }
                ]);
            }
        }
        else {
            this.table.updateMultiSortMeta([{ field: sortingColumnField, order }]);
        }
    }
    changeColumnsSortingOrder(targetModel, sortingColumnField) {
        const sourceIndex = this.multiSortMeta.findIndex(sortMeta => sortMeta.field === sortingColumnField);
        const targetIndex = this.multiSortMeta.findIndex(sortMeta => sortMeta.field === targetModel[0].id);
        const multiSortMeta = [...this.multiSortMeta];
        const sourceItem = multiSortMeta.splice(sourceIndex, 1);
        multiSortMeta.splice(targetIndex, 0, ...sourceItem);
        this.table.updateMultiSortMeta(multiSortMeta);
    }
    getSortOrderSelectModelName(fieldId) {
        var _a;
        const options = this.getSortOrderOptions();
        return (_a = options.find(option => option.id === fieldId)) === null || _a === void 0 ? void 0 : _a.name;
    }
    onRemoveCurrentFromSorting(sortingColumnField) {
        this.table.updateMultiSortMeta(this.multiSortMeta.filter((sortMeta => sortMeta.field !== sortingColumnField)));
    }
    // Method that implement multiple sorting in PrimeNG(sortMultiple) is overridden in projects/adapt-table/src/lib/primeng-overrides.ts
    // to allow clearing sort and reset table to default sorting state
    onClearAllSorting() {
        this.table.updateMultiSortMeta(null);
    }
    _getMultiSortMetaLength() {
        var _a;
        return (_a = this.multiSortMeta) === null || _a === void 0 ? void 0 : _a.length;
    }
    _isColumnSorted(sortingColumnField) {
        return this.table.isSorted(sortingColumnField);
    }
}
AdaptTableHeaderCellMenuComponent.ɵfac = function AdaptTableHeaderCellMenuComponent_Factory(t) { return new (t || AdaptTableHeaderCellMenuComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i3.Directionality)); };
AdaptTableHeaderCellMenuComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTableHeaderCellMenuComponent, selectors: [["adapt-table-header-cell-menu"]], inputs: { headerCellMenuTexts: "headerCellMenuTexts", columns: "columns", table: "table" }, decls: 16, vars: 9, consts: [["adaptDropdown", "", 3, "adaptRadarDisableEventSending", "appendToBody", "positionTo", "restoreFocusAfterClose", "holdFocusInMenu", "autoClose"], ["headerCellMenuDropdown", "adaptDropdown"], ["adaptDropdownToggle", "", 1, "btn", "btn-link", "d-icon-ellipsis", "adapt-table-sort-menu__kebab", 3, "showCaret"], ["anchorToEl", ""], [1, "sr-only"], ["adaptDropdownMenu", "", 1, "adapt-table-sort-menu__wrapper", "dropdown-menu"], [4, "ngIf"], ["class", "adapt-table-sort-menu__block", 3, "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "adapt-table-sort-menu__clear-all-btn-wrapper", 4, "ngIf"], [1, "adapt-table-sort-menu__block", 3, "ngClass"], [1, "adapt-table-sort-menu__controls"], ["for", "sortButtons", 1, "form-control-label", "mb-2"], ["id", "sortButtons", 1, "adapt-table-sort-menu__btn-wrapper"], [1, "btn-group"], ["type", "button", "adapt-button", "", 3, "btn-type", "adaptRadarDisableEventSending", "ngClass", "tabindex", "click"], ["class", "adapt-table-sort-menu__sort-wrapper", 4, "ngIf"], [1, "adapt-table-sort-menu__sort-wrapper"], [1, "adapt-table-sort-menu__sort-order-select"], [3, "options", "adaptRadarDisableEventSending", "optionFormatter", "appendToBody", "closeOnSelect", "ngModel", "label", "ngModelChange"], [1, "adapt-table-sort-menu__remove-current-btn"], ["type", "button", 1, "btn", "btn-secondary", "w-100", 3, "click"], [1, "adapt-table-sort-menu__clear-all-btn-wrapper"], [1, "adapt-table-sort-menu__clear-all-btn"]], template: function AdaptTableHeaderCellMenuComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵelementStart(3, "button", 2, 3);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementStart(6, "span", 4);
        i0.ɵɵtext(7);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(9, "\n\n  ");
        i0.ɵɵelementStart(10, "div", 5);
        i0.ɵɵtext(11, "\n    ");
        i0.ɵɵtemplate(12, AdaptTableHeaderCellMenuComponent_div_12_Template, 6, 3, "div", 6);
        i0.ɵɵtext(13, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(14, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(15, "\n");
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(1);
        const _r1 = i0.ɵɵreference(4);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true)("positionTo", _r1)("restoreFocusAfterClose", true)("holdFocusInMenu", true)("autoClose", "outside");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("showCaret", false);
        i0.ɵɵadvance(4);
        i0.ɵɵtextInterpolate(ctx.multiSortMeta ? ctx.headerCellMenuTexts.orderLabelAddToSort : ctx.headerCellMenuTexts.orderLabelSort);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", _r0.isOpen());
    } }, directives: [i1.AdaptDropdownDirective, i1.AdaptDropdownToggleDirective, i1.AdaptDropdownMenuDirective, i2$1.NgIf, i2$1.NgForOf, i2$1.NgClass, i1.AdaptButtonComponent, i1.AdaptRxSelectComponent, i5.NgControlStatus, i5.NgModel], encapsulation: 2, data: { animation: [
            trigger('menuControlAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            duration: ANIMATION_DURATION.fast,
                            timingFunction: ANIMATION_TIMING_FUNCTION.base.transitionIn
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            duration: ANIMATION_DURATION.fast,
                            from: '*',
                            to: '0',
                            timingFunction: ANIMATION_TIMING_FUNCTION.base.transitionOut
                        }
                    })
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableHeaderCellMenuComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-table-header-cell-menu',
                templateUrl: './adapt-table-header-cell-menu.html',
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('menuControlAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    duration: ANIMATION_DURATION.fast,
                                    timingFunction: ANIMATION_TIMING_FUNCTION.base.transitionIn
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    duration: ANIMATION_DURATION.fast,
                                    from: '*',
                                    to: '0',
                                    timingFunction: ANIMATION_TIMING_FUNCTION.base.transitionOut
                                }
                            })
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i0.NgZone }, { type: i1.AdaptTranslateService }, { type: i3.Directionality }]; }, { headerCellMenuTexts: [{
            type: Input
        }], columns: [{
            type: Input
        }], table: [{
            type: Input
        }] }); })();

function AdaptTableHeaderCellComponent_ng_container_6_ng_template_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
} }
function AdaptTableHeaderCellComponent_ng_container_6_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵtemplate(1, AdaptTableHeaderCellComponent_ng_container_6_ng_template_3_ng_template_1_Template, 1, 0, "ng-template", 7);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    const columnConfig_r2 = i0.ɵɵnextContext().$implicit;
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", columnConfig_r2.headerTitleTemplate)("ngTemplateOutletContext", ctx_r4.getColumnHeaderTemplateParams(columnConfig_r2));
} }
function AdaptTableHeaderCellComponent_ng_container_6_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵelementStart(1, "span", 8);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n        ");
} if (rf & 2) {
    const columnConfig_r2 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(columnConfig_r2.header);
} }
function AdaptTableHeaderCellComponent_ng_container_6_span_9_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 11);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const columnConfig_r2 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r11 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r11.getDisplayNumberOfSortingOrder(columnConfig_r2), "\n            ");
} }
const _c0$2 = function (a0, a1, a2) { return { "d-icon-sorting": a0, "d-icon-triangle_up_adapt": a1, "d-icon-triangle_down_adapt": a2 }; };
function AdaptTableHeaderCellComponent_ng_container_6_span_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 9);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptTableHeaderCellComponent_ng_container_6_span_9_span_2_Template, 2, 1, "span", 10);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const columnConfig_r2 = i0.ɵɵnextContext().$implicit;
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(4, _c0$2, !ctx_r7.isSortedColumn(columnConfig_r2), ctx_r7.isSortedColumn(columnConfig_r2) && ctx_r7.table.isColumnSortOrderAsc(columnConfig_r2.field), ctx_r7.isSortedColumn(columnConfig_r2) && !ctx_r7.table.isColumnSortOrderAsc(columnConfig_r2.field)))("pSortableColumnDisabled", !ctx_r7.table.isSortableColumn(columnConfig_r2))("pSortableColumn", columnConfig_r2.field);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r7.getDisplayNumberOfSortingOrder(columnConfig_r2));
} }
function AdaptTableHeaderCellComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtemplate(3, AdaptTableHeaderCellComponent_ng_container_6_ng_template_3_Template, 3, 2, "ng-template", 3);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵtemplate(5, AdaptTableHeaderCellComponent_ng_container_6_ng_template_5_Template, 4, 1, "ng-template", null, 4, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵelementStart(7, "span", 5);
    i0.ɵɵtext(8, "\u00A0");
    i0.ɵɵtemplate(9, AdaptTableHeaderCellComponent_ng_container_6_span_9_Template, 4, 8, "span", 6);
    i0.ɵɵtext(10, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const columnConfig_r2 = ctx.$implicit;
    const _r5 = i0.ɵɵreference(6);
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", columnConfig_r2.headerTitleTemplate)("ngIfElse", _r5);
    i0.ɵɵadvance(6);
    i0.ɵɵproperty("ngIf", ctx_r0.table.isSortableColumn(columnConfig_r2));
} }
function AdaptTableHeaderCellComponent_adapt_table_header_cell_menu_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-table-header-cell-menu", 12);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("table", ctx_r1.table)("headerCellMenuTexts", ctx_r1.texts)("columns", ctx_r1.renderingColumn.columnsConfigs);
} }
class AdaptTableHeaderCellComponent {
    constructor(table) {
        this.table = table;
        this.tableClasses = AdaptTableClasses;
    }
    getColumnHeaderTemplateParams(column) {
        return {
            column: column,
            index: this.index,
        };
    }
    getFilterableColumns(columns) {
        return columns.filter(column => this.table.isFilterableColumn(column));
    }
    getDisplayNumberOfSortingOrder(column) {
        const multiSortMeta = this.table.multiSortMeta || [];
        if (this.table.isMultipleSortMode && multiSortMeta.length >= 2) {
            const sortField = column.field;
            const indexOfSort = multiSortMeta.findIndex(sortMeta => sortMeta.field === sortField);
            return indexOfSort >= 0 ? indexOfSort + 1 : null;
        }
        return null;
    }
    isSortedColumn(column) {
        return this.table.isSorted(column.field);
    }
    getSortedColumnSvgViewBox(column) {
        return this.table.isColumnSortOrderAsc(column.field) ? '0 -6 18 24' : '0 6 18 24';
    }
}
AdaptTableHeaderCellComponent.ɵfac = function AdaptTableHeaderCellComponent_Factory(t) { return new (t || AdaptTableHeaderCellComponent)(i0.ɵɵdirectiveInject(AdaptTableComponent)); };
AdaptTableHeaderCellComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTableHeaderCellComponent, selectors: [["adapt-table-header-cell"]], inputs: { renderingColumn: "renderingColumn", index: "index", texts: "texts" }, decls: 16, vars: 14, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "table", "headerCellMenuTexts", "columns", 4, "ngIf"], [3, "columns", "index", "texts"], [3, "ngIf", "ngIfElse"], ["headerTitleDefaultTemplate", ""], [1, "c-header__sort-icon-wrapper"], ["class", "c-header__sort-icon", 3, "ngClass", "pSortableColumnDisabled", "pSortableColumn", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "c-header__separator"], [1, "c-header__sort-icon", 3, "ngClass", "pSortableColumnDisabled", "pSortableColumn"], ["class", "at__sorted-column-number", 4, "ngIf"], [1, "at__sorted-column-number"], [3, "table", "headerCellMenuTexts", "columns"]], template: function AdaptTableHeaderCellComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div");
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelementStart(2, "div");
        i0.ɵɵtext(3, "\n    ");
        i0.ɵɵelementStart(4, "div");
        i0.ɵɵtext(5, "\n      ");
        i0.ɵɵtemplate(6, AdaptTableHeaderCellComponent_ng_container_6_Template, 12, 3, "ng-container", 0);
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n    ");
        i0.ɵɵtemplate(9, AdaptTableHeaderCellComponent_adapt_table_header_cell_menu_9_Template, 2, 3, "adapt-table-header-cell-menu", 1);
        i0.ɵɵtext(10, "\n\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(11, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(12, "\n\n");
        i0.ɵɵelementStart(13, "adapt-table-filters", 2);
        i0.ɵɵtext(14, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(15, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵclassMap(ctx.tableClasses.HeaderContainer);
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("", ctx.tableClasses.HeaderTitle, " text-url-break-out");
        i0.ɵɵclassProp("c-header__separator_no-wrap", !ctx.table.wrapCellText);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", ctx.renderingColumn.columnsConfigs)("ngForTrackBy", ctx.table.trackByForColumns);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.table.isMultipleSortMode && ctx.table.isSortableRenderingColumn(ctx.renderingColumn));
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("columns", ctx.getFilterableColumns(ctx.renderingColumn.columnsConfigs))("index", ctx.index)("texts", ctx.texts);
    } }, directives: [i2$1.NgForOf, i2$1.NgIf, AdaptTableFiltersComponent, i2$1.NgTemplateOutlet, i2$1.NgClass, SortableColumn, AdaptTableHeaderCellMenuComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableHeaderCellComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-table-header-cell',
                templateUrl: './table-header-cell.html'
            }]
    }], function () { return [{ type: AdaptTableComponent }]; }, { renderingColumn: [{
            type: Input
        }], index: [{
            type: Input
        }], texts: [{
            type: Input
        }] }); })();

const _c0$1 = ["paginatorContainer"];
function AdaptPaginatorComponent_div_0_span_3_span_2_ng_template_2_Template(rf, ctx) { }
function AdaptPaginatorComponent_div_0_span_3_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 8);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptPaginatorComponent_div_0_span_3_span_2_ng_template_2_Template, 0, 0, "ng-template", 9);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r1 = i0.ɵɵreference(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r1);
} }
function AdaptPaginatorComponent_div_0_span_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 6);
    i0.ɵɵtext(1);
    i0.ɵɵtemplate(2, AdaptPaginatorComponent_div_0_span_3_span_2_Template, 4, 1, "span", 7);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n    ", ctx_r4.currentPageReport, "\n    ");
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r4.rowsPerPageOptions);
} }
function AdaptPaginatorComponent_div_0_div_5_span_2_ng_template_2_Template(rf, ctx) { }
function AdaptPaginatorComponent_div_0_div_5_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 18);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptPaginatorComponent_div_0_div_5_span_2_ng_template_2_Template, 0, 0, "ng-template", 9);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r1 = i0.ɵɵreference(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r1);
} }
const _c1$1 = function (a0) { return { "ui-state-active": a0 }; };
function AdaptPaginatorComponent_div_0_div_5_ng_template_12_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r18 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 21);
    i0.ɵɵlistener("click", function AdaptPaginatorComponent_div_0_div_5_ng_template_12_button_1_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r18); const pageLink_r12 = i0.ɵɵnextContext().$implicit; const ctx_r16 = i0.ɵɵnextContext(3); return ctx_r16.changePage(pageLink_r12 - 1); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const pageLink_r12 = i0.ɵɵnextContext().$implicit;
    const ctx_r13 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(2, _c1$1, pageLink_r12 === ctx_r13.getPage() + 1));
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n        ", pageLink_r12, "\n      ");
} }
function AdaptPaginatorComponent_div_0_div_5_ng_template_12_ng_template_3_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r25 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵelementStart(1, "div", 25);
    i0.ɵɵtext(2, "\n            ");
    i0.ɵɵelement(3, "input", 26, 27);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelementStart(6, "span", 28);
    i0.ɵɵtext(7, "\n\t\t\t\t\t\t\t");
    i0.ɵɵelementStart(8, "button", 29);
    i0.ɵɵlistener("click", function AdaptPaginatorComponent_div_0_div_5_ng_template_12_ng_template_3_ng_template_1_Template_button_click_8_listener() { i0.ɵɵrestoreView(_r25); const _r23 = i0.ɵɵreference(4); i0.ɵɵnextContext(); const _r22 = i0.ɵɵreference(5); const ctx_r24 = i0.ɵɵnextContext(4); return ctx_r24.onGotoPageClick(_r23.value - 1, _r22); });
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n\t\t\t\t\t\t");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n        ");
} if (rf & 2) {
    const ctx_r21 = i0.ɵɵnextContext(5);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("placeholder", ctx_r21.texts.pageNumberText)("value", ctx_r21.getPage() + 1);
    i0.ɵɵattribute("min", 1)("max", ctx_r21.getPageCount());
    i0.ɵɵadvance(6);
    i0.ɵɵtextInterpolate1("\n                ", ctx_r21.texts.goBtnText, "\n              ");
} }
function AdaptPaginatorComponent_div_0_div_5_ng_template_12_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    const _r27 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵtemplate(1, AdaptPaginatorComponent_div_0_div_5_ng_template_12_ng_template_3_ng_template_1_Template, 13, 5, "ng-template", null, 22, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(3, "\n\n        ");
    i0.ɵɵelementStart(4, "button", 23, 24);
    i0.ɵɵlistener("shown", function AdaptPaginatorComponent_div_0_div_5_ng_template_12_ng_template_3_Template_button_shown_4_listener() { i0.ɵɵrestoreView(_r27); const ctx_r26 = i0.ɵɵnextContext(4); return ctx_r26.onGotoPopoverShown(); });
    i0.ɵɵtext(6, "...\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n\n      ");
} if (rf & 2) {
    const _r20 = i0.ɵɵreference(2);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("adaptPopover", _r20)("adaptRadarDisableEventSending", true)("appendToBody", true)("autoClose", "outside");
} }
function AdaptPaginatorComponent_div_0_div_5_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptPaginatorComponent_div_0_div_5_ng_template_12_button_1_Template, 2, 4, "button", 19);
    i0.ɵɵtext(2, "\n\n      ");
    i0.ɵɵtemplate(3, AdaptPaginatorComponent_div_0_div_5_ng_template_12_ng_template_3_Template, 8, 4, "ng-template", null, 20, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n    ");
} if (rf & 2) {
    const pageLink_r12 = ctx.$implicit;
    const _r14 = i0.ɵɵreference(4);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", pageLink_r12 !== null)("ngIfElse", _r14);
} }
function AdaptPaginatorComponent_div_0_div_5_span_22_ng_template_2_Template(rf, ctx) { }
function AdaptPaginatorComponent_div_0_div_5_span_22_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 18);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptPaginatorComponent_div_0_div_5_span_22_ng_template_2_Template, 0, 0, "ng-template", 9);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵnextContext(3);
    const _r1 = i0.ɵɵreference(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r1);
} }
const _c2$1 = function (a0) { return { "ui-state-disabled": a0 }; };
function AdaptPaginatorComponent_div_0_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r30 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 10);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptPaginatorComponent_div_0_div_5_span_2_Template, 4, 1, "span", 11);
    i0.ɵɵtext(3, "\n\n    ");
    i0.ɵɵelementStart(4, "button", 12);
    i0.ɵɵlistener("click", function AdaptPaginatorComponent_div_0_div_5_Template_button_click_4_listener() { i0.ɵɵrestoreView(_r30); const ctx_r29 = i0.ɵɵnextContext(2); return ctx_r29.changePage(ctx_r29.getPage() - 1); });
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelement(6, "span", 13);
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementStart(8, "span", 14);
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n\n    ");
    i0.ɵɵtemplate(12, AdaptPaginatorComponent_div_0_div_5_ng_template_12_Template, 6, 2, "ng-template", 15);
    i0.ɵɵtext(13, "\n\n    ");
    i0.ɵɵelementStart(14, "button", 16);
    i0.ɵɵlistener("click", function AdaptPaginatorComponent_div_0_div_5_Template_button_click_14_listener() { i0.ɵɵrestoreView(_r30); const ctx_r31 = i0.ɵɵnextContext(2); return ctx_r31.changePage(ctx_r31.getPage() + 1); });
    i0.ɵɵtext(15, "\n      ");
    i0.ɵɵelement(16, "span", 17);
    i0.ɵɵtext(17, "\n      ");
    i0.ɵɵelementStart(18, "span", 14);
    i0.ɵɵtext(19);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(21, "\n\n    ");
    i0.ɵɵtemplate(22, AdaptPaginatorComponent_div_0_div_5_span_22_Template, 4, 1, "span", 11);
    i0.ɵɵtext(23, "\n\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.rowsPerPageOptions && ctx_r5.paginatorAlign === "right");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(10, _c2$1, ctx_r5.isFirstPage()))("disabled", ctx_r5.isFirstPage());
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r5.texts.prevPageBtnText);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", ctx_r5.pagesNumbers)("ngForTrackBy", ctx_r5.trackByForPages);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(12, _c2$1, ctx_r5.isLastPage()))("disabled", ctx_r5.isLastPage());
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(ctx_r5.texts.nextPageBtnText);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r5.rowsPerPageOptions && ctx_r5.paginatorAlign === "left");
} }
function AdaptPaginatorComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r33 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 2, 3);
    i0.ɵɵlistener("elementResize", function AdaptPaginatorComponent_div_0_Template_div_elementResize_0_listener() { i0.ɵɵrestoreView(_r33); const ctx_r32 = i0.ɵɵnextContext(); return ctx_r32.recalculatePageNumbers(); });
    i0.ɵɵtext(2, "\n  ");
    i0.ɵɵtemplate(3, AdaptPaginatorComponent_div_0_span_3_Template, 4, 2, "span", 4);
    i0.ɵɵtext(4, "\n\n  ");
    i0.ɵɵtemplate(5, AdaptPaginatorComponent_div_0_div_5_Template, 24, 14, "div", 5);
    i0.ɵɵtext(6, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r3 = i0.ɵɵreference(1);
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r0.styleClass);
    i0.ɵɵproperty("ngStyle", ctx_r0.style)("ngClass", "ui-paginator ui-widget ui-widget-header ui-unselectable-text ui-helper-clearfix");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r0.showCurrentPageReport);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", _r3);
} }
function AdaptPaginatorComponent_ng_template_2_button_14_Template(rf, ctx) { if (rf & 1) {
    const _r37 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 36);
    i0.ɵɵlistener("click", function AdaptPaginatorComponent_ng_template_2_button_14_Template_button_click_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r37); const rowPerPage_r35 = restoredCtx.$implicit; const ctx_r36 = i0.ɵɵnextContext(2); return ctx_r36.onRppChange({ event: $event, rows: rowPerPage_r35 }); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const rowPerPage_r35 = ctx.$implicit;
    const ctx_r34 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("active", ctx_r34.rows === rowPerPage_r35);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n        ", rowPerPage_r35, "\n      ");
} }
function AdaptPaginatorComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 30);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "button", 31);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementStart(5, "span", 32);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementStart(8, "span", 33);
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n    ");
    i0.ɵɵelementStart(12, "div", 34);
    i0.ɵɵtext(13, "\n      ");
    i0.ɵɵtemplate(14, AdaptPaginatorComponent_ng_template_2_button_14_Template, 2, 3, "button", 35);
    i0.ɵɵtext(15, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n");
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("restoreFocusAfterClose", true)("holdFocusInMenu", true)("appendToBody", true);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("dropdownTogglerType", "link");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r2.texts.recordsPerPage);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r2.rows);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngForOf", ctx_r2.rowsPerPageOptions);
} }
class AdaptPaginatorComponent extends Paginator {
    constructor(_cd, ts, resizeService, ngZone) {
        super(_cd);
        this._cd = _cd;
        this.ts = ts;
        this.resizeService = resizeService;
        this.ngZone = ngZone;
        this.defaultTexts = {};
        this._destroyed$ = new ReplaySubject(1);
    }
    ngOnChanges(changes) {
        if (changes.rows || changes.totalRecords || changes.rowsPerPageOptions) {
            this.ngZone.onStable.pipe(takeUntil(this._destroyed$), take(1)).subscribe(() => {
                // never detectChanges in a subscription to `onStable` without reattaching to the NgZone
                // (onStable always emits outside the NgZone)
                this.ngZone.run(() => {
                    this.recalculatePageNumbers();
                    this.rowsPerPageModel = [{ label: `${this.rows}`, value: this.rows }];
                    this._cd.detectChanges();
                });
            });
        }
        super.ngOnChanges(changes);
    }
    ngAfterViewInit() {
        this.onPageChange.pipe(takeUntil(this._destroyed$)).subscribe(() => {
            this.recalculatePageNumbers();
        });
    }
    recalculatePageNumbers() {
        this.pagesNumbers = this.getPagesNumbers();
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    getPagesNumbers() {
        if (!this.paginatorContainer) {
            return [];
        }
        const smallWidthBreakPoint = 320;
        const middleWidthBreakPoint = 400;
        const largeWidthBreakPoint = 500;
        const paginatorContainerWidth = this.paginatorContainer.nativeElement.offsetWidth;
        const itemsInGroup = paginatorContainerWidth <= middleWidthBreakPoint
            ? 1 : paginatorContainerWidth > middleWidthBreakPoint && paginatorContainerWidth <= largeWidthBreakPoint
            ? 2 : 3;
        const allPagesCount = this.getPageCount();
        if (allPagesCount <= itemsInGroup) {
            // TODO: Refactor this if possible
            // eslint-disable-next-line prefer-spread
            return Array.apply(null, { length: allPagesCount || 1 }).map((a, i) => i + 1);
        }
        const currentPage = this.getPage() + 1;
        const firstPages = [];
        const pages = [];
        for (let i = 1; i <= itemsInGroup; i++) {
            firstPages.push(i);
        }
        pages.push(...firstPages);
        if (currentPage >= itemsInGroup && currentPage <= (allPagesCount + 1 - itemsInGroup)) {
            const middlePages = [];
            if (paginatorContainerWidth >= smallWidthBreakPoint
                && currentPage - 1 > itemsInGroup && currentPage - 1 < (allPagesCount + 1 - itemsInGroup)) {
                middlePages.push(currentPage - 1);
            }
            if (currentPage > itemsInGroup && currentPage < (allPagesCount + 1 - itemsInGroup)) {
                middlePages.push(currentPage);
            }
            if (paginatorContainerWidth >= smallWidthBreakPoint
                && currentPage + 1 > itemsInGroup && currentPage + 1 < (allPagesCount + 1 - itemsInGroup)) {
                middlePages.push(currentPage + 1);
            }
            if (middlePages.length && middlePages[0] - 1 !== pages[pages.length - 1]) {
                pages.push(null);
            }
            pages.push(...middlePages);
        }
        const lastPages = [];
        const maxNumb = pages[pages.length - 1];
        for (let i = allPagesCount - itemsInGroup + 1; i <= allPagesCount; i++) {
            if (maxNumb < i) {
                lastPages.push(i);
            }
        }
        if (lastPages.length && lastPages[0] - 1 !== pages[pages.length - 1]) {
            pages.push(null);
        }
        pages.push(...lastPages);
        return pages;
    }
    onGotoPageClick(pageNumber, adaptPopover) {
        this.changePage(pageNumber);
        adaptPopover.close();
    }
    trackByForPages(index, pageNumber) {
        // by primary key or index
        return pageNumber == null ? index : pageNumber;
    }
    changePage(p) {
        super.changePage(p);
        SafeCdr.detectChanges(this._cd);
    }
    onGotoPopoverShown() {
        SafeCdr.detectChanges(this._cd);
    }
    rowsPerPageOptionFormatter(opt) {
        return `${opt.label}`;
    }
    onRppChange(event) {
        this.rows = event.rows;
        super.onRppChange(event);
    }
}
AdaptPaginatorComponent.ɵfac = function AdaptPaginatorComponent_Factory(t) { return new (t || AdaptPaginatorComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i1.ResizeService), i0.ɵɵdirectiveInject(i0.NgZone)); };
AdaptPaginatorComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptPaginatorComponent, selectors: [["adapt-paginator"]], viewQuery: function AdaptPaginatorComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$1, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.paginatorContainer = _t.first);
    } }, inputs: { texts: "texts", paginatorAlign: "paginatorAlign" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 5, vars: 1, consts: [[3, "class", "ngStyle", "adaptResize", "ngClass", "elementResize", 4, "ngIf"], ["rowsPerPageOptionsTemplate", ""], [3, "ngStyle", "adaptResize", "ngClass", "elementResize"], ["paginatorContainer", ""], ["class", "ui-paginator-current d-flex justify-content-between", 4, "ngIf"], ["class", "d-table", 4, "ngIf"], [1, "ui-paginator-current", "d-flex", "justify-content-between"], ["class", "ui-paginator__row-per-page_small-screen", 4, "ngIf"], [1, "ui-paginator__row-per-page_small-screen"], [3, "ngTemplateOutlet"], [1, "d-table"], ["class", "ui-paginator__row-per-page", 4, "ngIf"], ["type", "button", 1, "ui-paginator-prev", "ui-paginator-element", "ui-state-default", "ui-corner-all", 3, "ngClass", "disabled", "click"], ["aria-hidden", "true", 1, "ui-paginator-icon", "pi", "pi-caret-left"], [1, "sr-only"], ["ngFor", "", 3, "ngForOf", "ngForTrackBy"], ["type", "button", 1, "ui-paginator-next", "ui-paginator-element", "ui-state-default", "ui-corner-all", 3, "ngClass", "disabled", "click"], ["aria-hidden", "true", 1, "ui-paginator-icon", "pi", "pi-caret-right"], [1, "ui-paginator__row-per-page"], ["class", "ui-paginator-page ui-paginator-element ui-state-default ui-corner-all", "type", "button", 3, "ngClass", "click", 4, "ngIf", "ngIfElse"], ["emptyBtn", ""], ["type", "button", 1, "ui-paginator-page", "ui-paginator-element", "ui-state-default", "ui-corner-all", 3, "ngClass", "click"], ["gotoPopover", ""], ["type", "button", 1, "ui-paginator-page", "ui-paginator-element", "ui-state-default", "ui-corner-all", 3, "adaptPopover", "adaptRadarDisableEventSending", "appendToBody", "autoClose", "shown"], ["adaptPopover", "adaptPopover"], [1, "input-group"], ["type", "number", "min", "1", 1, "form-control", "ui-paginator-goto-input", 3, "placeholder", "value"], ["pageNum", ""], [1, "input-group-btn"], ["type", "button", 1, "btn", "btn-secondary", 3, "click"], ["adaptDropdown", "", 1, "d-inline-block", "mx-1", 3, "adaptRadarDisableEventSending", "restoreFocusAfterClose", "holdFocusInMenu", "appendToBody"], ["type", "button", "adapt-button", "", "btn-type", "tertiary", "size", "small", "id", "rowsPerPageOptionsDropdownMenu", "adaptDropdownToggle", "", 3, "adaptRadarDisableEventSending", "dropdownTogglerType"], [1, "ui-paginator__row-per-page-label"], [1, "ui-paginator__row-per-page-label_small-screen"], ["aria-labelledby", "rowsPerPageOptionsDropdownMenu", "adaptDropdownMenu", "", 1, "dropdown-menu"], ["class", "dropdown-item", "type", "button", 3, "active", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "dropdown-item", 3, "click"]], template: function AdaptPaginatorComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptPaginatorComponent_div_0_Template, 7, 6, "div", 0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptPaginatorComponent_ng_template_2_Template, 18, 9, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(4, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.alwaysShow ? true : ctx.pageLinks && ctx.pageLinks.length > 1);
    } }, directives: [i2$1.NgIf, i2$1.NgStyle, i1.AdaptResizeDirective, i2$1.NgClass, i2$1.NgTemplateOutlet, i2$1.NgForOf, i1.AdaptPopoverDirective, i1.AdaptDropdownDirective, i1.AdaptButtonComponent, i1.AdaptDropdownToggleDirective, i1.AdaptDropdownMenuDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptPaginatorComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-paginator',
                templateUrl: './adapt-paginator.html',
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.AdaptTranslateService }, { type: i1.ResizeService }, { type: i0.NgZone }]; }, { texts: [{
            type: Input
        }], paginatorAlign: [{
            type: Input
        }], paginatorContainer: [{
            type: ViewChild,
            args: ['paginatorContainer', { static: false }]
        }] }); })();

// copied from primeng p-tableCheckbox
const _c0 = ["box"];
function AdaptRowSelectionCheckboxComponent_span_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 7);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r0.ariaLabel);
} }
const _c1 = function (a1, a2) { return { "ui-chkbox-box ui-widget ui-state-default": true, "ui-state-active": a1, "ui-state-disabled": a2 }; };
const _c2 = function (a0) { return { "pi pi-check": a0 }; };
class AdaptRowSelectionCheckboxComponent {
    constructor(table) {
        this.table = table;
    }
    ngOnInit() {
        var _a;
        this.subscription = this.table.getTableService().selectionSource$.subscribe(() => {
            this.checked = this.table.isSelected(this.value);
        });
        this.checked = this.table.isSelected(this.value);
        if (isFunction(this.rowAriaDataResolver)) {
            this.ariaLabel = (_a = this.rowAriaDataResolver(this.value)) === null || _a === void 0 ? void 0 : _a.rowSelectionAriaLabel;
        }
    }
    onClick(event) {
        if (!this.disabled) {
            let appliedRangeRowsSelections = false;
            const currentRowId = this.table.getPrimaryKey(this.value);
            if (!this.checked) {
                const lastSelectedRowId = this.table.lastSelectedRowId;
                // range selection with shiftKey
                if (event.shiftKey && lastSelectedRowId && this.table.isRowSelected(lastSelectedRowId)) {
                    const renderingDataRows = this.table.getCurrentPageRenderingDataRows(true);
                    const startRowsSelectionIndex = this.getIndexOfSelectedDataItem(renderingDataRows, currentRowId);
                    if (startRowsSelectionIndex >= 0) {
                        let endRowsSelectionIndex = this.getIndexOfSelectedDataItem(renderingDataRows.slice(startRowsSelectionIndex + 1), currentRowId);
                        if (endRowsSelectionIndex >= 0) {
                            endRowsSelectionIndex += startRowsSelectionIndex + 1;
                            const rowsToAddForSelection = renderingDataRows
                                .slice(startRowsSelectionIndex, endRowsSelectionIndex + 1)
                                .filter(renderingDataRow => {
                                if (renderingDataRow.isGroup) {
                                    return false;
                                }
                                return !this.table.isRowSelected(renderingDataRow.rowData);
                            }).map(renderingDataRow => renderingDataRow.rowData);
                            appliedRangeRowsSelections = true;
                            this.table.addToRowSelection(rowsToAddForSelection);
                        }
                    }
                }
                this.table.lastSelectedRowId = currentRowId;
            }
            if (!appliedRangeRowsSelections) {
                this.table.toggleRowWithCheckbox({
                    originalEvent: event,
                    rowIndex: this.index
                }, this.value);
            }
        }
        DomHandler.clearSelection();
    }
    getIndexOfSelectedDataItem(dataRows, currentRowId) {
        return dataRows.findIndex(dataRow => {
            if (dataRow.isGroup) {
                return false;
            }
            const dataRowId = this.table.getPrimaryKey(dataRow.rowData);
            return dataRowId === this.table.lastSelectedRowId || dataRowId === currentRowId;
        });
    }
    onFocus() {
        DomHandler.addClass(this.boxViewChild.nativeElement, 'ui-state-focus');
    }
    onBlur() {
        DomHandler.removeClass(this.boxViewChild.nativeElement, 'ui-state-focus');
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
AdaptRowSelectionCheckboxComponent.ɵfac = function AdaptRowSelectionCheckboxComponent_Factory(t) { return new (t || AdaptRowSelectionCheckboxComponent)(i0.ɵɵdirectiveInject(AdaptTableComponent)); };
AdaptRowSelectionCheckboxComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRowSelectionCheckboxComponent, selectors: [["adapt-row-selection-checkbox"]], viewQuery: function AdaptRowSelectionCheckboxComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.boxViewChild = _t.first);
    } }, inputs: { renderRowData: "renderRowData", disabled: "disabled", value: "value", index: "index", rowAriaDataResolver: "rowAriaDataResolver" }, decls: 19, vars: 12, consts: [[1, "ui-chkbox", "ui-widget", 3, "click"], [1, "ui-helper-hidden-accessible"], ["type", "checkbox", 3, "checked", "disabled", "focus", "blur"], ["class", "sr-only", 4, "ngIf"], [3, "ngClass"], ["box", ""], [1, "ui-chkbox-icon", "ui-clickable", 3, "ngClass"], [1, "sr-only"]], template: function AdaptRowSelectionCheckboxComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵlistener("click", function AdaptRowSelectionCheckboxComponent_Template_div_click_0_listener($event) { return ctx.onClick($event); });
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelementStart(2, "div", 1);
        i0.ɵɵtext(3, "\n    ");
        i0.ɵɵelementStart(4, "label");
        i0.ɵɵtext(5, "\n      ");
        i0.ɵɵelementStart(6, "input", 2);
        i0.ɵɵlistener("focus", function AdaptRowSelectionCheckboxComponent_Template_input_focus_6_listener() { return ctx.onFocus(); })("blur", function AdaptRowSelectionCheckboxComponent_Template_input_blur_6_listener() { return ctx.onBlur(); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(7, "\n      ");
        i0.ɵɵtemplate(8, AdaptRowSelectionCheckboxComponent_span_8_Template, 2, 1, "span", 3);
        i0.ɵɵtext(9, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(11, "\n  ");
        i0.ɵɵelementStart(12, "div", 4, 5);
        i0.ɵɵtext(14, "\n    ");
        i0.ɵɵelement(15, "span", 6);
        i0.ɵɵtext(16, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("checked", ctx.checked)("disabled", ctx.disabled);
        i0.ɵɵattribute("aria-checked", ctx.checked)("aria-label", ctx.ariaLabel);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.ariaLabel);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction2(7, _c1, ctx.checked, ctx.disabled));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(10, _c2, ctx.checked));
    } }, directives: [i2$1.NgIf, i2$1.NgClass], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRowSelectionCheckboxComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-row-selection-checkbox',
                templateUrl: './row-selection-checkbox.html',
            }]
    }], function () { return [{ type: AdaptTableComponent }]; }, { renderRowData: [{
            type: Input
        }], disabled: [{
            type: Input
        }], value: [{
            type: Input
        }], index: [{
            type: Input
        }], rowAriaDataResolver: [{
            type: Input
        }], boxViewChild: [{
            type: ViewChild,
            args: ['box']
        }] }); })();

class AdaptFrozenColumnDirective {
    constructor(_element, _renderer, _dir) {
        this._element = _element;
        this._renderer = _renderer;
        this._dir = _dir;
        this._frozenClass = 'at-frozen-cell';
        this._isRtl = false;
        this._isRtl = this._dir.value === 'rtl';
    }
    ngOnChanges(changes) {
        if (changes.adaptFrozen.currentValue !== changes.adaptFrozen.previousValue) {
            const paddingDirection = this._isRtl ? 'right' : 'left';
            if (changes.adaptFrozen.currentValue) {
                this._renderer.addClass(this._element.nativeElement, this._frozenClass);
                this._renderer.setStyle(this._element.nativeElement, paddingDirection, this.getFrozenColumnPadding(this._element.nativeElement));
            }
            else {
                this._renderer.removeClass(this._element.nativeElement, this._frozenClass);
                this._renderer.setStyle(this._element.nativeElement, paddingDirection, 'auto');
            }
        }
    }
    getFrozenColumnPadding(cellEl) {
        let siblingColumn = cellEl === null || cellEl === void 0 ? void 0 : cellEl.previousElementSibling;
        let padding = 0;
        while (siblingColumn) {
            padding = padding + siblingColumn.getBoundingClientRect().width;
            siblingColumn = siblingColumn.previousElementSibling;
        }
        return `${padding}px`;
    }
}
AdaptFrozenColumnDirective.ɵfac = function AdaptFrozenColumnDirective_Factory(t) { return new (t || AdaptFrozenColumnDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i3.Directionality)); };
AdaptFrozenColumnDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptFrozenColumnDirective, selectors: [["", "adaptFrozen", ""]], inputs: { adaptFrozen: "adaptFrozen" }, features: [i0.ɵɵNgOnChangesFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptFrozenColumnDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptFrozen]',
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i3.Directionality }]; }, { adaptFrozen: [{
            type: Input
        }] }); })();

// TODO: double check forRoot
class AdaptTableModule {
    static forRoot() {
        return {
            ngModule: AdaptTableModule
        };
    }
}
AdaptTableModule.ɵfac = function AdaptTableModule_Factory(t) { return new (t || AdaptTableModule)(); };
AdaptTableModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptTableModule });
AdaptTableModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            DragDropModule,
            TableModule,
            AdaptTooltipModule,
            AdaptRxSearchModule,
            AdaptRxSelectModule,
            FormsModule,
            AdaptDropdownModule.forRoot(),
            AdaptRxTextfieldModule,
            AdaptRxRadiobuttonModule,
            AdaptPopoverModule.forRoot(),
            AdaptEmptyStateModule,
            AdaptBusyModule,
            AdaptFocusHolderModule,
            AdaptAccordionModule,
            AdaptTagModule,
            AdaptRxCheckboxModule,
            AdaptResizeModule,
            AdaptListKeyManagerModule,
            AdaptButtonModule
        ], TableModule] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTableModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    AdaptTableComponent,
                    AdaptTableFiltersComponent,
                    AdaptTableMergedFiltersComponent,
                    AdaptTableToolbarComponent,
                    AdaptTableActionsComponent,
                    AdaptDataDirective,
                    AdaptFrozenColumnDirective,
                    AdaptTableStateDirective,
                    AdaptTableHeaderCellComponent,
                    AdaptPaginatorComponent,
                    AdaptTableToolbarItemDirective,
                    AdaptHeaderSelectionCheckboxComponent,
                    AdaptRowSelectionCheckboxComponent,
                    AdaptTableHeaderCellMenuComponent,
                    SortByPipe,
                    AdaptSelectMigrationComponent
                ],
                imports: [
                    CommonModule,
                    DragDropModule,
                    TableModule,
                    AdaptTooltipModule,
                    AdaptRxSearchModule,
                    AdaptRxSelectModule,
                    FormsModule,
                    AdaptDropdownModule.forRoot(),
                    AdaptRxTextfieldModule,
                    AdaptRxRadiobuttonModule,
                    AdaptPopoverModule.forRoot(),
                    AdaptEmptyStateModule,
                    AdaptBusyModule,
                    AdaptFocusHolderModule,
                    AdaptAccordionModule,
                    AdaptTagModule,
                    AdaptRxCheckboxModule,
                    AdaptResizeModule,
                    AdaptListKeyManagerModule,
                    AdaptButtonModule
                ],
                exports: [
                    AdaptTableComponent,
                    AdaptTableStateDirective,
                    TableModule
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptTableModule, { declarations: [AdaptTableComponent,
        AdaptTableFiltersComponent,
        AdaptTableMergedFiltersComponent,
        AdaptTableToolbarComponent,
        AdaptTableActionsComponent,
        AdaptDataDirective,
        AdaptFrozenColumnDirective,
        AdaptTableStateDirective,
        AdaptTableHeaderCellComponent,
        AdaptPaginatorComponent,
        AdaptTableToolbarItemDirective,
        AdaptHeaderSelectionCheckboxComponent,
        AdaptRowSelectionCheckboxComponent,
        AdaptTableHeaderCellMenuComponent,
        SortByPipe,
        AdaptSelectMigrationComponent], imports: [CommonModule,
        DragDropModule,
        TableModule,
        AdaptTooltipModule,
        AdaptRxSearchModule,
        AdaptRxSelectModule,
        FormsModule, i1.AdaptDropdownModule, AdaptRxTextfieldModule,
        AdaptRxRadiobuttonModule, i1.AdaptPopoverModule, AdaptEmptyStateModule,
        AdaptBusyModule,
        AdaptFocusHolderModule,
        AdaptAccordionModule,
        AdaptTagModule,
        AdaptRxCheckboxModule,
        AdaptResizeModule,
        AdaptListKeyManagerModule,
        AdaptButtonModule], exports: [AdaptTableComponent,
        AdaptTableStateDirective,
        TableModule] }); })();
i0.ɵɵsetComponentScope(AdaptTableComponent, [i2$1.NgClass, i3$1.CdkDropList, i2$1.NgStyle, i2$1.NgIf, AdaptTableToolbarComponent, i2$1.NgTemplateOutlet, TableBody, i1.AdaptResizeDirective, ScrollableView, AdaptPaginatorComponent, i1.AdaptBusyDirective, i2$1.NgForOf, ResizableColumn, ReorderableColumn, AdaptFrozenColumnDirective,
    AdaptDataDirective,
    AdaptTableHeaderCellComponent,
    AdaptHeaderSelectionCheckboxComponent, i1.AdaptTooltipDirective, i3$1.CdkDrag, i3$1.CdkDragHandle, i1.AdaptRxCheckboxComponent, i5.NgControlStatus, i5.NgModel, EditableRow, i1.AdaptRxRadiobuttonComponent, RowToggler, AdaptRowSelectionCheckboxComponent, i1.AdaptEmptyStateComponent, AdaptTableActionsComponent, i1.AdaptRxTextfieldComponent, i1.AdaptButtonComponent], []);

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const ADAPT_TABLE_VERSION = new Version('12.24.1');

/*
 * Public API Surface of adapt-table-lib
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ADAPT_TABLE_VERSION, AdaptDataDirective, AdaptGridClasses, AdaptPaginatorComponent, AdaptTableActionsComponent, AdaptTableClasses, AdaptTableComponent, AdaptTableEventSource, AdaptTableFilters, AdaptTableFiltersComponent, AdaptTableFiltersService, AdaptTableHeaderCellComponent, AdaptTableHeaderCheckboxToggleSource, AdaptTableHeaderSelectionMode, AdaptTableInfiniteScrollingLoaderComponent, AdaptTableModule, AdaptTableSelectionMachineState, AdaptTableStateDirective, AdaptTableStorageService, AdaptTableToolbarComponent, CheckboxState, EditableRow, ExportType, FilterMatchMode, HtmlUtils, ObjectUtils, RenderingColumnType, ReorderableColumn, ResizableColumn, ResizeDirection, ResizeMode, RowToggler, ScrollableView, SortIcon, SortMode, SortOrder, SortableColumn, StorageType, Table, TableBody, TableModule, ToolbarItemsByPriority, hasRowGroupedData };
//# sourceMappingURL=bmc-ux-adapt-table.js.map
