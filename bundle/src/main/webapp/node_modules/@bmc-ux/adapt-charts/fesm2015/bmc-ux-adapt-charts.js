import * as i0 from '@angular/core';
import { Directive, Input, Output, EventEmitter, Component, ViewEncapsulation, ViewChild, Injectable, HostBinding, ContentChild, Pipe, isDevMode, ViewChildren, ChangeDetectionStrategy, Version, NgModule, NO_ERRORS_SCHEMA } from '@angular/core';
import * as i1 from '@bmc-ux/adapt-angular';
import { SafeCdr, ColorType, getEventKeyCode, isUndefined, getOverlayConnectedPositions, ANIMATION_DURATION, ANIMATION_TIMING_FUNCTION, AdaptTooltipComponent, isString as isString$1, AdaptDropdownToggleDirective, AdaptDropdownDirective, isDefined, adaptError, isFunction as isFunction$1, AdaptListKeyManagerItemDirective, debounce, adaptWarn, toBoolean, AdaptTooltipModule, AdaptSliderModule, AdaptEmptyStateModule, AdaptDropdownModule, AdaptListKeyManagerModule, AdaptIconModule } from '@bmc-ux/adapt-angular';
import { isNull, isString, isUndefined as isUndefined$1, isNumber, isFunction, inRange, cloneDeep, isArray } from 'lodash-es';
import BigNumber from 'bignumber.js';
import * as d3 from 'd3';
import { select } from 'd3';
import { ReplaySubject, timer, asapScheduler, Subject } from 'rxjs';
import * as i3 from '@angular/platform-browser';
import { ComponentPortal } from '@angular/cdk/portal';
import * as i2 from '@angular/cdk/bidi';
import { takeUntil, take } from 'rxjs/operators';
import { TAB, SPACE, ENTER, UP_ARROW, DOWN_ARROW, ESCAPE } from '@angular/cdk/keycodes';
import * as i3$1 from '@angular/common';
import { CommonModule } from '@angular/common';
import { ai_ellipsis } from '@bmc-ux/dpl-iconfont';
import { ListKeyManager } from '@angular/cdk/a11y';
import * as shape from 'd3-shape';
import * as i4 from '@angular/forms';
import { FormsModule } from '@angular/forms';
import * as i5 from '@swimlane/ngx-graph';
import { NgxGraphModule } from '@swimlane/ngx-graph';

class AdaptChartAbstract {
}
AdaptChartAbstract.ɵfac = function AdaptChartAbstract_Factory(t) { return new (t || AdaptChartAbstract)(); };
AdaptChartAbstract.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptChartAbstract, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", noDataText: "noDataText" }, outputs: { clickChart: "clickChart" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptChartAbstract, [{
        type: Directive
    }], null, { backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], legend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], clickChart: [{
            type: Output
        }] }); })();
var AdaptChartSliderType;
(function (AdaptChartSliderType) {
    AdaptChartSliderType["bar"] = "bar";
    AdaptChartSliderType["line"] = "line";
    AdaptChartSliderType["scatterplot"] = "scatterplot";
})(AdaptChartSliderType || (AdaptChartSliderType = {}));

var AdaptStackedChartType;
(function (AdaptStackedChartType) {
    AdaptStackedChartType["Bar"] = "bar";
    AdaptStackedChartType["Column"] = "column";
    AdaptStackedChartType["Area"] = "area";
})(AdaptStackedChartType || (AdaptStackedChartType = {}));
class AdaptStackedChartAbstract extends AdaptChartAbstract {
}
AdaptStackedChartAbstract.ɵfac = /*@__PURE__*/ function () { let ɵAdaptStackedChartAbstract_BaseFactory; return function AdaptStackedChartAbstract_Factory(t) { return (ɵAdaptStackedChartAbstract_BaseFactory || (ɵAdaptStackedChartAbstract_BaseFactory = i0.ɵɵgetInheritedFactory(AdaptStackedChartAbstract)))(t || AdaptStackedChartAbstract); }; }();
AdaptStackedChartAbstract.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptStackedChartAbstract, inputs: { type: "type", xAxis: "xAxis", yAxis: "yAxis", series: "series", hideAxises: "hideAxises", seriesDisplay: "seriesDisplay", showSlider: "showSlider", slidePointsCount: "slidePointsCount" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptStackedChartAbstract, [{
        type: Directive
    }], null, { type: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], series: [{
            type: Input
        }], hideAxises: [{
            type: Input
        }], seriesDisplay: [{
            type: Input
        }], showSlider: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }] }); })();

const _c0$b = ["chart"];
const _c1$8 = ["slider"];
const _c2$5 = ["dnd"];
const _c3$3 = ["overlay"];
const _c4$3 = ["overlayLeft"];
const _c5$2 = ["overlayRight"];
const _c6$1 = function () { return {}; };
function AdaptChartSliderComponent_ng_container_14_adapt_stacked_chart_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-stacked-chart", 11, 12);
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("suppressHeader", true)("suppressLegend", true)("renderLegend", false)("showEmptyColIndicator", false)("legend", null)("hideAxises", true)("xAxis", ctx_r6.xAxis)("yAxis", i0.ɵɵpureFunction0(12, _c6$1))("series", ctx_r6.data)("height", ctx_r6.height - ctx_r6.sliderPaddingTop)("type", ctx_r6.stackedChartType)("seriesDisplay", ctx_r6.stackedChart && ctx_r6.stackedChart.seriesDisplay);
} }
function AdaptChartSliderComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0, 9);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptChartSliderComponent_ng_container_14_adapt_stacked_chart_2_Template, 2, 13, "adapt-stacked-chart", 10);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngSwitch", ctx_r3.type);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", ctx_r3.chartSliderType.bar);
} }
let id = 0;
const classPrefix$1 = 'adapt-chart-slider';
const sliderPaddingTop$1 = 10;
class AdaptChartSliderComponent {
    constructor(_elementRef, _renderer, _changeDetectorRef) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.chartSliderType = AdaptChartSliderType;
        this.stackedChartType = AdaptStackedChartType.Column;
        this.isActive = false;
        this.sliderSpotWidth = 50;
        this.initComplete = false;
        this.height = 45;
        // TODO: has to be refactored
        this.leftShift = 0;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.rangeChanged = new EventEmitter();
        this._inMotion = false;
        this._categoryFilter = [];
        this._x = 0;
        this._destroyed$ = new ReplaySubject(1);
        id++;
        this.id = id;
        this.classPrefix = classPrefix$1;
        this.sliderPaddingTop = sliderPaddingTop$1;
    }
    get overlayLeftWidth() {
        const sliderLeft = this._sliderEl.nativeElement.getBoundingClientRect().left;
        const { left } = this._dndEl.nativeElement.getBoundingClientRect();
        return left - sliderLeft;
    }
    get overlayRightWidth() {
        const sliderLeft = this._sliderEl.nativeElement.getBoundingClientRect().left;
        const sliderWidth = this._sliderEl.nativeElement.getBoundingClientRect().width;
        const { left, width } = this._dndEl.nativeElement.getBoundingClientRect();
        return sliderWidth - (left - sliderLeft) - width;
    }
    ngOnInit() {
        this._dataCopy = this.data.slice();
        this._bodyMouseMoveLn = this._renderer.listen('body', 'mousemove', (e) => {
            if (this._inMotion) {
                const { clientX } = e;
                const { width } = this._dndEl.nativeElement.getBoundingClientRect();
                const sliderWidth = this._sliderEl.nativeElement.getBoundingClientRect().width;
                let x = clientX - this._sliderEl.nativeElement.getBoundingClientRect().left - this._gap;
                x = x < 0 ? 0 : x;
                x = x > sliderWidth - width ? sliderWidth - width : x;
                this._updateOverlay(x);
            }
        });
        this._bodyMouseUpLn = this._renderer.listen('body', 'mouseup', (e) => {
            const { target } = e;
            if (target !== this._dndEl.nativeElement) {
                this.isActive = false;
            }
            this._inMotion = false;
        });
    }
    ngAfterViewInit() {
        const { width } = this._sliderEl.nativeElement.getBoundingClientRect();
        const dataLength = this._getDataLength();
        const monitorsCount = Math.ceil(dataLength / this.slidePointsCount);
        this.monitorsCount = monitorsCount;
        this._width = width;
        this.sliderSpotWidth = width / monitorsCount;
        this._updateOverlay(0);
        this.initComplete = true;
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
        this._bodyMouseMoveLn();
        this._bodyMouseUpLn();
    }
    onMouseDown(e) {
        const { clientX, target } = e;
        const { left } = target.getBoundingClientRect();
        this._gap = Math.floor(clientX - left);
        this._inMotion = true;
    }
    onMouseOver() {
        this.isActive = true;
    }
    onMouseOut() {
        if (!this._inMotion) {
            this.isActive = false;
        }
    }
    onSliderShift(shiftBack) {
        const indicatorCS = getComputedStyle(this._overlayEl.nativeElement);
        const indicatorWidth = parseInt(indicatorCS.width, 10);
        const indicatorLeft = parseInt(indicatorCS.left, 10);
        const sliderWidth = parseInt(getComputedStyle(this._sliderEl.nativeElement).width, 10);
        let newX;
        if (shiftBack) {
            newX = indicatorLeft - indicatorWidth;
            if (newX < 0) {
                newX = 0;
            }
        }
        else {
            newX = indicatorLeft + indicatorWidth;
            if (newX + indicatorWidth > sliderWidth) {
                newX = sliderWidth - indicatorWidth;
            }
        }
        this._updateOverlay(newX);
    }
    onClickSliderArea(e) {
        if (this.isActive) {
            return;
        }
        const { clientX } = e;
        const { left, width } = this._sliderEl.nativeElement.getBoundingClientRect();
        let newLeftSpotPosition = clientX - left - this.sliderSpotWidth / 2;
        newLeftSpotPosition = newLeftSpotPosition < 0 ? 0 : newLeftSpotPosition;
        newLeftSpotPosition = newLeftSpotPosition > width - this.sliderSpotWidth ? width - this.sliderSpotWidth : newLeftSpotPosition;
        this._updateOverlay(newLeftSpotPosition);
    }
    updateSlider(dim) {
        const { height } = this._sliderEl.nativeElement.getBoundingClientRect();
        this._chartComponent.chartComponent.updateChart({
            w: dim.w - this.leftShift,
            h: height - this.sliderPaddingTop * 2
        });
    }
    showCategory(category) {
        const categoryId = this._categoryFilter.indexOf(category);
        if (categoryId !== -1) {
            this._categoryFilter.splice(categoryId, 1);
        }
        this._updateData();
    }
    hideCategory(category) {
        this._categoryFilter.push(category);
        this._updateData();
    }
    _getDataLength() {
        // TODO check for fix
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        return this.data[0].data.length;
    }
    _updateOverlay(x = this._x) {
        if (x !== this._x) {
            this._x = x;
            this._recalculateDataRange();
        }
        this._recalculateSpotPosition();
    }
    _updateData() {
        const timer = setTimeout(() => {
            this.data = this._dataCopy.map((item) => {
                const { name } = item;
                let { data } = item;
                if (this._categoryFilter.indexOf(name) !== -1) {
                    data = data.map(() => 0);
                }
                return { name, data };
            });
            clearTimeout(timer);
        }, 250);
    }
    _recalculateSpotPosition() {
        const { width } = this._sliderEl.nativeElement.getBoundingClientRect();
        const overlayRightWidth = width - this.sliderSpotWidth - this._x;
        const overlayLeftWidth = this._x;
        this._renderer.setStyle(this._dndEl.nativeElement, 'left', `${this._x * 100 / width}%`);
        this._renderer.setStyle(this._overlayEl.nativeElement, 'left', `${this._x * 100 / width}%`);
        this._renderer.setStyle(this._overlayLeftEl.nativeElement, 'width', `${overlayLeftWidth * 100 / width}%`);
        this._renderer.setStyle(this._overlayRightEl.nativeElement, 'width', `${overlayRightWidth * 100 / width}%`);
    }
    _recalculateDataRange() {
        const { width } = this._sliderEl.nativeElement.getBoundingClientRect();
        const count = this._getDataLength();
        const wPiece = width / count;
        this.sliderSpotWidth = width / this.monitorsCount;
        const startPiece = Math.floor(this._x / wPiece);
        const endPiece = Math.floor((this._x + this.sliderSpotWidth) / wPiece);
        if (this._startPoint !== startPiece) {
            this._startPoint = startPiece;
            this._endPoint = endPiece;
            this.rangeChanged.emit({ startPiece, endPiece });
        }
    }
}
AdaptChartSliderComponent.ɵfac = function AdaptChartSliderComponent_Factory(t) { return new (t || AdaptChartSliderComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptChartSliderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptChartSliderComponent, selectors: [["adapt-chart-slider"]], viewQuery: function AdaptChartSliderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$b, 5);
        i0.ɵɵviewQuery(_c1$8, 7);
        i0.ɵɵviewQuery(_c2$5, 7);
        i0.ɵɵviewQuery(_c3$3, 7);
        i0.ɵɵviewQuery(_c4$3, 7);
        i0.ɵɵviewQuery(_c5$2, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._chartComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._sliderEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._dndEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._overlayEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._overlayLeftEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._overlayRightEl = _t.first);
    } }, inputs: { type: "type", data: "data", xAxis: "xAxis", height: "height", slidePointsCount: "slidePointsCount", customColors: "customColors", stackedChart: "stackedChart", leftShift: "leftShift", containerWidth: "containerWidth" }, outputs: { rangeChanged: "rangeChanged" }, decls: 30, vars: 38, consts: [[3, "click"], ["slider", ""], ["overlayLeft", ""], [3, "ngClass", "mouseover", "mouseout", "mousedown"], ["dnd", ""], [3, "keydown.arrowRight", "keydown.arrowLeft"], [3, "ngSwitch", 4, "ngIf"], ["overlay", ""], ["overlayRight", ""], [3, "ngSwitch"], [3, "suppressHeader", "suppressLegend", "renderLegend", "showEmptyColIndicator", "legend", "hideAxises", "xAxis", "yAxis", "series", "height", "type", "seriesDisplay", 4, "ngSwitchCase"], [3, "suppressHeader", "suppressLegend", "renderLegend", "showEmptyColIndicator", "legend", "hideAxises", "xAxis", "yAxis", "series", "height", "type", "seriesDisplay"], ["chart", ""]], template: function AdaptChartSliderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0, 1);
        i0.ɵɵlistener("click", function AdaptChartSliderComponent_Template_div_click_1_listener($event) { return ctx.onClickSliderArea($event); });
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelementStart(4, "div");
        i0.ɵɵtext(5, "\n        ");
        i0.ɵɵelement(6, "div", null, 2);
        i0.ɵɵtext(8, "\n        ");
        i0.ɵɵelementStart(9, "div", 3, 4);
        i0.ɵɵlistener("mouseover", function AdaptChartSliderComponent_Template_div_mouseover_9_listener() { return ctx.onMouseOver(); })("mouseout", function AdaptChartSliderComponent_Template_div_mouseout_9_listener() { return ctx.onMouseOut(); })("mousedown", function AdaptChartSliderComponent_Template_div_mousedown_9_listener($event) { return ctx.onMouseDown($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(11, "\n        ");
        i0.ɵɵelementStart(12, "div", 5);
        i0.ɵɵlistener("keydown.arrowRight", function AdaptChartSliderComponent_Template_div_keydown_arrowRight_12_listener() { return ctx.onSliderShift(); })("keydown.arrowLeft", function AdaptChartSliderComponent_Template_div_keydown_arrowLeft_12_listener() { return ctx.onSliderShift(true); });
        i0.ɵɵtext(13, "\n          ");
        i0.ɵɵtemplate(14, AdaptChartSliderComponent_ng_container_14_Template, 4, 2, "ng-container", 6);
        i0.ɵɵtext(15, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n        ");
        i0.ɵɵelement(17, "div", null, 7);
        i0.ɵɵtext(19, "\n        ");
        i0.ɵɵelement(20, "div", null, 8);
        i0.ɵɵtext(22, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(23, "\n      ");
        i0.ɵɵelementStart(24, "div");
        i0.ɵɵtext(25, "\n        ");
        i0.ɵɵelement(26, "div");
        i0.ɵɵtext(27, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(28, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(29, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵclassMap(ctx.classPrefix);
        i0.ɵɵstyleProp("height", ctx.height, "px")("margin-left", ctx.leftShift, "px");
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-main");
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate2("", ctx.classPrefix, "-side-overlay ", ctx.classPrefix, "-side-overlay-right");
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-spot");
        i0.ɵɵstyleProp("width", 100 / ctx.monitorsCount, "%");
        i0.ɵɵproperty("ngClass", ctx.isActive ? ctx.classPrefix + "-spot-active" : "");
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-chart-zone");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.initComplete);
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-overlay");
        i0.ɵɵstyleProp("width", 100 / ctx.monitorsCount, "%");
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate2("", ctx.classPrefix, "-side-overlay ", ctx.classPrefix, "-side-overlay-left");
        i0.ɵɵadvance(4);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line-wrapper");
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptChartSliderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-chart-slider',
                template: `
    <div #slider
         [class]="classPrefix"
         [style.height.px]="height"
         (click)="onClickSliderArea($event)" [style.marginLeft.px]="leftShift">
      <div class="{{classPrefix}}-main">
        <div #overlayLeft
             class="{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-right"></div>
        <div #dnd
             (mouseover)="onMouseOver()"
             (mouseout)="onMouseOut()"
             (mousedown)="onMouseDown($event)"
             [style.width.%]="100 / monitorsCount"
             class="{{classPrefix}}-spot"
             [ngClass]="isActive ? classPrefix + '-spot-active' : ''"></div>
        <div class="{{classPrefix}}-chart-zone"
             (keydown.arrowRight)="onSliderShift()"
             (keydown.arrowLeft)="onSliderShift(true)">
          <ng-container *ngIf="initComplete" [ngSwitch]="type">
            <adapt-stacked-chart #chart
                                 *ngSwitchCase="chartSliderType.bar"
                                 [suppressHeader]="true"
                                 [suppressLegend]="true"
                                 [renderLegend]="false"
                                 [showEmptyColIndicator]="false"
                                 [legend]="null"
                                 [hideAxises]="true"
                                 [xAxis]="xAxis"
                                 [yAxis]="{}"
                                 [series]="data"
                                 [height]="height - sliderPaddingTop"
                                 [type]="stackedChartType"
                                 [seriesDisplay]="stackedChart && stackedChart.seriesDisplay"></adapt-stacked-chart>
          </ng-container>
        </div>
        <div #overlay class="{{classPrefix}}-overlay" [style.width.%]="100 / monitorsCount"></div>
        <div #overlayRight
             class="{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-left"></div>
      </div>
      <div class="{{classPrefix}}-line-wrapper">
        <div class="{{classPrefix}}-line"></div>
      </div>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, { type: [{
            type: Input
        }], data: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], height: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }], customColors: [{
            type: Input
        }], stackedChart: [{
            type: Input
        }], leftShift: [{
            type: Input
        }], containerWidth: [{
            type: Input
        }], rangeChanged: [{
            type: Output
        }], _chartComponent: [{
            type: ViewChild,
            args: ['chart']
        }], _sliderEl: [{
            type: ViewChild,
            args: ['slider', { static: true }]
        }], _dndEl: [{
            type: ViewChild,
            args: ['dnd', { static: true }]
        }], _overlayEl: [{
            type: ViewChild,
            args: ['overlay', { static: true }]
        }], _overlayLeftEl: [{
            type: ViewChild,
            args: ['overlayLeft', { static: true }]
        }], _overlayRightEl: [{
            type: ViewChild,
            args: ['overlayRight', { static: true }]
        }] }); })();

function nameof(key) {
    return key;
}
/**
 * Function allowing to 'wrap' the text from an SVG <text> element with <tspan>.
 * Based on https://github.com/mbostock/d3/issues/1642
 *
 * @example
 *   svg.append("g")
 *      .attr("class", "x axis")
 *      .attr("transform", "translate(0," + height + ")")
 *      .call(xAxis)
 *      .selectAll(".tick text")
 *          .call(textWrap, x.rangeBand());
 *
 * @param textItems d3.Selection<Element, string, SVGGElement, string> - d3 selection for one or more <text> object
 * @param width number - global width in which the text will be word-wrapped.
 * @param paddingRightLeft number - Padding right and left between the wrapped text and the 'invisible bax' of 'width' width
 * @param paddingTopBottom number - Padding top and bottom between the wrapped text and the 'invisible bax' of 'width' width
 * @returns number[] - Number of lines created by the function, stored in a Array in case multiple <text> element are passed to the function
 */
function textWrap(textItems, width, paddingRightLeft = 5, paddingTopBottom) {
    paddingTopBottom = (paddingTopBottom || 5) - 2; // Default padding (5px), remove 2 pixels because of the borders
    const maxWidth = width; // I store the tooltip max width
    width = width - (paddingRightLeft * 2); // Take the padding into account
    const arrLineCreatedCount = [];
    textItems.each(function () {
        const text = d3.select(this);
        const words = text.text().split(/[ \f\n\r\t\v]+/).reverse(); // Don't cut non-breaking space (\xA0), as well as the Unicode characters \u00A0 \u2028 \u2029)
        const lineHeight = 1.25; // Ems
        const textAlign = text.style('text-anchor') || 'start'; // 'start' by default (start, middle, end, inherit)
        let word;
        let line = [];
        let lineNumber = 0;
        let x;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        let y = text.attr('y');
        let dy = parseFloat(text.attr('dy'));
        let createdLineCount = 1; // Total line created count
        // Clean the data in case <text> does not define those values
        if (isNaN(dy)) {
            dy = 0;
        } // Default padding (0em) : the 'dy' attribute on the first <tspan> _must_ be identical to the 'dy' specified on the <text> element, or start at '0em' if undefined
        // Offset the text position based on the text-anchor
        const wrapTickLabels = d3.select(text.node().parentNode).classed('tick'); // Don't wrap the 'normal untranslated' <text> element and the translated <g class='tick'><text></text></g> elements the same way..
        if (wrapTickLabels) {
            switch (textAlign) {
                case 'start':
                    x = -width / 2;
                    break;
                case 'middle':
                    x = 0;
                    break;
                case 'end':
                    x = 0; // width / 2;
                    break;
                default:
            }
        }
        else { // untranslated <text> elements
            switch (textAlign) {
                case 'start':
                    x = paddingRightLeft;
                    break;
                case 'middle':
                    x = maxWidth / 2;
                    break;
                case 'end':
                    x = maxWidth - paddingRightLeft;
                    break;
                default:
            }
        }
        y = +((null === y) ? paddingTopBottom : y);
        let tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', dy + 'em');
        // eslint-disable-next-line no-cond-assign
        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(' '));
            if (tspan.node().getComputedTextLength() > width && line.length > 1) {
                line.pop();
                tspan.text(line.join(' '));
                line = [word];
                tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);
                ++createdLineCount;
            }
        }
        arrLineCreatedCount.push(createdLineCount); // Store the line count in the array
    });
    return arrLineCreatedCount;
}

var AdaptChartColorStatus;
(function (AdaptChartColorStatus) {
    AdaptChartColorStatus[AdaptChartColorStatus["Default"] = 0] = "Default";
    AdaptChartColorStatus[AdaptChartColorStatus["Success"] = 1] = "Success";
    AdaptChartColorStatus[AdaptChartColorStatus["Warning"] = 2] = "Warning";
    AdaptChartColorStatus[AdaptChartColorStatus["Danger"] = 3] = "Danger";
    AdaptChartColorStatus[AdaptChartColorStatus["Custom"] = 4] = "Custom"; // @since 9.3.0
})(AdaptChartColorStatus || (AdaptChartColorStatus = {}));
const STATUS_COLOR_RANGE = {
    Default: ['#195560', '#267f91'],
    Success: ['#408600', '#5da627'],
    Warning: ['#FFBE00', '#FFE438'],
    Danger: ['#E80B30', '#ff3a49'],
    Custom: ['#0078CC', '#009AF0']
};
class ChartColorsFactory {
    static getGradientColors() {
        return [
            '#488EE7',
            '#1145AC',
            '#8061C5',
            '#7E1E85',
            '#C94FAF',
            '#E9345D',
            '#EF6F70',
            '#DD8A44',
            '#E7B548',
            '#D5DB51',
            '#9DB957',
            '#54C2C3',
            '#89F4F4',
            '#9CD0FB',
            '#AAB2F5',
            '#E6A8D7'
        ];
    }
    static getHighDiffColors() {
        return [
            '#6487EA',
            '#E9862F',
            '#875BCB',
            '#EFB426',
            '#90D1FF',
            '#FF656C',
            '#95BC44',
            '#D83FB4',
            '#00C5C4',
            '#89008A',
            '#D3DD27',
            '#FB025A',
            '#0242B3',
            '#F0A3DA',
            '#62F7F6',
            '#AAB0FA',
        ];
    }
}
class ChartColorService {
    constructor() {
        this._gradientColors = ChartColorsFactory.getGradientColors();
        this._highDiffColorsColors = ChartColorsFactory.getHighDiffColors();
    }
    static getColorRange(range, count) {
        let _temp;
        if (range instanceof Array) {
            _temp = range;
        }
        else {
            switch (range) {
                case (AdaptChartColorStatus.Success): {
                    _temp = STATUS_COLOR_RANGE.Success;
                    break;
                }
                case (AdaptChartColorStatus.Warning): {
                    _temp = STATUS_COLOR_RANGE.Warning;
                    break;
                }
                case (AdaptChartColorStatus.Danger): {
                    _temp = STATUS_COLOR_RANGE.Danger;
                    break;
                }
                default: {
                    _temp = STATUS_COLOR_RANGE.Default;
                    break;
                }
            }
        }
        const _range = [];
        const _scale = d3
            .scaleLinear()
            .range(_temp)
            .domain([1, count]);
        for (let i = 0; i < count; i++) {
            _range.push(d3.color(_scale(i + 1)).hex());
        }
        return _range;
    }
    getColor(id, palette) {
        const colors = palette === 'high-diff' ? this._highDiffColorsColors : this._gradientColors;
        const len = colors.length - 1;
        return colors[id % len];
    }
    getDarken(color, percent, type) {
        const colorRGB = type === ColorType.HEX ? this._parseHEX(color) : this._parseRGB(color);
        Object.keys(colorRGB).forEach((colorComponentName) => {
            colorRGB[colorComponentName] = Math.floor((1 - percent) * colorRGB[colorComponentName]);
        });
        return `#${this._decToHEX(colorRGB.r)}${this._decToHEX(colorRGB.g)}${this._decToHEX(colorRGB.b)}`;
    }
    getContrast(color, type) {
        const channels = type === ColorType.HEX ? this._parseHEX(color) : this._parseRGB(color);
        // Converts the RGB color space into YIQ
        const yiq = ((channels.r * 299) + (channels.g * 587) + (channels.b * 114)) / 1000;
        return (yiq >= 128) ? '#000' : '#fff';
    }
    setColors(newColors) {
        this._gradientColors = newColors;
    }
    _parseHEX(color) {
        const colorCode = color.trim().slice(1);
        let r;
        let g;
        let b;
        // In case if color value passed in short variant (eg. #456 instead of #445566)
        if (colorCode.length === 3) {
            r = parseInt(colorCode.substring(0, 1) + colorCode.substring(0, 1), 16);
            g = parseInt(colorCode.substring(1, 2) + colorCode.substring(1, 2), 16);
            b = parseInt(colorCode.substring(2, 3) + colorCode.substring(2, 3), 16);
        }
        else {
            r = parseInt(colorCode.substring(0, 2), 16);
            g = parseInt(colorCode.substring(2, 4), 16);
            b = parseInt(colorCode.substring(4, 6), 16);
        }
        return { r, g, b };
    }
    _parseRGB(color) {
        const colorTrimmed = color.trim();
        const colorCode = colorTrimmed.substring(4, colorTrimmed.length - 1).replace(/ /g, '').split(',');
        const [r, g, b] = colorCode.map((c) => parseInt(c, 10));
        return { r, g, b };
    }
    _decToHEX(n) {
        const hex = n.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
}
ChartColorService.ɵfac = function ChartColorService_Factory(t) { return new (t || ChartColorService)(); };
ChartColorService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ChartColorService, factory: ChartColorService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ChartColorService, [{
        type: Injectable
    }], null, null); })();

function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "button", 6);
    i0.ɵɵlistener("click", function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template_button_click_2_listener() { const restoredCtx = i0.ɵɵrestoreView(_r10); const id_r8 = restoredCtx.index; const colId_r5 = i0.ɵɵnextContext().index; const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.clickLegend(ctx_r9.columnSize * colId_r5 + id_r8); })("mouseenter", function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template_button_mouseenter_2_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r10); const id_r8 = restoredCtx.index; const colId_r5 = i0.ɵɵnextContext().index; const ctx_r12 = i0.ɵɵnextContext(2); return ctx_r12.enterLegendItem($event, ctx_r12.columnSize * colId_r5 + id_r8); })("mouseleave", function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template_button_mouseleave_2_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r10); const id_r8 = restoredCtx.index; const colId_r5 = i0.ɵɵnextContext().index; const ctx_r14 = i0.ɵɵnextContext(2); return ctx_r14.leaveLegendItem($event, ctx_r14.columnSize * colId_r5 + id_r8); })("mousemove", function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template_button_mousemove_2_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r10); const id_r8 = restoredCtx.index; const colId_r5 = i0.ɵɵnextContext().index; const ctx_r16 = i0.ɵɵnextContext(2); return ctx_r16.moveLegendItem($event, ctx_r16.columnSize * colId_r5 + id_r8); });
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelement(4, "span", 7);
    i0.ɵɵtext(5, "\n              ");
    i0.ɵɵelementStart(6, "span", 8);
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n            ");
    i0.ɵɵelement(10, "br");
    i0.ɵɵtext(11, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const legend_r7 = ctx.$implicit;
    const id_r8 = ctx.index;
    const colId_r5 = i0.ɵɵnextContext().index;
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("adapt-chart-legend-item__hidden", legend_r7.hidden);
    i0.ɵɵattribute("id", ctx_r6.columnSize * colId_r5 + id_r8)("aria-checked", ctx_r6.activeClick ? !legend_r7.hidden : null)("aria-selected", ctx_r6.activeClick ? !legend_r7.hidden : null)("type", ctx_r6.activeClick ? "button" : null)("role", ctx_r6.activeClick ? "option" : "listitem");
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("border-color", ctx_r6.getBorderColorById(ctx_r6.columnSize * colId_r5 + id_r8))("background-color", ctx_r6.getColorById(ctx_r6.columnSize * colId_r5 + id_r8));
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("text-active", ctx_r6.legendFocus && ctx_r6.activeOption === ctx_r6.columnSize * colId_r5 + id_r8);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(legend_r7.item);
} }
function ChartLegendComponent_ng_container_3_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 4);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template, 12, 14, "ng-container", 5);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r4 = ctx.$implicit;
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", column_r4)("ngForTrackBy", ctx_r3.trackByIndex);
} }
function ChartLegendComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, ChartLegendComponent_ng_container_3_div_2_Template, 4, 2, "div", 3);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r0.columns)("ngForTrackBy", ctx_r0.trackByIndex);
} }
function ChartLegendComponent_ng_template_5_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r23 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 10);
    i0.ɵɵlistener("click", function ChartLegendComponent_ng_template_5_button_1_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r23); const id_r21 = restoredCtx.index; const ctx_r22 = i0.ɵɵnextContext(2); return ctx_r22.clickLegend(id_r21); });
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelement(2, "span", 7);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "div", 8);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelementStart(6, "div");
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const category_r20 = ctx.$implicit;
    const id_r21 = ctx.index;
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("border-color", ctx_r19.getBorderColorById(id_r21))("background-color", ctx_r19.getColorById(id_r21));
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(category_r20.item);
} }
function ChartLegendComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵtemplate(1, ChartLegendComponent_ng_template_5_button_1_Template, 10, 5, "button", 9);
    i0.ɵɵtext(2, "\n      ");
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r2.legend);
} }
const _c0$a = function (a0) { return { "adapt-chart-legend-mouse-over": a0 }; };
class ChartLegendComponent {
    constructor(_chartColorService, _deviceDetectionService, _sanitize, _ngZone) {
        this._chartColorService = _chartColorService;
        this._deviceDetectionService = _deviceDetectionService;
        this._sanitize = _sanitize;
        this._ngZone = _ngZone;
        this.mainCls = '';
        this.isScrolled = false;
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.columnsCount = 1;
        this.focusable = true;
        this.categoryShow = new EventEmitter();
        this.categoryHide = new EventEmitter();
        this.categoryEnter = new EventEmitter();
        this.categoryLeave = new EventEmitter();
        this.categoryMove = new EventEmitter();
        this.legend = [];
        this.columns = [];
        this.isMouseOver = this.isMobile;
        this.activeOption = null;
        this.legendFocus = false;
        this._destroyed$ = new ReplaySubject(1);
    }
    get isMobile() {
        return this._deviceDetectionService.deviceTablet() || this._deviceDetectionService.deviceMobile();
    }
    ngOnInit() {
        this.initLegend();
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    legendKeydownHandler(event) {
        var _a;
        switch (getEventKeyCode(event)) {
            case DOWN_ARROW:
            case UP_ARROW: {
                (_a = this._listKeyManager) === null || _a === void 0 ? void 0 : _a.onKeydown(event);
                break;
            }
            case ENTER:
            case SPACE: {
                if (!isNull(this.activeOption)) {
                    event.preventDefault();
                    this.clickLegend(this.activeOption);
                }
                break;
            }
            case TAB: {
                this.toggleMouseOverStatus();
                break;
            }
        }
    }
    keyManagerStateChange(listKeyManager) {
        var _a;
        this._listKeyManager = listKeyManager;
        this._ngZone.onStable
            .pipe(takeUntil(this._destroyed$), take(1))
            .subscribe(() => {
            var _a;
            (_a = this._listKeyManager) === null || _a === void 0 ? void 0 : _a.setFirstItemActive();
        });
        (_a = this._listKeyManager) === null || _a === void 0 ? void 0 : _a.change.pipe(takeUntil(this._destroyed$)).subscribe(() => {
            this.activeOption = this._listKeyManager.activeItemIndex;
        });
    }
    parseColumns() {
        let columns = (new Array(this.columnsCount)).fill([]);
        columns = columns.map((col, colId) => {
            const start = colId * this.columnSize;
            const items = this.legend.slice();
            const end = start + this.columnSize;
            return items.slice(start, end);
        });
        this.columns = columns;
        if (!this.legend || !this.legend.length || this.legend.length !== this.items.length) {
            this.initLegend();
        }
    }
    getColorById(id) {
        const defaultColor = this.customColors ? this.customColors[id] : this._chartColorService.getColor(id, this.colorsPalette);
        const hoverColor = this._chartColorService.getDarken(defaultColor, .14, ColorType.HEX);
        const color = this.legend[id].hover ? hoverColor : defaultColor;
        return this._sanitize.bypassSecurityTrustStyle(color);
    }
    getBorderColorById(id) {
        const backgroundColor = this.customColors ? this.customColors[id] : this._chartColorService.getColor(id, this.colorsPalette);
        const defaultBorderColor = this._chartColorService.getDarken(backgroundColor, .14, ColorType.HEX);
        const hoverBorderColor = this._chartColorService.getDarken(backgroundColor, .24, ColorType.HEX);
        const borderColor = this.legend[id].hover ? hoverBorderColor : defaultBorderColor;
        return this._sanitize.bypassSecurityTrustStyle(borderColor);
    }
    clickLegend(id) {
        const legend = this.legend[id];
        if (isNull(id) || !this.activeClick) {
            return;
        }
        if (legend.hidden) {
            this._showCategory(legend);
        }
        else {
            this._hideCategory(legend);
        }
    }
    toggleMouseOverStatus() {
        if (!this.activeHover) {
            return;
        }
        if (this.isMobile) {
            this.isMouseOver = true;
            return;
        }
        this.isMouseOver = !this.isMouseOver;
    }
    enterLegendItem(event, id) {
        this.activeOption = id;
        this.legend[id].hover = true;
        this.categoryEnter.emit({ id, event });
    }
    leaveLegendItem(event, id) {
        this.legend[id].hover = false;
        this.categoryLeave.emit({ id, event });
    }
    moveLegendItem(event, id) {
        this.categoryMove.emit({ id, event });
    }
    update(items) {
        this.items = items;
        this.legend = this._getLegend();
        this.columnSize = Math.ceil(this.items.length / this.columnsCount);
        this.parseColumns();
    }
    initLegend() {
        if (isUndefined(this.items) || !this.items.length || isNull(this.items)) {
            return;
        }
        this.activeHover = isUndefined(this.activeHover) ? true : this.activeHover;
        this.activeClick = isUndefined(this.activeClick) ? true : this.activeClick;
        this.legend = this._getLegend();
        this.columnSize = Math.ceil(this.items.length / this.columnsCount);
        this.parseColumns();
    }
    trackByIndex(index) {
        return index;
    }
    _getLegend() {
        return isString(this.items[0])
            ? this.items.map((item) => ({ item, hidden: false, hover: false }))
            : this.items.map((item) => ({ item: item.item, hidden: item.hidden, hover: false }));
    }
    _showCategory(legend) {
        legend.hidden = false;
        this.categoryShow.emit(legend.item);
    }
    _hideCategory(legend) {
        const visibleCount = this.legend.filter((l) => !l.hidden).length;
        if (visibleCount === 1) {
            return;
        }
        legend.hidden = true;
        this.categoryHide.emit(legend.item);
    }
}
ChartLegendComponent.id = 0;
ChartLegendComponent.ɵfac = function ChartLegendComponent_Factory(t) { return new (t || ChartLegendComponent)(i0.ɵɵdirectiveInject(ChartColorService), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i3.DomSanitizer), i0.ɵɵdirectiveInject(i0.NgZone)); };
ChartLegendComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ChartLegendComponent, selectors: [["adapt-chart-legend"]], hostVars: 4, hostBindings: function ChartLegendComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.mainCls);
        i0.ɵɵclassProp("adapt-chart-legend-scrolled", ctx.isScrolled);
    } }, inputs: { mainCls: "mainCls", items: "items", columnsCount: ["columns", "columnsCount"], customColors: "customColors", colorsPalette: "colorsPalette", activeHover: "activeHover", activeClick: "activeClick", width: "width", focusable: "focusable" }, outputs: { categoryShow: "categoryShow", categoryHide: "categoryHide", categoryEnter: "categoryEnter", categoryLeave: "categoryLeave", categoryMove: "categoryMove" }, decls: 9, vars: 12, consts: [["adaptListKeyManager", "", "tabindex", "0", 1, "adapt-chart-legend", 3, "ngClass", "keyManagerStateChange", "keydown", "keyup.tab", "mouseenter", "mouseleave", "focus", "blur"], [4, "ngIf", "ngIfElse"], ["mobileLegend", ""], ["class", "adapt-chart-legend-col", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "adapt-chart-legend-col"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["adaptListKeyManagerItem", "", "tabindex", "-1", 1, "adapt-chart-legend-item", 3, "click", "mouseenter", "mouseleave", "mousemove"], [1, "adapt-chart-legend-item-color"], [1, "adapt-chart-legend-item-text"], ["class", "adapt-chart-legend-item", "type", "button", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "adapt-chart-legend-item", 3, "click"]], template: function ChartLegendComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵlistener("keyManagerStateChange", function ChartLegendComponent_Template_div_keyManagerStateChange_1_listener($event) { return ctx.keyManagerStateChange($event); })("keydown", function ChartLegendComponent_Template_div_keydown_1_listener($event) { return ctx.legendKeydownHandler($event); })("keyup.tab", function ChartLegendComponent_Template_div_keyup_tab_1_listener() { return ctx.toggleMouseOverStatus(); })("mouseenter", function ChartLegendComponent_Template_div_mouseenter_1_listener() { return ctx.toggleMouseOverStatus(); })("mouseleave", function ChartLegendComponent_Template_div_mouseleave_1_listener() { return ctx.toggleMouseOverStatus(); })("focus", function ChartLegendComponent_Template_div_focus_1_listener() { return ctx.legendFocus = true; })("blur", function ChartLegendComponent_Template_div_blur_1_listener() { return ctx.legendFocus = false; });
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵtemplate(3, ChartLegendComponent_ng_container_3_Template, 4, 2, "ng-container", 1);
        i0.ɵɵtext(4, "\n\n      ");
        i0.ɵɵtemplate(5, ChartLegendComponent_ng_template_5_Template, 3, 1, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n  ");
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(6);
        i0.ɵɵadvance(1);
        i0.ɵɵstyleProp("width", ctx.isMobile ? "100%" : ctx.width + "px");
        i0.ɵɵclassProp("adapt-chart-legend-mobile", ctx.isMobile);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(10, _c0$a, ctx.isMouseOver));
        i0.ɵɵattribute("role", ctx.activeClick ? "listbox" : "list")("aria-multiselectable", ctx.activeClick ? true : null)("aria-activedescendant", ctx.activeOption);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.isMobile)("ngIfElse", _r1);
    } }, directives: [i1.AdaptListKeyManagerDirective, i3$1.NgClass, i3$1.NgIf, i3$1.NgForOf, i1.AdaptListKeyManagerItemDirective], styles: ["[_nghost-%COMP%] {\n      position: relative;\n    }\n\n    .adapt-chart-legend-item[_ngcontent-%COMP%] {\n      background: transparent;\n      border: none;\n    }"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ChartLegendComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-chart-legend',
                template: `
    <div adaptListKeyManager
         tabindex="0"
         class="adapt-chart-legend"
         [class.adapt-chart-legend-mobile]="isMobile"
         [ngClass]="{ 'adapt-chart-legend-mouse-over': isMouseOver }"
         [style.width]="isMobile ? '100%' : width + 'px'"
         [attr.role]="activeClick ? 'listbox' : 'list'"
         [attr.aria-multiselectable]="activeClick ? true : null"
         [attr.aria-activedescendant]="activeOption"
         (keyManagerStateChange)="keyManagerStateChange($event)"
         (keydown)="legendKeydownHandler($event)"
         (keyup.tab)="toggleMouseOverStatus()"
         (mouseenter)="toggleMouseOverStatus()"
         (mouseleave)="toggleMouseOverStatus()"
         (focus)="legendFocus = true"
         (blur)="legendFocus = false">
      <ng-container *ngIf="!isMobile; else mobileLegend">
        <div class="adapt-chart-legend-col"
             *ngFor="let column of columns; let colId = index; trackBy: trackByIndex">
          <ng-container *ngFor="let legend of column; let id = index; trackBy: trackByIndex">
            <button adaptListKeyManagerItem
                    tabindex="-1"
                    class="adapt-chart-legend-item"
                    [class.adapt-chart-legend-item__hidden]="legend.hidden"
                    [attr.id]="columnSize*colId + id"
                    [attr.aria-checked]="activeClick ? !legend.hidden : null"
                    [attr.aria-selected]="activeClick ? !legend.hidden : null"
                    [attr.type]="activeClick ? 'button' : null"
                    [attr.role]="activeClick ? 'option' : 'listitem'"
                    (click)="clickLegend(columnSize*colId + id)"
                    (mouseenter)="enterLegendItem($event, columnSize*colId + id)"
                    (mouseleave)="leaveLegendItem($event, columnSize*colId + id)"
                    (mousemove)="moveLegendItem($event, columnSize*colId + id)">
              <span class="adapt-chart-legend-item-color"
                    [style.border-color]="getBorderColorById(columnSize*colId + id)"
                    [style.background-color]="getColorById(columnSize*colId + id)"></span>
              <span class="adapt-chart-legend-item-text"
                    [class.text-active]="legendFocus && (activeOption === columnSize*colId + id)">{{legend.item}}</span>
            </button>
            <br/>
          </ng-container>
        </div>
      </ng-container>

      <ng-template #mobileLegend>
        <button class="adapt-chart-legend-item"
                type="button"
                *ngFor="let category of legend; let id = index;"
                (click)="clickLegend(id)">
          <span class="adapt-chart-legend-item-color"
                [style.border-color]="getBorderColorById(id)"
                [style.background-color]="getColorById(id)"></span>
          <div class="adapt-chart-legend-item-text">
            <div>{{category.item}}</div>
          </div>
        </button>
      </ng-template>
    </div>
  `,
                styles: [`
    :host {
      position: relative;
    }

    .adapt-chart-legend-item {
      background: transparent;
      border: none;
    }
  `]
            }]
    }], function () { return [{ type: ChartColorService }, { type: i1.AdaptDeviceDetectionService }, { type: i3.DomSanitizer }, { type: i0.NgZone }]; }, { mainCls: [{
            type: HostBinding,
            args: ['class']
        }, {
            type: Input
        }], isScrolled: [{
            type: HostBinding,
            args: ['class.adapt-chart-legend-scrolled']
        }], items: [{
            type: Input
        }], columnsCount: [{
            type: Input,
            args: ['columns']
        }], customColors: [{
            type: Input
        }], colorsPalette: [{
            type: Input
        }], activeHover: [{
            type: Input
        }], activeClick: [{
            type: Input
        }], width: [{
            type: Input
        }], focusable: [{
            type: Input
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], categoryEnter: [{
            type: Output
        }], categoryLeave: [{
            type: Output
        }], categoryMove: [{
            type: Output
        }] }); })();

const _c0$9 = ["svgBrushContainer"];
const _c1$7 = ["slider"];
const _c2$4 = ["chart"];
function AdaptAreaGraphSliderComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelement(2, "div");
    i0.ɵɵtext(3, "\n\n        ");
    i0.ɵɵelement(4, "div", 6);
    i0.ɵɵtext(5, "\n\n        ");
    i0.ɵɵelement(6, "div");
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate2("", ctx_r3.classPrefix, "-side-overlay ", ctx_r3.classPrefix, "-side-overlay-right");
    i0.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("height", ctx_r3.height, "px")("width", ctx_r3.getXPos(), "px");
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("", ctx_r3.classPrefix, "-spot");
    i0.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("z-index", 1)("height", ctx_r3.height + 5, "px")("width", ctx_r3.brushWidth, "px")("left", ctx_r3.getXPos(), "px");
    i0.ɵɵproperty("ngClass", ctx_r3.isActive ? ctx_r3.classPrefix + "-spot-active" : "");
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate2("", ctx_r3.classPrefix, "-side-overlay ", ctx_r3.classPrefix, "-side-overlay-left");
    i0.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("height", ctx_r3.height, "px")("left", ctx_r3.getXOverlayPos(), "px")("width", ctx_r3.getRightOverlayWidth(), "px");
} }
const _c3$2 = function () { return {}; };
const _c4$2 = function () { return []; };
const _c5$1 = function (a0, a1) { return { items: a0, customColors: a1 }; };
const classPrefix = 'adapt-chart-slider';
const sliderPaddingTop = 10; // need to be aligned with the css $slider-padding-top: 10;
class AdaptAreaGraphSliderComponent {
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        this.isInitialized = false;
        this.isActive = false;
        this.height = 35;
        this.leftShift = 0;
        this.rangeChanged = new EventEmitter();
        this.scrollEnd = new EventEmitter();
        this._cX = 0;
        this._inMotion = false;
        this._destroyed$ = new ReplaySubject(1);
        this.classPrefix = classPrefix;
        this.sliderPaddingTop = sliderPaddingTop;
    }
    ngOnInit() {
        this._ngZone.onStable
            .pipe(takeUntil(this._destroyed$), take(1))
            .subscribe(() => {
            this.isInitialized = true;
        });
    }
    ngOnChanges(changes) {
        if (this.isInitialized && changes.slidePointsCount) {
            this._g.select('.brush-wrp').remove();
            this._initBrush();
        }
    }
    ngAfterViewInit() {
        this._g = d3.select(this._svgContainerEl.nativeElement);
        this._xMinValue = this._chartComponent.getXMinValue(this.data);
        this._xMaxValue = this._chartComponent.getXMaxValue(this.data);
        this._renderBrushXAxis();
        this._initBrush();
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    getXPos() {
        return parseFloat(this._dndEl.getAttribute('x')) || 0;
    }
    getXOverlayPos() {
        return this.getXPos() + this.brushWidth;
    }
    getRightOverlayWidth() {
        return this.containerWidth - this.leftShift - this.getXOverlayPos();
    }
    showCategory(category) {
        this._chartComponent.categoryShowHandler(category);
    }
    hideCategory(category) {
        this._chartComponent.categoryHideHandler(category);
    }
    updateSlider(dim) {
        this.containerWidth = dim.w;
        const { height } = this._sliderEl.nativeElement.getBoundingClientRect();
        this._chartComponent._updateChart({
            w: dim.w - this.leftShift,
            h: height - this.sliderPaddingTop * 2
        });
        this.xBrush = d3.scaleLinear()
            .range([0, dim.w - this.leftShift])
            .domain([this._xMinValue, this._xMaxValue]);
        const x = this._g.select('.axis--x');
        x.call(this._getXAxisLineRenderer());
        this._g.select('.brush-wrp').remove();
        this._initBrush();
    }
    _renderBrushXAxis() {
        this._g
            .append('g').attr('class', 'axis axis--x')
            .attr('transform', `translate(0, ${this.height})`)
            .call(this._getXAxisLineRenderer());
    }
    _getXAxisLineRenderer() {
        return d3.axisBottom(this.xBrush);
    }
    _initBrush() {
        // TODO check for refactoring
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const _self = this;
        this._brush = d3.brushX()
            .extent([[0, 0], [this.containerWidth - this.leftShift, this.height]])
            .on('brush', function () {
            _self._brushed();
        })
            .on('end.brush', function () {
            _self.scrollEnd.emit();
        });
        this.brushWidth = Math.ceil(this.xBrush((this.xBrush).ticks()[this.slidePointsCount]));
        this._initBrushHandlers();
    }
    _initBrushHandlers() {
        // TODO check for refactoring
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const _self = this;
        this._g
            .append('g').attr('class', 'brush-wrp')
            .append('g').attr('class', 'brush')
            .call(this._brush)
            .call(this._brush.move, [this._cX, this._cX + this.brushWidth])
            .call(g => g.select('.selection').attr('stroke', null).attr('fill-opacity', '0.1')
            .on('mouseover', function () {
            _self.isActive = true;
        })
            .on('mousedown', function () {
            _self._inMotion = true;
        })
            .on('mouseout', function () {
            if (!_self._inMotion) {
                _self.isActive = false;
            }
        }))
            .call(g => g.select('.overlay')
            .datum({ type: 'selection' })
            .on('mousedown', function () {
            const [cx] = d3.mouse(this);
            const [x0, x1] = [cx - _self.brushWidth / 2, cx + _self.brushWidth / 2];
            const [r0, r1] = _self.xBrush.range();
            d3.select(this.parentNode)
                .call(_self._brush.move, x1 > r1
                ? [r1 - _self.brushWidth, r1]
                : x0 < r0
                    ? [r0, r0 + _self.brushWidth]
                    : [x0, x1]);
        }));
        // prevent resizing
        this._g.selectAll('.brush-wrp > .brush > .handle').remove();
        this._dndEl = this._svgContainerEl.nativeElement.querySelector('rect.selection');
    }
    _brushed() {
        this._cX = d3.event.selection[0];
        const selection = d3.event.selection || this.xBrush.range();
        this.rangeChanged.emit(selection.map((this.xBrush).invert, this.xBrush));
        this._inMotion = false;
    }
}
AdaptAreaGraphSliderComponent.ɵfac = function AdaptAreaGraphSliderComponent_Factory(t) { return new (t || AdaptAreaGraphSliderComponent)(i0.ɵɵdirectiveInject(i0.NgZone)); };
AdaptAreaGraphSliderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptAreaGraphSliderComponent, selectors: [["adapt-area-graph-slider"]], viewQuery: function AdaptAreaGraphSliderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$9, 5);
        i0.ɵɵviewQuery(_c1$7, 5);
        i0.ɵɵviewQuery(_c2$4, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._svgContainerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._sliderEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._chartComponent = _t.first);
    } }, inputs: { xAxis: "xAxis", height: "height", slidePointsCount: "slidePointsCount", customColors: "customColors", xBrush: "xBrush", leftShift: "leftShift", containerWidth: "containerWidth", data: "data" }, outputs: { rangeChanged: "rangeChanged", scrollEnd: "scrollEnd" }, features: [i0.ɵɵNgOnChangesFeature], decls: 19, vars: 28, consts: [["slider", ""], [3, "xAxis", "yAxis", "legend", "series", "height", "disallowPadding", "supressAxles", "suppressLegend"], ["chart", ""], ["xmlns", "http://www.w3.org/2000/svg", "tabindex", "-1", "role", "graphic/image", "aria-describedby", "title desc", 1, "adapt-chart-slider-brush-svg"], ["svgBrushContainer", ""], [4, "ngIf"], [3, "ngClass"]], template: function AdaptAreaGraphSliderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", null, 0);
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelement(4, "adapt-area-graph", 1, 2);
        i0.ɵɵtext(6, "\n\n      ");
        i0.ɵɵnamespaceSVG();
        i0.ɵɵelementStart(7, "svg", 3, 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n\n      ");
        i0.ɵɵtemplate(11, AdaptAreaGraphSliderComponent_ng_container_11_Template, 8, 36, "ng-container", 5);
        i0.ɵɵtext(12, "\n\n      ");
        i0.ɵɵnamespaceHTML();
        i0.ɵɵelementStart(13, "div");
        i0.ɵɵtext(14, "\n        ");
        i0.ɵɵelement(15, "div");
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵclassMap(ctx.classPrefix);
        i0.ɵɵstyleProp("margin-left", ctx.leftShift, "px");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("xAxis", ctx.xAxis)("yAxis", i0.ɵɵpureFunction0(23, _c3$2))("legend", i0.ɵɵpureFunction2(25, _c5$1, i0.ɵɵpureFunction0(24, _c4$2), ctx.customColors))("series", ctx.data)("height", ctx.height)("disallowPadding", true)("supressAxles", true)("suppressLegend", true);
        i0.ɵɵadvance(3);
        i0.ɵɵattributeInterpolate2("viewbox", "0 0 ", ctx.containerWidth - ctx.leftShift, " ", ctx.height, "");
        i0.ɵɵattribute("width", ctx.containerWidth - ctx.leftShift)("height", ctx.height);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.isInitialized);
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line-wrapper");
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptAreaGraphSliderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-area-graph-slider',
                template: `
    <div #slider
         [class]="classPrefix"
         [style.marginLeft.px]="leftShift">
      <adapt-area-graph #chart
                        [xAxis]="xAxis"
                        [yAxis]="{}"
                        [legend]="{items: [], customColors: customColors}"
                        [series]="data"
                        [height]="height"
                        [disallowPadding]="true"
                        [supressAxles]="true"
                        [suppressLegend]="true"></adapt-area-graph>

      <svg xmlns="http://www.w3.org/2000/svg" #svgBrushContainer
           class="adapt-chart-slider-brush-svg"
           tabindex="-1"
           role="graphic/image"
           aria-describedby="title desc"
           attr.viewbox="0 0 {{containerWidth - leftShift}} {{height}}"
           [attr.width]="containerWidth - leftShift"
           [attr.height]="height">
      </svg>

      <ng-container *ngIf="isInitialized">
        <div class="{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-right"
             [style.top.px]="sliderPaddingTop"
             [style.height.px]="height"
             [style.width.px]="getXPos()"></div>

        <div class="{{classPrefix}}-spot"
             [style.top.px]="sliderPaddingTop"
             [style.zIndex]="1"
             [style.height.px]="height + 5"
             [style.width.px]="brushWidth"
             [style.left.px]="getXPos()"
             [ngClass]="isActive ? classPrefix + '-spot-active' : ''"></div>

        <div class="{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-left"
             [style.top.px]="sliderPaddingTop"
             [style.height.px]="height"
             [style.left.px]="getXOverlayPos()"
             [style.width.px]="getRightOverlayWidth()"></div>
      </ng-container>

      <div class="{{classPrefix}}-line-wrapper">
        <div class="{{classPrefix}}-line"></div>
      </div>
    </div>
  `
            }]
    }], function () { return [{ type: i0.NgZone }]; }, { xAxis: [{
            type: Input
        }], height: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }], customColors: [{
            type: Input
        }], xBrush: [{
            type: Input
        }], leftShift: [{
            type: Input
        }], containerWidth: [{
            type: Input
        }], data: [{
            type: Input
        }], rangeChanged: [{
            type: Output
        }], scrollEnd: [{
            type: Output
        }], _svgContainerEl: [{
            type: ViewChild,
            args: ['svgBrushContainer']
        }], _sliderEl: [{
            type: ViewChild,
            args: ['slider']
        }], _chartComponent: [{
            type: ViewChild,
            args: ['chart']
        }] }); })();

function ChartGradientLegendComponent_span_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 6);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("tabIndex", ctx_r0.focusable ? 0 : -1);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r0.zeroText);
} }
const _c0$8 = function (a0, a1) { return { "width": a0, "height": a1 }; };
const _c1$6 = function (a0) { return { "backgroundImage": a0 }; };
class ChartGradientLegendComponent {
    constructor(_deviceDetectionService, _ts) {
        this._deviceDetectionService = _deviceDetectionService;
        this._ts = _ts;
        this.focusable = true;
        this._defaultTexts = {};
        this.setDefaultTexts(_ts.getCurrentLanguage());
    }
    get isMobile() {
        return this._deviceDetectionService.deviceTablet() || this._deviceDetectionService.deviceMobile();
    }
    ngOnInit() {
        var _a;
        this.zeroColor = this.zeroColor || '#f0f0f1';
        this.increaseText = this.increaseText || this._defaultTexts.increaseText;
        this.decreaseText = this.decreaseText || this._defaultTexts.decreaseText;
        // Use nullish coalescing to allow pass empty string and hide zeroText
        this.zeroText = (_a = this.zeroText) !== null && _a !== void 0 ? _a : this._defaultTexts.zeroText;
        this.height = this.height || '100%';
    }
    setDefaultTexts(translation) {
        this._defaultTexts.increaseText = translation['adapt.chart.gradientLegend.increaseDefaultText'];
        this._defaultTexts.decreaseText = translation['adapt.chart.gradientLegend.decreaseDefaultText'];
        this._defaultTexts.zeroText = translation['adapt.chart.gradientLegend.zeroDefaultText'];
    }
}
ChartGradientLegendComponent.ɵfac = function ChartGradientLegendComponent_Factory(t) { return new (t || ChartGradientLegendComponent)(i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i1.AdaptTranslateService)); };
ChartGradientLegendComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ChartGradientLegendComponent, selectors: [["adapt-chart-gradient-legend"]], inputs: { increaseColor: "increaseColor", decreaseColor: "decreaseColor", zeroColor: "zeroColor", increaseText: "increaseText", decreaseText: "decreaseText", zeroText: "zeroText", height: "height", containerWidth: "containerWidth", focusable: "focusable" }, decls: 18, vars: 12, consts: [["role", "legend", 1, "adapt-chart-legend", "adapt-chart-legend__gradient", 3, "ngStyle"], [1, "adapt-chart-legend__gradient-label", "adapt-chart-legend__gradient-label_top", 3, "tabIndex"], [1, "adapt-chart-legend__gradient-label", "adapt-chart-legend__gradient-label_middle"], [3, "tabIndex", 4, "ngIf"], [1, "adapt-chart-legend__gradient-label", "adapt-chart-legend__gradient-label_bottom", 3, "tabIndex"], [1, "adapt-chart-legend__gradient-block", 3, "ngStyle"], [3, "tabIndex"]], template: function ChartGradientLegendComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵelementStart(3, "div", 1);
        i0.ɵɵtext(4);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(5, "\n      ");
        i0.ɵɵelementStart(6, "div", 2);
        i0.ɵɵtext(7, "\n        ");
        i0.ɵɵtemplate(8, ChartGradientLegendComponent_span_8_Template, 2, 2, "span", 3);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵelementStart(11, "div", 4);
        i0.ɵɵtext(12);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n      ");
        i0.ɵɵelementStart(14, "div", 5);
        i0.ɵɵtext(15, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction2(7, _c0$8, ctx.isMobile ? "100%" : ctx.containerWidth ? ctx.containerWidth + "px" : "", ctx.height));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("tabIndex", ctx.focusable ? 0 : -1);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1("\n        ", ctx.increaseText, "\n      ");
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.zeroText);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("tabIndex", ctx.focusable ? 0 : -1);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate1("\n        ", ctx.decreaseText, "\n      ");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(10, _c1$6, "linear-gradient(to bottom, " + ctx.increaseColor + ", " + ctx.zeroColor + " 50%, " + ctx.decreaseColor + ")"));
    } }, directives: [i3$1.NgStyle, i3$1.NgIf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ChartGradientLegendComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-chart-gradient-legend',
                template: `
    <div class="adapt-chart-legend adapt-chart-legend__gradient"
         role="legend"
         [ngStyle]="{'width': isMobile ? '100%' : containerWidth ? containerWidth + 'px' : '', 'height': height}">
      <div class="adapt-chart-legend__gradient-label adapt-chart-legend__gradient-label_top"
           [tabIndex]="focusable ? 0 : -1">
        {{increaseText}}
      </div>
      <div class="adapt-chart-legend__gradient-label adapt-chart-legend__gradient-label_middle">
        <span *ngIf="zeroText" [tabIndex]="focusable ? 0 : -1">{{zeroText}}</span>
      </div>
      <div class="adapt-chart-legend__gradient-label adapt-chart-legend__gradient-label_bottom"
           [tabIndex]="focusable ? 0 : -1">
        {{decreaseText}}
      </div>
      <div class="adapt-chart-legend__gradient-block"
           [ngStyle]="{'backgroundImage': 'linear-gradient(to bottom, ' + increaseColor + ', ' + zeroColor + ' 50%, ' + decreaseColor + ')'}">
      </div>
    </div>
  `
            }]
    }], function () { return [{ type: i1.AdaptDeviceDetectionService }, { type: i1.AdaptTranslateService }]; }, { increaseColor: [{
            type: Input
        }], decreaseColor: [{
            type: Input
        }], zeroColor: [{
            type: Input
        }], increaseText: [{
            type: Input
        }], decreaseText: [{
            type: Input
        }], zeroText: [{
            type: Input
        }], height: [{
            type: Input
        }], containerWidth: [{
            type: Input
        }], focusable: [{
            type: Input
        }] }); })();

const _c0$7 = ["chartContainer"];
const _c1$5 = ["chartArea"];
const _c2$3 = ["svgContainer"];
const _c3$1 = ["legend"];
const _c4$1 = ["legendComponent"];
const _c5 = ["chartSlider"];
function AdaptChartComponent_div_5_h1_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "h1", 14);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r8.$this.header.title);
} }
function AdaptChartComponent_div_5_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 15);
    i0.ɵɵlistener("click", function AdaptChartComponent_div_5_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(2); return ctx_r10.toggleLegend(); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelement(2, "span");
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "span");
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("d-icon-left-eye", ctx_r9.isLegendHidden)("d-icon-left-eye_closed", !ctx_r9.isLegendHidden);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("", ctx_r9.isLegendHidden ? "Show" : "Hide", " legend");
} }
function AdaptChartComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 11);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptChartComponent_div_5_h1_2_Template, 2, 1, "h1", 12);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, AdaptChartComponent_div_5_button_4_Template, 7, 5, "button", 13);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r1.$this.header.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", (ctx_r1.$this == null ? null : ctx_r1.$this.header == null ? null : ctx_r1.$this.header.allowHideLegend) && !ctx_r1.isMobile && !ctx_r1.suppressLegend);
} }
function AdaptChartComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptChartComponent__svg_svg_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg", 16, 17);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵelementStart(3, "desc", 18);
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelement(6, "g", 19);
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("transition", ctx_r4.transition);
    i0.ɵɵattributeInterpolate2("viewbox", "0 0 ", ctx_r4.currentSVGWidth, " ", ctx_r4.currentSVGHeight, "");
    i0.ɵɵattribute("aria-label", ctx_r4.title || (ctx_r4.$this == null ? null : ctx_r4.$this.header == null ? null : ctx_r4.$this.header.title) || "")("width", ctx_r4.currentSVGWidth)("height", ctx_r4.currentSVGHeight ? ctx_r4.currentSVGHeight + ctx_r4.chartBottomPadding : ctx_r4.currentSVGHeight);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(ctx_r4.description);
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("id", ctx_r4.chartContainerId)("width", ctx_r4.currentSVGWidth);
} }
const _c6 = function (a0) { return { "adapt-legend-zone__hidden": a0 }; };
function AdaptChartComponent_div_28_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 20);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "adapt-chart-gradient-legend", 21);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("width", ctx_r6.isMobile ? "100%" : ctx_r6.legendWidth + "px")("transition", ctx_r6.transition);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(14, _c6, !ctx_r6.showLegend));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("containerWidth", ctx_r6.legendWidth - 25)("increaseColor", ctx_r6.gradientLegend.increaseColor)("decreaseColor", ctx_r6.gradientLegend.decreaseColor)("zeroColor", ctx_r6.gradientLegend.zeroColor)("increaseText", ctx_r6.gradientLegend.increaseText)("decreaseText", ctx_r6.gradientLegend.decreaseText)("zeroText", ctx_r6.gradientLegend.zeroText)("height", ctx_r6.gradientLegend.height)("focusable", ctx_r6.showLegend);
} }
function AdaptChartComponent_div_30_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 20, 22);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "adapt-chart-legend", 23, 24);
    i0.ɵɵlistener("categoryShow", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryShow_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.categoryShow.emit($event); })("categoryHide", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryHide_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.categoryHide.emit($event); })("categoryEnter", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryEnter_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.categoryEnter.emit($event); })("categoryLeave", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryLeave_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.categoryLeave.emit($event); })("categoryMove", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryMove_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.categoryMove.emit($event); });
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("width", ctx_r7.isMobile ? "100%" : ctx_r7.legendWidth + "px")("transition", ctx_r7.transition);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(13, _c6, !ctx_r7.showLegend));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("focusable", ctx_r7.showLegend)("activeHover", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.activeHover)("activeClick", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.activeClick)("customColors", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.customColors)("items", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.items)("width", ctx_r7.legendWidth - 30)("columns", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.columns)("colorsPalette", ctx_r7.colorsPalette);
} }
const _c7 = ["*", [["adapt-chart-slider"]], [["adapt-area-graph-slider"]]];
const _c8 = ["*", "adapt-chart-slider", "adapt-area-graph-slider"];
let CHART_ID = 1;
class AdaptChartComponent extends AdaptChartAbstract {
    constructor(_deviceDetectionService, _directionality, _domSanitizer, _injector, _ngZone, _changeDetectorRef, _overlayService) {
        super();
        this._deviceDetectionService = _deviceDetectionService;
        this._directionality = _directionality;
        this._domSanitizer = _domSanitizer;
        this._injector = _injector;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this._overlayService = _overlayService;
        // TODO update types
        this.$this = this;
        /*
        * Useful to prevent legend rendering on view(eg. on chart slider component)
        * @since 11.4.0
        */
        this.renderLegend = true;
        this.categoryShow = new EventEmitter();
        this.categoryHide = new EventEmitter();
        this.categoryEnter = new EventEmitter();
        this.categoryLeave = new EventEmitter();
        this.categoryMove = new EventEmitter();
        this.clickChart = new EventEmitter();
        this.chartContainerId = 'chartContainer-';
        this.isLegendHidden = false;
        this.legendWidth = 250;
        this.defaultMaxAxisWidth = 150;
        this._emptyText = 'No data to show...';
        this._tooltipOverlayDefaultOffset = 6;
        this._tooltipDefaultCustomCls = 'adapt-chart-tooltip position-static';
        this._showEmptyText = false;
        this._chartBottomPadding = 0;
        this._destroyed$ = new ReplaySubject(1);
        const placements = getOverlayConnectedPositions(this._directionality.value, this._tooltipOverlayDefaultOffset);
        this._tooltipOverlayPlacements = {
            top: placements.top,
            bottom: placements.bottom,
            left: placements.left,
            right: placements.right
        };
        this.id = CHART_ID;
        this.chartContainerId += CHART_ID;
        CHART_ID++;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set data(v) {
        this._data = v;
        if (this._isDataExists()) {
            this.hideTooltip();
            this._drawChart();
        }
        else {
            this._showEmptyText = true;
        }
    }
    get isMobile() {
        return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
    }
    get showHeader() {
        return !this.suppressHeader
            && this.header
            && this._isDataExists()
            && (!isUndefined$1(this.header.title)
                || !isUndefined$1(this.header.subtitle)
                || !isUndefined$1(this.header.allowHideLegend));
    }
    get showLegend() {
        return !this.isLegendHidden && !this.suppressLegend
            && (!isUndefined$1(this.legend) && !isUndefined$1(this.legend.items) && !!this.legend.items.length
                || !isUndefined$1(this.gradientLegend));
    }
    get chartWidth() {
        return isUndefined$1(this.width) ? this.currentContainerWidth : this.width;
    }
    get chartHeight() {
        return isUndefined$1(this.height) ? this.currentContainerHeight : this.height;
    }
    get transition() {
        return this._domSanitizer.bypassSecurityTrustStyle(`all ${ANIMATION_DURATION.fast}
      ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`);
    }
    get chartBottomPadding() {
        return this._chartBottomPadding;
    }
    set chartBottomPadding(value) {
        this._chartBottomPadding = value;
    }
    ngOnInit() {
        if (this.legend && this.legend.width) {
            this.legendWidth = this.legend.width;
        }
    }
    ngAfterViewInit() {
        timer(0, asapScheduler)
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            this.redrawChart();
        });
        if (!(this.width && this.height)) {
            if (this._showEmptyText) {
                this._drawEmptyText();
            }
        }
    }
    ngOnDestroy() {
        this._removeListeners();
        this._destroyed$.next(true);
        this._destroyed$.complete();
        this.hideTooltip();
    }
    redrawChart() {
        const { width, height } = this.chartContainerEl.nativeElement.getBoundingClientRect();
        if (this.header && isUndefined$1(this.header.allowHideLegend)) {
            this.header.allowHideLegend = true;
        }
        if (width && this._isDataExists()) {
            this.currentContainerWidth = width;
            this.currentContainerHeight = height;
            this._initChart();
        }
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    showTooltip(target, content, context, customCls, offset, sidePositionsFirst) {
        this.hideTooltip();
        this._ngZone.run(() => {
            if (target instanceof Element) {
                this._tooltipOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptTooltipComponent, null, this._injector), {
                    origin: target,
                    positionStrategy: 'connected',
                    scrollStrategy: 'close',
                    connectedPositions: this._getTooltipPositions(offset, sidePositionsFirst)
                });
            }
            else {
                this._tooltipOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptTooltipComponent, null, this._injector), {
                    origin: target,
                    positionStrategy: 'float',
                    scrollStrategy: 'close'
                });
                this._tooltipOverlayWithPortal.overlayRef.updatePosition();
            }
            this._tooltipOverlayWithPortal.componentRef.instance.content = content;
            this._tooltipOverlayWithPortal.componentRef.instance.visible = true;
            this._tooltipOverlayWithPortal.componentRef.instance.customCls = `${this._tooltipDefaultCustomCls} ` + customCls;
            if (context) {
                this._tooltipOverlayWithPortal.componentRef.instance.context = context;
            }
        });
    }
    hideTooltip() {
        if (this._tooltipOverlayWithPortal) {
            this._tooltipOverlayWithPortal.destroy();
            this._tooltipOverlayWithPortal = null;
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    updateTooltip(content, context) {
        if (this._tooltipOverlayWithPortal) {
            if (content) {
                this._tooltipOverlayWithPortal.componentRef.instance.content = content;
            }
            if (context) {
                this._tooltipOverlayWithPortal.componentRef.instance.context = context;
            }
            this._tooltipOverlayWithPortal.overlayRef.updatePosition();
        }
    }
    toggleLegend() {
        const { width } = this.chartAreaEl.nativeElement.getBoundingClientRect();
        let dim;
        this.isLegendHidden = !this.isLegendHidden;
        if (!this.isMobile) {
            dim = {
                w: width + (this.isLegendHidden ? this.legendWidth : -this.legendWidth),
                h: this.currentSVGHeight
            };
        }
        else {
            dim = {
                w: width,
                h: this.currentSVGHeight
            };
        }
        this._setChartSize(true, false);
        if (this.updateChart) {
            this.updateChart(dim);
        }
        if (!isUndefined$1(this.chartSliderCmp)) {
            this.chartSliderCmp.updateSlider(dim);
        }
        if (!isUndefined$1(this.areaChartSliderCmp)) {
            this.areaChartSliderCmp.updateSlider(dim);
        }
    }
    clear() {
        d3.select(`#${this.chartContainerId}`).selectAll('*').remove();
    }
    clickChartArea(e) {
        this.clickChart.emit(e);
    }
    updateLegend(items) {
        if (this.renderLegend) {
            this.legendComponent.update(items);
        }
    }
    getGroupAndDimensions() {
        const group = d3.select(`#${this.chartContainerId}`);
        this._setChartSize();
        return {
            group,
            w: this.currentSVGWidth,
            h: this.currentSVGHeight
        };
    }
    // Method creates hidden xAxis block to calculate maximum possible height.
    // Can be helpful when axis long titles need to be rotated
    updateChartBottomPadding(axisWidth, g, xAxis, rotateAxis = false) {
        if (!rotateAxis) {
            this.chartBottomPadding = 0;
            return;
        }
        const xScale = d3.scaleBand();
        xScale.range([0, axisWidth]).domain(xAxis.categories);
        const xScaleCall = d3.axisBottom(xScale).tickSizeOuter(0).tickPadding(12);
        g.select('g.fake-axis').remove();
        const axisBlock = g.append('g')
            .attr('class', 'fake-axis')
            .attr('style', 'display: none')
            .attr('aria-hidden', 'true')
            .call(xScaleCall);
        const textWidths = [];
        axisBlock.selectAll('text').each(function () {
            const text = d3.select(this);
            const length = text.node().getComputedTextLength();
            textWidths.push(length);
        });
        if (textWidths.length) {
            // TODO: Refactor this if possible
            // eslint-disable-next-line prefer-spread
            const largest = Math.max.apply(Math, textWidths);
            const diagonalHeight = largest > this.defaultMaxAxisWidth ? this.defaultMaxAxisWidth : largest;
            // Because we rotate string on 45 deg, we need to calculate height by Pythagoras theorem
            this.chartBottomPadding = Math.sqrt(Math.pow(diagonalHeight, 2) / 2);
        }
        else {
            this.chartBottomPadding = 0;
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    transformAxisTitles(axisBlock, shouldRotate) {
        const axisTexts = axisBlock.selectAll('text');
        axisTexts
            .style('text-anchor', shouldRotate ? 'end' : 'middle')
            .attr('dx', shouldRotate ? '-.8em' : '0')
            .attr('dy', shouldRotate ? '.15em' : '9')
            .attr('transform', shouldRotate ? 'rotate(-45)' : 'rotate(0)');
        if (shouldRotate) {
            axisTexts.call(textWrap, this.defaultMaxAxisWidth);
        }
    }
    _initChart() {
        this._setContainerSize();
        this._setChartSize();
        this._drawChart();
    }
    /**
     * This method manages the size of the main container element, dependently on
     * which size parameters have been set
     */
    _setContainerSize() {
        const { width, height } = this;
        this.currentContainerWidth = isUndefined$1(width) ? this.currentContainerWidth : width;
        this.currentContainerHeight = isUndefined$1(height) ? this.currentContainerHeight : height;
    }
    _setChartSize(recalculateWidth = true, recalculateHeight = true) {
        if (recalculateHeight) {
            const height = this.chartAreaEl.nativeElement.getBoundingClientRect().height;
            const sliderHeight = this.chartSliderEl.nativeElement.getBoundingClientRect().height;
            // @TODO: For area chart slider height is 0 on init, because of that chart height recalculate incorrectly when legend toggle
            this.currentSVGHeight = height - sliderHeight;
        }
        if (recalculateWidth) {
            const width = this.chartContainerEl.nativeElement.getBoundingClientRect().width;
            this.currentSVGWidth = width - (this.showLegend && !this.isMobile ? this.legendWidth : 0);
        }
    }
    _drawChart() {
        if (!this.dataBuilder) {
            return;
        }
        const options = this.getGroupAndDimensions();
        options.group.selectAll('*').remove();
        this.dataBuilder(options.group, {
            w: options.w,
            h: options.h
        });
    }
    _isDataExists() {
        return !isUndefined$1(this._data) && !isNull(this._data);
    }
    _drawEmptyText() {
        const group = d3.select(`#${this.chartContainerId}`);
        group.append('text')
            .attr('text-anchor', 'middle')
            .style('transform', 'translate(50%, 50%)')
            .style('font-size', '13px')
            .style('fill', 'currentcolor')
            .classed('text-default', true)
            .text(this.noDataText || this._emptyText);
    }
    _removeListeners() {
        if (this._removeClickEventListener) {
            this._removeClickEventListener();
        }
        if (this._removeScrollEventListener) {
            this._removeScrollEventListener();
        }
    }
    _getTooltipPositions(offset, sidePositionsFirst) {
        if (isNumber(offset) && (offset !== this._tooltipOverlayDefaultOffset)) {
            this._tooltipOverlayDefaultOffset = offset;
            this._tooltipOverlayPlacements.top.offsetY = -this._tooltipOverlayDefaultOffset;
            this._tooltipOverlayPlacements.bottom.offsetY = this._tooltipOverlayDefaultOffset;
            this._tooltipOverlayPlacements.left.offsetX = -this._tooltipOverlayDefaultOffset;
            this._tooltipOverlayPlacements.right.offsetX = this._tooltipOverlayDefaultOffset;
        }
        return sidePositionsFirst ?
            [
                this._tooltipOverlayPlacements.right,
                this._tooltipOverlayPlacements.left,
                this._tooltipOverlayPlacements.top,
                this._tooltipOverlayPlacements.bottom
            ] :
            [
                this._tooltipOverlayPlacements.top,
                this._tooltipOverlayPlacements.bottom,
                this._tooltipOverlayPlacements.left,
                this._tooltipOverlayPlacements.right
            ];
    }
}
AdaptChartComponent.ɵfac = function AdaptChartComponent_Factory(t) { return new (t || AdaptChartComponent)(i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i2.Directionality), i0.ɵɵdirectiveInject(i3.DomSanitizer), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptOverlayService)); };
AdaptChartComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptChartComponent, selectors: [["adapt-chart"]], contentQueries: function AdaptChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, AdaptChartSliderComponent, 5);
        i0.ɵɵcontentQuery(dirIndex, AdaptAreaGraphSliderComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartSliderCmp = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.areaChartSliderCmp = _t.first);
    } }, viewQuery: function AdaptChartComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$7, 7);
        i0.ɵɵviewQuery(_c1$5, 7);
        i0.ɵɵviewQuery(_c2$3, 5);
        i0.ɵɵviewQuery(_c3$1, 5);
        i0.ɵɵviewQuery(_c4$1, 5);
        i0.ɵɵviewQuery(_c5, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartContainerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartAreaEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.svgContainerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.legendEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.legendComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartSliderEl = _t.first);
    } }, inputs: { title: "title", description: "description", backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", renderLegend: "renderLegend", gradientLegend: "gradientLegend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", noDataText: "noDataText", dataBuilder: "dataBuilder", updateChart: "updateChart", colorsPalette: "colorsPalette", topSectionTemplate: "topSectionTemplate", data: "data" }, outputs: { categoryShow: "categoryShow", categoryHide: "categoryHide", categoryEnter: "categoryEnter", categoryLeave: "categoryLeave", categoryMove: "categoryMove", clickChart: "clickChart" }, features: [i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 35, vars: 17, consts: [[1, "adapt-chart", 3, "click"], ["chartContainer", ""], ["class", "adapt-chart-header", 4, "ngIf"], [4, "ngTemplateOutlet"], [1, "adapt-chart-body"], [1, "adapt-chart-zone"], ["chartArea", ""], ["xmlns", "http://www.w3.org/2000/svg", "class", "adapt-chart-svg", "tabindex", "0", "role", "graphic/image", 3, "transition", 4, "ngIf"], [1, "adapt-chart-slider-wrapper"], ["chartSlider", ""], ["class", "adapt-legend-zone", 3, "width", "transition", "ngClass", 4, "ngIf"], [1, "adapt-chart-header"], ["class", "adapt-chart-header-title m-0", 4, "ngIf"], ["class", "adapt-chart-context-menu-btn", "role", "button", 3, "click", 4, "ngIf"], [1, "adapt-chart-header-title", "m-0"], ["role", "button", 1, "adapt-chart-context-menu-btn", 3, "click"], ["xmlns", "http://www.w3.org/2000/svg", "tabindex", "0", "role", "graphic/image", 1, "adapt-chart-svg"], ["svgContainer", ""], ["id", "desc"], [1, "adapt-chart-group"], [1, "adapt-legend-zone", 3, "ngClass"], [3, "containerWidth", "increaseColor", "decreaseColor", "zeroColor", "increaseText", "decreaseText", "zeroText", "height", "focusable"], ["legend", ""], [3, "focusable", "activeHover", "activeClick", "customColors", "items", "width", "columns", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave", "categoryMove"], ["legendComponent", ""]], template: function AdaptChartComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c7);
        i0.ɵɵelementStart(0, "div");
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelementStart(2, "div", 0, 1);
        i0.ɵɵlistener("click", function AdaptChartComponent_Template_div_click_2_listener($event) { return ctx.clickChartArea($event); });
        i0.ɵɵtext(4, "\n\n    ");
        i0.ɵɵtemplate(5, AdaptChartComponent_div_5_Template, 6, 2, "div", 2);
        i0.ɵɵtext(6, "\n\n    ");
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵtemplate(8, AdaptChartComponent_ng_container_8_Template, 1, 0, "ng-container", 3);
        i0.ɵɵtext(9, "\n\n    ");
        i0.ɵɵelementStart(10, "div", 4);
        i0.ɵɵtext(11, "\n      ");
        i0.ɵɵelementStart(12, "div", 5, 6);
        i0.ɵɵtext(14, "\n        ");
        i0.ɵɵprojection(15);
        i0.ɵɵtext(16, "\n        ");
        i0.ɵɵtemplate(17, AdaptChartComponent__svg_svg_17_Template, 8, 10, "svg", 7);
        i0.ɵɵtext(18, "\n        ");
        i0.ɵɵelementStart(19, "div", 8, 9);
        i0.ɵɵtext(21, "\n          ");
        i0.ɵɵprojection(22, 1);
        i0.ɵɵtext(23, "\n          ");
        i0.ɵɵprojection(24, 2);
        i0.ɵɵtext(25, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(26, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(27, "\n      ");
        i0.ɵɵtemplate(28, AdaptChartComponent_div_28_Template, 5, 16, "div", 10);
        i0.ɵɵtext(29, "\n      ");
        i0.ɵɵtemplate(30, AdaptChartComponent_div_30_Template, 7, 15, "div", 10);
        i0.ɵɵtext(31, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(32, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(33, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(34, "\n");
    } if (rf & 2) {
        i0.ɵɵstyleProp("height", ctx.chartHeight + ctx.chartBottomPadding, "px");
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("width", ctx.chartWidth, "px")("height", ctx.chartHeight, "px");
        i0.ɵɵclassProp("adapt-chart-mobile", ctx.isMobile);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.showHeader);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngTemplateOutlet", ctx.topSectionTemplate);
        i0.ɵɵadvance(4);
        i0.ɵɵstyleProp("width", 0, "px")("background-color", ctx.$this.backgroundColor);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.dataBuilder);
        i0.ɵɵadvance(11);
        i0.ɵɵproperty("ngIf", ctx.gradientLegend);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.legend && ctx.renderLegend);
    } }, directives: [i3$1.NgIf, i3$1.NgTemplateOutlet, i3$1.NgClass, ChartGradientLegendComponent, ChartLegendComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptChartComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-chart',
                templateUrl: './chart.component.html',
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.AdaptDeviceDetectionService }, { type: i2.Directionality }, { type: i3.DomSanitizer }, { type: i0.Injector }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptOverlayService }]; }, { title: [{
            type: Input
        }], description: [{
            type: Input
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], legend: [{
            type: Input
        }], renderLegend: [{
            type: Input
        }], gradientLegend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], updateChart: [{
            type: Input
        }], colorsPalette: [{
            type: Input
        }], topSectionTemplate: [{
            type: Input
        }], data: [{
            type: Input
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], categoryEnter: [{
            type: Output
        }], categoryLeave: [{
            type: Output
        }], categoryMove: [{
            type: Output
        }], clickChart: [{
            type: Output
        }], chartContainerEl: [{
            type: ViewChild,
            args: ['chartContainer', { static: true }]
        }], chartAreaEl: [{
            type: ViewChild,
            args: ['chartArea', { static: true }]
        }], svgContainerEl: [{
            type: ViewChild,
            args: ['svgContainer', { static: false }]
        }], legendEl: [{
            type: ViewChild,
            args: ['legend', { static: false }]
        }], legendComponent: [{
            type: ViewChild,
            args: ['legendComponent', { static: false }]
        }], chartSliderEl: [{
            type: ViewChild,
            args: ['chartSlider', { static: true }]
        }], chartSliderCmp: [{
            type: ContentChild,
            args: [AdaptChartSliderComponent, { static: false }]
        }], areaChartSliderCmp: [{
            type: ContentChild,
            args: [AdaptAreaGraphSliderComponent, { static: false }]
        }] }); })();

class NumberPrefix {
}
NumberPrefix.K = Math.pow(10, 3);
NumberPrefix.M = Math.pow(10, 6);
NumberPrefix.G = Math.pow(10, 9);
NumberPrefix.T = Math.pow(10, 12);
class CutNumberPipe {
    // TODO: Double check 'fractional' argument
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    transform(value, fractional = 2) {
        const prefixes = Object.keys(NumberPrefix);
        let shortValue;
        prefixes.some((prefixCurrent, id) => {
            const prefixPrevious = prefixes[id - 1];
            if (value < NumberPrefix[prefixCurrent]) {
                if (prefixPrevious) {
                    const t = value % NumberPrefix[prefixPrevious];
                    shortValue = (value / NumberPrefix[prefixPrevious]).toFixed(t ? 1 : 0) + prefixPrevious;
                }
                else {
                    shortValue = Number(value.toFixed(6)).toString();
                }
            }
            return value < NumberPrefix[prefixCurrent];
        });
        return shortValue;
    }
}
CutNumberPipe.ɵfac = function CutNumberPipe_Factory(t) { return new (t || CutNumberPipe)(); };
CutNumberPipe.ɵpipe = /*@__PURE__*/ i0.ɵɵdefinePipe({ name: "cutNumber", type: CutNumberPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CutNumberPipe, [{
        type: Pipe,
        args: [{
                name: 'cutNumber'
            }]
    }], null, null); })();

/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
function textEllipsis(textNode, text, ellipsisWidth) {
    let ellipsisText = '';
    let width = ellipsisWidth;
    const letters = text.split('');
    const lettersNum = letters.length;
    // Clear all children before inserting text
    textNode.selectAll('*').remove();
    const ellipsis = textNode.append('tspan').attr('class', 'ellipsis').text('...');
    const tSpan = textNode.insert('tspan', ':first-child').text(letters.join(''));
    if (tSpan.node().getComputedTextLength() > width && letters.length) {
        width = ellipsisWidth - ellipsis.node().getComputedTextLength();
    }
    // Try the whole line
    // While it's too long, and we have words left, keep removing words
    while (tSpan.node().getComputedTextLength() > width && letters.length) {
        letters.pop();
        tSpan.text(letters.join(''));
    }
    if (letters.length === lettersNum) {
        ellipsis.remove();
        ellipsisText = tSpan.text();
    }
    else {
        ellipsisText = tSpan.text() + '...';
    }
    return ellipsisText;
}

const _c0$6 = ["tooltipTpl"];
const _c1$4 = ["tooltipListInfoTpl"];
function AdaptStackedChartComponent_adapt_chart_slider_4_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-chart-slider", 5);
    i0.ɵɵlistener("rangeChanged", function AdaptStackedChartComponent_adapt_chart_slider_4_Template_adapt_chart_slider_rangeChanged_0_listener($event) { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.changeDataRange($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("slidePointsCount", ctx_r1.slidePointsCount)("height", ctx_r1.sliderHeight)("xAxis", ctx_r1.xAxis)("data", ctx_r1.sliderData)("containerWidth", ctx_r1.chartWidth)("customColors", ctx_r1.legend == null ? null : ctx_r1.legend.customColors)("leftShift", ctx_r1.leftShift)("type", ctx_r1.sliderType)("stackedChart", ctx_r1.getStackedChart());
} }
function AdaptStackedChartComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 6);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "div");
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelement(5, "span", 7);
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementStart(7, "span", 8);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementStart(10, "span");
    i0.ɵɵelementStart(11, "b");
    i0.ɵɵtext(12);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n        ");
    i0.ɵɵelementStart(15, "div");
    i0.ɵɵtext(16, "\n          Total:\n          ");
    i0.ɵɵelementStart(17, "span");
    i0.ɵɵelementStart(18, "b");
    i0.ɵɵtext(19);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(21, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n    ");
} if (rf & 2) {
    const data_r8 = ctx.data;
    i0.ɵɵadvance(5);
    i0.ɵɵstyleProp("background-color", data_r8 == null ? null : data_r8.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("", data_r8.category, ":");
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(data_r8.value);
    i0.ɵɵadvance(7);
    i0.ɵɵtextInterpolate(data_r8.total);
} }
function AdaptStackedChartComponent_ng_template_10_div_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelement(2, "span", 7);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "span", 8);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelementStart(7, "span");
    i0.ɵɵelementStart(8, "b");
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const d_r11 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("background-color", d_r11 == null ? null : d_r11.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("", d_r11.category, ":");
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(d_r11.value);
} }
function AdaptStackedChartComponent_ng_template_10_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptStackedChartComponent_ng_template_10_div_3_ng_container_2_Template, 11, 4, "ng-container", 12);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const d_r11 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", d_r11.value !== 0);
} }
function AdaptStackedChartComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 9);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtemplate(3, AdaptStackedChartComponent_ng_template_10_div_3_Template, 4, 1, "div", 10);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelement(5, "hr", 11);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementStart(7, "div");
    i0.ɵɵtext(8, "\n          Total:\n          ");
    i0.ɵɵelementStart(9, "span");
    i0.ɵɵelementStart(10, "b");
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n    ");
} if (rf & 2) {
    const data_r9 = ctx.data;
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", data_r9.seriesData);
    i0.ɵɵadvance(8);
    i0.ɵɵtextInterpolate(data_r9.total);
} }
let chartCounter$2 = 1;
const DEFAULT_MARGIN = 10;
// TODO update types
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
class AdaptStackedChartComponent extends AdaptStackedChartAbstract {
    constructor(_cutNumber, _colorService) {
        super();
        this._cutNumber = _cutNumber;
        this._colorService = _colorService;
        this.sliderType = AdaptChartSliderType.bar;
        this.sliderHeight = 36;
        this.heightZero = 0;
        this.showSlider = false;
        this.hasTotalLabels = false;
        this.rotateXAxis = false;
        this.scientificMode = false;
        /*
        * Useful to prevent legend rendering on view(eg. on chart slider component)
        * @since 11.4.0
        */
        this.renderLegend = true;
        this.showEmptyColIndicator = true;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.clickChart = new EventEmitter();
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
        this.alreadyChanged = false;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._data = [];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._dataFull = [];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._colors = [];
        this._maxTicksCount = 7;
        this._totalByCol = {};
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._categoryFilter = [];
        // Default values of xAxis, yAxis and axisTitle thickness
        this._axisXThickness = 50;
        this._axisYThickness = 25;
        this._axisTitleThickness = 20;
        this._legend = {
            columns: 2,
            activeHover: true,
            activeClick: true,
            width: 250,
            customColors: null,
            items: []
        };
        this._series = [];
        this._startDataPiece = 0;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._cls = {
            axis: 'adapt-chart-axis',
            axisHidden: 'adapt-chart-axis__hidden',
            axisTitle: 'adapt-chart-axis-title',
            axisXTitle: 'adapt-chart-axis-x-title',
            axisYTitle: 'adapt-chart-axis-y-title',
            barXAxis: 'bar-x-axis',
            barYAxis: 'bar-y-axis',
            colXAxis: 'col-x-axis',
            colYAxis: 'col-y-axis',
            category: 'adapt-chart-bars-category',
            areaGroup: 'adapt-chart-area-group',
            areaTooltipLines: 'adapt-chart-area-tooltip-lines',
            dataRect: 'adapt-chart-data-rect',
            totalLabelsGroup: 'total-labels-group',
            totalLabelsGroupItem: 'total-labels-group-item',
            totalLabelItem: 'total-label-item',
            thresholdLineArea: 'threshold-line-area'
        };
        this._emptyColIndicatorWidth = 22;
        this._emptyColIndicatorHeight = 24;
        this.updateChart = this.updateChart.bind(this);
        this._dataBuilder = this._dataBuilder.bind(this);
        this._id = `stacked-chart-${chartCounter$2++}`;
    }
    get isHorizontalSeries() {
        return this.seriesDisplay === 'horizontal';
    }
    set series(s) {
        this.sliderData = s;
        this._categoryFilter = [];
        s.forEach(series => {
            if (series.hidden) {
                this._categoryFilter.push(series.name);
            }
        });
        if (this.showSlider) {
            this._series = this._getDataRange();
        }
        else {
            this._series = s;
        }
        if (this.alreadyChanged) {
            const options = this.chartComponent.getGroupAndDimensions();
            this._g = options.group;
            this._dim = {
                w: options.w,
                h: options.h
            };
        }
        if (this._g && this._dim && this.chartComponent) {
            this.chartComponent.updateLegend(this.series.map((item) => ({
                item: item.name,
                hidden: !!item.hidden,
                hover: false
            })));
        }
    }
    get series() {
        return this._series;
    }
    set legend(legend) {
        this._legend = Object.assign(this._legend, legend);
        if (this.alreadyChanged) {
            this.chartComponent.redrawChart();
        }
    }
    get legend() {
        return {
            customColors: this._legend.customColors,
            activeHover: this._legend.activeHover,
            activeClick: this._legend.activeClick,
            columns: this._legend.columns,
            width: this._legend.width,
            items: (this.series && this.series.map((series) => ({
                item: series.name,
                hidden: !!series.hidden
            })))
        };
    }
    get leftShift() {
        return this._margin.left;
    }
    get chartWidth() {
        return this.width || this.chartComponent.chartWidth;
    }
    get duration() {
        return parseFloat(ANIMATION_DURATION.fast) * 1000;
    }
    get _margin() {
        return {
            top: 0,
            left: !this.hideAxises && this.xAxis ?
                (this.xAxis.thickness || this._axisXThickness) + (this.xAxis.title ? this._axisTitleThickness : 0) : 0,
            right: 0,
            bottom: !this.hideAxises && this.yAxis ?
                (this.yAxis.thickness || this._axisYThickness) + (this.yAxis.title ? this._axisTitleThickness : 0) : 0
        };
    }
    ngOnInit() {
        if (this.scientificMode) {
            BigNumber.config({ EXPONENTIAL_AT: 4 });
        }
        if (this.showSlider && !this.slidePointsCount) {
            this._initSlidePointsCount();
        }
        this.alreadyChanged = true;
    }
    ngOnChanges(changes) {
        if ((changes[nameof('type')]
            || changes[nameof('showSlider')]
            || changes[nameof('thresholdLine')]
            || changes[nameof('seriesDisplay')]
            || changes[nameof('hasTotalLabels')]
            || changes[nameof('barWidth')]
            || changes[nameof('rotateXAxis')])
            && this.alreadyChanged && this._dim) {
            this.chartComponent.redrawChart();
        }
    }
    updateChart(dim) {
        if (dim) {
            this._dim = dim;
        }
        else {
            dim = this._dim;
        }
        this._initData();
        this._prepareOrdinal();
        this._updateAxisX(dim);
        this._updateAxisY(dim);
        this._updateData();
        this._updateThresholdLineArea();
    }
    _dataBuilder(g, dim) {
        this._g = g;
        this._dim = dim;
        this._clear();
        this._initData();
        this._prepareOrdinal();
        this._drawAxisX(g, dim);
        this._drawAxisY(g, dim);
        this._drawData(g);
        this._updateThresholdLineArea();
    }
    getStackedChart() {
        return this;
    }
    categoryEnterHandler(categoryEvent) {
        const categoryGroup = this._g.select(`[data-category-id='${categoryEvent.id}']`);
        const categoryGroupColor = categoryGroup.attr('fill');
        const hoveredColor = this._colorService.getDarken(categoryGroupColor, .15, ColorType.HEX);
        this._highlightColor = categoryGroupColor;
        categoryGroup.attr('fill', hoveredColor);
    }
    categoryLeaveHandler(categoryEvent) {
        const categoryGroup = this._g.select(`[data-category-id='${categoryEvent.id}']`);
        categoryGroup.attr('fill', this._highlightColor);
    }
    categoryShowHandler(category) {
        const categoryId = this._categoryFilter.indexOf(category);
        if (categoryId !== -1) {
            this._categoryFilter.splice(categoryId, 1);
        }
        this.updateChart(null);
        if (!isUndefined(this.chartSliderComponent)) {
            this.chartSliderComponent.showCategory(category);
        }
        this.categoryShow.emit({ category });
    }
    categoryHideHandler(category) {
        this._categoryFilter.push(category);
        this.updateChart(null);
        if (!isUndefined(this.chartSliderComponent)) {
            this.chartSliderComponent.hideCategory(category);
        }
        this.categoryHide.emit({ category });
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    clickChartArea(e) {
        const target = e.target;
        const isRect = target.classList.contains(this._cls.dataRect);
        if (isRect) {
            const color = d3.select(target.parentNode).attr('fill');
            const categoryId = target.parentNode.getAttribute('data-category-id');
            const category = this.series[categoryId].name;
            const id = target.getAttribute('data-id');
            const value = this._data[id][category];
            const keys = Object.keys(this._data[id]);
            const axisCategory = this._data[id].name;
            const nameId = keys.indexOf('name');
            keys.splice(nameId, 1);
            const total = keys.reduce((acc, c) => acc + this._data[id][c], 0);
            this.clickChart.emit({
                event: e,
                data: this.series.filter((d) => category === d.name)[0],
                axisCategory,
                color,
                categoryId: category,
                value,
                total
            });
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    changeDataRange(range) {
        this._startDataPiece = range.startPiece;
        this._endDataPiece = range.endPiece;
        this._series = this._getDataRange();
        this._totalByCol = {};
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getFormattedSeries(data) {
        const formattedData = data.series.map(d => {
            return {
                categoryName: d.name,
                seriesValues: Object.entries(d).filter(v => v[0] !== 'name')
            };
        });
        const currentCategory = formattedData.find(d => d.categoryName === data.category);
        const total = currentCategory.seriesValues.reduce((acc, cur) => acc + cur[1], 0);
        currentCategory.seriesValues = currentCategory.seriesValues.map((d, i) => {
            return {
                category: d[0],
                value: d[1],
                color: this.legend.customColors ? this._getCustomColorById(i) : this._colorService.getColor(i)
            };
        });
        return {
            seriesData: currentCategory.seriesValues,
            total
        };
    }
    _initData() {
        if (this.showSlider) {
            this._endDataPiece = this._endDataPiece || this.slidePointsCount;
        }
        const ctg = this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories;
        this._data = [];
        this._dataFull = [];
        ctg.forEach((c, index) => {
            const o = {
                name: c
            };
            this.series.forEach((s) => {
                if (this._categoryFilter.indexOf(s.name) === -1) {
                    o[s.name] = o[s.name] || 0;
                    o[s.name] += s.data[index];
                }
                else {
                    o[s.name] = 0;
                }
            });
            this._data.push(o);
        });
        this.xAxis.categories.forEach((c, index) => {
            const o = {
                name: c
            };
            this.sliderData.forEach((s) => {
                if (this._categoryFilter.indexOf(s.name) === -1) {
                    o[s.name] = o[s.name] || 0;
                    o[s.name] += s.data[index];
                }
                else {
                    o[s.name] = 0;
                }
            });
            this._dataFull.push(o);
        });
        this._data.forEach((data) => {
            const { name } = data;
            const categories = Object.keys(data);
            this._totalByCol[name] = 0;
            categories.forEach((category) => {
                if (category !== 'name') {
                    if (this.scientificMode) {
                        this._totalByCol[name] = new BigNumber(this._totalByCol[name]).plus(data[category]);
                    }
                    else {
                        this._totalByCol[name] += data[category];
                    }
                }
            });
        });
    }
    _prepareOrdinal() {
        this._keys = this.series.map((s) => s.name);
        this._colors = [];
        this.series.forEach((s, id) => {
            this._colors.push(this._legend.customColors ? this._getCustomColorById(id) : this._colorService.getColor(id));
        });
        this._ordinal = d3.scaleOrdinal()
            .range(this._colors)
            .domain(this._keys);
    }
    _drawAxisX(g, dim) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._drawAxisXForBar(g, dim);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._drawAxisXForColumn(g, dim);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._drawAxisXForArea(g, dim);
                break;
            }
        }
    }
    _drawAxisXForBar(g, dim) {
        const ticks = this._getTicks().reverse();
        this._drawAxisTitle(g, dim, this.xAxis.title, true);
        this._xScale = d3.scaleLinear();
        this._xScale.rangeRound([dim.w - this._margin.left - this._margin.right, 0]).domain([ticks[0], 0]);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickValues(ticks)
            .tickSize(-dim.h + this._margin.top + this._margin.bottom)
            .tickFormat((d, i) => isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver(d, i) : this._getTickFormatForNumber(d))
            .tickPadding(15);
        g.append('g')
            .attr('role', 'axis')
            .attr('class', `${this._cls.axis} ${this._cls.barXAxis} ${this.hideAxises ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`)
            .transition()
            .duration(this.duration)
            .call(this._xAxisCall);
    }
    _drawAxisXForColumn(g, dim) {
        const axisWidth = dim.w - this._margin.left - this._margin.right;
        setTimeout(() => {
            const axisXTitleBlock = g.select(`.${this._cls.axisXTitle}`);
            axisXTitleBlock.remove();
            this._drawAxisTitle(g, dim, this.xAxis.title);
        }, this.duration + 100);
        this._xScale = d3.scaleBand();
        this._xScale
            .range([0, axisWidth])
            .padding(0.25)
            .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickFormat(isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
            .tickSizeOuter(0)
            .tickPadding(12);
        this.chartComponent.updateChartBottomPadding(axisWidth, this._g, this.xAxis, this.rotateXAxis);
        const axisBlock = g.append('g')
            .attr('role', 'title')
            .attr('class', `${this._cls.axis} ${this._cls.colXAxis} ${this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.bottom})`);
        axisBlock
            .call(this._xAxisCall);
        if (this.rotateXAxis) {
            setTimeout(() => {
                this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
                if (!this.hideAxises) {
                    axisBlock.classed(this._cls.axisHidden, null);
                }
            }, this.duration);
        }
    }
    _drawAxisXForArea(g, dim) {
        const axisWidth = dim.w - this._margin.left - this._margin.right;
        setTimeout(() => {
            const axisXTitleBlock = g.select(`.${this._cls.axisXTitle}`);
            axisXTitleBlock.remove();
            this._drawAxisTitle(g, dim, this.xAxis.title);
        }, this.duration + 100);
        this._xScale = d3.scalePoint()
            .range([0, this._dim.w - this._margin.left - this._margin.right])
            .domain(this.xAxis.categories);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickFormat(isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
            .tickSizeOuter(0)
            .tickPadding(12);
        this.chartComponent.updateChartBottomPadding(axisWidth, this._g, this.xAxis, this.rotateXAxis);
        const axisBlock = g.append('g')
            .attr('role', 'title')
            .attr('class', `${this._cls.axis} ${this._cls.colXAxis} ${this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.bottom})`);
        axisBlock
            .call(this._xAxisCall);
        if (this.rotateXAxis) {
            setTimeout(() => {
                this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
                if (!this.hideAxises) {
                    axisBlock.classed(this._cls.axisHidden, null);
                }
            }, this.duration);
        }
    }
    _drawAxisY(g, dim) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._drawAxisYForBar(g, dim);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._drawAxisYForColumn(g, dim);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._drawAxisYForColumn(g, dim);
                break;
            }
        }
    }
    _drawAxisYForBar(g, dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        this._drawAxisTitle(g, dim, this.yAxis.title);
        this._yScale = d3.scaleBand()
            .rangeRound([0, dim.h - this._margin.top - this._margin.bottom])
            .padding(0.25)
            .domain(this.xAxis.categories);
        this._yAxisCall = d3
            .axisLeft(this._yScale)
            .tickSizeOuter(0)
            .tickFormat(function (d) {
            return _self._getTickFormatForString(d, this);
        });
        g.append('g')
            .attr('role', 'axis')
            .attr('class', `${this._cls.axis} ${this._cls.barYAxis} ${this.hideAxises ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, 0)`)
            .transition()
            .duration(this.duration)
            .call(this._yAxisCall);
    }
    _drawAxisYForColumn(g, dim) {
        const ticks = this._getTicks().reverse();
        this._drawAxisTitle(g, dim, this.yAxis.title, true);
        this._yScale = d3.scaleLinear()
            .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
            .domain([ticks[0], 0]);
        this._yAxisCall = d3.axisLeft(this._yScale)
            .tickValues(ticks)
            .tickPadding(8)
            .tickFormat((d) => this._getTickFormatForNumber(d))
            .tickSize(-dim.w + this._margin.left + this._margin.right);
        g.append('g')
            .attr('role', 'axis')
            .attr('class', `${this._cls.axis} ${this._cls.colYAxis} ${this.hideAxises ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, 0)`)
            .transition()
            .duration(this.duration)
            .call(this._yAxisCall);
    }
    _drawData(g) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._drawDataBars(g);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._drawDataColumns(g);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._drawDataArea(g);
                break;
            }
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _drawDataBars(g) {
        let baseColor;
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        this._bars = g.append('g')
            .attr('role', 'data')
            .selectAll('g')
            .data(d3.stack().keys(this._keys)(this._data));
        const _xScale = this._xScale;
        this._bars
            .enter()
            .append('g')
            .attr('data-category-id', (d, i) => i)
            .attr('role', 'group')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('aria-label', function (d, i) {
            return _this.series[i].name;
        })
            .attr('class', (d, i) => `category-${i}`)
            .attr('class', this._cls.category)
            .attr('fill', (d) => this._ordinal(d.key))
            .selectAll('rect')
            .data(d => d)
            .enter()
            .append('rect')
            .attr('class', this._cls.dataRect)
            .attr('role', 'item')
            .attr('data-id', (d, id) => id)
            .attr('x', (d) => _xScale(d[0]) + this._margin.left + 1)
            .attr('y', (d) => this._getBarYPosition(d.data.name))
            .attr('width', (d) => _xScale(d[1]) - _xScale(d[0]) === 0 ? this.heightZero : _xScale(d[1]) - _xScale(d[0]))
            .attr('height', this.barWidth ? this.barWidth : this._yScale.bandwidth())
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('mouseenter', function (d) {
            const { target } = d3.event;
            const categoryId = target.parentNode.getAttribute('data-category-id');
            _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipTemplate, {
                data: {
                    color: baseColor,
                    category: _this.series[categoryId].name,
                    value: _this._dividePoints(d[0], d[1]),
                    total: _this._totalByCol[d.data.name],
                    data: _this.series[categoryId],
                    event: d3.event
                }
            });
        })
            .on('mouseleave', function () {
            const rect = d3.select(this);
            _this.chartComponent.hideTooltip();
            rect.attr('fill', null);
        })
            .on('mouseover', function () {
            const self = d3.select(this);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            baseColor = self.select(function () {
                return this.parentNode;
            }).attr('fill');
            const darkenColor = _this._colorService.getDarken(baseColor, .15, ColorType.HEX);
            self.attr('fill', darkenColor);
        });
        if (this.showEmptyColIndicator) {
            // check for the bar(s) with no data
            const zeroBars = Object.keys(this._totalByCol).filter((key) => this._totalByCol[key] === 0);
            // indicate bar with no data
            zeroBars.forEach(bar => {
                const colYPos = this._yScale(bar) - this._margin.top;
                const yAttr = colYPos + this._yScale.bandwidth() / 2 - this._emptyColIndicatorHeight / 2;
                const xAttr = this._margin.left + DEFAULT_MARGIN;
                this._drawEmptyDataIndicator(xAttr, yAttr, bar);
            });
        }
        this._bars.exit().remove();
    }
    _getBarYPosition(d) {
        return this.barWidth
            ? this._yScale(d) + this._margin.top + (this._yScale.bandwidth() / 2) - (this.barWidth / 2)
            : this._yScale(d) + this._margin.top;
    }
    _getWidthForColumn() {
        return this.barWidth
            ? this.barWidth
            : this.isHorizontalSeries
                ? this._xScale.bandwidth() / this.series.length
                : this._xScale.bandwidth();
    }
    _getColumnYPosForHorizontalSeries(d) {
        return this._yScale(d[0] ? d[1] - d[0] : d[1]);
    }
    _dividePoints(a, b) {
        return this.scientificMode
            ? new BigNumber(b).minus(a).toString()
            : Number((b - a).toFixed(6)).toString();
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _getColumnXPos(d, node) {
        const xPos = this._xScale(d) + this._margin.left;
        if (this.isHorizontalSeries) {
            if (this.barWidth) {
                return xPos
                    // Based on category index calculate offset for each bar
                    + (this._getCurrentCategoryIndex(node) - (this.series.length / 2)) * this._getWidthForColumn()
                    + (this._xScale.bandwidth() / 2);
            }
            else {
                return xPos + (this._getCurrentCategoryIndex(node) * this._getWidthForColumn());
            }
        }
        else {
            return this.barWidth
                ? xPos + (this._xScale.bandwidth() / 2) - (this._getWidthForColumn() / 2)
                : xPos;
        }
    }
    _getColumnYPos(d) {
        return this.isHorizontalSeries ?
            this._getColumnYPosForHorizontalSeries(d) :
            this._yScale(d[1]);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _setYPos(d) {
        if (this._yScale(0) - this._getColumnYPosForHorizontalSeries(d) === 0) {
            return this._getColumnYPos(d) - this.heightZero;
        }
        else {
            return this._getColumnYPos(d);
        }
    }
    _setRectPositionAndScaleForColumnsType(selection) {
        return selection
            .attr('x', (d, i, groups) => this._getColumnXPos(d.data.name, groups[i]))
            .attr('y', (d) => this._setYPos(d))
            .attr('height', (d) => this.isHorizontalSeries ?
            (this._yScale(0) - this._getColumnYPosForHorizontalSeries(d) === 0 ?
                this.heightZero : this._yScale(0) - this._getColumnYPosForHorizontalSeries(d)) :
            (this._yScale(d[0]) - this._yScale(d[1]) === 0) ? this.heightZero : this._yScale(d[0]) - this._yScale(d[1]))
            .attr('width', () => this._getWidthForColumn());
    }
    _drawDataColumns(g) {
        let baseColor;
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        this._bars = g.append('g')
            .attr('role', 'data')
            .selectAll('g')
            .data(d3.stack().keys(this._keys)(this._data));
        const gContainer = this._bars
            .enter()
            .append('g')
            .attr('data-category-id', (d, i) => i)
            .attr('role', 'group')
            .attr('aria-label', (d, i) => this.series[i].name)
            .attr('fill', (d) => this._ordinal(d.key))
            .attr('class', this._cls.category)
            .selectAll('rect')
            .data(d => d)
            .enter();
        let selection = gContainer
            .append('rect')
            .attr('class', this._cls.dataRect)
            .attr('role', 'item')
            .attr('aria-label', (d) => `${d.data.name}.: ${this._dividePoints(d[0], d[1])}`)
            .attr('data-id', (d, id) => id);
        selection = this._setRectPositionAndScaleForColumnsType(selection);
        if (this.showEmptyColIndicator) {
            // check for the column(s) with no data
            const zeroCols = Object.keys(this._totalByCol).filter((key) => this._totalByCol[key] === 0);
            // indicate column with no data
            zeroCols.forEach(col => {
                const colXPos = this._xScale(col) + this._margin.left;
                const xAttr = colXPos + this._xScale.bandwidth() / 2 - this._emptyColIndicatorWidth / 2;
                const yAttr = this._dim.h - this._margin.bottom - this._emptyColIndicatorHeight - DEFAULT_MARGIN;
                this._drawEmptyDataIndicator(xAttr, yAttr, col);
            });
        }
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        selection.on('mouseenter', function (d) {
            const { target } = d3.event;
            let sv = 0;
            let i = 0;
            const keys = Object.keys(d.data).filter(k => k !== 'name');
            for (i; i < keys.length; i++) {
                if (d[0] === sv && d[1] === sv + d.data[keys[i]]) {
                    break;
                }
                else {
                    sv += d.data[keys[i]];
                }
            }
            _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipTemplate, {
                data: {
                    color: baseColor,
                    category: keys[i],
                    value: _this._dividePoints(d[0], d[1]),
                    total: _this._totalByCol[d.data.name],
                    data: _this.series.filter((r) => r.name === keys[i]),
                    event: d3.event
                }
            });
        })
            .on('mouseleave', function () {
            const self = d3.select(this);
            _this.chartComponent.hideTooltip();
            self.attr('fill', null);
        })
            .on('mouseover', function () {
            const self = d3.select(this);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            baseColor = self.select(function () {
                return this.parentNode;
            }).attr('fill');
            const darkenColor = _this._colorService.getDarken(baseColor, .15, ColorType.HEX);
            self.attr('fill', darkenColor);
        });
        this._addTotalLabels(g);
        this._bars.exit().remove();
    }
    _drawDataArea(g) {
        const series = d3.stack().keys(this._keys)(this._data);
        const ticks = this._getTicks();
        this._xScale = d3.scalePoint();
        this._xScale
            .range([this._margin.left + this._margin.right, this._dim.w])
            .domain(this.xAxis.categories);
        this._yScale = d3.scaleLinear();
        this._yScale
            .rangeRound([0, this._dim.h - this._margin.bottom - this._margin.top])
            .domain([ticks[ticks.length - 1], 0]);
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const area = d3.area()
            .x((d, i) => this._xScale(this.xAxis.categories[i]))
            .y0(d => this._yScale(d[0]))
            .y1(d => this._yScale(d[1]));
        g.append('g')
            .attr('class', this._cls.areaGroup)
            .selectAll('path')
            .data(series)
            .join('path')
            .attr('data-category-id', (d, i) => i)
            .attr('aria-label', (d, i) => this.series[i].name)
            .attr('fill', (d) => this._ordinal(d.key))
            .attr('class', this._cls.category)
            .attr('d', area);
        this._g.selectAll(`.${this._cls.areaTooltipLines}`).remove();
        this._drawTooltipLinesForArea(g, this._dim);
    }
    _drawTooltipLinesForArea(g, dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        const _xScale = d3.scalePoint()
            .range([0, dim.w - this._margin.left - this._margin.right])
            .domain(this.xAxis.categories);
        const _xAxisCall = d3.axisBottom(_xScale)
            .tickSize(-dim.h + this._margin.top + this._margin.bottom)
            .tickPadding(0);
        const areaBlock = g.append('g')
            .attr('role', 'axis')
            .attr('class', `${this._cls.colYAxis} ${this._cls.areaTooltipLines}`)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`);
        areaBlock.transition().duration(this.duration).call(_xAxisCall);
        areaBlock.select('path').attr('opacity', 0);
        areaBlock.selectAll('g text').remove();
        areaBlock.selectAll('g line').attr('opacity', 0);
        areaBlock
            .selectAll('g')
            .append('rect')
            .attr('pointer-events', 'all')
            .attr('width', 20)
            .attr('height', dim.h - this._margin.top - this._margin.bottom)
            .attr('x', -10)
            .attr('y', -dim.h + this._margin.top + this._margin.bottom)
            .on('mouseover', function (category) {
            const parent = d3.select(this.parentNode);
            parent.select('line').attr('opacity', 1);
            const { target } = d3.event;
            _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipListInfoTemplate, { data: _this.getFormattedSeries({ category, series: _this._data, event: d3.event }) }, null, null, true);
        })
            .on('mouseout', function () {
            const parent = d3.select(this.parentNode);
            parent.select('line').attr('opacity', 0);
            _this.chartComponent.hideTooltip();
        });
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _addTotalLabels(g) {
        const labelsGroup = g.append('g')
            .attr('class', this._cls.totalLabelsGroup)
            .attr('opacity', this.hasTotalLabels ? '1' : '0')
            .attr('text-anchor', 'middle');
        this._createTotalLabelsGroupsItems(labelsGroup);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _createTotalLabelsGroupsItems(labelsGroup) {
        labelsGroup
            .selectAll(`g.${this._cls.totalLabelsGroupItem}`)
            .data(this._getTotalLabelsData())
            .enter()
            .append('g')
            .attr('class', this._cls.totalLabelsGroupItem)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('opacity', (d) => this._getTotalLabelGroupOpacity(d))
            .selectAll('g')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .data((d) => d)
            .enter()
            .append('g')
            .attr('class', this._cls.totalLabelItem)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d, i, groups) => this._getTotalLabelTransform(d, groups[i]))
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .append('text').text((d) => this._getTotalLabelText(d))
            .attr('fill', 'currentColor')
            .exit().remove();
    }
    _getTotalLabelGroupOpacity(d) {
        return (!this.isHorizontalSeries || this._categoryFilter.indexOf(d.key) === -1) ? '1' : '0';
    }
    _getTotalLabelText(d) {
        const value = this.isHorizontalSeries ? d[1] - d[0] : this._totalByCol[d.data.name];
        if (this.totalLabelTextFormatter) {
            return this.totalLabelTextFormatter(value, d);
        }
        return value;
    }
    _getTotalLabelTransform(d, swg) {
        return `translate(${this._getColumnXPos(d.data.name, swg) + this._getWidthForColumn() / 2}, ${this._getColumnYPos(d) - 9})`;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _getTotalLabelsData() {
        const labelsDataArr = d3.stack().keys(this._keys)(this._data);
        return this.isHorizontalSeries ?
            labelsDataArr :
            labelsDataArr.splice(-1);
    }
    _getCurrentCategoryIndex(group) {
        return d3.select(group.parentNode).datum().index;
    }
    _getTicks() {
        const data = this._dataFull.map((row) => {
            const keys = Object.keys(row)
                .filter((key) => key !== 'name');
            return this.isHorizontalSeries ?
                Math.max(...keys.map(key => row[key]))
                : keys.reduce((acc, value) => {
                    return acc + row[value];
                }, 0);
        });
        let max = Math.max(...data);
        if (max === 0) {
            max = 1;
        }
        if (this.thresholdLine && this.thresholdLine > max) {
            max = this.thresholdLine;
        }
        let currentStep = Math.pow(10, Math.floor(Math.log10(max))) / 2;
        const step = Math.pow(10, Math.floor(Math.log10(max))) / 2;
        let count = Math.floor(max / currentStep) + 1;
        while (count >= this._maxTicksCount) {
            currentStep += step;
            count = Math.floor(max / currentStep) + 1;
        }
        return (new Array(count)).fill(0).map((v, id) => (id + 1) * currentStep);
    }
    _clear() {
        this.chartComponent.clear();
        this._data = [];
    }
    _updateData() {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                const _xScale = this._xScale;
                this._g
                    .selectAll(`.${this._cls.category}`)
                    .data(d3.stack().keys(this._keys)(this._data))
                    .selectAll('rect')
                    .data(d => d)
                    .attr('y', (d) => this._yScale(d.data.name) + (this.barWidth ? Math.floor(this._yScale.bandwidth() / 2 - this.barWidth / 2) : 0) + this._margin.top)
                    .attr('height', this.barWidth || this._yScale.bandwidth())
                    .transition()
                    .duration(this.duration)
                    .attr('width', (d) => _xScale(d[1]) - _xScale(d[0]))
                    .attr('x', (d) => _xScale(d[0]) + this._margin.left + 1);
                break;
            }
            case AdaptStackedChartType.Column: {
                const selection = this._g
                    .selectAll(`.${this._cls.category}`)
                    .data(d3.stack().keys(this._keys)(this._data))
                    .selectAll('rect')
                    .data(d => d)
                    .transition()
                    .duration(this.duration);
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                this._setRectPositionAndScaleForColumnsType(selection);
                if (this.showEmptyColIndicator) {
                    /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                    const _self = this;
                    const emptyDataIndicatorLists = this._g.selectAll('g[class="tick empty-column"]');
                    emptyDataIndicatorLists.each(function () {
                        const elem = d3.select(this);
                        const col = elem.attr('aria-column');
                        const colXPos = _self._xScale(col) + _self._margin.left;
                        const xAttr = colXPos + _self._xScale.bandwidth() / 2 - _self._emptyColIndicatorWidth / 2;
                        const yAttr = _self._dim.h - _self._margin.bottom - _self._emptyColIndicatorHeight - DEFAULT_MARGIN;
                        elem.transition().duration(_self.duration).attr('transform', `translate(${xAttr}, ${yAttr})`);
                    });
                }
                break;
            }
            case AdaptStackedChartType.Area: {
                this._g.selectAll(`.${this._cls.areaGroup}`).remove();
                this._drawDataArea(this._g);
                break;
            }
        }
        const totalsGroup = this._g
            .selectAll(`.${this._cls.totalLabelsGroup}`);
        totalsGroup.transition()
            .duration(this.duration)
            .attr('opacity', this.hasTotalLabels ? '1' : '0');
        if (this.hasTotalLabels) {
            const groupsItems = totalsGroup
                .selectAll(`.${this._cls.totalLabelsGroupItem}`)
                .data(this._getTotalLabelsData());
            groupsItems.exit().remove();
            this._createTotalLabelsGroupsItems(totalsGroup);
            groupsItems
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('opacity', (d) => this._getTotalLabelGroupOpacity(d))
                .selectAll(`.${this._cls.totalLabelItem}`)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .data((d) => d)
                .transition()
                .duration(this.duration)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', (d, i, groups) => this._getTotalLabelTransform(d, groups[i]))
                .selectAll('text')
                .text((d) => this._getTotalLabelText(d));
        }
    }
    _updateThresholdLineArea() {
        let thresholdLineArea = this._g.select(`.${this._cls.thresholdLineArea}`);
        if (!this.thresholdLine) {
            thresholdLineArea.remove();
            return;
        }
        if (thresholdLineArea.empty()) {
            thresholdLineArea = this._g.append('g')
                .attr('class', this._cls.thresholdLineArea);
            thresholdLineArea.append('rect')
                .attr('class', 'threshold-area-rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('fill', '#000000')
                .attr('style', 'pointer-events: none; opacity: .1;');
            const defs = thresholdLineArea.append('defs');
            defs.append('marker')
                .attr('class', 'threshold-line-marker')
                .attr('id', `${this._id}-marker-start`)
                .attr('viewBox', '0 0 6 8')
                .attr('markerWidth', 6)
                .attr('markerHeight', 8)
                .attr('refX', 5)
                .attr('refY', 4)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 6 4 L 0 8 z');
            defs.append('marker')
                .attr('class', 'threshold-line-marker')
                .attr('id', `${this._id}-marker-end`)
                .attr('viewBox', '0 0 6 8')
                .attr('markerWidth', 6)
                .attr('markerHeight', 8)
                .attr('refX', 1)
                .attr('refY', 4)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 4 L 6 0 L 6 8 z');
            thresholdLineArea.append('line')
                .attr('class', 'threshold-line')
                .attr('stroke-width', 1)
                .attr('marker-start', `url(#${this._id}-marker-start)`)
                .attr('marker-end', `url(#${this._id}-marker-end)`);
            thresholdLineArea.append('text')
                .attr('class', 'threshold-line-title-background');
            thresholdLineArea.append('text')
                .attr('class', 'threshold-line-title');
        }
        const maxTick = this._getTicks().pop(); // get the max tick
        const chartDataAreaWidth = this._dim.w - this._margin.left - this._margin.right;
        const chartDataAreaHeight = this._dim.h - this._margin.top - this._margin.bottom;
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                const thresholdLineAreaWidth = chartDataAreaWidth - chartDataAreaWidth / maxTick * this.thresholdLine;
                const thresholdLineAreaLeftShift = this._margin.left + chartDataAreaWidth - thresholdLineAreaWidth;
                thresholdLineArea.select('rect.threshold-area-rect')
                    .transition()
                    .duration(this.duration)
                    .attr('transform', `translate(${thresholdLineAreaLeftShift}, 0)`)
                    .attr('width', thresholdLineAreaWidth)
                    .attr('height', chartDataAreaHeight);
                thresholdLineArea.select('line.threshold-line')
                    .transition()
                    .duration(this.duration)
                    .attr('x1', thresholdLineAreaLeftShift)
                    .attr('x2', thresholdLineAreaLeftShift)
                    .attr('y1', this._margin.top)
                    .attr('y2', this._margin.top + chartDataAreaHeight);
                thresholdLineArea.select('text.threshold-line-title-background')
                    .transition()
                    .duration(this.duration)
                    .attr('x', thresholdLineAreaLeftShift)
                    .attr('y', this._margin.top + chartDataAreaHeight)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '24')
                    .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                thresholdLineArea.select('text.threshold-line-title')
                    .transition()
                    .duration(this.duration)
                    .attr('x', thresholdLineAreaLeftShift)
                    .attr('y', this._margin.top + chartDataAreaHeight)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '24')
                    .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                break;
            }
            case AdaptStackedChartType.Column:
            case AdaptStackedChartType.Area: {
                const thresholdLineAreaHeight = chartDataAreaHeight - chartDataAreaHeight / maxTick * this.thresholdLine;
                thresholdLineArea.select('rect.threshold-area-rect')
                    .transition()
                    .duration(this.duration)
                    .attr('transform', `translate(${this._margin.left}, 0)`)
                    .attr('width', chartDataAreaWidth)
                    .attr('height', thresholdLineAreaHeight);
                thresholdLineArea.select('line.threshold-line')
                    .transition()
                    .duration(this.duration)
                    .attr('x1', this._margin.left)
                    .attr('x2', this._dim.w)
                    .attr('y1', thresholdLineAreaHeight)
                    .attr('y2', thresholdLineAreaHeight);
                thresholdLineArea.select('text.threshold-line-title-background')
                    .transition()
                    .duration(this.duration)
                    .attr('x', this._margin.left - 8)
                    .attr('y', thresholdLineAreaHeight)
                    .attr('text-anchor', 'end')
                    .attr('dy', '.32em')
                    .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                thresholdLineArea.select('text.threshold-line-title')
                    .transition()
                    .duration(this.duration)
                    .attr('x', this._margin.left - 8)
                    .attr('y', thresholdLineAreaHeight)
                    .attr('text-anchor', 'end')
                    .attr('dy', '.32em')
                    .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                break;
            }
        }
        // If we have the same tick as the thresholdLine - remove that
        d3.selectAll('g.tick')
            .filter(d => d === this.thresholdLine)
            .remove();
    }
    _drawAxisTitle(g, dim, text, rotate = false) {
        if (!isString$1(text) || this.hideAxises) {
            return;
        }
        let translate;
        const axisTitle = g.append('g')
            .attr('class', `${this._cls.axisTitle} ${(rotate ? this._cls.axisYTitle : this._cls.axisXTitle)}`)
            .attr('role', 'title');
        if (rotate) {
            translate = `rotate(-90) translate(-${(dim.h - this._axisTitleThickness) / 2} ${this._axisTitleThickness / 2})`;
        }
        else {
            translate = `translate(${(dim.w + this._axisTitleThickness) / 2} ${dim.h + this.chartComponent.chartBottomPadding})`;
        }
        axisTitle
            .attr('transform', translate)
            .append('text')
            .text(text)
            .attr('text-anchor', 'middle')
            .attr('transform', `translate(${(this._axisTitleThickness / (rotate ? 2 : 1))} 0)`);
    }
    _updateAxisTitle(g, dim) {
        g.select(`.${this._cls.axisXTitle}`)
            .transition()
            .duration(this.duration)
            .attr('transform', `translate(${(dim.w + this._axisTitleThickness) / 2} ${dim.h + this.chartComponent.chartBottomPadding})`);
    }
    /* Update X Axis */
    _updateAxisX(dim) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._updateAxisXForBar(dim);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._updateAxisXForColumn(dim);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._updateAxisXForArea(dim);
                break;
            }
        }
    }
    _updateAxisXForBar(dim) {
        const ticks = this._getTicks().reverse();
        this._xScale = d3.scaleLinear();
        this._xScale.rangeRound([dim.w - this._margin.left - this._margin.right, 0]).domain([ticks[0], 0]);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickValues(ticks)
            .tickSize(-dim.h + this._margin.top + this._margin.bottom)
            .tickFormat((d, i) => isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver(d, i) : this._getTickFormatForNumber(d))
            .tickPadding(15);
        this._g.select(`.${this._cls.barXAxis}`)
            .transition()
            .duration(this.duration)
            .call(this._xAxisCall);
    }
    _updateAxisXForColumn(dim) {
        this._xScale = d3.scaleBand();
        this._xScale
            .range([0, dim.w - this._margin.left - this._margin.right])
            .padding(0.25)
            .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickFormat(isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
            .tickSizeOuter(0)
            .tickPadding(12);
        this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
        const axisBlock = this._g.select(`.${this._cls.colXAxis}`)
            .attr('class', `${this._cls.axis} ${this._cls.colXAxis} ${this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''}`);
        axisBlock
            .transition()
            .duration(this.duration)
            .call(this._xAxisCall);
        setTimeout(() => {
            this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
            if (!this.hideAxises) {
                axisBlock.classed(this._cls.axisHidden, null);
            }
        }, this.rotateXAxis ? this.duration + 100 : 0);
        this._updateAxisTitle(this._g, dim);
    }
    _updateAxisXForArea(dim) {
        this._xScale = d3.scalePoint();
        this._xScale
            .range([0, dim.w - this._margin.left - this._margin.right])
            .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickFormat(isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
            .tickSizeOuter(0)
            .tickPadding(12);
        this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
        const axisBlock = this._g.select(`.${this._cls.colXAxis}`)
            .attr('class', `${this._cls.axis} ${this._cls.colXAxis} ${this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''}`);
        axisBlock
            .transition()
            .duration(this.duration)
            .call(this._xAxisCall);
        setTimeout(() => {
            this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
            if (!this.hideAxises) {
                axisBlock.classed(this._cls.axisHidden, null);
            }
        }, this.rotateXAxis ? this.duration + 100 : 0);
        this._updateAxisTitle(this._g, dim);
    }
    /* Update Y Axis */
    _updateAxisY(dim) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._updateAxisYForBar(dim);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._updateAxisYForColumn(dim);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._updateAxisYForColumn(dim);
                break;
            }
        }
    }
    _updateAxisYForBar(dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        this._yScale = d3.scaleBand()
            .rangeRound([0, dim.h - this._margin.top - this._margin.bottom])
            .padding(0.25)
            .domain(this.xAxis.categories);
        this._yAxisCall = d3
            .axisLeft(this._yScale)
            .tickSizeOuter(0)
            .tickFormat(function (d) {
            return _self._getTickFormatForString(d, this);
        });
        this._g.select(`.${this._cls.barYAxis}`)
            .transition()
            .duration(this.duration)
            .call(this._yAxisCall);
    }
    _updateAxisYForColumn(dim) {
        const ticks = this._getTicks().reverse();
        this._yScale = d3.scaleLinear()
            .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
            .domain([ticks[0], 0]);
        this._yAxisCall = d3.axisLeft(this._yScale)
            .tickValues(ticks)
            .tickFormat((d) => this._getTickFormatForNumber(d))
            .tickSize(-dim.w + this._margin.left + this._margin.right);
        this._g.select(`.${this._cls.colYAxis}`)
            .transition()
            .duration(this.duration)
            .call(this._yAxisCall);
    }
    _getCustomColorById(id) {
        const customColors = this._legend.customColors;
        const len = customColors.length;
        const index = id % len;
        return customColors[index];
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _getDataRange() {
        return this.sliderData.map((item) => {
            const { name, hidden } = item;
            let { data } = item;
            data = data.slice(this._startDataPiece, this._endDataPiece);
            return { name, data, hidden };
        });
    }
    _getDataLength() {
        return this._series[0].data.length;
    }
    _initSlidePointsCount() {
        const dataLength = this._getDataLength();
        if (dataLength < 12) {
            this.slidePointsCount = 4;
        }
        else if (dataLength >= 12 && dataLength < 36) {
            this.slidePointsCount = 6;
        }
        else {
            this.slidePointsCount = 12;
        }
        this.sliderMonitorsCount = Math.ceil(dataLength / this.slidePointsCount);
    }
    /* empty data indicator */
    _drawEmptyDataIndicator(x, y, column) {
        const emptyGroupInfo = this._g.select('g[role="data"]')
            .append('g')
            .attr('role', 'group')
            .attr('class', 'tick empty-column')
            .attr('aria-label', 'empty column')
            .attr('aria-column', column)
            .attr('transform', `translate(${x}, ${y})`);
        emptyGroupInfo.append('rect')
            .attr('role', 'item')
            .attr('width', this._emptyColIndicatorWidth)
            .attr('height', this._emptyColIndicatorHeight)
            .attr('rx', 2);
        emptyGroupInfo.append('text')
            .attr('x', this._emptyColIndicatorWidth / 2)
            .attr('y', this._emptyColIndicatorHeight / 2)
            .attr('alignment-baseline', 'middle')
            .attr('text-anchor', 'middle')
            .attr('dy', '.1rem')
            .text('0');
    }
    _getTickFormatForNumber(d) {
        return this.scientificMode
            ? new BigNumber(d).toPrecision(2, 2)
            : this._cutNumber.transform(d, 0);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _getTickFormatForString(d, _this) {
        const tickNode = d3.select(_this);
        const ellipsisText = textEllipsis(tickNode, d, this.xAxis ? (this.xAxis.thickness || this._axisXThickness) : 0);
        if (ellipsisText !== d) {
            tickNode
                .on('mouseenter', () => {
                const { target } = d3.event;
                this.chartComponent.showTooltip(target, d);
            })
                .on('mouseleave', () => {
                this.chartComponent.hideTooltip();
            });
        }
        return ellipsisText;
    }
}
AdaptStackedChartComponent.ɵfac = function AdaptStackedChartComponent_Factory(t) { return new (t || AdaptStackedChartComponent)(i0.ɵɵdirectiveInject(CutNumberPipe), i0.ɵɵdirectiveInject(ChartColorService)); };
AdaptStackedChartComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptStackedChartComponent, selectors: [["adapt-stacked-chart"]], viewQuery: function AdaptStackedChartComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$6, 7);
        i0.ɵɵviewQuery(_c1$4, 7);
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(AdaptChartSliderComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipListInfoTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartSliderComponent = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", type: "type", xAxis: "xAxis", yAxis: "yAxis", showSlider: "showSlider", hasTotalLabels: "hasTotalLabels", seriesDisplay: "seriesDisplay", totalLabelTextFormatter: "totalLabelTextFormatter", barWidth: "barWidth", slidePointsCount: "slidePointsCount", hideAxises: "hideAxises", rotateXAxis: "rotateXAxis", xAxisTickFormatResolver: "xAxisTickFormatResolver", scientificMode: "scientificMode", renderLegend: "renderLegend", thresholdLine: "thresholdLine", showEmptyColIndicator: "showEmptyColIndicator", series: "series", legend: "legend" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵProvidersFeature([CutNumberPipe]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 12, vars: 16, consts: [[3, "width", "title", "description", "height", "header", "legend", "renderLegend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "noDataText", "updateChart", "dataBuilder", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave", "clickChart"], ["chart", ""], [3, "slidePointsCount", "height", "xAxis", "data", "containerWidth", "customColors", "leftShift", "type", "stackedChart", "rangeChanged", 4, "ngIf"], ["tooltipTpl", ""], ["tooltipListInfoTpl", ""], [3, "slidePointsCount", "height", "xAxis", "data", "containerWidth", "customColors", "leftShift", "type", "stackedChart", "rangeChanged"], [1, "adapt-chart-tooltip-content-container"], [1, "adapt-chart-tooltip-color-spot"], [1, "adapt-chart-tooltip-category"], [1, "chart-tooltip-content-container", "align-start"], [4, "ngFor", "ngForOf"], [1, "mt-1", "mb-1"], [4, "ngIf"]], template: function AdaptStackedChartComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "adapt-chart", 0, 1);
        i0.ɵɵlistener("categoryShow", function AdaptStackedChartComponent_Template_adapt_chart_categoryShow_1_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptStackedChartComponent_Template_adapt_chart_categoryHide_1_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptStackedChartComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx.categoryEnterHandler($event); })("categoryLeave", function AdaptStackedChartComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx.categoryLeaveHandler($event); })("clickChart", function AdaptStackedChartComponent_Template_adapt_chart_clickChart_1_listener($event) { return ctx.clickChartArea($event); });
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵtemplate(4, AdaptStackedChartComponent_adapt_chart_slider_4_Template, 1, 9, "adapt-chart-slider", 2);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n\n    ");
        i0.ɵɵtemplate(7, AdaptStackedChartComponent_ng_template_7_Template, 23, 5, "ng-template", null, 3, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(9, "\n    ");
        i0.ɵɵtemplate(10, AdaptStackedChartComponent_ng_template_10_Template, 15, 2, "ng-template", null, 4, i0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("width", ctx.width)("title", (ctx.header == null ? null : ctx.header.title) || "Graph chart")("description", (ctx.header == null ? null : ctx.header.subtitle) || "Graph chart")("height", ctx.height)("header", ctx.header)("legend", ctx.legend)("renderLegend", ctx.renderLegend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("noDataText", ctx.noDataText)("updateChart", ctx.updateChart)("dataBuilder", ctx._dataBuilder);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.showSlider);
    } }, directives: [AdaptChartComponent, i3$1.NgIf, AdaptChartSliderComponent, i3$1.NgForOf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptStackedChartComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-stacked-chart',
                template: `
    <adapt-chart #chart
                 [width]="width"
                 [title]="header?.title || 'Graph chart'"
                 [description]="header?.subtitle || 'Graph chart'"
                 [height]="height"
                 [header]="header"
                 [legend]="legend"
                 [renderLegend]="renderLegend"
                 [data]="series"
                 [backgroundColor]="backgroundColor"
                 [suppressHeader]="suppressHeader"
                 [suppressLegend]="suppressLegend"
                 [tooltip]="tooltip"
                 (categoryShow)="categoryShowHandler($event)"
                 (categoryHide)="categoryHideHandler($event)"
                 (categoryEnter)="categoryEnterHandler($event)"
                 (categoryLeave)="categoryLeaveHandler($event)"
                 (clickChart)="clickChartArea($event)"
                 [noDataText]="noDataText"
                 [updateChart]="updateChart"
                 [dataBuilder]="_dataBuilder">
      <adapt-chart-slider *ngIf="showSlider"
                          (rangeChanged)="changeDataRange($event)"
                          [slidePointsCount]="slidePointsCount"
                          [height]="sliderHeight"
                          [xAxis]="xAxis"
                          [data]="sliderData"
                          [containerWidth]="chartWidth"
                          [customColors]="legend?.customColors"
                          [leftShift]="leftShift"
                          [type]="sliderType"
                          [stackedChart]="getStackedChart()"></adapt-chart-slider>
    </adapt-chart>

    <ng-template #tooltipTpl let-data="data">
      <div class="adapt-chart-tooltip-content-container">
        <div>
          <span class="adapt-chart-tooltip-color-spot" [style.background-color]="data?.color"></span>
          <span class="adapt-chart-tooltip-category">{{ data.category }}:</span>
          <span><b>{{ data.value }}</b></span>
        </div>
        <div>
          Total:
          <span><b>{{ data.total }}</b></span>
        </div>
      </div>
    </ng-template>
    <ng-template #tooltipListInfoTpl let-data="data">
      <div class="chart-tooltip-content-container align-start">
        <div *ngFor="let d of data.seriesData">
          <ng-container *ngIf="d.value !== 0">
            <span class="adapt-chart-tooltip-color-spot" [style.background-color]="d?.color"></span>
            <span class="adapt-chart-tooltip-category">{{d.category}}:</span>
            <span><b>{{ d.value }}</b></span>
          </ng-container>
        </div>
        <hr class="mt-1 mb-1">
        <div>
          Total:
          <span><b>{{data.total}}</b></span>
        </div>
      </div>
    </ng-template>`,
                encapsulation: ViewEncapsulation.None,
                providers: [CutNumberPipe]
            }]
    }], function () { return [{ type: CutNumberPipe }, { type: ChartColorService }]; }, { tooltipTemplate: [{
            type: ViewChild,
            args: ['tooltipTpl', { static: true }]
        }], tooltipListInfoTemplate: [{
            type: ViewChild,
            args: ['tooltipListInfoTpl', { static: true }]
        }], chartComponent: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], chartSliderComponent: [{
            type: ViewChild,
            args: [AdaptChartSliderComponent, { static: false }]
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], type: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showSlider: [{
            type: Input
        }], hasTotalLabels: [{
            type: Input
        }], seriesDisplay: [{
            type: Input
        }], totalLabelTextFormatter: [{
            type: Input
        }], barWidth: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }], hideAxises: [{
            type: Input
        }], rotateXAxis: [{
            type: Input
        }], xAxisTickFormatResolver: [{
            type: Input
        }], scientificMode: [{
            type: Input
        }], renderLegend: [{
            type: Input
        }], thresholdLine: [{
            type: Input
        }], showEmptyColIndicator: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], series: [{
            type: Input
        }], legend: [{
            type: Input
        }] }); })();

class AdaptHeatmapAbstract extends AdaptChartAbstract {
}
AdaptHeatmapAbstract.ɵfac = /*@__PURE__*/ function () { let ɵAdaptHeatmapAbstract_BaseFactory; return function AdaptHeatmapAbstract_Factory(t) { return (ɵAdaptHeatmapAbstract_BaseFactory || (ɵAdaptHeatmapAbstract_BaseFactory = i0.ɵɵgetInheritedFactory(AdaptHeatmapAbstract)))(t || AdaptHeatmapAbstract); }; }();
AdaptHeatmapAbstract.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptHeatmapAbstract, inputs: { data: "data", xAxis: "xAxis", yAxis: "yAxis" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptHeatmapAbstract, [{
        type: Directive
    }], null, { data: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }] }); })();

const _c0$5 = ["heatmapDefaultTooltip"];
const _c1$3 = ["menuAnchor"];
const _c2$2 = ["menuContainer"];
function AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 12);
    i0.ɵɵlistener("click", function AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r11); const action_r9 = restoredCtx.$implicit; const ctx_r10 = i0.ɵɵnextContext(4); return ctx_r10.callAction(ctx_r10.menuData.target, ctx_r10.menuData.event, ctx_r10.menuData.context, action_r9); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r9 = ctx.$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n              ", action_r9.title, "\n            ");
} }
function AdaptHeatmapComponent_div_4_ng_template_6_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template, 2, 1, "button", 11);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r7.menuData.actions);
} }
function AdaptHeatmapComponent_div_4_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelementStart(1, "div", 9);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptHeatmapComponent_div_4_ng_template_6_div_3_Template, 4, 1, "div", 10);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n      ");
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r6.menuData && ctx_r6.menuData.actions && ctx_r6.menuData.actions.length);
} }
function AdaptHeatmapComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 4, 5);
    i0.ɵɵlistener("popupAnimationDone", function AdaptHeatmapComponent_div_4_Template_div_popupAnimationDone_0_listener() { i0.ɵɵrestoreView(_r13); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.popupAnimationDone(); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵelement(3, "button", 6, 7);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵtemplate(6, AdaptHeatmapComponent_div_4_ng_template_6_Template, 6, 1, "ng-template", 8);
    i0.ɵɵtext(7, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true);
} }
function AdaptHeatmapComponent_ng_template_6_adapt_icon_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 18);
} if (rf & 2) {
    const c_r14 = i0.ɵɵnextContext().context;
    const ctx_r15 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("color", c_r14.status.iconColor || c_r14.status.color || ctx_r15.defaultColor);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", c_r14.status.icon);
} }
function AdaptHeatmapComponent_ng_template_6_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "small", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const c_r14 = i0.ɵɵnextContext().context;
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(c_r14.info);
} }
function AdaptHeatmapComponent_ng_template_6_div_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "label", 20);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "div", 21);
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelement(7, "div", 22);
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const c_r14 = i0.ɵɵnextContext().context;
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("margin-left", c_r14.progress + "%");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", c_r14.progress, "%");
    i0.ɵɵadvance(4);
    i0.ɵɵstyleProp("width", c_r14.progress + "%");
    i0.ɵɵattribute("aria-valuenow", c_r14.progress);
} }
function AdaptHeatmapComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 13);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "div");
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵtemplate(5, AdaptHeatmapComponent_ng_template_6_adapt_icon_5_Template, 1, 4, "adapt-icon", 14);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵtemplate(8, AdaptHeatmapComponent_ng_template_6_div_8_Template, 5, 1, "div", 15);
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵtemplate(10, AdaptHeatmapComponent_ng_template_6_div_10_Template, 10, 6, "div", 15);
    i0.ɵɵtext(11, "\n        ");
    i0.ɵɵelementStart(12, "div", 16);
    i0.ɵɵtext(13, "\n          ");
    i0.ɵɵelement(14, "div", 17);
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n    ");
} if (rf & 2) {
    const c_r14 = ctx.context;
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", c_r14.status.icon);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", c_r14.name, "\n        ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", c_r14.info);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", c_r14.progress);
    i0.ɵɵadvance(4);
    i0.ɵɵstyleProp("background-color", c_r14.status.bg);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", c_r14.status.name, "\n        ");
} }
const ICON_HEIGHT = 14;
const LINE_HEIGHT = 18;
const NODE_PADDING$1 = 15;
// TODO update types
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
class AdaptHeatmapComponent extends AdaptHeatmapAbstract {
    constructor(_changeDetectorRef, _renderer, _iconConfig) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this._iconConfig = _iconConfig;
        this.hasActionMenu = false;
        this.defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--gray-900');
        // Chart data builder
        this._dataBuilder = (function (g, dim) {
            this._g = g;
            this._calculateMargin();
            const chartWidth = dim.w - (this._margin.left + this._margin.right);
            const chartHeight = dim.h - (this._margin.top + this._margin.bottom);
            const openTooltip = this._openTooltip.bind(this);
            const closeTooltip = this._closeTooltip.bind(this);
            const openMenu = this._openMenu.bind(this);
            const margin = this._margin;
            const ellipsis = this._ellipsis;
            const clickChart = this.clickChart;
            const _data = this._getPreparedData(chartWidth, chartHeight);
            const _getIcon = (name) => this._iconConfig.getIcon(name);
            // Draw chart
            const nodeGroup = this._g.selectAll('g')
                .attr('transform', `translate(${margin.left} ${margin.top})`)
                .data(_data)
                .enter()
                .append('g')
                .attr('class', (d) => `heatmap-node status-group-${d.data.status.name.split(' ').join('_').toLowerCase()}`)
                .attr('id', (d) => d.data.name.split(' ').join('_'))
                .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`)
                .on('mouseenter', function (d) {
                const eventDetail = d3.event.detail;
                const self = d3.select(this);
                if (eventDetail === 0 || (eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.eventSource) !== 'legend') {
                    openTooltip(self.node(), { context: d.data });
                }
                d3.select(this)
                    .selectAll('rect')
                    .each(function () {
                    const _r = d3.select(this).node();
                    if (!_r.classList.contains('menu-icon')) {
                        _r.style.fill = d3.rgb(_r.style.fill).darker(.3).formatHex();
                    }
                });
            })
                .on('mouseleave', function () {
                closeTooltip();
                d3.select(this)
                    .selectAll('rect')
                    .each(function () {
                    const _r = d3.select(this).node();
                    if (!_r.classList.contains('menu-icon')) {
                        _r.style.fill = d3.rgb(_r.style.fill).brighter(.3).formatHex();
                    }
                });
            })
                .on('click', function (d) {
                closeTooltip();
                clickChart.emit(d.data);
                d3.event.stopPropagation();
            });
            nodeGroup.append('g')
                .attr('class', 'treemap-node-bg')
                .each(function (d) {
                const _node = d3.select(this);
                _node.append('rect')
                    .attr('width', d.x1 - d.x0)
                    .attr('height', d.y1 - d.y0)
                    .attr('style', () => {
                    return `
              fill: ${d.data.status.bg};
              opacity: .6;
              transition: fill .2s;
              cursor: pointer;`;
                });
                _node.append('rect')
                    .attr('width', () => {
                    const c = d.data.progress ? d.data.progress / 100 : 1;
                    return (d.x1 - d.x0) * c;
                })
                    .attr('height', d.y1 - d.y0)
                    .attr('style', () => {
                    return `
              fill: ${d.data.status.bg};
              transition: fill .2s;
              cursor: pointer;`;
                });
            });
            const _defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--gray-900');
            nodeGroup.append('g')
                .attr('class', 'treemap-node-text')
                .each(function (d) {
                const _node = d3.select(this);
                let _icon;
                let _info;
                if (d.data.status.icon && (d.y1 - d.y0 > 60)) {
                    _icon = _node.append('g')
                        .attr('transform', `translate(${(d.x1 - d.x0) / 2 - ICON_HEIGHT / 2}, 0)`)
                        .html(_getIcon(d.data.status.icon))
                        .select('svg')
                        .attr('width', ICON_HEIGHT)
                        .attr('height', ICON_HEIGHT)
                        .attr('fill', d.data.status.iconColor || d.data.status.color || _defaultColor);
                }
                const _name = _node.append('text')
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2}, 0)`)
                    .attr('dy', _icon ? LINE_HEIGHT + ICON_HEIGHT : 0)
                    .attr('text-anchor', 'middle')
                    .attr('fill', d.data.status.color || _defaultColor)
                    .attr('style', 'font-size: 13px;');
                ellipsis(_name, d.data.name, d.x1 - d.x0 - NODE_PADDING$1);
                if (_icon) {
                    _node.attr('transform', `translate(0, ${(d.y1 - d.y0) / 2 - ICON_HEIGHT})`);
                }
                else {
                    _node.attr('transform', `translate(0, ${(d.y1 - d.y0) / 2 + LINE_HEIGHT / 2})`);
                }
                if (d.data.info && (d.y1 - d.y0 > 40)) {
                    _info = _node.append('text')
                        .attr('transform', `translate(${(d.x1 - d.x0) / 2}, 0)`)
                        .attr('dy', _icon ? LINE_HEIGHT * 2 + ICON_HEIGHT : LINE_HEIGHT)
                        .attr('text-anchor', 'middle')
                        .attr('fill', d.data.status.color || _defaultColor)
                        .attr('style', 'font-size: 12px; opacity: .7');
                    ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING$1);
                    if (_icon) {
                        _node.attr('transform', `translate(0, ${(d.y1 - d.y0) / 2 - ICON_HEIGHT - LINE_HEIGHT / 2})`);
                    }
                    else {
                        _node.attr('transform', `translate(0, ${(d.y1 - d.y0) / 2})`);
                    }
                }
            });
            // Draw kebab menu icon
            nodeGroup
                .append('g')
                .attr('class', 'heatmap__actions-menu')
                .each(function (d) {
                if (d.data.actions) {
                    const _node = d3.select(this);
                    _node.append('rect')
                        .attr('class', 'menu-icon')
                        .attr('cursor', 'pointer')
                        .attr('fill', 'transparent')
                        .attr('height', 20)
                        .attr('width', 20)
                        .attr('transform', `translate(${(d.x1 - d.x0) - 24}, 10)`);
                    _node.append('g')
                        .attr('transform', `translate(${(d.x1 - d.x0) - 24}, 10)`)
                        .html(ai_ellipsis.data)
                        .select('svg')
                        .attr('cursor', 'pointer')
                        .attr('fill', _defaultColor)
                        .attr('height', 20)
                        .attr('width', 20);
                }
            })
                .on('click', function (d) {
                if (d.data.actions) {
                    const self = d3.select(this);
                    openMenu(self.node(), d3.event, d.data);
                    d3.event.stopPropagation();
                }
            });
            // Draw Axises
            if (this.xAxis) {
                const axisScaleX = d3
                    .scaleBand()
                    .domain(this.xAxis.categories)
                    .range([0, chartWidth]);
                const xAxis = d3.axisBottom(axisScaleX)
                    .tickSizeOuter(0)
                    .tickSize(0)
                    .tickPadding(10);
                this._g.append('g')
                    .attr('class', 'adapt-chart-axis xAxis')
                    .attr('transform', `translate(${margin.left}, ${chartHeight})`)
                    .call(xAxis);
            }
            if (this.yAxis) {
                const axisScaleY = d3
                    .scaleBand()
                    .domain(this.yAxis.categories)
                    .range([0, chartHeight]);
                const yAxis = d3
                    .axisLeft(axisScaleY)
                    .tickSizeOuter(0)
                    .tickSize(0)
                    .tickPadding(10);
                this._g.append('g')
                    .attr('class', 'adapt-chart-axis')
                    .attr('transform', `translate(${margin.left}, 0)`)
                    .call(yAxis);
            }
            SafeCdr.detectChanges(this._changeDetectorRef);
        }).bind(this);
        // Chart update function
        this._updateChart = (function (dim) {
            this._calculateMargin();
            const chartWidth = dim.w - (this._margin.left + this._margin.right);
            const chartHeight = dim.h - (this._margin.top + this._margin.bottom);
            const _data = this._getPreparedData(chartWidth, chartHeight);
            this._g.selectAll('g.heatmap-node')
                .data(_data)
                .transition()
                .duration(200)
                .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`);
            this._g.selectAll('g.treemap-node-bg rect:first-child')
                .data(_data)
                .transition()
                .duration(200)
                .attr('width', (d) => d.x1 - d.x0);
            this._g.selectAll('g.treemap-node-bg rect:last-child')
                .data(_data)
                .transition()
                .duration(200)
                .attr('width', (d) => {
                const c = d.data.progress ? d.data.progress / 100 : 1;
                return (d.x1 - d.x0) * c;
            });
            this._g.selectAll('g.heatmap__actions-menu rect')
                .data(_data.filter((d) => d.data.actions))
                .transition()
                .duration(200)
                .attr('transform', (d) => `translate(${(d.x1 - d.x0) - 24}, 10)`);
            this._g.selectAll('g.heatmap__actions-menu use')
                .data(_data.filter((d) => d.data.actions))
                .transition()
                .duration(200)
                .attr('transform', (d) => `translate(${(d.x1 - d.x0) - 24}, 10)`);
            this._g.selectAll('.treemap-node-text')
                .data(_data)
                .each(function (d) {
                d3.select(this).select('use')
                    .transition()
                    .duration(200)
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2 - ICON_HEIGHT / 2}, 0)`);
                d3.select(this).selectAll('text')
                    .transition()
                    .duration(200)
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2}, 0)`);
            });
            if (this.xAxis) {
                const axisScaleX = d3
                    .scaleBand()
                    .domain(this.xAxis.categories)
                    .range([0, chartWidth]);
                const xAxis = d3.axisBottom(axisScaleX)
                    .tickSizeOuter(0)
                    .tickSize(0)
                    .tickPadding(10);
                this._g.select('g.adapt-chart-axis.xAxis')
                    .transition()
                    .duration(200)
                    .call(xAxis);
            }
        }).bind(this);
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.clickChart = new EventEmitter();
        this._margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        };
        this._closeMenuBind = this._closeMenu.bind(this);
    }
    ngOnInit() {
        if (this.legend) {
            this.legend.columns = 1;
            this.legend.activeHover = false;
            this.legend.activeClick = false;
        }
        this._initLegend();
    }
    ngOnDestroy() {
        this._removeListeners();
    }
    callAction(target, event, context, action) {
        action.callback(target, event, context);
    }
    popupAnimationDone() {
        if (this.menuContainer.isOpen()) {
            this._removeClickEventListener = this._renderer.listen('document', 'click', this._closeMenuBind);
            this._removeScrollEventListener = this._renderer.listen('document', 'scroll', this._closeMenuBind);
        }
        else {
            this._removeListeners();
        }
    }
    _categoryEnter(categoryEvent) {
        // Pass "detail" via custom params to not show the tooltip when items highlighted through legend items hover
        this._g
            .selectAll(`.status-group-${this._legend.items[categoryEvent.id.toString()].split(' ').join('_').toLowerCase()}`)
            .dispatch('mouseenter', { bubbles: true, cancelable: true, detail: { eventSource: 'legend' } });
    }
    _categoryLeave(categoryEvent) {
        this._g
            .selectAll(`.status-group-${this._legend.items[categoryEvent.id.toString()].split(' ').join('_').toLowerCase()}`)
            .dispatch('mouseleave');
    }
    _calculateMargin() {
        this._margin.left = this.yAxis ? 60 : 0;
        this._margin.bottom = this.xAxis ? 38 : 0;
    }
    _getPreparedData(w, h) {
        const padding = 1;
        const chartWidth = Math.round(w);
        const rowCount = this.data.items.length;
        const rowHeight = Math.round(h / rowCount);
        const chartGrid = [];
        this.data.items.forEach((row, rIndex) => {
            let rowWidth = 0;
            row.forEach((el) => {
                rowWidth += el.size;
            });
            let colWidth = this._margin.left + 1;
            const colWidthMultiplier = chartWidth / rowWidth;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            row.forEach((col) => {
                chartGrid.push({
                    data: col,
                    x0: Math.round(colWidth),
                    y0: Math.round(this._margin.top + rowHeight * rIndex),
                    x1: Math.round(colWidth + colWidthMultiplier * col.size - padding),
                    y1: Math.round(this._margin.top + rowHeight * rIndex + rowHeight - padding)
                });
                colWidth += colWidthMultiplier * col.size;
            });
        });
        // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
        this.hasActionMenu = chartGrid.some(item => item.data.actions && item.data.actions.length);
        return chartGrid;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _openMenu(target, event, context) {
        this._closeTooltip();
        this.menuContainer.placement = 'bottom-right';
        this.menuContainer.positionTo = target;
        this.menuData = { target, event, context, actions: context.actions };
        this.menuAnchor.toggleOpen(event);
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    _closeMenu() {
        if (this.menuContainer) {
            this.menuContainer.close();
        }
        this._removeListeners();
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _openTooltip(target, context) {
        this.chartBase.showTooltip(target, this.tooltip || this.heatmapDefaultTooltip, context);
    }
    _closeTooltip() {
        this.chartBase.hideTooltip();
    }
    _initLegend() {
        if (this.suppressLegend) {
            return;
        }
        const legendItems = [];
        this.data.items.forEach((row) => {
            row.forEach((col) => {
                if (col.status) {
                    const sameStatuses = legendItems.filter((lItem) => {
                        return col.status.name === lItem.name;
                    });
                    if (!sameStatuses.length) {
                        legendItems.push({ name: col.status.name, color: col.status.bg });
                    }
                }
            });
        });
        if (legendItems.length) {
            this._legend = {
                columns: 1,
                items: legendItems.map(el => el.name),
                customColors: legendItems.map(el => el.color),
                activeHover: false,
                activeClick: false
            };
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _ellipsis(textNode, text, ellipsisWidth) {
        const letters = text.split('');
        const ellipsis = textNode.append('tspan').attr('class', 'ellipsis').text('...');
        const width = ellipsisWidth - ellipsis.node().getComputedTextLength();
        const numWords = letters.length;
        const tspan = textNode.insert('tspan', ':first-child').text(letters.join(''));
        // Try the whole line
        // While it's too long, and we have words left, keep removing words
        while (tspan.node().getComputedTextLength() > width && letters.length) {
            letters.pop();
            tspan.text(letters.join(''));
        }
        if (letters.length === numWords) {
            ellipsis.remove();
        }
    }
    _removeListeners() {
        if (this._removeClickEventListener) {
            this._removeClickEventListener();
            this._removeClickEventListener = null;
        }
        if (this._removeScrollEventListener) {
            this._removeScrollEventListener();
            this._removeScrollEventListener = null;
        }
    }
}
AdaptHeatmapComponent.ɵfac = function AdaptHeatmapComponent_Factory(t) { return new (t || AdaptHeatmapComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptIconConfig)); };
AdaptHeatmapComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptHeatmapComponent, selectors: [["adapt-heatmap"]], viewQuery: function AdaptHeatmapComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(_c0$5, 7);
        i0.ɵɵviewQuery(_c1$3, 5, AdaptDropdownToggleDirective);
        i0.ɵɵviewQuery(_c2$2, 5, AdaptDropdownDirective);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartBase = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.heatmapDefaultTooltip = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuAnchor = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuContainer = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", data: "data", xAxis: "xAxis", yAxis: "yAxis", noDataText: "noDataText" }, outputs: { clickChart: "clickChart" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 9, vars: 13, consts: [[3, "data", "width", "height", "header", "legend", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "dataBuilder", "updateChart", "noDataText", "categoryEnter", "categoryLeave"], ["chartBase", ""], ["class", "dropdown heatmap-chart_hidden-menu", "adaptDropdown", "", 3, "adaptRadarDisableEventSending", "appendToBody", "popupAnimationDone", 4, "ngIf"], ["heatmapDefaultTooltip", ""], ["adaptDropdown", "", 1, "dropdown", "heatmap-chart_hidden-menu", 3, "adaptRadarDisableEventSending", "appendToBody", "popupAnimationDone"], ["menuContainer", ""], ["adaptDropdownToggle", "", "type", "button"], ["menuAnchor", ""], ["adaptDropdownMenuTemplate", ""], [1, "dropdown-menu"], [4, "ngIf"], ["class", "dropdown-item", "type", "button", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "dropdown-item", 3, "click"], [1, "text-left"], ["class", "icon-inline", 3, "adaptRadarDisableEventSending", "name", "color", 4, "ngIf"], ["class", "pt-2", 4, "ngIf"], [1, "pt-2"], [2, "width", "8px", "height", "8px", "margin", "0 4px 1px 2px", "display", "inline-block", "vertical-align", "middle"], [1, "icon-inline", 3, "adaptRadarDisableEventSending", "name"], [1, "text-secondary"], [1, "progress-label"], [1, "progress"], ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", 1, "progress-bar", "bg-primary-muted"]], template: function AdaptHeatmapComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "adapt-chart", 0, 1);
        i0.ɵɵlistener("categoryEnter", function AdaptHeatmapComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx._categoryEnter($event); })("categoryLeave", function AdaptHeatmapComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx._categoryLeave($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(3, "\n\n    ");
        i0.ɵɵtemplate(4, AdaptHeatmapComponent_div_4_Template, 8, 2, "div", 2);
        i0.ɵɵtext(5, "\n\n    ");
        i0.ɵɵtemplate(6, AdaptHeatmapComponent_ng_template_6_Template, 18, 7, "ng-template", null, 3, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(8, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("data", ctx.data)("width", ctx.width)("height", ctx.height)("header", ctx.header)("legend", ctx._legend)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("dataBuilder", ctx._dataBuilder)("updateChart", ctx._updateChart)("noDataText", ctx.noDataText);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.hasActionMenu);
    } }, directives: [AdaptChartComponent, i3$1.NgIf, i1.AdaptDropdownDirective, i1.AdaptDropdownToggleDirective, i1.AdaptDropdownMenuTemplateDirective, i3$1.NgForOf, i1.AdaptIconComponent], styles: [".heatmap-chart_hidden-menu[_ngcontent-%COMP%] {\n      opacity: 0;\n      visibility: hidden;\n      height: 0\n    }"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptHeatmapComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-heatmap',
                styles: [`
    .heatmap-chart_hidden-menu {
      opacity: 0;
      visibility: hidden;
      height: 0
    }
  `],
                template: `
    <adapt-chart #chartBase
                 [data]="data"
                 [width]="width"
                 [height]="height"
                 [header]="header"
                 [legend]="_legend"
                 [backgroundColor]="backgroundColor"
                 [suppressHeader]="suppressHeader"
                 [suppressLegend]="suppressLegend"
                 [tooltip]="tooltip"
                 [dataBuilder]="_dataBuilder"
                 [updateChart]="_updateChart"
                 [noDataText]="noDataText"
                 (categoryEnter)="_categoryEnter($event)"
                 (categoryLeave)="_categoryLeave($event)"></adapt-chart>

    <div class="dropdown heatmap-chart_hidden-menu"
         adaptDropdown
         #menuContainer
         *ngIf="hasActionMenu"
         [adaptRadarDisableEventSending]="true"
         [appendToBody]="true"
         (popupAnimationDone)="popupAnimationDone()">
      <button #menuAnchor adaptDropdownToggle type="button"></button>
      <ng-template adaptDropdownMenuTemplate>
        <div class="dropdown-menu">
          <div *ngIf="menuData && menuData.actions && menuData.actions.length">
            <button class="dropdown-item"
                    type="button"
                    *ngFor="let action of menuData.actions;"
                    (click)="callAction(menuData.target, menuData.event, menuData.context, action)">
              {{action.title}}
            </button>
          </div>
        </div>
      </ng-template>
    </div>

    <ng-template #heatmapDefaultTooltip let-c="context">
      <div class="text-left">
        <div>
          <adapt-icon class="icon-inline"
                      [adaptRadarDisableEventSending]="true"
                      *ngIf="c.status.icon"
                      [name]="c.status.icon"
                      [style.color]="c.status.iconColor || c.status.color || defaultColor"></adapt-icon>
          {{c.name}}
        </div>
        <div class="pt-2" *ngIf="c.info">
          <small class="text-secondary">{{c.info}}</small>
        </div>
        <div class="pt-2" *ngIf="c.progress">
          <label class="progress-label" [style.marginLeft]="c.progress + '%'">{{c.progress}}%</label>
          <div class="progress">
            <div class="progress-bar bg-primary-muted"
                 role="progressbar"
                 [style.width]="c.progress + '%'"
                 [attr.aria-valuenow]="c.progress"
                 aria-valuemin="0"
                 aria-valuemax="100"></div>
          </div>
        </div>
        <div class="pt-2">
          <div style="width: 8px; height: 8px; margin: 0 4px 1px 2px; display: inline-block; vertical-align: middle"
               [style.backgroundColor]="c.status.bg"></div>
          {{c.status.name}}
        </div>
      </div>
    </ng-template>
  `
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: i1.AdaptIconConfig }]; }, { chartBase: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], heatmapDefaultTooltip: [{
            type: ViewChild,
            args: ['heatmapDefaultTooltip', { static: true }]
        }], menuAnchor: [{
            type: ViewChild,
            args: ['menuAnchor', {
                    read: AdaptDropdownToggleDirective,
                    static: false
                }]
        }], menuContainer: [{
            type: ViewChild,
            args: ['menuContainer', { read: AdaptDropdownDirective, static: false }]
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], legend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], data: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], clickChart: [{
            type: Output
        }] }); })();

class AdaptLineGraphAbstract extends AdaptChartAbstract {
}
AdaptLineGraphAbstract.ɵfac = /*@__PURE__*/ function () { let ɵAdaptLineGraphAbstract_BaseFactory; return function AdaptLineGraphAbstract_Factory(t) { return (ɵAdaptLineGraphAbstract_BaseFactory || (ɵAdaptLineGraphAbstract_BaseFactory = i0.ɵɵgetInheritedFactory(AdaptLineGraphAbstract)))(t || AdaptLineGraphAbstract); }; }();
AdaptLineGraphAbstract.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptLineGraphAbstract, inputs: { xAxis: "xAxis", yAxis: "yAxis", series: "series", hideAxises: "hideAxises" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptLineGraphAbstract, [{
        type: Directive
    }], null, { xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], series: [{
            type: Input
        }], hideAxises: [{
            type: Input
        }] }); })();

const _c0$4 = ["tooltipTpl"];
function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-area-graph-slider", 3);
    i0.ɵɵlistener("rangeChanged", function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_rangeChanged_0_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.rangeChanged($event); })("scrollEnd", function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_scrollEnd_0_listener() { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.scrollEnd(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("data", ctx_r0.sliderData)("xAxis", ctx_r0.xAxis)("slidePointsCount", ctx_r0.slidePointsCount)("customColors", ctx_r0.legend == null ? null : ctx_r0.legend.customColors)("xBrush", ctx_r0.xBrush)("leftShift", ctx_r0.leftShift)("containerWidth", ctx_r0.chartWidth);
} }
function AdaptLineGraphComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 4);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "div", 5);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelement(5, "span", 6);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementStart(7, "span", 7);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementStart(11, "div");
    i0.ɵɵtext(12);
    i0.ɵɵelementStart(13, "span");
    i0.ɵɵelementStart(14, "b");
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n\n    ");
    i0.ɵɵelementStart(18, "div");
    i0.ɵɵtext(19);
    i0.ɵɵelementStart(20, "span");
    i0.ɵɵelementStart(21, "b");
    i0.ɵɵtext(22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n");
} if (rf & 2) {
    const data_r6 = ctx.data;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵstyleProp("background", data_r6 == null ? null : data_r6.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.category);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.getTooltipXValueTitle(), ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.xValue);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.yAxis == null ? null : ctx_r2.yAxis.title, ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.yValue);
} }
let chartCounter$1 = 1;
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
class AdaptLineGraphComponent extends AdaptLineGraphAbstract {
    constructor(_cutNumber, _deviceDetectionService, _colorService, _ngZone, _changeDetectorRef) {
        super();
        this._cutNumber = _cutNumber;
        this._deviceDetectionService = _deviceDetectionService;
        this._colorService = _colorService;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this.alreadyChanged = false;
        this.sliderData = [];
        this.sliderDomainData = [];
        this._dataBuilderBind = this._dataBuilder.bind(this);
        this._updateChartBind = this._updateChart.bind(this);
        this.componentNumericalValues = {
            circleRadius: 6,
            maxTicksCount: 7,
            axisShift: {
                top: 0,
                right: 0,
                bottom: 25,
                left: 25
            },
            margin: {
                top: 0,
                right: 0,
                bottom: 25,
                left: 50
            },
            marginMobile: 40
        };
        this.circleRadius = this.componentNumericalValues.circleRadius;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._series = [];
        this._maxTicksCount = this.componentNumericalValues.maxTicksCount;
        this._data = [];
        this._isDeselected = [];
        this._colors = [];
        this._destroy$ = new ReplaySubject(1);
        this._axisShift = Object.assign({}, this.componentNumericalValues.axisShift);
        this.colorsPalette = 'gradient';
        this.supressAxles = false;
        this.showLineCircles = true;
        this.rotateXAxis = false;
        this.showSlider = false;
        this.disallowPadding = false;
        this.scientificMode = false;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.clickChart = new EventEmitter();
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
        this._thresholdLine = null;
        this._legend = {
            columns: 1,
            activeHover: true,
            activeClick: true,
            width: 250,
            customColors: null,
            items: []
        };
        this._id = `line-graph-${chartCounter$1++}`;
    }
    get _margin() {
        return {
            top: 0,
            left: this.isMobile()
                ? this.componentNumericalValues.marginMobile
                : this.disallowPadding
                    ? 0
                    : this.yAxis && this.yAxis.title ? this.componentNumericalValues.margin.left + this._axisShift.left : this.componentNumericalValues.margin.left,
            right: 0,
            bottom: this.disallowPadding
                ? 0
                : this.xAxis && this.xAxis.title ? this.componentNumericalValues.margin.bottom + this._axisShift.bottom : this.componentNumericalValues.margin.bottom
        };
    }
    get duration() {
        return parseFloat(ANIMATION_DURATION.fast) * 1000;
    }
    /**
     * Threshold line in a chart to help determine which data points are either below or above a significant value
     * @since 10.11.0
     */
    set thresholdLine(value) {
        this._thresholdLine = isNumber(value) ? value : null;
        if (this.alreadyChanged) {
            this._updateThresholdLineArea();
        }
    }
    get thresholdLine() {
        return this._thresholdLine;
    }
    set legend(legend) {
        this._legend = Object.assign(this._legend, legend);
        if (this.alreadyChanged) {
            this.chartComponent.redrawChart();
        }
    }
    get legend() {
        return {
            customColors: this._legend.customColors,
            activeHover: this._legend.activeHover,
            activeClick: this._legend.activeClick,
            columns: this._legend.columns,
            width: this._legend.width,
            items: this.series.map((series) => ({ item: series.name, hidden: !!series.hidden }))
        };
    }
    set series(series) {
        this._series = series;
        this._isDeselected = [];
        series.forEach(s => {
            if (s.hidden) {
                this._isDeselected.push(s.name);
            }
        });
        // such transformation needed for proper display
        // of the slider for area graph
        this.sliderData = [...this.mapDataFromSeries(series)];
        if (this.alreadyChanged) {
            const options = this.chartComponent.getGroupAndDimensions();
            this._g = options.group;
            this._dim = {
                w: options.w,
                h: options.h
            };
        }
        if (this._g && this._dim && this.chartComponent) {
            this.chartComponent.updateLegend(this.series.map((item) => ({
                item: item.name,
                hidden: !!item.hidden,
                hover: false
            })));
        }
    }
    get series() {
        return this._series;
    }
    get leftShift() {
        return this._margin.left;
    }
    get chartWidth() {
        return this.chartComponent.currentSVGWidth;
    }
    ngOnInit() {
        if (this.scientificMode) {
            BigNumber.config({ EXPONENTIAL_AT: 4 });
        }
        this.alreadyChanged = true;
    }
    ngOnChanges(changes) {
        if (this._dim && (changes[this.nameof('showLineCircles')]
            || changes[this.nameof('supressAxles')]
            || changes[this.nameof('rotateXAxis')]
            || changes[this.nameof('showSlider')])) {
            this._detectViewChanges();
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    _dataBuilder(g, dim) {
        this._g = g;
        this._dim = dim;
        this._initClipPath();
        this._clear();
        this._initData();
        this._initAxis(g, dim);
        this._drawLines(g);
        this._drawDropShadow();
        this._updateThresholdLineArea();
    }
    _updateChart(dim, skipUpdateAxisX = false) {
        this._dim = dim; // after updating from toggling legend or create separate method for input
        this._initData();
        // update clipPath
        if (this._g) {
            this._g.select(`#${this._id}_clip > rect`)
                .attr('width', dim.w - (this._margin.left + this._margin.right))
                .attr('height', dim.h - (this._margin.top + this._margin.bottom));
        }
        if (!skipUpdateAxisX) {
            this._updateAxis(dim);
        }
        this._updateDataLines();
        this._updateThresholdLineArea();
    }
    isMobile() {
        return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
    }
    categoryShowHandler(category) {
        const index = this._isDeselected.indexOf(category);
        if (index !== -1) {
            this._isDeselected.splice(index, 1);
        }
        this._updateChart(this._dim, true);
        this.series.forEach((item, ind) => {
            if (item.name.indexOf(category) !== -1) {
                item.hidden = false;
                this._g
                    .select(`[data-line-graph-id='${ind}']`)
                    .style('display', 'block');
            }
        });
        if (!isUndefined(this.chartSliderComponent)) {
            this.chartSliderComponent.showCategory(category);
        }
        this.categoryShow.emit({ category });
    }
    categoryHideHandler(category) {
        this._isDeselected.push(category);
        this.series.forEach((item, index) => {
            if (item.name.indexOf(category) !== -1) {
                item.hidden = true;
                this._g
                    .select(`[data-line-graph-id='${index}']`)
                    .style('display', 'none');
            }
        });
        this._updateChart(this._dim, true);
        if (!isUndefined(this.chartSliderComponent)) {
            this.chartSliderComponent.hideCategory(category);
        }
        this.categoryHide.emit({ category });
    }
    categoryEnter(categoryEvent) {
        const ind = this._isDeselected.indexOf(this.series[categoryEvent.id].name);
        if (ind === -1) {
            const selectedGroup = this._g.select(`g[data-line-graph-id='${categoryEvent.id}']`);
            const selectedLine = selectedGroup.select('path');
            const linesWrapper = selectedGroup.node().parentNode;
            const colorLine = selectedLine.attr('stroke');
            this._highLightColor = colorLine;
            this._pathLines = linesWrapper.querySelectorAll('.line-chart-lines');
            this._pathLines.forEach(line => {
                const pathLineColor = line.getAttribute('stroke');
                if (pathLineColor === colorLine) {
                    line.setAttribute('stroke-width', '3');
                    this._pathLineCurrent = line;
                }
                else {
                    line.setAttribute('stroke-width', '1');
                }
            });
            if (this.showLineCircles) {
                const lineCirclesWrapper = this._g.select('.line-graph-circle-wrapper').node();
                const circles = lineCirclesWrapper.querySelectorAll('.line-graph-circle');
                circles.forEach(circle => {
                    if (circle.getAttribute('fill') !== colorLine) {
                        circle.setAttribute('r', '4');
                    }
                });
            }
        }
    }
    categoryLeave() {
        if (this._pathLineCurrent) {
            this._pathLineCurrent.setAttribute('stroke-width', '2');
        }
        if (this._pathLines) {
            this._pathLines.forEach(line => {
                line.classList.remove('line-graph-transition');
                line.setAttribute('stroke-width', '2');
            });
        }
        if (this.showLineCircles) {
            const lineCirclesWrapper = this._g.select('.line-graph-circle-wrapper').node();
            const circles = lineCirclesWrapper.querySelectorAll('.line-graph-circle');
            circles.forEach(circle => {
                if (circle.getAttribute('fill') !== this._highLightColor) {
                    circle.classList.remove('line-graph-transition');
                    circle.setAttribute('r', '6');
                }
            });
        }
    }
    getTooltipXValueTitle() {
        return this.xAxis ? this.xAxis.title : '';
    }
    rangeChanged(data) {
        this.sliderDomainData = data;
        // In case X axes text are rotated call update on the scroll end.
        // This is prevent incorrect text splitting on multiple lines
        if (!this.rotateXAxis) {
            this._updateXAxis(this._dim);
        }
        this._updateDataLines();
    }
    scrollEnd() {
        if (this.rotateXAxis) {
            this._updateXAxis(this._dim);
        }
    }
    getXAxisLineRenderer(dim) {
        return d3.axisBottom(this._x)
            .tickPadding(10)
            .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
            .tickSizeOuter(0);
    }
    getYPosFunc(dim, ticksVal) {
        return d3.scaleLinear()
            .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
            .domain([ticksVal[0], 0]);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getXPosFunc(dim, domain = []) {
        return d3.scalePoint()
            .range([0, dim.w - (this._margin.left + this._margin.right)])
            .domain(this.xAxis.categories);
    }
    _getCustomColorById(id) {
        const customColors = this.legend.customColors;
        const len = customColors.length;
        const index = id % len;
        return customColors[index];
    }
    _drawLines(g) {
        // TODO check if it can be refactored
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        this._gW = g.append('g')
            .attr('class', 'area-chart-data')
            .attr('transform', `translate(${this._margin.left}, 0)`);
        this._line = this.getLineRenderer();
        this._colors = [];
        this._data.forEach((dt, i) => {
            var _a;
            this._colors.push(((_a = this.legend.customColors) === null || _a === void 0 ? void 0 : _a.length) ? this._getCustomColorById(i) : this._colorService.getColor(i, this.colorsPalette));
            const lineWrapper = this._gW
                .append('g')
                .attr('class', 'line-chart-line-g')
                .attr('display', dt.hidden ? 'none' : 'block')
                .attr('id', this._colors[i])
                .attr('data-line-graph-id', i);
            this.drawLineForSeries(lineWrapper, dt, i);
            this.drawAreaForSeries(lineWrapper, dt, i);
            this.drawLineCircles(lineWrapper, i, dt)
                .on('mouseover', function (d) {
                /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                const circleEl = this;
                _self.onCircleMouseover(circleEl, dt, d);
            })
                .on('mouseout', function () {
                /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                const circleEl = this;
                _self.onCircleMouseout(circleEl);
            });
        });
        this.toggleLineCirclesVisibility(this._g, this.showLineCircles);
    }
    onCircleMouseout(circleEl) {
        const circleRadius = this.circleRadius;
        const circleParentLineEl = this.getCircleLine(circleEl);
        circleParentLineEl.attr('stroke-width', '2');
        const circleSelection = d3.select(circleEl);
        this._gW.selectAll('.line-chart-lines')
            .classed('line-graph-transition', false)
            .attr('stroke-width', '2');
        const baseColor = circleSelection.attr('fill-old');
        d3.selectAll('.line-graph-circle-wrapper .line-graph-circle').each(function () {
            if (d3.select(this).attr('fill') !== baseColor) {
                d3.select(this)
                    .classed('line-graph-transition', false)
                    .attr('r', circleRadius);
            }
        });
        circleSelection
            .attr('fill', baseColor)
            .style('filter', null)
            .attr('fill-old', null);
        this.chartComponent.hideTooltip();
    }
    onCircleMouseover(circleEl, dt, d) {
        const circleSelection = d3.select(circleEl);
        const circleParentLineSelection = this.getCircleLine(circleEl);
        const circleParentLineEl = circleParentLineSelection.node();
        const baseColor = circleSelection.attr('fill');
        circleSelection.attr('fill-old', baseColor);
        const colorHex = this.getCircleDarkenColor(baseColor, circleParentLineSelection);
        d3.selectAll('.line-chart-line-g').each(function () {
            if (d3.select(this).attr('data-id') === baseColor && this.nextElementSibling !== null) {
                this.parentNode.appendChild(this);
            }
        });
        this._gW.selectAll('.line-chart-lines').each(function () {
            if (circleParentLineEl === this) {
                d3.select(this).attr('stroke-width', '3');
            }
            else {
                d3.select(this).classed('line-graph-transition', true).attr('stroke-width', '1');
            }
        });
        d3.selectAll('.line-graph-circle-wrapper .line-graph-circle').each(function () {
            if (d3.select(this).attr('fill') !== baseColor) {
                d3.select(this).classed('line-graph-transition', true).attr('r', 4);
            }
        });
        this.showCircleTooltip(circleParentLineSelection.attr('stroke'), dt, d);
        circleSelection
            .attr('r', 8)
            .style('filter', 'url(#drop-shadow)')
            .attr('fill', colorHex);
    }
    showCircleTooltip(baseColor, dt, 
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    d) {
        this.chartComponent.showTooltip(d3.event.target, this.tooltip || this.tooltipTemplate, {
            data: this.getTooltipData(baseColor, dt, d)
        });
    }
    getTooltipData(baseColor, dt, 
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    d) {
        return {
            color: baseColor,
            category: dt.name,
            xValue: d.date,
            yValue: this.scientificMode ? new BigNumber(d.data) : d.data
        };
    }
    // TODO check if useless arg can be removed
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getCircleDarkenColor(baseColor, circleParentLineSelection) {
        return this._colorService.getDarken(baseColor, .15, ColorType.HEX);
    }
    drawLineCircles(lineWrapper, i, dt) {
        const circleSel = lineWrapper
            .append('g')
            .attr('class', 'line-graph-circle-wrapper')
            .attr('data-id', this._colors[i])
            .selectAll('dots')
            .data(this.getDataForCirclesOrLines(dt))
            .enter()
            .append('circle')
            .attr('r', this.circleRadius)
            .attr('class', 'line-graph-circle')
            .attr('fill', this.getCircleColor(i));
        return this.setCirclePosition(circleSel);
    }
    toggleLineCirclesVisibility(g, isShown) {
        if (g) {
            g.selectAll('.line-graph-circle-wrapper').style('display', isShown ? 'block' : 'none');
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getDataForCirclesOrLines(dt) {
        return dt.data;
    }
    setCirclePosition(
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    circleSel) {
        return circleSel
            .attr('cx', (d) => this._x(d.date))
            .attr('cy', (d) => this._y(d.data));
    }
    drawLineForSeries(lineWrapper, dt, i) {
        return lineWrapper
            .append('path')
            .datum(this.getDataForCirclesOrLines(dt))
            .attr('clip-path', `url(#${this._id}_clip)`)
            .attr('fill', 'none')
            .attr('class', 'line-chart-lines')
            .attr('stroke', this._colors[i])
            .attr('stroke-width', '2')
            .attr('d', this._line);
    }
    getCircleColor(i) {
        return this._colors[i];
    }
    // for overriding
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    drawAreaForSeries(lineWrapper, dt, i) {
        // Nothing to draw
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getLineRenderer() {
        return d3.line()
            .x((d) => this._x(d.date))
            .y((d) => this._y(d.data));
    }
    // for overriding
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    updateLinesAreas() {
    }
    // for overriding
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    restrictXPosTicks() {
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    mapDataFromSeries(series) {
        return series.map((item) => {
            const data = item.data.map((tt, index) => {
                return {
                    date: this.xAxis.categories[index],
                    data: tt
                };
            });
            return {
                name: item.name,
                hidden: item.hidden,
                data
            };
        });
    }
    getDataYValues(row) {
        return row.data.map((item) => item.data);
    }
    nameof(key) {
        return nameof(key);
    }
    _detectViewChanges() {
        this._updateChart(this._dim); // Update chart data
        SafeCdr.detectChanges(this._changeDetectorRef);
        this._ngZone.onStable
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(() => {
            this._ngZone.run(() => {
                this.chartComponent.redrawChart(); // Redraw chart using the latest dimensions
                SafeCdr.detectChanges(this._changeDetectorRef);
            });
        });
    }
    _initAxis(g, dim) {
        const axisWidth = dim.w - this._margin.left - this._margin.right;
        const ticks = this._getTicks().reverse();
        if (this.yAxis && this.yAxis.title) {
            g.append('g')
                .attr('class', 'adapt-chart-axis-title')
                .attr('transform', `rotate(-90) translate(-${(dim.h - this._axisShift.bottom) / 2} ${this._axisShift.left / 2})`)
                .style('opacity', this.supressAxles ? 0 : 1)
                .append('text').text(this.yAxis.title)
                .attr('text-anchor', 'middle')
                .attr('transform', `translate(${(this._axisShift.bottom / 2)} 0)`);
        }
        if (this.xAxis && this.xAxis.title) {
            g.append('g')
                .attr('class', 'adapt-chart-axis-title adapt-chart-axis-title--x')
                .attr('transform', `translate(${(dim.w + this._axisShift.left) / 2} ${dim.h + this.chartComponent.chartBottomPadding})`)
                .style('opacity', this.supressAxles ? 0 : 1)
                .append('text').text(this.xAxis.title)
                .attr('text-anchor', 'middle')
                .attr('transform', `translate(${(this._axisShift.left)} 0)`);
        }
        if (this.xAxis && this.xAxis.categories) {
            this._x = this.xBrush = this.getXPosFunc(dim);
            this.restrictXPosTicks();
        }
        const axisBlock = g.append('g').attr('class', 'axis axis--x');
        this.renderXAxis(dim, axisBlock);
        if (this.rotateXAxis) {
            this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
            this.chartComponent.updateChartBottomPadding(axisWidth, g, this.xAxis, this.rotateXAxis);
        }
        const ticksOrCategs = isUndefined(this.yAxis.categories) ? ticks : this.yAxis.categories.reverse();
        // TODO: can be y axis categories?
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._y = this.getYPosFunc(dim, ticksOrCategs);
        this.renderYAxis(g.append('g').attr('class', 'axis axis--y'), ticksOrCategs, dim);
    }
    renderYAxis(g, ticksVal, dim) {
        g.attr('transform', `translate(${this._margin.left}, 0)`)
            .style('opacity', this.supressAxles ? 0 : 1)
            .call(this.getYAxisRenderer(ticksVal, dim));
    }
    getYAxisRenderer(ticksVal, dim) {
        return d3.axisLeft(this._y)
            .ticks(ticksVal)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .tickValues(ticksVal)
            .tickFormat((d) => {
            if (this.scientificMode) {
                return new BigNumber(d).toPrecision(2, 2);
            }
            else {
                return this._cutNumber.transform(d, 0);
            }
        })
            .tickSize(-dim.w + (this._margin.left + this._margin.right))
            .tickPadding(3);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    renderXAxis(dim, el) {
        el.attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`)
            .style('opacity', this.supressAxles ? 0 : 1)
            .call(
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.getXAxisLineRenderer(dim));
    }
    _updateXAxis(dim) {
        this._x = this.getXPosFunc(dim, this.showSlider && this.slidePointsCount ? this.sliderDomainData : []);
        if (this._g) {
            const axisBlock = this._g.select('.axis--x');
            axisBlock.attr('class', `axis axis--x ${this.rotateXAxis ? 'adapt-chart-axis__hidden' : ''}`);
            this.renderXAxis(dim, axisBlock);
            this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
            this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
            axisBlock.classed('adapt-chart-axis__hidden', null);
            this._g.select('.adapt-chart-axis-title--x')
                .transition()
                .duration(this.duration)
                .attr('transform', `translate(${(dim.w + this._axisShift.left) / 2} ${dim.h + this.chartComponent.chartBottomPadding})`);
            this._g.selectAll('.adapt-chart-axis-title')
                .style('opacity', this.supressAxles ? 0 : 1);
        }
    }
    _updateYAxis(dim) {
        const ticks = this._getTicks().reverse();
        const ticksOrCategs = isUndefined(this.yAxis.categories) ? ticks : this.yAxis.categories.reverse();
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._y = this.getYPosFunc(dim, ticksOrCategs);
        if (this._g) {
            this._g.select('.axis--y')
                .attr('transform', `translate(${this._margin.left}, 0)`)
                .transition()
                .duration(this.duration)
                .call(
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this.getYAxisRenderer(ticksOrCategs, dim));
            this.renderYAxis(this._g.select('.axis--y')
                .transition()
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .duration(this.duration), ticksOrCategs, dim);
        }
    }
    _updateAxis(dim) {
        this._updateXAxis(dim);
        this._updateYAxis(dim);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getCircleLine(el) {
        return d3
            .select(el.closest('.line-chart-line-g'))
            .select('.line-chart-lines');
    }
    _updateDataLines() {
        this._line = this.getLineRenderer();
        if (this._g) {
            this._g.selectAll('.line-chart-lines').attr('d', this._line);
            this._g.selectAll('.line-graph-circle').each((d, i, g) => {
                this.setCirclePosition(d3.select(g[i]));
            });
        }
        this.toggleLineCirclesVisibility(this._g, this.showLineCircles);
        this.updateLinesAreas();
    }
    _initData() {
        this._data = this.mapDataFromSeries(this.series);
    }
    _getTicks() {
        let data = [];
        this._data.forEach(row => {
            data = data.concat(this.getDataYValues(row));
        });
        let max = Math.max(...data);
        if (max === 0) {
            max = 1;
        }
        if (this.thresholdLine && this.thresholdLine > max) {
            max = this.thresholdLine;
        }
        let currentStep = Math.pow(10, Math.floor(Math.log10(max))) / 2;
        const step = Math.pow(10, Math.floor(Math.log10(max))) / 2;
        let count = Math.floor(max / currentStep) + 1;
        while (count >= this._maxTicksCount) {
            currentStep += step;
            count = Math.floor(max / currentStep) + 1;
        }
        return (new Array(count)).fill(0).map((v, id) => (id + 1) * currentStep);
    }
    _initClipPath() {
        // Add a clipPath: we restrict lines appearing by explicitly setting width and height - everything out of this area won't be drawn
        // useful for the situation once we show the graph slider
        this._g.append('defs').append('svg:clipPath')
            .attr('id', `${this._id}_clip`)
            .append('svg:rect')
            .attr('width', this._dim.w - (this._margin.left + this._margin.right))
            .attr('height', this._dim.h - (this._margin.top + this._margin.bottom))
            .attr('x', 0)
            .attr('y', 0);
    }
    _clear() {
        this._data = [];
    }
    _updateThresholdLineArea() {
        const thresholdLineAreaClass = 'threshold-line-area';
        let thresholdLineArea;
        if (this._g) {
            thresholdLineArea = this._g.select(`.${thresholdLineAreaClass}`);
        }
        if (!this.thresholdLine && thresholdLineArea) {
            thresholdLineArea.remove();
            return;
        }
        if (thresholdLineArea === null || thresholdLineArea === void 0 ? void 0 : thresholdLineArea.empty()) {
            thresholdLineArea = this._g.append('g')
                .attr('class', thresholdLineAreaClass);
            thresholdLineArea.append('rect')
                .attr('class', 'threshold-area-rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('fill', '#000000')
                .attr('style', 'pointer-events: none; opacity: .1;');
            const defs = thresholdLineArea.append('defs');
            defs.append('marker')
                .attr('class', 'threshold-line-marker')
                .attr('id', `${this._id}-marker-start`)
                .attr('viewBox', '0 0 6 8')
                .attr('markerWidth', 6)
                .attr('markerHeight', 8)
                .attr('refX', 5)
                .attr('refY', 4)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 6 4 L 0 8 z');
            defs.append('marker')
                .attr('class', 'threshold-line-marker')
                .attr('id', `${this._id}-marker-end`)
                .attr('viewBox', '0 0 6 8')
                .attr('markerWidth', 6)
                .attr('markerHeight', 8)
                .attr('refX', 1)
                .attr('refY', 4)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 4 L 6 0 L 6 8 z');
            thresholdLineArea.append('line')
                .attr('class', 'threshold-line')
                .attr('stroke-width', 1)
                .attr('marker-start', `url(#${this._id}-marker-start)`)
                .attr('marker-end', `url(#${this._id}-marker-end)`);
            thresholdLineArea.append('text')
                .attr('class', 'threshold-line-title-background');
            thresholdLineArea.append('text')
                .attr('class', 'threshold-line-title');
        }
        const maxTick = this._getTicks().pop(); // get the max tick
        const chartDataAreaWidth = this._dim.w - this._margin.left - this._margin.right;
        const chartDataAreaHeight = this._dim.h - this._margin.top - this._margin.bottom;
        const thresholdLineAreaHeight = chartDataAreaHeight - chartDataAreaHeight / maxTick * this.thresholdLine;
        if (thresholdLineArea) {
            thresholdLineArea.select('rect.threshold-area-rect')
                .transition()
                .duration(this.duration)
                .attr('transform', `translate(${this._margin.left}, 0)`)
                .attr('width', chartDataAreaWidth)
                .attr('height', thresholdLineAreaHeight);
            thresholdLineArea.select('line.threshold-line')
                .transition()
                .duration(this.duration)
                .attr('x1', this._margin.left)
                .attr('x2', this._dim.w)
                .attr('y1', thresholdLineAreaHeight)
                .attr('y2', thresholdLineAreaHeight);
            thresholdLineArea.select('text.threshold-line-title-background')
                .transition()
                .duration(this.duration)
                .attr('x', this._margin.left - 8)
                .attr('y', thresholdLineAreaHeight)
                .attr('text-anchor', 'end')
                .attr('dy', '.32em')
                .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
            thresholdLineArea.select('text.threshold-line-title')
                .transition()
                .duration(this.duration)
                .attr('x', this._margin.left - 8)
                .attr('y', thresholdLineAreaHeight)
                .attr('text-anchor', 'end')
                .attr('dy', '.32em')
                .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
        }
        // If we have the same tick as the thresholdLine - remove that
        d3.selectAll('g.tick')
            .filter(d => d === this.thresholdLine)
            .remove();
    }
    _drawDropShadow() {
        const defs = this._g
            .append('defs');
        const filter = defs.append('filter')
            .attr('id', 'drop-shadow')
            .attr('x', '-50%')
            .attr('y', '-50%')
            .attr('width', '180%')
            .attr('height', '180%')
            .attr('filterUnits', 'userSpaceOnUse');
        filter
            .append('feGaussianBlur')
            .attr('in', 'SourceAlpha')
            .attr('stdDeviation', 3);
        filter
            .append('feOffset')
            .attr('dx', 0)
            .attr('dy', 1)
            .attr('result', 'offsetBlur');
        filter
            .append('feOffset')
            .attr('dx', 0)
            .attr('dy', 2)
            .attr('result', 'offsetBlur');
        filter
            .append('feColorMatrix')
            .attr('type', 'matrix')
            .attr('values', '0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.22 0');
        const feMerge = filter
            .append('feMerge');
        feMerge
            .append('feMergeNode');
        feMerge
            .append('feMergeNode')
            .attr('in', 'SourceGraphic');
        feMerge
            .append('feMergeNode')
            .attr('in', 'SourceGraphic');
    }
}
AdaptLineGraphComponent.ɵfac = function AdaptLineGraphComponent_Factory(t) { return new (t || AdaptLineGraphComponent)(i0.ɵɵdirectiveInject(CutNumberPipe), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(ChartColorService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptLineGraphComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptLineGraphComponent, selectors: [["adapt-line-graph"]], viewQuery: function AdaptLineGraphComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$4, 7);
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(AdaptAreaGraphSliderComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartSliderComponent = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", colorsPalette: "colorsPalette", supressAxles: "supressAxles", noDataText: "noDataText", xAxis: "xAxis", yAxis: "yAxis", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", updateChart: "updateChart", showLineCircles: "showLineCircles", rotateXAxis: "rotateXAxis", showSlider: "showSlider", slidePointsCount: "slidePointsCount", disallowPadding: "disallowPadding", scientificMode: "scientificMode", thresholdLine: "thresholdLine", legend: "legend", series: "series" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵProvidersFeature([CutNumberPipe]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 8, vars: 14, consts: [[3, "width", "height", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "header", "noDataText", "updateChart", "dataBuilder", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd", 4, "ngIf"], ["tooltipTpl", ""], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd"], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptLineGraphComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "adapt-chart", 0);
        i0.ɵɵlistener("categoryShow", function AdaptLineGraphComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptLineGraphComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptLineGraphComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptLineGraphComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵtemplate(2, AdaptLineGraphComponent_adapt_area_graph_slider_2_Template, 1, 7, "adapt-area-graph-slider", 1);
        i0.ɵɵtext(3, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(4, "\n\n");
        i0.ɵɵtemplate(5, AdaptLineGraphComponent_ng_template_5_Template, 26, 7, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("width", ctx.width)("height", ctx.height)("legend", ctx.legend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("header", ctx.header)("noDataText", ctx.noDataText)("updateChart", ctx._updateChartBind)("dataBuilder", ctx._dataBuilderBind)("colorsPalette", ctx.colorsPalette);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.showSlider && ctx.slidePointsCount && ctx.chartWidth);
    } }, directives: [AdaptChartComponent, i3$1.NgIf, AdaptAreaGraphSliderComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptLineGraphComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-line-graph',
                templateUrl: './line-graph.component.html',
                providers: [CutNumberPipe],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: CutNumberPipe }, { type: i1.AdaptDeviceDetectionService }, { type: ChartColorService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, { tooltipTemplate: [{
            type: ViewChild,
            args: ['tooltipTpl', { static: true }]
        }], chartComponent: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], chartSliderComponent: [{
            type: ViewChild,
            args: [AdaptAreaGraphSliderComponent, { static: false }]
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], colorsPalette: [{
            type: Input
        }], supressAxles: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], updateChart: [{
            type: Input
        }], showLineCircles: [{
            type: Input
        }], rotateXAxis: [{
            type: Input
        }], showSlider: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }], disallowPadding: [{
            type: Input
        }], scientificMode: [{
            type: Input
        }], thresholdLine: [{
            type: Input
        }], legend: [{
            type: Input
        }], series: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }] }); })();

function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-area-graph-slider", 3);
    i0.ɵɵlistener("rangeChanged", function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_rangeChanged_0_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.rangeChanged($event); })("scrollEnd", function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_scrollEnd_0_listener() { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.scrollEnd(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("data", ctx_r0.sliderData)("xAxis", ctx_r0.xAxis)("slidePointsCount", ctx_r0.slidePointsCount)("customColors", ctx_r0.legend == null ? null : ctx_r0.legend.customColors)("xBrush", ctx_r0.xBrush)("leftShift", ctx_r0.leftShift)("containerWidth", ctx_r0.chartWidth);
} }
function AdaptAreaGraphComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 4);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "div", 5);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelement(5, "span", 6);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementStart(7, "span", 7);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementStart(11, "div");
    i0.ɵɵtext(12);
    i0.ɵɵelementStart(13, "span");
    i0.ɵɵelementStart(14, "b");
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n\n    ");
    i0.ɵɵelementStart(18, "div");
    i0.ɵɵtext(19);
    i0.ɵɵelementStart(20, "span");
    i0.ɵɵelementStart(21, "b");
    i0.ɵɵtext(22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n");
} if (rf & 2) {
    const data_r6 = ctx.data;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵstyleProp("background", data_r6 == null ? null : data_r6.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.category);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.getTooltipXValueTitle(), ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.xValue);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.yAxis == null ? null : ctx_r2.yAxis.title, ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.yValue);
} }
let chartCounter = 1;
class AdaptAreaGraphComponent extends AdaptLineGraphComponent {
    constructor() {
        super(...arguments);
        this._data = [];
        this._series = [];
        this.circleRadius = 4;
        this.areaOpacity = 0.25;
        this.areaOpacityForHovered = 0.75;
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
    }
    getTooltipXValueTitle() {
        return 'x';
    }
    ngOnInit() {
        super.ngOnInit();
        this._id = `area-graph-${chartCounter++}`;
    }
    ngAfterViewInit() {
        // The change consists of two line graphs (one is the main, second in the slider),
        // so need to check the chart view after they both have been drawn
        timer(0, asapScheduler)
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            this._detectViewChanges();
        });
    }
    getXMaxValue(data) {
        let maxYVal = data[0].xyPointData[0].x;
        data.forEach(dataItem => {
            // assume that last value is the biggest value
            const value = dataItem.xyPointData[dataItem.xyPointData.length - 1].x;
            if (value > maxYVal) {
                maxYVal = value;
            }
        });
        return maxYVal;
    }
    getXMinValue(data) {
        let minYVal = data[0].xyPointData[0].x;
        data.forEach(dataItem => {
            // assume that first value is the lowest value
            const value = dataItem.xyPointData[0].x;
            if (value < minYVal) {
                minYVal = value;
            }
        });
        return minYVal;
    }
    getCircleColor() {
        return 'transparent';
    }
    getLineRenderer() {
        return d3.line()
            .x((d) => this._xPos(d.x))
            .y((d) => this._y(d.y));
    }
    getXPosFunc(dim, domain = []) {
        const [min, max] = domain;
        return d3.scaleLinear()
            .range([0, dim.w - (this._margin.left + this._margin.right)])
            .domain([min || this.getXMinValue(this._data), max || this.getXMaxValue(this._data)]);
    }
    getYPosFunc(dim, ticksVal) {
        return d3.scaleLinear()
            .range([0, dim.h - this._margin.bottom - this._margin.top])
            .domain([ticksVal[0], 0]);
    }
    getXAxisLineRenderer(dim) {
        var _a;
        const baseRenderer = super.getXAxisLineRenderer(dim);
        const cats = [...this.xAxis.categories];
        if (cats && cats.length) {
            // for proper rendering with categories
            const maxX = this.getXMaxValue(this._data);
            const minX = this.getXMinValue(this._data);
            const minMaxRange = maxX - minX;
            const tickStep = minMaxRange / (cats.length - 1);
            let tickValuesArray = cats.map((category, index) => minX + tickStep * index);
            if (this.showSlider && ((_a = this.sliderDomainData) === null || _a === void 0 ? void 0 : _a.length)) {
                const [min, max] = this.sliderDomainData;
                tickValuesArray = tickValuesArray.filter((tick, index) => {
                    if (inRange(tick, min, max)) {
                        return true;
                    }
                    cats[index] = null;
                });
            }
            return baseRenderer
                .tickValues(tickValuesArray)
                .tickFormat((val, ind) => cats.filter(category => !!category)[ind]);
        }
        if (this.showSlider && this.slidePointsCount) {
            baseRenderer.ticks(this.slidePointsCount);
        }
        if (this.formatXAxisValue) {
            return baseRenderer.tickFormat(this.formatXAxisValue);
        }
        return baseRenderer;
    }
    mapDataFromSeries(series) {
        return series.map((item) => {
            return {
                name: item.name,
                hidden: item.hidden,
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                data: item.data,
                xyPointData: item.data, // used in area
            };
        });
    }
    // TODO check for type improvement
    // eslint-disable-next-line
    drawAreaForSeries(lineWrapper, dt, i) {
        lineWrapper.append('path')
            .datum(dt.xyPointData)
            .classed('line-graph-transition line-chart-area', true)
            .attr('clip-path', `url(#${this._id}_clip)`)
            .attr('fill', this._colors[i])
            .attr('fill-opacity', this.areaOpacity)
            .attr('stroke', 'none')
            .attr('d', this.getAreaFilling())
            .on('mouseover', (data, ind, group) => {
            this.fillAreaDarkerColor(group[ind]);
        })
            .on('mouseout', (data, ind, group) => {
            this.fillAreaDefaultColor(group[ind]);
        });
    }
    onCircleMouseover(circleEl, dt, d) {
        super.onCircleMouseover(circleEl, dt, d);
        this.fillAreaDarkerColor(d3.select(circleEl.closest('.line-chart-line-g')).select('.line-chart-area').node());
    }
    onCircleMouseout(circleEl) {
        super.onCircleMouseout(circleEl);
        this.fillAreaDefaultColor(d3.select(circleEl.closest('.line-chart-line-g')).select('.line-chart-area').node());
    }
    getCircleDarkenColor(baseColor, circleParentLineSelection) {
        return this._colorService.getDarken(circleParentLineSelection.attr('stroke'), .15, ColorType.HEX);
    }
    getDataForCirclesOrLines(dt) {
        return dt.xyPointData;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    setCirclePosition(circleSel) {
        return circleSel
            .attr('cx', (d) => this._xPos(d.x))
            .attr('cy', (d) => this._y(d.y));
    }
    updateLinesAreas() {
        this._g.selectAll('.line-chart-area').each((dat, i, g) => {
            d3.select(g[i]).attr('d', this.getAreaFilling());
        });
    }
    restrictXPosTicks() {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const ticksCount = this._x.ticks();
        if (this.showSlider && this.slidePointsCount) {
            this._x = d3.scaleLinear()
                .range([0, this._dim.w - (this._margin.left + this._margin.right)])
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .domain([ticksCount[0], ticksCount[this.slidePointsCount]]);
        }
    }
    getTooltipData(baseColor, dt, d) {
        return {
            color: baseColor,
            category: dt.name,
            xValue: d.x,
            yValue: this.scientificMode ? new BigNumber(d.y).toPrecision(2, 2) : d.y,
        };
    }
    getDataYValues(row) {
        return row.xyPointData.map((item) => item.y);
    }
    get _xPos() {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        return this._x;
    }
    getAreaFilling() {
        return d3.area()
            .x((d) => this._xPos(d.x))
            .y0(this._y(0))
            .y1((d) => this._y(d.y));
    }
    fillAreaDarkerColor(el) {
        d3.select(el).attr('fill-opacity', this.areaOpacityForHovered);
    }
    fillAreaDefaultColor(el) {
        d3.select(el).attr('fill-opacity', this.areaOpacity);
    }
}
AdaptAreaGraphComponent.ɵfac = /*@__PURE__*/ function () { let ɵAdaptAreaGraphComponent_BaseFactory; return function AdaptAreaGraphComponent_Factory(t) { return (ɵAdaptAreaGraphComponent_BaseFactory || (ɵAdaptAreaGraphComponent_BaseFactory = i0.ɵɵgetInheritedFactory(AdaptAreaGraphComponent)))(t || AdaptAreaGraphComponent); }; }();
AdaptAreaGraphComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptAreaGraphComponent, selectors: [["adapt-area-graph"]], inputs: { formatXAxisValue: "formatXAxisValue", getTooltipXValueTitle: "getTooltipXValueTitle" }, outputs: { categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵProvidersFeature([CutNumberPipe]), i0.ɵɵInheritDefinitionFeature], decls: 8, vars: 14, consts: [[3, "width", "height", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "header", "noDataText", "updateChart", "dataBuilder", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd", 4, "ngIf"], ["tooltipTpl", ""], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd"], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptAreaGraphComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "adapt-chart", 0);
        i0.ɵɵlistener("categoryShow", function AdaptAreaGraphComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptAreaGraphComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptAreaGraphComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptAreaGraphComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵtemplate(2, AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template, 1, 7, "adapt-area-graph-slider", 1);
        i0.ɵɵtext(3, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(4, "\n\n");
        i0.ɵɵtemplate(5, AdaptAreaGraphComponent_ng_template_5_Template, 26, 7, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("width", ctx.width)("height", ctx.height)("legend", ctx.legend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("header", ctx.header)("noDataText", ctx.noDataText)("updateChart", ctx._updateChartBind)("dataBuilder", ctx._dataBuilderBind)("colorsPalette", ctx.colorsPalette);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.showSlider && ctx.slidePointsCount && ctx.chartWidth);
    } }, directives: [AdaptChartComponent, i3$1.NgIf, AdaptAreaGraphSliderComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptAreaGraphComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-area-graph',
                templateUrl: '../line-graph/line-graph.component.html',
                providers: [CutNumberPipe],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { formatXAxisValue: [{
            type: Input
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], getTooltipXValueTitle: [{
            type: Input
        }] }); })();

class AdaptPieChartAbstract extends AdaptChartAbstract {
}
AdaptPieChartAbstract.ɵfac = /*@__PURE__*/ function () { let ɵAdaptPieChartAbstract_BaseFactory; return function AdaptPieChartAbstract_Factory(t) { return (ɵAdaptPieChartAbstract_BaseFactory || (ɵAdaptPieChartAbstract_BaseFactory = i0.ɵɵgetInheritedFactory(AdaptPieChartAbstract)))(t || AdaptPieChartAbstract); }; }();
AdaptPieChartAbstract.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptPieChartAbstract, inputs: { innerRadius: "innerRadius", series: "series" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptPieChartAbstract, [{
        type: Directive
    }], null, { innerRadius: [{
            type: Input
        }], series: [{
            type: Input
        }] }); })();

const _c0$3 = ["chart"];
const _c1$2 = ["tooltipTpl"];
function AdaptPieChartComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 3);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelement(3, "span", 4);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementStart(5, "span", 5);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementStart(8, "b");
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementStart(10, "span");
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n          ");
    i0.ɵɵelementStart(13, "span");
    i0.ɵɵtext(14);
    i0.ɵɵpipe(15, "percent");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n    ");
} if (rf & 2) {
    const data_r3 = ctx.data;
    i0.ɵɵadvance(3);
    i0.ɵɵstyleProp("background-color", data_r3.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r3.category);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(data_r3.value);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("(", i0.ɵɵpipeBind1(15, 5, data_r3.value / data_r3.total), ")");
} }
// TODO fix types
class AdaptPieChartComponent extends AdaptPieChartAbstract {
    constructor(_colorService) {
        super();
        this._colorService = _colorService;
        this.$this = this;
        this.showLegendTooltip = false;
        this.clickChart = new EventEmitter();
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
        this.alreadyChanged = false;
        this._dataBuilder = (function (g, dim) {
            this._clear();
            this._g = g;
            this._dim = dim;
            this._renderChart();
        }).bind(this);
        // TODO check if it can be refactored
        this._updateChart = (function () {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            const __this = this;
            const oldData = this._pie(this._data);
            const data = this.series.map((d) => {
                return {
                    name: d.name,
                    y: this._filter.indexOf(d.name) === -1 ? d.y : 0
                };
            });
            this.total = data.reduce((acc, cur) => {
                acc += cur.y;
                return acc;
            }, 0);
            this._initData();
            this._path = this._path.data(this._pie(this._data));
            this._path
                .transition()
                .duration(this.duration)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attrTween('d', function (d, index) {
                const startInter = d3.interpolate(oldData[index].startAngle, d.startAngle);
                const endInter = d3.interpolate(oldData[index].endAngle, d.endAngle);
                return function (t) {
                    d.startAngle = startInter(t);
                    d.endAngle = endInter(t);
                    return __this._arc(d);
                };
            });
            if (this.innerRadius > 1) {
                this._g
                    .selectAll('.adapt-pie-chart-main-label-sum')
                    .text(`${this.total}`);
            }
        }).bind(this);
        this.donutProportion = 16 / 25;
        this._filter = [];
        this._cls = {
            arc: 'arc',
            arcPart: 'arc-part',
            segment: 'arc-segment',
            sectorIdentifier: 'adapt-pie-chart-sector',
            summary: 'adapt-pie-chart-summary',
            summaryLabel: 'adapt-pie-chart-main-label',
            summaryText: 'adapt-pie-chart-main-label-sum'
        };
        this._legend = {
            columns: 1,
            activeHover: true,
            activeClick: true,
            width: 250,
            customColors: null,
            items: []
        };
        this._series = [];
        this._legendTooltipPoint = { x: 0, y: 0 };
    }
    set series(s) {
        this._series = s;
        if (s) {
            this._updateFilter(s);
        }
        if (this.alreadyChanged) {
            const options = this.chartComponent.getGroupAndDimensions();
            this._g = options.group;
            this._dim = {
                w: options.w,
                h: options.h
            };
        }
        if (this._g && this._dim && this.chartComponent) {
            this.chartComponent.updateLegend(this.series.map((item) => ({
                item: item.name,
                hidden: !!item.hidden,
                hover: false
            })));
        }
    }
    get series() {
        return this._series;
    }
    set legend(legend) {
        this._legend = Object.assign(this._legend, legend);
    }
    get legend() {
        return {
            customColors: this._legend.customColors,
            activeHover: this._legend.activeHover,
            activeClick: this._legend.activeClick,
            columns: this._legend.columns,
            width: this._legend.width,
            items: (this.series && this.series.map((series) => ({
                item: series.name,
                hidden: !!series.hidden
            })))
        };
    }
    get duration() {
        return parseFloat(ANIMATION_DURATION.fast) * 1000;
    }
    ngOnInit() {
        if (this.header) {
            this.header.allowHideLegend = false;
        }
    }
    ngOnChanges() {
        if (this.alreadyChanged && this._g && this._dim) {
            this._data = [];
            this._updateFilter(this.series);
            this._clear();
            this._renderChart();
            this._updateChart();
        }
        this.alreadyChanged = true;
    }
    categoryEnter(categoryEvent) {
        const group = this._g.select(`#adapt-pie-chart-sector-${categoryEvent.id}`);
        const color = group.attr('fill');
        const hoverColor = this._colorService.getDarken(color, .15, ColorType.HEX);
        this._initialColor = color;
        group.attr('fill', hoverColor);
        if (this.showLegendTooltip) {
            this._legendTooltipPoint.x = categoryEvent.event.clientX;
            this._legendTooltipPoint.y = categoryEvent.event.clientY;
            const id = categoryEvent.id;
            const tooltipTpl = this.tooltip || this.tooltipTemplate;
            const data = this.series.map((d) => {
                return {
                    name: d.name,
                    y: this._filter.indexOf(d.name) === -1 ? d.y : 0
                };
            });
            this.chartComponent.showTooltip(this._legendTooltipPoint, tooltipTpl, {
                data: {
                    color: this._legend.customColors ? this._getCustomColorById(id) : this._colorService.getColor(id),
                    category: data[id].name,
                    value: this.series[id].y,
                    total: this.total,
                    data: this.series[id],
                    event: categoryEvent.event
                }
            });
        }
    }
    categoryLeave(categoryEvent) {
        const group = this._g.select(`#adapt-pie-chart-sector-${categoryEvent.id}`);
        group.attr('fill', this._initialColor);
        if (this.showLegendTooltip) {
            this.chartComponent.hideTooltip();
        }
    }
    categoryMove(categoryEvent) {
        this._legendTooltipPoint.x = categoryEvent.event.clientX;
        this._legendTooltipPoint.y = categoryEvent.event.clientY;
        this.chartComponent.updateTooltip();
    }
    categoryShowHandler(category) {
        const categoryId = this._filter.indexOf(category);
        if (categoryId !== -1) {
            this._filter.splice(categoryId, 1);
            this._updateChart();
        }
        this.categoryShow.emit({ category });
    }
    categoryHideHandler(category) {
        this._filter.push(category);
        this._updateChart();
        this.categoryHide.emit({ category });
    }
    clickChartArea(e) {
        var _a;
        const target = e.target;
        const isSector = target.classList.contains(this._cls.segment);
        if (isSector) {
            const id = (_a = target.parentNode) === null || _a === void 0 ? void 0 : _a.getAttribute('id');
            const index = id.split('-').reverse()[0];
            const total = this.series.reduce((acc, v) => acc + v.y, 0);
            const color = d3.select(target.parentNode).attr('fill');
            this.clickChart.emit({
                event: e,
                data: this.series[index],
                color,
                category: this.series[index].name,
                value: this.series[index].y,
                total
            });
        }
    }
    _renderChart() {
        this._initData();
        if (this.innerRadius > 0) {
            this._addSummary();
        }
        this._createColor();
        this._createPie();
        this._createDataChart();
    }
    _initData() {
        this._data = this.series.map((d) => this._filter.indexOf(d.name) === -1 ? d.y : 0);
    }
    _createColor() {
        this._colors = this._data.map((d, id) => {
            return this._legend.customColors ? this._getCustomColorById(id) : this._colorService.getColor(id);
        });
        this._radius = Math.min(this._dim.w, this._dim.h) / 2;
        this._g.attr('transform', `translate(${this._radius} ${this._radius})`);
        this._arc = d3.arc()
            .innerRadius(this._getInnerRadius())
            .outerRadius(this._radius);
    }
    _createPie() {
        this._pie = d3.pie()
            .sort(null);
    }
    _createDataChart() {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const __this = this;
        const tooltipTpl = this.tooltip || this.tooltipTemplate;
        const data = this.series.map((d) => {
            return {
                name: d.name,
                y: this._filter.indexOf(d.name) === -1 ? d.y : 0
            };
        });
        const arc = this._g.selectAll(`.${this._cls.arc}`)
            .data(this._pie(this._data))
            .enter()
            .each((d) => {
            d.outerRadius = this._radius;
        })
            .append('g')
            .attr('class', this._cls.arcPart)
            .attr('id', (d, id) => `${this._cls.sectorIdentifier}-${id}`)
            .attr('fill', (d, colorId) => this._colors[colorId]);
        this.total = data.reduce((acc, cur) => {
            acc += cur.y;
            return acc;
        }, 0);
        this._path = arc.append('path')
            .attr('class', this._cls.segment)
            .attr('d', this._arc);
        const tooltipAnchorPoint = { x: 0, y: 0 };
        this._path.on('mouseenter', (d) => {
            const { clientX, clientY } = d3.event;
            const { index, value } = d;
            tooltipAnchorPoint.x = clientX;
            tooltipAnchorPoint.y = clientY;
            this.chartComponent.showTooltip(tooltipAnchorPoint, tooltipTpl, {
                data: {
                    color: __this._legend.customColors ? __this._getCustomColorById(index) : __this._colorService.getColor(index),
                    category: data[index].name,
                    value: value,
                    total: this.total,
                    data: __this.series[index],
                    event: d3.event
                }
            });
        });
        this._path.on('mousemove', () => {
            const { clientX, clientY } = d3.event;
            tooltipAnchorPoint.x = clientX;
            tooltipAnchorPoint.y = clientY;
            this.chartComponent.updateTooltip();
        });
        arc.on('mouseenter', function () {
            __this._initialColor = d3.select(this)
                .attr('fill');
            d3.select(this)
                .attr('fill', __this._colorService.getDarken(__this._initialColor, .15, ColorType.HEX));
        })
            .on('mouseout', function () {
            __this.chartComponent.hideTooltip();
            d3.select(this)
                .attr('fill', __this._initialColor);
        });
    }
    _getInnerRadius() {
        const maxInnerRadius = this._radius * (1 + this.donutProportion) / 2;
        let minInnerRadius = this._radius * (1 - (1 - this.donutProportion) * 2);
        let innerRadius = 0;
        if (this.innerRadius > 0) {
            const node = this._g
                .select(`.${this._cls.summary}`)
                .node();
            const width = node ? node.getBoundingClientRect().width : 0;
            minInnerRadius = Math.floor(width / 2) + 15;
        }
        if (!isUndefined(this.innerRadius) || this.innerRadius > 0) {
            innerRadius = this.innerRadius;
            innerRadius = innerRadius < minInnerRadius ? minInnerRadius : innerRadius;
            innerRadius = innerRadius > maxInnerRadius ? maxInnerRadius : innerRadius;
        }
        return innerRadius;
    }
    _clear() {
        if (this._g) {
            this._g.selectAll('*').remove();
        }
    }
    _addSummary() {
        const data = this.series.map((d) => {
            return {
                name: d.name,
                y: this._filter.indexOf(d.name) === -1 ? d.y : 0
            };
        });
        const text = this._g
            .append('text')
            .attr('class', this._cls.summary);
        this.total = data.reduce((acc, cur) => {
            acc += cur.y;
            return acc;
        }, 0);
        text.append('tspan')
            .attr('text-anchor', 'middle')
            .attr('x', 0)
            .attr('y', '-.4em')
            .attr('class', this._cls.summaryLabel)
            .text('Total');
        text.append('tspan')
            .attr('text-anchor', 'middle')
            .attr('x', 0)
            .attr('y', '.8em')
            .attr('class', this._cls.summaryText)
            .text(`${this.total}`);
    }
    _getCustomColorById(id) {
        const customColors = this._legend.customColors;
        const len = customColors.length;
        const index = id % len;
        return customColors[index];
    }
    _updateFilter(series) {
        this._filter = [];
        series.forEach(s => {
            if (s.hidden) {
                this._filter.push(s.name);
            }
        });
    }
}
AdaptPieChartComponent.ɵfac = function AdaptPieChartComponent_Factory(t) { return new (t || AdaptPieChartComponent)(i0.ɵɵdirectiveInject(ChartColorService)); };
AdaptPieChartComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptPieChartComponent, selectors: [["adapt-pie-chart"]], viewQuery: function AdaptPieChartComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(_c0$3, 7);
        i0.ɵɵviewQuery(_c1$2, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chart = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", innerRadius: "innerRadius", showLegendTooltip: "showLegendTooltip", series: "series", legend: "legend" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 7, vars: 12, consts: [[3, "width", "height", "header", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "noDataText", "updateChart", "dataBuilder", "categoryEnter", "categoryLeave", "categoryMove", "categoryShow", "categoryHide", "clickChart"], ["chart", ""], ["tooltipTpl", ""], [1, "adapt-pie-chart-tooltip"], [1, "adapt-pie-chart-tooltip__color"], [1, "adapt-pie-chart-tooltip__category"]], template: function AdaptPieChartComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "adapt-chart", 0, 1);
        i0.ɵɵlistener("categoryEnter", function AdaptPieChartComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptPieChartComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx.categoryLeave($event); })("categoryMove", function AdaptPieChartComponent_Template_adapt_chart_categoryMove_1_listener($event) { return ctx.categoryMove($event); })("categoryShow", function AdaptPieChartComponent_Template_adapt_chart_categoryShow_1_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptPieChartComponent_Template_adapt_chart_categoryHide_1_listener($event) { return ctx.categoryHideHandler($event); })("clickChart", function AdaptPieChartComponent_Template_adapt_chart_clickChart_1_listener($event) { return ctx.clickChartArea($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(3, "\n\n    ");
        i0.ɵɵtemplate(4, AdaptPieChartComponent_ng_template_4_Template, 19, 7, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(6, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("width", ctx.$this.width)("height", ctx.$this.height)("header", ctx.$this.header)("legend", ctx.$this.legend)("data", ctx.series)("backgroundColor", ctx.$this.backgroundColor)("suppressHeader", ctx.$this.suppressHeader)("suppressLegend", ctx.$this.suppressLegend)("tooltip", ctx.$this.tooltip)("noDataText", ctx.noDataText)("updateChart", ctx._updateChart)("dataBuilder", ctx._dataBuilder);
    } }, directives: [AdaptChartComponent], pipes: [i3$1.PercentPipe], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptPieChartComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-pie-chart',
                template: `
    <adapt-chart #chart
                 [width]="$this.width"
                 [height]="$this.height"
                 [header]="$this.header"
                 [legend]="$this.legend"
                 [data]="series"
                 [backgroundColor]="$this.backgroundColor"
                 [suppressHeader]="$this.suppressHeader"
                 [suppressLegend]="$this.suppressLegend"
                 [tooltip]="$this.tooltip"
                 (categoryEnter)="categoryEnter($event)"
                 (categoryLeave)="categoryLeave($event)"
                 (categoryMove)="categoryMove($event)"
                 (categoryShow)="categoryShowHandler($event)"
                 (categoryHide)="categoryHideHandler($event)"
                 (clickChart)="clickChartArea($event)"
                 [noDataText]="noDataText"
                 [updateChart]="_updateChart"
                 [dataBuilder]="_dataBuilder"></adapt-chart>

    <ng-template #tooltipTpl let-data="data">
      <div class="adapt-pie-chart-tooltip">
        <span [style.background-color]="data.color" class="adapt-pie-chart-tooltip__color"></span>
        <span class="adapt-pie-chart-tooltip__category">{{data.category}}</span>
        <b>
          <span>{{data.value}}</span>
          <span>({{data.value / data.total | percent}})</span>
        </b>
      </div>
    </ng-template>
  `,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: ChartColorService }]; }, { backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], showLegendTooltip: [{
            type: Input
        }], series: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], legend: [{
            type: Input
        }], chartComponent: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], chart: [{
            type: ViewChild,
            args: ['chart', { static: true }]
        }], tooltipTemplate: [{
            type: ViewChild,
            args: ['tooltipTpl', { static: true }]
        }] }); })();

class AdaptScatterPlotAbstract extends AdaptChartAbstract {
}
AdaptScatterPlotAbstract.ɵfac = /*@__PURE__*/ function () { let ɵAdaptScatterPlotAbstract_BaseFactory; return function AdaptScatterPlotAbstract_Factory(t) { return (ɵAdaptScatterPlotAbstract_BaseFactory || (ɵAdaptScatterPlotAbstract_BaseFactory = i0.ɵɵgetInheritedFactory(AdaptScatterPlotAbstract)))(t || AdaptScatterPlotAbstract); }; }();
AdaptScatterPlotAbstract.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptScatterPlotAbstract, inputs: { xAxis: "xAxis", yAxis: "yAxis", series: "series", hideAxises: "hideAxises" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptScatterPlotAbstract, [{
        type: Directive
    }], null, { xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], series: [{
            type: Input
        }], hideAxises: [{
            type: Input
        }] }); })();

const _c0$2 = ["tooltipTpl"];
function AdaptScatterPlotComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 2);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "div", 3);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelement(5, "span", 4);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementStart(7, "span", 5);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementStart(11, "div");
    i0.ɵɵtext(12);
    i0.ɵɵelementStart(13, "span");
    i0.ɵɵelementStart(14, "b");
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n\n    ");
    i0.ɵɵelementStart(18, "div");
    i0.ɵɵtext(19);
    i0.ɵɵelementStart(20, "span");
    i0.ɵɵelementStart(21, "b");
    i0.ɵɵtext(22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n");
} if (rf & 2) {
    const data_r2 = ctx.data;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵstyleProp("background", data_r2 == null ? null : data_r2.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r2 == null ? null : data_r2.category);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r1.xAxis == null ? null : ctx_r1.xAxis.title, ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r2.xValue);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r1.yAxis == null ? null : ctx_r1.yAxis.title, ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r2.yValue);
} }
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
class AdaptScatterPlotComponent extends AdaptScatterPlotAbstract {
    constructor(_cutNumber, _deviceDetectionService, _colorService) {
        super();
        this._cutNumber = _cutNumber;
        this._deviceDetectionService = _deviceDetectionService;
        this._colorService = _colorService;
        this.alreadyChanged = false;
        this.scientificMode = false;
        this.clickChart = new EventEmitter();
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
        this._series = [];
        this._margin = {
            top: 0,
            right: 0,
            bottom: 25,
            left: 30
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._colors = [];
        this._axisShift = {
            top: 0,
            right: 0,
            bottom: 25,
            left: 25
        };
        this._axisScientificLeftShift = 60;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._generatedData = [];
        this._isDeselected = [];
        this._legend = {
            columns: 1,
            activeHover: true,
            activeClick: true,
            width: 250,
            customColors: null,
            items: []
        };
        this._updateChart = (dim) => {
            this._updatedScatterChart(dim);
        };
        this._dataBuilder = (g, dim) => {
            this._g = g;
            this._dim = dim;
            this._initAxis(g, dim);
            this._drawLines(g);
            this._drawDropShadow();
        };
    }
    set series(s) {
        this._series = s;
        this._isDeselected = [];
        s.forEach(series => {
            if (series.hidden) {
                this._isDeselected.push(series.name);
            }
        });
        if (this.alreadyChanged) {
            const options = this.chartComponent.getGroupAndDimensions();
            this._g = options.group;
            this._dim = {
                w: options.w,
                h: options.h
            };
        }
        if (this._g && this._dim && this.chartComponent) {
            this.chartComponent.updateLegend(this.series.map((item) => item.name));
        }
    }
    get series() {
        return this._series;
    }
    set legend(legend) {
        this._legend = Object.assign(this._legend, legend);
        if (this.alreadyChanged) {
            this.chartComponent.redrawChart();
        }
    }
    get legend() {
        return {
            customColors: this._legend.customColors,
            activeHover: this._legend.activeHover,
            activeClick: this._legend.activeClick,
            columns: this._legend.columns,
            width: this._legend.width,
            items: (this.series && this.series.map((series) => ({
                item: series.name,
                hidden: !!series.hidden
            })))
        };
    }
    get duration() {
        return parseFloat(ANIMATION_DURATION.fast) * 1000;
    }
    get axisShiftLeft() {
        return this.scientificMode ? this._axisScientificLeftShift : this._axisShift.left;
    }
    ngOnInit() {
        if (this.isMobile()) {
            this._margin.left = 40;
        }
        if (this.xAxis && this.xAxis.title) {
            this._margin.bottom += this._axisShift.bottom;
        }
        if (this.yAxis && this.yAxis.title) {
            this._margin.left += this.axisShiftLeft;
        }
        this.alreadyChanged = true;
    }
    isMobile() {
        return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
    }
    categoryShowHandler(category) {
        const ind = this._isDeselected.indexOf(category);
        if (ind !== -1) {
            this._isDeselected.splice(ind, 1);
        }
        this._updatedScatterChart(this._dim);
        this.series.forEach((item, index) => {
            if (item.name.indexOf(category) !== -1) {
                item.hidden = false;
                this._g
                    .select(`[data-line-graph-id='${index}']`)
                    .style('transition', 'all .3s ease')
                    .style('opacity', '1')
                    .style('visibility', 'visible')
                    .attr('data-disabled', 'false');
            }
        });
        this.categoryShow.emit({ category });
    }
    categoryHideHandler(category) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        this._isDeselected.push(category);
        this.series.forEach((item, index) => {
            if (item.name.indexOf(category) !== -1) {
                item.hidden = true;
                this._g
                    .select(`[data-line-graph-id='${index}']`)
                    .style('transition', 'all .3s ease')
                    .style('opacity', '0')
                    .style('visibility', 'hidden');
            }
        });
        d3.selectAll('.scatter-regression-line')
            .each(function () {
            if (d3.select(this).attr('id') === _self._highLightColor) {
                _self._regLine = d3.select(this);
                _self._regLine
                    .style('visibility', 'hidden')
                    .style('opacity', '0');
            }
        });
        this._updatedScatterChart(this._dim);
        this.categoryHide.emit({ category });
    }
    categoryEnter(categoryEvent) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        const ind = this._isDeselected.indexOf(this.series[categoryEvent.id].name);
        if (ind === -1) {
            const selectedLine = this._g.select(`[data-line-graph-id='${categoryEvent.id}']  .scatter-plot-circle`);
            const colorLine = selectedLine.attr('fill');
            const colorHexLine = _self._colorService.getDarken(colorLine, .22, ColorType.HEX);
            this._highLightColor = colorLine;
            d3.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                if (d3.select(this).attr('fill').toLowerCase().trim() !== colorLine.toLowerCase().trim()) {
                    d3.select(this).classed('scatter-transition', true).attr('r', 3.5);
                }
            });
            d3.selectAll('.scatter-chart-line-g').each(function () {
                if (d3.select(this).attr('id').toLowerCase().trim() === colorLine.toLowerCase().trim() &&
                    this.nextElementSibling !== null) {
                    this.parentNode.appendChild(this);
                }
            });
            d3.selectAll('.scatter-regression-line').each(function () {
                if (d3.select(this).attr('id').toLowerCase().trim() === colorLine.toLowerCase().trim()) {
                    _self._regLine = d3.select(this);
                    _self._regLine
                        .style('visibility', 'visible')
                        .attr('stroke', colorHexLine)
                        .style('opacity', '1');
                }
            });
        }
    }
    categoryLeave() {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        d3.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
            var _a;
            if (d3.select(this).attr('fill').toLowerCase().trim() !== ((_a = _self._highLightColor) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim())) {
                d3.select(this).classed('scatter-transition', false).attr('r', 5);
            }
        });
        if (this._regLine) {
            this._regLine
                .attr('stroke', this._highLightColor)
                .style('visibility', 'hidden')
                .style('opacity', '0');
        }
    }
    _getCustomColorById(id) {
        const customColors = this.legend.customColors;
        const len = customColors.length;
        const index = id % len;
        return customColors[index];
    }
    _updatedScatterChart(dim) {
        this._generatedData = [];
        this._updateAxis(dim);
        this._updateDataLines();
    }
    _initAxis(g, dim) {
        this._generatedData = [];
        if (this.series) {
            this.series.forEach(dt => dt.data.map(d => this._generatedData.push({ data1: d[0], data2: d[1] })));
            if (this.yAxis && this.yAxis.title) {
                g.append('g')
                    .attr('class', 'adapt-chart-axis-title')
                    .attr('transform', `rotate(-90) translate(-${(dim.h - this._axisShift.bottom) / 2} ${this.axisShiftLeft / 4})`)
                    .append('text')
                    .text(this.yAxis.title)
                    .attr('text-anchor', 'middle')
                    .attr('transform', `translate(${(this._axisShift.bottom / 2)} 0)`);
            }
            if (this.xAxis && this.xAxis.title) {
                g.append('g')
                    .attr('class', 'adapt-chart-axis-title adapt-chart-axis-title--x')
                    .attr('transform', `translate(${(dim.w + this.axisShiftLeft) / 2} ${dim.h})`)
                    .append('text')
                    .text(this.xAxis.title)
                    .attr('text-anchor', 'middle')
                    .attr('transform', `translate(${(this.axisShiftLeft)} 0)`);
            }
            this._x = d3
                .scaleLinear()
                .domain([d3.min(this._generatedData, (d) => d.data1), d3.max(this._generatedData, (d) => d.data1)])
                .range([0, dim.w - (this._margin.left + this._margin.right)]);
            this._y = d3
                .scaleLinear()
                .domain([d3.min(this._generatedData, (d) => d.data2), d3.max(this._generatedData, (d) => d.data2)])
                .range([dim.h - this._margin.top - this._margin.bottom, 0]);
            g.append('g')
                .attr('class', 'axis axis--y')
                .attr('transform', `translate(${this._margin.left}, 0)`)
                .transition()
                .duration(this.duration)
                .call(d3.axisLeft(this._y)
                .ticks(7)
                .tickPadding(10)
                .tickFormat((d) => this._getTickFormatForNumber(d))
                .tickSize(-dim.w + (this._margin.left + this._margin.right))
                .tickSizeOuter(0));
            g.append('g')
                .attr('class', 'axis axis--x')
                .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`)
                .transition()
                .duration(this.duration)
                .call(d3.axisBottom(this._x)
                .tickPadding(10)
                .tickFormat((d) => this._getTickFormatForNumber(d))
                .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
                .tickSizeOuter(0));
            const xAxis = this._generatedData.map(d => d.data1);
            const yAxis = this._generatedData.map(d => d.data2);
            const regression = this._leastSquaresequation(xAxis, yAxis);
            this._line = d3.line()
                .x((d) => this._x(d['data1']))
                .y((d) => this._y(regression(d['data1'])));
        }
    }
    _updateAxis(dim) {
        this.series.forEach(dt => dt.data.map(d => {
            if (this._isDeselected.indexOf(dt.name) === -1) {
                return this._generatedData.push({ data1: d[0], data2: d[1] });
            }
        }));
        this._g.select('.adapt-chart-axis-title--x')
            .transition()
            .duration(this.duration)
            .attr('transform', `translate(${(dim.w + this.axisShiftLeft) / 2} ${dim.h})`);
        this._x = d3
            .scaleLinear()
            .domain([d3.min(this._generatedData, (d) => d.data1), d3.max(this._generatedData, (d) => d.data1)])
            .range([0, dim.w - (this._margin.left + this._margin.right)]);
        this._g.select('.axis--x')
            .transition()
            .duration(this.duration)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`)
            .call(d3.axisBottom(this._x)
            .tickPadding(10)
            .tickFormat((d) => this._getTickFormatForNumber(d))
            .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
            .tickSizeOuter(0));
        this._y = d3
            .scaleLinear()
            .domain([d3.min(this._generatedData, (d) => d.data2), d3.max(this._generatedData, (d) => d.data2)])
            .range([dim.h - this._margin.top - this._margin.bottom, 0]);
        this._g.select('.axis--y')
            .transition()
            .duration(this.duration)
            .attr('transform', `translate(${this._margin.left}, 0)`)
            .call(d3.axisLeft(this._y)
            .ticks(7)
            .tickPadding(10)
            .tickFormat((d) => this._getTickFormatForNumber(d))
            .tickSize(-dim.w + (this._margin.left + this._margin.right))
            .tickSizeOuter(0));
        const xAxis = this._generatedData.map(d => d.data1);
        const yAxis = this._generatedData.map(d => d.data2);
        const regression = this._leastSquaresequation(xAxis, yAxis);
        this._line = d3.line()
            .x((d) => this._x(d['data1']))
            .y((d) => this._y(regression(d['data1'])));
    }
    _updateDataLines() {
        this._g.selectAll('.scatter-plot-circle').attr('cx', (d) => this._x(d.data1)).attr('cy', (d) => this._y(d.data2));
        this._g.selectAll('.scatter-regression-line').attr('d', this._line);
    }
    _drawLines(g) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        let baseColor;
        let colorHex;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        let regLine;
        let colorHexLine;
        this._gW = g.append('g')
            .attr('transform', `translate(${this._margin.left}, 0)`);
        if (this.series) {
            this._colors = [];
            this.series.map((dt, i) => this._colors.push(this.legend.customColors ? this._getCustomColorById(i) : this._colorService.getColor(i)));
            this.series.forEach((dt, i) => {
                this._generatedData = dt.data.map(d => {
                    return {
                        data1: d[0],
                        data2: d[1]
                    };
                });
                g.append('g')
                    .attr('transform', `translate(${this._margin.left}, 0)`)
                    .append('path')
                    .datum(this._generatedData)
                    .attr('id', this._colors[i])
                    .attr('stroke', this._colors[i])
                    .attr('fill', 'none')
                    .attr('stroke-width', '2px')
                    .classed('scatter-regression-line', true)
                    .style('opacity', '0')
                    .style('visibility', 'hidden')
                    .attr('d', this._line);
                const lineWrapper = this._gW
                    .append('g')
                    .attr('class', 'scatter-chart-line-g')
                    .style('opacity', dt.hidden ? 0 : 1)
                    .style('visibility', dt.hidden ? 'hidden' : 'visible')
                    .attr('id', this._colors[i])
                    .attr('data-line-graph-id', i);
                lineWrapper
                    .append('g')
                    .attr('class', 'scatter-plot-circle-wrapper')
                    .attr('id', this._colors[i])
                    .selectAll('dots')
                    .data(this._generatedData)
                    .enter()
                    .append('circle')
                    .attr('r', 5)
                    .attr('class', 'scatter-plot-circle')
                    .attr('fill', this._colors[i])
                    .attr('cx', (d) => this._x(d.data1))
                    .attr('cy', (d) => this._y(d.data2))
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    .on('mouseover', function (d) {
                    const __this = d3.select(this);
                    baseColor = __this.attr('fill');
                    colorHex = _self._colorService.getDarken(baseColor, .15, ColorType.HEX);
                    colorHexLine = _self._colorService.getDarken(baseColor, .22, ColorType.HEX);
                    d3.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                        if (d3.select(this).attr('fill') !== baseColor) {
                            d3.select(this)
                                .classed('scatter-transition', true)
                                .attr('r', 3.5);
                        }
                    });
                    d3.selectAll('.scatter-chart-line-g').each(function () {
                        if (d3.select(this).attr('id') === baseColor && this.nextElementSibling !== null) {
                            this.parentNode.appendChild(this);
                        }
                    });
                    d3.selectAll('.scatter-regression-line').each(function () {
                        if (d3.select(this).attr('id').toLowerCase().trim() === baseColor.toLowerCase().trim()) {
                            regLine = d3.select(this);
                            regLine
                                .style('visibility', 'visible')
                                .attr('stroke', colorHexLine)
                                .style('opacity', '1');
                        }
                    });
                    __this
                        .attr('r', 7)
                        .style('opacity', '1')
                        .style('filter', 'url(#drop-shadow)')
                        .attr('fill', colorHex);
                    _self.chartComponent.showTooltip(d3.event.target, _self.tooltipTemplate, {
                        data: {
                            color: baseColor,
                            category: dt.name,
                            xValue: _self.scientificMode ? new BigNumber(d.data1).toPrecision(2, 2) : d.data1,
                            yValue: _self.scientificMode ? new BigNumber(d.data2).toPrecision(2, 2) : d.data2,
                        }
                    });
                })
                    .on('mouseout', function () {
                    d3.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                        if (d3.select(this).attr('fill').toLowerCase().trim() !== baseColor.toLowerCase().trim()) {
                            d3.select(this)
                                .classed('scatter-transition', false)
                                .attr('r', 5);
                        }
                    });
                    regLine
                        .attr('stroke', baseColor)
                        .style('visibility', 'hidden')
                        .style('opacity', '0');
                    d3.select(this)
                        .style('opacity', '.8')
                        .style('filter', null)
                        .attr('fill', baseColor);
                    _self.chartComponent.hideTooltip();
                });
            });
        }
    }
    /**
     * http://bl.ocks.org/tommyogden/f416a5c27971908845a9
     */
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _leastSquaresequation(xAxisData, yAxisData) {
        const ReduceAddition = (prev, cur) => prev + cur;
        // finding the mean of Xaxis and Yaxis data
        const xBar = xAxisData.reduce(ReduceAddition) * 1.0 / xAxisData.length;
        const yBar = yAxisData.reduce(ReduceAddition) * 1.0 / yAxisData.length;
        const SquareXX = xAxisData.map(d => Math.pow(d - xBar, 2)).reduce(ReduceAddition);
        // const ssYY = yAxisData.map(d => Math.pow(d - yBar, 2)).reduce(ReduceAddition);
        const MeanDiffXY = xAxisData.map((d, i) => (d - xBar) * (yAxisData[i] - yBar)).reduce(ReduceAddition);
        const slope = MeanDiffXY / SquareXX;
        const intercept = yBar - (xBar * slope);
        // returning regression function
        return function (x) {
            return x * slope + intercept;
        };
    }
    _drawDropShadow() {
        const defs = this._g
            .append('defs');
        const filter = defs
            .append('filter')
            .attr('id', 'drop-shadow')
            .attr('x', '-50%')
            .attr('y', '-50%')
            .attr('width', '180%')
            .attr('height', '180%')
            .attr('filterUnits', 'userSpaceOnUse');
        filter
            .append('feGaussianBlur')
            .attr('in', 'SourceAlpha')
            .attr('stdDeviation', 3);
        filter
            .append('feOffset')
            .attr('dx', 0)
            .attr('dy', 1)
            .attr('result', 'offsetblur');
        filter
            .append('feOffset')
            .attr('dx', 0)
            .attr('dy', 2)
            .attr('result', 'offsetblur');
        filter
            .append('feColorMatrix')
            .attr('type', 'matrix')
            .attr('values', '0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.22 0');
        const feMerge = filter
            .append('feMerge');
        feMerge
            .append('feMergeNode');
        feMerge
            .append('feMergeNode')
            .attr('in', 'SourceGraphic');
        feMerge
            .append('feMergeNode')
            .attr('in', 'SourceGraphic');
    }
    _getTickFormatForNumber(d) {
        return this.scientificMode
            ? new BigNumber(d).toPrecision(2, 2)
            : this._cutNumber.transform(d, 0);
    }
}
AdaptScatterPlotComponent.ɵfac = function AdaptScatterPlotComponent_Factory(t) { return new (t || AdaptScatterPlotComponent)(i0.ɵɵdirectiveInject(CutNumberPipe), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(ChartColorService)); };
AdaptScatterPlotComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptScatterPlotComponent, selectors: [["adapt-scatter-plot"]], viewQuery: function AdaptScatterPlotComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0$2, 7);
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", series: "series", xAxis: "xAxis", yAxis: "yAxis", noDataText: "noDataText", legend: "legend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", updateChart: "updateChart", scientificMode: "scientificMode" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵProvidersFeature([CutNumberPipe]), i0.ɵɵInheritDefinitionFeature], decls: 5, vars: 11, consts: [[3, "width", "height", "header", "data", "dataBuilder", "legend", "updateChart", "backgroundColor", "suppressHeader", "suppressLegend", "noDataText", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], ["tooltipTpl", ""], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptScatterPlotComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "adapt-chart", 0);
        i0.ɵɵlistener("categoryShow", function AdaptScatterPlotComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptScatterPlotComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptScatterPlotComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptScatterPlotComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptScatterPlotComponent_ng_template_2_Template, 26, 7, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(4, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("width", ctx.width)("height", ctx.height)("header", ctx.header)("data", ctx.series)("dataBuilder", ctx._dataBuilder)("legend", ctx.legend)("updateChart", ctx._updateChart)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("noDataText", ctx.noDataText);
    } }, directives: [AdaptChartComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptScatterPlotComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-scatter-plot',
                templateUrl: './scatter-plot.component.html',
                providers: [CutNumberPipe],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: CutNumberPipe }, { type: i1.AdaptDeviceDetectionService }, { type: ChartColorService }]; }, { backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], series: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], legend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], updateChart: [{
            type: Input
        }], scientificMode: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], tooltipTemplate: [{
            type: ViewChild,
            args: ['tooltipTpl', { static: true }]
        }], chartComponent: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }] }); })();

class AdaptTreemapAbstract extends AdaptChartAbstract {
}
AdaptTreemapAbstract.ɵfac = /*@__PURE__*/ function () { let ɵAdaptTreemapAbstract_BaseFactory; return function AdaptTreemapAbstract_Factory(t) { return (ɵAdaptTreemapAbstract_BaseFactory || (ɵAdaptTreemapAbstract_BaseFactory = i0.ɵɵgetInheritedFactory(AdaptTreemapAbstract)))(t || AdaptTreemapAbstract); }; }();
AdaptTreemapAbstract.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTreemapAbstract, inputs: { data: "data" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTreemapAbstract, [{
        type: Directive
    }], null, { data: [{
            type: Input
        }] }); })();

const _c0$1 = ["treemapDefaultTooltip"];
const _c1$1 = ["treemapGroupTooltip"];
const _c2$1 = ["menuAnchor"];
const _c3 = ["menuContainer"];
const _c4 = ["optionsListRef"];
function AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 15);
    i0.ɵɵlistener("click", function AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r17); const action_r14 = restoredCtx.$implicit; const ctx_r16 = i0.ɵɵnextContext(4); return ctx_r16.callAction(ctx_r16.menuData.target, ctx_r16.menuData.event, ctx_r16.menuData.context, action_r14); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r14 = ctx.$implicit;
    const index_r15 = ctx.index;
    const ctx_r13 = i0.ɵɵnextContext(4);
    i0.ɵɵclassProp("text-active", ctx_r13.isActiveDescendant(index_r15));
    i0.ɵɵpropertyInterpolate1("id", "treemap__actions__action-", index_r15, "");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", action_r14.title, "\n        ");
} }
function AdaptTreemapComponent_div_3_ng_template_6_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template, 2, 4, "button", 14);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r12.menuData.actions);
} }
function AdaptTreemapComponent_div_3_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    const _r19 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵelementStart(1, "div", 11, 12);
    i0.ɵɵlistener("keydown", function AdaptTreemapComponent_div_3_ng_template_6_Template_div_keydown_1_listener($event) { i0.ɵɵrestoreView(_r19); const ctx_r18 = i0.ɵɵnextContext(2); return ctx_r18.keydownHandler($event); });
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, AdaptTreemapComponent_div_3_ng_template_6_div_4_Template, 4, 1, "div", 13);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n  ");
} if (rf & 2) {
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵattribute("aria-activedescendant", ctx_r10.getActiveDescendant());
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r10.menuData && ctx_r10.menuData.actions && ctx_r10.menuData.actions.length);
} }
function AdaptTreemapComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r21 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 6, 7);
    i0.ɵɵlistener("popupAnimationDone", function AdaptTreemapComponent_div_3_Template_div_popupAnimationDone_0_listener() { i0.ɵɵrestoreView(_r21); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.popupAnimationDone(); });
    i0.ɵɵtext(2, "\n  ");
    i0.ɵɵelement(3, "button", 8, 9);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵtemplate(6, AdaptTreemapComponent_div_3_ng_template_6_Template, 7, 2, "ng-template", 10);
    i0.ɵɵtext(7, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true)("restoreFocusAfterClose", true);
} }
function AdaptTreemapComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "strong");
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementStart(6, "div");
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n");
} if (rf & 2) {
    const context_r22 = ctx.context;
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(context_r22.name);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(context_r22.size);
} }
function AdaptTreemapComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 16);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelement(3, "span", 17);
    i0.ɵɵtext(4);
    i0.ɵɵelementStart(5, "strong");
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n");
} if (rf & 2) {
    const parentContext_r23 = ctx.parentContext;
    const childContext_r24 = ctx.childContext;
    i0.ɵɵadvance(3);
    i0.ɵɵstyleProp("background-color", parentContext_r23.color);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n    ", parentContext_r23.name, ": ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(childContext_r24.name);
} }
function AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r33 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 23);
    i0.ɵɵlistener("click", function AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template_a_click_0_listener($event) { i0.ɵɵrestoreView(_r33); const breadCrumb_r27 = i0.ɵɵnextContext().$implicit; const ctx_r31 = i0.ɵɵnextContext(3); return ctx_r31.navigateToGroup($event, breadCrumb_r27, ctx_r31.data); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const breadCrumb_r27 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(breadCrumb_r27);
} }
function AdaptTreemapComponent_ng_template_11_ol_1_li_2_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const breadCrumb_r27 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(breadCrumb_r27);
} }
function AdaptTreemapComponent_ng_template_11_ol_1_li_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "li", 21);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template, 2, 1, "a", 22);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, AdaptTreemapComponent_ng_template_11_ol_1_li_2_ng_container_4_Template, 2, 1, "ng-container", 13);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const last_r28 = ctx.last;
    i0.ɵɵclassProp("active", last_r28);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !last_r28);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", last_r28);
} }
function AdaptTreemapComponent_ng_template_11_ol_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "ol", 19);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptTreemapComponent_ng_template_11_ol_1_li_2_Template, 6, 4, "li", 20);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r25 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r25.breadCrumbs);
} }
function AdaptTreemapComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵtemplate(1, AdaptTreemapComponent_ng_template_11_ol_1_Template, 4, 1, "ol", 18);
    i0.ɵɵtext(2, "\n");
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r7.breadCrumbs.length);
} }
const NODE_PADDING = 15;
// TODO update types
class AdaptTreemapComponent extends AdaptTreemapAbstract {
    constructor(_renderer, _chartColorService, _changeDetectorRef) {
        super();
        this._renderer = _renderer;
        this._chartColorService = _chartColorService;
        this._changeDetectorRef = _changeDetectorRef;
        this.hasActionMenu = false;
        this.breadCrumbs = [];
        // Chart data builder
        this.dataBuilderBind = this._dataBuilder.bind(this);
        // Chart update function
        this.updateChartBind = this._updateChart.bind(this);
        // Chart data builder for grouped treemap
        this.dataBuilderForGroupsBind = this._dataBuilderForGroups.bind(this);
        // Chart update function for grouped treemap
        this.updateChartForGroupsBind = this._updateChartForGroups.bind(this);
        this.showSizeInName = true;
        /**
         * @since 10.14.0
         */
        this.groupView = false;
        // Outputs
        this.clickChart = new EventEmitter();
        this.groupEntered = new EventEmitter();
        this._tooltipPoint = { x: 0, y: 0 };
        this._closeMenuBind = this._closeMenu.bind(this);
    }
    categoryEnter(categoryEvent) {
        this._getRelatedToLegendNodes(categoryEvent.id.toString()).dispatch('mouseenter', {
            bubbles: true,
            cancelable: true,
            detail: { eventSource: 'legend' }
        });
    }
    categoryLeave(categoryEvent) {
        this._getRelatedToLegendNodes(categoryEvent.id.toString()).dispatch('mouseleave');
    }
    ngOnInit() {
        this.innerData = cloneDeep(this.data);
        this._initLegend();
    }
    ngOnChanges(changes) {
        if (changes['data']) {
            this.innerData = changes['data'].currentValue;
            this.breadCrumbs = [];
            this._updateLegend(changes['data'].firstChange);
        }
    }
    ngOnDestroy() {
        this._removeListeners();
    }
    popupAnimationDone() {
        if (this.menuContainer.isOpen()) {
            this.optionsListRef.nativeElement.focus();
            this._listKeyManager = new ListKeyManager(this.items)
                .withWrap(false)
                .withHomeAndEnd();
            this._listKeyManager.setFirstItemActive();
            this._removeClickEventListener = this._renderer.listen('document', 'click', this._closeMenuBind);
            this._removeScrollEventListener = this._renderer.listen('document', 'scroll', this._closeMenuBind);
        }
        else {
            this._listKeyManager = null;
            this._removeListeners();
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    keydownHandler(event) {
        if (this._listKeyManager) {
            switch (getEventKeyCode(event)) {
                case DOWN_ARROW:
                case UP_ARROW: {
                    this._listKeyManager.onKeydown(event);
                    break;
                }
                case ENTER: {
                    this.callAction(this.menuData.target, this.menuData.event, this.menuData.context, this.menuData.actions[this._listKeyManager.activeItemIndex]);
                    this.menuContainer.close();
                    break;
                }
                case TAB: {
                    if (this.menuContainer.isOpen()) {
                        this.menuContainer.close();
                    }
                    break;
                }
            }
        }
    }
    getActiveDescendant() {
        return this._listKeyManager ? `treemap__actions__action-${this._listKeyManager.activeItemIndex}` : undefined;
    }
    isActiveDescendant(index) {
        var _a;
        return index === ((_a = this._listKeyManager) === null || _a === void 0 ? void 0 : _a.activeItemIndex);
    }
    callAction(target, event, context, action) {
        action.callback(target, event, context);
    }
    enterGroup(event, d) {
        this.innerData = d.data;
        this._legend = this._prepareGroupLegend();
        this.chartBase.updateLegend(this._legend.items);
        this.groupEntered.emit({ event, data: d.data, node: d });
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    updateBreadCrumbs(d) {
        if (!this.breadCrumbs.length) {
            this.breadCrumbs.push(this.innerData.name);
        }
        this.breadCrumbs.push(d.data.name);
    }
    navigateToGroup(event, name, data) {
        if (data.name === name) {
            this.innerData = cloneDeep(data);
            this.breadCrumbs = this.breadCrumbs.slice(0, this.breadCrumbs.indexOf(name) + 1);
            if (this.breadCrumbs.length === 1) {
                this.breadCrumbs = [];
            }
            this._legend = this._prepareGroupLegend();
            this.chartBase.updateLegend(this._legend.items);
            this.groupEntered.emit({ event, data });
            SafeCdr.detectChanges(this._changeDetectorRef);
            return;
        }
        if (data.children) {
            data.children.forEach(child => {
                this.navigateToGroup(event, name, child);
            });
        }
    }
    _dataBuilder(g, dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        this._g = g;
        const data = this.innerData;
        const openTooltip = this._openTooltip.bind(this);
        const closeTooltip = this._closeTooltip.bind(this);
        const ellipsis = this._ellipsis;
        const clickChart = this.clickChart;
        const openMenu = this._openMenu.bind(this);
        const showSizeInName = this.showSizeInName;
        const chartColorService = this._chartColorService;
        // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
        this.hasActionMenu = this._isDataContainsActions(data);
        const treemap = d3.treemap()
            .tile(d3.treemapResquarify)
            .size([dim.w, dim.h])
            .round(true)
            .paddingInner(1);
        const root = d3.hierarchy(data)
            .eachBefore((d) => {
            d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
        })
            .sum((d) => d.size)
            .sort((a, b) => b.height - a.height || b.value - a.value);
        treemap(root);
        let _currColorGroup = '';
        let _currColorRange = [];
        let _currColorRangeCounter = 0;
        const nodeGroup = this._g.selectAll('g')
            .data(root.leaves())
            .enter()
            .append('g')
            .attr('class', (d) => `treemap-node status-group-${d.data.id.split(' ').join('_')}`)
            .attr('id', (d) => d.data.id.split(' ').join('_'))
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`);
        const nodeGroupInnerElem = nodeGroup
            .append('g')
            .attr('class', 'treemap-node__inner')
            .attr('tabindex', 0)
            .attr('aria-label', (d) => `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''))
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('mouseenter', function (d) {
            const rect = d3.select(this).select('rect');
            const oldColor = rect.node().style.fill;
            const target = d3.select(this);
            const tooltipCustomCls = d.data.id.split('.').join('_').split(' ').join('_');
            const eventDetail = d3.event.detail;
            if (eventDetail === 0 || (eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.eventSource) !== 'legend') {
                openTooltip(target, { context: d.data }, `treemap_tooltip treemap_tooltip__${tooltipCustomCls}`, 1);
                _this._tooltipEl = window.document.querySelector(`.treemap_tooltip__${tooltipCustomCls}`);
                if (isDefined(_this._tooltipEl)) {
                    _this._tooltipMouseleaveHandler = () => {
                        closeTooltip();
                        _this._tooltipEl.removeEventListener('mouseleave', _this._tooltipMouseleaveHandler);
                    };
                    _this._tooltipEl.addEventListener('mouseleave', _this._tooltipMouseleaveHandler);
                }
            }
            rect.node().style.fill = d3.rgb(oldColor).darker(.3).formatHex();
        })
            .on('mouseleave', function () {
            var _a, _b, _c;
            const rect = d3.select(this).select('rect');
            const oldColor = rect.node().style.fill;
            if (!((_c = (_b = (_a = d3.event) === null || _a === void 0 ? void 0 : _a.toElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null || _c === void 0 ? void 0 : _c.classList.contains('adapt-tooltip-inner'))) {
                closeTooltip();
                _this._removeTooltipMouseleaveListener();
            }
            rect.node().style.fill = d3.rgb(oldColor).brighter(.3).formatHex();
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('click', function (d) {
            closeTooltip();
            _this._removeTooltipMouseleaveListener();
            clickChart.emit(d.data);
            d3.event.stopPropagation();
        });
        nodeGroupInnerElem.append('rect')
            .attr('class', 'treemap__node-rect')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('width', (d) => d.x1 - d.x0)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('height', (d) => d.y1 - d.y0)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('style', function (d) {
            if (!_currColorGroup || !(_currColorGroup === d.parent.data.id)) {
                const customColorsRange = d.parent.data.customColorsRange;
                if (isDevMode && customColorsRange && customColorsRange.length !== 2
                    || customColorsRange && customColorsRange[0] && customColorsRange[0].length !== 7
                    || customColorsRange && customColorsRange[1] && customColorsRange[1].length !== 7) {
                    adaptError('ADAPT-ANGULAR Error! \n Treemap component! \n Please pass correct color range. "customColorsRange" property should be an array of 2 values, and each value should be HEX format color 7 chars length each. (eg. customColorsRange: ["#000000", "#ffffff"])');
                }
                _currColorGroup = d.parent.data.id;
                _currColorRange = ChartColorService.getColorRange(d.parent.data.status === AdaptChartColorStatus.Custom
                    ? customColorsRange
                    : d.parent.data.status, d.parent.children.length);
                _currColorRangeCounter = 0;
            }
            const bg = d.data.color ? d.data.color : _currColorRange[_currColorRangeCounter];
            const currentChild = d.parent.children[_currColorRangeCounter];
            if (isDefined(currentChild)) {
                currentChild.bg = bg;
                currentChild.textColor = chartColorService.getContrast(bg, ColorType.HEX);
            }
            _currColorRangeCounter++;
            return `
          fill: ${bg};
          transition: fill .2s;
          cursor: pointer;
        `;
        });
        nodeGroupInnerElem.append('g')
            .attr('class', 'treemap-node-text')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .each(function (d) {
            const _node = d3.select(this);
            _node.attr('id', `${d.data.id.split(' ').join('_')}_text`);
            const _name = _node.append('text')
                .attr('class', 'treemap__node-name')
                .attr('transform', `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
                .attr('style', () => {
                return `
              text-anchor: middle;
              dominant-baseline: middle;
              font-size: 13px;
              fill: ${d.textColor};
            `;
            });
            ellipsis(_name, `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''), d.x1 - d.x0 - NODE_PADDING);
            const lineHeight = 22;
            const _info = _node.append('text')
                .attr('class', 'treemap__node-info-text')
                .attr('transform', `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
                .attr('dy', lineHeight)
                .attr('text-anchor', 'middle')
                .attr('style', `font-size: 12px; opacity: .7; fill: ${d.textColor}`);
            if (d.data.info && (d.y1 - d.y0 > 40)) {
                ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING);
            }
        });
        this._buildActionsMenu(nodeGroup, openMenu);
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    _updateChart(dim) {
        const data = this.innerData;
        const ellipsis = this._ellipsis;
        const showSizeInName = this.showSizeInName;
        // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
        this.hasActionMenu = this._isDataContainsActions(data);
        const treemap = d3.treemap()
            .tile(d3.treemapResquarify)
            .size([dim.w, dim.h])
            .round(true)
            .paddingInner(1);
        const root = d3.hierarchy(data)
            .eachBefore((d) => {
            d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
        })
            .sum((d) => d.size)
            .sort((a, b) => b.height - a.height || b.value - a.value);
        treemap(root);
        const leaves = root.leaves();
        this._g.selectAll('g.treemap-node')
            .data(leaves)
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`);
        this._g.selectAll('g.treemap__actions-menu rect')
            .data(leaves.filter((d) => d.data.actions))
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${(d.x1 - d.x0) - 24}, 10)`);
        this._g.selectAll('g.treemap__actions-menu use')
            .data(leaves.filter((d) => d.data.actions))
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${(d.x1 - d.x0) - 24}, 10)`);
        this._g.selectAll('rect.treemap__node-rect')
            .data(leaves)
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('width', (d) => d.x1 - d.x0)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('height', (d) => d.y1 - d.y0);
        this._g.selectAll('text.treemap__node-name')
            .data(leaves)
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .each(function (d) {
            d3.select(this).text('');
            ellipsis(d3.select(this), `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''), d.x1 - d.x0 - NODE_PADDING);
        });
        this._g.selectAll('text.treemap__node-info-text')
            .data(leaves)
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .each(function (d) {
            d3.select(this).text('');
            if (d.data.info && (d.y1 - d.y0 > 40)) {
                ellipsis(d3.select(this), d.data.info, d.x1 - d.x0 - NODE_PADDING);
            }
        });
    }
    _dataBuilderForGroups(g, dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        this._g = g;
        const data = this.innerData;
        const ellipsis = this._ellipsis;
        const clickChart = this.clickChart;
        const showSizeInName = this.showSizeInName;
        const openMenu = this._openMenu.bind(this);
        // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
        this.hasActionMenu = this._isDataContainsActions(data);
        const treemap = d3.treemap()
            .tile(d3.treemapResquarify)
            .size([dim.w, dim.h])
            .round(true)
            .paddingInner(1)
            .paddingOuter(1);
        const root = d3.hierarchy(data)
            .eachBefore((d) => {
            d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
        })
            // Ignore size value of node if it has children, because only it's children should be calculated to create correct view
            .sum((d) => { var _a; return ((_a = d.children) === null || _a === void 0 ? void 0 : _a.length) ? 0 : d.size; })
            .sort((a, b) => b.height - a.height || b.value - a.value);
        treemap(root);
        const nodeGroup = this._g.selectAll('g')
            .data(root.children)
            .enter()
            .append('g')
            .attr('class', (d) => { var _a; return `treemap-node ${((_a = d.data.children) === null || _a === void 0 ? void 0 : _a.length) ? 'treemap-node__parent' : 'treemap-node__child'}`; })
            .attr('id', (d) => d.data.id.split(' ').join('_'))
            .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`);
        const nodeGroupInnerElem = nodeGroup
            .append('g')
            .attr('class', 'treemap-node__inner')
            .attr('tabindex', 0)
            .attr('aria-label', (d) => `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''))
            .each(function (d) {
            if (_this.groupView && d.children) {
                const node = d3.select(this);
                node.attr('role', 'button')
                    .attr('aria-expanded', false);
            }
        })
            .on('click', function (d) {
            d3.event.stopPropagation();
            if (_this.groupView && d.children) {
                _this._activeNode = d;
                _this.chartBase.hideTooltip();
                _this.updateBreadCrumbs(d);
                _this.enterGroup(d3.event, d);
            }
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('keydown', function (d) {
            if (d3.event.keyCode === ENTER || d3.event.keyCode === SPACE) {
                if (_this.groupView && d.children) {
                    _this._activeNode = d;
                    _this.chartBase.hideTooltip();
                    _this.updateBreadCrumbs(d);
                    _this.enterGroup(d3.event, d);
                }
            }
        });
        const itemsWithChildren = nodeGroupInnerElem.filter(d => { var _a; return !!((_a = d.children) === null || _a === void 0 ? void 0 : _a.length); });
        const itemsWithoutChildren = nodeGroupInnerElem.filter(d => { var _a; return !((_a = d.children) === null || _a === void 0 ? void 0 : _a.length); });
        if (itemsWithChildren.size() > 0) {
            itemsWithChildren
                .each(function (parentData) {
                const parentItem = d3.select(this);
                parentItem
                    .append('rect')
                    .attr('width', parentData.x1 - parentData.x0)
                    .attr('height', parentData.y1 - parentData.y0)
                    .attr('fill', 'transparent')
                    .on('mouseenter', function () {
                    _this._hideParentLabel(parentItem);
                })
                    .on('mouseleave', function () {
                    _this._showParentLabel(parentItem, parentData);
                });
                parentData.children.forEach((childData) => {
                    const childItem = parentItem
                        .append('g')
                        .attr('class', 'treemap-node__child')
                        .attr('tabindex', 0)
                        .attr('aria-label', childData.data.name);
                    const childRect = childItem
                        .append('rect')
                        .attr('class', 'treemap__node-rect')
                        .attr('transform', `translate(${childData.x0 - parentData.x0}, ${childData.y0 - parentData.y0})`)
                        .attr('width', childData.x1 - childData.x0)
                        .attr('height', childData.y1 - childData.y0)
                        .attr('style', `fill: ${childData.data.color}; transition: fill .2s; cursor: pointer;`);
                    childItem
                        .on('mouseenter', function () {
                        const oldColor = childRect.node().style.fill;
                        childRect.node().style.fill = d3.rgb(oldColor).darker(.3).formatHex();
                        _this._hideParentLabel(parentItem);
                        const { clientX, clientY } = d3.event;
                        _this._tooltipPoint.x = clientX;
                        _this._tooltipPoint.y = clientY;
                        _this.chartBase.showTooltip(_this._tooltipPoint, _this.treemapGroupTooltip, {
                            parentContext: parentData.data,
                            childContext: childData.data
                        });
                    })
                        .on('mousemove', function () {
                        const { clientX, clientY } = d3.event;
                        _this._tooltipPoint.x = clientX;
                        _this._tooltipPoint.y = clientY;
                        _this.chartBase.updateTooltip();
                    })
                        .on('mouseleave', function () {
                        const oldColor = childRect.node().style.fill;
                        childRect.node().style.fill = d3.rgb(oldColor).brighter(.3).formatHex();
                        _this._showParentLabel(parentItem, parentData);
                        _this.chartBase.hideTooltip();
                    });
                    const _name = childItem
                        .append('text')
                        .attr('class', 'treemap__node-child-label')
                        .attr('opacity', '0')
                        .attr('transform', `translate(${(childData.x0 - parentData.x0 + ((childData.x1 - childData.x0) / 2))}, ${(childData.y0 - parentData.y0 + ((childData.y1 - childData.y0) / 2))})`)
                        .attr('style', `text-anchor: middle; dominant-baseline: middle; font-size: 13px; fill: ${_this._chartColorService.getContrast(childData.data.color, ColorType.HEX)};`);
                    ellipsis(_name, `${childData.data.name}` + (showSizeInName ? ` (${childData.data.size})` : ''), childData.x1 - childData.x0 - NODE_PADDING);
                });
            })
                .on('mouseenter', function () {
                const texts = d3.select(this).selectAll('.treemap__node-child-label');
                texts.attr('opacity', '1');
            })
                .on('mouseleave', function () {
                const texts = d3.select(this).selectAll('.treemap__node-child-label');
                texts.attr('opacity', '0');
            });
            itemsWithChildren
                .append('g')
                .attr('class', 'treemap-node-parent-label')
                .each(function (parentData) {
                const _node = d3.select(this);
                const tooltipWrapperHeight = 60;
                _node
                    .append('foreignObject')
                    .attr('width', parentData.x1 - parentData.x0)
                    .attr('height', 1)
                    .attr('overflow', 'visible')
                    .attr('transform', `translate(0, ${((parentData.y1 - parentData.y0) / 2) - (tooltipWrapperHeight / 2)})`)
                    .append('xhtml:div')
                    .html(`
                <div class="treemap__group-parent-tooltip shadow-1">
                    <div class="treemap__group-parent-tooltip-color"
                         style="background-color: ${parentData.data.color}; border-color: ${_this._chartColorService.getDarken(parentData.data.color, .14, ColorType.HEX)};">&nbsp;</div>
                    <div class="treemap__group-parent-tooltip-text align-start" id="${parentData.data.id.split(' ').join('_')}_text">${parentData.data.name}</div>
                </div>
            `)
                    .attr('class', 'treemap__group-parent-tooltip-wrapper');
            });
        }
        if (itemsWithoutChildren.size() > 0) {
            itemsWithoutChildren.append('rect')
                .attr('class', 'treemap__node-rect')
                .attr('width', (d) => d.x1 - d.x0)
                .attr('height', (d) => d.y1 - d.y0)
                .attr('style', (d) => `fill: ${d.data.color}; transition: fill .2s; cursor: pointer;`)
                .on('click', function (d) {
                clickChart.emit(d.data);
            });
            itemsWithoutChildren.append('g')
                .attr('class', 'treemap-node-text treemap-node-text_no-child')
                .each(function (d) {
                const _node = d3.select(this);
                const _name = _node.append('text')
                    .attr('class', 'treemap__node-name')
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
                    .attr('style', `text-anchor: middle; dominant-baseline: middle; font-size: 13px; fill: ${_this._chartColorService.getContrast(d.data.color, ColorType.HEX)};`);
                ellipsis(_name, `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''), d.x1 - d.x0 - NODE_PADDING);
                const lineHeight = 22;
                const _info = _node.append('text')
                    .attr('class', 'treemap__node-info-text')
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
                    .attr('dy', lineHeight)
                    .attr('text-anchor', 'middle')
                    .attr('style', `font-size: 12px; opacity: .7; fill: ${_this._chartColorService.getContrast(d.data.color, ColorType.HEX)}`);
                if (d.data.info && (d.y1 - d.y0 > 40)) {
                    ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING);
                }
            });
        }
        this._buildActionsMenu(nodeGroup, openMenu);
    }
    _updateChartForGroups(dim) {
        this._g.selectAll('g').remove();
        this._dataBuilderForGroups(this._g, dim);
    }
    _showParentLabel(item, data) {
        item
            .select('.treemap-node-parent-label > foreignObject')
            .attr('style', `opacity: 1; height: 1px; overflow: visible; width: ${data.x1 - data.x0}px;`);
    }
    _hideParentLabel(item) {
        item
            .select('.treemap-node-parent-label > foreignObject')
            .attr('style', 'opacity: 0; height: 1px; overflow: hidden; width: 0;');
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _buildActionsMenu(nodeGroup, openMenu) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        // Draw kebab menu icon
        nodeGroup
            .append('g')
            .attr('class', 'treemap__actions-menu')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .each(function (d) {
            if (d.data.actions) {
                const _node = d3.select(this);
                _node.attr('tabindex', 0)
                    .attr('role', 'button')
                    .attr('aria-haspopup', true)
                    .attr('aria-expanded', false);
                _node.append('rect')
                    .attr('cursor', 'pointer')
                    .attr('fill', 'transparent')
                    .attr('height', 20)
                    .attr('width', 20)
                    .attr('transform', `translate(${(d.x1 - d.x0) - 24}, 10)`);
                _node.append('g')
                    .attr('transform', `translate(${(d.x1 - d.x0) - 24}, 10)`)
                    .html(ai_ellipsis.data)
                    .select('svg')
                    .attr('cursor', 'pointer')
                    .attr('fill', d.textColor)
                    .attr('height', 20)
                    .attr('width', 20);
            }
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('click', function (d) {
            if (d.data.actions) {
                d3.event.stopPropagation();
                _this._targetWithActions = d3.select(this);
                openMenu(d3.event, d.data);
            }
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('keydown', function (d) {
            var _a, _b;
            if (!((_b = (_a = d.data) === null || _a === void 0 ? void 0 : _a.actions) === null || _b === void 0 ? void 0 : _b.length)) {
                return;
            }
            if (d3.event.keyCode === ENTER || d3.event.keyCode === DOWN_ARROW || d3.event.keyCode === SPACE) {
                d3.event.preventDefault();
                _this._targetWithActions = d3.select(this);
                openMenu(d3.event, d.data);
            }
            if ((d3.event.keyCode === ESCAPE) && _this.menuContainer.isOpen()) {
                d3.event.preventDefault();
                _this._closeMenu();
            }
        });
    }
    _openMenu(event, context) {
        this._closeTooltip();
        this.menuContainer.placement = ['bottom-right', 'top-right', 'right', 'left'];
        this.menuContainer.positionTo = this._targetWithActions.node();
        this.menuData = { target: this._targetWithActions.node(), event, context, actions: context.actions };
        if (this.menuContainer.isOpen()) {
            this._closeMenu();
        }
        else {
            this.menuContainer.open(event);
            this._targetWithActions.attr('aria-expanded', true);
        }
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    _closeMenu() {
        var _a;
        if (this.menuContainer) {
            this.menuContainer.close();
            (_a = this._targetWithActions) === null || _a === void 0 ? void 0 : _a.attr('aria-expanded', false);
        }
        this._removeListeners();
    }
    _isDataContainsActions(data) {
        return data.children.some(item => item.actions && item.actions.length
            || item.children && item.children.some(childrenItem => childrenItem.actions && childrenItem.actions.length));
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _openTooltip(target, context, customCls, offset) {
        this.chartBase.showTooltip(target.node(), this.tooltip || this.treemapDefaultTooltip, context, customCls, offset);
    }
    _closeTooltip() {
        this.chartBase.hideTooltip();
        this._removeListeners();
    }
    _prepareLegend() {
        let legendItems = [];
        const data = this.innerData;
        const flattenData = this._flattenByChildren(data.children);
        // In case if data contains "color" property assume that user use "custom colors" approach to control colors
        if (flattenData.some(d => d.color)) {
            legendItems = flattenData;
        }
        else {
            if (isDefined(data.status)) {
                legendItems.push({
                    name: data.name,
                    status: data.status,
                    color: data.status === AdaptChartColorStatus.Custom
                        ? data.customColorsRange
                        : ChartColorService.getColorRange(data.status, 1)
                });
            }
            data.children.forEach((elem) => {
                if (isDefined(elem.status)) {
                    const sameStatuses = legendItems.filter((lItem) => {
                        return elem.status !== AdaptChartColorStatus.Custom && elem.status === lItem.status;
                    });
                    if (!sameStatuses.length) {
                        legendItems.push({
                            name: elem.name,
                            status: elem.status,
                            color: elem.status === AdaptChartColorStatus.Custom
                                ? elem.customColorsRange
                                : ChartColorService.getColorRange(elem.status, 1)
                        });
                    }
                }
            });
        }
        if (legendItems.length) {
            legendItems.sort((a, b) => {
                return a.status - b.status;
            });
            return Object.assign({ columns: 1, items: legendItems.map(el => el.name), customColors: legendItems.map(el => isArray(el.color) ? el.color[0] : el.color), activeHover: false, activeClick: false }, this.legend);
        }
    }
    _prepareGroupLegend() {
        const data = this.innerData;
        if (data.children) {
            return Object.assign({ columns: 1, items: data.children.map(el => el.name), customColors: data.children.map(el => isArray(el.color) ? el.color[0] : el.color), activeHover: false, activeClick: false }, this.legend);
        }
    }
    _initLegend() {
        if (this.suppressLegend) {
            return;
        }
        if (!this.gradientLegend) {
            this._legend = this.groupView ? this._prepareGroupLegend() : this._prepareLegend();
        }
    }
    _updateLegend(isFirstChange) {
        if (this.suppressLegend) {
            return;
        }
        if (!isFirstChange) {
            if (!this.gradientLegend) {
                this._legend = this.groupView ? this._prepareGroupLegend() : this._prepareLegend();
                this.chartBase.updateLegend(this._legend.items);
            }
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _ellipsis(textNode, text, ellipsisWidth) {
        const letters = text.split('');
        const ellipsis = textNode.append('tspan').attr('class', 'ellipsis').text('...');
        const width = ellipsisWidth - ellipsis.node().getComputedTextLength();
        const numWords = letters.length;
        const tspan = textNode.insert('tspan', ':first-child').text(letters.join(''));
        // Try the whole line
        // While it's too long, and we have words left, keep removing words
        while (tspan.node().getComputedTextLength() > width && letters.length) {
            letters.pop();
            tspan.text(letters.join(''));
        }
        if (letters.length === numWords) {
            ellipsis.remove();
        }
    }
    _removeListeners() {
        if (this._removeClickEventListener) {
            this._removeClickEventListener();
            this._removeClickEventListener = null;
        }
        if (this._removeScrollEventListener) {
            this._removeScrollEventListener();
            this._removeScrollEventListener = null;
        }
    }
    _removeTooltipMouseleaveListener() {
        if (isDefined(this._tooltipEl) && isFunction$1(this._tooltipMouseleaveHandler)) {
            this._tooltipEl.removeEventListener('mouseleave', this._tooltipMouseleaveHandler);
            this._tooltipEl = null;
            this._tooltipMouseleaveHandler = null;
        }
    }
    _flattenByChildren(array, result = []) {
        array.forEach(el => {
            if (el.children) {
                this._flattenByChildren(el.children, result);
            }
            else {
                result.push(el);
            }
        });
        return result;
    }
    _getRelatedToLegendNodes(index) {
        const currentLegendItem = this._legend.items[parseInt(index, 10)];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const allNodes = this._g.selectAll('.treemap-node');
        return allNodes.filter(node => node.data.id.indexOf(currentLegendItem) > -1);
    }
}
AdaptTreemapComponent.ɵfac = function AdaptTreemapComponent_Factory(t) { return new (t || AdaptTreemapComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ChartColorService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptTreemapComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTreemapComponent, selectors: [["adapt-treemap"]], viewQuery: function AdaptTreemapComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(_c0$1, 7);
        i0.ɵɵviewQuery(_c1$1, 7);
        i0.ɵɵviewQuery(_c2$1, 5, AdaptDropdownToggleDirective);
        i0.ɵɵviewQuery(_c3, 5, AdaptDropdownDirective);
        i0.ɵɵviewQuery(_c4, 5);
        i0.ɵɵviewQuery(AdaptListKeyManagerItemDirective, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartBase = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treemapDefaultTooltip = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treemapGroupTooltip = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuAnchor = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsListRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", gradientLegend: "gradientLegend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", data: "data", noDataText: "noDataText", showSizeInName: "showSizeInName", groupView: "groupView" }, outputs: { clickChart: "clickChart", groupEntered: "groupEntered" }, exportAs: ["treemap"], features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 14, vars: 14, consts: [[3, "data", "width", "height", "backgroundColor", "header", "legend", "gradientLegend", "suppressHeader", "suppressLegend", "dataBuilder", "updateChart", "noDataText", "topSectionTemplate", "categoryEnter", "categoryLeave"], ["chartBase", ""], ["class", "dropdown treemap-chart_hidden-menu", "adaptDropdown", "", 3, "adaptRadarDisableEventSending", "appendToBody", "restoreFocusAfterClose", "popupAnimationDone", 4, "ngIf"], ["treemapDefaultTooltip", ""], ["treemapGroupTooltip", ""], ["treemapBreadCrumbsTemplate", ""], ["adaptDropdown", "", 1, "dropdown", "treemap-chart_hidden-menu", 3, "adaptRadarDisableEventSending", "appendToBody", "restoreFocusAfterClose", "popupAnimationDone"], ["menuContainer", ""], ["adaptDropdownToggle", "", "type", "button"], ["menuAnchor", ""], ["adaptDropdownMenuTemplate", ""], ["tabindex", "0", "aria-labelledby", "dropdownMenu", 1, "dropdown-menu", 3, "keydown"], ["optionsListRef", ""], [4, "ngIf"], ["class", "dropdown-item", "type", "button", "role", "button", "tabindex", "-1", "adaptListKeyManagerItem", "", 3, "text-active", "id", "click", 4, "ngFor", "ngForOf"], ["type", "button", "role", "button", "tabindex", "-1", "adaptListKeyManagerItem", "", 1, "dropdown-item", 3, "id", "click"], [1, "treemap__group-tooltip"], [1, "adapt-chart-tooltip-color-spot", "mr-1"], ["class", "breadcrumb mb-0", 4, "ngIf"], [1, "breadcrumb", "mb-0"], ["class", "breadcrumb-item", 3, "active", 4, "ngFor", "ngForOf"], [1, "breadcrumb-item"], ["href", "javascript:void(0)", 3, "click", 4, "ngIf"], ["href", "javascript:void(0)", 3, "click"]], template: function AdaptTreemapComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "adapt-chart", 0, 1);
        i0.ɵɵlistener("categoryEnter", function AdaptTreemapComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptTreemapComponent_Template_adapt_chart_categoryLeave_0_listener($event) { return ctx.categoryLeave($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(2, "\n\n");
        i0.ɵɵtemplate(3, AdaptTreemapComponent_div_3_Template, 8, 3, "div", 2);
        i0.ɵɵtext(4, "\n\n");
        i0.ɵɵtemplate(5, AdaptTreemapComponent_ng_template_5_Template, 10, 2, "ng-template", null, 3, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n\n");
        i0.ɵɵtemplate(8, AdaptTreemapComponent_ng_template_8_Template, 9, 4, "ng-template", null, 4, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(10, "\n\n");
        i0.ɵɵtemplate(11, AdaptTreemapComponent_ng_template_11_Template, 3, 1, "ng-template", null, 5, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(13, "\n");
    } if (rf & 2) {
        const _r6 = i0.ɵɵreference(12);
        i0.ɵɵproperty("data", ctx.innerData)("width", ctx.width)("height", ctx.height)("backgroundColor", ctx.backgroundColor)("header", ctx.header)("legend", ctx._legend)("gradientLegend", ctx.gradientLegend)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("dataBuilder", ctx.groupView ? ctx.dataBuilderForGroupsBind : ctx.dataBuilderBind)("updateChart", ctx.groupView ? ctx.updateChartForGroupsBind : ctx.updateChartBind)("noDataText", ctx.noDataText)("topSectionTemplate", _r6);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.hasActionMenu);
    } }, directives: [AdaptChartComponent, i3$1.NgIf, i1.AdaptDropdownDirective, i1.AdaptDropdownToggleDirective, i1.AdaptDropdownMenuTemplateDirective, i3$1.NgForOf, i1.AdaptListKeyManagerItemDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTreemapComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-treemap',
                templateUrl: './treemap.component.html',
                exportAs: 'treemap'
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: ChartColorService }, { type: i0.ChangeDetectorRef }]; }, { chartBase: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], treemapDefaultTooltip: [{
            type: ViewChild,
            args: ['treemapDefaultTooltip', { static: true }]
        }], treemapGroupTooltip: [{
            type: ViewChild,
            args: ['treemapGroupTooltip', { static: true }]
        }], menuAnchor: [{
            type: ViewChild,
            args: ['menuAnchor', {
                    read: AdaptDropdownToggleDirective,
                    static: false
                }]
        }], menuContainer: [{
            type: ViewChild,
            args: ['menuContainer', { read: AdaptDropdownDirective, static: false }]
        }], optionsListRef: [{
            type: ViewChild,
            args: ['optionsListRef', { static: false }]
        }], items: [{
            type: ViewChildren,
            args: [AdaptListKeyManagerItemDirective]
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], legend: [{
            type: Input
        }], gradientLegend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], data: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], showSizeInName: [{
            type: Input
        }], groupView: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], groupEntered: [{
            type: Output
        }] }); })();

var AdaptFlowChartOrientation;
(function (AdaptFlowChartOrientation) {
    AdaptFlowChartOrientation["LEFT_TO_RIGHT"] = "LR";
    AdaptFlowChartOrientation["RIGHT_TO_LEFT"] = "RL";
    AdaptFlowChartOrientation["TOP_TO_BOTTOM"] = "TB";
    AdaptFlowChartOrientation["BOTTOM_TO_TOP"] = "BT";
})(AdaptFlowChartOrientation || (AdaptFlowChartOrientation = {}));

class AdaptTextEllipsisDirective {
    constructor(_el) {
        this._el = _el;
    }
    ngOnChanges(changes) {
        if (changes) {
            const el = select(this._el.nativeElement);
            textEllipsis(el, this.text, this.width);
        }
    }
}
AdaptTextEllipsisDirective.ɵfac = function AdaptTextEllipsisDirective_Factory(t) { return new (t || AdaptTextEllipsisDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptTextEllipsisDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTextEllipsisDirective, selectors: [["text", "adaptTextEllipsis", ""]], inputs: { text: "text", width: "width" }, features: [i0.ɵɵNgOnChangesFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTextEllipsisDirective, [{
        type: Directive,
        args: [{ selector: 'svg text[adaptTextEllipsis]' }]
    }], function () { return [{ type: i0.ElementRef }]; }, { text: [{
            type: Input
        }], width: [{
            type: Input
        }] }); })();

function AdaptFlowChartComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelement(2, "div", 6);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} }
function AdaptFlowChartComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 7);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelement(2, "adapt-empty-state", 8);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("type", "chart")("inverted", ctx_r1.emptyStateConfig.inverted)("label", ctx_r1.emptyStateConfig.label);
} }
function AdaptFlowChartComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "adapt-slider", 9);
    i0.ɵɵlistener("ngModelChange", function AdaptFlowChartComponent_div_6_Template_adapt_slider_ngModelChange_2_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.zoomLevel = $event; });
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementStart(5, "button", 10);
    i0.ɵɵlistener("click", function AdaptFlowChartComponent_div_6_Template_button_click_5_listener() { i0.ɵɵrestoreView(_r5); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.fitGraph(); });
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngModel", ctx_r2.zoomLevel)("customStepChange", true)("min", ctx_r2.minZoomLevel)("max", ctx_r2.maxZoomLevel)("formatter", ctx_r2.sliderValueFormatter)("step", 0.05)("styleClass", "adapt-flow-chart__zoom-slider");
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.texts.fitGraphButton, "\n    ");
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_ng_template_2_Template(rf, ctx) { }
const _c0 = function (a0) { return { $implicit: a0 }; };
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 17);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext().$implicit;
    const ctx_r14 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r14.customTemplateConfig.nodeTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c0, node_r13));
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_svg_62_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg");
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelement(2, "g", 40);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r20 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("class", node_r13.iconCustomClass)("fill", ctx_r20.getStatusColor(node_r13.status))("height", ctx_r20.mainIconDimension)("width", ctx_r20.mainIconDimension)("x", ctx_r20.mainIconLeftPadding)("y", ctx_r20.mainIconTopPadding);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("innerHTML", ctx_r20.getSvgIcon(node_r13.icon), i0.ɵɵsanitizeHtml);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_line_72_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelement(0, "line", 41);
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r21 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("x1", 0)("y1", ctx_r21.defaultNodeHeight)("x2", node_r13.dimension.width)("y2", ctx_r21.defaultNodeHeight);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg");
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵelement(2, "g", 40);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r31 = i0.ɵɵnextContext();
    const info_r26 = ctx_r31.$implicit;
    const i_r27 = ctx_r31.index;
    const ctx_r29 = i0.ɵɵnextContext(6);
    i0.ɵɵattribute("class", info_r26.iconCustomClass)("fill", ctx_r29.getStatusColor(info_r26.status) || ctx_r29.defaultLabelColor)("height", ctx_r29.additionalIconDimension)("width", ctx_r29.additionalIconDimension)("x", ctx_r29.basicLeftPadding + ctx_r29.additionalLeftPadding)("y", ctx_r29.additionalIconTopPadding + i_r27 * ctx_r29.additionalInfoRowHeight);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("innerHTML", ctx_r29.getSvgIcon(info_r26.icon), i0.ɵɵsanitizeHtml);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_line_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelement(0, "line", 41);
} if (rf & 2) {
    const i_r27 = i0.ɵɵnextContext().index;
    const node_r13 = i0.ɵɵnextContext(4).$implicit;
    const ctx_r30 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("x1", 0)("y1", ctx_r30.additionalLineTopPadding + i_r27 * ctx_r30.additionalInfoRowHeight)("x2", node_r13.dimension.width)("y2", ctx_r30.additionalLineTopPadding + i_r27 * ctx_r30.additionalInfoRowHeight);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g");
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_svg_2_Template, 4, 7, "svg", 3);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵtext(4, "\n            ");
    i0.ɵɵelementStart(5, "text", 43);
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n            ");
    i0.ɵɵtemplate(8, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_line_8_Template, 1, 4, "line", 39);
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const info_r26 = ctx.$implicit;
    const i_r27 = ctx.index;
    const last_r28 = ctx.last;
    const node_r13 = i0.ɵɵnextContext(4).$implicit;
    const ctx_r25 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", info_r26.icon);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("text", info_r26.text)("width", node_r13.dimension.width - ctx_r25.basicLeftPadding * 3 - ctx_r25.additionalIconDimension);
    i0.ɵɵattribute("fill", ctx_r25.defaultColor)("x", info_r26.icon ? ctx_r25.basicLeftPadding * 3 : ctx_r25.basicLeftPadding + ctx_r25.additionalLeftPadding)("y", ctx_r25.additionalTextTopPadding + i_r27 * ctx_r25.additionalInfoRowHeight);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", !last_r28);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2_Template, 10, 7, "g", 42);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r22 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", node_r13.data)("ngForTrackBy", ctx_r22.trackByForNodeData);
} }
const _c1 = function (a0) { return { "filter": a0 }; };
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    const _r38 = i0.ɵɵgetCurrentView();
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g", 19);
    i0.ɵɵlistener("click", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_click_0_listener($event) { i0.ɵɵrestoreView(_r38); const node_r13 = i0.ɵɵnextContext(2).$implicit; const ctx_r36 = i0.ɵɵnextContext(2); return ctx_r36.handleNodeClick($event, node_r13); })("mouseover", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_mouseover_0_listener() { i0.ɵɵrestoreView(_r38); const node_r13 = i0.ɵɵnextContext(2).$implicit; const ctx_r39 = i0.ɵɵnextContext(2); return ctx_r39.handleMouseOver(node_r13); })("mouseleave", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_mouseleave_0_listener() { i0.ɵɵrestoreView(_r38); const ctx_r41 = i0.ɵɵnextContext(4); return ctx_r41.nodeHoverId = ""; });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "defs");
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "filter", 20);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelement(6, "feGaussianBlur", 21);
    i0.ɵɵtext(7, "\n            ");
    i0.ɵɵelement(8, "feOffset", 22);
    i0.ɵɵtext(9, "\n            ");
    i0.ɵɵelement(10, "feOffset", 23);
    i0.ɵɵtext(11, "\n            ");
    i0.ɵɵelement(12, "feFlood", 24);
    i0.ɵɵtext(13, "\n            ");
    i0.ɵɵelement(14, "feFlood", 25);
    i0.ɵɵtext(15, "\n            ");
    i0.ɵɵelement(16, "feComposite", 26);
    i0.ɵɵtext(17, "\n            ");
    i0.ɵɵelement(18, "feComposite", 27);
    i0.ɵɵtext(19, "\n            ");
    i0.ɵɵelementStart(20, "feMerge");
    i0.ɵɵtext(21, "\n              ");
    i0.ɵɵelement(22, "feMergeNode", 28);
    i0.ɵɵtext(23, "\n              ");
    i0.ɵɵelement(24, "feMergeNode", 29);
    i0.ɵɵtext(25, "\n              ");
    i0.ɵɵelement(26, "feMergeNode", 30);
    i0.ɵɵtext(27, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(28, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(29, "\n\n          ");
    i0.ɵɵelementStart(30, "filter", 20);
    i0.ɵɵtext(31, "\n            ");
    i0.ɵɵelement(32, "feGaussianBlur", 31);
    i0.ɵɵtext(33, "\n            ");
    i0.ɵɵelement(34, "feOffset", 32);
    i0.ɵɵtext(35, "\n            ");
    i0.ɵɵelement(36, "feOffset", 33);
    i0.ɵɵtext(37, "\n            ");
    i0.ɵɵelement(38, "feFlood", 34);
    i0.ɵɵtext(39, "\n            ");
    i0.ɵɵelement(40, "feFlood", 35);
    i0.ɵɵtext(41, "\n            ");
    i0.ɵɵelement(42, "feComposite", 26);
    i0.ɵɵtext(43, "\n            ");
    i0.ɵɵelement(44, "feComposite", 27);
    i0.ɵɵtext(45, "\n            ");
    i0.ɵɵelementStart(46, "feMerge");
    i0.ɵɵtext(47, "\n              ");
    i0.ɵɵelement(48, "feMergeNode", 28);
    i0.ɵɵtext(49, "\n              ");
    i0.ɵɵelement(50, "feMergeNode", 29);
    i0.ɵɵtext(51, "\n              ");
    i0.ɵɵelement(52, "feMergeNode", 30);
    i0.ɵɵtext(53, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(54, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(55, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(56, "\n        ");
    i0.ɵɵelementStart(57, "rect", 36);
    i0.ɵɵtext(58, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(59, "\n        ");
    i0.ɵɵelementStart(60, "g");
    i0.ɵɵtext(61, "\n          ");
    i0.ɵɵtemplate(62, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_svg_62_Template, 4, 7, "svg", 3);
    i0.ɵɵtext(63, "\n          ");
    i0.ɵɵelementStart(64, "text", 37);
    i0.ɵɵtext(65, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(66, "\n          ");
    i0.ɵɵtext(67, "\n          ");
    i0.ɵɵtext(68, "\n          ");
    i0.ɵɵelementStart(69, "text", 38);
    i0.ɵɵtext(70, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(71, "\n          ");
    i0.ɵɵtemplate(72, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_line_72_Template, 1, 4, "line", 39);
    i0.ɵɵtext(73, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(74, "\n        ");
    i0.ɵɵtemplate(75, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75_Template, 4, 2, "g", 3);
    i0.ɵɵtext(76, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(4);
    i0.ɵɵpropertyInterpolate1("id", "shadow", ctx_r19.componentLevelId, "");
    i0.ɵɵadvance(26);
    i0.ɵɵpropertyInterpolate1("id", "shadow-hover", ctx_r19.componentLevelId, "");
    i0.ɵɵadvance(27);
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(20, _c1, ctx_r19.nodeHoverId && ctx_r19.nodeHoverId === node_r13.id ? "url(#shadow-hover" + ctx_r19.componentLevelId + ")" : "url(#shadow" + ctx_r19.componentLevelId + ")"));
    i0.ɵɵattribute("rx", node_r13.type === "rounded" ? ctx_r19.nodeRoundRadix : 0)("width", node_r13.dimension.width)("height", node_r13.dimension.height)("fill", ctx_r19.defaultBackgroundColor);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", node_r13.icon);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("text", node_r13.label)("width", node_r13.dimension.width - ctx_r19.mainIconLeftPadding * 3 - ctx_r19.mainIconDimension);
    i0.ɵɵattribute("fill", ctx_r19.defaultLabelColor)("x", node_r13.icon ? ctx_r19.mainTextLeftPadding : ctx_r19.basicLeftPadding + ctx_r19.additionalLeftPadding)("y", ctx_r19.mainTextTopPadding);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("text", node_r13.description)("width", node_r13.dimension.width - ctx_r19.mainIconLeftPadding * 3 - ctx_r19.mainIconDimension);
    i0.ɵɵattribute("fill", ctx_r19.defaultColor)("x", node_r13.icon ? ctx_r19.mainTextLeftPadding : ctx_r19.basicLeftPadding + ctx_r19.additionalLeftPadding)("y", (ctx_r19.mainTextTopPadding - ctx_r19.mainTextTopGap) * 2);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", node_r13.data && node_r13.data.length);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", node_r13.data && node_r13.data.length);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template, 77, 22, "g", 18);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", node_r13 && node_r13.dimension && node_r13.dimension.width);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_Template, 4, 4, "ng-container", 15);
    i0.ɵɵtext(2, "\n\n    ");
    i0.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3_Template, 3, 1, "ng-template", null, 16, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n  ");
} if (rf & 2) {
    const _r15 = i0.ɵɵreference(4);
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r8.customTemplateConfig == null ? null : ctx_r8.customTemplateConfig.nodeTemplate)("ngIfElse", _r15);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_ng_template_2_Template(rf, ctx) { }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 45);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r44 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r44.customTemplateConfig.defsTemplate);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(1, "marker", 46);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelement(3, "polygon", 47);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n    ");
} if (rf & 2) {
    const ctx_r46 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate1("id", "arrow", ctx_r46.componentLevelId, "");
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_Template, 4, 1, "ng-container", 15);
    i0.ɵɵtext(2, "\n\n    ");
    i0.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_template_3_Template, 6, 1, "ng-template", null, 44, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n  ");
} if (rf & 2) {
    const _r45 = i0.ɵɵreference(4);
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r10.customTemplateConfig == null ? null : ctx_r10.customTemplateConfig.defsTemplate)("ngIfElse", _r45);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_ng_template_2_Template(rf, ctx) { }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 17);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const link_r48 = i0.ɵɵnextContext().$implicit;
    const ctx_r49 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r49.customTemplateConfig.linkTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c0, link_r48));
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3__svg_g_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "rect", 51);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "text", 52);
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const link_r48 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r54 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("transform", "translate(" + link_r48.midPoint.x + "," + link_r48.midPoint.y + ")");
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("filter", "url(#shadow" + ctx_r54.componentLevelId + ")");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("text", link_r48.label)("width", 70);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(1, "g", 49);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "path", 50);
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵtemplate(7, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3__svg_g_7_Template, 8, 4, "g", 3);
    i0.ɵɵtext(8, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
} if (rf & 2) {
    const link_r48 = i0.ɵɵnextContext().$implicit;
    const ctx_r51 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(4);
    i0.ɵɵattribute("stroke-dasharray", link_r48.type === "stroke" ? ctx_r51.strokeLineLength : 0)("marker-end", "url(#arrow" + ctx_r51.componentLevelId + ")");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", link_r48.label && link_r48.midPoint);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_Template, 4, 4, "ng-container", 15);
    i0.ɵɵtext(2, "\n\n    ");
    i0.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3_Template, 10, 3, "ng-template", null, 48, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n  ");
} if (rf & 2) {
    const _r50 = i0.ɵɵreference(4);
    const ctx_r12 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r12.customTemplateConfig == null ? null : ctx_r12.customTemplateConfig.linkTemplate)("ngIfElse", _r50);
} }
const _c2 = function () { return []; };
function AdaptFlowChartComponent_ngx_graph_10_Template(rf, ctx) { if (rf & 1) {
    const _r58 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "ngx-graph", 11);
    i0.ɵɵlistener("zoomChange", function AdaptFlowChartComponent_ngx_graph_10_Template_ngx_graph_zoomChange_0_listener($event) { i0.ɵɵrestoreView(_r58); const ctx_r57 = i0.ɵɵnextContext(); return ctx_r57.handleZoomChangeDebounced($event); });
    i0.ɵɵtext(1, "\n\n  ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_Template, 6, 2, "ng-template", null, 12, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(4, "\n\n  ");
    i0.ɵɵtemplate(5, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_Template, 6, 2, "ng-template", null, 13, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(7, "\n\n  ");
    i0.ɵɵtemplate(8, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_Template, 6, 2, "ng-template", null, 14, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(10, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("links", ctx_r3.links || i0.ɵɵpureFunction0(17, _c2))("nodes", ctx_r3.nodes)("curve", ctx_r3.curve)("draggingEnabled", false)("layoutSettings", ctx_r3.layoutSettings)("enableZoom", ctx_r3.enableZoom)("zoomSpeed", ctx_r3.zoomSpeed)("autoZoom", ctx_r3.autoZoom)("autoCenter", ctx_r3.autoCenter)("center$", ctx_r3.center$)("zoomToFit$", ctx_r3.zoomToFit$)("update$", ctx_r3.update$)("panToNode$", ctx_r3.panToNode$)("panningEnabled", !ctx_r3.isIE)("zoomLevel", ctx_r3.zoomLevel)("minZoomLevel", ctx_r3.minZoomLevel)("maxZoomLevel", ctx_r3.maxZoomLevel);
} }
class AdaptFlowChartComponent {
    constructor(_deviceDetection, _changeDetectorRef, _domSanitizer, _iconConfig) {
        this._deviceDetection = _deviceDetection;
        this._changeDetectorRef = _changeDetectorRef;
        this._domSanitizer = _domSanitizer;
        this._iconConfig = _iconConfig;
        this.center$ = new Subject();
        this.zoomToFit$ = new Subject();
        this.panToNode$ = new Subject();
        this.update$ = new Subject();
        this.mainTextLeftPadding = 70;
        this.mainTextTopPadding = 34;
        this.mainTextTopGap = 6;
        this.mainIconDimension = 40;
        this.mainIconLeftPadding = 15;
        this.mainIconTopPadding = 20;
        this.defaultNodeHeight = 78;
        this.defaultNodeWidth = 280;
        this.nodeRoundRadix = 45;
        this.additionalInfoRowHeight = 42;
        this.additionalIconDimension = 13;
        this.basicLeftPadding = 12;
        this.additionalLeftPadding = 4;
        this.additionalIconTopPadding = 93;
        this.additionalTextTopPadding = 103;
        this.additionalLineTopPadding = 120;
        this.defaultColor = 'currentcolor';
        this.defaultLabelColor = 'var(--color-active)';
        this.defaultBackgroundColor = '#fff';
        this.strokeLineLength = 4;
        this.layoutSettings = {
            orientation: AdaptFlowChartOrientation.BOTTOM_TO_TOP
        };
        this.minZoomLevel = 0.1;
        this.maxZoomLevel = 4;
        this.handleZoomChangeDebounced = debounce(this.handleZoomChange.bind(this), 200);
        this.loading = true;
        this.isIE = false;
        this.nodeHoverId = '';
        this.curve = shape.curveCatmullRom;
        this.orientation = AdaptFlowChartOrientation.BOTTOM_TO_TOP;
        this.zoomSpeed = 0.04;
        // @Input() draggingEnabled = false;
        this.enableZoom = true;
        this.autoZoom = false;
        this.autoCenter = false;
        this.hasEmptyState = true;
        this.clickNode = new EventEmitter();
        this.class = 'adapt-flow-chart';
        this._defaultTexts = {
            fitGraphButton: 'Fit to screen'
        };
        this._defaultEmptyStateConfig = {
            label: '',
            inverted: false
        };
    }
    ngOnInit() {
        this.componentLevelId = Math.floor(Math.random() * 1000000).toString();
        this.isIE = this._deviceDetection.isIE();
        this.texts = Object.assign(Object.assign({}, this._defaultTexts), this.texts);
        this.emptyStateConfig = Object.assign(Object.assign({}, this._defaultEmptyStateConfig), this.emptyStateConfig);
        this.layoutSettings.orientation = this.orientation;
    }
    ngOnChanges(changes) {
        const nodes = changes.nodes;
        if (this.nodes && nodes && nodes.previousValue !== nodes.currentValue) {
            this.nodes.forEach(node => {
                node.dimension = {
                    width: node.dimension && node.dimension.width || this.defaultNodeWidth,
                    height: this.getNodeHeight(node)
                };
            });
            if (this.autoCenterToNode) {
                if (this.autoCenter) {
                    this.autoCenter = false;
                    adaptWarn(`ADAPT-ANGULAR Warning! Flow chart component!
          Seems like "autoCenter" is enabled with "autoCenterToNode".
          In this case "autoCenter" will be disabled for correct work of "autoCenterToNode"`);
                }
                setTimeout(() => {
                    this.panToNode$.next(this.autoCenterToNode);
                    this.autoCenterToNode = null;
                });
            }
            this.loading = false;
        }
    }
    showEmptyState() {
        return this.hasEmptyState && !this.loading && (!this.nodes || this.nodes.length === 0);
    }
    showGraph() {
        return toBoolean(!this.loading && this.nodes && this.nodes.length !== 0);
    }
    getStatusColor(status) {
        return status || status === 0 ? ChartColorService.getColorRange(status, 1)[0] : this.defaultColor;
    }
    getSvgIcon(name) {
        return this._domSanitizer.bypassSecurityTrustHtml(this._iconConfig.getIcon(name));
    }
    fitGraph() {
        this.zoomToFit$.next(true);
        // At the same time centring graph for better user experience
        this.center$.next(true);
    }
    handleNodeClick(event, node) {
        this.clickNode.emit({ event, node });
    }
    handleMouseOver(node) {
        this.nodeHoverId = node.id;
    }
    handleZoomMouseDown() {
        this._disableAutoZoom();
    }
    handleZoomChange(zoomLevel) {
        this._disableAutoZoom();
        this.zoomLevel = zoomLevel;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    getNodeHeight(node) {
        if (node.data && node.data.length) {
            return this.defaultNodeHeight + node.data.length * this.additionalInfoRowHeight;
        }
        else {
            return node.dimension && node.dimension.height || this.defaultNodeHeight;
        }
    }
    trackByForNodeData(index) {
        return index;
    }
    sliderValueFormatter(value) {
        if ((value ^ 0) === value) {
            return value.toString();
        }
        else {
            const digitsAfterComma = value.toString().split('.')[1].length;
            const roundTo = digitsAfterComma > 2 ? 2 : 1;
            return value.toFixed(roundTo);
        }
    }
    _disableAutoZoom() {
        // This hack need to be done to allow zooming with slider if autoZoom feature was enabled by default
        if (this.autoZoom) {
            this.autoZoom = false;
        }
        // Also need to disable autoCenter to avoid centring on zooming
        if (this.autoCenter) {
            this.autoCenter = false;
        }
    }
}
AdaptFlowChartComponent.ɵfac = function AdaptFlowChartComponent_Factory(t) { return new (t || AdaptFlowChartComponent)(i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.DomSanitizer), i0.ɵɵdirectiveInject(i1.AdaptIconConfig)); };
AdaptFlowChartComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptFlowChartComponent, selectors: [["adapt-flow-chart"]], hostVars: 4, hostBindings: function AdaptFlowChartComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.class);
        i0.ɵɵstyleProp("background-color", ctx.backgroundColor);
    } }, inputs: { links: "links", nodes: "nodes", curve: "curve", orientation: "orientation", zoomSpeed: "zoomSpeed", enableZoom: "enableZoom", autoZoom: "autoZoom", autoCenter: "autoCenter", texts: "texts", autoCenterToNode: "autoCenterToNode", hasEmptyState: "hasEmptyState", emptyStateConfig: "emptyStateConfig", customTemplateConfig: "customTemplateConfig", backgroundColor: "backgroundColor" }, outputs: { clickNode: "clickNode" }, features: [i0.ɵɵNgOnChangesFeature], decls: 12, vars: 4, consts: [["class", "loader-container adapt-flow-chart__loader", 4, "ngIf"], ["class", "adapt-flow-chart__empty-state", 4, "ngIf"], [1, "adapt-flow-chart__zoom-slider-wrapper"], [4, "ngIf"], ["version", "1.1", 0, "xmlns", "svg", "http://www.w3.org/2000/svg", 3, "links", "nodes", "curve", "draggingEnabled", "layoutSettings", "enableZoom", "zoomSpeed", "autoZoom", "autoCenter", "center$", "zoomToFit$", "update$", "panToNode$", "panningEnabled", "zoomLevel", "minZoomLevel", "maxZoomLevel", "zoomChange", 4, "ngIf"], [1, "loader-container", "adapt-flow-chart__loader"], [1, "loader-section"], [1, "adapt-flow-chart__empty-state"], [3, "type", "inverted", "label"], ["orientation", "vertical", 3, "ngModel", "customStepChange", "min", "max", "formatter", "step", "styleClass", "ngModelChange"], [1, "adapt-flow-chart__zoom-fit-button", 3, "click"], ["version", "1.1", 0, "xmlns", "svg", "http://www.w3.org/2000/svg", 3, "links", "nodes", "curve", "draggingEnabled", "layoutSettings", "enableZoom", "zoomSpeed", "autoZoom", "autoCenter", "center$", "zoomToFit$", "update$", "panToNode$", "panningEnabled", "zoomLevel", "minZoomLevel", "maxZoomLevel", "zoomChange"], ["nodeTemplate", ""], ["defsTemplate", ""], ["linkTemplate", ""], [4, "ngIf", "ngIfElse"], ["defaultNodeTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "node", 3, "click", "mouseover", "mouseleave", 4, "ngIf"], [1, "node", 3, "click", "mouseover", "mouseleave"], ["height", "150%", 3, "id"], ["in", "SourceAlpha", "stdDeviation", "2.5", "result", "blur"], ["dx", "0", "dy", "2", "result", "offsetBlur"], ["dx", "0", "dy", "4", "result", "offsetBlur2", "in", "blur"], ["flood-color", "black", "flood-opacity", "0.14", "result", "offsetColor"], ["flood-color", "black", "flood-opacity", "0.06", "result", "offsetColor2"], ["in", "offsetColor", "in2", "offsetBlur", "operator", "in", "result", "offsetBlur"], ["in", "offsetColor2", "in2", "offsetBlur2", "operator", "in", "result", "offsetBlur2"], ["in", "offsetBlur"], ["in", "offsetBlur2"], ["in", "SourceGraphic"], ["in", "SourceAlpha", "stdDeviation", "7", "result", "blur"], ["dx", "0", "dy", "4", "result", "offsetBlur"], ["dx", "0", "dy", "9", "result", "offsetBlur2", "in", "blur"], ["flood-color", "black", "flood-opacity", "0.17", "result", "offsetColor"], ["flood-color", "black", "flood-opacity", "0.09", "result", "offsetColor2"], [1, "adapt-flow-chart__box", 3, "ngStyle"], ["alignment-baseline", "central", "adaptTextEllipsis", "", 1, "adapt-flow-chart__label", 3, "text", "width"], ["alignment-baseline", "central", "adaptTextEllipsis", "", 3, "text", "width"], ["stroke", "lightgrey", 4, "ngIf"], [3, "innerHTML"], ["stroke", "lightgrey"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["adaptTextEllipsis", "", 3, "text", "width"], ["defaultDefsTemplate", ""], [3, "ngTemplateOutlet"], ["markerWidth", "8", "markerHeight", "7", "refX", "7", "refY", "3", "orient", "auto", 3, "id"], ["points", "0 0, 8 3, 0 6", "fill", "#333"], ["defaultLinkTemplate", ""], [1, "edge"], ["stroke-width", "2", "stroke", "#333", 1, "line"], ["width", "90", "height", "30", "x", "-45", "y", "-18", "rx", "3", 1, "adapt-flow-chart__edge-label-bg"], ["adaptTextEllipsis", "", "alignment-baseline", "central", 1, "adapt-flow-chart__edge-label-text", 3, "text", "width"]], template: function AdaptFlowChartComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptFlowChartComponent_div_0_Template, 4, 0, "div", 0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptFlowChartComponent_div_2_Template, 4, 3, "div", 1);
        i0.ɵɵtext(3, "\n\n");
        i0.ɵɵelementStart(4, "div", 2);
        i0.ɵɵtext(5, "\n  ");
        i0.ɵɵtemplate(6, AdaptFlowChartComponent_div_6_Template, 8, 8, "div", 3);
        i0.ɵɵtext(7, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n");
        i0.ɵɵtext(9, "\n");
        i0.ɵɵtemplate(10, AdaptFlowChartComponent_ngx_graph_10_Template, 11, 18, "ngx-graph", 4);
        i0.ɵɵtext(11, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.loading);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.showEmptyState());
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.showGraph() && ctx.enableZoom);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.showGraph());
    } }, directives: [i3$1.NgIf, i1.AdaptEmptyStateComponent, i1.AdaptSliderComponent, i4.NgControlStatus, i4.NgModel, i5.GraphComponent, i3$1.NgTemplateOutlet, i3$1.NgStyle, AdaptTextEllipsisDirective, i3$1.NgForOf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptFlowChartComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-flow-chart',
                templateUrl: './flow-chart.component.html',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i1.AdaptDeviceDetectionService }, { type: i0.ChangeDetectorRef }, { type: i3.DomSanitizer }, { type: i1.AdaptIconConfig }]; }, { links: [{
            type: Input
        }], nodes: [{
            type: Input
        }], curve: [{
            type: Input
        }], orientation: [{
            type: Input
        }], zoomSpeed: [{
            type: Input
        }], enableZoom: [{
            type: Input
        }], autoZoom: [{
            type: Input
        }], autoCenter: [{
            type: Input
        }], texts: [{
            type: Input
        }], autoCenterToNode: [{
            type: Input
        }], hasEmptyState: [{
            type: Input
        }], emptyStateConfig: [{
            type: Input
        }], customTemplateConfig: [{
            type: Input
        }], clickNode: [{
            type: Output
        }], class: [{
            type: HostBinding,
            args: ['class']
        }], backgroundColor: [{
            type: HostBinding,
            args: ['style.background-color']
        }, {
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
const ADAPT_CHARTS_VERSION = new Version('12.25.0');

class AdaptChartsModule {
}
AdaptChartsModule.ɵfac = function AdaptChartsModule_Factory(t) { return new (t || AdaptChartsModule)(); };
AdaptChartsModule.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: AdaptChartsModule });
AdaptChartsModule.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ providers: [
        ChartColorService
    ], imports: [[
            AdaptTooltipModule,
            NgxGraphModule,
            FormsModule,
            AdaptSliderModule,
            AdaptEmptyStateModule,
            AdaptDropdownModule,
            CommonModule,
            AdaptListKeyManagerModule,
            AdaptIconModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptChartsModule, [{
        type: NgModule,
        args: [{
                imports: [
                    AdaptTooltipModule,
                    NgxGraphModule,
                    FormsModule,
                    AdaptSliderModule,
                    AdaptEmptyStateModule,
                    AdaptDropdownModule,
                    CommonModule,
                    AdaptListKeyManagerModule,
                    AdaptIconModule
                ],
                declarations: [
                    AdaptChartComponent,
                    AdaptHeatmapComponent,
                    AdaptLineGraphComponent,
                    AdaptScatterPlotComponent,
                    AdaptTreemapComponent,
                    ChartLegendComponent,
                    ChartGradientLegendComponent,
                    CutNumberPipe,
                    AdaptPieChartComponent,
                    AdaptStackedChartComponent,
                    AdaptChartSliderComponent,
                    AdaptAreaGraphSliderComponent,
                    AdaptAreaGraphComponent,
                    AdaptFlowChartComponent,
                    AdaptTextEllipsisDirective,
                ],
                providers: [
                    ChartColorService
                ],
                exports: [
                    AdaptChartComponent,
                    AdaptHeatmapComponent,
                    AdaptLineGraphComponent,
                    AdaptScatterPlotComponent,
                    AdaptTreemapComponent,
                    ChartLegendComponent,
                    ChartGradientLegendComponent,
                    AdaptPieChartComponent,
                    AdaptStackedChartComponent,
                    AdaptAreaGraphComponent,
                    AdaptFlowChartComponent,
                    AdaptTextEllipsisDirective
                ],
                schemas: [NO_ERRORS_SCHEMA]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(AdaptChartsModule, { declarations: [AdaptChartComponent,
        AdaptHeatmapComponent,
        AdaptLineGraphComponent,
        AdaptScatterPlotComponent,
        AdaptTreemapComponent,
        ChartLegendComponent,
        ChartGradientLegendComponent,
        CutNumberPipe,
        AdaptPieChartComponent,
        AdaptStackedChartComponent,
        AdaptChartSliderComponent,
        AdaptAreaGraphSliderComponent,
        AdaptAreaGraphComponent,
        AdaptFlowChartComponent,
        AdaptTextEllipsisDirective], imports: [AdaptTooltipModule,
        NgxGraphModule,
        FormsModule,
        AdaptSliderModule,
        AdaptEmptyStateModule,
        AdaptDropdownModule,
        CommonModule,
        AdaptListKeyManagerModule,
        AdaptIconModule], exports: [AdaptChartComponent,
        AdaptHeatmapComponent,
        AdaptLineGraphComponent,
        AdaptScatterPlotComponent,
        AdaptTreemapComponent,
        ChartLegendComponent,
        ChartGradientLegendComponent,
        AdaptPieChartComponent,
        AdaptStackedChartComponent,
        AdaptAreaGraphComponent,
        AdaptFlowChartComponent,
        AdaptTextEllipsisDirective] }); })();
i0.ɵɵsetComponentScope(AdaptChartSliderComponent, [i3$1.NgClass, i3$1.NgIf, i3$1.NgSwitch, i3$1.NgSwitchCase, AdaptStackedChartComponent], []);
i0.ɵɵsetComponentScope(AdaptAreaGraphSliderComponent, [AdaptAreaGraphComponent, i3$1.NgIf, i3$1.NgClass], []);

/*
 * Public API Surface of adapt-charts
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ADAPT_CHARTS_VERSION, AdaptAreaGraphComponent, AdaptChartAbstract, AdaptChartColorStatus, AdaptChartComponent, AdaptChartSliderType, AdaptChartsModule, AdaptFlowChartComponent, AdaptFlowChartOrientation, AdaptHeatmapAbstract, AdaptHeatmapComponent, AdaptLineGraphAbstract, AdaptLineGraphComponent, AdaptPieChartAbstract, AdaptPieChartComponent, AdaptScatterPlotAbstract, AdaptScatterPlotComponent, AdaptStackedChartAbstract, AdaptStackedChartComponent, AdaptStackedChartType, AdaptTextEllipsisDirective, AdaptTreemapAbstract, AdaptTreemapComponent, ChartColorService, ChartColorsFactory, ChartGradientLegendComponent, ChartLegendComponent, STATUS_COLOR_RANGE, textEllipsis };
//# sourceMappingURL=bmc-ux-adapt-charts.js.map
