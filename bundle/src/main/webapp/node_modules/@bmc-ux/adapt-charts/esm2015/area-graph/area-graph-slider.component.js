import { Component, ElementRef, EventEmitter, Input, NgZone, Output, ViewChild } from '@angular/core';
/* eslint-disable no-duplicate-imports */
import * as d3 from 'd3';
import { ReplaySubject } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
const _c0 = ["svgBrushContainer"];
const _c1 = ["slider"];
const _c2 = ["chart"];
function AdaptAreaGraphSliderComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵnamespaceHTML();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelement(2, "div");
    i0.ɵɵtext(3, "\n\n        ");
    i0.ɵɵelement(4, "div", 6);
    i0.ɵɵtext(5, "\n\n        ");
    i0.ɵɵelement(6, "div");
    i0.ɵɵtext(7, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate2("", ctx_r3.classPrefix, "-side-overlay ", ctx_r3.classPrefix, "-side-overlay-right");
    i0.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("height", ctx_r3.height, "px")("width", ctx_r3.getXPos(), "px");
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("", ctx_r3.classPrefix, "-spot");
    i0.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("z-index", 1)("height", ctx_r3.height + 5, "px")("width", ctx_r3.brushWidth, "px")("left", ctx_r3.getXPos(), "px");
    i0.ɵɵproperty("ngClass", ctx_r3.isActive ? ctx_r3.classPrefix + "-spot-active" : "");
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate2("", ctx_r3.classPrefix, "-side-overlay ", ctx_r3.classPrefix, "-side-overlay-left");
    i0.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("height", ctx_r3.height, "px")("left", ctx_r3.getXOverlayPos(), "px")("width", ctx_r3.getRightOverlayWidth(), "px");
} }
const _c3 = function () { return {}; };
const _c4 = function () { return []; };
const _c5 = function (a0, a1) { return { items: a0, customColors: a1 }; };
const classPrefix = 'adapt-chart-slider';
const sliderPaddingTop = 10; // need to be aligned with the css $slider-padding-top: 10;
export class AdaptAreaGraphSliderComponent {
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        this.isInitialized = false;
        this.isActive = false;
        this.height = 35;
        this.leftShift = 0;
        this.rangeChanged = new EventEmitter();
        this.scrollEnd = new EventEmitter();
        this._cX = 0;
        this._inMotion = false;
        this._destroyed$ = new ReplaySubject(1);
        this.classPrefix = classPrefix;
        this.sliderPaddingTop = sliderPaddingTop;
    }
    ngOnInit() {
        this._ngZone.onStable
            .pipe(takeUntil(this._destroyed$), take(1))
            .subscribe(() => {
            this.isInitialized = true;
        });
    }
    ngOnChanges(changes) {
        if (this.isInitialized && changes.slidePointsCount) {
            this._g.select('.brush-wrp').remove();
            this._initBrush();
        }
    }
    ngAfterViewInit() {
        this._g = d3.select(this._svgContainerEl.nativeElement);
        this._xMinValue = this._chartComponent.getXMinValue(this.data);
        this._xMaxValue = this._chartComponent.getXMaxValue(this.data);
        this._renderBrushXAxis();
        this._initBrush();
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    getXPos() {
        return parseFloat(this._dndEl.getAttribute('x')) || 0;
    }
    getXOverlayPos() {
        return this.getXPos() + this.brushWidth;
    }
    getRightOverlayWidth() {
        return this.containerWidth - this.leftShift - this.getXOverlayPos();
    }
    showCategory(category) {
        this._chartComponent.categoryShowHandler(category);
    }
    hideCategory(category) {
        this._chartComponent.categoryHideHandler(category);
    }
    updateSlider(dim) {
        this.containerWidth = dim.w;
        const { height } = this._sliderEl.nativeElement.getBoundingClientRect();
        this._chartComponent._updateChart({
            w: dim.w - this.leftShift,
            h: height - this.sliderPaddingTop * 2
        });
        this.xBrush = d3.scaleLinear()
            .range([0, dim.w - this.leftShift])
            .domain([this._xMinValue, this._xMaxValue]);
        const x = this._g.select('.axis--x');
        x.call(this._getXAxisLineRenderer());
        this._g.select('.brush-wrp').remove();
        this._initBrush();
    }
    _renderBrushXAxis() {
        this._g
            .append('g').attr('class', 'axis axis--x')
            .attr('transform', `translate(0, ${this.height})`)
            .call(this._getXAxisLineRenderer());
    }
    _getXAxisLineRenderer() {
        return d3.axisBottom(this.xBrush);
    }
    _initBrush() {
        // TODO check for refactoring
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const _self = this;
        this._brush = d3.brushX()
            .extent([[0, 0], [this.containerWidth - this.leftShift, this.height]])
            .on('brush', function () {
            _self._brushed();
        })
            .on('end.brush', function () {
            _self.scrollEnd.emit();
        });
        this.brushWidth = Math.ceil(this.xBrush((this.xBrush).ticks()[this.slidePointsCount]));
        this._initBrushHandlers();
    }
    _initBrushHandlers() {
        // TODO check for refactoring
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const _self = this;
        this._g
            .append('g').attr('class', 'brush-wrp')
            .append('g').attr('class', 'brush')
            .call(this._brush)
            .call(this._brush.move, [this._cX, this._cX + this.brushWidth])
            .call(g => g.select('.selection').attr('stroke', null).attr('fill-opacity', '0.1')
            .on('mouseover', function () {
            _self.isActive = true;
        })
            .on('mousedown', function () {
            _self._inMotion = true;
        })
            .on('mouseout', function () {
            if (!_self._inMotion) {
                _self.isActive = false;
            }
        }))
            .call(g => g.select('.overlay')
            .datum({ type: 'selection' })
            .on('mousedown', function () {
            const [cx] = d3.mouse(this);
            const [x0, x1] = [cx - _self.brushWidth / 2, cx + _self.brushWidth / 2];
            const [r0, r1] = _self.xBrush.range();
            d3.select(this.parentNode)
                .call(_self._brush.move, x1 > r1
                ? [r1 - _self.brushWidth, r1]
                : x0 < r0
                    ? [r0, r0 + _self.brushWidth]
                    : [x0, x1]);
        }));
        // prevent resizing
        this._g.selectAll('.brush-wrp > .brush > .handle').remove();
        this._dndEl = this._svgContainerEl.nativeElement.querySelector('rect.selection');
    }
    _brushed() {
        this._cX = d3.event.selection[0];
        const selection = d3.event.selection || this.xBrush.range();
        this.rangeChanged.emit(selection.map((this.xBrush).invert, this.xBrush));
        this._inMotion = false;
    }
}
AdaptAreaGraphSliderComponent.ɵfac = function AdaptAreaGraphSliderComponent_Factory(t) { return new (t || AdaptAreaGraphSliderComponent)(i0.ɵɵdirectiveInject(i0.NgZone)); };
AdaptAreaGraphSliderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptAreaGraphSliderComponent, selectors: [["adapt-area-graph-slider"]], viewQuery: function AdaptAreaGraphSliderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 5);
        i0.ɵɵviewQuery(_c2, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._svgContainerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._sliderEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._chartComponent = _t.first);
    } }, inputs: { xAxis: "xAxis", height: "height", slidePointsCount: "slidePointsCount", customColors: "customColors", xBrush: "xBrush", leftShift: "leftShift", containerWidth: "containerWidth", data: "data" }, outputs: { rangeChanged: "rangeChanged", scrollEnd: "scrollEnd" }, features: [i0.ɵɵNgOnChangesFeature], decls: 19, vars: 28, consts: [["slider", ""], [3, "xAxis", "yAxis", "legend", "series", "height", "disallowPadding", "supressAxles", "suppressLegend"], ["chart", ""], ["xmlns", "http://www.w3.org/2000/svg", "tabindex", "-1", "role", "graphic/image", "aria-describedby", "title desc", 1, "adapt-chart-slider-brush-svg"], ["svgBrushContainer", ""], [4, "ngIf"], [3, "ngClass"]], template: function AdaptAreaGraphSliderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", null, 0);
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelement(4, "adapt-area-graph", 1, 2);
        i0.ɵɵtext(6, "\n\n      ");
        i0.ɵɵnamespaceSVG();
        i0.ɵɵelementStart(7, "svg", 3, 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n\n      ");
        i0.ɵɵtemplate(11, AdaptAreaGraphSliderComponent_ng_container_11_Template, 8, 36, "ng-container", 5);
        i0.ɵɵtext(12, "\n\n      ");
        i0.ɵɵnamespaceHTML();
        i0.ɵɵelementStart(13, "div");
        i0.ɵɵtext(14, "\n        ");
        i0.ɵɵelement(15, "div");
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵclassMap(ctx.classPrefix);
        i0.ɵɵstyleProp("margin-left", ctx.leftShift, "px");
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("xAxis", ctx.xAxis)("yAxis", i0.ɵɵpureFunction0(23, _c3))("legend", i0.ɵɵpureFunction2(25, _c5, i0.ɵɵpureFunction0(24, _c4), ctx.customColors))("series", ctx.data)("height", ctx.height)("disallowPadding", true)("supressAxles", true)("suppressLegend", true);
        i0.ɵɵadvance(3);
        i0.ɵɵattributeInterpolate2("viewbox", "0 0 ", ctx.containerWidth - ctx.leftShift, " ", ctx.height, "");
        i0.ɵɵattribute("width", ctx.containerWidth - ctx.leftShift)("height", ctx.height);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.isInitialized);
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line-wrapper");
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptAreaGraphSliderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-area-graph-slider',
                template: `
    <div #slider
         [class]="classPrefix"
         [style.marginLeft.px]="leftShift">
      <adapt-area-graph #chart
                        [xAxis]="xAxis"
                        [yAxis]="{}"
                        [legend]="{items: [], customColors: customColors}"
                        [series]="data"
                        [height]="height"
                        [disallowPadding]="true"
                        [supressAxles]="true"
                        [suppressLegend]="true"></adapt-area-graph>

      <svg xmlns="http://www.w3.org/2000/svg" #svgBrushContainer
           class="adapt-chart-slider-brush-svg"
           tabindex="-1"
           role="graphic/image"
           aria-describedby="title desc"
           attr.viewbox="0 0 {{containerWidth - leftShift}} {{height}}"
           [attr.width]="containerWidth - leftShift"
           [attr.height]="height">
      </svg>

      <ng-container *ngIf="isInitialized">
        <div class="{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-right"
             [style.top.px]="sliderPaddingTop"
             [style.height.px]="height"
             [style.width.px]="getXPos()"></div>

        <div class="{{classPrefix}}-spot"
             [style.top.px]="sliderPaddingTop"
             [style.zIndex]="1"
             [style.height.px]="height + 5"
             [style.width.px]="brushWidth"
             [style.left.px]="getXPos()"
             [ngClass]="isActive ? classPrefix + '-spot-active' : ''"></div>

        <div class="{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-left"
             [style.top.px]="sliderPaddingTop"
             [style.height.px]="height"
             [style.left.px]="getXOverlayPos()"
             [style.width.px]="getRightOverlayWidth()"></div>
      </ng-container>

      <div class="{{classPrefix}}-line-wrapper">
        <div class="{{classPrefix}}-line"></div>
      </div>
    </div>
  `
            }]
    }], function () { return [{ type: i0.NgZone }]; }, { xAxis: [{
            type: Input
        }], height: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }], customColors: [{
            type: Input
        }], xBrush: [{
            type: Input
        }], leftShift: [{
            type: Input
        }], containerWidth: [{
            type: Input
        }], data: [{
            type: Input
        }], rangeChanged: [{
            type: Output
        }], scrollEnd: [{
            type: Output
        }], _svgContainerEl: [{
            type: ViewChild,
            args: ['svgBrushContainer']
        }], _sliderEl: [{
            type: ViewChild,
            args: ['slider']
        }], _chartComponent: [{
            type: ViewChild,
            args: ['chart']
        }] }); })();
//# sourceMappingURL=area-graph-slider.component.js.map