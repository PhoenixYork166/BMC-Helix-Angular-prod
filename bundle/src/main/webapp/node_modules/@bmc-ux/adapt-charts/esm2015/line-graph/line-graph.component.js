import { ChangeDetectorRef, Component, EventEmitter, Input, NgZone, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { take, takeUntil } from 'rxjs/operators';
import { ReplaySubject } from 'rxjs';
import BigNumber from 'bignumber.js';
/* eslint-disable no-duplicate-imports */
import * as d3 from 'd3';
import { isNumber } from 'lodash-es';
/* eslint-enable no-duplicate-imports */
import { CutNumberPipe } from '../common/pipes/cut-number.pipe';
import { ChartColorService } from '../common/services/chart-color.service';
import { nameof } from '../common/utils/chart-utils';
import { AdaptLineGraphAbstract } from '../common/models/line-graph.model';
import { AdaptChartComponent } from '../common/chart.component';
import { AdaptAreaGraphSliderComponent } from '../area-graph/area-graph-slider.component';
import { AdaptDeviceDetectionService, ANIMATION_DURATION, ColorType, isUndefined, SafeCdr } from '@bmc-ux/adapt-angular';
import * as i0 from "@angular/core";
import * as i1 from "../common/pipes/cut-number.pipe";
import * as i2 from "@bmc-ux/adapt-angular";
import * as i3 from "../common/services/chart-color.service";
import * as i4 from "../common/chart.component";
import * as i5 from "@angular/common";
import * as i6 from "../area-graph/area-graph-slider.component";
const _c0 = ["tooltipTpl"];
function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-area-graph-slider", 3);
    i0.ɵɵlistener("rangeChanged", function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_rangeChanged_0_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.rangeChanged($event); })("scrollEnd", function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_scrollEnd_0_listener() { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.scrollEnd(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("data", ctx_r0.sliderData)("xAxis", ctx_r0.xAxis)("slidePointsCount", ctx_r0.slidePointsCount)("customColors", ctx_r0.legend == null ? null : ctx_r0.legend.customColors)("xBrush", ctx_r0.xBrush)("leftShift", ctx_r0.leftShift)("containerWidth", ctx_r0.chartWidth);
} }
function AdaptLineGraphComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 4);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "div", 5);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelement(5, "span", 6);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementStart(7, "span", 7);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementStart(11, "div");
    i0.ɵɵtext(12);
    i0.ɵɵelementStart(13, "span");
    i0.ɵɵelementStart(14, "b");
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n\n    ");
    i0.ɵɵelementStart(18, "div");
    i0.ɵɵtext(19);
    i0.ɵɵelementStart(20, "span");
    i0.ɵɵelementStart(21, "b");
    i0.ɵɵtext(22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n");
} if (rf & 2) {
    const data_r6 = ctx.data;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵstyleProp("background", data_r6 == null ? null : data_r6.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.category);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.getTooltipXValueTitle(), ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.xValue);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.yAxis == null ? null : ctx_r2.yAxis.title, ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.yValue);
} }
let chartCounter = 1;
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export class AdaptLineGraphComponent extends AdaptLineGraphAbstract {
    constructor(_cutNumber, _deviceDetectionService, _colorService, _ngZone, _changeDetectorRef) {
        super();
        this._cutNumber = _cutNumber;
        this._deviceDetectionService = _deviceDetectionService;
        this._colorService = _colorService;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this.alreadyChanged = false;
        this.sliderData = [];
        this.sliderDomainData = [];
        this._dataBuilderBind = this._dataBuilder.bind(this);
        this._updateChartBind = this._updateChart.bind(this);
        this.componentNumericalValues = {
            circleRadius: 6,
            maxTicksCount: 7,
            axisShift: {
                top: 0,
                right: 0,
                bottom: 25,
                left: 25
            },
            margin: {
                top: 0,
                right: 0,
                bottom: 25,
                left: 50
            },
            marginMobile: 40
        };
        this.circleRadius = this.componentNumericalValues.circleRadius;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._series = [];
        this._maxTicksCount = this.componentNumericalValues.maxTicksCount;
        this._data = [];
        this._isDeselected = [];
        this._colors = [];
        this._destroy$ = new ReplaySubject(1);
        this._axisShift = Object.assign({}, this.componentNumericalValues.axisShift);
        this.colorsPalette = 'gradient';
        this.supressAxles = false;
        this.showLineCircles = true;
        this.rotateXAxis = false;
        this.showSlider = false;
        this.disallowPadding = false;
        this.scientificMode = false;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.clickChart = new EventEmitter();
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
        this._thresholdLine = null;
        this._legend = {
            columns: 1,
            activeHover: true,
            activeClick: true,
            width: 250,
            customColors: null,
            items: []
        };
        this._id = `line-graph-${chartCounter++}`;
    }
    get _margin() {
        return {
            top: 0,
            left: this.isMobile()
                ? this.componentNumericalValues.marginMobile
                : this.disallowPadding
                    ? 0
                    : this.yAxis && this.yAxis.title ? this.componentNumericalValues.margin.left + this._axisShift.left : this.componentNumericalValues.margin.left,
            right: 0,
            bottom: this.disallowPadding
                ? 0
                : this.xAxis && this.xAxis.title ? this.componentNumericalValues.margin.bottom + this._axisShift.bottom : this.componentNumericalValues.margin.bottom
        };
    }
    get duration() {
        return parseFloat(ANIMATION_DURATION.fast) * 1000;
    }
    /**
     * Threshold line in a chart to help determine which data points are either below or above a significant value
     * @since 10.11.0
     */
    set thresholdLine(value) {
        this._thresholdLine = isNumber(value) ? value : null;
        if (this.alreadyChanged) {
            this._updateThresholdLineArea();
        }
    }
    get thresholdLine() {
        return this._thresholdLine;
    }
    set legend(legend) {
        this._legend = Object.assign(this._legend, legend);
        if (this.alreadyChanged) {
            this.chartComponent.redrawChart();
        }
    }
    get legend() {
        return {
            customColors: this._legend.customColors,
            activeHover: this._legend.activeHover,
            activeClick: this._legend.activeClick,
            columns: this._legend.columns,
            width: this._legend.width,
            items: this.series.map((series) => ({ item: series.name, hidden: !!series.hidden }))
        };
    }
    set series(series) {
        this._series = series;
        this._isDeselected = [];
        series.forEach(s => {
            if (s.hidden) {
                this._isDeselected.push(s.name);
            }
        });
        // such transformation needed for proper display
        // of the slider for area graph
        this.sliderData = [...this.mapDataFromSeries(series)];
        if (this.alreadyChanged) {
            const options = this.chartComponent.getGroupAndDimensions();
            this._g = options.group;
            this._dim = {
                w: options.w,
                h: options.h
            };
        }
        if (this._g && this._dim && this.chartComponent) {
            this.chartComponent.updateLegend(this.series.map((item) => ({
                item: item.name,
                hidden: !!item.hidden,
                hover: false
            })));
        }
    }
    get series() {
        return this._series;
    }
    get leftShift() {
        return this._margin.left;
    }
    get chartWidth() {
        return this.chartComponent.currentSVGWidth;
    }
    ngOnInit() {
        if (this.scientificMode) {
            BigNumber.config({ EXPONENTIAL_AT: 4 });
        }
        this.alreadyChanged = true;
    }
    ngOnChanges(changes) {
        if (this._dim && (changes[this.nameof('showLineCircles')]
            || changes[this.nameof('supressAxles')]
            || changes[this.nameof('rotateXAxis')]
            || changes[this.nameof('showSlider')])) {
            this._detectViewChanges();
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    _dataBuilder(g, dim) {
        this._g = g;
        this._dim = dim;
        this._initClipPath();
        this._clear();
        this._initData();
        this._initAxis(g, dim);
        this._drawLines(g);
        this._drawDropShadow();
        this._updateThresholdLineArea();
    }
    _updateChart(dim, skipUpdateAxisX = false) {
        this._dim = dim; // after updating from toggling legend or create separate method for input
        this._initData();
        // update clipPath
        if (this._g) {
            this._g.select(`#${this._id}_clip > rect`)
                .attr('width', dim.w - (this._margin.left + this._margin.right))
                .attr('height', dim.h - (this._margin.top + this._margin.bottom));
        }
        if (!skipUpdateAxisX) {
            this._updateAxis(dim);
        }
        this._updateDataLines();
        this._updateThresholdLineArea();
    }
    isMobile() {
        return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
    }
    categoryShowHandler(category) {
        const index = this._isDeselected.indexOf(category);
        if (index !== -1) {
            this._isDeselected.splice(index, 1);
        }
        this._updateChart(this._dim, true);
        this.series.forEach((item, ind) => {
            if (item.name.indexOf(category) !== -1) {
                item.hidden = false;
                this._g
                    .select(`[data-line-graph-id='${ind}']`)
                    .style('display', 'block');
            }
        });
        if (!isUndefined(this.chartSliderComponent)) {
            this.chartSliderComponent.showCategory(category);
        }
        this.categoryShow.emit({ category });
    }
    categoryHideHandler(category) {
        this._isDeselected.push(category);
        this.series.forEach((item, index) => {
            if (item.name.indexOf(category) !== -1) {
                item.hidden = true;
                this._g
                    .select(`[data-line-graph-id='${index}']`)
                    .style('display', 'none');
            }
        });
        this._updateChart(this._dim, true);
        if (!isUndefined(this.chartSliderComponent)) {
            this.chartSliderComponent.hideCategory(category);
        }
        this.categoryHide.emit({ category });
    }
    categoryEnter(categoryEvent) {
        const ind = this._isDeselected.indexOf(this.series[categoryEvent.id].name);
        if (ind === -1) {
            const selectedGroup = this._g.select(`g[data-line-graph-id='${categoryEvent.id}']`);
            const selectedLine = selectedGroup.select('path');
            const linesWrapper = selectedGroup.node().parentNode;
            const colorLine = selectedLine.attr('stroke');
            this._highLightColor = colorLine;
            this._pathLines = linesWrapper.querySelectorAll('.line-chart-lines');
            this._pathLines.forEach(line => {
                const pathLineColor = line.getAttribute('stroke');
                if (pathLineColor === colorLine) {
                    line.setAttribute('stroke-width', '3');
                    this._pathLineCurrent = line;
                }
                else {
                    line.setAttribute('stroke-width', '1');
                }
            });
            if (this.showLineCircles) {
                const lineCirclesWrapper = this._g.select('.line-graph-circle-wrapper').node();
                const circles = lineCirclesWrapper.querySelectorAll('.line-graph-circle');
                circles.forEach(circle => {
                    if (circle.getAttribute('fill') !== colorLine) {
                        circle.setAttribute('r', '4');
                    }
                });
            }
        }
    }
    categoryLeave() {
        if (this._pathLineCurrent) {
            this._pathLineCurrent.setAttribute('stroke-width', '2');
        }
        if (this._pathLines) {
            this._pathLines.forEach(line => {
                line.classList.remove('line-graph-transition');
                line.setAttribute('stroke-width', '2');
            });
        }
        if (this.showLineCircles) {
            const lineCirclesWrapper = this._g.select('.line-graph-circle-wrapper').node();
            const circles = lineCirclesWrapper.querySelectorAll('.line-graph-circle');
            circles.forEach(circle => {
                if (circle.getAttribute('fill') !== this._highLightColor) {
                    circle.classList.remove('line-graph-transition');
                    circle.setAttribute('r', '6');
                }
            });
        }
    }
    getTooltipXValueTitle() {
        return this.xAxis ? this.xAxis.title : '';
    }
    rangeChanged(data) {
        this.sliderDomainData = data;
        // In case X axes text are rotated call update on the scroll end.
        // This is prevent incorrect text splitting on multiple lines
        if (!this.rotateXAxis) {
            this._updateXAxis(this._dim);
        }
        this._updateDataLines();
    }
    scrollEnd() {
        if (this.rotateXAxis) {
            this._updateXAxis(this._dim);
        }
    }
    getXAxisLineRenderer(dim) {
        return d3.axisBottom(this._x)
            .tickPadding(10)
            .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
            .tickSizeOuter(0);
    }
    getYPosFunc(dim, ticksVal) {
        return d3.scaleLinear()
            .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
            .domain([ticksVal[0], 0]);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getXPosFunc(dim, domain = []) {
        return d3.scalePoint()
            .range([0, dim.w - (this._margin.left + this._margin.right)])
            .domain(this.xAxis.categories);
    }
    _getCustomColorById(id) {
        const customColors = this.legend.customColors;
        const len = customColors.length;
        const index = id % len;
        return customColors[index];
    }
    _drawLines(g) {
        // TODO check if it can be refactored
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        this._gW = g.append('g')
            .attr('class', 'area-chart-data')
            .attr('transform', `translate(${this._margin.left}, 0)`);
        this._line = this.getLineRenderer();
        this._colors = [];
        this._data.forEach((dt, i) => {
            var _a;
            this._colors.push(((_a = this.legend.customColors) === null || _a === void 0 ? void 0 : _a.length) ? this._getCustomColorById(i) : this._colorService.getColor(i, this.colorsPalette));
            const lineWrapper = this._gW
                .append('g')
                .attr('class', 'line-chart-line-g')
                .attr('display', dt.hidden ? 'none' : 'block')
                .attr('id', this._colors[i])
                .attr('data-line-graph-id', i);
            this.drawLineForSeries(lineWrapper, dt, i);
            this.drawAreaForSeries(lineWrapper, dt, i);
            this.drawLineCircles(lineWrapper, i, dt)
                .on('mouseover', function (d) {
                /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                const circleEl = this;
                _self.onCircleMouseover(circleEl, dt, d);
            })
                .on('mouseout', function () {
                /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                const circleEl = this;
                _self.onCircleMouseout(circleEl);
            });
        });
        this.toggleLineCirclesVisibility(this._g, this.showLineCircles);
    }
    onCircleMouseout(circleEl) {
        const circleRadius = this.circleRadius;
        const circleParentLineEl = this.getCircleLine(circleEl);
        circleParentLineEl.attr('stroke-width', '2');
        const circleSelection = d3.select(circleEl);
        this._gW.selectAll('.line-chart-lines')
            .classed('line-graph-transition', false)
            .attr('stroke-width', '2');
        const baseColor = circleSelection.attr('fill-old');
        d3.selectAll('.line-graph-circle-wrapper .line-graph-circle').each(function () {
            if (d3.select(this).attr('fill') !== baseColor) {
                d3.select(this)
                    .classed('line-graph-transition', false)
                    .attr('r', circleRadius);
            }
        });
        circleSelection
            .attr('fill', baseColor)
            .style('filter', null)
            .attr('fill-old', null);
        this.chartComponent.hideTooltip();
    }
    onCircleMouseover(circleEl, dt, d) {
        const circleSelection = d3.select(circleEl);
        const circleParentLineSelection = this.getCircleLine(circleEl);
        const circleParentLineEl = circleParentLineSelection.node();
        const baseColor = circleSelection.attr('fill');
        circleSelection.attr('fill-old', baseColor);
        const colorHex = this.getCircleDarkenColor(baseColor, circleParentLineSelection);
        d3.selectAll('.line-chart-line-g').each(function () {
            if (d3.select(this).attr('data-id') === baseColor && this.nextElementSibling !== null) {
                this.parentNode.appendChild(this);
            }
        });
        this._gW.selectAll('.line-chart-lines').each(function () {
            if (circleParentLineEl === this) {
                d3.select(this).attr('stroke-width', '3');
            }
            else {
                d3.select(this).classed('line-graph-transition', true).attr('stroke-width', '1');
            }
        });
        d3.selectAll('.line-graph-circle-wrapper .line-graph-circle').each(function () {
            if (d3.select(this).attr('fill') !== baseColor) {
                d3.select(this).classed('line-graph-transition', true).attr('r', 4);
            }
        });
        this.showCircleTooltip(circleParentLineSelection.attr('stroke'), dt, d);
        circleSelection
            .attr('r', 8)
            .style('filter', 'url(#drop-shadow)')
            .attr('fill', colorHex);
    }
    showCircleTooltip(baseColor, dt, 
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    d) {
        this.chartComponent.showTooltip(d3.event.target, this.tooltip || this.tooltipTemplate, {
            data: this.getTooltipData(baseColor, dt, d)
        });
    }
    getTooltipData(baseColor, dt, 
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    d) {
        return {
            color: baseColor,
            category: dt.name,
            xValue: d.date,
            yValue: this.scientificMode ? new BigNumber(d.data) : d.data
        };
    }
    // TODO check if useless arg can be removed
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getCircleDarkenColor(baseColor, circleParentLineSelection) {
        return this._colorService.getDarken(baseColor, .15, ColorType.HEX);
    }
    drawLineCircles(lineWrapper, i, dt) {
        const circleSel = lineWrapper
            .append('g')
            .attr('class', 'line-graph-circle-wrapper')
            .attr('data-id', this._colors[i])
            .selectAll('dots')
            .data(this.getDataForCirclesOrLines(dt))
            .enter()
            .append('circle')
            .attr('r', this.circleRadius)
            .attr('class', 'line-graph-circle')
            .attr('fill', this.getCircleColor(i));
        return this.setCirclePosition(circleSel);
    }
    toggleLineCirclesVisibility(g, isShown) {
        if (g) {
            g.selectAll('.line-graph-circle-wrapper').style('display', isShown ? 'block' : 'none');
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getDataForCirclesOrLines(dt) {
        return dt.data;
    }
    setCirclePosition(
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    circleSel) {
        return circleSel
            .attr('cx', (d) => this._x(d.date))
            .attr('cy', (d) => this._y(d.data));
    }
    drawLineForSeries(lineWrapper, dt, i) {
        return lineWrapper
            .append('path')
            .datum(this.getDataForCirclesOrLines(dt))
            .attr('clip-path', `url(#${this._id}_clip)`)
            .attr('fill', 'none')
            .attr('class', 'line-chart-lines')
            .attr('stroke', this._colors[i])
            .attr('stroke-width', '2')
            .attr('d', this._line);
    }
    getCircleColor(i) {
        return this._colors[i];
    }
    // for overriding
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    drawAreaForSeries(lineWrapper, dt, i) {
        // Nothing to draw
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getLineRenderer() {
        return d3.line()
            .x((d) => this._x(d.date))
            .y((d) => this._y(d.data));
    }
    // for overriding
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    updateLinesAreas() {
    }
    // for overriding
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    restrictXPosTicks() {
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    mapDataFromSeries(series) {
        return series.map((item) => {
            const data = item.data.map((tt, index) => {
                return {
                    date: this.xAxis.categories[index],
                    data: tt
                };
            });
            return {
                name: item.name,
                hidden: item.hidden,
                data
            };
        });
    }
    getDataYValues(row) {
        return row.data.map((item) => item.data);
    }
    nameof(key) {
        return nameof(key);
    }
    _detectViewChanges() {
        this._updateChart(this._dim); // Update chart data
        SafeCdr.detectChanges(this._changeDetectorRef);
        this._ngZone.onStable
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(() => {
            this._ngZone.run(() => {
                this.chartComponent.redrawChart(); // Redraw chart using the latest dimensions
                SafeCdr.detectChanges(this._changeDetectorRef);
            });
        });
    }
    _initAxis(g, dim) {
        const axisWidth = dim.w - this._margin.left - this._margin.right;
        const ticks = this._getTicks().reverse();
        if (this.yAxis && this.yAxis.title) {
            g.append('g')
                .attr('class', 'adapt-chart-axis-title')
                .attr('transform', `rotate(-90) translate(-${(dim.h - this._axisShift.bottom) / 2} ${this._axisShift.left / 2})`)
                .style('opacity', this.supressAxles ? 0 : 1)
                .append('text').text(this.yAxis.title)
                .attr('text-anchor', 'middle')
                .attr('transform', `translate(${(this._axisShift.bottom / 2)} 0)`);
        }
        if (this.xAxis && this.xAxis.title) {
            g.append('g')
                .attr('class', 'adapt-chart-axis-title adapt-chart-axis-title--x')
                .attr('transform', `translate(${(dim.w + this._axisShift.left) / 2} ${dim.h + this.chartComponent.chartBottomPadding})`)
                .style('opacity', this.supressAxles ? 0 : 1)
                .append('text').text(this.xAxis.title)
                .attr('text-anchor', 'middle')
                .attr('transform', `translate(${(this._axisShift.left)} 0)`);
        }
        if (this.xAxis && this.xAxis.categories) {
            this._x = this.xBrush = this.getXPosFunc(dim);
            this.restrictXPosTicks();
        }
        const axisBlock = g.append('g').attr('class', 'axis axis--x');
        this.renderXAxis(dim, axisBlock);
        if (this.rotateXAxis) {
            this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
            this.chartComponent.updateChartBottomPadding(axisWidth, g, this.xAxis, this.rotateXAxis);
        }
        const ticksOrCategs = isUndefined(this.yAxis.categories) ? ticks : this.yAxis.categories.reverse();
        // TODO: can be y axis categories?
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._y = this.getYPosFunc(dim, ticksOrCategs);
        this.renderYAxis(g.append('g').attr('class', 'axis axis--y'), ticksOrCategs, dim);
    }
    renderYAxis(g, ticksVal, dim) {
        g.attr('transform', `translate(${this._margin.left}, 0)`)
            .style('opacity', this.supressAxles ? 0 : 1)
            .call(this.getYAxisRenderer(ticksVal, dim));
    }
    getYAxisRenderer(ticksVal, dim) {
        return d3.axisLeft(this._y)
            .ticks(ticksVal)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .tickValues(ticksVal)
            .tickFormat((d) => {
            if (this.scientificMode) {
                return new BigNumber(d).toPrecision(2, 2);
            }
            else {
                return this._cutNumber.transform(d, 0);
            }
        })
            .tickSize(-dim.w + (this._margin.left + this._margin.right))
            .tickPadding(3);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    renderXAxis(dim, el) {
        el.attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`)
            .style('opacity', this.supressAxles ? 0 : 1)
            .call(
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.getXAxisLineRenderer(dim));
    }
    _updateXAxis(dim) {
        this._x = this.getXPosFunc(dim, this.showSlider && this.slidePointsCount ? this.sliderDomainData : []);
        if (this._g) {
            const axisBlock = this._g.select('.axis--x');
            axisBlock.attr('class', `axis axis--x ${this.rotateXAxis ? 'adapt-chart-axis__hidden' : ''}`);
            this.renderXAxis(dim, axisBlock);
            this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
            this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
            axisBlock.classed('adapt-chart-axis__hidden', null);
            this._g.select('.adapt-chart-axis-title--x')
                .transition()
                .duration(this.duration)
                .attr('transform', `translate(${(dim.w + this._axisShift.left) / 2} ${dim.h + this.chartComponent.chartBottomPadding})`);
            this._g.selectAll('.adapt-chart-axis-title')
                .style('opacity', this.supressAxles ? 0 : 1);
        }
    }
    _updateYAxis(dim) {
        const ticks = this._getTicks().reverse();
        const ticksOrCategs = isUndefined(this.yAxis.categories) ? ticks : this.yAxis.categories.reverse();
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._y = this.getYPosFunc(dim, ticksOrCategs);
        if (this._g) {
            this._g.select('.axis--y')
                .attr('transform', `translate(${this._margin.left}, 0)`)
                .transition()
                .duration(this.duration)
                .call(
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this.getYAxisRenderer(ticksOrCategs, dim));
            this.renderYAxis(this._g.select('.axis--y')
                .transition()
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .duration(this.duration), ticksOrCategs, dim);
        }
    }
    _updateAxis(dim) {
        this._updateXAxis(dim);
        this._updateYAxis(dim);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getCircleLine(el) {
        return d3
            .select(el.closest('.line-chart-line-g'))
            .select('.line-chart-lines');
    }
    _updateDataLines() {
        this._line = this.getLineRenderer();
        if (this._g) {
            this._g.selectAll('.line-chart-lines').attr('d', this._line);
            this._g.selectAll('.line-graph-circle').each((d, i, g) => {
                this.setCirclePosition(d3.select(g[i]));
            });
        }
        this.toggleLineCirclesVisibility(this._g, this.showLineCircles);
        this.updateLinesAreas();
    }
    _initData() {
        this._data = this.mapDataFromSeries(this.series);
    }
    _getTicks() {
        let data = [];
        this._data.forEach(row => {
            data = data.concat(this.getDataYValues(row));
        });
        let max = Math.max(...data);
        if (max === 0) {
            max = 1;
        }
        if (this.thresholdLine && this.thresholdLine > max) {
            max = this.thresholdLine;
        }
        let currentStep = Math.pow(10, Math.floor(Math.log10(max))) / 2;
        const step = Math.pow(10, Math.floor(Math.log10(max))) / 2;
        let count = Math.floor(max / currentStep) + 1;
        while (count >= this._maxTicksCount) {
            currentStep += step;
            count = Math.floor(max / currentStep) + 1;
        }
        return (new Array(count)).fill(0).map((v, id) => (id + 1) * currentStep);
    }
    _initClipPath() {
        // Add a clipPath: we restrict lines appearing by explicitly setting width and height - everything out of this area won't be drawn
        // useful for the situation once we show the graph slider
        this._g.append('defs').append('svg:clipPath')
            .attr('id', `${this._id}_clip`)
            .append('svg:rect')
            .attr('width', this._dim.w - (this._margin.left + this._margin.right))
            .attr('height', this._dim.h - (this._margin.top + this._margin.bottom))
            .attr('x', 0)
            .attr('y', 0);
    }
    _clear() {
        this._data = [];
    }
    _updateThresholdLineArea() {
        const thresholdLineAreaClass = 'threshold-line-area';
        let thresholdLineArea;
        if (this._g) {
            thresholdLineArea = this._g.select(`.${thresholdLineAreaClass}`);
        }
        if (!this.thresholdLine && thresholdLineArea) {
            thresholdLineArea.remove();
            return;
        }
        if (thresholdLineArea === null || thresholdLineArea === void 0 ? void 0 : thresholdLineArea.empty()) {
            thresholdLineArea = this._g.append('g')
                .attr('class', thresholdLineAreaClass);
            thresholdLineArea.append('rect')
                .attr('class', 'threshold-area-rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('fill', '#000000')
                .attr('style', 'pointer-events: none; opacity: .1;');
            const defs = thresholdLineArea.append('defs');
            defs.append('marker')
                .attr('class', 'threshold-line-marker')
                .attr('id', `${this._id}-marker-start`)
                .attr('viewBox', '0 0 6 8')
                .attr('markerWidth', 6)
                .attr('markerHeight', 8)
                .attr('refX', 5)
                .attr('refY', 4)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 6 4 L 0 8 z');
            defs.append('marker')
                .attr('class', 'threshold-line-marker')
                .attr('id', `${this._id}-marker-end`)
                .attr('viewBox', '0 0 6 8')
                .attr('markerWidth', 6)
                .attr('markerHeight', 8)
                .attr('refX', 1)
                .attr('refY', 4)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 4 L 6 0 L 6 8 z');
            thresholdLineArea.append('line')
                .attr('class', 'threshold-line')
                .attr('stroke-width', 1)
                .attr('marker-start', `url(#${this._id}-marker-start)`)
                .attr('marker-end', `url(#${this._id}-marker-end)`);
            thresholdLineArea.append('text')
                .attr('class', 'threshold-line-title-background');
            thresholdLineArea.append('text')
                .attr('class', 'threshold-line-title');
        }
        const maxTick = this._getTicks().pop(); // get the max tick
        const chartDataAreaWidth = this._dim.w - this._margin.left - this._margin.right;
        const chartDataAreaHeight = this._dim.h - this._margin.top - this._margin.bottom;
        const thresholdLineAreaHeight = chartDataAreaHeight - chartDataAreaHeight / maxTick * this.thresholdLine;
        if (thresholdLineArea) {
            thresholdLineArea.select('rect.threshold-area-rect')
                .transition()
                .duration(this.duration)
                .attr('transform', `translate(${this._margin.left}, 0)`)
                .attr('width', chartDataAreaWidth)
                .attr('height', thresholdLineAreaHeight);
            thresholdLineArea.select('line.threshold-line')
                .transition()
                .duration(this.duration)
                .attr('x1', this._margin.left)
                .attr('x2', this._dim.w)
                .attr('y1', thresholdLineAreaHeight)
                .attr('y2', thresholdLineAreaHeight);
            thresholdLineArea.select('text.threshold-line-title-background')
                .transition()
                .duration(this.duration)
                .attr('x', this._margin.left - 8)
                .attr('y', thresholdLineAreaHeight)
                .attr('text-anchor', 'end')
                .attr('dy', '.32em')
                .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
            thresholdLineArea.select('text.threshold-line-title')
                .transition()
                .duration(this.duration)
                .attr('x', this._margin.left - 8)
                .attr('y', thresholdLineAreaHeight)
                .attr('text-anchor', 'end')
                .attr('dy', '.32em')
                .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
        }
        // If we have the same tick as the thresholdLine - remove that
        d3.selectAll('g.tick')
            .filter(d => d === this.thresholdLine)
            .remove();
    }
    _drawDropShadow() {
        const defs = this._g
            .append('defs');
        const filter = defs.append('filter')
            .attr('id', 'drop-shadow')
            .attr('x', '-50%')
            .attr('y', '-50%')
            .attr('width', '180%')
            .attr('height', '180%')
            .attr('filterUnits', 'userSpaceOnUse');
        filter
            .append('feGaussianBlur')
            .attr('in', 'SourceAlpha')
            .attr('stdDeviation', 3);
        filter
            .append('feOffset')
            .attr('dx', 0)
            .attr('dy', 1)
            .attr('result', 'offsetBlur');
        filter
            .append('feOffset')
            .attr('dx', 0)
            .attr('dy', 2)
            .attr('result', 'offsetBlur');
        filter
            .append('feColorMatrix')
            .attr('type', 'matrix')
            .attr('values', '0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.22 0');
        const feMerge = filter
            .append('feMerge');
        feMerge
            .append('feMergeNode');
        feMerge
            .append('feMergeNode')
            .attr('in', 'SourceGraphic');
        feMerge
            .append('feMergeNode')
            .attr('in', 'SourceGraphic');
    }
}
AdaptLineGraphComponent.ɵfac = function AdaptLineGraphComponent_Factory(t) { return new (t || AdaptLineGraphComponent)(i0.ɵɵdirectiveInject(i1.CutNumberPipe), i0.ɵɵdirectiveInject(i2.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i3.ChartColorService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptLineGraphComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptLineGraphComponent, selectors: [["adapt-line-graph"]], viewQuery: function AdaptLineGraphComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(AdaptAreaGraphSliderComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartSliderComponent = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", colorsPalette: "colorsPalette", supressAxles: "supressAxles", noDataText: "noDataText", xAxis: "xAxis", yAxis: "yAxis", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", updateChart: "updateChart", showLineCircles: "showLineCircles", rotateXAxis: "rotateXAxis", showSlider: "showSlider", slidePointsCount: "slidePointsCount", disallowPadding: "disallowPadding", scientificMode: "scientificMode", thresholdLine: "thresholdLine", legend: "legend", series: "series" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵProvidersFeature([CutNumberPipe]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 8, vars: 14, consts: [[3, "width", "height", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "header", "noDataText", "updateChart", "dataBuilder", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd", 4, "ngIf"], ["tooltipTpl", ""], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd"], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptLineGraphComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "adapt-chart", 0);
        i0.ɵɵlistener("categoryShow", function AdaptLineGraphComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptLineGraphComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptLineGraphComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptLineGraphComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵtemplate(2, AdaptLineGraphComponent_adapt_area_graph_slider_2_Template, 1, 7, "adapt-area-graph-slider", 1);
        i0.ɵɵtext(3, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(4, "\n\n");
        i0.ɵɵtemplate(5, AdaptLineGraphComponent_ng_template_5_Template, 26, 7, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("width", ctx.width)("height", ctx.height)("legend", ctx.legend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("header", ctx.header)("noDataText", ctx.noDataText)("updateChart", ctx._updateChartBind)("dataBuilder", ctx._dataBuilderBind)("colorsPalette", ctx.colorsPalette);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.showSlider && ctx.slidePointsCount && ctx.chartWidth);
    } }, directives: [i4.AdaptChartComponent, i5.NgIf, i6.AdaptAreaGraphSliderComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptLineGraphComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-line-graph',
                templateUrl: './line-graph.component.html',
                providers: [CutNumberPipe],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.CutNumberPipe }, { type: i2.AdaptDeviceDetectionService }, { type: i3.ChartColorService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, { tooltipTemplate: [{
            type: ViewChild,
            args: ['tooltipTpl', { static: true }]
        }], chartComponent: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], chartSliderComponent: [{
            type: ViewChild,
            args: [AdaptAreaGraphSliderComponent, { static: false }]
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], colorsPalette: [{
            type: Input
        }], supressAxles: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], updateChart: [{
            type: Input
        }], showLineCircles: [{
            type: Input
        }], rotateXAxis: [{
            type: Input
        }], showSlider: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }], disallowPadding: [{
            type: Input
        }], scientificMode: [{
            type: Input
        }], thresholdLine: [{
            type: Input
        }], legend: [{
            type: Input
        }], series: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }] }); })();
//# sourceMappingURL=line-graph.component.js.map