import { ChangeDetectorRef, Component, EventEmitter, Input, Output, Renderer2, ViewChild } from '@angular/core';
import * as d3 from 'd3';
import { AdaptDropdownDirective, AdaptDropdownToggleDirective, AdaptIconConfig, SafeCdr } from '@bmc-ux/adapt-angular';
import { ai_ellipsis } from '@bmc-ux/dpl-iconfont';
import { AdaptChartComponent } from '../common/chart.component';
import { AdaptHeatmapAbstract } from '../common/models/heatmap.model';
import * as i0 from "@angular/core";
import * as i1 from "@bmc-ux/adapt-angular";
import * as i2 from "../common/chart.component";
import * as i3 from "@angular/common";
const _c0 = ["heatmapDefaultTooltip"];
const _c1 = ["menuAnchor"];
const _c2 = ["menuContainer"];
function AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 12);
    i0.ɵɵlistener("click", function AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r11); const action_r9 = restoredCtx.$implicit; const ctx_r10 = i0.ɵɵnextContext(4); return ctx_r10.callAction(ctx_r10.menuData.target, ctx_r10.menuData.event, ctx_r10.menuData.context, action_r9); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r9 = ctx.$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n              ", action_r9.title, "\n            ");
} }
function AdaptHeatmapComponent_div_4_ng_template_6_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template, 2, 1, "button", 11);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r7.menuData.actions);
} }
function AdaptHeatmapComponent_div_4_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelementStart(1, "div", 9);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵtemplate(3, AdaptHeatmapComponent_div_4_ng_template_6_div_3_Template, 4, 1, "div", 10);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n      ");
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r6.menuData && ctx_r6.menuData.actions && ctx_r6.menuData.actions.length);
} }
function AdaptHeatmapComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r13 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 4, 5);
    i0.ɵɵlistener("popupAnimationDone", function AdaptHeatmapComponent_div_4_Template_div_popupAnimationDone_0_listener() { i0.ɵɵrestoreView(_r13); const ctx_r12 = i0.ɵɵnextContext(); return ctx_r12.popupAnimationDone(); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵelement(3, "button", 6, 7);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵtemplate(6, AdaptHeatmapComponent_div_4_ng_template_6_Template, 6, 1, "ng-template", 8);
    i0.ɵɵtext(7, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true);
} }
function AdaptHeatmapComponent_ng_template_6_adapt_icon_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-icon", 18);
} if (rf & 2) {
    const c_r14 = i0.ɵɵnextContext().context;
    const ctx_r15 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("color", c_r14.status.iconColor || c_r14.status.color || ctx_r15.defaultColor);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("name", c_r14.status.icon);
} }
function AdaptHeatmapComponent_ng_template_6_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "small", 19);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const c_r14 = i0.ɵɵnextContext().context;
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(c_r14.info);
} }
function AdaptHeatmapComponent_ng_template_6_div_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "label", 20);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "div", 21);
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelement(7, "div", 22);
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const c_r14 = i0.ɵɵnextContext().context;
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("margin-left", c_r14.progress + "%");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", c_r14.progress, "%");
    i0.ɵɵadvance(4);
    i0.ɵɵstyleProp("width", c_r14.progress + "%");
    i0.ɵɵattribute("aria-valuenow", c_r14.progress);
} }
function AdaptHeatmapComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 13);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "div");
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵtemplate(5, AdaptHeatmapComponent_ng_template_6_adapt_icon_5_Template, 1, 4, "adapt-icon", 14);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵtemplate(8, AdaptHeatmapComponent_ng_template_6_div_8_Template, 5, 1, "div", 15);
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵtemplate(10, AdaptHeatmapComponent_ng_template_6_div_10_Template, 10, 6, "div", 15);
    i0.ɵɵtext(11, "\n        ");
    i0.ɵɵelementStart(12, "div", 16);
    i0.ɵɵtext(13, "\n          ");
    i0.ɵɵelement(14, "div", 17);
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n    ");
} if (rf & 2) {
    const c_r14 = ctx.context;
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", c_r14.status.icon);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", c_r14.name, "\n        ");
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", c_r14.info);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", c_r14.progress);
    i0.ɵɵadvance(4);
    i0.ɵɵstyleProp("background-color", c_r14.status.bg);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", c_r14.status.name, "\n        ");
} }
const ICON_HEIGHT = 14;
const LINE_HEIGHT = 18;
const NODE_PADDING = 15;
// TODO update types
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export class AdaptHeatmapComponent extends AdaptHeatmapAbstract {
    constructor(_changeDetectorRef, _renderer, _iconConfig) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this._iconConfig = _iconConfig;
        this.hasActionMenu = false;
        this.defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--gray-900');
        // Chart data builder
        this._dataBuilder = (function (g, dim) {
            this._g = g;
            this._calculateMargin();
            const chartWidth = dim.w - (this._margin.left + this._margin.right);
            const chartHeight = dim.h - (this._margin.top + this._margin.bottom);
            const openTooltip = this._openTooltip.bind(this);
            const closeTooltip = this._closeTooltip.bind(this);
            const openMenu = this._openMenu.bind(this);
            const margin = this._margin;
            const ellipsis = this._ellipsis;
            const clickChart = this.clickChart;
            const _data = this._getPreparedData(chartWidth, chartHeight);
            const _getIcon = (name) => this._iconConfig.getIcon(name);
            // Draw chart
            const nodeGroup = this._g.selectAll('g')
                .attr('transform', `translate(${margin.left} ${margin.top})`)
                .data(_data)
                .enter()
                .append('g')
                .attr('class', (d) => `heatmap-node status-group-${d.data.status.name.split(' ').join('_').toLowerCase()}`)
                .attr('id', (d) => d.data.name.split(' ').join('_'))
                .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`)
                .on('mouseenter', function (d) {
                const eventDetail = d3.event.detail;
                const self = d3.select(this);
                if (eventDetail === 0 || (eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.eventSource) !== 'legend') {
                    openTooltip(self.node(), { context: d.data });
                }
                d3.select(this)
                    .selectAll('rect')
                    .each(function () {
                    const _r = d3.select(this).node();
                    if (!_r.classList.contains('menu-icon')) {
                        _r.style.fill = d3.rgb(_r.style.fill).darker(.3).formatHex();
                    }
                });
            })
                .on('mouseleave', function () {
                closeTooltip();
                d3.select(this)
                    .selectAll('rect')
                    .each(function () {
                    const _r = d3.select(this).node();
                    if (!_r.classList.contains('menu-icon')) {
                        _r.style.fill = d3.rgb(_r.style.fill).brighter(.3).formatHex();
                    }
                });
            })
                .on('click', function (d) {
                closeTooltip();
                clickChart.emit(d.data);
                d3.event.stopPropagation();
            });
            nodeGroup.append('g')
                .attr('class', 'treemap-node-bg')
                .each(function (d) {
                const _node = d3.select(this);
                _node.append('rect')
                    .attr('width', d.x1 - d.x0)
                    .attr('height', d.y1 - d.y0)
                    .attr('style', () => {
                    return `
              fill: ${d.data.status.bg};
              opacity: .6;
              transition: fill .2s;
              cursor: pointer;`;
                });
                _node.append('rect')
                    .attr('width', () => {
                    const c = d.data.progress ? d.data.progress / 100 : 1;
                    return (d.x1 - d.x0) * c;
                })
                    .attr('height', d.y1 - d.y0)
                    .attr('style', () => {
                    return `
              fill: ${d.data.status.bg};
              transition: fill .2s;
              cursor: pointer;`;
                });
            });
            const _defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--gray-900');
            nodeGroup.append('g')
                .attr('class', 'treemap-node-text')
                .each(function (d) {
                const _node = d3.select(this);
                let _icon;
                let _info;
                if (d.data.status.icon && (d.y1 - d.y0 > 60)) {
                    _icon = _node.append('g')
                        .attr('transform', `translate(${(d.x1 - d.x0) / 2 - ICON_HEIGHT / 2}, 0)`)
                        .html(_getIcon(d.data.status.icon))
                        .select('svg')
                        .attr('width', ICON_HEIGHT)
                        .attr('height', ICON_HEIGHT)
                        .attr('fill', d.data.status.iconColor || d.data.status.color || _defaultColor);
                }
                const _name = _node.append('text')
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2}, 0)`)
                    .attr('dy', _icon ? LINE_HEIGHT + ICON_HEIGHT : 0)
                    .attr('text-anchor', 'middle')
                    .attr('fill', d.data.status.color || _defaultColor)
                    .attr('style', 'font-size: 13px;');
                ellipsis(_name, d.data.name, d.x1 - d.x0 - NODE_PADDING);
                if (_icon) {
                    _node.attr('transform', `translate(0, ${(d.y1 - d.y0) / 2 - ICON_HEIGHT})`);
                }
                else {
                    _node.attr('transform', `translate(0, ${(d.y1 - d.y0) / 2 + LINE_HEIGHT / 2})`);
                }
                if (d.data.info && (d.y1 - d.y0 > 40)) {
                    _info = _node.append('text')
                        .attr('transform', `translate(${(d.x1 - d.x0) / 2}, 0)`)
                        .attr('dy', _icon ? LINE_HEIGHT * 2 + ICON_HEIGHT : LINE_HEIGHT)
                        .attr('text-anchor', 'middle')
                        .attr('fill', d.data.status.color || _defaultColor)
                        .attr('style', 'font-size: 12px; opacity: .7');
                    ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING);
                    if (_icon) {
                        _node.attr('transform', `translate(0, ${(d.y1 - d.y0) / 2 - ICON_HEIGHT - LINE_HEIGHT / 2})`);
                    }
                    else {
                        _node.attr('transform', `translate(0, ${(d.y1 - d.y0) / 2})`);
                    }
                }
            });
            // Draw kebab menu icon
            nodeGroup
                .append('g')
                .attr('class', 'heatmap__actions-menu')
                .each(function (d) {
                if (d.data.actions) {
                    const _node = d3.select(this);
                    _node.append('rect')
                        .attr('class', 'menu-icon')
                        .attr('cursor', 'pointer')
                        .attr('fill', 'transparent')
                        .attr('height', 20)
                        .attr('width', 20)
                        .attr('transform', `translate(${(d.x1 - d.x0) - 24}, 10)`);
                    _node.append('g')
                        .attr('transform', `translate(${(d.x1 - d.x0) - 24}, 10)`)
                        .html(ai_ellipsis.data)
                        .select('svg')
                        .attr('cursor', 'pointer')
                        .attr('fill', _defaultColor)
                        .attr('height', 20)
                        .attr('width', 20);
                }
            })
                .on('click', function (d) {
                if (d.data.actions) {
                    const self = d3.select(this);
                    openMenu(self.node(), d3.event, d.data);
                    d3.event.stopPropagation();
                }
            });
            // Draw Axises
            if (this.xAxis) {
                const axisScaleX = d3
                    .scaleBand()
                    .domain(this.xAxis.categories)
                    .range([0, chartWidth]);
                const xAxis = d3.axisBottom(axisScaleX)
                    .tickSizeOuter(0)
                    .tickSize(0)
                    .tickPadding(10);
                this._g.append('g')
                    .attr('class', 'adapt-chart-axis xAxis')
                    .attr('transform', `translate(${margin.left}, ${chartHeight})`)
                    .call(xAxis);
            }
            if (this.yAxis) {
                const axisScaleY = d3
                    .scaleBand()
                    .domain(this.yAxis.categories)
                    .range([0, chartHeight]);
                const yAxis = d3
                    .axisLeft(axisScaleY)
                    .tickSizeOuter(0)
                    .tickSize(0)
                    .tickPadding(10);
                this._g.append('g')
                    .attr('class', 'adapt-chart-axis')
                    .attr('transform', `translate(${margin.left}, 0)`)
                    .call(yAxis);
            }
            SafeCdr.detectChanges(this._changeDetectorRef);
        }).bind(this);
        // Chart update function
        this._updateChart = (function (dim) {
            this._calculateMargin();
            const chartWidth = dim.w - (this._margin.left + this._margin.right);
            const chartHeight = dim.h - (this._margin.top + this._margin.bottom);
            const _data = this._getPreparedData(chartWidth, chartHeight);
            this._g.selectAll('g.heatmap-node')
                .data(_data)
                .transition()
                .duration(200)
                .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`);
            this._g.selectAll('g.treemap-node-bg rect:first-child')
                .data(_data)
                .transition()
                .duration(200)
                .attr('width', (d) => d.x1 - d.x0);
            this._g.selectAll('g.treemap-node-bg rect:last-child')
                .data(_data)
                .transition()
                .duration(200)
                .attr('width', (d) => {
                const c = d.data.progress ? d.data.progress / 100 : 1;
                return (d.x1 - d.x0) * c;
            });
            this._g.selectAll('g.heatmap__actions-menu rect')
                .data(_data.filter((d) => d.data.actions))
                .transition()
                .duration(200)
                .attr('transform', (d) => `translate(${(d.x1 - d.x0) - 24}, 10)`);
            this._g.selectAll('g.heatmap__actions-menu use')
                .data(_data.filter((d) => d.data.actions))
                .transition()
                .duration(200)
                .attr('transform', (d) => `translate(${(d.x1 - d.x0) - 24}, 10)`);
            this._g.selectAll('.treemap-node-text')
                .data(_data)
                .each(function (d) {
                d3.select(this).select('use')
                    .transition()
                    .duration(200)
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2 - ICON_HEIGHT / 2}, 0)`);
                d3.select(this).selectAll('text')
                    .transition()
                    .duration(200)
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2}, 0)`);
            });
            if (this.xAxis) {
                const axisScaleX = d3
                    .scaleBand()
                    .domain(this.xAxis.categories)
                    .range([0, chartWidth]);
                const xAxis = d3.axisBottom(axisScaleX)
                    .tickSizeOuter(0)
                    .tickSize(0)
                    .tickPadding(10);
                this._g.select('g.adapt-chart-axis.xAxis')
                    .transition()
                    .duration(200)
                    .call(xAxis);
            }
        }).bind(this);
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.clickChart = new EventEmitter();
        this._margin = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        };
        this._closeMenuBind = this._closeMenu.bind(this);
    }
    ngOnInit() {
        if (this.legend) {
            this.legend.columns = 1;
            this.legend.activeHover = false;
            this.legend.activeClick = false;
        }
        this._initLegend();
    }
    ngOnDestroy() {
        this._removeListeners();
    }
    callAction(target, event, context, action) {
        action.callback(target, event, context);
    }
    popupAnimationDone() {
        if (this.menuContainer.isOpen()) {
            this._removeClickEventListener = this._renderer.listen('document', 'click', this._closeMenuBind);
            this._removeScrollEventListener = this._renderer.listen('document', 'scroll', this._closeMenuBind);
        }
        else {
            this._removeListeners();
        }
    }
    _categoryEnter(categoryEvent) {
        // Pass "detail" via custom params to not show the tooltip when items highlighted through legend items hover
        this._g
            .selectAll(`.status-group-${this._legend.items[categoryEvent.id.toString()].split(' ').join('_').toLowerCase()}`)
            .dispatch('mouseenter', { bubbles: true, cancelable: true, detail: { eventSource: 'legend' } });
    }
    _categoryLeave(categoryEvent) {
        this._g
            .selectAll(`.status-group-${this._legend.items[categoryEvent.id.toString()].split(' ').join('_').toLowerCase()}`)
            .dispatch('mouseleave');
    }
    _calculateMargin() {
        this._margin.left = this.yAxis ? 60 : 0;
        this._margin.bottom = this.xAxis ? 38 : 0;
    }
    _getPreparedData(w, h) {
        const padding = 1;
        const chartWidth = Math.round(w);
        const rowCount = this.data.items.length;
        const rowHeight = Math.round(h / rowCount);
        const chartGrid = [];
        this.data.items.forEach((row, rIndex) => {
            let rowWidth = 0;
            row.forEach((el) => {
                rowWidth += el.size;
            });
            let colWidth = this._margin.left + 1;
            const colWidthMultiplier = chartWidth / rowWidth;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            row.forEach((col) => {
                chartGrid.push({
                    data: col,
                    x0: Math.round(colWidth),
                    y0: Math.round(this._margin.top + rowHeight * rIndex),
                    x1: Math.round(colWidth + colWidthMultiplier * col.size - padding),
                    y1: Math.round(this._margin.top + rowHeight * rIndex + rowHeight - padding)
                });
                colWidth += colWidthMultiplier * col.size;
            });
        });
        // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
        this.hasActionMenu = chartGrid.some(item => item.data.actions && item.data.actions.length);
        return chartGrid;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _openMenu(target, event, context) {
        this._closeTooltip();
        this.menuContainer.placement = 'bottom-right';
        this.menuContainer.positionTo = target;
        this.menuData = { target, event, context, actions: context.actions };
        this.menuAnchor.toggleOpen(event);
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    _closeMenu() {
        if (this.menuContainer) {
            this.menuContainer.close();
        }
        this._removeListeners();
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _openTooltip(target, context) {
        this.chartBase.showTooltip(target, this.tooltip || this.heatmapDefaultTooltip, context);
    }
    _closeTooltip() {
        this.chartBase.hideTooltip();
    }
    _initLegend() {
        if (this.suppressLegend) {
            return;
        }
        const legendItems = [];
        this.data.items.forEach((row) => {
            row.forEach((col) => {
                if (col.status) {
                    const sameStatuses = legendItems.filter((lItem) => {
                        return col.status.name === lItem.name;
                    });
                    if (!sameStatuses.length) {
                        legendItems.push({ name: col.status.name, color: col.status.bg });
                    }
                }
            });
        });
        if (legendItems.length) {
            this._legend = {
                columns: 1,
                items: legendItems.map(el => el.name),
                customColors: legendItems.map(el => el.color),
                activeHover: false,
                activeClick: false
            };
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _ellipsis(textNode, text, ellipsisWidth) {
        const letters = text.split('');
        const ellipsis = textNode.append('tspan').attr('class', 'ellipsis').text('...');
        const width = ellipsisWidth - ellipsis.node().getComputedTextLength();
        const numWords = letters.length;
        const tspan = textNode.insert('tspan', ':first-child').text(letters.join(''));
        // Try the whole line
        // While it's too long, and we have words left, keep removing words
        while (tspan.node().getComputedTextLength() > width && letters.length) {
            letters.pop();
            tspan.text(letters.join(''));
        }
        if (letters.length === numWords) {
            ellipsis.remove();
        }
    }
    _removeListeners() {
        if (this._removeClickEventListener) {
            this._removeClickEventListener();
            this._removeClickEventListener = null;
        }
        if (this._removeScrollEventListener) {
            this._removeScrollEventListener();
            this._removeScrollEventListener = null;
        }
    }
}
AdaptHeatmapComponent.ɵfac = function AdaptHeatmapComponent_Factory(t) { return new (t || AdaptHeatmapComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptIconConfig)); };
AdaptHeatmapComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptHeatmapComponent, selectors: [["adapt-heatmap"]], viewQuery: function AdaptHeatmapComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 5, AdaptDropdownToggleDirective);
        i0.ɵɵviewQuery(_c2, 5, AdaptDropdownDirective);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartBase = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.heatmapDefaultTooltip = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuAnchor = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuContainer = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", data: "data", xAxis: "xAxis", yAxis: "yAxis", noDataText: "noDataText" }, outputs: { clickChart: "clickChart" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 9, vars: 13, consts: [[3, "data", "width", "height", "header", "legend", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "dataBuilder", "updateChart", "noDataText", "categoryEnter", "categoryLeave"], ["chartBase", ""], ["class", "dropdown heatmap-chart_hidden-menu", "adaptDropdown", "", 3, "adaptRadarDisableEventSending", "appendToBody", "popupAnimationDone", 4, "ngIf"], ["heatmapDefaultTooltip", ""], ["adaptDropdown", "", 1, "dropdown", "heatmap-chart_hidden-menu", 3, "adaptRadarDisableEventSending", "appendToBody", "popupAnimationDone"], ["menuContainer", ""], ["adaptDropdownToggle", "", "type", "button"], ["menuAnchor", ""], ["adaptDropdownMenuTemplate", ""], [1, "dropdown-menu"], [4, "ngIf"], ["class", "dropdown-item", "type", "button", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "dropdown-item", 3, "click"], [1, "text-left"], ["class", "icon-inline", 3, "adaptRadarDisableEventSending", "name", "color", 4, "ngIf"], ["class", "pt-2", 4, "ngIf"], [1, "pt-2"], [2, "width", "8px", "height", "8px", "margin", "0 4px 1px 2px", "display", "inline-block", "vertical-align", "middle"], [1, "icon-inline", 3, "adaptRadarDisableEventSending", "name"], [1, "text-secondary"], [1, "progress-label"], [1, "progress"], ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", 1, "progress-bar", "bg-primary-muted"]], template: function AdaptHeatmapComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "adapt-chart", 0, 1);
        i0.ɵɵlistener("categoryEnter", function AdaptHeatmapComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx._categoryEnter($event); })("categoryLeave", function AdaptHeatmapComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx._categoryLeave($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(3, "\n\n    ");
        i0.ɵɵtemplate(4, AdaptHeatmapComponent_div_4_Template, 8, 2, "div", 2);
        i0.ɵɵtext(5, "\n\n    ");
        i0.ɵɵtemplate(6, AdaptHeatmapComponent_ng_template_6_Template, 18, 7, "ng-template", null, 3, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(8, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("data", ctx.data)("width", ctx.width)("height", ctx.height)("header", ctx.header)("legend", ctx._legend)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("dataBuilder", ctx._dataBuilder)("updateChart", ctx._updateChart)("noDataText", ctx.noDataText);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.hasActionMenu);
    } }, directives: [i2.AdaptChartComponent, i3.NgIf, i1.AdaptDropdownDirective, i1.AdaptDropdownToggleDirective, i1.AdaptDropdownMenuTemplateDirective, i3.NgForOf, i1.AdaptIconComponent], styles: [".heatmap-chart_hidden-menu[_ngcontent-%COMP%] {\n      opacity: 0;\n      visibility: hidden;\n      height: 0\n    }"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptHeatmapComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-heatmap',
                styles: [`
    .heatmap-chart_hidden-menu {
      opacity: 0;
      visibility: hidden;
      height: 0
    }
  `],
                template: `
    <adapt-chart #chartBase
                 [data]="data"
                 [width]="width"
                 [height]="height"
                 [header]="header"
                 [legend]="_legend"
                 [backgroundColor]="backgroundColor"
                 [suppressHeader]="suppressHeader"
                 [suppressLegend]="suppressLegend"
                 [tooltip]="tooltip"
                 [dataBuilder]="_dataBuilder"
                 [updateChart]="_updateChart"
                 [noDataText]="noDataText"
                 (categoryEnter)="_categoryEnter($event)"
                 (categoryLeave)="_categoryLeave($event)"></adapt-chart>

    <div class="dropdown heatmap-chart_hidden-menu"
         adaptDropdown
         #menuContainer
         *ngIf="hasActionMenu"
         [adaptRadarDisableEventSending]="true"
         [appendToBody]="true"
         (popupAnimationDone)="popupAnimationDone()">
      <button #menuAnchor adaptDropdownToggle type="button"></button>
      <ng-template adaptDropdownMenuTemplate>
        <div class="dropdown-menu">
          <div *ngIf="menuData && menuData.actions && menuData.actions.length">
            <button class="dropdown-item"
                    type="button"
                    *ngFor="let action of menuData.actions;"
                    (click)="callAction(menuData.target, menuData.event, menuData.context, action)">
              {{action.title}}
            </button>
          </div>
        </div>
      </ng-template>
    </div>

    <ng-template #heatmapDefaultTooltip let-c="context">
      <div class="text-left">
        <div>
          <adapt-icon class="icon-inline"
                      [adaptRadarDisableEventSending]="true"
                      *ngIf="c.status.icon"
                      [name]="c.status.icon"
                      [style.color]="c.status.iconColor || c.status.color || defaultColor"></adapt-icon>
          {{c.name}}
        </div>
        <div class="pt-2" *ngIf="c.info">
          <small class="text-secondary">{{c.info}}</small>
        </div>
        <div class="pt-2" *ngIf="c.progress">
          <label class="progress-label" [style.marginLeft]="c.progress + '%'">{{c.progress}}%</label>
          <div class="progress">
            <div class="progress-bar bg-primary-muted"
                 role="progressbar"
                 [style.width]="c.progress + '%'"
                 [attr.aria-valuenow]="c.progress"
                 aria-valuemin="0"
                 aria-valuemax="100"></div>
          </div>
        </div>
        <div class="pt-2">
          <div style="width: 8px; height: 8px; margin: 0 4px 1px 2px; display: inline-block; vertical-align: middle"
               [style.backgroundColor]="c.status.bg"></div>
          {{c.status.name}}
        </div>
      </div>
    </ng-template>
  `
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: i1.AdaptIconConfig }]; }, { chartBase: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], heatmapDefaultTooltip: [{
            type: ViewChild,
            args: ['heatmapDefaultTooltip', { static: true }]
        }], menuAnchor: [{
            type: ViewChild,
            args: ['menuAnchor', {
                    read: AdaptDropdownToggleDirective,
                    static: false
                }]
        }], menuContainer: [{
            type: ViewChild,
            args: ['menuContainer', { read: AdaptDropdownDirective, static: false }]
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], legend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], data: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], clickChart: [{
            type: Output
        }] }); })();
//# sourceMappingURL=heatmap.component.js.map