import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, HostBinding, Input, Output, ViewEncapsulation } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import * as shape from 'd3-shape';
import { Subject } from 'rxjs';
import { AdaptDeviceDetectionService, AdaptIconConfig, adaptWarn, debounce, SafeCdr, toBoolean } from '@bmc-ux/adapt-angular';
import { AdaptFlowChartOrientation } from '../common/models/flow-chart.model';
import { ChartColorService } from '../common/services/chart-color.service';
import * as i0 from "@angular/core";
import * as i1 from "@bmc-ux/adapt-angular";
import * as i2 from "@angular/platform-browser";
import * as i3 from "@angular/common";
import * as i4 from "@angular/forms";
import * as i5 from "@swimlane/ngx-graph";
import * as i6 from "../common/utils/text-ellipsis.directive";
function AdaptFlowChartComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelement(2, "div", 6);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} }
function AdaptFlowChartComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 7);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵelement(2, "adapt-empty-state", 8);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("type", "chart")("inverted", ctx_r1.emptyStateConfig.inverted)("label", ctx_r1.emptyStateConfig.label);
} }
function AdaptFlowChartComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r5 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵelementStart(2, "adapt-slider", 9);
    i0.ɵɵlistener("ngModelChange", function AdaptFlowChartComponent_div_6_Template_adapt_slider_ngModelChange_2_listener($event) { i0.ɵɵrestoreView(_r5); const ctx_r4 = i0.ɵɵnextContext(); return ctx_r4.zoomLevel = $event; });
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementStart(5, "button", 10);
    i0.ɵɵlistener("click", function AdaptFlowChartComponent_div_6_Template_button_click_5_listener() { i0.ɵɵrestoreView(_r5); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.fitGraph(); });
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngModel", ctx_r2.zoomLevel)("customStepChange", true)("min", ctx_r2.minZoomLevel)("max", ctx_r2.maxZoomLevel)("formatter", ctx_r2.sliderValueFormatter)("step", 0.05)("styleClass", "adapt-flow-chart__zoom-slider");
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.texts.fitGraphButton, "\n    ");
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_ng_template_2_Template(rf, ctx) { }
const _c0 = function (a0) { return { $implicit: a0 }; };
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 17);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext().$implicit;
    const ctx_r14 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r14.customTemplateConfig.nodeTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c0, node_r13));
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_svg_62_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg");
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelement(2, "g", 40);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r20 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("class", node_r13.iconCustomClass)("fill", ctx_r20.getStatusColor(node_r13.status))("height", ctx_r20.mainIconDimension)("width", ctx_r20.mainIconDimension)("x", ctx_r20.mainIconLeftPadding)("y", ctx_r20.mainIconTopPadding);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("innerHTML", ctx_r20.getSvgIcon(node_r13.icon), i0.ɵɵsanitizeHtml);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_line_72_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelement(0, "line", 41);
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r21 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("x1", 0)("y1", ctx_r21.defaultNodeHeight)("x2", node_r13.dimension.width)("y2", ctx_r21.defaultNodeHeight);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_svg_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg");
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵelement(2, "g", 40);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r31 = i0.ɵɵnextContext();
    const info_r26 = ctx_r31.$implicit;
    const i_r27 = ctx_r31.index;
    const ctx_r29 = i0.ɵɵnextContext(6);
    i0.ɵɵattribute("class", info_r26.iconCustomClass)("fill", ctx_r29.getStatusColor(info_r26.status) || ctx_r29.defaultLabelColor)("height", ctx_r29.additionalIconDimension)("width", ctx_r29.additionalIconDimension)("x", ctx_r29.basicLeftPadding + ctx_r29.additionalLeftPadding)("y", ctx_r29.additionalIconTopPadding + i_r27 * ctx_r29.additionalInfoRowHeight);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("innerHTML", ctx_r29.getSvgIcon(info_r26.icon), i0.ɵɵsanitizeHtml);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_line_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelement(0, "line", 41);
} if (rf & 2) {
    const i_r27 = i0.ɵɵnextContext().index;
    const node_r13 = i0.ɵɵnextContext(4).$implicit;
    const ctx_r30 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("x1", 0)("y1", ctx_r30.additionalLineTopPadding + i_r27 * ctx_r30.additionalInfoRowHeight)("x2", node_r13.dimension.width)("y2", ctx_r30.additionalLineTopPadding + i_r27 * ctx_r30.additionalInfoRowHeight);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g");
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_svg_2_Template, 4, 7, "svg", 3);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵtext(4, "\n            ");
    i0.ɵɵelementStart(5, "text", 43);
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n            ");
    i0.ɵɵtemplate(8, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_line_8_Template, 1, 4, "line", 39);
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const info_r26 = ctx.$implicit;
    const i_r27 = ctx.index;
    const last_r28 = ctx.last;
    const node_r13 = i0.ɵɵnextContext(4).$implicit;
    const ctx_r25 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", info_r26.icon);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("text", info_r26.text)("width", node_r13.dimension.width - ctx_r25.basicLeftPadding * 3 - ctx_r25.additionalIconDimension);
    i0.ɵɵattribute("fill", ctx_r25.defaultColor)("x", info_r26.icon ? ctx_r25.basicLeftPadding * 3 : ctx_r25.basicLeftPadding + ctx_r25.additionalLeftPadding)("y", ctx_r25.additionalTextTopPadding + i_r27 * ctx_r25.additionalInfoRowHeight);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", !last_r28);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2_Template, 10, 7, "g", 42);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext(3).$implicit;
    const ctx_r22 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", node_r13.data)("ngForTrackBy", ctx_r22.trackByForNodeData);
} }
const _c1 = function (a0) { return { "filter": a0 }; };
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    const _r38 = i0.ɵɵgetCurrentView();
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g", 19);
    i0.ɵɵlistener("click", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_click_0_listener($event) { i0.ɵɵrestoreView(_r38); const node_r13 = i0.ɵɵnextContext(2).$implicit; const ctx_r36 = i0.ɵɵnextContext(2); return ctx_r36.handleNodeClick($event, node_r13); })("mouseover", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_mouseover_0_listener() { i0.ɵɵrestoreView(_r38); const node_r13 = i0.ɵɵnextContext(2).$implicit; const ctx_r39 = i0.ɵɵnextContext(2); return ctx_r39.handleMouseOver(node_r13); })("mouseleave", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_mouseleave_0_listener() { i0.ɵɵrestoreView(_r38); const ctx_r41 = i0.ɵɵnextContext(4); return ctx_r41.nodeHoverId = ""; });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "defs");
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementStart(4, "filter", 20);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelement(6, "feGaussianBlur", 21);
    i0.ɵɵtext(7, "\n            ");
    i0.ɵɵelement(8, "feOffset", 22);
    i0.ɵɵtext(9, "\n            ");
    i0.ɵɵelement(10, "feOffset", 23);
    i0.ɵɵtext(11, "\n            ");
    i0.ɵɵelement(12, "feFlood", 24);
    i0.ɵɵtext(13, "\n            ");
    i0.ɵɵelement(14, "feFlood", 25);
    i0.ɵɵtext(15, "\n            ");
    i0.ɵɵelement(16, "feComposite", 26);
    i0.ɵɵtext(17, "\n            ");
    i0.ɵɵelement(18, "feComposite", 27);
    i0.ɵɵtext(19, "\n            ");
    i0.ɵɵelementStart(20, "feMerge");
    i0.ɵɵtext(21, "\n              ");
    i0.ɵɵelement(22, "feMergeNode", 28);
    i0.ɵɵtext(23, "\n              ");
    i0.ɵɵelement(24, "feMergeNode", 29);
    i0.ɵɵtext(25, "\n              ");
    i0.ɵɵelement(26, "feMergeNode", 30);
    i0.ɵɵtext(27, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(28, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(29, "\n\n          ");
    i0.ɵɵelementStart(30, "filter", 20);
    i0.ɵɵtext(31, "\n            ");
    i0.ɵɵelement(32, "feGaussianBlur", 31);
    i0.ɵɵtext(33, "\n            ");
    i0.ɵɵelement(34, "feOffset", 32);
    i0.ɵɵtext(35, "\n            ");
    i0.ɵɵelement(36, "feOffset", 33);
    i0.ɵɵtext(37, "\n            ");
    i0.ɵɵelement(38, "feFlood", 34);
    i0.ɵɵtext(39, "\n            ");
    i0.ɵɵelement(40, "feFlood", 35);
    i0.ɵɵtext(41, "\n            ");
    i0.ɵɵelement(42, "feComposite", 26);
    i0.ɵɵtext(43, "\n            ");
    i0.ɵɵelement(44, "feComposite", 27);
    i0.ɵɵtext(45, "\n            ");
    i0.ɵɵelementStart(46, "feMerge");
    i0.ɵɵtext(47, "\n              ");
    i0.ɵɵelement(48, "feMergeNode", 28);
    i0.ɵɵtext(49, "\n              ");
    i0.ɵɵelement(50, "feMergeNode", 29);
    i0.ɵɵtext(51, "\n              ");
    i0.ɵɵelement(52, "feMergeNode", 30);
    i0.ɵɵtext(53, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(54, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(55, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(56, "\n        ");
    i0.ɵɵelementStart(57, "rect", 36);
    i0.ɵɵtext(58, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(59, "\n        ");
    i0.ɵɵelementStart(60, "g");
    i0.ɵɵtext(61, "\n          ");
    i0.ɵɵtemplate(62, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_svg_62_Template, 4, 7, "svg", 3);
    i0.ɵɵtext(63, "\n          ");
    i0.ɵɵelementStart(64, "text", 37);
    i0.ɵɵtext(65, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(66, "\n          ");
    i0.ɵɵtext(67, "\n          ");
    i0.ɵɵtext(68, "\n          ");
    i0.ɵɵelementStart(69, "text", 38);
    i0.ɵɵtext(70, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(71, "\n          ");
    i0.ɵɵtemplate(72, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_line_72_Template, 1, 4, "line", 39);
    i0.ɵɵtext(73, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(74, "\n        ");
    i0.ɵɵtemplate(75, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75_Template, 4, 2, "g", 3);
    i0.ɵɵtext(76, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r19 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(4);
    i0.ɵɵpropertyInterpolate1("id", "shadow", ctx_r19.componentLevelId, "");
    i0.ɵɵadvance(26);
    i0.ɵɵpropertyInterpolate1("id", "shadow-hover", ctx_r19.componentLevelId, "");
    i0.ɵɵadvance(27);
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(20, _c1, ctx_r19.nodeHoverId && ctx_r19.nodeHoverId === node_r13.id ? "url(#shadow-hover" + ctx_r19.componentLevelId + ")" : "url(#shadow" + ctx_r19.componentLevelId + ")"));
    i0.ɵɵattribute("rx", node_r13.type === "rounded" ? ctx_r19.nodeRoundRadix : 0)("width", node_r13.dimension.width)("height", node_r13.dimension.height)("fill", ctx_r19.defaultBackgroundColor);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", node_r13.icon);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("text", node_r13.label)("width", node_r13.dimension.width - ctx_r19.mainIconLeftPadding * 3 - ctx_r19.mainIconDimension);
    i0.ɵɵattribute("fill", ctx_r19.defaultLabelColor)("x", node_r13.icon ? ctx_r19.mainTextLeftPadding : ctx_r19.basicLeftPadding + ctx_r19.additionalLeftPadding)("y", ctx_r19.mainTextTopPadding);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("text", node_r13.description)("width", node_r13.dimension.width - ctx_r19.mainIconLeftPadding * 3 - ctx_r19.mainIconDimension);
    i0.ɵɵattribute("fill", ctx_r19.defaultColor)("x", node_r13.icon ? ctx_r19.mainTextLeftPadding : ctx_r19.basicLeftPadding + ctx_r19.additionalLeftPadding)("y", (ctx_r19.mainTextTopPadding - ctx_r19.mainTextTopGap) * 2);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", node_r13.data && node_r13.data.length);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", node_r13.data && node_r13.data.length);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template, 77, 22, "g", 18);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const node_r13 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", node_r13 && node_r13.dimension && node_r13.dimension.width);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_Template, 4, 4, "ng-container", 15);
    i0.ɵɵtext(2, "\n\n    ");
    i0.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3_Template, 3, 1, "ng-template", null, 16, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n  ");
} if (rf & 2) {
    const _r15 = i0.ɵɵreference(4);
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r8.customTemplateConfig == null ? null : ctx_r8.customTemplateConfig.nodeTemplate)("ngIfElse", _r15);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_ng_template_2_Template(rf, ctx) { }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 45);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r44 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r44.customTemplateConfig.defsTemplate);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(1, "marker", 46);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelement(3, "polygon", 47);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n    ");
} if (rf & 2) {
    const ctx_r46 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵpropertyInterpolate1("id", "arrow", ctx_r46.componentLevelId, "");
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_Template, 4, 1, "ng-container", 15);
    i0.ɵɵtext(2, "\n\n    ");
    i0.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_template_3_Template, 6, 1, "ng-template", null, 44, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n  ");
} if (rf & 2) {
    const _r45 = i0.ɵɵreference(4);
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r10.customTemplateConfig == null ? null : ctx_r10.customTemplateConfig.defsTemplate)("ngIfElse", _r45);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_ng_template_2_Template(rf, ctx) { }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 17);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const link_r48 = i0.ɵɵnextContext().$implicit;
    const ctx_r49 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r49.customTemplateConfig.linkTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c0, link_r48));
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3__svg_g_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "rect", 51);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "text", 52);
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const link_r48 = i0.ɵɵnextContext(2).$implicit;
    const ctx_r54 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("transform", "translate(" + link_r48.midPoint.x + "," + link_r48.midPoint.y + ")");
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("filter", "url(#shadow" + ctx_r54.componentLevelId + ")");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("text", link_r48.label)("width", 70);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(1, "g", 49);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "path", 50);
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵtemplate(7, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3__svg_g_7_Template, 8, 4, "g", 3);
    i0.ɵɵtext(8, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
} if (rf & 2) {
    const link_r48 = i0.ɵɵnextContext().$implicit;
    const ctx_r51 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(4);
    i0.ɵɵattribute("stroke-dasharray", link_r48.type === "stroke" ? ctx_r51.strokeLineLength : 0)("marker-end", "url(#arrow" + ctx_r51.componentLevelId + ")");
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", link_r48.label && link_r48.midPoint);
} }
function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_Template, 4, 4, "ng-container", 15);
    i0.ɵɵtext(2, "\n\n    ");
    i0.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3_Template, 10, 3, "ng-template", null, 48, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n  ");
} if (rf & 2) {
    const _r50 = i0.ɵɵreference(4);
    const ctx_r12 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r12.customTemplateConfig == null ? null : ctx_r12.customTemplateConfig.linkTemplate)("ngIfElse", _r50);
} }
const _c2 = function () { return []; };
function AdaptFlowChartComponent_ngx_graph_10_Template(rf, ctx) { if (rf & 1) {
    const _r58 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "ngx-graph", 11);
    i0.ɵɵlistener("zoomChange", function AdaptFlowChartComponent_ngx_graph_10_Template_ngx_graph_zoomChange_0_listener($event) { i0.ɵɵrestoreView(_r58); const ctx_r57 = i0.ɵɵnextContext(); return ctx_r57.handleZoomChangeDebounced($event); });
    i0.ɵɵtext(1, "\n\n  ");
    i0.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_Template, 6, 2, "ng-template", null, 12, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(4, "\n\n  ");
    i0.ɵɵtemplate(5, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_Template, 6, 2, "ng-template", null, 13, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(7, "\n\n  ");
    i0.ɵɵtemplate(8, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_Template, 6, 2, "ng-template", null, 14, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(10, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("links", ctx_r3.links || i0.ɵɵpureFunction0(17, _c2))("nodes", ctx_r3.nodes)("curve", ctx_r3.curve)("draggingEnabled", false)("layoutSettings", ctx_r3.layoutSettings)("enableZoom", ctx_r3.enableZoom)("zoomSpeed", ctx_r3.zoomSpeed)("autoZoom", ctx_r3.autoZoom)("autoCenter", ctx_r3.autoCenter)("center$", ctx_r3.center$)("zoomToFit$", ctx_r3.zoomToFit$)("update$", ctx_r3.update$)("panToNode$", ctx_r3.panToNode$)("panningEnabled", !ctx_r3.isIE)("zoomLevel", ctx_r3.zoomLevel)("minZoomLevel", ctx_r3.minZoomLevel)("maxZoomLevel", ctx_r3.maxZoomLevel);
} }
export class AdaptFlowChartComponent {
    constructor(_deviceDetection, _changeDetectorRef, _domSanitizer, _iconConfig) {
        this._deviceDetection = _deviceDetection;
        this._changeDetectorRef = _changeDetectorRef;
        this._domSanitizer = _domSanitizer;
        this._iconConfig = _iconConfig;
        this.center$ = new Subject();
        this.zoomToFit$ = new Subject();
        this.panToNode$ = new Subject();
        this.update$ = new Subject();
        this.mainTextLeftPadding = 70;
        this.mainTextTopPadding = 34;
        this.mainTextTopGap = 6;
        this.mainIconDimension = 40;
        this.mainIconLeftPadding = 15;
        this.mainIconTopPadding = 20;
        this.defaultNodeHeight = 78;
        this.defaultNodeWidth = 280;
        this.nodeRoundRadix = 45;
        this.additionalInfoRowHeight = 42;
        this.additionalIconDimension = 13;
        this.basicLeftPadding = 12;
        this.additionalLeftPadding = 4;
        this.additionalIconTopPadding = 93;
        this.additionalTextTopPadding = 103;
        this.additionalLineTopPadding = 120;
        this.defaultColor = 'currentcolor';
        this.defaultLabelColor = 'var(--color-active)';
        this.defaultBackgroundColor = '#fff';
        this.strokeLineLength = 4;
        this.layoutSettings = {
            orientation: AdaptFlowChartOrientation.BOTTOM_TO_TOP
        };
        this.minZoomLevel = 0.1;
        this.maxZoomLevel = 4;
        this.handleZoomChangeDebounced = debounce(this.handleZoomChange.bind(this), 200);
        this.loading = true;
        this.isIE = false;
        this.nodeHoverId = '';
        this.curve = shape.curveCatmullRom;
        this.orientation = AdaptFlowChartOrientation.BOTTOM_TO_TOP;
        this.zoomSpeed = 0.04;
        // @Input() draggingEnabled = false;
        this.enableZoom = true;
        this.autoZoom = false;
        this.autoCenter = false;
        this.hasEmptyState = true;
        this.clickNode = new EventEmitter();
        this.class = 'adapt-flow-chart';
        this._defaultTexts = {
            fitGraphButton: 'Fit to screen'
        };
        this._defaultEmptyStateConfig = {
            label: '',
            inverted: false
        };
    }
    ngOnInit() {
        this.componentLevelId = Math.floor(Math.random() * 1000000).toString();
        this.isIE = this._deviceDetection.isIE();
        this.texts = Object.assign(Object.assign({}, this._defaultTexts), this.texts);
        this.emptyStateConfig = Object.assign(Object.assign({}, this._defaultEmptyStateConfig), this.emptyStateConfig);
        this.layoutSettings.orientation = this.orientation;
    }
    ngOnChanges(changes) {
        const nodes = changes.nodes;
        if (this.nodes && nodes && nodes.previousValue !== nodes.currentValue) {
            this.nodes.forEach(node => {
                node.dimension = {
                    width: node.dimension && node.dimension.width || this.defaultNodeWidth,
                    height: this.getNodeHeight(node)
                };
            });
            if (this.autoCenterToNode) {
                if (this.autoCenter) {
                    this.autoCenter = false;
                    adaptWarn(`ADAPT-ANGULAR Warning! Flow chart component!
          Seems like "autoCenter" is enabled with "autoCenterToNode".
          In this case "autoCenter" will be disabled for correct work of "autoCenterToNode"`);
                }
                setTimeout(() => {
                    this.panToNode$.next(this.autoCenterToNode);
                    this.autoCenterToNode = null;
                });
            }
            this.loading = false;
        }
    }
    showEmptyState() {
        return this.hasEmptyState && !this.loading && (!this.nodes || this.nodes.length === 0);
    }
    showGraph() {
        return toBoolean(!this.loading && this.nodes && this.nodes.length !== 0);
    }
    getStatusColor(status) {
        return status || status === 0 ? ChartColorService.getColorRange(status, 1)[0] : this.defaultColor;
    }
    getSvgIcon(name) {
        return this._domSanitizer.bypassSecurityTrustHtml(this._iconConfig.getIcon(name));
    }
    fitGraph() {
        this.zoomToFit$.next(true);
        // At the same time centring graph for better user experience
        this.center$.next(true);
    }
    handleNodeClick(event, node) {
        this.clickNode.emit({ event, node });
    }
    handleMouseOver(node) {
        this.nodeHoverId = node.id;
    }
    handleZoomMouseDown() {
        this._disableAutoZoom();
    }
    handleZoomChange(zoomLevel) {
        this._disableAutoZoom();
        this.zoomLevel = zoomLevel;
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    getNodeHeight(node) {
        if (node.data && node.data.length) {
            return this.defaultNodeHeight + node.data.length * this.additionalInfoRowHeight;
        }
        else {
            return node.dimension && node.dimension.height || this.defaultNodeHeight;
        }
    }
    trackByForNodeData(index) {
        return index;
    }
    sliderValueFormatter(value) {
        if ((value ^ 0) === value) {
            return value.toString();
        }
        else {
            const digitsAfterComma = value.toString().split('.')[1].length;
            const roundTo = digitsAfterComma > 2 ? 2 : 1;
            return value.toFixed(roundTo);
        }
    }
    _disableAutoZoom() {
        // This hack need to be done to allow zooming with slider if autoZoom feature was enabled by default
        if (this.autoZoom) {
            this.autoZoom = false;
        }
        // Also need to disable autoCenter to avoid centring on zooming
        if (this.autoCenter) {
            this.autoCenter = false;
        }
    }
}
AdaptFlowChartComponent.ɵfac = function AdaptFlowChartComponent_Factory(t) { return new (t || AdaptFlowChartComponent)(i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.DomSanitizer), i0.ɵɵdirectiveInject(i1.AdaptIconConfig)); };
AdaptFlowChartComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptFlowChartComponent, selectors: [["adapt-flow-chart"]], hostVars: 4, hostBindings: function AdaptFlowChartComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.class);
        i0.ɵɵstyleProp("background-color", ctx.backgroundColor);
    } }, inputs: { links: "links", nodes: "nodes", curve: "curve", orientation: "orientation", zoomSpeed: "zoomSpeed", enableZoom: "enableZoom", autoZoom: "autoZoom", autoCenter: "autoCenter", texts: "texts", autoCenterToNode: "autoCenterToNode", hasEmptyState: "hasEmptyState", emptyStateConfig: "emptyStateConfig", customTemplateConfig: "customTemplateConfig", backgroundColor: "backgroundColor" }, outputs: { clickNode: "clickNode" }, features: [i0.ɵɵNgOnChangesFeature], decls: 12, vars: 4, consts: [["class", "loader-container adapt-flow-chart__loader", 4, "ngIf"], ["class", "adapt-flow-chart__empty-state", 4, "ngIf"], [1, "adapt-flow-chart__zoom-slider-wrapper"], [4, "ngIf"], ["version", "1.1", 0, "xmlns", "svg", "http://www.w3.org/2000/svg", 3, "links", "nodes", "curve", "draggingEnabled", "layoutSettings", "enableZoom", "zoomSpeed", "autoZoom", "autoCenter", "center$", "zoomToFit$", "update$", "panToNode$", "panningEnabled", "zoomLevel", "minZoomLevel", "maxZoomLevel", "zoomChange", 4, "ngIf"], [1, "loader-container", "adapt-flow-chart__loader"], [1, "loader-section"], [1, "adapt-flow-chart__empty-state"], [3, "type", "inverted", "label"], ["orientation", "vertical", 3, "ngModel", "customStepChange", "min", "max", "formatter", "step", "styleClass", "ngModelChange"], [1, "adapt-flow-chart__zoom-fit-button", 3, "click"], ["version", "1.1", 0, "xmlns", "svg", "http://www.w3.org/2000/svg", 3, "links", "nodes", "curve", "draggingEnabled", "layoutSettings", "enableZoom", "zoomSpeed", "autoZoom", "autoCenter", "center$", "zoomToFit$", "update$", "panToNode$", "panningEnabled", "zoomLevel", "minZoomLevel", "maxZoomLevel", "zoomChange"], ["nodeTemplate", ""], ["defsTemplate", ""], ["linkTemplate", ""], [4, "ngIf", "ngIfElse"], ["defaultNodeTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "node", 3, "click", "mouseover", "mouseleave", 4, "ngIf"], [1, "node", 3, "click", "mouseover", "mouseleave"], ["height", "150%", 3, "id"], ["in", "SourceAlpha", "stdDeviation", "2.5", "result", "blur"], ["dx", "0", "dy", "2", "result", "offsetBlur"], ["dx", "0", "dy", "4", "result", "offsetBlur2", "in", "blur"], ["flood-color", "black", "flood-opacity", "0.14", "result", "offsetColor"], ["flood-color", "black", "flood-opacity", "0.06", "result", "offsetColor2"], ["in", "offsetColor", "in2", "offsetBlur", "operator", "in", "result", "offsetBlur"], ["in", "offsetColor2", "in2", "offsetBlur2", "operator", "in", "result", "offsetBlur2"], ["in", "offsetBlur"], ["in", "offsetBlur2"], ["in", "SourceGraphic"], ["in", "SourceAlpha", "stdDeviation", "7", "result", "blur"], ["dx", "0", "dy", "4", "result", "offsetBlur"], ["dx", "0", "dy", "9", "result", "offsetBlur2", "in", "blur"], ["flood-color", "black", "flood-opacity", "0.17", "result", "offsetColor"], ["flood-color", "black", "flood-opacity", "0.09", "result", "offsetColor2"], [1, "adapt-flow-chart__box", 3, "ngStyle"], ["alignment-baseline", "central", "adaptTextEllipsis", "", 1, "adapt-flow-chart__label", 3, "text", "width"], ["alignment-baseline", "central", "adaptTextEllipsis", "", 3, "text", "width"], ["stroke", "lightgrey", 4, "ngIf"], [3, "innerHTML"], ["stroke", "lightgrey"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["adaptTextEllipsis", "", 3, "text", "width"], ["defaultDefsTemplate", ""], [3, "ngTemplateOutlet"], ["markerWidth", "8", "markerHeight", "7", "refX", "7", "refY", "3", "orient", "auto", 3, "id"], ["points", "0 0, 8 3, 0 6", "fill", "#333"], ["defaultLinkTemplate", ""], [1, "edge"], ["stroke-width", "2", "stroke", "#333", 1, "line"], ["width", "90", "height", "30", "x", "-45", "y", "-18", "rx", "3", 1, "adapt-flow-chart__edge-label-bg"], ["adaptTextEllipsis", "", "alignment-baseline", "central", 1, "adapt-flow-chart__edge-label-text", 3, "text", "width"]], template: function AdaptFlowChartComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptFlowChartComponent_div_0_Template, 4, 0, "div", 0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptFlowChartComponent_div_2_Template, 4, 3, "div", 1);
        i0.ɵɵtext(3, "\n\n");
        i0.ɵɵelementStart(4, "div", 2);
        i0.ɵɵtext(5, "\n  ");
        i0.ɵɵtemplate(6, AdaptFlowChartComponent_div_6_Template, 8, 8, "div", 3);
        i0.ɵɵtext(7, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n");
        i0.ɵɵtext(9, "\n");
        i0.ɵɵtemplate(10, AdaptFlowChartComponent_ngx_graph_10_Template, 11, 18, "ngx-graph", 4);
        i0.ɵɵtext(11, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.loading);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.showEmptyState());
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.showGraph() && ctx.enableZoom);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.showGraph());
    } }, directives: [i3.NgIf, i1.AdaptEmptyStateComponent, i1.AdaptSliderComponent, i4.NgControlStatus, i4.NgModel, i5.GraphComponent, i3.NgTemplateOutlet, i3.NgStyle, i6.AdaptTextEllipsisDirective, i3.NgForOf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptFlowChartComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-flow-chart',
                templateUrl: './flow-chart.component.html',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: i1.AdaptDeviceDetectionService }, { type: i0.ChangeDetectorRef }, { type: i2.DomSanitizer }, { type: i1.AdaptIconConfig }]; }, { links: [{
            type: Input
        }], nodes: [{
            type: Input
        }], curve: [{
            type: Input
        }], orientation: [{
            type: Input
        }], zoomSpeed: [{
            type: Input
        }], enableZoom: [{
            type: Input
        }], autoZoom: [{
            type: Input
        }], autoCenter: [{
            type: Input
        }], texts: [{
            type: Input
        }], autoCenterToNode: [{
            type: Input
        }], hasEmptyState: [{
            type: Input
        }], emptyStateConfig: [{
            type: Input
        }], customTemplateConfig: [{
            type: Input
        }], clickNode: [{
            type: Output
        }], class: [{
            type: HostBinding,
            args: ['class']
        }], backgroundColor: [{
            type: HostBinding,
            args: ['style.background-color']
        }, {
            type: Input
        }] }); })();
//# sourceMappingURL=flow-chart.component.js.map