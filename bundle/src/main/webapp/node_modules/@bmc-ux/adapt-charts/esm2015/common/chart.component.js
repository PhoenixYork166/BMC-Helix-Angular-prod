import { ChangeDetectorRef, Component, ContentChild, ElementRef, EventEmitter, Injector, Input, NgZone, Output, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { ComponentPortal } from '@angular/cdk/portal';
import { Directionality } from '@angular/cdk/bidi';
import { asapScheduler, ReplaySubject, timer } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { isNull, isNumber, isUndefined } from 'lodash-es';
import * as d3 from 'd3';
import { AdaptDeviceDetectionService, AdaptOverlayService, AdaptTooltipComponent, ANIMATION_DURATION, ANIMATION_TIMING_FUNCTION, getOverlayConnectedPositions, SafeCdr, } from '@bmc-ux/adapt-angular';
import { textWrap } from './utils/chart-utils';
import { AdaptChartAbstract } from './models/chart.model';
import { AdaptChartSliderComponent } from './chart-slider/chart-slider.component';
import { ChartLegendComponent } from './legend/chart-legend.component';
import { AdaptAreaGraphSliderComponent } from '../area-graph/area-graph-slider.component';
import * as i0 from "@angular/core";
import * as i1 from "@bmc-ux/adapt-angular";
import * as i2 from "@angular/cdk/bidi";
import * as i3 from "@angular/platform-browser";
import * as i4 from "@angular/common";
import * as i5 from "./legend/chart-gradient-legend.component";
import * as i6 from "./legend/chart-legend.component";
const _c0 = ["chartContainer"];
const _c1 = ["chartArea"];
const _c2 = ["svgContainer"];
const _c3 = ["legend"];
const _c4 = ["legendComponent"];
const _c5 = ["chartSlider"];
function AdaptChartComponent_div_5_h1_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "h1", 14);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r8.$this.header.title);
} }
function AdaptChartComponent_div_5_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 15);
    i0.ɵɵlistener("click", function AdaptChartComponent_div_5_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(2); return ctx_r10.toggleLegend(); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelement(2, "span");
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "span");
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("d-icon-left-eye", ctx_r9.isLegendHidden)("d-icon-left-eye_closed", !ctx_r9.isLegendHidden);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("", ctx_r9.isLegendHidden ? "Show" : "Hide", " legend");
} }
function AdaptChartComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 11);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptChartComponent_div_5_h1_2_Template, 2, 1, "h1", 12);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, AdaptChartComponent_div_5_button_4_Template, 7, 5, "button", 13);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r1.$this.header.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", (ctx_r1.$this == null ? null : ctx_r1.$this.header == null ? null : ctx_r1.$this.header.allowHideLegend) && !ctx_r1.isMobile && !ctx_r1.suppressLegend);
} }
function AdaptChartComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptChartComponent__svg_svg_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg", 16, 17);
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵelementStart(3, "desc", 18);
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelement(6, "g", 19);
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("transition", ctx_r4.transition);
    i0.ɵɵattributeInterpolate2("viewbox", "0 0 ", ctx_r4.currentSVGWidth, " ", ctx_r4.currentSVGHeight, "");
    i0.ɵɵattribute("aria-label", ctx_r4.title || (ctx_r4.$this == null ? null : ctx_r4.$this.header == null ? null : ctx_r4.$this.header.title) || "")("width", ctx_r4.currentSVGWidth)("height", ctx_r4.currentSVGHeight ? ctx_r4.currentSVGHeight + ctx_r4.chartBottomPadding : ctx_r4.currentSVGHeight);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(ctx_r4.description);
    i0.ɵɵadvance(2);
    i0.ɵɵattribute("id", ctx_r4.chartContainerId)("width", ctx_r4.currentSVGWidth);
} }
const _c6 = function (a0) { return { "adapt-legend-zone__hidden": a0 }; };
function AdaptChartComponent_div_28_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 20);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "adapt-chart-gradient-legend", 21);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("width", ctx_r6.isMobile ? "100%" : ctx_r6.legendWidth + "px")("transition", ctx_r6.transition);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(14, _c6, !ctx_r6.showLegend));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("containerWidth", ctx_r6.legendWidth - 25)("increaseColor", ctx_r6.gradientLegend.increaseColor)("decreaseColor", ctx_r6.gradientLegend.decreaseColor)("zeroColor", ctx_r6.gradientLegend.zeroColor)("increaseText", ctx_r6.gradientLegend.increaseText)("decreaseText", ctx_r6.gradientLegend.decreaseText)("zeroText", ctx_r6.gradientLegend.zeroText)("height", ctx_r6.gradientLegend.height)("focusable", ctx_r6.showLegend);
} }
function AdaptChartComponent_div_30_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 20, 22);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "adapt-chart-legend", 23, 24);
    i0.ɵɵlistener("categoryShow", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryShow_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.categoryShow.emit($event); })("categoryHide", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryHide_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.categoryHide.emit($event); })("categoryEnter", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryEnter_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r18 = i0.ɵɵnextContext(); return ctx_r18.categoryEnter.emit($event); })("categoryLeave", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryLeave_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.categoryLeave.emit($event); })("categoryMove", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryMove_3_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.categoryMove.emit($event); });
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("width", ctx_r7.isMobile ? "100%" : ctx_r7.legendWidth + "px")("transition", ctx_r7.transition);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(13, _c6, !ctx_r7.showLegend));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("focusable", ctx_r7.showLegend)("activeHover", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.activeHover)("activeClick", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.activeClick)("customColors", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.customColors)("items", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.items)("width", ctx_r7.legendWidth - 30)("columns", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.columns)("colorsPalette", ctx_r7.colorsPalette);
} }
const _c7 = ["*", [["adapt-chart-slider"]], [["adapt-area-graph-slider"]]];
const _c8 = ["*", "adapt-chart-slider", "adapt-area-graph-slider"];
let CHART_ID = 1;
export class AdaptChartComponent extends AdaptChartAbstract {
    constructor(_deviceDetectionService, _directionality, _domSanitizer, _injector, _ngZone, _changeDetectorRef, _overlayService) {
        super();
        this._deviceDetectionService = _deviceDetectionService;
        this._directionality = _directionality;
        this._domSanitizer = _domSanitizer;
        this._injector = _injector;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this._overlayService = _overlayService;
        // TODO update types
        this.$this = this;
        /*
        * Useful to prevent legend rendering on view(eg. on chart slider component)
        * @since 11.4.0
        */
        this.renderLegend = true;
        this.categoryShow = new EventEmitter();
        this.categoryHide = new EventEmitter();
        this.categoryEnter = new EventEmitter();
        this.categoryLeave = new EventEmitter();
        this.categoryMove = new EventEmitter();
        this.clickChart = new EventEmitter();
        this.chartContainerId = 'chartContainer-';
        this.isLegendHidden = false;
        this.legendWidth = 250;
        this.defaultMaxAxisWidth = 150;
        this._emptyText = 'No data to show...';
        this._tooltipOverlayDefaultOffset = 6;
        this._tooltipDefaultCustomCls = 'adapt-chart-tooltip position-static';
        this._showEmptyText = false;
        this._chartBottomPadding = 0;
        this._destroyed$ = new ReplaySubject(1);
        const placements = getOverlayConnectedPositions(this._directionality.value, this._tooltipOverlayDefaultOffset);
        this._tooltipOverlayPlacements = {
            top: placements.top,
            bottom: placements.bottom,
            left: placements.left,
            right: placements.right
        };
        this.id = CHART_ID;
        this.chartContainerId += CHART_ID;
        CHART_ID++;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set data(v) {
        this._data = v;
        if (this._isDataExists()) {
            this.hideTooltip();
            this._drawChart();
        }
        else {
            this._showEmptyText = true;
        }
    }
    get isMobile() {
        return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
    }
    get showHeader() {
        return !this.suppressHeader
            && this.header
            && this._isDataExists()
            && (!isUndefined(this.header.title)
                || !isUndefined(this.header.subtitle)
                || !isUndefined(this.header.allowHideLegend));
    }
    get showLegend() {
        return !this.isLegendHidden && !this.suppressLegend
            && (!isUndefined(this.legend) && !isUndefined(this.legend.items) && !!this.legend.items.length
                || !isUndefined(this.gradientLegend));
    }
    get chartWidth() {
        return isUndefined(this.width) ? this.currentContainerWidth : this.width;
    }
    get chartHeight() {
        return isUndefined(this.height) ? this.currentContainerHeight : this.height;
    }
    get transition() {
        return this._domSanitizer.bypassSecurityTrustStyle(`all ${ANIMATION_DURATION.fast}
      ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`);
    }
    get chartBottomPadding() {
        return this._chartBottomPadding;
    }
    set chartBottomPadding(value) {
        this._chartBottomPadding = value;
    }
    ngOnInit() {
        if (this.legend && this.legend.width) {
            this.legendWidth = this.legend.width;
        }
    }
    ngAfterViewInit() {
        timer(0, asapScheduler)
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            this.redrawChart();
        });
        if (!(this.width && this.height)) {
            if (this._showEmptyText) {
                this._drawEmptyText();
            }
        }
    }
    ngOnDestroy() {
        this._removeListeners();
        this._destroyed$.next(true);
        this._destroyed$.complete();
        this.hideTooltip();
    }
    redrawChart() {
        const { width, height } = this.chartContainerEl.nativeElement.getBoundingClientRect();
        if (this.header && isUndefined(this.header.allowHideLegend)) {
            this.header.allowHideLegend = true;
        }
        if (width && this._isDataExists()) {
            this.currentContainerWidth = width;
            this.currentContainerHeight = height;
            this._initChart();
        }
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    showTooltip(target, content, context, customCls, offset, sidePositionsFirst) {
        this.hideTooltip();
        this._ngZone.run(() => {
            if (target instanceof Element) {
                this._tooltipOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptTooltipComponent, null, this._injector), {
                    origin: target,
                    positionStrategy: 'connected',
                    scrollStrategy: 'close',
                    connectedPositions: this._getTooltipPositions(offset, sidePositionsFirst)
                });
            }
            else {
                this._tooltipOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptTooltipComponent, null, this._injector), {
                    origin: target,
                    positionStrategy: 'float',
                    scrollStrategy: 'close'
                });
                this._tooltipOverlayWithPortal.overlayRef.updatePosition();
            }
            this._tooltipOverlayWithPortal.componentRef.instance.content = content;
            this._tooltipOverlayWithPortal.componentRef.instance.visible = true;
            this._tooltipOverlayWithPortal.componentRef.instance.customCls = `${this._tooltipDefaultCustomCls} ` + customCls;
            if (context) {
                this._tooltipOverlayWithPortal.componentRef.instance.context = context;
            }
        });
    }
    hideTooltip() {
        if (this._tooltipOverlayWithPortal) {
            this._tooltipOverlayWithPortal.destroy();
            this._tooltipOverlayWithPortal = null;
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    updateTooltip(content, context) {
        if (this._tooltipOverlayWithPortal) {
            if (content) {
                this._tooltipOverlayWithPortal.componentRef.instance.content = content;
            }
            if (context) {
                this._tooltipOverlayWithPortal.componentRef.instance.context = context;
            }
            this._tooltipOverlayWithPortal.overlayRef.updatePosition();
        }
    }
    toggleLegend() {
        const { width } = this.chartAreaEl.nativeElement.getBoundingClientRect();
        let dim;
        this.isLegendHidden = !this.isLegendHidden;
        if (!this.isMobile) {
            dim = {
                w: width + (this.isLegendHidden ? this.legendWidth : -this.legendWidth),
                h: this.currentSVGHeight
            };
        }
        else {
            dim = {
                w: width,
                h: this.currentSVGHeight
            };
        }
        this._setChartSize(true, false);
        if (this.updateChart) {
            this.updateChart(dim);
        }
        if (!isUndefined(this.chartSliderCmp)) {
            this.chartSliderCmp.updateSlider(dim);
        }
        if (!isUndefined(this.areaChartSliderCmp)) {
            this.areaChartSliderCmp.updateSlider(dim);
        }
    }
    clear() {
        d3.select(`#${this.chartContainerId}`).selectAll('*').remove();
    }
    clickChartArea(e) {
        this.clickChart.emit(e);
    }
    updateLegend(items) {
        if (this.renderLegend) {
            this.legendComponent.update(items);
        }
    }
    getGroupAndDimensions() {
        const group = d3.select(`#${this.chartContainerId}`);
        this._setChartSize();
        return {
            group,
            w: this.currentSVGWidth,
            h: this.currentSVGHeight
        };
    }
    // Method creates hidden xAxis block to calculate maximum possible height.
    // Can be helpful when axis long titles need to be rotated
    updateChartBottomPadding(axisWidth, g, xAxis, rotateAxis = false) {
        if (!rotateAxis) {
            this.chartBottomPadding = 0;
            return;
        }
        const xScale = d3.scaleBand();
        xScale.range([0, axisWidth]).domain(xAxis.categories);
        const xScaleCall = d3.axisBottom(xScale).tickSizeOuter(0).tickPadding(12);
        g.select('g.fake-axis').remove();
        const axisBlock = g.append('g')
            .attr('class', 'fake-axis')
            .attr('style', 'display: none')
            .attr('aria-hidden', 'true')
            .call(xScaleCall);
        const textWidths = [];
        axisBlock.selectAll('text').each(function () {
            const text = d3.select(this);
            const length = text.node().getComputedTextLength();
            textWidths.push(length);
        });
        if (textWidths.length) {
            // TODO: Refactor this if possible
            // eslint-disable-next-line prefer-spread
            const largest = Math.max.apply(Math, textWidths);
            const diagonalHeight = largest > this.defaultMaxAxisWidth ? this.defaultMaxAxisWidth : largest;
            // Because we rotate string on 45 deg, we need to calculate height by Pythagoras theorem
            this.chartBottomPadding = Math.sqrt(Math.pow(diagonalHeight, 2) / 2);
        }
        else {
            this.chartBottomPadding = 0;
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    transformAxisTitles(axisBlock, shouldRotate) {
        const axisTexts = axisBlock.selectAll('text');
        axisTexts
            .style('text-anchor', shouldRotate ? 'end' : 'middle')
            .attr('dx', shouldRotate ? '-.8em' : '0')
            .attr('dy', shouldRotate ? '.15em' : '9')
            .attr('transform', shouldRotate ? 'rotate(-45)' : 'rotate(0)');
        if (shouldRotate) {
            axisTexts.call(textWrap, this.defaultMaxAxisWidth);
        }
    }
    _initChart() {
        this._setContainerSize();
        this._setChartSize();
        this._drawChart();
    }
    /**
     * This method manages the size of the main container element, dependently on
     * which size parameters have been set
     */
    _setContainerSize() {
        const { width, height } = this;
        this.currentContainerWidth = isUndefined(width) ? this.currentContainerWidth : width;
        this.currentContainerHeight = isUndefined(height) ? this.currentContainerHeight : height;
    }
    _setChartSize(recalculateWidth = true, recalculateHeight = true) {
        if (recalculateHeight) {
            const height = this.chartAreaEl.nativeElement.getBoundingClientRect().height;
            const sliderHeight = this.chartSliderEl.nativeElement.getBoundingClientRect().height;
            // @TODO: For area chart slider height is 0 on init, because of that chart height recalculate incorrectly when legend toggle
            this.currentSVGHeight = height - sliderHeight;
        }
        if (recalculateWidth) {
            const width = this.chartContainerEl.nativeElement.getBoundingClientRect().width;
            this.currentSVGWidth = width - (this.showLegend && !this.isMobile ? this.legendWidth : 0);
        }
    }
    _drawChart() {
        if (!this.dataBuilder) {
            return;
        }
        const options = this.getGroupAndDimensions();
        options.group.selectAll('*').remove();
        this.dataBuilder(options.group, {
            w: options.w,
            h: options.h
        });
    }
    _isDataExists() {
        return !isUndefined(this._data) && !isNull(this._data);
    }
    _drawEmptyText() {
        const group = d3.select(`#${this.chartContainerId}`);
        group.append('text')
            .attr('text-anchor', 'middle')
            .style('transform', 'translate(50%, 50%)')
            .style('font-size', '13px')
            .style('fill', 'currentcolor')
            .classed('text-default', true)
            .text(this.noDataText || this._emptyText);
    }
    _removeListeners() {
        if (this._removeClickEventListener) {
            this._removeClickEventListener();
        }
        if (this._removeScrollEventListener) {
            this._removeScrollEventListener();
        }
    }
    _getTooltipPositions(offset, sidePositionsFirst) {
        if (isNumber(offset) && (offset !== this._tooltipOverlayDefaultOffset)) {
            this._tooltipOverlayDefaultOffset = offset;
            this._tooltipOverlayPlacements.top.offsetY = -this._tooltipOverlayDefaultOffset;
            this._tooltipOverlayPlacements.bottom.offsetY = this._tooltipOverlayDefaultOffset;
            this._tooltipOverlayPlacements.left.offsetX = -this._tooltipOverlayDefaultOffset;
            this._tooltipOverlayPlacements.right.offsetX = this._tooltipOverlayDefaultOffset;
        }
        return sidePositionsFirst ?
            [
                this._tooltipOverlayPlacements.right,
                this._tooltipOverlayPlacements.left,
                this._tooltipOverlayPlacements.top,
                this._tooltipOverlayPlacements.bottom
            ] :
            [
                this._tooltipOverlayPlacements.top,
                this._tooltipOverlayPlacements.bottom,
                this._tooltipOverlayPlacements.left,
                this._tooltipOverlayPlacements.right
            ];
    }
}
AdaptChartComponent.ɵfac = function AdaptChartComponent_Factory(t) { return new (t || AdaptChartComponent)(i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i2.Directionality), i0.ɵɵdirectiveInject(i3.DomSanitizer), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptOverlayService)); };
AdaptChartComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptChartComponent, selectors: [["adapt-chart"]], contentQueries: function AdaptChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, AdaptChartSliderComponent, 5);
        i0.ɵɵcontentQuery(dirIndex, AdaptAreaGraphSliderComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartSliderCmp = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.areaChartSliderCmp = _t.first);
    } }, viewQuery: function AdaptChartComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 5);
        i0.ɵɵviewQuery(_c3, 5);
        i0.ɵɵviewQuery(_c4, 5);
        i0.ɵɵviewQuery(_c5, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartContainerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartAreaEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.svgContainerEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.legendEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.legendComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartSliderEl = _t.first);
    } }, inputs: { title: "title", description: "description", backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", renderLegend: "renderLegend", gradientLegend: "gradientLegend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", noDataText: "noDataText", dataBuilder: "dataBuilder", updateChart: "updateChart", colorsPalette: "colorsPalette", topSectionTemplate: "topSectionTemplate", data: "data" }, outputs: { categoryShow: "categoryShow", categoryHide: "categoryHide", categoryEnter: "categoryEnter", categoryLeave: "categoryLeave", categoryMove: "categoryMove", clickChart: "clickChart" }, features: [i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 35, vars: 17, consts: [[1, "adapt-chart", 3, "click"], ["chartContainer", ""], ["class", "adapt-chart-header", 4, "ngIf"], [4, "ngTemplateOutlet"], [1, "adapt-chart-body"], [1, "adapt-chart-zone"], ["chartArea", ""], ["xmlns", "http://www.w3.org/2000/svg", "class", "adapt-chart-svg", "tabindex", "0", "role", "graphic/image", 3, "transition", 4, "ngIf"], [1, "adapt-chart-slider-wrapper"], ["chartSlider", ""], ["class", "adapt-legend-zone", 3, "width", "transition", "ngClass", 4, "ngIf"], [1, "adapt-chart-header"], ["class", "adapt-chart-header-title m-0", 4, "ngIf"], ["class", "adapt-chart-context-menu-btn", "role", "button", 3, "click", 4, "ngIf"], [1, "adapt-chart-header-title", "m-0"], ["role", "button", 1, "adapt-chart-context-menu-btn", 3, "click"], ["xmlns", "http://www.w3.org/2000/svg", "tabindex", "0", "role", "graphic/image", 1, "adapt-chart-svg"], ["svgContainer", ""], ["id", "desc"], [1, "adapt-chart-group"], [1, "adapt-legend-zone", 3, "ngClass"], [3, "containerWidth", "increaseColor", "decreaseColor", "zeroColor", "increaseText", "decreaseText", "zeroText", "height", "focusable"], ["legend", ""], [3, "focusable", "activeHover", "activeClick", "customColors", "items", "width", "columns", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave", "categoryMove"], ["legendComponent", ""]], template: function AdaptChartComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c7);
        i0.ɵɵelementStart(0, "div");
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelementStart(2, "div", 0, 1);
        i0.ɵɵlistener("click", function AdaptChartComponent_Template_div_click_2_listener($event) { return ctx.clickChartArea($event); });
        i0.ɵɵtext(4, "\n\n    ");
        i0.ɵɵtemplate(5, AdaptChartComponent_div_5_Template, 6, 2, "div", 2);
        i0.ɵɵtext(6, "\n\n    ");
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵtemplate(8, AdaptChartComponent_ng_container_8_Template, 1, 0, "ng-container", 3);
        i0.ɵɵtext(9, "\n\n    ");
        i0.ɵɵelementStart(10, "div", 4);
        i0.ɵɵtext(11, "\n      ");
        i0.ɵɵelementStart(12, "div", 5, 6);
        i0.ɵɵtext(14, "\n        ");
        i0.ɵɵprojection(15);
        i0.ɵɵtext(16, "\n        ");
        i0.ɵɵtemplate(17, AdaptChartComponent__svg_svg_17_Template, 8, 10, "svg", 7);
        i0.ɵɵtext(18, "\n        ");
        i0.ɵɵelementStart(19, "div", 8, 9);
        i0.ɵɵtext(21, "\n          ");
        i0.ɵɵprojection(22, 1);
        i0.ɵɵtext(23, "\n          ");
        i0.ɵɵprojection(24, 2);
        i0.ɵɵtext(25, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(26, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(27, "\n      ");
        i0.ɵɵtemplate(28, AdaptChartComponent_div_28_Template, 5, 16, "div", 10);
        i0.ɵɵtext(29, "\n      ");
        i0.ɵɵtemplate(30, AdaptChartComponent_div_30_Template, 7, 15, "div", 10);
        i0.ɵɵtext(31, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(32, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(33, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(34, "\n");
    } if (rf & 2) {
        i0.ɵɵstyleProp("height", ctx.chartHeight + ctx.chartBottomPadding, "px");
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("width", ctx.chartWidth, "px")("height", ctx.chartHeight, "px");
        i0.ɵɵclassProp("adapt-chart-mobile", ctx.isMobile);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.showHeader);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngTemplateOutlet", ctx.topSectionTemplate);
        i0.ɵɵadvance(4);
        i0.ɵɵstyleProp("width", 0, "px")("background-color", ctx.$this.backgroundColor);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.dataBuilder);
        i0.ɵɵadvance(11);
        i0.ɵɵproperty("ngIf", ctx.gradientLegend);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.legend && ctx.renderLegend);
    } }, directives: [i4.NgIf, i4.NgTemplateOutlet, i4.NgClass, i5.ChartGradientLegendComponent, i6.ChartLegendComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptChartComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-chart',
                templateUrl: './chart.component.html',
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.AdaptDeviceDetectionService }, { type: i2.Directionality }, { type: i3.DomSanitizer }, { type: i0.Injector }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i1.AdaptOverlayService }]; }, { title: [{
            type: Input
        }], description: [{
            type: Input
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], legend: [{
            type: Input
        }], renderLegend: [{
            type: Input
        }], gradientLegend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], updateChart: [{
            type: Input
        }], colorsPalette: [{
            type: Input
        }], topSectionTemplate: [{
            type: Input
        }], data: [{
            type: Input
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], categoryEnter: [{
            type: Output
        }], categoryLeave: [{
            type: Output
        }], categoryMove: [{
            type: Output
        }], clickChart: [{
            type: Output
        }], chartContainerEl: [{
            type: ViewChild,
            args: ['chartContainer', { static: true }]
        }], chartAreaEl: [{
            type: ViewChild,
            args: ['chartArea', { static: true }]
        }], svgContainerEl: [{
            type: ViewChild,
            args: ['svgContainer', { static: false }]
        }], legendEl: [{
            type: ViewChild,
            args: ['legend', { static: false }]
        }], legendComponent: [{
            type: ViewChild,
            args: ['legendComponent', { static: false }]
        }], chartSliderEl: [{
            type: ViewChild,
            args: ['chartSlider', { static: true }]
        }], chartSliderCmp: [{
            type: ContentChild,
            args: [AdaptChartSliderComponent, { static: false }]
        }], areaChartSliderCmp: [{
            type: ContentChild,
            args: [AdaptAreaGraphSliderComponent, { static: false }]
        }] }); })();
//# sourceMappingURL=chart.component.js.map