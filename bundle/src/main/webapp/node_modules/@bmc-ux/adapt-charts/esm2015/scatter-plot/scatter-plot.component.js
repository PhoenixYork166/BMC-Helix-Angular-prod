import { Component, EventEmitter, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import BigNumber from 'bignumber.js';
// eslint-disable-next-line no-duplicate-imports, @typescript-eslint/no-unused-vars
import * as d3 from 'd3';
import { CutNumberPipe } from '../common/pipes/cut-number.pipe';
import { ChartColorService } from '../common/services/chart-color.service';
import { AdaptChartComponent } from '../common/chart.component';
import { AdaptDeviceDetectionService, ANIMATION_DURATION, ColorType } from '@bmc-ux/adapt-angular';
import { AdaptScatterPlotAbstract } from '../common/models/scatter-plot.model';
import * as i0 from "@angular/core";
import * as i1 from "../common/pipes/cut-number.pipe";
import * as i2 from "@bmc-ux/adapt-angular";
import * as i3 from "../common/services/chart-color.service";
import * as i4 from "../common/chart.component";
const _c0 = ["tooltipTpl"];
function AdaptScatterPlotComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 2);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "div", 3);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelement(5, "span", 4);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementStart(7, "span", 5);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementStart(11, "div");
    i0.ɵɵtext(12);
    i0.ɵɵelementStart(13, "span");
    i0.ɵɵelementStart(14, "b");
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n\n    ");
    i0.ɵɵelementStart(18, "div");
    i0.ɵɵtext(19);
    i0.ɵɵelementStart(20, "span");
    i0.ɵɵelementStart(21, "b");
    i0.ɵɵtext(22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n");
} if (rf & 2) {
    const data_r2 = ctx.data;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵstyleProp("background", data_r2 == null ? null : data_r2.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r2 == null ? null : data_r2.category);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r1.xAxis == null ? null : ctx_r1.xAxis.title, ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r2.xValue);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r1.yAxis == null ? null : ctx_r1.yAxis.title, ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r2.yValue);
} }
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export class AdaptScatterPlotComponent extends AdaptScatterPlotAbstract {
    constructor(_cutNumber, _deviceDetectionService, _colorService) {
        super();
        this._cutNumber = _cutNumber;
        this._deviceDetectionService = _deviceDetectionService;
        this._colorService = _colorService;
        this.alreadyChanged = false;
        this.scientificMode = false;
        this.clickChart = new EventEmitter();
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
        this._series = [];
        this._margin = {
            top: 0,
            right: 0,
            bottom: 25,
            left: 30
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._colors = [];
        this._axisShift = {
            top: 0,
            right: 0,
            bottom: 25,
            left: 25
        };
        this._axisScientificLeftShift = 60;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._generatedData = [];
        this._isDeselected = [];
        this._legend = {
            columns: 1,
            activeHover: true,
            activeClick: true,
            width: 250,
            customColors: null,
            items: []
        };
        this._updateChart = (dim) => {
            this._updatedScatterChart(dim);
        };
        this._dataBuilder = (g, dim) => {
            this._g = g;
            this._dim = dim;
            this._initAxis(g, dim);
            this._drawLines(g);
            this._drawDropShadow();
        };
    }
    set series(s) {
        this._series = s;
        this._isDeselected = [];
        s.forEach(series => {
            if (series.hidden) {
                this._isDeselected.push(series.name);
            }
        });
        if (this.alreadyChanged) {
            const options = this.chartComponent.getGroupAndDimensions();
            this._g = options.group;
            this._dim = {
                w: options.w,
                h: options.h
            };
        }
        if (this._g && this._dim && this.chartComponent) {
            this.chartComponent.updateLegend(this.series.map((item) => item.name));
        }
    }
    get series() {
        return this._series;
    }
    set legend(legend) {
        this._legend = Object.assign(this._legend, legend);
        if (this.alreadyChanged) {
            this.chartComponent.redrawChart();
        }
    }
    get legend() {
        return {
            customColors: this._legend.customColors,
            activeHover: this._legend.activeHover,
            activeClick: this._legend.activeClick,
            columns: this._legend.columns,
            width: this._legend.width,
            items: (this.series && this.series.map((series) => ({
                item: series.name,
                hidden: !!series.hidden
            })))
        };
    }
    get duration() {
        return parseFloat(ANIMATION_DURATION.fast) * 1000;
    }
    get axisShiftLeft() {
        return this.scientificMode ? this._axisScientificLeftShift : this._axisShift.left;
    }
    ngOnInit() {
        if (this.isMobile()) {
            this._margin.left = 40;
        }
        if (this.xAxis && this.xAxis.title) {
            this._margin.bottom += this._axisShift.bottom;
        }
        if (this.yAxis && this.yAxis.title) {
            this._margin.left += this.axisShiftLeft;
        }
        this.alreadyChanged = true;
    }
    isMobile() {
        return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
    }
    categoryShowHandler(category) {
        const ind = this._isDeselected.indexOf(category);
        if (ind !== -1) {
            this._isDeselected.splice(ind, 1);
        }
        this._updatedScatterChart(this._dim);
        this.series.forEach((item, index) => {
            if (item.name.indexOf(category) !== -1) {
                item.hidden = false;
                this._g
                    .select(`[data-line-graph-id='${index}']`)
                    .style('transition', 'all .3s ease')
                    .style('opacity', '1')
                    .style('visibility', 'visible')
                    .attr('data-disabled', 'false');
            }
        });
        this.categoryShow.emit({ category });
    }
    categoryHideHandler(category) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        this._isDeselected.push(category);
        this.series.forEach((item, index) => {
            if (item.name.indexOf(category) !== -1) {
                item.hidden = true;
                this._g
                    .select(`[data-line-graph-id='${index}']`)
                    .style('transition', 'all .3s ease')
                    .style('opacity', '0')
                    .style('visibility', 'hidden');
            }
        });
        d3.selectAll('.scatter-regression-line')
            .each(function () {
            if (d3.select(this).attr('id') === _self._highLightColor) {
                _self._regLine = d3.select(this);
                _self._regLine
                    .style('visibility', 'hidden')
                    .style('opacity', '0');
            }
        });
        this._updatedScatterChart(this._dim);
        this.categoryHide.emit({ category });
    }
    categoryEnter(categoryEvent) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        const ind = this._isDeselected.indexOf(this.series[categoryEvent.id].name);
        if (ind === -1) {
            const selectedLine = this._g.select(`[data-line-graph-id='${categoryEvent.id}']  .scatter-plot-circle`);
            const colorLine = selectedLine.attr('fill');
            const colorHexLine = _self._colorService.getDarken(colorLine, .22, ColorType.HEX);
            this._highLightColor = colorLine;
            d3.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                if (d3.select(this).attr('fill').toLowerCase().trim() !== colorLine.toLowerCase().trim()) {
                    d3.select(this).classed('scatter-transition', true).attr('r', 3.5);
                }
            });
            d3.selectAll('.scatter-chart-line-g').each(function () {
                if (d3.select(this).attr('id').toLowerCase().trim() === colorLine.toLowerCase().trim() &&
                    this.nextElementSibling !== null) {
                    this.parentNode.appendChild(this);
                }
            });
            d3.selectAll('.scatter-regression-line').each(function () {
                if (d3.select(this).attr('id').toLowerCase().trim() === colorLine.toLowerCase().trim()) {
                    _self._regLine = d3.select(this);
                    _self._regLine
                        .style('visibility', 'visible')
                        .attr('stroke', colorHexLine)
                        .style('opacity', '1');
                }
            });
        }
    }
    categoryLeave() {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        d3.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
            var _a;
            if (d3.select(this).attr('fill').toLowerCase().trim() !== ((_a = _self._highLightColor) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim())) {
                d3.select(this).classed('scatter-transition', false).attr('r', 5);
            }
        });
        if (this._regLine) {
            this._regLine
                .attr('stroke', this._highLightColor)
                .style('visibility', 'hidden')
                .style('opacity', '0');
        }
    }
    _getCustomColorById(id) {
        const customColors = this.legend.customColors;
        const len = customColors.length;
        const index = id % len;
        return customColors[index];
    }
    _updatedScatterChart(dim) {
        this._generatedData = [];
        this._updateAxis(dim);
        this._updateDataLines();
    }
    _initAxis(g, dim) {
        this._generatedData = [];
        if (this.series) {
            this.series.forEach(dt => dt.data.map(d => this._generatedData.push({ data1: d[0], data2: d[1] })));
            if (this.yAxis && this.yAxis.title) {
                g.append('g')
                    .attr('class', 'adapt-chart-axis-title')
                    .attr('transform', `rotate(-90) translate(-${(dim.h - this._axisShift.bottom) / 2} ${this.axisShiftLeft / 4})`)
                    .append('text')
                    .text(this.yAxis.title)
                    .attr('text-anchor', 'middle')
                    .attr('transform', `translate(${(this._axisShift.bottom / 2)} 0)`);
            }
            if (this.xAxis && this.xAxis.title) {
                g.append('g')
                    .attr('class', 'adapt-chart-axis-title adapt-chart-axis-title--x')
                    .attr('transform', `translate(${(dim.w + this.axisShiftLeft) / 2} ${dim.h})`)
                    .append('text')
                    .text(this.xAxis.title)
                    .attr('text-anchor', 'middle')
                    .attr('transform', `translate(${(this.axisShiftLeft)} 0)`);
            }
            this._x = d3
                .scaleLinear()
                .domain([d3.min(this._generatedData, (d) => d.data1), d3.max(this._generatedData, (d) => d.data1)])
                .range([0, dim.w - (this._margin.left + this._margin.right)]);
            this._y = d3
                .scaleLinear()
                .domain([d3.min(this._generatedData, (d) => d.data2), d3.max(this._generatedData, (d) => d.data2)])
                .range([dim.h - this._margin.top - this._margin.bottom, 0]);
            g.append('g')
                .attr('class', 'axis axis--y')
                .attr('transform', `translate(${this._margin.left}, 0)`)
                .transition()
                .duration(this.duration)
                .call(d3.axisLeft(this._y)
                .ticks(7)
                .tickPadding(10)
                .tickFormat((d) => this._getTickFormatForNumber(d))
                .tickSize(-dim.w + (this._margin.left + this._margin.right))
                .tickSizeOuter(0));
            g.append('g')
                .attr('class', 'axis axis--x')
                .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`)
                .transition()
                .duration(this.duration)
                .call(d3.axisBottom(this._x)
                .tickPadding(10)
                .tickFormat((d) => this._getTickFormatForNumber(d))
                .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
                .tickSizeOuter(0));
            const xAxis = this._generatedData.map(d => d.data1);
            const yAxis = this._generatedData.map(d => d.data2);
            const regression = this._leastSquaresequation(xAxis, yAxis);
            this._line = d3.line()
                .x((d) => this._x(d['data1']))
                .y((d) => this._y(regression(d['data1'])));
        }
    }
    _updateAxis(dim) {
        this.series.forEach(dt => dt.data.map(d => {
            if (this._isDeselected.indexOf(dt.name) === -1) {
                return this._generatedData.push({ data1: d[0], data2: d[1] });
            }
        }));
        this._g.select('.adapt-chart-axis-title--x')
            .transition()
            .duration(this.duration)
            .attr('transform', `translate(${(dim.w + this.axisShiftLeft) / 2} ${dim.h})`);
        this._x = d3
            .scaleLinear()
            .domain([d3.min(this._generatedData, (d) => d.data1), d3.max(this._generatedData, (d) => d.data1)])
            .range([0, dim.w - (this._margin.left + this._margin.right)]);
        this._g.select('.axis--x')
            .transition()
            .duration(this.duration)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`)
            .call(d3.axisBottom(this._x)
            .tickPadding(10)
            .tickFormat((d) => this._getTickFormatForNumber(d))
            .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
            .tickSizeOuter(0));
        this._y = d3
            .scaleLinear()
            .domain([d3.min(this._generatedData, (d) => d.data2), d3.max(this._generatedData, (d) => d.data2)])
            .range([dim.h - this._margin.top - this._margin.bottom, 0]);
        this._g.select('.axis--y')
            .transition()
            .duration(this.duration)
            .attr('transform', `translate(${this._margin.left}, 0)`)
            .call(d3.axisLeft(this._y)
            .ticks(7)
            .tickPadding(10)
            .tickFormat((d) => this._getTickFormatForNumber(d))
            .tickSize(-dim.w + (this._margin.left + this._margin.right))
            .tickSizeOuter(0));
        const xAxis = this._generatedData.map(d => d.data1);
        const yAxis = this._generatedData.map(d => d.data2);
        const regression = this._leastSquaresequation(xAxis, yAxis);
        this._line = d3.line()
            .x((d) => this._x(d['data1']))
            .y((d) => this._y(regression(d['data1'])));
    }
    _updateDataLines() {
        this._g.selectAll('.scatter-plot-circle').attr('cx', (d) => this._x(d.data1)).attr('cy', (d) => this._y(d.data2));
        this._g.selectAll('.scatter-regression-line').attr('d', this._line);
    }
    _drawLines(g) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        let baseColor;
        let colorHex;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        let regLine;
        let colorHexLine;
        this._gW = g.append('g')
            .attr('transform', `translate(${this._margin.left}, 0)`);
        if (this.series) {
            this._colors = [];
            this.series.map((dt, i) => this._colors.push(this.legend.customColors ? this._getCustomColorById(i) : this._colorService.getColor(i)));
            this.series.forEach((dt, i) => {
                this._generatedData = dt.data.map(d => {
                    return {
                        data1: d[0],
                        data2: d[1]
                    };
                });
                g.append('g')
                    .attr('transform', `translate(${this._margin.left}, 0)`)
                    .append('path')
                    .datum(this._generatedData)
                    .attr('id', this._colors[i])
                    .attr('stroke', this._colors[i])
                    .attr('fill', 'none')
                    .attr('stroke-width', '2px')
                    .classed('scatter-regression-line', true)
                    .style('opacity', '0')
                    .style('visibility', 'hidden')
                    .attr('d', this._line);
                const lineWrapper = this._gW
                    .append('g')
                    .attr('class', 'scatter-chart-line-g')
                    .style('opacity', dt.hidden ? 0 : 1)
                    .style('visibility', dt.hidden ? 'hidden' : 'visible')
                    .attr('id', this._colors[i])
                    .attr('data-line-graph-id', i);
                lineWrapper
                    .append('g')
                    .attr('class', 'scatter-plot-circle-wrapper')
                    .attr('id', this._colors[i])
                    .selectAll('dots')
                    .data(this._generatedData)
                    .enter()
                    .append('circle')
                    .attr('r', 5)
                    .attr('class', 'scatter-plot-circle')
                    .attr('fill', this._colors[i])
                    .attr('cx', (d) => this._x(d.data1))
                    .attr('cy', (d) => this._y(d.data2))
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    .on('mouseover', function (d) {
                    const __this = d3.select(this);
                    baseColor = __this.attr('fill');
                    colorHex = _self._colorService.getDarken(baseColor, .15, ColorType.HEX);
                    colorHexLine = _self._colorService.getDarken(baseColor, .22, ColorType.HEX);
                    d3.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                        if (d3.select(this).attr('fill') !== baseColor) {
                            d3.select(this)
                                .classed('scatter-transition', true)
                                .attr('r', 3.5);
                        }
                    });
                    d3.selectAll('.scatter-chart-line-g').each(function () {
                        if (d3.select(this).attr('id') === baseColor && this.nextElementSibling !== null) {
                            this.parentNode.appendChild(this);
                        }
                    });
                    d3.selectAll('.scatter-regression-line').each(function () {
                        if (d3.select(this).attr('id').toLowerCase().trim() === baseColor.toLowerCase().trim()) {
                            regLine = d3.select(this);
                            regLine
                                .style('visibility', 'visible')
                                .attr('stroke', colorHexLine)
                                .style('opacity', '1');
                        }
                    });
                    __this
                        .attr('r', 7)
                        .style('opacity', '1')
                        .style('filter', 'url(#drop-shadow)')
                        .attr('fill', colorHex);
                    _self.chartComponent.showTooltip(d3.event.target, _self.tooltipTemplate, {
                        data: {
                            color: baseColor,
                            category: dt.name,
                            xValue: _self.scientificMode ? new BigNumber(d.data1).toPrecision(2, 2) : d.data1,
                            yValue: _self.scientificMode ? new BigNumber(d.data2).toPrecision(2, 2) : d.data2,
                        }
                    });
                })
                    .on('mouseout', function () {
                    d3.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                        if (d3.select(this).attr('fill').toLowerCase().trim() !== baseColor.toLowerCase().trim()) {
                            d3.select(this)
                                .classed('scatter-transition', false)
                                .attr('r', 5);
                        }
                    });
                    regLine
                        .attr('stroke', baseColor)
                        .style('visibility', 'hidden')
                        .style('opacity', '0');
                    d3.select(this)
                        .style('opacity', '.8')
                        .style('filter', null)
                        .attr('fill', baseColor);
                    _self.chartComponent.hideTooltip();
                });
            });
        }
    }
    /**
     * http://bl.ocks.org/tommyogden/f416a5c27971908845a9
     */
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _leastSquaresequation(xAxisData, yAxisData) {
        const ReduceAddition = (prev, cur) => prev + cur;
        // finding the mean of Xaxis and Yaxis data
        const xBar = xAxisData.reduce(ReduceAddition) * 1.0 / xAxisData.length;
        const yBar = yAxisData.reduce(ReduceAddition) * 1.0 / yAxisData.length;
        const SquareXX = xAxisData.map(d => Math.pow(d - xBar, 2)).reduce(ReduceAddition);
        // const ssYY = yAxisData.map(d => Math.pow(d - yBar, 2)).reduce(ReduceAddition);
        const MeanDiffXY = xAxisData.map((d, i) => (d - xBar) * (yAxisData[i] - yBar)).reduce(ReduceAddition);
        const slope = MeanDiffXY / SquareXX;
        const intercept = yBar - (xBar * slope);
        // returning regression function
        return function (x) {
            return x * slope + intercept;
        };
    }
    _drawDropShadow() {
        const defs = this._g
            .append('defs');
        const filter = defs
            .append('filter')
            .attr('id', 'drop-shadow')
            .attr('x', '-50%')
            .attr('y', '-50%')
            .attr('width', '180%')
            .attr('height', '180%')
            .attr('filterUnits', 'userSpaceOnUse');
        filter
            .append('feGaussianBlur')
            .attr('in', 'SourceAlpha')
            .attr('stdDeviation', 3);
        filter
            .append('feOffset')
            .attr('dx', 0)
            .attr('dy', 1)
            .attr('result', 'offsetblur');
        filter
            .append('feOffset')
            .attr('dx', 0)
            .attr('dy', 2)
            .attr('result', 'offsetblur');
        filter
            .append('feColorMatrix')
            .attr('type', 'matrix')
            .attr('values', '0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.22 0');
        const feMerge = filter
            .append('feMerge');
        feMerge
            .append('feMergeNode');
        feMerge
            .append('feMergeNode')
            .attr('in', 'SourceGraphic');
        feMerge
            .append('feMergeNode')
            .attr('in', 'SourceGraphic');
    }
    _getTickFormatForNumber(d) {
        return this.scientificMode
            ? new BigNumber(d).toPrecision(2, 2)
            : this._cutNumber.transform(d, 0);
    }
}
AdaptScatterPlotComponent.ɵfac = function AdaptScatterPlotComponent_Factory(t) { return new (t || AdaptScatterPlotComponent)(i0.ɵɵdirectiveInject(i1.CutNumberPipe), i0.ɵɵdirectiveInject(i2.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i3.ChartColorService)); };
AdaptScatterPlotComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptScatterPlotComponent, selectors: [["adapt-scatter-plot"]], viewQuery: function AdaptScatterPlotComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", series: "series", xAxis: "xAxis", yAxis: "yAxis", noDataText: "noDataText", legend: "legend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", updateChart: "updateChart", scientificMode: "scientificMode" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵProvidersFeature([CutNumberPipe]), i0.ɵɵInheritDefinitionFeature], decls: 5, vars: 11, consts: [[3, "width", "height", "header", "data", "dataBuilder", "legend", "updateChart", "backgroundColor", "suppressHeader", "suppressLegend", "noDataText", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], ["tooltipTpl", ""], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptScatterPlotComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "adapt-chart", 0);
        i0.ɵɵlistener("categoryShow", function AdaptScatterPlotComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptScatterPlotComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptScatterPlotComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptScatterPlotComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptScatterPlotComponent_ng_template_2_Template, 26, 7, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(4, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("width", ctx.width)("height", ctx.height)("header", ctx.header)("data", ctx.series)("dataBuilder", ctx._dataBuilder)("legend", ctx.legend)("updateChart", ctx._updateChart)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("noDataText", ctx.noDataText);
    } }, directives: [i4.AdaptChartComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptScatterPlotComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-scatter-plot',
                templateUrl: './scatter-plot.component.html',
                providers: [CutNumberPipe],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.CutNumberPipe }, { type: i2.AdaptDeviceDetectionService }, { type: i3.ChartColorService }]; }, { backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], series: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], legend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], updateChart: [{
            type: Input
        }], scientificMode: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], tooltipTemplate: [{
            type: ViewChild,
            args: ['tooltipTpl', { static: true }]
        }], chartComponent: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }] }); })();
//# sourceMappingURL=scatter-plot.component.js.map