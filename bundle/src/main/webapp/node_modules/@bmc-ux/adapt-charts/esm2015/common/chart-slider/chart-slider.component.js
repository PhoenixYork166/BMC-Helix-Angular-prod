import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, Output, Renderer2, ViewChild, ViewEncapsulation } from '@angular/core';
import { ReplaySubject } from 'rxjs';
import { SafeCdr } from '@bmc-ux/adapt-angular';
import { AdaptChartSliderType } from '../models/chart.model';
import { AdaptStackedChartAbstract, AdaptStackedChartType } from '../models/stacked-chart.model';
import * as i0 from "@angular/core";
const _c0 = ["chart"];
const _c1 = ["slider"];
const _c2 = ["dnd"];
const _c3 = ["overlay"];
const _c4 = ["overlayLeft"];
const _c5 = ["overlayRight"];
const _c6 = function () { return {}; };
function AdaptChartSliderComponent_ng_container_14_adapt_stacked_chart_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "adapt-stacked-chart", 11, 12);
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("suppressHeader", true)("suppressLegend", true)("renderLegend", false)("showEmptyColIndicator", false)("legend", null)("hideAxises", true)("xAxis", ctx_r6.xAxis)("yAxis", i0.ɵɵpureFunction0(12, _c6))("series", ctx_r6.data)("height", ctx_r6.height - ctx_r6.sliderPaddingTop)("type", ctx_r6.stackedChartType)("seriesDisplay", ctx_r6.stackedChart && ctx_r6.stackedChart.seriesDisplay);
} }
function AdaptChartSliderComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0, 9);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptChartSliderComponent_ng_container_14_adapt_stacked_chart_2_Template, 2, 13, "adapt-stacked-chart", 10);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngSwitch", ctx_r3.type);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngSwitchCase", ctx_r3.chartSliderType.bar);
} }
let id = 0;
const classPrefix = 'adapt-chart-slider';
const sliderPaddingTop = 10;
export class AdaptChartSliderComponent {
    constructor(_elementRef, _renderer, _changeDetectorRef) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.chartSliderType = AdaptChartSliderType;
        this.stackedChartType = AdaptStackedChartType.Column;
        this.isActive = false;
        this.sliderSpotWidth = 50;
        this.initComplete = false;
        this.height = 45;
        // TODO: has to be refactored
        this.leftShift = 0;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.rangeChanged = new EventEmitter();
        this._inMotion = false;
        this._categoryFilter = [];
        this._x = 0;
        this._destroyed$ = new ReplaySubject(1);
        id++;
        this.id = id;
        this.classPrefix = classPrefix;
        this.sliderPaddingTop = sliderPaddingTop;
    }
    get overlayLeftWidth() {
        const sliderLeft = this._sliderEl.nativeElement.getBoundingClientRect().left;
        const { left } = this._dndEl.nativeElement.getBoundingClientRect();
        return left - sliderLeft;
    }
    get overlayRightWidth() {
        const sliderLeft = this._sliderEl.nativeElement.getBoundingClientRect().left;
        const sliderWidth = this._sliderEl.nativeElement.getBoundingClientRect().width;
        const { left, width } = this._dndEl.nativeElement.getBoundingClientRect();
        return sliderWidth - (left - sliderLeft) - width;
    }
    ngOnInit() {
        this._dataCopy = this.data.slice();
        this._bodyMouseMoveLn = this._renderer.listen('body', 'mousemove', (e) => {
            if (this._inMotion) {
                const { clientX } = e;
                const { width } = this._dndEl.nativeElement.getBoundingClientRect();
                const sliderWidth = this._sliderEl.nativeElement.getBoundingClientRect().width;
                let x = clientX - this._sliderEl.nativeElement.getBoundingClientRect().left - this._gap;
                x = x < 0 ? 0 : x;
                x = x > sliderWidth - width ? sliderWidth - width : x;
                this._updateOverlay(x);
            }
        });
        this._bodyMouseUpLn = this._renderer.listen('body', 'mouseup', (e) => {
            const { target } = e;
            if (target !== this._dndEl.nativeElement) {
                this.isActive = false;
            }
            this._inMotion = false;
        });
    }
    ngAfterViewInit() {
        const { width } = this._sliderEl.nativeElement.getBoundingClientRect();
        const dataLength = this._getDataLength();
        const monitorsCount = Math.ceil(dataLength / this.slidePointsCount);
        this.monitorsCount = monitorsCount;
        this._width = width;
        this.sliderSpotWidth = width / monitorsCount;
        this._updateOverlay(0);
        this.initComplete = true;
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
        this._bodyMouseMoveLn();
        this._bodyMouseUpLn();
    }
    onMouseDown(e) {
        const { clientX, target } = e;
        const { left } = target.getBoundingClientRect();
        this._gap = Math.floor(clientX - left);
        this._inMotion = true;
    }
    onMouseOver() {
        this.isActive = true;
    }
    onMouseOut() {
        if (!this._inMotion) {
            this.isActive = false;
        }
    }
    onSliderShift(shiftBack) {
        const indicatorCS = getComputedStyle(this._overlayEl.nativeElement);
        const indicatorWidth = parseInt(indicatorCS.width, 10);
        const indicatorLeft = parseInt(indicatorCS.left, 10);
        const sliderWidth = parseInt(getComputedStyle(this._sliderEl.nativeElement).width, 10);
        let newX;
        if (shiftBack) {
            newX = indicatorLeft - indicatorWidth;
            if (newX < 0) {
                newX = 0;
            }
        }
        else {
            newX = indicatorLeft + indicatorWidth;
            if (newX + indicatorWidth > sliderWidth) {
                newX = sliderWidth - indicatorWidth;
            }
        }
        this._updateOverlay(newX);
    }
    onClickSliderArea(e) {
        if (this.isActive) {
            return;
        }
        const { clientX } = e;
        const { left, width } = this._sliderEl.nativeElement.getBoundingClientRect();
        let newLeftSpotPosition = clientX - left - this.sliderSpotWidth / 2;
        newLeftSpotPosition = newLeftSpotPosition < 0 ? 0 : newLeftSpotPosition;
        newLeftSpotPosition = newLeftSpotPosition > width - this.sliderSpotWidth ? width - this.sliderSpotWidth : newLeftSpotPosition;
        this._updateOverlay(newLeftSpotPosition);
    }
    updateSlider(dim) {
        const { height } = this._sliderEl.nativeElement.getBoundingClientRect();
        this._chartComponent.chartComponent.updateChart({
            w: dim.w - this.leftShift,
            h: height - this.sliderPaddingTop * 2
        });
    }
    showCategory(category) {
        const categoryId = this._categoryFilter.indexOf(category);
        if (categoryId !== -1) {
            this._categoryFilter.splice(categoryId, 1);
        }
        this._updateData();
    }
    hideCategory(category) {
        this._categoryFilter.push(category);
        this._updateData();
    }
    _getDataLength() {
        // TODO check for fix
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        return this.data[0].data.length;
    }
    _updateOverlay(x = this._x) {
        if (x !== this._x) {
            this._x = x;
            this._recalculateDataRange();
        }
        this._recalculateSpotPosition();
    }
    _updateData() {
        const timer = setTimeout(() => {
            this.data = this._dataCopy.map((item) => {
                const { name } = item;
                let { data } = item;
                if (this._categoryFilter.indexOf(name) !== -1) {
                    data = data.map(() => 0);
                }
                return { name, data };
            });
            clearTimeout(timer);
        }, 250);
    }
    _recalculateSpotPosition() {
        const { width } = this._sliderEl.nativeElement.getBoundingClientRect();
        const overlayRightWidth = width - this.sliderSpotWidth - this._x;
        const overlayLeftWidth = this._x;
        this._renderer.setStyle(this._dndEl.nativeElement, 'left', `${this._x * 100 / width}%`);
        this._renderer.setStyle(this._overlayEl.nativeElement, 'left', `${this._x * 100 / width}%`);
        this._renderer.setStyle(this._overlayLeftEl.nativeElement, 'width', `${overlayLeftWidth * 100 / width}%`);
        this._renderer.setStyle(this._overlayRightEl.nativeElement, 'width', `${overlayRightWidth * 100 / width}%`);
    }
    _recalculateDataRange() {
        const { width } = this._sliderEl.nativeElement.getBoundingClientRect();
        const count = this._getDataLength();
        const wPiece = width / count;
        this.sliderSpotWidth = width / this.monitorsCount;
        const startPiece = Math.floor(this._x / wPiece);
        const endPiece = Math.floor((this._x + this.sliderSpotWidth) / wPiece);
        if (this._startPoint !== startPiece) {
            this._startPoint = startPiece;
            this._endPoint = endPiece;
            this.rangeChanged.emit({ startPiece, endPiece });
        }
    }
}
AdaptChartSliderComponent.ɵfac = function AdaptChartSliderComponent_Factory(t) { return new (t || AdaptChartSliderComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptChartSliderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptChartSliderComponent, selectors: [["adapt-chart-slider"]], viewQuery: function AdaptChartSliderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 7);
        i0.ɵɵviewQuery(_c3, 7);
        i0.ɵɵviewQuery(_c4, 7);
        i0.ɵɵviewQuery(_c5, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._chartComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._sliderEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._dndEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._overlayEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._overlayLeftEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._overlayRightEl = _t.first);
    } }, inputs: { type: "type", data: "data", xAxis: "xAxis", height: "height", slidePointsCount: "slidePointsCount", customColors: "customColors", stackedChart: "stackedChart", leftShift: "leftShift", containerWidth: "containerWidth" }, outputs: { rangeChanged: "rangeChanged" }, decls: 30, vars: 38, consts: [[3, "click"], ["slider", ""], ["overlayLeft", ""], [3, "ngClass", "mouseover", "mouseout", "mousedown"], ["dnd", ""], [3, "keydown.arrowRight", "keydown.arrowLeft"], [3, "ngSwitch", 4, "ngIf"], ["overlay", ""], ["overlayRight", ""], [3, "ngSwitch"], [3, "suppressHeader", "suppressLegend", "renderLegend", "showEmptyColIndicator", "legend", "hideAxises", "xAxis", "yAxis", "series", "height", "type", "seriesDisplay", 4, "ngSwitchCase"], [3, "suppressHeader", "suppressLegend", "renderLegend", "showEmptyColIndicator", "legend", "hideAxises", "xAxis", "yAxis", "series", "height", "type", "seriesDisplay"], ["chart", ""]], template: function AdaptChartSliderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0, 1);
        i0.ɵɵlistener("click", function AdaptChartSliderComponent_Template_div_click_1_listener($event) { return ctx.onClickSliderArea($event); });
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵelementStart(4, "div");
        i0.ɵɵtext(5, "\n        ");
        i0.ɵɵelement(6, "div", null, 2);
        i0.ɵɵtext(8, "\n        ");
        i0.ɵɵelementStart(9, "div", 3, 4);
        i0.ɵɵlistener("mouseover", function AdaptChartSliderComponent_Template_div_mouseover_9_listener() { return ctx.onMouseOver(); })("mouseout", function AdaptChartSliderComponent_Template_div_mouseout_9_listener() { return ctx.onMouseOut(); })("mousedown", function AdaptChartSliderComponent_Template_div_mousedown_9_listener($event) { return ctx.onMouseDown($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(11, "\n        ");
        i0.ɵɵelementStart(12, "div", 5);
        i0.ɵɵlistener("keydown.arrowRight", function AdaptChartSliderComponent_Template_div_keydown_arrowRight_12_listener() { return ctx.onSliderShift(); })("keydown.arrowLeft", function AdaptChartSliderComponent_Template_div_keydown_arrowLeft_12_listener() { return ctx.onSliderShift(true); });
        i0.ɵɵtext(13, "\n          ");
        i0.ɵɵtemplate(14, AdaptChartSliderComponent_ng_container_14_Template, 4, 2, "ng-container", 6);
        i0.ɵɵtext(15, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n        ");
        i0.ɵɵelement(17, "div", null, 7);
        i0.ɵɵtext(19, "\n        ");
        i0.ɵɵelement(20, "div", null, 8);
        i0.ɵɵtext(22, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(23, "\n      ");
        i0.ɵɵelementStart(24, "div");
        i0.ɵɵtext(25, "\n        ");
        i0.ɵɵelement(26, "div");
        i0.ɵɵtext(27, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(28, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(29, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵclassMap(ctx.classPrefix);
        i0.ɵɵstyleProp("height", ctx.height, "px")("margin-left", ctx.leftShift, "px");
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-main");
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate2("", ctx.classPrefix, "-side-overlay ", ctx.classPrefix, "-side-overlay-right");
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-spot");
        i0.ɵɵstyleProp("width", 100 / ctx.monitorsCount, "%");
        i0.ɵɵproperty("ngClass", ctx.isActive ? ctx.classPrefix + "-spot-active" : "");
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-chart-zone");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.initComplete);
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-overlay");
        i0.ɵɵstyleProp("width", 100 / ctx.monitorsCount, "%");
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate2("", ctx.classPrefix, "-side-overlay ", ctx.classPrefix, "-side-overlay-left");
        i0.ɵɵadvance(4);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line-wrapper");
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptChartSliderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-chart-slider',
                template: `
    <div #slider
         [class]="classPrefix"
         [style.height.px]="height"
         (click)="onClickSliderArea($event)" [style.marginLeft.px]="leftShift">
      <div class="{{classPrefix}}-main">
        <div #overlayLeft
             class="{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-right"></div>
        <div #dnd
             (mouseover)="onMouseOver()"
             (mouseout)="onMouseOut()"
             (mousedown)="onMouseDown($event)"
             [style.width.%]="100 / monitorsCount"
             class="{{classPrefix}}-spot"
             [ngClass]="isActive ? classPrefix + '-spot-active' : ''"></div>
        <div class="{{classPrefix}}-chart-zone"
             (keydown.arrowRight)="onSliderShift()"
             (keydown.arrowLeft)="onSliderShift(true)">
          <ng-container *ngIf="initComplete" [ngSwitch]="type">
            <adapt-stacked-chart #chart
                                 *ngSwitchCase="chartSliderType.bar"
                                 [suppressHeader]="true"
                                 [suppressLegend]="true"
                                 [renderLegend]="false"
                                 [showEmptyColIndicator]="false"
                                 [legend]="null"
                                 [hideAxises]="true"
                                 [xAxis]="xAxis"
                                 [yAxis]="{}"
                                 [series]="data"
                                 [height]="height - sliderPaddingTop"
                                 [type]="stackedChartType"
                                 [seriesDisplay]="stackedChart && stackedChart.seriesDisplay"></adapt-stacked-chart>
          </ng-container>
        </div>
        <div #overlay class="{{classPrefix}}-overlay" [style.width.%]="100 / monitorsCount"></div>
        <div #overlayRight
             class="{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-left"></div>
      </div>
      <div class="{{classPrefix}}-line-wrapper">
        <div class="{{classPrefix}}-line"></div>
      </div>
    </div>
  `,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, { type: [{
            type: Input
        }], data: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], height: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }], customColors: [{
            type: Input
        }], stackedChart: [{
            type: Input
        }], leftShift: [{
            type: Input
        }], containerWidth: [{
            type: Input
        }], rangeChanged: [{
            type: Output
        }], _chartComponent: [{
            type: ViewChild,
            args: ['chart']
        }], _sliderEl: [{
            type: ViewChild,
            args: ['slider', { static: true }]
        }], _dndEl: [{
            type: ViewChild,
            args: ['dnd', { static: true }]
        }], _overlayEl: [{
            type: ViewChild,
            args: ['overlay', { static: true }]
        }], _overlayLeftEl: [{
            type: ViewChild,
            args: ['overlayLeft', { static: true }]
        }], _overlayRightEl: [{
            type: ViewChild,
            args: ['overlayRight', { static: true }]
        }] }); })();
//# sourceMappingURL=chart-slider.component.js.map