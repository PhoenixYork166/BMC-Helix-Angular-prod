import { Component, ElementRef, EventEmitter, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import * as d3 from 'd3';
import { ChartColorService } from '../common/services/chart-color.service';
import { ANIMATION_DURATION, ColorType, isUndefined } from '@bmc-ux/adapt-angular';
import { AdaptChartComponent } from '../common/chart.component';
import { AdaptPieChartAbstract } from '../common/models/pie.model';
import * as i0 from "@angular/core";
import * as i1 from "../common/services/chart-color.service";
import * as i2 from "../common/chart.component";
import * as i3 from "@angular/common";
const _c0 = ["chart"];
const _c1 = ["tooltipTpl"];
function AdaptPieChartComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 3);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelement(3, "span", 4);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelementStart(5, "span", 5);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementStart(8, "b");
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementStart(10, "span");
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n          ");
    i0.ɵɵelementStart(13, "span");
    i0.ɵɵtext(14);
    i0.ɵɵpipe(15, "percent");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n    ");
} if (rf & 2) {
    const data_r3 = ctx.data;
    i0.ɵɵadvance(3);
    i0.ɵɵstyleProp("background-color", data_r3.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r3.category);
    i0.ɵɵadvance(5);
    i0.ɵɵtextInterpolate(data_r3.value);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("(", i0.ɵɵpipeBind1(15, 5, data_r3.value / data_r3.total), ")");
} }
// TODO fix types
export class AdaptPieChartComponent extends AdaptPieChartAbstract {
    constructor(_colorService) {
        super();
        this._colorService = _colorService;
        this.$this = this;
        this.showLegendTooltip = false;
        this.clickChart = new EventEmitter();
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
        this.alreadyChanged = false;
        this._dataBuilder = (function (g, dim) {
            this._clear();
            this._g = g;
            this._dim = dim;
            this._renderChart();
        }).bind(this);
        // TODO check if it can be refactored
        this._updateChart = (function () {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            const __this = this;
            const oldData = this._pie(this._data);
            const data = this.series.map((d) => {
                return {
                    name: d.name,
                    y: this._filter.indexOf(d.name) === -1 ? d.y : 0
                };
            });
            this.total = data.reduce((acc, cur) => {
                acc += cur.y;
                return acc;
            }, 0);
            this._initData();
            this._path = this._path.data(this._pie(this._data));
            this._path
                .transition()
                .duration(this.duration)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attrTween('d', function (d, index) {
                const startInter = d3.interpolate(oldData[index].startAngle, d.startAngle);
                const endInter = d3.interpolate(oldData[index].endAngle, d.endAngle);
                return function (t) {
                    d.startAngle = startInter(t);
                    d.endAngle = endInter(t);
                    return __this._arc(d);
                };
            });
            if (this.innerRadius > 1) {
                this._g
                    .selectAll('.adapt-pie-chart-main-label-sum')
                    .text(`${this.total}`);
            }
        }).bind(this);
        this.donutProportion = 16 / 25;
        this._filter = [];
        this._cls = {
            arc: 'arc',
            arcPart: 'arc-part',
            segment: 'arc-segment',
            sectorIdentifier: 'adapt-pie-chart-sector',
            summary: 'adapt-pie-chart-summary',
            summaryLabel: 'adapt-pie-chart-main-label',
            summaryText: 'adapt-pie-chart-main-label-sum'
        };
        this._legend = {
            columns: 1,
            activeHover: true,
            activeClick: true,
            width: 250,
            customColors: null,
            items: []
        };
        this._series = [];
        this._legendTooltipPoint = { x: 0, y: 0 };
    }
    set series(s) {
        this._series = s;
        if (s) {
            this._updateFilter(s);
        }
        if (this.alreadyChanged) {
            const options = this.chartComponent.getGroupAndDimensions();
            this._g = options.group;
            this._dim = {
                w: options.w,
                h: options.h
            };
        }
        if (this._g && this._dim && this.chartComponent) {
            this.chartComponent.updateLegend(this.series.map((item) => ({
                item: item.name,
                hidden: !!item.hidden,
                hover: false
            })));
        }
    }
    get series() {
        return this._series;
    }
    set legend(legend) {
        this._legend = Object.assign(this._legend, legend);
    }
    get legend() {
        return {
            customColors: this._legend.customColors,
            activeHover: this._legend.activeHover,
            activeClick: this._legend.activeClick,
            columns: this._legend.columns,
            width: this._legend.width,
            items: (this.series && this.series.map((series) => ({
                item: series.name,
                hidden: !!series.hidden
            })))
        };
    }
    get duration() {
        return parseFloat(ANIMATION_DURATION.fast) * 1000;
    }
    ngOnInit() {
        if (this.header) {
            this.header.allowHideLegend = false;
        }
    }
    ngOnChanges() {
        if (this.alreadyChanged && this._g && this._dim) {
            this._data = [];
            this._updateFilter(this.series);
            this._clear();
            this._renderChart();
            this._updateChart();
        }
        this.alreadyChanged = true;
    }
    categoryEnter(categoryEvent) {
        const group = this._g.select(`#adapt-pie-chart-sector-${categoryEvent.id}`);
        const color = group.attr('fill');
        const hoverColor = this._colorService.getDarken(color, .15, ColorType.HEX);
        this._initialColor = color;
        group.attr('fill', hoverColor);
        if (this.showLegendTooltip) {
            this._legendTooltipPoint.x = categoryEvent.event.clientX;
            this._legendTooltipPoint.y = categoryEvent.event.clientY;
            const id = categoryEvent.id;
            const tooltipTpl = this.tooltip || this.tooltipTemplate;
            const data = this.series.map((d) => {
                return {
                    name: d.name,
                    y: this._filter.indexOf(d.name) === -1 ? d.y : 0
                };
            });
            this.chartComponent.showTooltip(this._legendTooltipPoint, tooltipTpl, {
                data: {
                    color: this._legend.customColors ? this._getCustomColorById(id) : this._colorService.getColor(id),
                    category: data[id].name,
                    value: this.series[id].y,
                    total: this.total,
                    data: this.series[id],
                    event: categoryEvent.event
                }
            });
        }
    }
    categoryLeave(categoryEvent) {
        const group = this._g.select(`#adapt-pie-chart-sector-${categoryEvent.id}`);
        group.attr('fill', this._initialColor);
        if (this.showLegendTooltip) {
            this.chartComponent.hideTooltip();
        }
    }
    categoryMove(categoryEvent) {
        this._legendTooltipPoint.x = categoryEvent.event.clientX;
        this._legendTooltipPoint.y = categoryEvent.event.clientY;
        this.chartComponent.updateTooltip();
    }
    categoryShowHandler(category) {
        const categoryId = this._filter.indexOf(category);
        if (categoryId !== -1) {
            this._filter.splice(categoryId, 1);
            this._updateChart();
        }
        this.categoryShow.emit({ category });
    }
    categoryHideHandler(category) {
        this._filter.push(category);
        this._updateChart();
        this.categoryHide.emit({ category });
    }
    clickChartArea(e) {
        var _a;
        const target = e.target;
        const isSector = target.classList.contains(this._cls.segment);
        if (isSector) {
            const id = (_a = target.parentNode) === null || _a === void 0 ? void 0 : _a.getAttribute('id');
            const index = id.split('-').reverse()[0];
            const total = this.series.reduce((acc, v) => acc + v.y, 0);
            const color = d3.select(target.parentNode).attr('fill');
            this.clickChart.emit({
                event: e,
                data: this.series[index],
                color,
                category: this.series[index].name,
                value: this.series[index].y,
                total
            });
        }
    }
    _renderChart() {
        this._initData();
        if (this.innerRadius > 0) {
            this._addSummary();
        }
        this._createColor();
        this._createPie();
        this._createDataChart();
    }
    _initData() {
        this._data = this.series.map((d) => this._filter.indexOf(d.name) === -1 ? d.y : 0);
    }
    _createColor() {
        this._colors = this._data.map((d, id) => {
            return this._legend.customColors ? this._getCustomColorById(id) : this._colorService.getColor(id);
        });
        this._radius = Math.min(this._dim.w, this._dim.h) / 2;
        this._g.attr('transform', `translate(${this._radius} ${this._radius})`);
        this._arc = d3.arc()
            .innerRadius(this._getInnerRadius())
            .outerRadius(this._radius);
    }
    _createPie() {
        this._pie = d3.pie()
            .sort(null);
    }
    _createDataChart() {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const __this = this;
        const tooltipTpl = this.tooltip || this.tooltipTemplate;
        const data = this.series.map((d) => {
            return {
                name: d.name,
                y: this._filter.indexOf(d.name) === -1 ? d.y : 0
            };
        });
        const arc = this._g.selectAll(`.${this._cls.arc}`)
            .data(this._pie(this._data))
            .enter()
            .each((d) => {
            d.outerRadius = this._radius;
        })
            .append('g')
            .attr('class', this._cls.arcPart)
            .attr('id', (d, id) => `${this._cls.sectorIdentifier}-${id}`)
            .attr('fill', (d, colorId) => this._colors[colorId]);
        this.total = data.reduce((acc, cur) => {
            acc += cur.y;
            return acc;
        }, 0);
        this._path = arc.append('path')
            .attr('class', this._cls.segment)
            .attr('d', this._arc);
        const tooltipAnchorPoint = { x: 0, y: 0 };
        this._path.on('mouseenter', (d) => {
            const { clientX, clientY } = d3.event;
            const { index, value } = d;
            tooltipAnchorPoint.x = clientX;
            tooltipAnchorPoint.y = clientY;
            this.chartComponent.showTooltip(tooltipAnchorPoint, tooltipTpl, {
                data: {
                    color: __this._legend.customColors ? __this._getCustomColorById(index) : __this._colorService.getColor(index),
                    category: data[index].name,
                    value: value,
                    total: this.total,
                    data: __this.series[index],
                    event: d3.event
                }
            });
        });
        this._path.on('mousemove', () => {
            const { clientX, clientY } = d3.event;
            tooltipAnchorPoint.x = clientX;
            tooltipAnchorPoint.y = clientY;
            this.chartComponent.updateTooltip();
        });
        arc.on('mouseenter', function () {
            __this._initialColor = d3.select(this)
                .attr('fill');
            d3.select(this)
                .attr('fill', __this._colorService.getDarken(__this._initialColor, .15, ColorType.HEX));
        })
            .on('mouseout', function () {
            __this.chartComponent.hideTooltip();
            d3.select(this)
                .attr('fill', __this._initialColor);
        });
    }
    _getInnerRadius() {
        const maxInnerRadius = this._radius * (1 + this.donutProportion) / 2;
        let minInnerRadius = this._radius * (1 - (1 - this.donutProportion) * 2);
        let innerRadius = 0;
        if (this.innerRadius > 0) {
            const node = this._g
                .select(`.${this._cls.summary}`)
                .node();
            const width = node ? node.getBoundingClientRect().width : 0;
            minInnerRadius = Math.floor(width / 2) + 15;
        }
        if (!isUndefined(this.innerRadius) || this.innerRadius > 0) {
            innerRadius = this.innerRadius;
            innerRadius = innerRadius < minInnerRadius ? minInnerRadius : innerRadius;
            innerRadius = innerRadius > maxInnerRadius ? maxInnerRadius : innerRadius;
        }
        return innerRadius;
    }
    _clear() {
        if (this._g) {
            this._g.selectAll('*').remove();
        }
    }
    _addSummary() {
        const data = this.series.map((d) => {
            return {
                name: d.name,
                y: this._filter.indexOf(d.name) === -1 ? d.y : 0
            };
        });
        const text = this._g
            .append('text')
            .attr('class', this._cls.summary);
        this.total = data.reduce((acc, cur) => {
            acc += cur.y;
            return acc;
        }, 0);
        text.append('tspan')
            .attr('text-anchor', 'middle')
            .attr('x', 0)
            .attr('y', '-.4em')
            .attr('class', this._cls.summaryLabel)
            .text('Total');
        text.append('tspan')
            .attr('text-anchor', 'middle')
            .attr('x', 0)
            .attr('y', '.8em')
            .attr('class', this._cls.summaryText)
            .text(`${this.total}`);
    }
    _getCustomColorById(id) {
        const customColors = this._legend.customColors;
        const len = customColors.length;
        const index = id % len;
        return customColors[index];
    }
    _updateFilter(series) {
        this._filter = [];
        series.forEach(s => {
            if (s.hidden) {
                this._filter.push(s.name);
            }
        });
    }
}
AdaptPieChartComponent.ɵfac = function AdaptPieChartComponent_Factory(t) { return new (t || AdaptPieChartComponent)(i0.ɵɵdirectiveInject(i1.ChartColorService)); };
AdaptPieChartComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptPieChartComponent, selectors: [["adapt-pie-chart"]], viewQuery: function AdaptPieChartComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chart = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", innerRadius: "innerRadius", showLegendTooltip: "showLegendTooltip", series: "series", legend: "legend" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 7, vars: 12, consts: [[3, "width", "height", "header", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "noDataText", "updateChart", "dataBuilder", "categoryEnter", "categoryLeave", "categoryMove", "categoryShow", "categoryHide", "clickChart"], ["chart", ""], ["tooltipTpl", ""], [1, "adapt-pie-chart-tooltip"], [1, "adapt-pie-chart-tooltip__color"], [1, "adapt-pie-chart-tooltip__category"]], template: function AdaptPieChartComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "adapt-chart", 0, 1);
        i0.ɵɵlistener("categoryEnter", function AdaptPieChartComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptPieChartComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx.categoryLeave($event); })("categoryMove", function AdaptPieChartComponent_Template_adapt_chart_categoryMove_1_listener($event) { return ctx.categoryMove($event); })("categoryShow", function AdaptPieChartComponent_Template_adapt_chart_categoryShow_1_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptPieChartComponent_Template_adapt_chart_categoryHide_1_listener($event) { return ctx.categoryHideHandler($event); })("clickChart", function AdaptPieChartComponent_Template_adapt_chart_clickChart_1_listener($event) { return ctx.clickChartArea($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(3, "\n\n    ");
        i0.ɵɵtemplate(4, AdaptPieChartComponent_ng_template_4_Template, 19, 7, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(6, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("width", ctx.$this.width)("height", ctx.$this.height)("header", ctx.$this.header)("legend", ctx.$this.legend)("data", ctx.series)("backgroundColor", ctx.$this.backgroundColor)("suppressHeader", ctx.$this.suppressHeader)("suppressLegend", ctx.$this.suppressLegend)("tooltip", ctx.$this.tooltip)("noDataText", ctx.noDataText)("updateChart", ctx._updateChart)("dataBuilder", ctx._dataBuilder);
    } }, directives: [i2.AdaptChartComponent], pipes: [i3.PercentPipe], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptPieChartComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-pie-chart',
                template: `
    <adapt-chart #chart
                 [width]="$this.width"
                 [height]="$this.height"
                 [header]="$this.header"
                 [legend]="$this.legend"
                 [data]="series"
                 [backgroundColor]="$this.backgroundColor"
                 [suppressHeader]="$this.suppressHeader"
                 [suppressLegend]="$this.suppressLegend"
                 [tooltip]="$this.tooltip"
                 (categoryEnter)="categoryEnter($event)"
                 (categoryLeave)="categoryLeave($event)"
                 (categoryMove)="categoryMove($event)"
                 (categoryShow)="categoryShowHandler($event)"
                 (categoryHide)="categoryHideHandler($event)"
                 (clickChart)="clickChartArea($event)"
                 [noDataText]="noDataText"
                 [updateChart]="_updateChart"
                 [dataBuilder]="_dataBuilder"></adapt-chart>

    <ng-template #tooltipTpl let-data="data">
      <div class="adapt-pie-chart-tooltip">
        <span [style.background-color]="data.color" class="adapt-pie-chart-tooltip__color"></span>
        <span class="adapt-pie-chart-tooltip__category">{{data.category}}</span>
        <b>
          <span>{{data.value}}</span>
          <span>({{data.value / data.total | percent}})</span>
        </b>
      </div>
    </ng-template>
  `,
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.ChartColorService }]; }, { backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], showLegendTooltip: [{
            type: Input
        }], series: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], legend: [{
            type: Input
        }], chartComponent: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], chart: [{
            type: ViewChild,
            args: ['chart', { static: true }]
        }], tooltipTemplate: [{
            type: ViewChild,
            args: ['tooltipTpl', { static: true }]
        }] }); })();
//# sourceMappingURL=pie-chart.component.js.map