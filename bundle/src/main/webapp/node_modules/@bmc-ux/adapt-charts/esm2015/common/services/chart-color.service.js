import { Injectable } from '@angular/core';
import { ColorType } from '@bmc-ux/adapt-angular';
import * as d3 from 'd3';
import * as i0 from "@angular/core";
export var AdaptChartColorStatus;
(function (AdaptChartColorStatus) {
    AdaptChartColorStatus[AdaptChartColorStatus["Default"] = 0] = "Default";
    AdaptChartColorStatus[AdaptChartColorStatus["Success"] = 1] = "Success";
    AdaptChartColorStatus[AdaptChartColorStatus["Warning"] = 2] = "Warning";
    AdaptChartColorStatus[AdaptChartColorStatus["Danger"] = 3] = "Danger";
    AdaptChartColorStatus[AdaptChartColorStatus["Custom"] = 4] = "Custom"; // @since 9.3.0
})(AdaptChartColorStatus || (AdaptChartColorStatus = {}));
export const STATUS_COLOR_RANGE = {
    Default: ['#195560', '#267f91'],
    Success: ['#408600', '#5da627'],
    Warning: ['#FFBE00', '#FFE438'],
    Danger: ['#E80B30', '#ff3a49'],
    Custom: ['#0078CC', '#009AF0']
};
export class ChartColorsFactory {
    static getGradientColors() {
        return [
            '#488EE7',
            '#1145AC',
            '#8061C5',
            '#7E1E85',
            '#C94FAF',
            '#E9345D',
            '#EF6F70',
            '#DD8A44',
            '#E7B548',
            '#D5DB51',
            '#9DB957',
            '#54C2C3',
            '#89F4F4',
            '#9CD0FB',
            '#AAB2F5',
            '#E6A8D7'
        ];
    }
    static getHighDiffColors() {
        return [
            '#6487EA',
            '#E9862F',
            '#875BCB',
            '#EFB426',
            '#90D1FF',
            '#FF656C',
            '#95BC44',
            '#D83FB4',
            '#00C5C4',
            '#89008A',
            '#D3DD27',
            '#FB025A',
            '#0242B3',
            '#F0A3DA',
            '#62F7F6',
            '#AAB0FA',
        ];
    }
}
export class ChartColorService {
    constructor() {
        this._gradientColors = ChartColorsFactory.getGradientColors();
        this._highDiffColorsColors = ChartColorsFactory.getHighDiffColors();
    }
    static getColorRange(range, count) {
        let _temp;
        if (range instanceof Array) {
            _temp = range;
        }
        else {
            switch (range) {
                case (AdaptChartColorStatus.Success): {
                    _temp = STATUS_COLOR_RANGE.Success;
                    break;
                }
                case (AdaptChartColorStatus.Warning): {
                    _temp = STATUS_COLOR_RANGE.Warning;
                    break;
                }
                case (AdaptChartColorStatus.Danger): {
                    _temp = STATUS_COLOR_RANGE.Danger;
                    break;
                }
                default: {
                    _temp = STATUS_COLOR_RANGE.Default;
                    break;
                }
            }
        }
        const _range = [];
        const _scale = d3
            .scaleLinear()
            .range(_temp)
            .domain([1, count]);
        for (let i = 0; i < count; i++) {
            _range.push(d3.color(_scale(i + 1)).hex());
        }
        return _range;
    }
    getColor(id, palette) {
        const colors = palette === 'high-diff' ? this._highDiffColorsColors : this._gradientColors;
        const len = colors.length - 1;
        return colors[id % len];
    }
    getDarken(color, percent, type) {
        const colorRGB = type === ColorType.HEX ? this._parseHEX(color) : this._parseRGB(color);
        Object.keys(colorRGB).forEach((colorComponentName) => {
            colorRGB[colorComponentName] = Math.floor((1 - percent) * colorRGB[colorComponentName]);
        });
        return `#${this._decToHEX(colorRGB.r)}${this._decToHEX(colorRGB.g)}${this._decToHEX(colorRGB.b)}`;
    }
    getContrast(color, type) {
        const channels = type === ColorType.HEX ? this._parseHEX(color) : this._parseRGB(color);
        // Converts the RGB color space into YIQ
        const yiq = ((channels.r * 299) + (channels.g * 587) + (channels.b * 114)) / 1000;
        return (yiq >= 128) ? '#000' : '#fff';
    }
    setColors(newColors) {
        this._gradientColors = newColors;
    }
    _parseHEX(color) {
        const colorCode = color.trim().slice(1);
        let r;
        let g;
        let b;
        // In case if color value passed in short variant (eg. #456 instead of #445566)
        if (colorCode.length === 3) {
            r = parseInt(colorCode.substring(0, 1) + colorCode.substring(0, 1), 16);
            g = parseInt(colorCode.substring(1, 2) + colorCode.substring(1, 2), 16);
            b = parseInt(colorCode.substring(2, 3) + colorCode.substring(2, 3), 16);
        }
        else {
            r = parseInt(colorCode.substring(0, 2), 16);
            g = parseInt(colorCode.substring(2, 4), 16);
            b = parseInt(colorCode.substring(4, 6), 16);
        }
        return { r, g, b };
    }
    _parseRGB(color) {
        const colorTrimmed = color.trim();
        const colorCode = colorTrimmed.substring(4, colorTrimmed.length - 1).replace(/ /g, '').split(',');
        const [r, g, b] = colorCode.map((c) => parseInt(c, 10));
        return { r, g, b };
    }
    _decToHEX(n) {
        const hex = n.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
}
ChartColorService.ɵfac = function ChartColorService_Factory(t) { return new (t || ChartColorService)(); };
ChartColorService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ChartColorService, factory: ChartColorService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ChartColorService, [{
        type: Injectable
    }], null, null); })();
//# sourceMappingURL=chart-color.service.js.map