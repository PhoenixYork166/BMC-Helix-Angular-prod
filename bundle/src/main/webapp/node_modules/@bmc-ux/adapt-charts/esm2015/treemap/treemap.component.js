import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, isDevMode, Output, QueryList, Renderer2, TemplateRef, ViewChild, ViewChildren } from '@angular/core';
import { ListKeyManager } from '@angular/cdk/a11y';
import { DOWN_ARROW, ENTER, ESCAPE, SPACE, TAB, UP_ARROW } from '@angular/cdk/keycodes';
import { cloneDeep, isArray } from 'lodash-es';
import * as d3 from 'd3';
import { AdaptDropdownDirective, AdaptDropdownToggleDirective, adaptError, AdaptListKeyManagerItemDirective, ColorType, getEventKeyCode, isDefined, isFunction, SafeCdr } from '@bmc-ux/adapt-angular';
import { ai_ellipsis } from '@bmc-ux/dpl-iconfont';
import { AdaptChartComponent } from '../common/chart.component';
import { AdaptTreemapAbstract } from '../common/models/treemap.model';
import { AdaptChartColorStatus, ChartColorService } from '../common/services/chart-color.service';
import * as i0 from "@angular/core";
import * as i1 from "../common/services/chart-color.service";
import * as i2 from "../common/chart.component";
import * as i3 from "@angular/common";
import * as i4 from "@bmc-ux/adapt-angular";
const _c0 = ["treemapDefaultTooltip"];
const _c1 = ["treemapGroupTooltip"];
const _c2 = ["menuAnchor"];
const _c3 = ["menuContainer"];
const _c4 = ["optionsListRef"];
function AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r17 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 15);
    i0.ɵɵlistener("click", function AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r17); const action_r14 = restoredCtx.$implicit; const ctx_r16 = i0.ɵɵnextContext(4); return ctx_r16.callAction(ctx_r16.menuData.target, ctx_r16.menuData.event, ctx_r16.menuData.context, action_r14); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const action_r14 = ctx.$implicit;
    const index_r15 = ctx.index;
    const ctx_r13 = i0.ɵɵnextContext(4);
    i0.ɵɵclassProp("text-active", ctx_r13.isActiveDescendant(index_r15));
    i0.ɵɵpropertyInterpolate1("id", "treemap__actions__action-", index_r15, "");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n          ", action_r14.title, "\n        ");
} }
function AdaptTreemapComponent_div_3_ng_template_6_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template, 2, 4, "button", 14);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r12.menuData.actions);
} }
function AdaptTreemapComponent_div_3_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    const _r19 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n    ");
    i0.ɵɵelementStart(1, "div", 11, 12);
    i0.ɵɵlistener("keydown", function AdaptTreemapComponent_div_3_ng_template_6_Template_div_keydown_1_listener($event) { i0.ɵɵrestoreView(_r19); const ctx_r18 = i0.ɵɵnextContext(2); return ctx_r18.keydownHandler($event); });
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, AdaptTreemapComponent_div_3_ng_template_6_div_4_Template, 4, 1, "div", 13);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n  ");
} if (rf & 2) {
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵattribute("aria-activedescendant", ctx_r10.getActiveDescendant());
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r10.menuData && ctx_r10.menuData.actions && ctx_r10.menuData.actions.length);
} }
function AdaptTreemapComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r21 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 6, 7);
    i0.ɵɵlistener("popupAnimationDone", function AdaptTreemapComponent_div_3_Template_div_popupAnimationDone_0_listener() { i0.ɵɵrestoreView(_r21); const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.popupAnimationDone(); });
    i0.ɵɵtext(2, "\n  ");
    i0.ɵɵelement(3, "button", 8, 9);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵtemplate(6, AdaptTreemapComponent_div_3_ng_template_6_Template, 7, 2, "ng-template", 10);
    i0.ɵɵtext(7, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true)("restoreFocusAfterClose", true);
} }
function AdaptTreemapComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div");
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "strong");
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementStart(6, "div");
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n");
} if (rf & 2) {
    const context_r22 = ctx.context;
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(context_r22.name);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(context_r22.size);
} }
function AdaptTreemapComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 16);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelement(3, "span", 17);
    i0.ɵɵtext(4);
    i0.ɵɵelementStart(5, "strong");
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n");
} if (rf & 2) {
    const parentContext_r23 = ctx.parentContext;
    const childContext_r24 = ctx.childContext;
    i0.ɵɵadvance(3);
    i0.ɵɵstyleProp("background-color", parentContext_r23.color);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n    ", parentContext_r23.name, ": ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(childContext_r24.name);
} }
function AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r33 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 23);
    i0.ɵɵlistener("click", function AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template_a_click_0_listener($event) { i0.ɵɵrestoreView(_r33); const breadCrumb_r27 = i0.ɵɵnextContext().$implicit; const ctx_r31 = i0.ɵɵnextContext(3); return ctx_r31.navigateToGroup($event, breadCrumb_r27, ctx_r31.data); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const breadCrumb_r27 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(breadCrumb_r27);
} }
function AdaptTreemapComponent_ng_template_11_ol_1_li_2_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const breadCrumb_r27 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(breadCrumb_r27);
} }
function AdaptTreemapComponent_ng_template_11_ol_1_li_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "li", 21);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template, 2, 1, "a", 22);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵtemplate(4, AdaptTreemapComponent_ng_template_11_ol_1_li_2_ng_container_4_Template, 2, 1, "ng-container", 13);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const last_r28 = ctx.last;
    i0.ɵɵclassProp("active", last_r28);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !last_r28);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", last_r28);
} }
function AdaptTreemapComponent_ng_template_11_ol_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "ol", 19);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptTreemapComponent_ng_template_11_ol_1_li_2_Template, 6, 4, "li", 20);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r25 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r25.breadCrumbs);
} }
function AdaptTreemapComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵtemplate(1, AdaptTreemapComponent_ng_template_11_ol_1_Template, 4, 1, "ol", 18);
    i0.ɵɵtext(2, "\n");
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r7.breadCrumbs.length);
} }
const NODE_PADDING = 15;
// TODO update types
export class AdaptTreemapComponent extends AdaptTreemapAbstract {
    constructor(_renderer, _chartColorService, _changeDetectorRef) {
        super();
        this._renderer = _renderer;
        this._chartColorService = _chartColorService;
        this._changeDetectorRef = _changeDetectorRef;
        this.hasActionMenu = false;
        this.breadCrumbs = [];
        // Chart data builder
        this.dataBuilderBind = this._dataBuilder.bind(this);
        // Chart update function
        this.updateChartBind = this._updateChart.bind(this);
        // Chart data builder for grouped treemap
        this.dataBuilderForGroupsBind = this._dataBuilderForGroups.bind(this);
        // Chart update function for grouped treemap
        this.updateChartForGroupsBind = this._updateChartForGroups.bind(this);
        this.showSizeInName = true;
        /**
         * @since 10.14.0
         */
        this.groupView = false;
        // Outputs
        this.clickChart = new EventEmitter();
        this.groupEntered = new EventEmitter();
        this._tooltipPoint = { x: 0, y: 0 };
        this._closeMenuBind = this._closeMenu.bind(this);
    }
    categoryEnter(categoryEvent) {
        this._getRelatedToLegendNodes(categoryEvent.id.toString()).dispatch('mouseenter', {
            bubbles: true,
            cancelable: true,
            detail: { eventSource: 'legend' }
        });
    }
    categoryLeave(categoryEvent) {
        this._getRelatedToLegendNodes(categoryEvent.id.toString()).dispatch('mouseleave');
    }
    ngOnInit() {
        this.innerData = cloneDeep(this.data);
        this._initLegend();
    }
    ngOnChanges(changes) {
        if (changes['data']) {
            this.innerData = changes['data'].currentValue;
            this.breadCrumbs = [];
            this._updateLegend(changes['data'].firstChange);
        }
    }
    ngOnDestroy() {
        this._removeListeners();
    }
    popupAnimationDone() {
        if (this.menuContainer.isOpen()) {
            this.optionsListRef.nativeElement.focus();
            this._listKeyManager = new ListKeyManager(this.items)
                .withWrap(false)
                .withHomeAndEnd();
            this._listKeyManager.setFirstItemActive();
            this._removeClickEventListener = this._renderer.listen('document', 'click', this._closeMenuBind);
            this._removeScrollEventListener = this._renderer.listen('document', 'scroll', this._closeMenuBind);
        }
        else {
            this._listKeyManager = null;
            this._removeListeners();
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    keydownHandler(event) {
        if (this._listKeyManager) {
            switch (getEventKeyCode(event)) {
                case DOWN_ARROW:
                case UP_ARROW: {
                    this._listKeyManager.onKeydown(event);
                    break;
                }
                case ENTER: {
                    this.callAction(this.menuData.target, this.menuData.event, this.menuData.context, this.menuData.actions[this._listKeyManager.activeItemIndex]);
                    this.menuContainer.close();
                    break;
                }
                case TAB: {
                    if (this.menuContainer.isOpen()) {
                        this.menuContainer.close();
                    }
                    break;
                }
            }
        }
    }
    getActiveDescendant() {
        return this._listKeyManager ? `treemap__actions__action-${this._listKeyManager.activeItemIndex}` : undefined;
    }
    isActiveDescendant(index) {
        var _a;
        return index === ((_a = this._listKeyManager) === null || _a === void 0 ? void 0 : _a.activeItemIndex);
    }
    callAction(target, event, context, action) {
        action.callback(target, event, context);
    }
    enterGroup(event, d) {
        this.innerData = d.data;
        this._legend = this._prepareGroupLegend();
        this.chartBase.updateLegend(this._legend.items);
        this.groupEntered.emit({ event, data: d.data, node: d });
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    updateBreadCrumbs(d) {
        if (!this.breadCrumbs.length) {
            this.breadCrumbs.push(this.innerData.name);
        }
        this.breadCrumbs.push(d.data.name);
    }
    navigateToGroup(event, name, data) {
        if (data.name === name) {
            this.innerData = cloneDeep(data);
            this.breadCrumbs = this.breadCrumbs.slice(0, this.breadCrumbs.indexOf(name) + 1);
            if (this.breadCrumbs.length === 1) {
                this.breadCrumbs = [];
            }
            this._legend = this._prepareGroupLegend();
            this.chartBase.updateLegend(this._legend.items);
            this.groupEntered.emit({ event, data });
            SafeCdr.detectChanges(this._changeDetectorRef);
            return;
        }
        if (data.children) {
            data.children.forEach(child => {
                this.navigateToGroup(event, name, child);
            });
        }
    }
    _dataBuilder(g, dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        this._g = g;
        const data = this.innerData;
        const openTooltip = this._openTooltip.bind(this);
        const closeTooltip = this._closeTooltip.bind(this);
        const ellipsis = this._ellipsis;
        const clickChart = this.clickChart;
        const openMenu = this._openMenu.bind(this);
        const showSizeInName = this.showSizeInName;
        const chartColorService = this._chartColorService;
        // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
        this.hasActionMenu = this._isDataContainsActions(data);
        const treemap = d3.treemap()
            .tile(d3.treemapResquarify)
            .size([dim.w, dim.h])
            .round(true)
            .paddingInner(1);
        const root = d3.hierarchy(data)
            .eachBefore((d) => {
            d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
        })
            .sum((d) => d.size)
            .sort((a, b) => b.height - a.height || b.value - a.value);
        treemap(root);
        let _currColorGroup = '';
        let _currColorRange = [];
        let _currColorRangeCounter = 0;
        const nodeGroup = this._g.selectAll('g')
            .data(root.leaves())
            .enter()
            .append('g')
            .attr('class', (d) => `treemap-node status-group-${d.data.id.split(' ').join('_')}`)
            .attr('id', (d) => d.data.id.split(' ').join('_'))
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`);
        const nodeGroupInnerElem = nodeGroup
            .append('g')
            .attr('class', 'treemap-node__inner')
            .attr('tabindex', 0)
            .attr('aria-label', (d) => `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''))
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('mouseenter', function (d) {
            const rect = d3.select(this).select('rect');
            const oldColor = rect.node().style.fill;
            const target = d3.select(this);
            const tooltipCustomCls = d.data.id.split('.').join('_').split(' ').join('_');
            const eventDetail = d3.event.detail;
            if (eventDetail === 0 || (eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.eventSource) !== 'legend') {
                openTooltip(target, { context: d.data }, `treemap_tooltip treemap_tooltip__${tooltipCustomCls}`, 1);
                _this._tooltipEl = window.document.querySelector(`.treemap_tooltip__${tooltipCustomCls}`);
                if (isDefined(_this._tooltipEl)) {
                    _this._tooltipMouseleaveHandler = () => {
                        closeTooltip();
                        _this._tooltipEl.removeEventListener('mouseleave', _this._tooltipMouseleaveHandler);
                    };
                    _this._tooltipEl.addEventListener('mouseleave', _this._tooltipMouseleaveHandler);
                }
            }
            rect.node().style.fill = d3.rgb(oldColor).darker(.3).formatHex();
        })
            .on('mouseleave', function () {
            var _a, _b, _c;
            const rect = d3.select(this).select('rect');
            const oldColor = rect.node().style.fill;
            if (!((_c = (_b = (_a = d3.event) === null || _a === void 0 ? void 0 : _a.toElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null || _c === void 0 ? void 0 : _c.classList.contains('adapt-tooltip-inner'))) {
                closeTooltip();
                _this._removeTooltipMouseleaveListener();
            }
            rect.node().style.fill = d3.rgb(oldColor).brighter(.3).formatHex();
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('click', function (d) {
            closeTooltip();
            _this._removeTooltipMouseleaveListener();
            clickChart.emit(d.data);
            d3.event.stopPropagation();
        });
        nodeGroupInnerElem.append('rect')
            .attr('class', 'treemap__node-rect')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('width', (d) => d.x1 - d.x0)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('height', (d) => d.y1 - d.y0)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('style', function (d) {
            if (!_currColorGroup || !(_currColorGroup === d.parent.data.id)) {
                const customColorsRange = d.parent.data.customColorsRange;
                if (isDevMode && customColorsRange && customColorsRange.length !== 2
                    || customColorsRange && customColorsRange[0] && customColorsRange[0].length !== 7
                    || customColorsRange && customColorsRange[1] && customColorsRange[1].length !== 7) {
                    adaptError('ADAPT-ANGULAR Error! \n Treemap component! \n Please pass correct color range. "customColorsRange" property should be an array of 2 values, and each value should be HEX format color 7 chars length each. (eg. customColorsRange: ["#000000", "#ffffff"])');
                }
                _currColorGroup = d.parent.data.id;
                _currColorRange = ChartColorService.getColorRange(d.parent.data.status === AdaptChartColorStatus.Custom
                    ? customColorsRange
                    : d.parent.data.status, d.parent.children.length);
                _currColorRangeCounter = 0;
            }
            const bg = d.data.color ? d.data.color : _currColorRange[_currColorRangeCounter];
            const currentChild = d.parent.children[_currColorRangeCounter];
            if (isDefined(currentChild)) {
                currentChild.bg = bg;
                currentChild.textColor = chartColorService.getContrast(bg, ColorType.HEX);
            }
            _currColorRangeCounter++;
            return `
          fill: ${bg};
          transition: fill .2s;
          cursor: pointer;
        `;
        });
        nodeGroupInnerElem.append('g')
            .attr('class', 'treemap-node-text')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .each(function (d) {
            const _node = d3.select(this);
            _node.attr('id', `${d.data.id.split(' ').join('_')}_text`);
            const _name = _node.append('text')
                .attr('class', 'treemap__node-name')
                .attr('transform', `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
                .attr('style', () => {
                return `
              text-anchor: middle;
              dominant-baseline: middle;
              font-size: 13px;
              fill: ${d.textColor};
            `;
            });
            ellipsis(_name, `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''), d.x1 - d.x0 - NODE_PADDING);
            const lineHeight = 22;
            const _info = _node.append('text')
                .attr('class', 'treemap__node-info-text')
                .attr('transform', `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
                .attr('dy', lineHeight)
                .attr('text-anchor', 'middle')
                .attr('style', `font-size: 12px; opacity: .7; fill: ${d.textColor}`);
            if (d.data.info && (d.y1 - d.y0 > 40)) {
                ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING);
            }
        });
        this._buildActionsMenu(nodeGroup, openMenu);
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    _updateChart(dim) {
        const data = this.innerData;
        const ellipsis = this._ellipsis;
        const showSizeInName = this.showSizeInName;
        // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
        this.hasActionMenu = this._isDataContainsActions(data);
        const treemap = d3.treemap()
            .tile(d3.treemapResquarify)
            .size([dim.w, dim.h])
            .round(true)
            .paddingInner(1);
        const root = d3.hierarchy(data)
            .eachBefore((d) => {
            d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
        })
            .sum((d) => d.size)
            .sort((a, b) => b.height - a.height || b.value - a.value);
        treemap(root);
        const leaves = root.leaves();
        this._g.selectAll('g.treemap-node')
            .data(leaves)
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`);
        this._g.selectAll('g.treemap__actions-menu rect')
            .data(leaves.filter((d) => d.data.actions))
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${(d.x1 - d.x0) - 24}, 10)`);
        this._g.selectAll('g.treemap__actions-menu use')
            .data(leaves.filter((d) => d.data.actions))
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${(d.x1 - d.x0) - 24}, 10)`);
        this._g.selectAll('rect.treemap__node-rect')
            .data(leaves)
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('width', (d) => d.x1 - d.x0)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('height', (d) => d.y1 - d.y0);
        this._g.selectAll('text.treemap__node-name')
            .data(leaves)
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .each(function (d) {
            d3.select(this).text('');
            ellipsis(d3.select(this), `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''), d.x1 - d.x0 - NODE_PADDING);
        });
        this._g.selectAll('text.treemap__node-info-text')
            .data(leaves)
            .transition()
            .duration(200)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d) => `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .each(function (d) {
            d3.select(this).text('');
            if (d.data.info && (d.y1 - d.y0 > 40)) {
                ellipsis(d3.select(this), d.data.info, d.x1 - d.x0 - NODE_PADDING);
            }
        });
    }
    _dataBuilderForGroups(g, dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        this._g = g;
        const data = this.innerData;
        const ellipsis = this._ellipsis;
        const clickChart = this.clickChart;
        const showSizeInName = this.showSizeInName;
        const openMenu = this._openMenu.bind(this);
        // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
        this.hasActionMenu = this._isDataContainsActions(data);
        const treemap = d3.treemap()
            .tile(d3.treemapResquarify)
            .size([dim.w, dim.h])
            .round(true)
            .paddingInner(1)
            .paddingOuter(1);
        const root = d3.hierarchy(data)
            .eachBefore((d) => {
            d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
        })
            // Ignore size value of node if it has children, because only it's children should be calculated to create correct view
            .sum((d) => { var _a; return ((_a = d.children) === null || _a === void 0 ? void 0 : _a.length) ? 0 : d.size; })
            .sort((a, b) => b.height - a.height || b.value - a.value);
        treemap(root);
        const nodeGroup = this._g.selectAll('g')
            .data(root.children)
            .enter()
            .append('g')
            .attr('class', (d) => { var _a; return `treemap-node ${((_a = d.data.children) === null || _a === void 0 ? void 0 : _a.length) ? 'treemap-node__parent' : 'treemap-node__child'}`; })
            .attr('id', (d) => d.data.id.split(' ').join('_'))
            .attr('transform', (d) => `translate(${d.x0}, ${d.y0})`);
        const nodeGroupInnerElem = nodeGroup
            .append('g')
            .attr('class', 'treemap-node__inner')
            .attr('tabindex', 0)
            .attr('aria-label', (d) => `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''))
            .each(function (d) {
            if (_this.groupView && d.children) {
                const node = d3.select(this);
                node.attr('role', 'button')
                    .attr('aria-expanded', false);
            }
        })
            .on('click', function (d) {
            d3.event.stopPropagation();
            if (_this.groupView && d.children) {
                _this._activeNode = d;
                _this.chartBase.hideTooltip();
                _this.updateBreadCrumbs(d);
                _this.enterGroup(d3.event, d);
            }
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('keydown', function (d) {
            if (d3.event.keyCode === ENTER || d3.event.keyCode === SPACE) {
                if (_this.groupView && d.children) {
                    _this._activeNode = d;
                    _this.chartBase.hideTooltip();
                    _this.updateBreadCrumbs(d);
                    _this.enterGroup(d3.event, d);
                }
            }
        });
        const itemsWithChildren = nodeGroupInnerElem.filter(d => { var _a; return !!((_a = d.children) === null || _a === void 0 ? void 0 : _a.length); });
        const itemsWithoutChildren = nodeGroupInnerElem.filter(d => { var _a; return !((_a = d.children) === null || _a === void 0 ? void 0 : _a.length); });
        if (itemsWithChildren.size() > 0) {
            itemsWithChildren
                .each(function (parentData) {
                const parentItem = d3.select(this);
                parentItem
                    .append('rect')
                    .attr('width', parentData.x1 - parentData.x0)
                    .attr('height', parentData.y1 - parentData.y0)
                    .attr('fill', 'transparent')
                    .on('mouseenter', function () {
                    _this._hideParentLabel(parentItem);
                })
                    .on('mouseleave', function () {
                    _this._showParentLabel(parentItem, parentData);
                });
                parentData.children.forEach((childData) => {
                    const childItem = parentItem
                        .append('g')
                        .attr('class', 'treemap-node__child')
                        .attr('tabindex', 0)
                        .attr('aria-label', childData.data.name);
                    const childRect = childItem
                        .append('rect')
                        .attr('class', 'treemap__node-rect')
                        .attr('transform', `translate(${childData.x0 - parentData.x0}, ${childData.y0 - parentData.y0})`)
                        .attr('width', childData.x1 - childData.x0)
                        .attr('height', childData.y1 - childData.y0)
                        .attr('style', `fill: ${childData.data.color}; transition: fill .2s; cursor: pointer;`);
                    childItem
                        .on('mouseenter', function () {
                        const oldColor = childRect.node().style.fill;
                        childRect.node().style.fill = d3.rgb(oldColor).darker(.3).formatHex();
                        _this._hideParentLabel(parentItem);
                        const { clientX, clientY } = d3.event;
                        _this._tooltipPoint.x = clientX;
                        _this._tooltipPoint.y = clientY;
                        _this.chartBase.showTooltip(_this._tooltipPoint, _this.treemapGroupTooltip, {
                            parentContext: parentData.data,
                            childContext: childData.data
                        });
                    })
                        .on('mousemove', function () {
                        const { clientX, clientY } = d3.event;
                        _this._tooltipPoint.x = clientX;
                        _this._tooltipPoint.y = clientY;
                        _this.chartBase.updateTooltip();
                    })
                        .on('mouseleave', function () {
                        const oldColor = childRect.node().style.fill;
                        childRect.node().style.fill = d3.rgb(oldColor).brighter(.3).formatHex();
                        _this._showParentLabel(parentItem, parentData);
                        _this.chartBase.hideTooltip();
                    });
                    const _name = childItem
                        .append('text')
                        .attr('class', 'treemap__node-child-label')
                        .attr('opacity', '0')
                        .attr('transform', `translate(${(childData.x0 - parentData.x0 + ((childData.x1 - childData.x0) / 2))}, ${(childData.y0 - parentData.y0 + ((childData.y1 - childData.y0) / 2))})`)
                        .attr('style', `text-anchor: middle; dominant-baseline: middle; font-size: 13px; fill: ${_this._chartColorService.getContrast(childData.data.color, ColorType.HEX)};`);
                    ellipsis(_name, `${childData.data.name}` + (showSizeInName ? ` (${childData.data.size})` : ''), childData.x1 - childData.x0 - NODE_PADDING);
                });
            })
                .on('mouseenter', function () {
                const texts = d3.select(this).selectAll('.treemap__node-child-label');
                texts.attr('opacity', '1');
            })
                .on('mouseleave', function () {
                const texts = d3.select(this).selectAll('.treemap__node-child-label');
                texts.attr('opacity', '0');
            });
            itemsWithChildren
                .append('g')
                .attr('class', 'treemap-node-parent-label')
                .each(function (parentData) {
                const _node = d3.select(this);
                const tooltipWrapperHeight = 60;
                _node
                    .append('foreignObject')
                    .attr('width', parentData.x1 - parentData.x0)
                    .attr('height', 1)
                    .attr('overflow', 'visible')
                    .attr('transform', `translate(0, ${((parentData.y1 - parentData.y0) / 2) - (tooltipWrapperHeight / 2)})`)
                    .append('xhtml:div')
                    .html(`
                <div class="treemap__group-parent-tooltip shadow-1">
                    <div class="treemap__group-parent-tooltip-color"
                         style="background-color: ${parentData.data.color}; border-color: ${_this._chartColorService.getDarken(parentData.data.color, .14, ColorType.HEX)};">&nbsp;</div>
                    <div class="treemap__group-parent-tooltip-text align-start" id="${parentData.data.id.split(' ').join('_')}_text">${parentData.data.name}</div>
                </div>
            `)
                    .attr('class', 'treemap__group-parent-tooltip-wrapper');
            });
        }
        if (itemsWithoutChildren.size() > 0) {
            itemsWithoutChildren.append('rect')
                .attr('class', 'treemap__node-rect')
                .attr('width', (d) => d.x1 - d.x0)
                .attr('height', (d) => d.y1 - d.y0)
                .attr('style', (d) => `fill: ${d.data.color}; transition: fill .2s; cursor: pointer;`)
                .on('click', function (d) {
                clickChart.emit(d.data);
            });
            itemsWithoutChildren.append('g')
                .attr('class', 'treemap-node-text treemap-node-text_no-child')
                .each(function (d) {
                const _node = d3.select(this);
                const _name = _node.append('text')
                    .attr('class', 'treemap__node-name')
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
                    .attr('style', `text-anchor: middle; dominant-baseline: middle; font-size: 13px; fill: ${_this._chartColorService.getContrast(d.data.color, ColorType.HEX)};`);
                ellipsis(_name, `${d.data.name}` + (showSizeInName ? ` (${d.data.size})` : ''), d.x1 - d.x0 - NODE_PADDING);
                const lineHeight = 22;
                const _info = _node.append('text')
                    .attr('class', 'treemap__node-info-text')
                    .attr('transform', `translate(${(d.x1 - d.x0) / 2}, ${(d.y1 - d.y0) / 2})`)
                    .attr('dy', lineHeight)
                    .attr('text-anchor', 'middle')
                    .attr('style', `font-size: 12px; opacity: .7; fill: ${_this._chartColorService.getContrast(d.data.color, ColorType.HEX)}`);
                if (d.data.info && (d.y1 - d.y0 > 40)) {
                    ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING);
                }
            });
        }
        this._buildActionsMenu(nodeGroup, openMenu);
    }
    _updateChartForGroups(dim) {
        this._g.selectAll('g').remove();
        this._dataBuilderForGroups(this._g, dim);
    }
    _showParentLabel(item, data) {
        item
            .select('.treemap-node-parent-label > foreignObject')
            .attr('style', `opacity: 1; height: 1px; overflow: visible; width: ${data.x1 - data.x0}px;`);
    }
    _hideParentLabel(item) {
        item
            .select('.treemap-node-parent-label > foreignObject')
            .attr('style', 'opacity: 0; height: 1px; overflow: hidden; width: 0;');
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _buildActionsMenu(nodeGroup, openMenu) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        // Draw kebab menu icon
        nodeGroup
            .append('g')
            .attr('class', 'treemap__actions-menu')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .each(function (d) {
            if (d.data.actions) {
                const _node = d3.select(this);
                _node.attr('tabindex', 0)
                    .attr('role', 'button')
                    .attr('aria-haspopup', true)
                    .attr('aria-expanded', false);
                _node.append('rect')
                    .attr('cursor', 'pointer')
                    .attr('fill', 'transparent')
                    .attr('height', 20)
                    .attr('width', 20)
                    .attr('transform', `translate(${(d.x1 - d.x0) - 24}, 10)`);
                _node.append('g')
                    .attr('transform', `translate(${(d.x1 - d.x0) - 24}, 10)`)
                    .html(ai_ellipsis.data)
                    .select('svg')
                    .attr('cursor', 'pointer')
                    .attr('fill', d.textColor)
                    .attr('height', 20)
                    .attr('width', 20);
            }
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('click', function (d) {
            if (d.data.actions) {
                d3.event.stopPropagation();
                _this._targetWithActions = d3.select(this);
                openMenu(d3.event, d.data);
            }
        })
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('keydown', function (d) {
            var _a, _b;
            if (!((_b = (_a = d.data) === null || _a === void 0 ? void 0 : _a.actions) === null || _b === void 0 ? void 0 : _b.length)) {
                return;
            }
            if (d3.event.keyCode === ENTER || d3.event.keyCode === DOWN_ARROW || d3.event.keyCode === SPACE) {
                d3.event.preventDefault();
                _this._targetWithActions = d3.select(this);
                openMenu(d3.event, d.data);
            }
            if ((d3.event.keyCode === ESCAPE) && _this.menuContainer.isOpen()) {
                d3.event.preventDefault();
                _this._closeMenu();
            }
        });
    }
    _openMenu(event, context) {
        this._closeTooltip();
        this.menuContainer.placement = ['bottom-right', 'top-right', 'right', 'left'];
        this.menuContainer.positionTo = this._targetWithActions.node();
        this.menuData = { target: this._targetWithActions.node(), event, context, actions: context.actions };
        if (this.menuContainer.isOpen()) {
            this._closeMenu();
        }
        else {
            this.menuContainer.open(event);
            this._targetWithActions.attr('aria-expanded', true);
        }
        SafeCdr.detectChanges(this._changeDetectorRef);
    }
    _closeMenu() {
        var _a;
        if (this.menuContainer) {
            this.menuContainer.close();
            (_a = this._targetWithActions) === null || _a === void 0 ? void 0 : _a.attr('aria-expanded', false);
        }
        this._removeListeners();
    }
    _isDataContainsActions(data) {
        return data.children.some(item => item.actions && item.actions.length
            || item.children && item.children.some(childrenItem => childrenItem.actions && childrenItem.actions.length));
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _openTooltip(target, context, customCls, offset) {
        this.chartBase.showTooltip(target.node(), this.tooltip || this.treemapDefaultTooltip, context, customCls, offset);
    }
    _closeTooltip() {
        this.chartBase.hideTooltip();
        this._removeListeners();
    }
    _prepareLegend() {
        let legendItems = [];
        const data = this.innerData;
        const flattenData = this._flattenByChildren(data.children);
        // In case if data contains "color" property assume that user use "custom colors" approach to control colors
        if (flattenData.some(d => d.color)) {
            legendItems = flattenData;
        }
        else {
            if (isDefined(data.status)) {
                legendItems.push({
                    name: data.name,
                    status: data.status,
                    color: data.status === AdaptChartColorStatus.Custom
                        ? data.customColorsRange
                        : ChartColorService.getColorRange(data.status, 1)
                });
            }
            data.children.forEach((elem) => {
                if (isDefined(elem.status)) {
                    const sameStatuses = legendItems.filter((lItem) => {
                        return elem.status !== AdaptChartColorStatus.Custom && elem.status === lItem.status;
                    });
                    if (!sameStatuses.length) {
                        legendItems.push({
                            name: elem.name,
                            status: elem.status,
                            color: elem.status === AdaptChartColorStatus.Custom
                                ? elem.customColorsRange
                                : ChartColorService.getColorRange(elem.status, 1)
                        });
                    }
                }
            });
        }
        if (legendItems.length) {
            legendItems.sort((a, b) => {
                return a.status - b.status;
            });
            return Object.assign({ columns: 1, items: legendItems.map(el => el.name), customColors: legendItems.map(el => isArray(el.color) ? el.color[0] : el.color), activeHover: false, activeClick: false }, this.legend);
        }
    }
    _prepareGroupLegend() {
        const data = this.innerData;
        if (data.children) {
            return Object.assign({ columns: 1, items: data.children.map(el => el.name), customColors: data.children.map(el => isArray(el.color) ? el.color[0] : el.color), activeHover: false, activeClick: false }, this.legend);
        }
    }
    _initLegend() {
        if (this.suppressLegend) {
            return;
        }
        if (!this.gradientLegend) {
            this._legend = this.groupView ? this._prepareGroupLegend() : this._prepareLegend();
        }
    }
    _updateLegend(isFirstChange) {
        if (this.suppressLegend) {
            return;
        }
        if (!isFirstChange) {
            if (!this.gradientLegend) {
                this._legend = this.groupView ? this._prepareGroupLegend() : this._prepareLegend();
                this.chartBase.updateLegend(this._legend.items);
            }
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _ellipsis(textNode, text, ellipsisWidth) {
        const letters = text.split('');
        const ellipsis = textNode.append('tspan').attr('class', 'ellipsis').text('...');
        const width = ellipsisWidth - ellipsis.node().getComputedTextLength();
        const numWords = letters.length;
        const tspan = textNode.insert('tspan', ':first-child').text(letters.join(''));
        // Try the whole line
        // While it's too long, and we have words left, keep removing words
        while (tspan.node().getComputedTextLength() > width && letters.length) {
            letters.pop();
            tspan.text(letters.join(''));
        }
        if (letters.length === numWords) {
            ellipsis.remove();
        }
    }
    _removeListeners() {
        if (this._removeClickEventListener) {
            this._removeClickEventListener();
            this._removeClickEventListener = null;
        }
        if (this._removeScrollEventListener) {
            this._removeScrollEventListener();
            this._removeScrollEventListener = null;
        }
    }
    _removeTooltipMouseleaveListener() {
        if (isDefined(this._tooltipEl) && isFunction(this._tooltipMouseleaveHandler)) {
            this._tooltipEl.removeEventListener('mouseleave', this._tooltipMouseleaveHandler);
            this._tooltipEl = null;
            this._tooltipMouseleaveHandler = null;
        }
    }
    _flattenByChildren(array, result = []) {
        array.forEach(el => {
            if (el.children) {
                this._flattenByChildren(el.children, result);
            }
            else {
                result.push(el);
            }
        });
        return result;
    }
    _getRelatedToLegendNodes(index) {
        const currentLegendItem = this._legend.items[parseInt(index, 10)];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const allNodes = this._g.selectAll('.treemap-node');
        return allNodes.filter(node => node.data.id.indexOf(currentLegendItem) > -1);
    }
}
AdaptTreemapComponent.ɵfac = function AdaptTreemapComponent_Factory(t) { return new (t || AdaptTreemapComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.ChartColorService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptTreemapComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTreemapComponent, selectors: [["adapt-treemap"]], viewQuery: function AdaptTreemapComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 5, AdaptDropdownToggleDirective);
        i0.ɵɵviewQuery(_c3, 5, AdaptDropdownDirective);
        i0.ɵɵviewQuery(_c4, 5);
        i0.ɵɵviewQuery(AdaptListKeyManagerItemDirective, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartBase = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treemapDefaultTooltip = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treemapGroupTooltip = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuAnchor = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionsListRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", gradientLegend: "gradientLegend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", data: "data", noDataText: "noDataText", showSizeInName: "showSizeInName", groupView: "groupView" }, outputs: { clickChart: "clickChart", groupEntered: "groupEntered" }, exportAs: ["treemap"], features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 14, vars: 14, consts: [[3, "data", "width", "height", "backgroundColor", "header", "legend", "gradientLegend", "suppressHeader", "suppressLegend", "dataBuilder", "updateChart", "noDataText", "topSectionTemplate", "categoryEnter", "categoryLeave"], ["chartBase", ""], ["class", "dropdown treemap-chart_hidden-menu", "adaptDropdown", "", 3, "adaptRadarDisableEventSending", "appendToBody", "restoreFocusAfterClose", "popupAnimationDone", 4, "ngIf"], ["treemapDefaultTooltip", ""], ["treemapGroupTooltip", ""], ["treemapBreadCrumbsTemplate", ""], ["adaptDropdown", "", 1, "dropdown", "treemap-chart_hidden-menu", 3, "adaptRadarDisableEventSending", "appendToBody", "restoreFocusAfterClose", "popupAnimationDone"], ["menuContainer", ""], ["adaptDropdownToggle", "", "type", "button"], ["menuAnchor", ""], ["adaptDropdownMenuTemplate", ""], ["tabindex", "0", "aria-labelledby", "dropdownMenu", 1, "dropdown-menu", 3, "keydown"], ["optionsListRef", ""], [4, "ngIf"], ["class", "dropdown-item", "type", "button", "role", "button", "tabindex", "-1", "adaptListKeyManagerItem", "", 3, "text-active", "id", "click", 4, "ngFor", "ngForOf"], ["type", "button", "role", "button", "tabindex", "-1", "adaptListKeyManagerItem", "", 1, "dropdown-item", 3, "id", "click"], [1, "treemap__group-tooltip"], [1, "adapt-chart-tooltip-color-spot", "mr-1"], ["class", "breadcrumb mb-0", 4, "ngIf"], [1, "breadcrumb", "mb-0"], ["class", "breadcrumb-item", 3, "active", 4, "ngFor", "ngForOf"], [1, "breadcrumb-item"], ["href", "javascript:void(0)", 3, "click", 4, "ngIf"], ["href", "javascript:void(0)", 3, "click"]], template: function AdaptTreemapComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "adapt-chart", 0, 1);
        i0.ɵɵlistener("categoryEnter", function AdaptTreemapComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptTreemapComponent_Template_adapt_chart_categoryLeave_0_listener($event) { return ctx.categoryLeave($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(2, "\n\n");
        i0.ɵɵtemplate(3, AdaptTreemapComponent_div_3_Template, 8, 3, "div", 2);
        i0.ɵɵtext(4, "\n\n");
        i0.ɵɵtemplate(5, AdaptTreemapComponent_ng_template_5_Template, 10, 2, "ng-template", null, 3, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n\n");
        i0.ɵɵtemplate(8, AdaptTreemapComponent_ng_template_8_Template, 9, 4, "ng-template", null, 4, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(10, "\n\n");
        i0.ɵɵtemplate(11, AdaptTreemapComponent_ng_template_11_Template, 3, 1, "ng-template", null, 5, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(13, "\n");
    } if (rf & 2) {
        const _r6 = i0.ɵɵreference(12);
        i0.ɵɵproperty("data", ctx.innerData)("width", ctx.width)("height", ctx.height)("backgroundColor", ctx.backgroundColor)("header", ctx.header)("legend", ctx._legend)("gradientLegend", ctx.gradientLegend)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("dataBuilder", ctx.groupView ? ctx.dataBuilderForGroupsBind : ctx.dataBuilderBind)("updateChart", ctx.groupView ? ctx.updateChartForGroupsBind : ctx.updateChartBind)("noDataText", ctx.noDataText)("topSectionTemplate", _r6);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.hasActionMenu);
    } }, directives: [i2.AdaptChartComponent, i3.NgIf, i4.AdaptDropdownDirective, i4.AdaptDropdownToggleDirective, i4.AdaptDropdownMenuTemplateDirective, i3.NgForOf, i4.AdaptListKeyManagerItemDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTreemapComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-treemap',
                templateUrl: './treemap.component.html',
                exportAs: 'treemap'
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i1.ChartColorService }, { type: i0.ChangeDetectorRef }]; }, { chartBase: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], treemapDefaultTooltip: [{
            type: ViewChild,
            args: ['treemapDefaultTooltip', { static: true }]
        }], treemapGroupTooltip: [{
            type: ViewChild,
            args: ['treemapGroupTooltip', { static: true }]
        }], menuAnchor: [{
            type: ViewChild,
            args: ['menuAnchor', {
                    read: AdaptDropdownToggleDirective,
                    static: false
                }]
        }], menuContainer: [{
            type: ViewChild,
            args: ['menuContainer', { read: AdaptDropdownDirective, static: false }]
        }], optionsListRef: [{
            type: ViewChild,
            args: ['optionsListRef', { static: false }]
        }], items: [{
            type: ViewChildren,
            args: [AdaptListKeyManagerItemDirective]
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], legend: [{
            type: Input
        }], gradientLegend: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], data: [{
            type: Input
        }], noDataText: [{
            type: Input
        }], showSizeInName: [{
            type: Input
        }], groupView: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], groupEntered: [{
            type: Output
        }] }); })();
//# sourceMappingURL=treemap.component.js.map