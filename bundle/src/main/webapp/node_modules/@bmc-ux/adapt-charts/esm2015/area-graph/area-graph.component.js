import { Component, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { asapScheduler, timer } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import BigNumber from 'bignumber.js';
import * as d3 from 'd3';
import { inRange } from 'lodash-es';
import { CutNumberPipe } from '../common/pipes/cut-number.pipe';
import { ColorType } from '@bmc-ux/adapt-angular';
import { AdaptLineGraphComponent } from '../line-graph/line-graph.component';
import * as i0 from "@angular/core";
import * as i1 from "../common/chart.component";
import * as i2 from "@angular/common";
import * as i3 from "./area-graph-slider.component";
function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-area-graph-slider", 3);
    i0.ɵɵlistener("rangeChanged", function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_rangeChanged_0_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.rangeChanged($event); })("scrollEnd", function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_scrollEnd_0_listener() { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.scrollEnd(); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("data", ctx_r0.sliderData)("xAxis", ctx_r0.xAxis)("slidePointsCount", ctx_r0.slidePointsCount)("customColors", ctx_r0.legend == null ? null : ctx_r0.legend.customColors)("xBrush", ctx_r0.xBrush)("leftShift", ctx_r0.leftShift)("containerWidth", ctx_r0.chartWidth);
} }
function AdaptAreaGraphComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 4);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵelementStart(3, "div", 5);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelement(5, "span", 6);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementStart(7, "span", 7);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n    ");
    i0.ɵɵelementStart(11, "div");
    i0.ɵɵtext(12);
    i0.ɵɵelementStart(13, "span");
    i0.ɵɵelementStart(14, "b");
    i0.ɵɵtext(15);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n\n    ");
    i0.ɵɵelementStart(18, "div");
    i0.ɵɵtext(19);
    i0.ɵɵelementStart(20, "span");
    i0.ɵɵelementStart(21, "b");
    i0.ɵɵtext(22);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(23, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(24, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n");
} if (rf & 2) {
    const data_r6 = ctx.data;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵstyleProp("background", data_r6 == null ? null : data_r6.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.category);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.getTooltipXValueTitle(), ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.xValue);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r2.yAxis == null ? null : ctx_r2.yAxis.title, ":\n      ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(data_r6.yValue);
} }
let chartCounter = 1;
export class AdaptAreaGraphComponent extends AdaptLineGraphComponent {
    constructor() {
        super(...arguments);
        this._data = [];
        this._series = [];
        this.circleRadius = 4;
        this.areaOpacity = 0.25;
        this.areaOpacityForHovered = 0.75;
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
    }
    getTooltipXValueTitle() {
        return 'x';
    }
    ngOnInit() {
        super.ngOnInit();
        this._id = `area-graph-${chartCounter++}`;
    }
    ngAfterViewInit() {
        // The change consists of two line graphs (one is the main, second in the slider),
        // so need to check the chart view after they both have been drawn
        timer(0, asapScheduler)
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            this._detectViewChanges();
        });
    }
    getXMaxValue(data) {
        let maxYVal = data[0].xyPointData[0].x;
        data.forEach(dataItem => {
            // assume that last value is the biggest value
            const value = dataItem.xyPointData[dataItem.xyPointData.length - 1].x;
            if (value > maxYVal) {
                maxYVal = value;
            }
        });
        return maxYVal;
    }
    getXMinValue(data) {
        let minYVal = data[0].xyPointData[0].x;
        data.forEach(dataItem => {
            // assume that first value is the lowest value
            const value = dataItem.xyPointData[0].x;
            if (value < minYVal) {
                minYVal = value;
            }
        });
        return minYVal;
    }
    getCircleColor() {
        return 'transparent';
    }
    getLineRenderer() {
        return d3.line()
            .x((d) => this._xPos(d.x))
            .y((d) => this._y(d.y));
    }
    getXPosFunc(dim, domain = []) {
        const [min, max] = domain;
        return d3.scaleLinear()
            .range([0, dim.w - (this._margin.left + this._margin.right)])
            .domain([min || this.getXMinValue(this._data), max || this.getXMaxValue(this._data)]);
    }
    getYPosFunc(dim, ticksVal) {
        return d3.scaleLinear()
            .range([0, dim.h - this._margin.bottom - this._margin.top])
            .domain([ticksVal[0], 0]);
    }
    getXAxisLineRenderer(dim) {
        var _a;
        const baseRenderer = super.getXAxisLineRenderer(dim);
        const cats = [...this.xAxis.categories];
        if (cats && cats.length) {
            // for proper rendering with categories
            const maxX = this.getXMaxValue(this._data);
            const minX = this.getXMinValue(this._data);
            const minMaxRange = maxX - minX;
            const tickStep = minMaxRange / (cats.length - 1);
            let tickValuesArray = cats.map((category, index) => minX + tickStep * index);
            if (this.showSlider && ((_a = this.sliderDomainData) === null || _a === void 0 ? void 0 : _a.length)) {
                const [min, max] = this.sliderDomainData;
                tickValuesArray = tickValuesArray.filter((tick, index) => {
                    if (inRange(tick, min, max)) {
                        return true;
                    }
                    cats[index] = null;
                });
            }
            return baseRenderer
                .tickValues(tickValuesArray)
                .tickFormat((val, ind) => cats.filter(category => !!category)[ind]);
        }
        if (this.showSlider && this.slidePointsCount) {
            baseRenderer.ticks(this.slidePointsCount);
        }
        if (this.formatXAxisValue) {
            return baseRenderer.tickFormat(this.formatXAxisValue);
        }
        return baseRenderer;
    }
    mapDataFromSeries(series) {
        return series.map((item) => {
            return {
                name: item.name,
                hidden: item.hidden,
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                data: item.data,
                xyPointData: item.data, // used in area
            };
        });
    }
    // TODO check for type improvement
    // eslint-disable-next-line
    drawAreaForSeries(lineWrapper, dt, i) {
        lineWrapper.append('path')
            .datum(dt.xyPointData)
            .classed('line-graph-transition line-chart-area', true)
            .attr('clip-path', `url(#${this._id}_clip)`)
            .attr('fill', this._colors[i])
            .attr('fill-opacity', this.areaOpacity)
            .attr('stroke', 'none')
            .attr('d', this.getAreaFilling())
            .on('mouseover', (data, ind, group) => {
            this.fillAreaDarkerColor(group[ind]);
        })
            .on('mouseout', (data, ind, group) => {
            this.fillAreaDefaultColor(group[ind]);
        });
    }
    onCircleMouseover(circleEl, dt, d) {
        super.onCircleMouseover(circleEl, dt, d);
        this.fillAreaDarkerColor(d3.select(circleEl.closest('.line-chart-line-g')).select('.line-chart-area').node());
    }
    onCircleMouseout(circleEl) {
        super.onCircleMouseout(circleEl);
        this.fillAreaDefaultColor(d3.select(circleEl.closest('.line-chart-line-g')).select('.line-chart-area').node());
    }
    getCircleDarkenColor(baseColor, circleParentLineSelection) {
        return this._colorService.getDarken(circleParentLineSelection.attr('stroke'), .15, ColorType.HEX);
    }
    getDataForCirclesOrLines(dt) {
        return dt.xyPointData;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    setCirclePosition(circleSel) {
        return circleSel
            .attr('cx', (d) => this._xPos(d.x))
            .attr('cy', (d) => this._y(d.y));
    }
    updateLinesAreas() {
        this._g.selectAll('.line-chart-area').each((dat, i, g) => {
            d3.select(g[i]).attr('d', this.getAreaFilling());
        });
    }
    restrictXPosTicks() {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const ticksCount = this._x.ticks();
        if (this.showSlider && this.slidePointsCount) {
            this._x = d3.scaleLinear()
                .range([0, this._dim.w - (this._margin.left + this._margin.right)])
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .domain([ticksCount[0], ticksCount[this.slidePointsCount]]);
        }
    }
    getTooltipData(baseColor, dt, d) {
        return {
            color: baseColor,
            category: dt.name,
            xValue: d.x,
            yValue: this.scientificMode ? new BigNumber(d.y).toPrecision(2, 2) : d.y,
        };
    }
    getDataYValues(row) {
        return row.xyPointData.map((item) => item.y);
    }
    get _xPos() {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        return this._x;
    }
    getAreaFilling() {
        return d3.area()
            .x((d) => this._xPos(d.x))
            .y0(this._y(0))
            .y1((d) => this._y(d.y));
    }
    fillAreaDarkerColor(el) {
        d3.select(el).attr('fill-opacity', this.areaOpacityForHovered);
    }
    fillAreaDefaultColor(el) {
        d3.select(el).attr('fill-opacity', this.areaOpacity);
    }
}
AdaptAreaGraphComponent.ɵfac = /*@__PURE__*/ function () { let ɵAdaptAreaGraphComponent_BaseFactory; return function AdaptAreaGraphComponent_Factory(t) { return (ɵAdaptAreaGraphComponent_BaseFactory || (ɵAdaptAreaGraphComponent_BaseFactory = i0.ɵɵgetInheritedFactory(AdaptAreaGraphComponent)))(t || AdaptAreaGraphComponent); }; }();
AdaptAreaGraphComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptAreaGraphComponent, selectors: [["adapt-area-graph"]], inputs: { formatXAxisValue: "formatXAxisValue", getTooltipXValueTitle: "getTooltipXValueTitle" }, outputs: { categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵProvidersFeature([CutNumberPipe]), i0.ɵɵInheritDefinitionFeature], decls: 8, vars: 14, consts: [[3, "width", "height", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "header", "noDataText", "updateChart", "dataBuilder", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd", 4, "ngIf"], ["tooltipTpl", ""], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd"], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptAreaGraphComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "adapt-chart", 0);
        i0.ɵɵlistener("categoryShow", function AdaptAreaGraphComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptAreaGraphComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptAreaGraphComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptAreaGraphComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵtemplate(2, AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template, 1, 7, "adapt-area-graph-slider", 1);
        i0.ɵɵtext(3, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(4, "\n\n");
        i0.ɵɵtemplate(5, AdaptAreaGraphComponent_ng_template_5_Template, 26, 7, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("width", ctx.width)("height", ctx.height)("legend", ctx.legend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("header", ctx.header)("noDataText", ctx.noDataText)("updateChart", ctx._updateChartBind)("dataBuilder", ctx._dataBuilderBind)("colorsPalette", ctx.colorsPalette);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.showSlider && ctx.slidePointsCount && ctx.chartWidth);
    } }, directives: [i1.AdaptChartComponent, i2.NgIf, i3.AdaptAreaGraphSliderComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptAreaGraphComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-area-graph',
                templateUrl: '../line-graph/line-graph.component.html',
                providers: [CutNumberPipe],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { formatXAxisValue: [{
            type: Input
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], getTooltipXValueTitle: [{
            type: Input
        }] }); })();
//# sourceMappingURL=area-graph.component.js.map