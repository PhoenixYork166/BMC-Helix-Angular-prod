import { Component, EventEmitter, Input, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { ANIMATION_DURATION, ColorType, isString, isUndefined } from '@bmc-ux/adapt-angular';
import { isFunction } from 'lodash-es';
import BigNumber from 'bignumber.js';
import * as d3 from 'd3';
import { AdaptChartSliderComponent } from '../common/chart-slider/chart-slider.component';
import { AdaptChartComponent } from '../common/chart.component';
import { AdaptChartSliderType } from '../common/models/chart.model';
import { CutNumberPipe } from '../common/pipes/cut-number.pipe';
import { ChartColorService } from '../common/services/chart-color.service';
import { nameof } from '../common/utils/chart-utils';
import { textEllipsis } from '../common/utils/text-ellipsis';
import { AdaptStackedChartAbstract, AdaptStackedChartType } from '../common/models/stacked-chart.model';
import * as i0 from "@angular/core";
import * as i1 from "../common/pipes/cut-number.pipe";
import * as i2 from "../common/services/chart-color.service";
import * as i3 from "../common/chart.component";
import * as i4 from "@angular/common";
import * as i5 from "../common/chart-slider/chart-slider.component";
const _c0 = ["tooltipTpl"];
const _c1 = ["tooltipListInfoTpl"];
function AdaptStackedChartComponent_adapt_chart_slider_4_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-chart-slider", 5);
    i0.ɵɵlistener("rangeChanged", function AdaptStackedChartComponent_adapt_chart_slider_4_Template_adapt_chart_slider_rangeChanged_0_listener($event) { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.changeDataRange($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("slidePointsCount", ctx_r1.slidePointsCount)("height", ctx_r1.sliderHeight)("xAxis", ctx_r1.xAxis)("data", ctx_r1.sliderData)("containerWidth", ctx_r1.chartWidth)("customColors", ctx_r1.legend == null ? null : ctx_r1.legend.customColors)("leftShift", ctx_r1.leftShift)("type", ctx_r1.sliderType)("stackedChart", ctx_r1.getStackedChart());
} }
function AdaptStackedChartComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 6);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "div");
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelement(5, "span", 7);
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementStart(7, "span", 8);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n          ");
    i0.ɵɵelementStart(10, "span");
    i0.ɵɵelementStart(11, "b");
    i0.ɵɵtext(12);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n        ");
    i0.ɵɵelementStart(15, "div");
    i0.ɵɵtext(16, "\n          Total:\n          ");
    i0.ɵɵelementStart(17, "span");
    i0.ɵɵelementStart(18, "b");
    i0.ɵɵtext(19);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(20, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(21, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(22, "\n    ");
} if (rf & 2) {
    const data_r8 = ctx.data;
    i0.ɵɵadvance(5);
    i0.ɵɵstyleProp("background-color", data_r8 == null ? null : data_r8.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("", data_r8.category, ":");
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(data_r8.value);
    i0.ɵɵadvance(7);
    i0.ɵɵtextInterpolate(data_r8.total);
} }
function AdaptStackedChartComponent_ng_template_10_div_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelement(2, "span", 7);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "span", 8);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵelementStart(7, "span");
    i0.ɵɵelementStart(8, "b");
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const d_r11 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("background-color", d_r11 == null ? null : d_r11.color);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("", d_r11.category, ":");
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate(d_r11.value);
} }
function AdaptStackedChartComponent_ng_template_10_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptStackedChartComponent_ng_template_10_div_3_ng_container_2_Template, 11, 4, "ng-container", 12);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const d_r11 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", d_r11.value !== 0);
} }
function AdaptStackedChartComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 9);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtemplate(3, AdaptStackedChartComponent_ng_template_10_div_3_Template, 4, 1, "div", 10);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵelement(5, "hr", 11);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementStart(7, "div");
    i0.ɵɵtext(8, "\n          Total:\n          ");
    i0.ɵɵelementStart(9, "span");
    i0.ɵɵelementStart(10, "b");
    i0.ɵɵtext(11);
    i0.ɵɵelementEnd();
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(14, "\n    ");
} if (rf & 2) {
    const data_r9 = ctx.data;
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", data_r9.seriesData);
    i0.ɵɵadvance(8);
    i0.ɵɵtextInterpolate(data_r9.total);
} }
let chartCounter = 1;
const DEFAULT_MARGIN = 10;
// TODO update types
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export class AdaptStackedChartComponent extends AdaptStackedChartAbstract {
    constructor(_cutNumber, _colorService) {
        super();
        this._cutNumber = _cutNumber;
        this._colorService = _colorService;
        this.sliderType = AdaptChartSliderType.bar;
        this.sliderHeight = 36;
        this.heightZero = 0;
        this.showSlider = false;
        this.hasTotalLabels = false;
        this.rotateXAxis = false;
        this.scientificMode = false;
        /*
        * Useful to prevent legend rendering on view(eg. on chart slider component)
        * @since 11.4.0
        */
        this.renderLegend = true;
        this.showEmptyColIndicator = true;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.clickChart = new EventEmitter();
        /**
         * Output that emits each time chart category shown
         * @since 12.11.0
         */
        this.categoryShow = new EventEmitter();
        /**
         * Output that emits each time chart category hidden
         * @since 12.11.0
         */
        this.categoryHide = new EventEmitter();
        this.alreadyChanged = false;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._data = [];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._dataFull = [];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._colors = [];
        this._maxTicksCount = 7;
        this._totalByCol = {};
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._categoryFilter = [];
        // Default values of xAxis, yAxis and axisTitle thickness
        this._axisXThickness = 50;
        this._axisYThickness = 25;
        this._axisTitleThickness = 20;
        this._legend = {
            columns: 2,
            activeHover: true,
            activeClick: true,
            width: 250,
            customColors: null,
            items: []
        };
        this._series = [];
        this._startDataPiece = 0;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._cls = {
            axis: 'adapt-chart-axis',
            axisHidden: 'adapt-chart-axis__hidden',
            axisTitle: 'adapt-chart-axis-title',
            axisXTitle: 'adapt-chart-axis-x-title',
            axisYTitle: 'adapt-chart-axis-y-title',
            barXAxis: 'bar-x-axis',
            barYAxis: 'bar-y-axis',
            colXAxis: 'col-x-axis',
            colYAxis: 'col-y-axis',
            category: 'adapt-chart-bars-category',
            areaGroup: 'adapt-chart-area-group',
            areaTooltipLines: 'adapt-chart-area-tooltip-lines',
            dataRect: 'adapt-chart-data-rect',
            totalLabelsGroup: 'total-labels-group',
            totalLabelsGroupItem: 'total-labels-group-item',
            totalLabelItem: 'total-label-item',
            thresholdLineArea: 'threshold-line-area'
        };
        this._emptyColIndicatorWidth = 22;
        this._emptyColIndicatorHeight = 24;
        this.updateChart = this.updateChart.bind(this);
        this._dataBuilder = this._dataBuilder.bind(this);
        this._id = `stacked-chart-${chartCounter++}`;
    }
    get isHorizontalSeries() {
        return this.seriesDisplay === 'horizontal';
    }
    set series(s) {
        this.sliderData = s;
        this._categoryFilter = [];
        s.forEach(series => {
            if (series.hidden) {
                this._categoryFilter.push(series.name);
            }
        });
        if (this.showSlider) {
            this._series = this._getDataRange();
        }
        else {
            this._series = s;
        }
        if (this.alreadyChanged) {
            const options = this.chartComponent.getGroupAndDimensions();
            this._g = options.group;
            this._dim = {
                w: options.w,
                h: options.h
            };
        }
        if (this._g && this._dim && this.chartComponent) {
            this.chartComponent.updateLegend(this.series.map((item) => ({
                item: item.name,
                hidden: !!item.hidden,
                hover: false
            })));
        }
    }
    get series() {
        return this._series;
    }
    set legend(legend) {
        this._legend = Object.assign(this._legend, legend);
        if (this.alreadyChanged) {
            this.chartComponent.redrawChart();
        }
    }
    get legend() {
        return {
            customColors: this._legend.customColors,
            activeHover: this._legend.activeHover,
            activeClick: this._legend.activeClick,
            columns: this._legend.columns,
            width: this._legend.width,
            items: (this.series && this.series.map((series) => ({
                item: series.name,
                hidden: !!series.hidden
            })))
        };
    }
    get leftShift() {
        return this._margin.left;
    }
    get chartWidth() {
        return this.width || this.chartComponent.chartWidth;
    }
    get duration() {
        return parseFloat(ANIMATION_DURATION.fast) * 1000;
    }
    get _margin() {
        return {
            top: 0,
            left: !this.hideAxises && this.xAxis ?
                (this.xAxis.thickness || this._axisXThickness) + (this.xAxis.title ? this._axisTitleThickness : 0) : 0,
            right: 0,
            bottom: !this.hideAxises && this.yAxis ?
                (this.yAxis.thickness || this._axisYThickness) + (this.yAxis.title ? this._axisTitleThickness : 0) : 0
        };
    }
    ngOnInit() {
        if (this.scientificMode) {
            BigNumber.config({ EXPONENTIAL_AT: 4 });
        }
        if (this.showSlider && !this.slidePointsCount) {
            this._initSlidePointsCount();
        }
        this.alreadyChanged = true;
    }
    ngOnChanges(changes) {
        if ((changes[nameof('type')]
            || changes[nameof('showSlider')]
            || changes[nameof('thresholdLine')]
            || changes[nameof('seriesDisplay')]
            || changes[nameof('hasTotalLabels')]
            || changes[nameof('barWidth')]
            || changes[nameof('rotateXAxis')])
            && this.alreadyChanged && this._dim) {
            this.chartComponent.redrawChart();
        }
    }
    updateChart(dim) {
        if (dim) {
            this._dim = dim;
        }
        else {
            dim = this._dim;
        }
        this._initData();
        this._prepareOrdinal();
        this._updateAxisX(dim);
        this._updateAxisY(dim);
        this._updateData();
        this._updateThresholdLineArea();
    }
    _dataBuilder(g, dim) {
        this._g = g;
        this._dim = dim;
        this._clear();
        this._initData();
        this._prepareOrdinal();
        this._drawAxisX(g, dim);
        this._drawAxisY(g, dim);
        this._drawData(g);
        this._updateThresholdLineArea();
    }
    getStackedChart() {
        return this;
    }
    categoryEnterHandler(categoryEvent) {
        const categoryGroup = this._g.select(`[data-category-id='${categoryEvent.id}']`);
        const categoryGroupColor = categoryGroup.attr('fill');
        const hoveredColor = this._colorService.getDarken(categoryGroupColor, .15, ColorType.HEX);
        this._highlightColor = categoryGroupColor;
        categoryGroup.attr('fill', hoveredColor);
    }
    categoryLeaveHandler(categoryEvent) {
        const categoryGroup = this._g.select(`[data-category-id='${categoryEvent.id}']`);
        categoryGroup.attr('fill', this._highlightColor);
    }
    categoryShowHandler(category) {
        const categoryId = this._categoryFilter.indexOf(category);
        if (categoryId !== -1) {
            this._categoryFilter.splice(categoryId, 1);
        }
        this.updateChart(null);
        if (!isUndefined(this.chartSliderComponent)) {
            this.chartSliderComponent.showCategory(category);
        }
        this.categoryShow.emit({ category });
    }
    categoryHideHandler(category) {
        this._categoryFilter.push(category);
        this.updateChart(null);
        if (!isUndefined(this.chartSliderComponent)) {
            this.chartSliderComponent.hideCategory(category);
        }
        this.categoryHide.emit({ category });
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    clickChartArea(e) {
        const target = e.target;
        const isRect = target.classList.contains(this._cls.dataRect);
        if (isRect) {
            const color = d3.select(target.parentNode).attr('fill');
            const categoryId = target.parentNode.getAttribute('data-category-id');
            const category = this.series[categoryId].name;
            const id = target.getAttribute('data-id');
            const value = this._data[id][category];
            const keys = Object.keys(this._data[id]);
            const axisCategory = this._data[id].name;
            const nameId = keys.indexOf('name');
            keys.splice(nameId, 1);
            const total = keys.reduce((acc, c) => acc + this._data[id][c], 0);
            this.clickChart.emit({
                event: e,
                data: this.series.filter((d) => category === d.name)[0],
                axisCategory,
                color,
                categoryId: category,
                value,
                total
            });
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    changeDataRange(range) {
        this._startDataPiece = range.startPiece;
        this._endDataPiece = range.endPiece;
        this._series = this._getDataRange();
        this._totalByCol = {};
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getFormattedSeries(data) {
        const formattedData = data.series.map(d => {
            return {
                categoryName: d.name,
                seriesValues: Object.entries(d).filter(v => v[0] !== 'name')
            };
        });
        const currentCategory = formattedData.find(d => d.categoryName === data.category);
        const total = currentCategory.seriesValues.reduce((acc, cur) => acc + cur[1], 0);
        currentCategory.seriesValues = currentCategory.seriesValues.map((d, i) => {
            return {
                category: d[0],
                value: d[1],
                color: this.legend.customColors ? this._getCustomColorById(i) : this._colorService.getColor(i)
            };
        });
        return {
            seriesData: currentCategory.seriesValues,
            total
        };
    }
    _initData() {
        if (this.showSlider) {
            this._endDataPiece = this._endDataPiece || this.slidePointsCount;
        }
        const ctg = this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories;
        this._data = [];
        this._dataFull = [];
        ctg.forEach((c, index) => {
            const o = {
                name: c
            };
            this.series.forEach((s) => {
                if (this._categoryFilter.indexOf(s.name) === -1) {
                    o[s.name] = o[s.name] || 0;
                    o[s.name] += s.data[index];
                }
                else {
                    o[s.name] = 0;
                }
            });
            this._data.push(o);
        });
        this.xAxis.categories.forEach((c, index) => {
            const o = {
                name: c
            };
            this.sliderData.forEach((s) => {
                if (this._categoryFilter.indexOf(s.name) === -1) {
                    o[s.name] = o[s.name] || 0;
                    o[s.name] += s.data[index];
                }
                else {
                    o[s.name] = 0;
                }
            });
            this._dataFull.push(o);
        });
        this._data.forEach((data) => {
            const { name } = data;
            const categories = Object.keys(data);
            this._totalByCol[name] = 0;
            categories.forEach((category) => {
                if (category !== 'name') {
                    if (this.scientificMode) {
                        this._totalByCol[name] = new BigNumber(this._totalByCol[name]).plus(data[category]);
                    }
                    else {
                        this._totalByCol[name] += data[category];
                    }
                }
            });
        });
    }
    _prepareOrdinal() {
        this._keys = this.series.map((s) => s.name);
        this._colors = [];
        this.series.forEach((s, id) => {
            this._colors.push(this._legend.customColors ? this._getCustomColorById(id) : this._colorService.getColor(id));
        });
        this._ordinal = d3.scaleOrdinal()
            .range(this._colors)
            .domain(this._keys);
    }
    _drawAxisX(g, dim) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._drawAxisXForBar(g, dim);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._drawAxisXForColumn(g, dim);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._drawAxisXForArea(g, dim);
                break;
            }
        }
    }
    _drawAxisXForBar(g, dim) {
        const ticks = this._getTicks().reverse();
        this._drawAxisTitle(g, dim, this.xAxis.title, true);
        this._xScale = d3.scaleLinear();
        this._xScale.rangeRound([dim.w - this._margin.left - this._margin.right, 0]).domain([ticks[0], 0]);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickValues(ticks)
            .tickSize(-dim.h + this._margin.top + this._margin.bottom)
            .tickFormat((d, i) => isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver(d, i) : this._getTickFormatForNumber(d))
            .tickPadding(15);
        g.append('g')
            .attr('role', 'axis')
            .attr('class', `${this._cls.axis} ${this._cls.barXAxis} ${this.hideAxises ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`)
            .transition()
            .duration(this.duration)
            .call(this._xAxisCall);
    }
    _drawAxisXForColumn(g, dim) {
        const axisWidth = dim.w - this._margin.left - this._margin.right;
        setTimeout(() => {
            const axisXTitleBlock = g.select(`.${this._cls.axisXTitle}`);
            axisXTitleBlock.remove();
            this._drawAxisTitle(g, dim, this.xAxis.title);
        }, this.duration + 100);
        this._xScale = d3.scaleBand();
        this._xScale
            .range([0, axisWidth])
            .padding(0.25)
            .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickFormat(isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
            .tickSizeOuter(0)
            .tickPadding(12);
        this.chartComponent.updateChartBottomPadding(axisWidth, this._g, this.xAxis, this.rotateXAxis);
        const axisBlock = g.append('g')
            .attr('role', 'title')
            .attr('class', `${this._cls.axis} ${this._cls.colXAxis} ${this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.bottom})`);
        axisBlock
            .call(this._xAxisCall);
        if (this.rotateXAxis) {
            setTimeout(() => {
                this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
                if (!this.hideAxises) {
                    axisBlock.classed(this._cls.axisHidden, null);
                }
            }, this.duration);
        }
    }
    _drawAxisXForArea(g, dim) {
        const axisWidth = dim.w - this._margin.left - this._margin.right;
        setTimeout(() => {
            const axisXTitleBlock = g.select(`.${this._cls.axisXTitle}`);
            axisXTitleBlock.remove();
            this._drawAxisTitle(g, dim, this.xAxis.title);
        }, this.duration + 100);
        this._xScale = d3.scalePoint()
            .range([0, this._dim.w - this._margin.left - this._margin.right])
            .domain(this.xAxis.categories);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickFormat(isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
            .tickSizeOuter(0)
            .tickPadding(12);
        this.chartComponent.updateChartBottomPadding(axisWidth, this._g, this.xAxis, this.rotateXAxis);
        const axisBlock = g.append('g')
            .attr('role', 'title')
            .attr('class', `${this._cls.axis} ${this._cls.colXAxis} ${this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.bottom})`);
        axisBlock
            .call(this._xAxisCall);
        if (this.rotateXAxis) {
            setTimeout(() => {
                this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
                if (!this.hideAxises) {
                    axisBlock.classed(this._cls.axisHidden, null);
                }
            }, this.duration);
        }
    }
    _drawAxisY(g, dim) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._drawAxisYForBar(g, dim);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._drawAxisYForColumn(g, dim);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._drawAxisYForColumn(g, dim);
                break;
            }
        }
    }
    _drawAxisYForBar(g, dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        this._drawAxisTitle(g, dim, this.yAxis.title);
        this._yScale = d3.scaleBand()
            .rangeRound([0, dim.h - this._margin.top - this._margin.bottom])
            .padding(0.25)
            .domain(this.xAxis.categories);
        this._yAxisCall = d3
            .axisLeft(this._yScale)
            .tickSizeOuter(0)
            .tickFormat(function (d) {
            return _self._getTickFormatForString(d, this);
        });
        g.append('g')
            .attr('role', 'axis')
            .attr('class', `${this._cls.axis} ${this._cls.barYAxis} ${this.hideAxises ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, 0)`)
            .transition()
            .duration(this.duration)
            .call(this._yAxisCall);
    }
    _drawAxisYForColumn(g, dim) {
        const ticks = this._getTicks().reverse();
        this._drawAxisTitle(g, dim, this.yAxis.title, true);
        this._yScale = d3.scaleLinear()
            .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
            .domain([ticks[0], 0]);
        this._yAxisCall = d3.axisLeft(this._yScale)
            .tickValues(ticks)
            .tickPadding(8)
            .tickFormat((d) => this._getTickFormatForNumber(d))
            .tickSize(-dim.w + this._margin.left + this._margin.right);
        g.append('g')
            .attr('role', 'axis')
            .attr('class', `${this._cls.axis} ${this._cls.colYAxis} ${this.hideAxises ? this._cls.axisHidden : ''}`)
            .attr('transform', `translate(${this._margin.left}, 0)`)
            .transition()
            .duration(this.duration)
            .call(this._yAxisCall);
    }
    _drawData(g) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._drawDataBars(g);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._drawDataColumns(g);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._drawDataArea(g);
                break;
            }
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _drawDataBars(g) {
        let baseColor;
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        this._bars = g.append('g')
            .attr('role', 'data')
            .selectAll('g')
            .data(d3.stack().keys(this._keys)(this._data));
        const _xScale = this._xScale;
        this._bars
            .enter()
            .append('g')
            .attr('data-category-id', (d, i) => i)
            .attr('role', 'group')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('aria-label', function (d, i) {
            return _this.series[i].name;
        })
            .attr('class', (d, i) => `category-${i}`)
            .attr('class', this._cls.category)
            .attr('fill', (d) => this._ordinal(d.key))
            .selectAll('rect')
            .data(d => d)
            .enter()
            .append('rect')
            .attr('class', this._cls.dataRect)
            .attr('role', 'item')
            .attr('data-id', (d, id) => id)
            .attr('x', (d) => _xScale(d[0]) + this._margin.left + 1)
            .attr('y', (d) => this._getBarYPosition(d.data.name))
            .attr('width', (d) => _xScale(d[1]) - _xScale(d[0]) === 0 ? this.heightZero : _xScale(d[1]) - _xScale(d[0]))
            .attr('height', this.barWidth ? this.barWidth : this._yScale.bandwidth())
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .on('mouseenter', function (d) {
            const { target } = d3.event;
            const categoryId = target.parentNode.getAttribute('data-category-id');
            _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipTemplate, {
                data: {
                    color: baseColor,
                    category: _this.series[categoryId].name,
                    value: _this._dividePoints(d[0], d[1]),
                    total: _this._totalByCol[d.data.name],
                    data: _this.series[categoryId],
                    event: d3.event
                }
            });
        })
            .on('mouseleave', function () {
            const rect = d3.select(this);
            _this.chartComponent.hideTooltip();
            rect.attr('fill', null);
        })
            .on('mouseover', function () {
            const self = d3.select(this);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            baseColor = self.select(function () {
                return this.parentNode;
            }).attr('fill');
            const darkenColor = _this._colorService.getDarken(baseColor, .15, ColorType.HEX);
            self.attr('fill', darkenColor);
        });
        if (this.showEmptyColIndicator) {
            // check for the bar(s) with no data
            const zeroBars = Object.keys(this._totalByCol).filter((key) => this._totalByCol[key] === 0);
            // indicate bar with no data
            zeroBars.forEach(bar => {
                const colYPos = this._yScale(bar) - this._margin.top;
                const yAttr = colYPos + this._yScale.bandwidth() / 2 - this._emptyColIndicatorHeight / 2;
                const xAttr = this._margin.left + DEFAULT_MARGIN;
                this._drawEmptyDataIndicator(xAttr, yAttr, bar);
            });
        }
        this._bars.exit().remove();
    }
    _getBarYPosition(d) {
        return this.barWidth
            ? this._yScale(d) + this._margin.top + (this._yScale.bandwidth() / 2) - (this.barWidth / 2)
            : this._yScale(d) + this._margin.top;
    }
    _getWidthForColumn() {
        return this.barWidth
            ? this.barWidth
            : this.isHorizontalSeries
                ? this._xScale.bandwidth() / this.series.length
                : this._xScale.bandwidth();
    }
    _getColumnYPosForHorizontalSeries(d) {
        return this._yScale(d[0] ? d[1] - d[0] : d[1]);
    }
    _dividePoints(a, b) {
        return this.scientificMode
            ? new BigNumber(b).minus(a).toString()
            : Number((b - a).toFixed(6)).toString();
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _getColumnXPos(d, node) {
        const xPos = this._xScale(d) + this._margin.left;
        if (this.isHorizontalSeries) {
            if (this.barWidth) {
                return xPos
                    // Based on category index calculate offset for each bar
                    + (this._getCurrentCategoryIndex(node) - (this.series.length / 2)) * this._getWidthForColumn()
                    + (this._xScale.bandwidth() / 2);
            }
            else {
                return xPos + (this._getCurrentCategoryIndex(node) * this._getWidthForColumn());
            }
        }
        else {
            return this.barWidth
                ? xPos + (this._xScale.bandwidth() / 2) - (this._getWidthForColumn() / 2)
                : xPos;
        }
    }
    _getColumnYPos(d) {
        return this.isHorizontalSeries ?
            this._getColumnYPosForHorizontalSeries(d) :
            this._yScale(d[1]);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _setYPos(d) {
        if (this._yScale(0) - this._getColumnYPosForHorizontalSeries(d) === 0) {
            return this._getColumnYPos(d) - this.heightZero;
        }
        else {
            return this._getColumnYPos(d);
        }
    }
    _setRectPositionAndScaleForColumnsType(selection) {
        return selection
            .attr('x', (d, i, groups) => this._getColumnXPos(d.data.name, groups[i]))
            .attr('y', (d) => this._setYPos(d))
            .attr('height', (d) => this.isHorizontalSeries ?
            (this._yScale(0) - this._getColumnYPosForHorizontalSeries(d) === 0 ?
                this.heightZero : this._yScale(0) - this._getColumnYPosForHorizontalSeries(d)) :
            (this._yScale(d[0]) - this._yScale(d[1]) === 0) ? this.heightZero : this._yScale(d[0]) - this._yScale(d[1]))
            .attr('width', () => this._getWidthForColumn());
    }
    _drawDataColumns(g) {
        let baseColor;
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        this._bars = g.append('g')
            .attr('role', 'data')
            .selectAll('g')
            .data(d3.stack().keys(this._keys)(this._data));
        const gContainer = this._bars
            .enter()
            .append('g')
            .attr('data-category-id', (d, i) => i)
            .attr('role', 'group')
            .attr('aria-label', (d, i) => this.series[i].name)
            .attr('fill', (d) => this._ordinal(d.key))
            .attr('class', this._cls.category)
            .selectAll('rect')
            .data(d => d)
            .enter();
        let selection = gContainer
            .append('rect')
            .attr('class', this._cls.dataRect)
            .attr('role', 'item')
            .attr('aria-label', (d) => `${d.data.name}.: ${this._dividePoints(d[0], d[1])}`)
            .attr('data-id', (d, id) => id);
        selection = this._setRectPositionAndScaleForColumnsType(selection);
        if (this.showEmptyColIndicator) {
            // check for the column(s) with no data
            const zeroCols = Object.keys(this._totalByCol).filter((key) => this._totalByCol[key] === 0);
            // indicate column with no data
            zeroCols.forEach(col => {
                const colXPos = this._xScale(col) + this._margin.left;
                const xAttr = colXPos + this._xScale.bandwidth() / 2 - this._emptyColIndicatorWidth / 2;
                const yAttr = this._dim.h - this._margin.bottom - this._emptyColIndicatorHeight - DEFAULT_MARGIN;
                this._drawEmptyDataIndicator(xAttr, yAttr, col);
            });
        }
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        selection.on('mouseenter', function (d) {
            const { target } = d3.event;
            let sv = 0;
            let i = 0;
            const keys = Object.keys(d.data).filter(k => k !== 'name');
            for (i; i < keys.length; i++) {
                if (d[0] === sv && d[1] === sv + d.data[keys[i]]) {
                    break;
                }
                else {
                    sv += d.data[keys[i]];
                }
            }
            _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipTemplate, {
                data: {
                    color: baseColor,
                    category: keys[i],
                    value: _this._dividePoints(d[0], d[1]),
                    total: _this._totalByCol[d.data.name],
                    data: _this.series.filter((r) => r.name === keys[i]),
                    event: d3.event
                }
            });
        })
            .on('mouseleave', function () {
            const self = d3.select(this);
            _this.chartComponent.hideTooltip();
            self.attr('fill', null);
        })
            .on('mouseover', function () {
            const self = d3.select(this);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            baseColor = self.select(function () {
                return this.parentNode;
            }).attr('fill');
            const darkenColor = _this._colorService.getDarken(baseColor, .15, ColorType.HEX);
            self.attr('fill', darkenColor);
        });
        this._addTotalLabels(g);
        this._bars.exit().remove();
    }
    _drawDataArea(g) {
        const series = d3.stack().keys(this._keys)(this._data);
        const ticks = this._getTicks();
        this._xScale = d3.scalePoint();
        this._xScale
            .range([this._margin.left + this._margin.right, this._dim.w])
            .domain(this.xAxis.categories);
        this._yScale = d3.scaleLinear();
        this._yScale
            .rangeRound([0, this._dim.h - this._margin.bottom - this._margin.top])
            .domain([ticks[ticks.length - 1], 0]);
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const area = d3.area()
            .x((d, i) => this._xScale(this.xAxis.categories[i]))
            .y0(d => this._yScale(d[0]))
            .y1(d => this._yScale(d[1]));
        g.append('g')
            .attr('class', this._cls.areaGroup)
            .selectAll('path')
            .data(series)
            .join('path')
            .attr('data-category-id', (d, i) => i)
            .attr('aria-label', (d, i) => this.series[i].name)
            .attr('fill', (d) => this._ordinal(d.key))
            .attr('class', this._cls.category)
            .attr('d', area);
        this._g.selectAll(`.${this._cls.areaTooltipLines}`).remove();
        this._drawTooltipLinesForArea(g, this._dim);
    }
    _drawTooltipLinesForArea(g, dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _this = this;
        const _xScale = d3.scalePoint()
            .range([0, dim.w - this._margin.left - this._margin.right])
            .domain(this.xAxis.categories);
        const _xAxisCall = d3.axisBottom(_xScale)
            .tickSize(-dim.h + this._margin.top + this._margin.bottom)
            .tickPadding(0);
        const areaBlock = g.append('g')
            .attr('role', 'axis')
            .attr('class', `${this._cls.colYAxis} ${this._cls.areaTooltipLines}`)
            .attr('transform', `translate(${this._margin.left}, ${dim.h - this._margin.top - this._margin.bottom})`);
        areaBlock.transition().duration(this.duration).call(_xAxisCall);
        areaBlock.select('path').attr('opacity', 0);
        areaBlock.selectAll('g text').remove();
        areaBlock.selectAll('g line').attr('opacity', 0);
        areaBlock
            .selectAll('g')
            .append('rect')
            .attr('pointer-events', 'all')
            .attr('width', 20)
            .attr('height', dim.h - this._margin.top - this._margin.bottom)
            .attr('x', -10)
            .attr('y', -dim.h + this._margin.top + this._margin.bottom)
            .on('mouseover', function (category) {
            const parent = d3.select(this.parentNode);
            parent.select('line').attr('opacity', 1);
            const { target } = d3.event;
            _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipListInfoTemplate, { data: _this.getFormattedSeries({ category, series: _this._data, event: d3.event }) }, null, null, true);
        })
            .on('mouseout', function () {
            const parent = d3.select(this.parentNode);
            parent.select('line').attr('opacity', 0);
            _this.chartComponent.hideTooltip();
        });
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _addTotalLabels(g) {
        const labelsGroup = g.append('g')
            .attr('class', this._cls.totalLabelsGroup)
            .attr('opacity', this.hasTotalLabels ? '1' : '0')
            .attr('text-anchor', 'middle');
        this._createTotalLabelsGroupsItems(labelsGroup);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _createTotalLabelsGroupsItems(labelsGroup) {
        labelsGroup
            .selectAll(`g.${this._cls.totalLabelsGroupItem}`)
            .data(this._getTotalLabelsData())
            .enter()
            .append('g')
            .attr('class', this._cls.totalLabelsGroupItem)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('opacity', (d) => this._getTotalLabelGroupOpacity(d))
            .selectAll('g')
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .data((d) => d)
            .enter()
            .append('g')
            .attr('class', this._cls.totalLabelItem)
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .attr('transform', (d, i, groups) => this._getTotalLabelTransform(d, groups[i]))
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            .append('text').text((d) => this._getTotalLabelText(d))
            .attr('fill', 'currentColor')
            .exit().remove();
    }
    _getTotalLabelGroupOpacity(d) {
        return (!this.isHorizontalSeries || this._categoryFilter.indexOf(d.key) === -1) ? '1' : '0';
    }
    _getTotalLabelText(d) {
        const value = this.isHorizontalSeries ? d[1] - d[0] : this._totalByCol[d.data.name];
        if (this.totalLabelTextFormatter) {
            return this.totalLabelTextFormatter(value, d);
        }
        return value;
    }
    _getTotalLabelTransform(d, swg) {
        return `translate(${this._getColumnXPos(d.data.name, swg) + this._getWidthForColumn() / 2}, ${this._getColumnYPos(d) - 9})`;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _getTotalLabelsData() {
        const labelsDataArr = d3.stack().keys(this._keys)(this._data);
        return this.isHorizontalSeries ?
            labelsDataArr :
            labelsDataArr.splice(-1);
    }
    _getCurrentCategoryIndex(group) {
        return d3.select(group.parentNode).datum().index;
    }
    _getTicks() {
        const data = this._dataFull.map((row) => {
            const keys = Object.keys(row)
                .filter((key) => key !== 'name');
            return this.isHorizontalSeries ?
                Math.max(...keys.map(key => row[key]))
                : keys.reduce((acc, value) => {
                    return acc + row[value];
                }, 0);
        });
        let max = Math.max(...data);
        if (max === 0) {
            max = 1;
        }
        if (this.thresholdLine && this.thresholdLine > max) {
            max = this.thresholdLine;
        }
        let currentStep = Math.pow(10, Math.floor(Math.log10(max))) / 2;
        const step = Math.pow(10, Math.floor(Math.log10(max))) / 2;
        let count = Math.floor(max / currentStep) + 1;
        while (count >= this._maxTicksCount) {
            currentStep += step;
            count = Math.floor(max / currentStep) + 1;
        }
        return (new Array(count)).fill(0).map((v, id) => (id + 1) * currentStep);
    }
    _clear() {
        this.chartComponent.clear();
        this._data = [];
    }
    _updateData() {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                const _xScale = this._xScale;
                this._g
                    .selectAll(`.${this._cls.category}`)
                    .data(d3.stack().keys(this._keys)(this._data))
                    .selectAll('rect')
                    .data(d => d)
                    .attr('y', (d) => this._yScale(d.data.name) + (this.barWidth ? Math.floor(this._yScale.bandwidth() / 2 - this.barWidth / 2) : 0) + this._margin.top)
                    .attr('height', this.barWidth || this._yScale.bandwidth())
                    .transition()
                    .duration(this.duration)
                    .attr('width', (d) => _xScale(d[1]) - _xScale(d[0]))
                    .attr('x', (d) => _xScale(d[0]) + this._margin.left + 1);
                break;
            }
            case AdaptStackedChartType.Column: {
                const selection = this._g
                    .selectAll(`.${this._cls.category}`)
                    .data(d3.stack().keys(this._keys)(this._data))
                    .selectAll('rect')
                    .data(d => d)
                    .transition()
                    .duration(this.duration);
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                this._setRectPositionAndScaleForColumnsType(selection);
                if (this.showEmptyColIndicator) {
                    /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                    const _self = this;
                    const emptyDataIndicatorLists = this._g.selectAll('g[class="tick empty-column"]');
                    emptyDataIndicatorLists.each(function () {
                        const elem = d3.select(this);
                        const col = elem.attr('aria-column');
                        const colXPos = _self._xScale(col) + _self._margin.left;
                        const xAttr = colXPos + _self._xScale.bandwidth() / 2 - _self._emptyColIndicatorWidth / 2;
                        const yAttr = _self._dim.h - _self._margin.bottom - _self._emptyColIndicatorHeight - DEFAULT_MARGIN;
                        elem.transition().duration(_self.duration).attr('transform', `translate(${xAttr}, ${yAttr})`);
                    });
                }
                break;
            }
            case AdaptStackedChartType.Area: {
                this._g.selectAll(`.${this._cls.areaGroup}`).remove();
                this._drawDataArea(this._g);
                break;
            }
        }
        const totalsGroup = this._g
            .selectAll(`.${this._cls.totalLabelsGroup}`);
        totalsGroup.transition()
            .duration(this.duration)
            .attr('opacity', this.hasTotalLabels ? '1' : '0');
        if (this.hasTotalLabels) {
            const groupsItems = totalsGroup
                .selectAll(`.${this._cls.totalLabelsGroupItem}`)
                .data(this._getTotalLabelsData());
            groupsItems.exit().remove();
            this._createTotalLabelsGroupsItems(totalsGroup);
            groupsItems
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('opacity', (d) => this._getTotalLabelGroupOpacity(d))
                .selectAll(`.${this._cls.totalLabelItem}`)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .data((d) => d)
                .transition()
                .duration(this.duration)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', (d, i, groups) => this._getTotalLabelTransform(d, groups[i]))
                .selectAll('text')
                .text((d) => this._getTotalLabelText(d));
        }
    }
    _updateThresholdLineArea() {
        let thresholdLineArea = this._g.select(`.${this._cls.thresholdLineArea}`);
        if (!this.thresholdLine) {
            thresholdLineArea.remove();
            return;
        }
        if (thresholdLineArea.empty()) {
            thresholdLineArea = this._g.append('g')
                .attr('class', this._cls.thresholdLineArea);
            thresholdLineArea.append('rect')
                .attr('class', 'threshold-area-rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('fill', '#000000')
                .attr('style', 'pointer-events: none; opacity: .1;');
            const defs = thresholdLineArea.append('defs');
            defs.append('marker')
                .attr('class', 'threshold-line-marker')
                .attr('id', `${this._id}-marker-start`)
                .attr('viewBox', '0 0 6 8')
                .attr('markerWidth', 6)
                .attr('markerHeight', 8)
                .attr('refX', 5)
                .attr('refY', 4)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 6 4 L 0 8 z');
            defs.append('marker')
                .attr('class', 'threshold-line-marker')
                .attr('id', `${this._id}-marker-end`)
                .attr('viewBox', '0 0 6 8')
                .attr('markerWidth', 6)
                .attr('markerHeight', 8)
                .attr('refX', 1)
                .attr('refY', 4)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 4 L 6 0 L 6 8 z');
            thresholdLineArea.append('line')
                .attr('class', 'threshold-line')
                .attr('stroke-width', 1)
                .attr('marker-start', `url(#${this._id}-marker-start)`)
                .attr('marker-end', `url(#${this._id}-marker-end)`);
            thresholdLineArea.append('text')
                .attr('class', 'threshold-line-title-background');
            thresholdLineArea.append('text')
                .attr('class', 'threshold-line-title');
        }
        const maxTick = this._getTicks().pop(); // get the max tick
        const chartDataAreaWidth = this._dim.w - this._margin.left - this._margin.right;
        const chartDataAreaHeight = this._dim.h - this._margin.top - this._margin.bottom;
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                const thresholdLineAreaWidth = chartDataAreaWidth - chartDataAreaWidth / maxTick * this.thresholdLine;
                const thresholdLineAreaLeftShift = this._margin.left + chartDataAreaWidth - thresholdLineAreaWidth;
                thresholdLineArea.select('rect.threshold-area-rect')
                    .transition()
                    .duration(this.duration)
                    .attr('transform', `translate(${thresholdLineAreaLeftShift}, 0)`)
                    .attr('width', thresholdLineAreaWidth)
                    .attr('height', chartDataAreaHeight);
                thresholdLineArea.select('line.threshold-line')
                    .transition()
                    .duration(this.duration)
                    .attr('x1', thresholdLineAreaLeftShift)
                    .attr('x2', thresholdLineAreaLeftShift)
                    .attr('y1', this._margin.top)
                    .attr('y2', this._margin.top + chartDataAreaHeight);
                thresholdLineArea.select('text.threshold-line-title-background')
                    .transition()
                    .duration(this.duration)
                    .attr('x', thresholdLineAreaLeftShift)
                    .attr('y', this._margin.top + chartDataAreaHeight)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '24')
                    .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                thresholdLineArea.select('text.threshold-line-title')
                    .transition()
                    .duration(this.duration)
                    .attr('x', thresholdLineAreaLeftShift)
                    .attr('y', this._margin.top + chartDataAreaHeight)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '24')
                    .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                break;
            }
            case AdaptStackedChartType.Column:
            case AdaptStackedChartType.Area: {
                const thresholdLineAreaHeight = chartDataAreaHeight - chartDataAreaHeight / maxTick * this.thresholdLine;
                thresholdLineArea.select('rect.threshold-area-rect')
                    .transition()
                    .duration(this.duration)
                    .attr('transform', `translate(${this._margin.left}, 0)`)
                    .attr('width', chartDataAreaWidth)
                    .attr('height', thresholdLineAreaHeight);
                thresholdLineArea.select('line.threshold-line')
                    .transition()
                    .duration(this.duration)
                    .attr('x1', this._margin.left)
                    .attr('x2', this._dim.w)
                    .attr('y1', thresholdLineAreaHeight)
                    .attr('y2', thresholdLineAreaHeight);
                thresholdLineArea.select('text.threshold-line-title-background')
                    .transition()
                    .duration(this.duration)
                    .attr('x', this._margin.left - 8)
                    .attr('y', thresholdLineAreaHeight)
                    .attr('text-anchor', 'end')
                    .attr('dy', '.32em')
                    .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                thresholdLineArea.select('text.threshold-line-title')
                    .transition()
                    .duration(this.duration)
                    .attr('x', this._margin.left - 8)
                    .attr('y', thresholdLineAreaHeight)
                    .attr('text-anchor', 'end')
                    .attr('dy', '.32em')
                    .text(this.scientificMode ? new BigNumber(this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                break;
            }
        }
        // If we have the same tick as the thresholdLine - remove that
        d3.selectAll('g.tick')
            .filter(d => d === this.thresholdLine)
            .remove();
    }
    _drawAxisTitle(g, dim, text, rotate = false) {
        if (!isString(text) || this.hideAxises) {
            return;
        }
        let translate;
        const axisTitle = g.append('g')
            .attr('class', `${this._cls.axisTitle} ${(rotate ? this._cls.axisYTitle : this._cls.axisXTitle)}`)
            .attr('role', 'title');
        if (rotate) {
            translate = `rotate(-90) translate(-${(dim.h - this._axisTitleThickness) / 2} ${this._axisTitleThickness / 2})`;
        }
        else {
            translate = `translate(${(dim.w + this._axisTitleThickness) / 2} ${dim.h + this.chartComponent.chartBottomPadding})`;
        }
        axisTitle
            .attr('transform', translate)
            .append('text')
            .text(text)
            .attr('text-anchor', 'middle')
            .attr('transform', `translate(${(this._axisTitleThickness / (rotate ? 2 : 1))} 0)`);
    }
    _updateAxisTitle(g, dim) {
        g.select(`.${this._cls.axisXTitle}`)
            .transition()
            .duration(this.duration)
            .attr('transform', `translate(${(dim.w + this._axisTitleThickness) / 2} ${dim.h + this.chartComponent.chartBottomPadding})`);
    }
    /* Update X Axis */
    _updateAxisX(dim) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._updateAxisXForBar(dim);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._updateAxisXForColumn(dim);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._updateAxisXForArea(dim);
                break;
            }
        }
    }
    _updateAxisXForBar(dim) {
        const ticks = this._getTicks().reverse();
        this._xScale = d3.scaleLinear();
        this._xScale.rangeRound([dim.w - this._margin.left - this._margin.right, 0]).domain([ticks[0], 0]);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickValues(ticks)
            .tickSize(-dim.h + this._margin.top + this._margin.bottom)
            .tickFormat((d, i) => isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver(d, i) : this._getTickFormatForNumber(d))
            .tickPadding(15);
        this._g.select(`.${this._cls.barXAxis}`)
            .transition()
            .duration(this.duration)
            .call(this._xAxisCall);
    }
    _updateAxisXForColumn(dim) {
        this._xScale = d3.scaleBand();
        this._xScale
            .range([0, dim.w - this._margin.left - this._margin.right])
            .padding(0.25)
            .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickFormat(isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
            .tickSizeOuter(0)
            .tickPadding(12);
        this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
        const axisBlock = this._g.select(`.${this._cls.colXAxis}`)
            .attr('class', `${this._cls.axis} ${this._cls.colXAxis} ${this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''}`);
        axisBlock
            .transition()
            .duration(this.duration)
            .call(this._xAxisCall);
        setTimeout(() => {
            this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
            if (!this.hideAxises) {
                axisBlock.classed(this._cls.axisHidden, null);
            }
        }, this.rotateXAxis ? this.duration + 100 : 0);
        this._updateAxisTitle(this._g, dim);
    }
    _updateAxisXForArea(dim) {
        this._xScale = d3.scalePoint();
        this._xScale
            .range([0, dim.w - this._margin.left - this._margin.right])
            .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
        this._xAxisCall = d3.axisBottom(this._xScale)
            .tickFormat(isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
            .tickSizeOuter(0)
            .tickPadding(12);
        this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
        const axisBlock = this._g.select(`.${this._cls.colXAxis}`)
            .attr('class', `${this._cls.axis} ${this._cls.colXAxis} ${this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''}`);
        axisBlock
            .transition()
            .duration(this.duration)
            .call(this._xAxisCall);
        setTimeout(() => {
            this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
            if (!this.hideAxises) {
                axisBlock.classed(this._cls.axisHidden, null);
            }
        }, this.rotateXAxis ? this.duration + 100 : 0);
        this._updateAxisTitle(this._g, dim);
    }
    /* Update Y Axis */
    _updateAxisY(dim) {
        switch (this.type) {
            case AdaptStackedChartType.Bar: {
                this._updateAxisYForBar(dim);
                break;
            }
            case AdaptStackedChartType.Column: {
                this._updateAxisYForColumn(dim);
                break;
            }
            case AdaptStackedChartType.Area: {
                this._updateAxisYForColumn(dim);
                break;
            }
        }
    }
    _updateAxisYForBar(dim) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
        const _self = this;
        this._yScale = d3.scaleBand()
            .rangeRound([0, dim.h - this._margin.top - this._margin.bottom])
            .padding(0.25)
            .domain(this.xAxis.categories);
        this._yAxisCall = d3
            .axisLeft(this._yScale)
            .tickSizeOuter(0)
            .tickFormat(function (d) {
            return _self._getTickFormatForString(d, this);
        });
        this._g.select(`.${this._cls.barYAxis}`)
            .transition()
            .duration(this.duration)
            .call(this._yAxisCall);
    }
    _updateAxisYForColumn(dim) {
        const ticks = this._getTicks().reverse();
        this._yScale = d3.scaleLinear()
            .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
            .domain([ticks[0], 0]);
        this._yAxisCall = d3.axisLeft(this._yScale)
            .tickValues(ticks)
            .tickFormat((d) => this._getTickFormatForNumber(d))
            .tickSize(-dim.w + this._margin.left + this._margin.right);
        this._g.select(`.${this._cls.colYAxis}`)
            .transition()
            .duration(this.duration)
            .call(this._yAxisCall);
    }
    _getCustomColorById(id) {
        const customColors = this._legend.customColors;
        const len = customColors.length;
        const index = id % len;
        return customColors[index];
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _getDataRange() {
        return this.sliderData.map((item) => {
            const { name, hidden } = item;
            let { data } = item;
            data = data.slice(this._startDataPiece, this._endDataPiece);
            return { name, data, hidden };
        });
    }
    _getDataLength() {
        return this._series[0].data.length;
    }
    _initSlidePointsCount() {
        const dataLength = this._getDataLength();
        if (dataLength < 12) {
            this.slidePointsCount = 4;
        }
        else if (dataLength >= 12 && dataLength < 36) {
            this.slidePointsCount = 6;
        }
        else {
            this.slidePointsCount = 12;
        }
        this.sliderMonitorsCount = Math.ceil(dataLength / this.slidePointsCount);
    }
    /* empty data indicator */
    _drawEmptyDataIndicator(x, y, column) {
        const emptyGroupInfo = this._g.select('g[role="data"]')
            .append('g')
            .attr('role', 'group')
            .attr('class', 'tick empty-column')
            .attr('aria-label', 'empty column')
            .attr('aria-column', column)
            .attr('transform', `translate(${x}, ${y})`);
        emptyGroupInfo.append('rect')
            .attr('role', 'item')
            .attr('width', this._emptyColIndicatorWidth)
            .attr('height', this._emptyColIndicatorHeight)
            .attr('rx', 2);
        emptyGroupInfo.append('text')
            .attr('x', this._emptyColIndicatorWidth / 2)
            .attr('y', this._emptyColIndicatorHeight / 2)
            .attr('alignment-baseline', 'middle')
            .attr('text-anchor', 'middle')
            .attr('dy', '.1rem')
            .text('0');
    }
    _getTickFormatForNumber(d) {
        return this.scientificMode
            ? new BigNumber(d).toPrecision(2, 2)
            : this._cutNumber.transform(d, 0);
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _getTickFormatForString(d, _this) {
        const tickNode = d3.select(_this);
        const ellipsisText = textEllipsis(tickNode, d, this.xAxis ? (this.xAxis.thickness || this._axisXThickness) : 0);
        if (ellipsisText !== d) {
            tickNode
                .on('mouseenter', () => {
                const { target } = d3.event;
                this.chartComponent.showTooltip(target, d);
            })
                .on('mouseleave', () => {
                this.chartComponent.hideTooltip();
            });
        }
        return ellipsisText;
    }
}
AdaptStackedChartComponent.ɵfac = function AdaptStackedChartComponent_Factory(t) { return new (t || AdaptStackedChartComponent)(i0.ɵɵdirectiveInject(i1.CutNumberPipe), i0.ɵɵdirectiveInject(i2.ChartColorService)); };
AdaptStackedChartComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptStackedChartComponent, selectors: [["adapt-stacked-chart"]], viewQuery: function AdaptStackedChartComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(AdaptChartComponent, 7);
        i0.ɵɵviewQuery(AdaptChartSliderComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tooltipListInfoTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.chartSliderComponent = _t.first);
    } }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", type: "type", xAxis: "xAxis", yAxis: "yAxis", showSlider: "showSlider", hasTotalLabels: "hasTotalLabels", seriesDisplay: "seriesDisplay", totalLabelTextFormatter: "totalLabelTextFormatter", barWidth: "barWidth", slidePointsCount: "slidePointsCount", hideAxises: "hideAxises", rotateXAxis: "rotateXAxis", xAxisTickFormatResolver: "xAxisTickFormatResolver", scientificMode: "scientificMode", renderLegend: "renderLegend", thresholdLine: "thresholdLine", showEmptyColIndicator: "showEmptyColIndicator", series: "series", legend: "legend" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0.ɵɵProvidersFeature([CutNumberPipe]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 12, vars: 16, consts: [[3, "width", "title", "description", "height", "header", "legend", "renderLegend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "noDataText", "updateChart", "dataBuilder", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave", "clickChart"], ["chart", ""], [3, "slidePointsCount", "height", "xAxis", "data", "containerWidth", "customColors", "leftShift", "type", "stackedChart", "rangeChanged", 4, "ngIf"], ["tooltipTpl", ""], ["tooltipListInfoTpl", ""], [3, "slidePointsCount", "height", "xAxis", "data", "containerWidth", "customColors", "leftShift", "type", "stackedChart", "rangeChanged"], [1, "adapt-chart-tooltip-content-container"], [1, "adapt-chart-tooltip-color-spot"], [1, "adapt-chart-tooltip-category"], [1, "chart-tooltip-content-container", "align-start"], [4, "ngFor", "ngForOf"], [1, "mt-1", "mb-1"], [4, "ngIf"]], template: function AdaptStackedChartComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "adapt-chart", 0, 1);
        i0.ɵɵlistener("categoryShow", function AdaptStackedChartComponent_Template_adapt_chart_categoryShow_1_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptStackedChartComponent_Template_adapt_chart_categoryHide_1_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptStackedChartComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx.categoryEnterHandler($event); })("categoryLeave", function AdaptStackedChartComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx.categoryLeaveHandler($event); })("clickChart", function AdaptStackedChartComponent_Template_adapt_chart_clickChart_1_listener($event) { return ctx.clickChartArea($event); });
        i0.ɵɵtext(3, "\n      ");
        i0.ɵɵtemplate(4, AdaptStackedChartComponent_adapt_chart_slider_4_Template, 1, 9, "adapt-chart-slider", 2);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n\n    ");
        i0.ɵɵtemplate(7, AdaptStackedChartComponent_ng_template_7_Template, 23, 5, "ng-template", null, 3, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(9, "\n    ");
        i0.ɵɵtemplate(10, AdaptStackedChartComponent_ng_template_10_Template, 15, 2, "ng-template", null, 4, i0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("width", ctx.width)("title", (ctx.header == null ? null : ctx.header.title) || "Graph chart")("description", (ctx.header == null ? null : ctx.header.subtitle) || "Graph chart")("height", ctx.height)("header", ctx.header)("legend", ctx.legend)("renderLegend", ctx.renderLegend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("noDataText", ctx.noDataText)("updateChart", ctx.updateChart)("dataBuilder", ctx._dataBuilder);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.showSlider);
    } }, directives: [i3.AdaptChartComponent, i4.NgIf, i5.AdaptChartSliderComponent, i4.NgForOf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptStackedChartComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-stacked-chart',
                template: `
    <adapt-chart #chart
                 [width]="width"
                 [title]="header?.title || 'Graph chart'"
                 [description]="header?.subtitle || 'Graph chart'"
                 [height]="height"
                 [header]="header"
                 [legend]="legend"
                 [renderLegend]="renderLegend"
                 [data]="series"
                 [backgroundColor]="backgroundColor"
                 [suppressHeader]="suppressHeader"
                 [suppressLegend]="suppressLegend"
                 [tooltip]="tooltip"
                 (categoryShow)="categoryShowHandler($event)"
                 (categoryHide)="categoryHideHandler($event)"
                 (categoryEnter)="categoryEnterHandler($event)"
                 (categoryLeave)="categoryLeaveHandler($event)"
                 (clickChart)="clickChartArea($event)"
                 [noDataText]="noDataText"
                 [updateChart]="updateChart"
                 [dataBuilder]="_dataBuilder">
      <adapt-chart-slider *ngIf="showSlider"
                          (rangeChanged)="changeDataRange($event)"
                          [slidePointsCount]="slidePointsCount"
                          [height]="sliderHeight"
                          [xAxis]="xAxis"
                          [data]="sliderData"
                          [containerWidth]="chartWidth"
                          [customColors]="legend?.customColors"
                          [leftShift]="leftShift"
                          [type]="sliderType"
                          [stackedChart]="getStackedChart()"></adapt-chart-slider>
    </adapt-chart>

    <ng-template #tooltipTpl let-data="data">
      <div class="adapt-chart-tooltip-content-container">
        <div>
          <span class="adapt-chart-tooltip-color-spot" [style.background-color]="data?.color"></span>
          <span class="adapt-chart-tooltip-category">{{ data.category }}:</span>
          <span><b>{{ data.value }}</b></span>
        </div>
        <div>
          Total:
          <span><b>{{ data.total }}</b></span>
        </div>
      </div>
    </ng-template>
    <ng-template #tooltipListInfoTpl let-data="data">
      <div class="chart-tooltip-content-container align-start">
        <div *ngFor="let d of data.seriesData">
          <ng-container *ngIf="d.value !== 0">
            <span class="adapt-chart-tooltip-color-spot" [style.background-color]="d?.color"></span>
            <span class="adapt-chart-tooltip-category">{{d.category}}:</span>
            <span><b>{{ d.value }}</b></span>
          </ng-container>
        </div>
        <hr class="mt-1 mb-1">
        <div>
          Total:
          <span><b>{{data.total}}</b></span>
        </div>
      </div>
    </ng-template>`,
                encapsulation: ViewEncapsulation.None,
                providers: [CutNumberPipe]
            }]
    }], function () { return [{ type: i1.CutNumberPipe }, { type: i2.ChartColorService }]; }, { tooltipTemplate: [{
            type: ViewChild,
            args: ['tooltipTpl', { static: true }]
        }], tooltipListInfoTemplate: [{
            type: ViewChild,
            args: ['tooltipListInfoTpl', { static: true }]
        }], chartComponent: [{
            type: ViewChild,
            args: [AdaptChartComponent, { static: true }]
        }], chartSliderComponent: [{
            type: ViewChild,
            args: [AdaptChartSliderComponent, { static: false }]
        }], backgroundColor: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], header: [{
            type: Input
        }], suppressHeader: [{
            type: Input
        }], suppressLegend: [{
            type: Input
        }], tooltip: [{
            type: Input
        }], dataBuilder: [{
            type: Input
        }], type: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showSlider: [{
            type: Input
        }], hasTotalLabels: [{
            type: Input
        }], seriesDisplay: [{
            type: Input
        }], totalLabelTextFormatter: [{
            type: Input
        }], barWidth: [{
            type: Input
        }], slidePointsCount: [{
            type: Input
        }], hideAxises: [{
            type: Input
        }], rotateXAxis: [{
            type: Input
        }], xAxisTickFormatResolver: [{
            type: Input
        }], scientificMode: [{
            type: Input
        }], renderLegend: [{
            type: Input
        }], thresholdLine: [{
            type: Input
        }], showEmptyColIndicator: [{
            type: Input
        }], clickChart: [{
            type: Output
        }], categoryShow: [{
            type: Output
        }], categoryHide: [{
            type: Output
        }], series: [{
            type: Input
        }], legend: [{
            type: Input
        }] }); })();
//# sourceMappingURL=stacked-chart.component.js.map