(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@bmc-ux/adapt-angular'), require('lodash-es'), require('bignumber.js'), require('d3'), require('rxjs'), require('@angular/cdk/portal'), require('rxjs/operators'), require('@angular/cdk/bidi'), require('@angular/platform-browser'), require('@angular/common'), require('@angular/cdk/keycodes'), require('@bmc-ux/dpl-iconfont'), require('@angular/cdk/a11y'), require('d3-shape'), require('@angular/forms'), require('@swimlane/ngx-graph')) :
    typeof define === 'function' && define.amd ? define('@bmc-ux/adapt-charts', ['exports', '@angular/core', '@bmc-ux/adapt-angular', 'lodash-es', 'bignumber.js', 'd3', 'rxjs', '@angular/cdk/portal', 'rxjs/operators', '@angular/cdk/bidi', '@angular/platform-browser', '@angular/common', '@angular/cdk/keycodes', '@bmc-ux/dpl-iconfont', '@angular/cdk/a11y', 'd3-shape', '@angular/forms', '@swimlane/ngx-graph'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["bmc-ux"] = global["bmc-ux"] || {}, global["bmc-ux"]["adapt-charts"] = {}), global.ng.core, global["@bmc-ux/adapt-angular"], global["lodash-es"], global.BigNumber, global.d3, global.rxjs, global.ng.cdk.portal, global.rxjs.operators, global.ng.cdk.bidi, global.ng.platformBrowser, global.ng.common, global.ng.cdk.keycodes, global.dplIconfont, global.ng.cdk.a11y, global.shape, global.ng.forms, global["@swimlane/ngx-graph"]));
})(this, (function (exports, i0, i1, lodashEs, BigNumber, d3, rxjs, portal, operators, i2, i3$1, i3, keycodes, dplIconfont, a11y, shape, i4, i5) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);
    var d3__namespace = /*#__PURE__*/_interopNamespace(d3);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);
    var i3__namespace$1 = /*#__PURE__*/_interopNamespace(i3$1);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var shape__namespace = /*#__PURE__*/_interopNamespace(shape);
    var i4__namespace = /*#__PURE__*/_interopNamespace(i4);
    var i5__namespace = /*#__PURE__*/_interopNamespace(i5);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var AdaptChartAbstract = /** @class */ (function () {
        function AdaptChartAbstract() {
        }
        return AdaptChartAbstract;
    }());
    AdaptChartAbstract.ɵfac = function AdaptChartAbstract_Factory(t) { return new (t || AdaptChartAbstract)(); };
    AdaptChartAbstract.ɵdir = /*@__PURE__*/ i0__namespace.ɵɵdefineDirective({ type: AdaptChartAbstract, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", noDataText: "noDataText" }, outputs: { clickChart: "clickChart" } });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptChartAbstract, [{
                type: i0.Directive
            }], null, { backgroundColor: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], header: [{
                    type: i0.Input
                }], legend: [{
                    type: i0.Input
                }], suppressHeader: [{
                    type: i0.Input
                }], suppressLegend: [{
                    type: i0.Input
                }], tooltip: [{
                    type: i0.Input
                }], dataBuilder: [{
                    type: i0.Input
                }], noDataText: [{
                    type: i0.Input
                }], clickChart: [{
                    type: i0.Output
                }] });
    })();
    exports.AdaptChartSliderType = void 0;
    (function (AdaptChartSliderType) {
        AdaptChartSliderType["bar"] = "bar";
        AdaptChartSliderType["line"] = "line";
        AdaptChartSliderType["scatterplot"] = "scatterplot";
    })(exports.AdaptChartSliderType || (exports.AdaptChartSliderType = {}));

    exports.AdaptStackedChartType = void 0;
    (function (AdaptStackedChartType) {
        AdaptStackedChartType["Bar"] = "bar";
        AdaptStackedChartType["Column"] = "column";
        AdaptStackedChartType["Area"] = "area";
    })(exports.AdaptStackedChartType || (exports.AdaptStackedChartType = {}));
    var AdaptStackedChartAbstract = /** @class */ (function (_super) {
        __extends(AdaptStackedChartAbstract, _super);
        function AdaptStackedChartAbstract() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AdaptStackedChartAbstract;
    }(AdaptChartAbstract));
    AdaptStackedChartAbstract.ɵfac = /*@__PURE__*/ function () { var ɵAdaptStackedChartAbstract_BaseFactory; return function AdaptStackedChartAbstract_Factory(t) { return (ɵAdaptStackedChartAbstract_BaseFactory || (ɵAdaptStackedChartAbstract_BaseFactory = i0__namespace.ɵɵgetInheritedFactory(AdaptStackedChartAbstract)))(t || AdaptStackedChartAbstract); }; }();
    AdaptStackedChartAbstract.ɵdir = /*@__PURE__*/ i0__namespace.ɵɵdefineDirective({ type: AdaptStackedChartAbstract, inputs: { type: "type", xAxis: "xAxis", yAxis: "yAxis", series: "series", hideAxises: "hideAxises", seriesDisplay: "seriesDisplay", showSlider: "showSlider", slidePointsCount: "slidePointsCount" }, features: [i0__namespace.ɵɵInheritDefinitionFeature] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptStackedChartAbstract, [{
                type: i0.Directive
            }], null, { type: [{
                    type: i0.Input
                }], xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }], series: [{
                    type: i0.Input
                }], hideAxises: [{
                    type: i0.Input
                }], seriesDisplay: [{
                    type: i0.Input
                }], showSlider: [{
                    type: i0.Input
                }], slidePointsCount: [{
                    type: i0.Input
                }] });
    })();

    var _c0$b = ["chart"];
    var _c1$8 = ["slider"];
    var _c2$5 = ["dnd"];
    var _c3$3 = ["overlay"];
    var _c4$3 = ["overlayLeft"];
    var _c5$2 = ["overlayRight"];
    var _c6$1 = function () { return {}; };
    function AdaptChartSliderComponent_ng_container_14_adapt_stacked_chart_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelement(0, "adapt-stacked-chart", 11, 12);
        }
        if (rf & 2) {
            var ctx_r6 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵproperty("suppressHeader", true)("suppressLegend", true)("renderLegend", false)("showEmptyColIndicator", false)("legend", null)("hideAxises", true)("xAxis", ctx_r6.xAxis)("yAxis", i0__namespace.ɵɵpureFunction0(12, _c6$1))("series", ctx_r6.data)("height", ctx_r6.height - ctx_r6.sliderPaddingTop)("type", ctx_r6.stackedChartType)("seriesDisplay", ctx_r6.stackedChart && ctx_r6.stackedChart.seriesDisplay);
        }
    }
    function AdaptChartSliderComponent_ng_container_14_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementContainerStart(0, 9);
            i0__namespace.ɵɵtext(1, "\n            ");
            i0__namespace.ɵɵtemplate(2, AdaptChartSliderComponent_ng_container_14_adapt_stacked_chart_2_Template, 2, 13, "adapt-stacked-chart", 10);
            i0__namespace.ɵɵtext(3, "\n          ");
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var ctx_r3 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵproperty("ngSwitch", ctx_r3.type);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngSwitchCase", ctx_r3.chartSliderType.bar);
        }
    }
    var id = 0;
    var classPrefix$1 = 'adapt-chart-slider';
    var sliderPaddingTop$1 = 10;
    var AdaptChartSliderComponent = /** @class */ (function () {
        function AdaptChartSliderComponent(_elementRef, _renderer, _changeDetectorRef) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._changeDetectorRef = _changeDetectorRef;
            this.chartSliderType = exports.AdaptChartSliderType;
            this.stackedChartType = exports.AdaptStackedChartType.Column;
            this.isActive = false;
            this.sliderSpotWidth = 50;
            this.initComplete = false;
            this.height = 45;
            // TODO: has to be refactored
            this.leftShift = 0;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this.rangeChanged = new i0.EventEmitter();
            this._inMotion = false;
            this._categoryFilter = [];
            this._x = 0;
            this._destroyed$ = new rxjs.ReplaySubject(1);
            id++;
            this.id = id;
            this.classPrefix = classPrefix$1;
            this.sliderPaddingTop = sliderPaddingTop$1;
        }
        Object.defineProperty(AdaptChartSliderComponent.prototype, "overlayLeftWidth", {
            get: function () {
                var sliderLeft = this._sliderEl.nativeElement.getBoundingClientRect().left;
                var left = this._dndEl.nativeElement.getBoundingClientRect().left;
                return left - sliderLeft;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptChartSliderComponent.prototype, "overlayRightWidth", {
            get: function () {
                var sliderLeft = this._sliderEl.nativeElement.getBoundingClientRect().left;
                var sliderWidth = this._sliderEl.nativeElement.getBoundingClientRect().width;
                var _a = this._dndEl.nativeElement.getBoundingClientRect(), left = _a.left, width = _a.width;
                return sliderWidth - (left - sliderLeft) - width;
            },
            enumerable: false,
            configurable: true
        });
        AdaptChartSliderComponent.prototype.ngOnInit = function () {
            var _this = this;
            this._dataCopy = this.data.slice();
            this._bodyMouseMoveLn = this._renderer.listen('body', 'mousemove', function (e) {
                if (_this._inMotion) {
                    var clientX = e.clientX;
                    var width = _this._dndEl.nativeElement.getBoundingClientRect().width;
                    var sliderWidth = _this._sliderEl.nativeElement.getBoundingClientRect().width;
                    var x = clientX - _this._sliderEl.nativeElement.getBoundingClientRect().left - _this._gap;
                    x = x < 0 ? 0 : x;
                    x = x > sliderWidth - width ? sliderWidth - width : x;
                    _this._updateOverlay(x);
                }
            });
            this._bodyMouseUpLn = this._renderer.listen('body', 'mouseup', function (e) {
                var target = e.target;
                if (target !== _this._dndEl.nativeElement) {
                    _this.isActive = false;
                }
                _this._inMotion = false;
            });
        };
        AdaptChartSliderComponent.prototype.ngAfterViewInit = function () {
            var width = this._sliderEl.nativeElement.getBoundingClientRect().width;
            var dataLength = this._getDataLength();
            var monitorsCount = Math.ceil(dataLength / this.slidePointsCount);
            this.monitorsCount = monitorsCount;
            this._width = width;
            this.sliderSpotWidth = width / monitorsCount;
            this._updateOverlay(0);
            this.initComplete = true;
            i1.SafeCdr.detectChanges(this._changeDetectorRef);
        };
        AdaptChartSliderComponent.prototype.ngOnDestroy = function () {
            this._destroyed$.next(true);
            this._destroyed$.complete();
            this._bodyMouseMoveLn();
            this._bodyMouseUpLn();
        };
        AdaptChartSliderComponent.prototype.onMouseDown = function (e) {
            var clientX = e.clientX, target = e.target;
            var left = target.getBoundingClientRect().left;
            this._gap = Math.floor(clientX - left);
            this._inMotion = true;
        };
        AdaptChartSliderComponent.prototype.onMouseOver = function () {
            this.isActive = true;
        };
        AdaptChartSliderComponent.prototype.onMouseOut = function () {
            if (!this._inMotion) {
                this.isActive = false;
            }
        };
        AdaptChartSliderComponent.prototype.onSliderShift = function (shiftBack) {
            var indicatorCS = getComputedStyle(this._overlayEl.nativeElement);
            var indicatorWidth = parseInt(indicatorCS.width, 10);
            var indicatorLeft = parseInt(indicatorCS.left, 10);
            var sliderWidth = parseInt(getComputedStyle(this._sliderEl.nativeElement).width, 10);
            var newX;
            if (shiftBack) {
                newX = indicatorLeft - indicatorWidth;
                if (newX < 0) {
                    newX = 0;
                }
            }
            else {
                newX = indicatorLeft + indicatorWidth;
                if (newX + indicatorWidth > sliderWidth) {
                    newX = sliderWidth - indicatorWidth;
                }
            }
            this._updateOverlay(newX);
        };
        AdaptChartSliderComponent.prototype.onClickSliderArea = function (e) {
            if (this.isActive) {
                return;
            }
            var clientX = e.clientX;
            var _a = this._sliderEl.nativeElement.getBoundingClientRect(), left = _a.left, width = _a.width;
            var newLeftSpotPosition = clientX - left - this.sliderSpotWidth / 2;
            newLeftSpotPosition = newLeftSpotPosition < 0 ? 0 : newLeftSpotPosition;
            newLeftSpotPosition = newLeftSpotPosition > width - this.sliderSpotWidth ? width - this.sliderSpotWidth : newLeftSpotPosition;
            this._updateOverlay(newLeftSpotPosition);
        };
        AdaptChartSliderComponent.prototype.updateSlider = function (dim) {
            var height = this._sliderEl.nativeElement.getBoundingClientRect().height;
            this._chartComponent.chartComponent.updateChart({
                w: dim.w - this.leftShift,
                h: height - this.sliderPaddingTop * 2
            });
        };
        AdaptChartSliderComponent.prototype.showCategory = function (category) {
            var categoryId = this._categoryFilter.indexOf(category);
            if (categoryId !== -1) {
                this._categoryFilter.splice(categoryId, 1);
            }
            this._updateData();
        };
        AdaptChartSliderComponent.prototype.hideCategory = function (category) {
            this._categoryFilter.push(category);
            this._updateData();
        };
        AdaptChartSliderComponent.prototype._getDataLength = function () {
            // TODO check for fix
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            return this.data[0].data.length;
        };
        AdaptChartSliderComponent.prototype._updateOverlay = function (x) {
            if (x === void 0) { x = this._x; }
            if (x !== this._x) {
                this._x = x;
                this._recalculateDataRange();
            }
            this._recalculateSpotPosition();
        };
        AdaptChartSliderComponent.prototype._updateData = function () {
            var _this = this;
            var timer = setTimeout(function () {
                _this.data = _this._dataCopy.map(function (item) {
                    var name = item.name;
                    var data = item.data;
                    if (_this._categoryFilter.indexOf(name) !== -1) {
                        data = data.map(function () { return 0; });
                    }
                    return { name: name, data: data };
                });
                clearTimeout(timer);
            }, 250);
        };
        AdaptChartSliderComponent.prototype._recalculateSpotPosition = function () {
            var width = this._sliderEl.nativeElement.getBoundingClientRect().width;
            var overlayRightWidth = width - this.sliderSpotWidth - this._x;
            var overlayLeftWidth = this._x;
            this._renderer.setStyle(this._dndEl.nativeElement, 'left', this._x * 100 / width + "%");
            this._renderer.setStyle(this._overlayEl.nativeElement, 'left', this._x * 100 / width + "%");
            this._renderer.setStyle(this._overlayLeftEl.nativeElement, 'width', overlayLeftWidth * 100 / width + "%");
            this._renderer.setStyle(this._overlayRightEl.nativeElement, 'width', overlayRightWidth * 100 / width + "%");
        };
        AdaptChartSliderComponent.prototype._recalculateDataRange = function () {
            var width = this._sliderEl.nativeElement.getBoundingClientRect().width;
            var count = this._getDataLength();
            var wPiece = width / count;
            this.sliderSpotWidth = width / this.monitorsCount;
            var startPiece = Math.floor(this._x / wPiece);
            var endPiece = Math.floor((this._x + this.sliderSpotWidth) / wPiece);
            if (this._startPoint !== startPiece) {
                this._startPoint = startPiece;
                this._endPoint = endPiece;
                this.rangeChanged.emit({ startPiece: startPiece, endPiece: endPiece });
            }
        };
        return AdaptChartSliderComponent;
    }());
    AdaptChartSliderComponent.ɵfac = function AdaptChartSliderComponent_Factory(t) { return new (t || AdaptChartSliderComponent)(i0__namespace.ɵɵdirectiveInject(i0__namespace.ElementRef), i0__namespace.ɵɵdirectiveInject(i0__namespace.Renderer2), i0__namespace.ɵɵdirectiveInject(i0__namespace.ChangeDetectorRef)); };
    AdaptChartSliderComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptChartSliderComponent, selectors: [["adapt-chart-slider"]], viewQuery: function AdaptChartSliderComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(_c0$b, 5);
                i0__namespace.ɵɵviewQuery(_c1$8, 7);
                i0__namespace.ɵɵviewQuery(_c2$5, 7);
                i0__namespace.ɵɵviewQuery(_c3$3, 7);
                i0__namespace.ɵɵviewQuery(_c4$3, 7);
                i0__namespace.ɵɵviewQuery(_c5$2, 7);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._chartComponent = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._sliderEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._dndEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._overlayEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._overlayLeftEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._overlayRightEl = _t.first);
            }
        }, inputs: { type: "type", data: "data", xAxis: "xAxis", height: "height", slidePointsCount: "slidePointsCount", customColors: "customColors", stackedChart: "stackedChart", leftShift: "leftShift", containerWidth: "containerWidth" }, outputs: { rangeChanged: "rangeChanged" }, decls: 30, vars: 38, consts: [[3, "click"], ["slider", ""], ["overlayLeft", ""], [3, "ngClass", "mouseover", "mouseout", "mousedown"], ["dnd", ""], [3, "keydown.arrowRight", "keydown.arrowLeft"], [3, "ngSwitch", 4, "ngIf"], ["overlay", ""], ["overlayRight", ""], [3, "ngSwitch"], [3, "suppressHeader", "suppressLegend", "renderLegend", "showEmptyColIndicator", "legend", "hideAxises", "xAxis", "yAxis", "series", "height", "type", "seriesDisplay", 4, "ngSwitchCase"], [3, "suppressHeader", "suppressLegend", "renderLegend", "showEmptyColIndicator", "legend", "hideAxises", "xAxis", "yAxis", "series", "height", "type", "seriesDisplay"], ["chart", ""]], template: function AdaptChartSliderComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵtext(0, "\n    ");
                i0__namespace.ɵɵelementStart(1, "div", 0, 1);
                i0__namespace.ɵɵlistener("click", function AdaptChartSliderComponent_Template_div_click_1_listener($event) { return ctx.onClickSliderArea($event); });
                i0__namespace.ɵɵtext(3, "\n      ");
                i0__namespace.ɵɵelementStart(4, "div");
                i0__namespace.ɵɵtext(5, "\n        ");
                i0__namespace.ɵɵelement(6, "div", null, 2);
                i0__namespace.ɵɵtext(8, "\n        ");
                i0__namespace.ɵɵelementStart(9, "div", 3, 4);
                i0__namespace.ɵɵlistener("mouseover", function AdaptChartSliderComponent_Template_div_mouseover_9_listener() { return ctx.onMouseOver(); })("mouseout", function AdaptChartSliderComponent_Template_div_mouseout_9_listener() { return ctx.onMouseOut(); })("mousedown", function AdaptChartSliderComponent_Template_div_mousedown_9_listener($event) { return ctx.onMouseDown($event); });
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(11, "\n        ");
                i0__namespace.ɵɵelementStart(12, "div", 5);
                i0__namespace.ɵɵlistener("keydown.arrowRight", function AdaptChartSliderComponent_Template_div_keydown_arrowRight_12_listener() { return ctx.onSliderShift(); })("keydown.arrowLeft", function AdaptChartSliderComponent_Template_div_keydown_arrowLeft_12_listener() { return ctx.onSliderShift(true); });
                i0__namespace.ɵɵtext(13, "\n          ");
                i0__namespace.ɵɵtemplate(14, AdaptChartSliderComponent_ng_container_14_Template, 4, 2, "ng-container", 6);
                i0__namespace.ɵɵtext(15, "\n        ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(16, "\n        ");
                i0__namespace.ɵɵelement(17, "div", null, 7);
                i0__namespace.ɵɵtext(19, "\n        ");
                i0__namespace.ɵɵelement(20, "div", null, 8);
                i0__namespace.ɵɵtext(22, "\n      ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(23, "\n      ");
                i0__namespace.ɵɵelementStart(24, "div");
                i0__namespace.ɵɵtext(25, "\n        ");
                i0__namespace.ɵɵelement(26, "div");
                i0__namespace.ɵɵtext(27, "\n      ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(28, "\n    ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(29, "\n  ");
            }
            if (rf & 2) {
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵclassMap(ctx.classPrefix);
                i0__namespace.ɵɵstyleProp("height", ctx.height, "px")("margin-left", ctx.leftShift, "px");
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-main");
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵclassMapInterpolate2("", ctx.classPrefix, "-side-overlay ", ctx.classPrefix, "-side-overlay-right");
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-spot");
                i0__namespace.ɵɵstyleProp("width", 100 / ctx.monitorsCount, "%");
                i0__namespace.ɵɵproperty("ngClass", ctx.isActive ? ctx.classPrefix + "-spot-active" : "");
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-chart-zone");
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵproperty("ngIf", ctx.initComplete);
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-overlay");
                i0__namespace.ɵɵstyleProp("width", 100 / ctx.monitorsCount, "%");
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵclassMapInterpolate2("", ctx.classPrefix, "-side-overlay ", ctx.classPrefix, "-side-overlay-left");
                i0__namespace.ɵɵadvance(4);
                i0__namespace.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line-wrapper");
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line");
            }
        }, encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptChartSliderComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-chart-slider',
                        template: "\n    <div #slider\n         [class]=\"classPrefix\"\n         [style.height.px]=\"height\"\n         (click)=\"onClickSliderArea($event)\" [style.marginLeft.px]=\"leftShift\">\n      <div class=\"{{classPrefix}}-main\">\n        <div #overlayLeft\n             class=\"{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-right\"></div>\n        <div #dnd\n             (mouseover)=\"onMouseOver()\"\n             (mouseout)=\"onMouseOut()\"\n             (mousedown)=\"onMouseDown($event)\"\n             [style.width.%]=\"100 / monitorsCount\"\n             class=\"{{classPrefix}}-spot\"\n             [ngClass]=\"isActive ? classPrefix + '-spot-active' : ''\"></div>\n        <div class=\"{{classPrefix}}-chart-zone\"\n             (keydown.arrowRight)=\"onSliderShift()\"\n             (keydown.arrowLeft)=\"onSliderShift(true)\">\n          <ng-container *ngIf=\"initComplete\" [ngSwitch]=\"type\">\n            <adapt-stacked-chart #chart\n                                 *ngSwitchCase=\"chartSliderType.bar\"\n                                 [suppressHeader]=\"true\"\n                                 [suppressLegend]=\"true\"\n                                 [renderLegend]=\"false\"\n                                 [showEmptyColIndicator]=\"false\"\n                                 [legend]=\"null\"\n                                 [hideAxises]=\"true\"\n                                 [xAxis]=\"xAxis\"\n                                 [yAxis]=\"{}\"\n                                 [series]=\"data\"\n                                 [height]=\"height - sliderPaddingTop\"\n                                 [type]=\"stackedChartType\"\n                                 [seriesDisplay]=\"stackedChart && stackedChart.seriesDisplay\"></adapt-stacked-chart>\n          </ng-container>\n        </div>\n        <div #overlay class=\"{{classPrefix}}-overlay\" [style.width.%]=\"100 / monitorsCount\"></div>\n        <div #overlayRight\n             class=\"{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-left\"></div>\n      </div>\n      <div class=\"{{classPrefix}}-line-wrapper\">\n        <div class=\"{{classPrefix}}-line\"></div>\n      </div>\n    </div>\n  ",
                        encapsulation: i0.ViewEncapsulation.None
                    }]
            }], function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }, { type: i0__namespace.ChangeDetectorRef }]; }, { type: [{
                    type: i0.Input
                }], data: [{
                    type: i0.Input
                }], xAxis: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], slidePointsCount: [{
                    type: i0.Input
                }], customColors: [{
                    type: i0.Input
                }], stackedChart: [{
                    type: i0.Input
                }], leftShift: [{
                    type: i0.Input
                }], containerWidth: [{
                    type: i0.Input
                }], rangeChanged: [{
                    type: i0.Output
                }], _chartComponent: [{
                    type: i0.ViewChild,
                    args: ['chart']
                }], _sliderEl: [{
                    type: i0.ViewChild,
                    args: ['slider', { static: true }]
                }], _dndEl: [{
                    type: i0.ViewChild,
                    args: ['dnd', { static: true }]
                }], _overlayEl: [{
                    type: i0.ViewChild,
                    args: ['overlay', { static: true }]
                }], _overlayLeftEl: [{
                    type: i0.ViewChild,
                    args: ['overlayLeft', { static: true }]
                }], _overlayRightEl: [{
                    type: i0.ViewChild,
                    args: ['overlayRight', { static: true }]
                }] });
    })();

    function nameof(key) {
        return key;
    }
    /**
     * Function allowing to 'wrap' the text from an SVG <text> element with <tspan>.
     * Based on https://github.com/mbostock/d3/issues/1642
     *
     * @example
     *   svg.append("g")
     *      .attr("class", "x axis")
     *      .attr("transform", "translate(0," + height + ")")
     *      .call(xAxis)
     *      .selectAll(".tick text")
     *          .call(textWrap, x.rangeBand());
     *
     * @param textItems d3.Selection<Element, string, SVGGElement, string> - d3 selection for one or more <text> object
     * @param width number - global width in which the text will be word-wrapped.
     * @param paddingRightLeft number - Padding right and left between the wrapped text and the 'invisible bax' of 'width' width
     * @param paddingTopBottom number - Padding top and bottom between the wrapped text and the 'invisible bax' of 'width' width
     * @returns number[] - Number of lines created by the function, stored in a Array in case multiple <text> element are passed to the function
     */
    function textWrap(textItems, width, paddingRightLeft, paddingTopBottom) {
        if (paddingRightLeft === void 0) { paddingRightLeft = 5; }
        paddingTopBottom = (paddingTopBottom || 5) - 2; // Default padding (5px), remove 2 pixels because of the borders
        var maxWidth = width; // I store the tooltip max width
        width = width - (paddingRightLeft * 2); // Take the padding into account
        var arrLineCreatedCount = [];
        textItems.each(function () {
            var text = d3__namespace.select(this);
            var words = text.text().split(/[ \f\n\r\t\v]+/).reverse(); // Don't cut non-breaking space (\xA0), as well as the Unicode characters \u00A0 \u2028 \u2029)
            var lineHeight = 1.25; // Ems
            var textAlign = text.style('text-anchor') || 'start'; // 'start' by default (start, middle, end, inherit)
            var word;
            var line = [];
            var lineNumber = 0;
            var x;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var y = text.attr('y');
            var dy = parseFloat(text.attr('dy'));
            var createdLineCount = 1; // Total line created count
            // Clean the data in case <text> does not define those values
            if (isNaN(dy)) {
                dy = 0;
            } // Default padding (0em) : the 'dy' attribute on the first <tspan> _must_ be identical to the 'dy' specified on the <text> element, or start at '0em' if undefined
            // Offset the text position based on the text-anchor
            var wrapTickLabels = d3__namespace.select(text.node().parentNode).classed('tick'); // Don't wrap the 'normal untranslated' <text> element and the translated <g class='tick'><text></text></g> elements the same way..
            if (wrapTickLabels) {
                switch (textAlign) {
                    case 'start':
                        x = -width / 2;
                        break;
                    case 'middle':
                        x = 0;
                        break;
                    case 'end':
                        x = 0; // width / 2;
                        break;
                    default:
                }
            }
            else { // untranslated <text> elements
                switch (textAlign) {
                    case 'start':
                        x = paddingRightLeft;
                        break;
                    case 'middle':
                        x = maxWidth / 2;
                        break;
                    case 'end':
                        x = maxWidth - paddingRightLeft;
                        break;
                    default:
                }
            }
            y = +((null === y) ? paddingTopBottom : y);
            var tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', dy + 'em');
            // eslint-disable-next-line no-cond-assign
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(' '));
                if (tspan.node().getComputedTextLength() > width && line.length > 1) {
                    line.pop();
                    tspan.text(line.join(' '));
                    line = [word];
                    tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'em').text(word);
                    ++createdLineCount;
                }
            }
            arrLineCreatedCount.push(createdLineCount); // Store the line count in the array
        });
        return arrLineCreatedCount;
    }

    var _c0$a = ["svgBrushContainer"];
    var _c1$7 = ["slider"];
    var _c2$4 = ["chart"];
    function AdaptAreaGraphSliderComponent_ng_container_11_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵnamespaceHTML();
            i0__namespace.ɵɵelementContainerStart(0);
            i0__namespace.ɵɵtext(1, "\n        ");
            i0__namespace.ɵɵelement(2, "div");
            i0__namespace.ɵɵtext(3, "\n\n        ");
            i0__namespace.ɵɵelement(4, "div", 6);
            i0__namespace.ɵɵtext(5, "\n\n        ");
            i0__namespace.ɵɵelement(6, "div");
            i0__namespace.ɵɵtext(7, "\n      ");
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var ctx_r3 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵclassMapInterpolate2("", ctx_r3.classPrefix, "-side-overlay ", ctx_r3.classPrefix, "-side-overlay-right");
            i0__namespace.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("height", ctx_r3.height, "px")("width", ctx_r3.getXPos(), "px");
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵclassMapInterpolate1("", ctx_r3.classPrefix, "-spot");
            i0__namespace.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("z-index", 1)("height", ctx_r3.height + 5, "px")("width", ctx_r3.brushWidth, "px")("left", ctx_r3.getXPos(), "px");
            i0__namespace.ɵɵproperty("ngClass", ctx_r3.isActive ? ctx_r3.classPrefix + "-spot-active" : "");
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵclassMapInterpolate2("", ctx_r3.classPrefix, "-side-overlay ", ctx_r3.classPrefix, "-side-overlay-left");
            i0__namespace.ɵɵstyleProp("top", ctx_r3.sliderPaddingTop, "px")("height", ctx_r3.height, "px")("left", ctx_r3.getXOverlayPos(), "px")("width", ctx_r3.getRightOverlayWidth(), "px");
        }
    }
    var _c3$2 = function () { return {}; };
    var _c4$2 = function () { return []; };
    var _c5$1 = function (a0, a1) { return { items: a0, customColors: a1 }; };
    var classPrefix = 'adapt-chart-slider';
    var sliderPaddingTop = 10; // need to be aligned with the css $slider-padding-top: 10;
    var AdaptAreaGraphSliderComponent = /** @class */ (function () {
        function AdaptAreaGraphSliderComponent(_ngZone) {
            this._ngZone = _ngZone;
            this.isInitialized = false;
            this.isActive = false;
            this.height = 35;
            this.leftShift = 0;
            this.rangeChanged = new i0.EventEmitter();
            this.scrollEnd = new i0.EventEmitter();
            this._cX = 0;
            this._inMotion = false;
            this._destroyed$ = new rxjs.ReplaySubject(1);
            this.classPrefix = classPrefix;
            this.sliderPaddingTop = sliderPaddingTop;
        }
        AdaptAreaGraphSliderComponent.prototype.ngOnInit = function () {
            var _this = this;
            this._ngZone.onStable
                .pipe(operators.takeUntil(this._destroyed$), operators.take(1))
                .subscribe(function () {
                _this.isInitialized = true;
            });
        };
        AdaptAreaGraphSliderComponent.prototype.ngOnChanges = function (changes) {
            if (this.isInitialized && changes.slidePointsCount) {
                this._g.select('.brush-wrp').remove();
                this._initBrush();
            }
        };
        AdaptAreaGraphSliderComponent.prototype.ngAfterViewInit = function () {
            this._g = d3__namespace.select(this._svgContainerEl.nativeElement);
            this._xMinValue = this._chartComponent.getXMinValue(this.data);
            this._xMaxValue = this._chartComponent.getXMaxValue(this.data);
            this._renderBrushXAxis();
            this._initBrush();
        };
        AdaptAreaGraphSliderComponent.prototype.ngOnDestroy = function () {
            this._destroyed$.next(true);
            this._destroyed$.complete();
        };
        AdaptAreaGraphSliderComponent.prototype.getXPos = function () {
            return parseFloat(this._dndEl.getAttribute('x')) || 0;
        };
        AdaptAreaGraphSliderComponent.prototype.getXOverlayPos = function () {
            return this.getXPos() + this.brushWidth;
        };
        AdaptAreaGraphSliderComponent.prototype.getRightOverlayWidth = function () {
            return this.containerWidth - this.leftShift - this.getXOverlayPos();
        };
        AdaptAreaGraphSliderComponent.prototype.showCategory = function (category) {
            this._chartComponent.categoryShowHandler(category);
        };
        AdaptAreaGraphSliderComponent.prototype.hideCategory = function (category) {
            this._chartComponent.categoryHideHandler(category);
        };
        AdaptAreaGraphSliderComponent.prototype.updateSlider = function (dim) {
            this.containerWidth = dim.w;
            var height = this._sliderEl.nativeElement.getBoundingClientRect().height;
            this._chartComponent._updateChart({
                w: dim.w - this.leftShift,
                h: height - this.sliderPaddingTop * 2
            });
            this.xBrush = d3__namespace.scaleLinear()
                .range([0, dim.w - this.leftShift])
                .domain([this._xMinValue, this._xMaxValue]);
            var x = this._g.select('.axis--x');
            x.call(this._getXAxisLineRenderer());
            this._g.select('.brush-wrp').remove();
            this._initBrush();
        };
        AdaptAreaGraphSliderComponent.prototype._renderBrushXAxis = function () {
            this._g
                .append('g').attr('class', 'axis axis--x')
                .attr('transform', "translate(0, " + this.height + ")")
                .call(this._getXAxisLineRenderer());
        };
        AdaptAreaGraphSliderComponent.prototype._getXAxisLineRenderer = function () {
            return d3__namespace.axisBottom(this.xBrush);
        };
        AdaptAreaGraphSliderComponent.prototype._initBrush = function () {
            // TODO check for refactoring
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var _self = this;
            this._brush = d3__namespace.brushX()
                .extent([[0, 0], [this.containerWidth - this.leftShift, this.height]])
                .on('brush', function () {
                _self._brushed();
            })
                .on('end.brush', function () {
                _self.scrollEnd.emit();
            });
            this.brushWidth = Math.ceil(this.xBrush((this.xBrush).ticks()[this.slidePointsCount]));
            this._initBrushHandlers();
        };
        AdaptAreaGraphSliderComponent.prototype._initBrushHandlers = function () {
            // TODO check for refactoring
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var _self = this;
            this._g
                .append('g').attr('class', 'brush-wrp')
                .append('g').attr('class', 'brush')
                .call(this._brush)
                .call(this._brush.move, [this._cX, this._cX + this.brushWidth])
                .call(function (g) { return g.select('.selection').attr('stroke', null).attr('fill-opacity', '0.1')
                .on('mouseover', function () {
                _self.isActive = true;
            })
                .on('mousedown', function () {
                _self._inMotion = true;
            })
                .on('mouseout', function () {
                if (!_self._inMotion) {
                    _self.isActive = false;
                }
            }); })
                .call(function (g) { return g.select('.overlay')
                .datum({ type: 'selection' })
                .on('mousedown', function () {
                var _a = __read(d3__namespace.mouse(this), 1), cx = _a[0];
                var _b = __read([cx - _self.brushWidth / 2, cx + _self.brushWidth / 2], 2), x0 = _b[0], x1 = _b[1];
                var _c = __read(_self.xBrush.range(), 2), r0 = _c[0], r1 = _c[1];
                d3__namespace.select(this.parentNode)
                    .call(_self._brush.move, x1 > r1
                    ? [r1 - _self.brushWidth, r1]
                    : x0 < r0
                        ? [r0, r0 + _self.brushWidth]
                        : [x0, x1]);
            }); });
            // prevent resizing
            this._g.selectAll('.brush-wrp > .brush > .handle').remove();
            this._dndEl = this._svgContainerEl.nativeElement.querySelector('rect.selection');
        };
        AdaptAreaGraphSliderComponent.prototype._brushed = function () {
            this._cX = d3__namespace.event.selection[0];
            var selection = d3__namespace.event.selection || this.xBrush.range();
            this.rangeChanged.emit(selection.map((this.xBrush).invert, this.xBrush));
            this._inMotion = false;
        };
        return AdaptAreaGraphSliderComponent;
    }());
    AdaptAreaGraphSliderComponent.ɵfac = function AdaptAreaGraphSliderComponent_Factory(t) { return new (t || AdaptAreaGraphSliderComponent)(i0__namespace.ɵɵdirectiveInject(i0__namespace.NgZone)); };
    AdaptAreaGraphSliderComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptAreaGraphSliderComponent, selectors: [["adapt-area-graph-slider"]], viewQuery: function AdaptAreaGraphSliderComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(_c0$a, 5);
                i0__namespace.ɵɵviewQuery(_c1$7, 5);
                i0__namespace.ɵɵviewQuery(_c2$4, 5);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._svgContainerEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._sliderEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx._chartComponent = _t.first);
            }
        }, inputs: { xAxis: "xAxis", height: "height", slidePointsCount: "slidePointsCount", customColors: "customColors", xBrush: "xBrush", leftShift: "leftShift", containerWidth: "containerWidth", data: "data" }, outputs: { rangeChanged: "rangeChanged", scrollEnd: "scrollEnd" }, features: [i0__namespace.ɵɵNgOnChangesFeature], decls: 19, vars: 28, consts: [["slider", ""], [3, "xAxis", "yAxis", "legend", "series", "height", "disallowPadding", "supressAxles", "suppressLegend"], ["chart", ""], ["xmlns", "http://www.w3.org/2000/svg", "tabindex", "-1", "role", "graphic/image", "aria-describedby", "title desc", 1, "adapt-chart-slider-brush-svg"], ["svgBrushContainer", ""], [4, "ngIf"], [3, "ngClass"]], template: function AdaptAreaGraphSliderComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵtext(0, "\n    ");
                i0__namespace.ɵɵelementStart(1, "div", null, 0);
                i0__namespace.ɵɵtext(3, "\n      ");
                i0__namespace.ɵɵelement(4, "adapt-area-graph", 1, 2);
                i0__namespace.ɵɵtext(6, "\n\n      ");
                i0__namespace.ɵɵnamespaceSVG();
                i0__namespace.ɵɵelementStart(7, "svg", 3, 4);
                i0__namespace.ɵɵtext(9, "\n      ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(10, "\n\n      ");
                i0__namespace.ɵɵtemplate(11, AdaptAreaGraphSliderComponent_ng_container_11_Template, 8, 36, "ng-container", 5);
                i0__namespace.ɵɵtext(12, "\n\n      ");
                i0__namespace.ɵɵnamespaceHTML();
                i0__namespace.ɵɵelementStart(13, "div");
                i0__namespace.ɵɵtext(14, "\n        ");
                i0__namespace.ɵɵelement(15, "div");
                i0__namespace.ɵɵtext(16, "\n      ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(17, "\n    ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(18, "\n  ");
            }
            if (rf & 2) {
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵclassMap(ctx.classPrefix);
                i0__namespace.ɵɵstyleProp("margin-left", ctx.leftShift, "px");
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵproperty("xAxis", ctx.xAxis)("yAxis", i0__namespace.ɵɵpureFunction0(23, _c3$2))("legend", i0__namespace.ɵɵpureFunction2(25, _c5$1, i0__namespace.ɵɵpureFunction0(24, _c4$2), ctx.customColors))("series", ctx.data)("height", ctx.height)("disallowPadding", true)("supressAxles", true)("suppressLegend", true);
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵattributeInterpolate2("viewbox", "0 0 ", ctx.containerWidth - ctx.leftShift, " ", ctx.height, "");
                i0__namespace.ɵɵattribute("width", ctx.containerWidth - ctx.leftShift)("height", ctx.height);
                i0__namespace.ɵɵadvance(4);
                i0__namespace.ɵɵproperty("ngIf", ctx.isInitialized);
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line-wrapper");
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵclassMapInterpolate1("", ctx.classPrefix, "-line");
            }
        }, encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptAreaGraphSliderComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-area-graph-slider',
                        template: "\n    <div #slider\n         [class]=\"classPrefix\"\n         [style.marginLeft.px]=\"leftShift\">\n      <adapt-area-graph #chart\n                        [xAxis]=\"xAxis\"\n                        [yAxis]=\"{}\"\n                        [legend]=\"{items: [], customColors: customColors}\"\n                        [series]=\"data\"\n                        [height]=\"height\"\n                        [disallowPadding]=\"true\"\n                        [supressAxles]=\"true\"\n                        [suppressLegend]=\"true\"></adapt-area-graph>\n\n      <svg xmlns=\"http://www.w3.org/2000/svg\" #svgBrushContainer\n           class=\"adapt-chart-slider-brush-svg\"\n           tabindex=\"-1\"\n           role=\"graphic/image\"\n           aria-describedby=\"title desc\"\n           attr.viewbox=\"0 0 {{containerWidth - leftShift}} {{height}}\"\n           [attr.width]=\"containerWidth - leftShift\"\n           [attr.height]=\"height\">\n      </svg>\n\n      <ng-container *ngIf=\"isInitialized\">\n        <div class=\"{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-right\"\n             [style.top.px]=\"sliderPaddingTop\"\n             [style.height.px]=\"height\"\n             [style.width.px]=\"getXPos()\"></div>\n\n        <div class=\"{{classPrefix}}-spot\"\n             [style.top.px]=\"sliderPaddingTop\"\n             [style.zIndex]=\"1\"\n             [style.height.px]=\"height + 5\"\n             [style.width.px]=\"brushWidth\"\n             [style.left.px]=\"getXPos()\"\n             [ngClass]=\"isActive ? classPrefix + '-spot-active' : ''\"></div>\n\n        <div class=\"{{classPrefix}}-side-overlay {{classPrefix}}-side-overlay-left\"\n             [style.top.px]=\"sliderPaddingTop\"\n             [style.height.px]=\"height\"\n             [style.left.px]=\"getXOverlayPos()\"\n             [style.width.px]=\"getRightOverlayWidth()\"></div>\n      </ng-container>\n\n      <div class=\"{{classPrefix}}-line-wrapper\">\n        <div class=\"{{classPrefix}}-line\"></div>\n      </div>\n    </div>\n  "
                    }]
            }], function () { return [{ type: i0__namespace.NgZone }]; }, { xAxis: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], slidePointsCount: [{
                    type: i0.Input
                }], customColors: [{
                    type: i0.Input
                }], xBrush: [{
                    type: i0.Input
                }], leftShift: [{
                    type: i0.Input
                }], containerWidth: [{
                    type: i0.Input
                }], data: [{
                    type: i0.Input
                }], rangeChanged: [{
                    type: i0.Output
                }], scrollEnd: [{
                    type: i0.Output
                }], _svgContainerEl: [{
                    type: i0.ViewChild,
                    args: ['svgBrushContainer']
                }], _sliderEl: [{
                    type: i0.ViewChild,
                    args: ['slider']
                }], _chartComponent: [{
                    type: i0.ViewChild,
                    args: ['chart']
                }] });
    })();

    function ChartGradientLegendComponent_span_8_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "span", 6);
            i0__namespace.ɵɵtext(1);
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r0 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵproperty("tabIndex", ctx_r0.focusable ? 0 : -1);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate(ctx_r0.zeroText);
        }
    }
    var _c0$9 = function (a0, a1) { return { "width": a0, "height": a1 }; };
    var _c1$6 = function (a0) { return { "backgroundImage": a0 }; };
    var ChartGradientLegendComponent = /** @class */ (function () {
        function ChartGradientLegendComponent(_deviceDetectionService, _ts) {
            this._deviceDetectionService = _deviceDetectionService;
            this._ts = _ts;
            this.focusable = true;
            this._defaultTexts = {};
            this.setDefaultTexts(_ts.getCurrentLanguage());
        }
        Object.defineProperty(ChartGradientLegendComponent.prototype, "isMobile", {
            get: function () {
                return this._deviceDetectionService.deviceTablet() || this._deviceDetectionService.deviceMobile();
            },
            enumerable: false,
            configurable: true
        });
        ChartGradientLegendComponent.prototype.ngOnInit = function () {
            var _a;
            this.zeroColor = this.zeroColor || '#f0f0f1';
            this.increaseText = this.increaseText || this._defaultTexts.increaseText;
            this.decreaseText = this.decreaseText || this._defaultTexts.decreaseText;
            // Use nullish coalescing to allow pass empty string and hide zeroText
            this.zeroText = (_a = this.zeroText) !== null && _a !== void 0 ? _a : this._defaultTexts.zeroText;
            this.height = this.height || '100%';
        };
        ChartGradientLegendComponent.prototype.setDefaultTexts = function (translation) {
            this._defaultTexts.increaseText = translation['adapt.chart.gradientLegend.increaseDefaultText'];
            this._defaultTexts.decreaseText = translation['adapt.chart.gradientLegend.decreaseDefaultText'];
            this._defaultTexts.zeroText = translation['adapt.chart.gradientLegend.zeroDefaultText'];
        };
        return ChartGradientLegendComponent;
    }());
    ChartGradientLegendComponent.ɵfac = function ChartGradientLegendComponent_Factory(t) { return new (t || ChartGradientLegendComponent)(i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptDeviceDetectionService), i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptTranslateService)); };
    ChartGradientLegendComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: ChartGradientLegendComponent, selectors: [["adapt-chart-gradient-legend"]], inputs: { increaseColor: "increaseColor", decreaseColor: "decreaseColor", zeroColor: "zeroColor", increaseText: "increaseText", decreaseText: "decreaseText", zeroText: "zeroText", height: "height", containerWidth: "containerWidth", focusable: "focusable" }, decls: 18, vars: 12, consts: [["role", "legend", 1, "adapt-chart-legend", "adapt-chart-legend__gradient", 3, "ngStyle"], [1, "adapt-chart-legend__gradient-label", "adapt-chart-legend__gradient-label_top", 3, "tabIndex"], [1, "adapt-chart-legend__gradient-label", "adapt-chart-legend__gradient-label_middle"], [3, "tabIndex", 4, "ngIf"], [1, "adapt-chart-legend__gradient-label", "adapt-chart-legend__gradient-label_bottom", 3, "tabIndex"], [1, "adapt-chart-legend__gradient-block", 3, "ngStyle"], [3, "tabIndex"]], template: function ChartGradientLegendComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵtext(0, "\n    ");
                i0__namespace.ɵɵelementStart(1, "div", 0);
                i0__namespace.ɵɵtext(2, "\n      ");
                i0__namespace.ɵɵelementStart(3, "div", 1);
                i0__namespace.ɵɵtext(4);
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(5, "\n      ");
                i0__namespace.ɵɵelementStart(6, "div", 2);
                i0__namespace.ɵɵtext(7, "\n        ");
                i0__namespace.ɵɵtemplate(8, ChartGradientLegendComponent_span_8_Template, 2, 2, "span", 3);
                i0__namespace.ɵɵtext(9, "\n      ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(10, "\n      ");
                i0__namespace.ɵɵelementStart(11, "div", 4);
                i0__namespace.ɵɵtext(12);
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(13, "\n      ");
                i0__namespace.ɵɵelementStart(14, "div", 5);
                i0__namespace.ɵɵtext(15, "\n      ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(16, "\n    ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(17, "\n  ");
            }
            if (rf & 2) {
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵproperty("ngStyle", i0__namespace.ɵɵpureFunction2(7, _c0$9, ctx.isMobile ? "100%" : ctx.containerWidth ? ctx.containerWidth + "px" : "", ctx.height));
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵproperty("tabIndex", ctx.focusable ? 0 : -1);
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵtextInterpolate1("\n        ", ctx.increaseText, "\n      ");
                i0__namespace.ɵɵadvance(4);
                i0__namespace.ɵɵproperty("ngIf", ctx.zeroText);
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵproperty("tabIndex", ctx.focusable ? 0 : -1);
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵtextInterpolate1("\n        ", ctx.decreaseText, "\n      ");
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵproperty("ngStyle", i0__namespace.ɵɵpureFunction1(10, _c1$6, "linear-gradient(to bottom, " + ctx.increaseColor + ", " + ctx.zeroColor + " 50%, " + ctx.decreaseColor + ")"));
            }
        }, directives: [i3__namespace.NgStyle, i3__namespace.NgIf], encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(ChartGradientLegendComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-chart-gradient-legend',
                        template: "\n    <div class=\"adapt-chart-legend adapt-chart-legend__gradient\"\n         role=\"legend\"\n         [ngStyle]=\"{'width': isMobile ? '100%' : containerWidth ? containerWidth + 'px' : '', 'height': height}\">\n      <div class=\"adapt-chart-legend__gradient-label adapt-chart-legend__gradient-label_top\"\n           [tabIndex]=\"focusable ? 0 : -1\">\n        {{increaseText}}\n      </div>\n      <div class=\"adapt-chart-legend__gradient-label adapt-chart-legend__gradient-label_middle\">\n        <span *ngIf=\"zeroText\" [tabIndex]=\"focusable ? 0 : -1\">{{zeroText}}</span>\n      </div>\n      <div class=\"adapt-chart-legend__gradient-label adapt-chart-legend__gradient-label_bottom\"\n           [tabIndex]=\"focusable ? 0 : -1\">\n        {{decreaseText}}\n      </div>\n      <div class=\"adapt-chart-legend__gradient-block\"\n           [ngStyle]=\"{'backgroundImage': 'linear-gradient(to bottom, ' + increaseColor + ', ' + zeroColor + ' 50%, ' + decreaseColor + ')'}\">\n      </div>\n    </div>\n  "
                    }]
            }], function () { return [{ type: i1__namespace.AdaptDeviceDetectionService }, { type: i1__namespace.AdaptTranslateService }]; }, { increaseColor: [{
                    type: i0.Input
                }], decreaseColor: [{
                    type: i0.Input
                }], zeroColor: [{
                    type: i0.Input
                }], increaseText: [{
                    type: i0.Input
                }], decreaseText: [{
                    type: i0.Input
                }], zeroText: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], containerWidth: [{
                    type: i0.Input
                }], focusable: [{
                    type: i0.Input
                }] });
    })();

    exports.AdaptChartColorStatus = void 0;
    (function (AdaptChartColorStatus) {
        AdaptChartColorStatus[AdaptChartColorStatus["Default"] = 0] = "Default";
        AdaptChartColorStatus[AdaptChartColorStatus["Success"] = 1] = "Success";
        AdaptChartColorStatus[AdaptChartColorStatus["Warning"] = 2] = "Warning";
        AdaptChartColorStatus[AdaptChartColorStatus["Danger"] = 3] = "Danger";
        AdaptChartColorStatus[AdaptChartColorStatus["Custom"] = 4] = "Custom"; // @since 9.3.0
    })(exports.AdaptChartColorStatus || (exports.AdaptChartColorStatus = {}));
    var STATUS_COLOR_RANGE = {
        Default: ['#195560', '#267f91'],
        Success: ['#408600', '#5da627'],
        Warning: ['#FFBE00', '#FFE438'],
        Danger: ['#E80B30', '#ff3a49'],
        Custom: ['#0078CC', '#009AF0']
    };
    var ChartColorsFactory = /** @class */ (function () {
        function ChartColorsFactory() {
        }
        ChartColorsFactory.getGradientColors = function () {
            return [
                '#488EE7',
                '#1145AC',
                '#8061C5',
                '#7E1E85',
                '#C94FAF',
                '#E9345D',
                '#EF6F70',
                '#DD8A44',
                '#E7B548',
                '#D5DB51',
                '#9DB957',
                '#54C2C3',
                '#89F4F4',
                '#9CD0FB',
                '#AAB2F5',
                '#E6A8D7'
            ];
        };
        ChartColorsFactory.getHighDiffColors = function () {
            return [
                '#6487EA',
                '#E9862F',
                '#875BCB',
                '#EFB426',
                '#90D1FF',
                '#FF656C',
                '#95BC44',
                '#D83FB4',
                '#00C5C4',
                '#89008A',
                '#D3DD27',
                '#FB025A',
                '#0242B3',
                '#F0A3DA',
                '#62F7F6',
                '#AAB0FA',
            ];
        };
        return ChartColorsFactory;
    }());
    var ChartColorService = /** @class */ (function () {
        function ChartColorService() {
            this._gradientColors = ChartColorsFactory.getGradientColors();
            this._highDiffColorsColors = ChartColorsFactory.getHighDiffColors();
        }
        ChartColorService.getColorRange = function (range, count) {
            var _temp;
            if (range instanceof Array) {
                _temp = range;
            }
            else {
                switch (range) {
                    case (exports.AdaptChartColorStatus.Success): {
                        _temp = STATUS_COLOR_RANGE.Success;
                        break;
                    }
                    case (exports.AdaptChartColorStatus.Warning): {
                        _temp = STATUS_COLOR_RANGE.Warning;
                        break;
                    }
                    case (exports.AdaptChartColorStatus.Danger): {
                        _temp = STATUS_COLOR_RANGE.Danger;
                        break;
                    }
                    default: {
                        _temp = STATUS_COLOR_RANGE.Default;
                        break;
                    }
                }
            }
            var _range = [];
            var _scale = d3__namespace
                .scaleLinear()
                .range(_temp)
                .domain([1, count]);
            for (var i = 0; i < count; i++) {
                _range.push(d3__namespace.color(_scale(i + 1)).hex());
            }
            return _range;
        };
        ChartColorService.prototype.getColor = function (id, palette) {
            var colors = palette === 'high-diff' ? this._highDiffColorsColors : this._gradientColors;
            var len = colors.length - 1;
            return colors[id % len];
        };
        ChartColorService.prototype.getDarken = function (color, percent, type) {
            var colorRGB = type === i1.ColorType.HEX ? this._parseHEX(color) : this._parseRGB(color);
            Object.keys(colorRGB).forEach(function (colorComponentName) {
                colorRGB[colorComponentName] = Math.floor((1 - percent) * colorRGB[colorComponentName]);
            });
            return "#" + this._decToHEX(colorRGB.r) + this._decToHEX(colorRGB.g) + this._decToHEX(colorRGB.b);
        };
        ChartColorService.prototype.getContrast = function (color, type) {
            var channels = type === i1.ColorType.HEX ? this._parseHEX(color) : this._parseRGB(color);
            // Converts the RGB color space into YIQ
            var yiq = ((channels.r * 299) + (channels.g * 587) + (channels.b * 114)) / 1000;
            return (yiq >= 128) ? '#000' : '#fff';
        };
        ChartColorService.prototype.setColors = function (newColors) {
            this._gradientColors = newColors;
        };
        ChartColorService.prototype._parseHEX = function (color) {
            var colorCode = color.trim().slice(1);
            var r;
            var g;
            var b;
            // In case if color value passed in short variant (eg. #456 instead of #445566)
            if (colorCode.length === 3) {
                r = parseInt(colorCode.substring(0, 1) + colorCode.substring(0, 1), 16);
                g = parseInt(colorCode.substring(1, 2) + colorCode.substring(1, 2), 16);
                b = parseInt(colorCode.substring(2, 3) + colorCode.substring(2, 3), 16);
            }
            else {
                r = parseInt(colorCode.substring(0, 2), 16);
                g = parseInt(colorCode.substring(2, 4), 16);
                b = parseInt(colorCode.substring(4, 6), 16);
            }
            return { r: r, g: g, b: b };
        };
        ChartColorService.prototype._parseRGB = function (color) {
            var colorTrimmed = color.trim();
            var colorCode = colorTrimmed.substring(4, colorTrimmed.length - 1).replace(/ /g, '').split(',');
            var _a = __read(colorCode.map(function (c) { return parseInt(c, 10); }), 3), r = _a[0], g = _a[1], b = _a[2];
            return { r: r, g: g, b: b };
        };
        ChartColorService.prototype._decToHEX = function (n) {
            var hex = n.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };
        return ChartColorService;
    }());
    ChartColorService.ɵfac = function ChartColorService_Factory(t) { return new (t || ChartColorService)(); };
    ChartColorService.ɵprov = /*@__PURE__*/ i0__namespace.ɵɵdefineInjectable({ token: ChartColorService, factory: ChartColorService.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(ChartColorService, [{
                type: i0.Injectable
            }], null, null);
    })();

    function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
            var _r10_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementContainerStart(0);
            i0__namespace.ɵɵtext(1, "\n            ");
            i0__namespace.ɵɵelementStart(2, "button", 6);
            i0__namespace.ɵɵlistener("click", function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template_button_click_2_listener() { var restoredCtx = i0__namespace.ɵɵrestoreView(_r10_1); var id_r8 = restoredCtx.index; var colId_r5 = i0__namespace.ɵɵnextContext().index; var ctx_r9 = i0__namespace.ɵɵnextContext(2); return ctx_r9.clickLegend(ctx_r9.columnSize * colId_r5 + id_r8); })("mouseenter", function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template_button_mouseenter_2_listener($event) { var restoredCtx = i0__namespace.ɵɵrestoreView(_r10_1); var id_r8 = restoredCtx.index; var colId_r5 = i0__namespace.ɵɵnextContext().index; var ctx_r12 = i0__namespace.ɵɵnextContext(2); return ctx_r12.enterLegendItem($event, ctx_r12.columnSize * colId_r5 + id_r8); })("mouseleave", function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template_button_mouseleave_2_listener($event) { var restoredCtx = i0__namespace.ɵɵrestoreView(_r10_1); var id_r8 = restoredCtx.index; var colId_r5 = i0__namespace.ɵɵnextContext().index; var ctx_r14 = i0__namespace.ɵɵnextContext(2); return ctx_r14.leaveLegendItem($event, ctx_r14.columnSize * colId_r5 + id_r8); })("mousemove", function ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template_button_mousemove_2_listener($event) { var restoredCtx = i0__namespace.ɵɵrestoreView(_r10_1); var id_r8 = restoredCtx.index; var colId_r5 = i0__namespace.ɵɵnextContext().index; var ctx_r16 = i0__namespace.ɵɵnextContext(2); return ctx_r16.moveLegendItem($event, ctx_r16.columnSize * colId_r5 + id_r8); });
            i0__namespace.ɵɵtext(3, "\n              ");
            i0__namespace.ɵɵelement(4, "span", 7);
            i0__namespace.ɵɵtext(5, "\n              ");
            i0__namespace.ɵɵelementStart(6, "span", 8);
            i0__namespace.ɵɵtext(7);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(8, "\n            ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n            ");
            i0__namespace.ɵɵelement(10, "br");
            i0__namespace.ɵɵtext(11, "\n          ");
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var legend_r7 = ctx.$implicit;
            var id_r8 = ctx.index;
            var colId_r5 = i0__namespace.ɵɵnextContext().index;
            var ctx_r6 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵclassProp("adapt-chart-legend-item__hidden", legend_r7.hidden);
            i0__namespace.ɵɵattribute("id", ctx_r6.columnSize * colId_r5 + id_r8)("aria-checked", ctx_r6.activeClick ? !legend_r7.hidden : null)("aria-selected", ctx_r6.activeClick ? !legend_r7.hidden : null)("type", ctx_r6.activeClick ? "button" : null)("role", ctx_r6.activeClick ? "option" : "listitem");
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵstyleProp("border-color", ctx_r6.getBorderColorById(ctx_r6.columnSize * colId_r5 + id_r8))("background-color", ctx_r6.getColorById(ctx_r6.columnSize * colId_r5 + id_r8));
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵclassProp("text-active", ctx_r6.legendFocus && ctx_r6.activeOption === ctx_r6.columnSize * colId_r5 + id_r8);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate(legend_r7.item);
        }
    }
    function ChartLegendComponent_ng_container_3_div_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div", 4);
            i0__namespace.ɵɵtext(1, "\n          ");
            i0__namespace.ɵɵtemplate(2, ChartLegendComponent_ng_container_3_div_2_ng_container_2_Template, 12, 14, "ng-container", 5);
            i0__namespace.ɵɵtext(3, "\n        ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var column_r4 = ctx.$implicit;
            var ctx_r3 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngForOf", column_r4)("ngForTrackBy", ctx_r3.trackByIndex);
        }
    }
    function ChartLegendComponent_ng_container_3_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementContainerStart(0);
            i0__namespace.ɵɵtext(1, "\n        ");
            i0__namespace.ɵɵtemplate(2, ChartLegendComponent_ng_container_3_div_2_Template, 4, 2, "div", 3);
            i0__namespace.ɵɵtext(3, "\n      ");
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var ctx_r0 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngForOf", ctx_r0.columns)("ngForTrackBy", ctx_r0.trackByIndex);
        }
    }
    function ChartLegendComponent_ng_template_5_button_1_Template(rf, ctx) {
        if (rf & 1) {
            var _r23_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "button", 10);
            i0__namespace.ɵɵlistener("click", function ChartLegendComponent_ng_template_5_button_1_Template_button_click_0_listener() { var restoredCtx = i0__namespace.ɵɵrestoreView(_r23_1); var id_r21 = restoredCtx.index; var ctx_r22 = i0__namespace.ɵɵnextContext(2); return ctx_r22.clickLegend(id_r21); });
            i0__namespace.ɵɵtext(1, "\n          ");
            i0__namespace.ɵɵelement(2, "span", 7);
            i0__namespace.ɵɵtext(3, "\n          ");
            i0__namespace.ɵɵelementStart(4, "div", 8);
            i0__namespace.ɵɵtext(5, "\n            ");
            i0__namespace.ɵɵelementStart(6, "div");
            i0__namespace.ɵɵtext(7);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(8, "\n          ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n        ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var category_r20 = ctx.$implicit;
            var id_r21 = ctx.index;
            var ctx_r19 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵstyleProp("border-color", ctx_r19.getBorderColorById(id_r21))("background-color", ctx_r19.getColorById(id_r21));
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵtextInterpolate(category_r20.item);
        }
    }
    function ChartLegendComponent_ng_template_5_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n        ");
            i0__namespace.ɵɵtemplate(1, ChartLegendComponent_ng_template_5_button_1_Template, 10, 5, "button", 9);
            i0__namespace.ɵɵtext(2, "\n      ");
        }
        if (rf & 2) {
            var ctx_r2 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵproperty("ngForOf", ctx_r2.legend);
        }
    }
    var _c0$8 = function (a0) { return { "adapt-chart-legend-mouse-over": a0 }; };
    var ChartLegendComponent = /** @class */ (function () {
        function ChartLegendComponent(_chartColorService, _deviceDetectionService, _sanitize, _ngZone) {
            this._chartColorService = _chartColorService;
            this._deviceDetectionService = _deviceDetectionService;
            this._sanitize = _sanitize;
            this._ngZone = _ngZone;
            this.mainCls = '';
            this.isScrolled = false;
            // eslint-disable-next-line @angular-eslint/no-input-rename
            this.columnsCount = 1;
            this.focusable = true;
            this.categoryShow = new i0.EventEmitter();
            this.categoryHide = new i0.EventEmitter();
            this.categoryEnter = new i0.EventEmitter();
            this.categoryLeave = new i0.EventEmitter();
            this.categoryMove = new i0.EventEmitter();
            this.legend = [];
            this.columns = [];
            this.isMouseOver = this.isMobile;
            this.activeOption = null;
            this.legendFocus = false;
            this._destroyed$ = new rxjs.ReplaySubject(1);
        }
        Object.defineProperty(ChartLegendComponent.prototype, "isMobile", {
            get: function () {
                return this._deviceDetectionService.deviceTablet() || this._deviceDetectionService.deviceMobile();
            },
            enumerable: false,
            configurable: true
        });
        ChartLegendComponent.prototype.ngOnInit = function () {
            this.initLegend();
        };
        ChartLegendComponent.prototype.ngOnDestroy = function () {
            this._destroyed$.next(true);
            this._destroyed$.complete();
        };
        ChartLegendComponent.prototype.legendKeydownHandler = function (event) {
            var _a;
            switch (i1.getEventKeyCode(event)) {
                case keycodes.DOWN_ARROW:
                case keycodes.UP_ARROW: {
                    (_a = this._listKeyManager) === null || _a === void 0 ? void 0 : _a.onKeydown(event);
                    break;
                }
                case keycodes.ENTER:
                case keycodes.SPACE: {
                    if (!lodashEs.isNull(this.activeOption)) {
                        event.preventDefault();
                        this.clickLegend(this.activeOption);
                    }
                    break;
                }
                case keycodes.TAB: {
                    this.toggleMouseOverStatus();
                    break;
                }
            }
        };
        ChartLegendComponent.prototype.keyManagerStateChange = function (listKeyManager) {
            var _this = this;
            var _a;
            this._listKeyManager = listKeyManager;
            this._ngZone.onStable
                .pipe(operators.takeUntil(this._destroyed$), operators.take(1))
                .subscribe(function () {
                var _a;
                (_a = _this._listKeyManager) === null || _a === void 0 ? void 0 : _a.setFirstItemActive();
            });
            (_a = this._listKeyManager) === null || _a === void 0 ? void 0 : _a.change.pipe(operators.takeUntil(this._destroyed$)).subscribe(function () {
                _this.activeOption = _this._listKeyManager.activeItemIndex;
            });
        };
        ChartLegendComponent.prototype.parseColumns = function () {
            var _this = this;
            var columns = (new Array(this.columnsCount)).fill([]);
            columns = columns.map(function (col, colId) {
                var start = colId * _this.columnSize;
                var items = _this.legend.slice();
                var end = start + _this.columnSize;
                return items.slice(start, end);
            });
            this.columns = columns;
            if (!this.legend || !this.legend.length || this.legend.length !== this.items.length) {
                this.initLegend();
            }
        };
        ChartLegendComponent.prototype.getColorById = function (id) {
            var defaultColor = this.customColors ? this.customColors[id] : this._chartColorService.getColor(id, this.colorsPalette);
            var hoverColor = this._chartColorService.getDarken(defaultColor, .14, i1.ColorType.HEX);
            var color = this.legend[id].hover ? hoverColor : defaultColor;
            return this._sanitize.bypassSecurityTrustStyle(color);
        };
        ChartLegendComponent.prototype.getBorderColorById = function (id) {
            var backgroundColor = this.customColors ? this.customColors[id] : this._chartColorService.getColor(id, this.colorsPalette);
            var defaultBorderColor = this._chartColorService.getDarken(backgroundColor, .14, i1.ColorType.HEX);
            var hoverBorderColor = this._chartColorService.getDarken(backgroundColor, .24, i1.ColorType.HEX);
            var borderColor = this.legend[id].hover ? hoverBorderColor : defaultBorderColor;
            return this._sanitize.bypassSecurityTrustStyle(borderColor);
        };
        ChartLegendComponent.prototype.clickLegend = function (id) {
            var legend = this.legend[id];
            if (lodashEs.isNull(id) || !this.activeClick) {
                return;
            }
            if (legend.hidden) {
                this._showCategory(legend);
            }
            else {
                this._hideCategory(legend);
            }
        };
        ChartLegendComponent.prototype.toggleMouseOverStatus = function () {
            if (!this.activeHover) {
                return;
            }
            if (this.isMobile) {
                this.isMouseOver = true;
                return;
            }
            this.isMouseOver = !this.isMouseOver;
        };
        ChartLegendComponent.prototype.enterLegendItem = function (event, id) {
            this.activeOption = id;
            this.legend[id].hover = true;
            this.categoryEnter.emit({ id: id, event: event });
        };
        ChartLegendComponent.prototype.leaveLegendItem = function (event, id) {
            this.legend[id].hover = false;
            this.categoryLeave.emit({ id: id, event: event });
        };
        ChartLegendComponent.prototype.moveLegendItem = function (event, id) {
            this.categoryMove.emit({ id: id, event: event });
        };
        ChartLegendComponent.prototype.update = function (items) {
            this.items = items;
            this.legend = this._getLegend();
            this.columnSize = Math.ceil(this.items.length / this.columnsCount);
            this.parseColumns();
        };
        ChartLegendComponent.prototype.initLegend = function () {
            if (i1.isUndefined(this.items) || !this.items.length || lodashEs.isNull(this.items)) {
                return;
            }
            this.activeHover = i1.isUndefined(this.activeHover) ? true : this.activeHover;
            this.activeClick = i1.isUndefined(this.activeClick) ? true : this.activeClick;
            this.legend = this._getLegend();
            this.columnSize = Math.ceil(this.items.length / this.columnsCount);
            this.parseColumns();
        };
        ChartLegendComponent.prototype.trackByIndex = function (index) {
            return index;
        };
        ChartLegendComponent.prototype._getLegend = function () {
            return lodashEs.isString(this.items[0])
                ? this.items.map(function (item) { return ({ item: item, hidden: false, hover: false }); })
                : this.items.map(function (item) { return ({ item: item.item, hidden: item.hidden, hover: false }); });
        };
        ChartLegendComponent.prototype._showCategory = function (legend) {
            legend.hidden = false;
            this.categoryShow.emit(legend.item);
        };
        ChartLegendComponent.prototype._hideCategory = function (legend) {
            var visibleCount = this.legend.filter(function (l) { return !l.hidden; }).length;
            if (visibleCount === 1) {
                return;
            }
            legend.hidden = true;
            this.categoryHide.emit(legend.item);
        };
        return ChartLegendComponent;
    }());
    ChartLegendComponent.id = 0;
    ChartLegendComponent.ɵfac = function ChartLegendComponent_Factory(t) { return new (t || ChartLegendComponent)(i0__namespace.ɵɵdirectiveInject(ChartColorService), i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptDeviceDetectionService), i0__namespace.ɵɵdirectiveInject(i3__namespace$1.DomSanitizer), i0__namespace.ɵɵdirectiveInject(i0__namespace.NgZone)); };
    ChartLegendComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: ChartLegendComponent, selectors: [["adapt-chart-legend"]], hostVars: 4, hostBindings: function ChartLegendComponent_HostBindings(rf, ctx) {
            if (rf & 2) {
                i0__namespace.ɵɵclassMap(ctx.mainCls);
                i0__namespace.ɵɵclassProp("adapt-chart-legend-scrolled", ctx.isScrolled);
            }
        }, inputs: { mainCls: "mainCls", items: "items", columnsCount: ["columns", "columnsCount"], customColors: "customColors", colorsPalette: "colorsPalette", activeHover: "activeHover", activeClick: "activeClick", width: "width", focusable: "focusable" }, outputs: { categoryShow: "categoryShow", categoryHide: "categoryHide", categoryEnter: "categoryEnter", categoryLeave: "categoryLeave", categoryMove: "categoryMove" }, decls: 9, vars: 12, consts: [["adaptListKeyManager", "", "tabindex", "0", 1, "adapt-chart-legend", 3, "ngClass", "keyManagerStateChange", "keydown", "keyup.tab", "mouseenter", "mouseleave", "focus", "blur"], [4, "ngIf", "ngIfElse"], ["mobileLegend", ""], ["class", "adapt-chart-legend-col", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "adapt-chart-legend-col"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["adaptListKeyManagerItem", "", "tabindex", "-1", 1, "adapt-chart-legend-item", 3, "click", "mouseenter", "mouseleave", "mousemove"], [1, "adapt-chart-legend-item-color"], [1, "adapt-chart-legend-item-text"], ["class", "adapt-chart-legend-item", "type", "button", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "adapt-chart-legend-item", 3, "click"]], template: function ChartLegendComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵtext(0, "\n    ");
                i0__namespace.ɵɵelementStart(1, "div", 0);
                i0__namespace.ɵɵlistener("keyManagerStateChange", function ChartLegendComponent_Template_div_keyManagerStateChange_1_listener($event) { return ctx.keyManagerStateChange($event); })("keydown", function ChartLegendComponent_Template_div_keydown_1_listener($event) { return ctx.legendKeydownHandler($event); })("keyup.tab", function ChartLegendComponent_Template_div_keyup_tab_1_listener() { return ctx.toggleMouseOverStatus(); })("mouseenter", function ChartLegendComponent_Template_div_mouseenter_1_listener() { return ctx.toggleMouseOverStatus(); })("mouseleave", function ChartLegendComponent_Template_div_mouseleave_1_listener() { return ctx.toggleMouseOverStatus(); })("focus", function ChartLegendComponent_Template_div_focus_1_listener() { return ctx.legendFocus = true; })("blur", function ChartLegendComponent_Template_div_blur_1_listener() { return ctx.legendFocus = false; });
                i0__namespace.ɵɵtext(2, "\n      ");
                i0__namespace.ɵɵtemplate(3, ChartLegendComponent_ng_container_3_Template, 4, 2, "ng-container", 1);
                i0__namespace.ɵɵtext(4, "\n\n      ");
                i0__namespace.ɵɵtemplate(5, ChartLegendComponent_ng_template_5_Template, 3, 1, "ng-template", null, 2, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(7, "\n    ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(8, "\n  ");
            }
            if (rf & 2) {
                var _r1 = i0__namespace.ɵɵreference(6);
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵstyleProp("width", ctx.isMobile ? "100%" : ctx.width + "px");
                i0__namespace.ɵɵclassProp("adapt-chart-legend-mobile", ctx.isMobile);
                i0__namespace.ɵɵproperty("ngClass", i0__namespace.ɵɵpureFunction1(10, _c0$8, ctx.isMouseOver));
                i0__namespace.ɵɵattribute("role", ctx.activeClick ? "listbox" : "list")("aria-multiselectable", ctx.activeClick ? true : null)("aria-activedescendant", ctx.activeOption);
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵproperty("ngIf", !ctx.isMobile)("ngIfElse", _r1);
            }
        }, directives: [i1__namespace.AdaptListKeyManagerDirective, i3__namespace.NgClass, i3__namespace.NgIf, i3__namespace.NgForOf, i1__namespace.AdaptListKeyManagerItemDirective], styles: ["[_nghost-%COMP%] {\n      position: relative;\n    }\n\n    .adapt-chart-legend-item[_ngcontent-%COMP%] {\n      background: transparent;\n      border: none;\n    }"] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(ChartLegendComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-chart-legend',
                        template: "\n    <div adaptListKeyManager\n         tabindex=\"0\"\n         class=\"adapt-chart-legend\"\n         [class.adapt-chart-legend-mobile]=\"isMobile\"\n         [ngClass]=\"{ 'adapt-chart-legend-mouse-over': isMouseOver }\"\n         [style.width]=\"isMobile ? '100%' : width + 'px'\"\n         [attr.role]=\"activeClick ? 'listbox' : 'list'\"\n         [attr.aria-multiselectable]=\"activeClick ? true : null\"\n         [attr.aria-activedescendant]=\"activeOption\"\n         (keyManagerStateChange)=\"keyManagerStateChange($event)\"\n         (keydown)=\"legendKeydownHandler($event)\"\n         (keyup.tab)=\"toggleMouseOverStatus()\"\n         (mouseenter)=\"toggleMouseOverStatus()\"\n         (mouseleave)=\"toggleMouseOverStatus()\"\n         (focus)=\"legendFocus = true\"\n         (blur)=\"legendFocus = false\">\n      <ng-container *ngIf=\"!isMobile; else mobileLegend\">\n        <div class=\"adapt-chart-legend-col\"\n             *ngFor=\"let column of columns; let colId = index; trackBy: trackByIndex\">\n          <ng-container *ngFor=\"let legend of column; let id = index; trackBy: trackByIndex\">\n            <button adaptListKeyManagerItem\n                    tabindex=\"-1\"\n                    class=\"adapt-chart-legend-item\"\n                    [class.adapt-chart-legend-item__hidden]=\"legend.hidden\"\n                    [attr.id]=\"columnSize*colId + id\"\n                    [attr.aria-checked]=\"activeClick ? !legend.hidden : null\"\n                    [attr.aria-selected]=\"activeClick ? !legend.hidden : null\"\n                    [attr.type]=\"activeClick ? 'button' : null\"\n                    [attr.role]=\"activeClick ? 'option' : 'listitem'\"\n                    (click)=\"clickLegend(columnSize*colId + id)\"\n                    (mouseenter)=\"enterLegendItem($event, columnSize*colId + id)\"\n                    (mouseleave)=\"leaveLegendItem($event, columnSize*colId + id)\"\n                    (mousemove)=\"moveLegendItem($event, columnSize*colId + id)\">\n              <span class=\"adapt-chart-legend-item-color\"\n                    [style.border-color]=\"getBorderColorById(columnSize*colId + id)\"\n                    [style.background-color]=\"getColorById(columnSize*colId + id)\"></span>\n              <span class=\"adapt-chart-legend-item-text\"\n                    [class.text-active]=\"legendFocus && (activeOption === columnSize*colId + id)\">{{legend.item}}</span>\n            </button>\n            <br/>\n          </ng-container>\n        </div>\n      </ng-container>\n\n      <ng-template #mobileLegend>\n        <button class=\"adapt-chart-legend-item\"\n                type=\"button\"\n                *ngFor=\"let category of legend; let id = index;\"\n                (click)=\"clickLegend(id)\">\n          <span class=\"adapt-chart-legend-item-color\"\n                [style.border-color]=\"getBorderColorById(id)\"\n                [style.background-color]=\"getColorById(id)\"></span>\n          <div class=\"adapt-chart-legend-item-text\">\n            <div>{{category.item}}</div>\n          </div>\n        </button>\n      </ng-template>\n    </div>\n  ",
                        styles: ["\n    :host {\n      position: relative;\n    }\n\n    .adapt-chart-legend-item {\n      background: transparent;\n      border: none;\n    }\n  "]
                    }]
            }], function () { return [{ type: ChartColorService }, { type: i1__namespace.AdaptDeviceDetectionService }, { type: i3__namespace$1.DomSanitizer }, { type: i0__namespace.NgZone }]; }, { mainCls: [{
                    type: i0.HostBinding,
                    args: ['class']
                }, {
                    type: i0.Input
                }], isScrolled: [{
                    type: i0.HostBinding,
                    args: ['class.adapt-chart-legend-scrolled']
                }], items: [{
                    type: i0.Input
                }], columnsCount: [{
                    type: i0.Input,
                    args: ['columns']
                }], customColors: [{
                    type: i0.Input
                }], colorsPalette: [{
                    type: i0.Input
                }], activeHover: [{
                    type: i0.Input
                }], activeClick: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], focusable: [{
                    type: i0.Input
                }], categoryShow: [{
                    type: i0.Output
                }], categoryHide: [{
                    type: i0.Output
                }], categoryEnter: [{
                    type: i0.Output
                }], categoryLeave: [{
                    type: i0.Output
                }], categoryMove: [{
                    type: i0.Output
                }] });
    })();

    var _c0$7 = ["chartContainer"];
    var _c1$5 = ["chartArea"];
    var _c2$3 = ["svgContainer"];
    var _c3$1 = ["legend"];
    var _c4$1 = ["legendComponent"];
    var _c5 = ["chartSlider"];
    function AdaptChartComponent_div_5_h1_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "h1", 14);
            i0__namespace.ɵɵtext(1);
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r8 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate(ctx_r8.$this.header.title);
        }
    }
    function AdaptChartComponent_div_5_button_4_Template(rf, ctx) {
        if (rf & 1) {
            var _r11_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "button", 15);
            i0__namespace.ɵɵlistener("click", function AdaptChartComponent_div_5_button_4_Template_button_click_0_listener() { i0__namespace.ɵɵrestoreView(_r11_1); var ctx_r10 = i0__namespace.ɵɵnextContext(2); return ctx_r10.toggleLegend(); });
            i0__namespace.ɵɵtext(1, "\n      ");
            i0__namespace.ɵɵelement(2, "span");
            i0__namespace.ɵɵtext(3, "\n        ");
            i0__namespace.ɵɵelementStart(4, "span");
            i0__namespace.ɵɵtext(5);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(6, "\n      ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r9 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵclassProp("d-icon-left-eye", ctx_r9.isLegendHidden)("d-icon-left-eye_closed", !ctx_r9.isLegendHidden);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate1("", ctx_r9.isLegendHidden ? "Show" : "Hide", " legend");
        }
    }
    function AdaptChartComponent_div_5_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div", 11);
            i0__namespace.ɵɵtext(1, "\n      ");
            i0__namespace.ɵɵtemplate(2, AdaptChartComponent_div_5_h1_2_Template, 2, 1, "h1", 12);
            i0__namespace.ɵɵtext(3, "\n      ");
            i0__namespace.ɵɵtemplate(4, AdaptChartComponent_div_5_button_4_Template, 7, 5, "button", 13);
            i0__namespace.ɵɵtext(5, "\n    ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r1 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngIf", ctx_r1.$this.header.title);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngIf", (ctx_r1.$this == null ? null : ctx_r1.$this.header == null ? null : ctx_r1.$this.header.allowHideLegend) && !ctx_r1.isMobile && !ctx_r1.suppressLegend);
        }
    }
    function AdaptChartComponent_ng_container_8_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementContainer(0);
        }
    }
    function AdaptChartComponent__svg_svg_17_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(0, "svg", 16, 17);
            i0__namespace.ɵɵtext(2, "\n          ");
            i0__namespace.ɵɵelementStart(3, "desc", 18);
            i0__namespace.ɵɵtext(4);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(5, "\n          ");
            i0__namespace.ɵɵelement(6, "g", 19);
            i0__namespace.ɵɵtext(7, "\n        ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r4 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵstyleProp("transition", ctx_r4.transition);
            i0__namespace.ɵɵattributeInterpolate2("viewbox", "0 0 ", ctx_r4.currentSVGWidth, " ", ctx_r4.currentSVGHeight, "");
            i0__namespace.ɵɵattribute("aria-label", ctx_r4.title || (ctx_r4.$this == null ? null : ctx_r4.$this.header == null ? null : ctx_r4.$this.header.title) || "")("width", ctx_r4.currentSVGWidth)("height", ctx_r4.currentSVGHeight ? ctx_r4.currentSVGHeight + ctx_r4.chartBottomPadding : ctx_r4.currentSVGHeight);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate(ctx_r4.description);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵattribute("id", ctx_r4.chartContainerId)("width", ctx_r4.currentSVGWidth);
        }
    }
    var _c6 = function (a0) { return { "adapt-legend-zone__hidden": a0 }; };
    function AdaptChartComponent_div_28_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div", 20);
            i0__namespace.ɵɵtext(1, "\n        ");
            i0__namespace.ɵɵelementStart(2, "adapt-chart-gradient-legend", 21);
            i0__namespace.ɵɵtext(3, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(4, "\n      ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r6 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵstyleProp("width", ctx_r6.isMobile ? "100%" : ctx_r6.legendWidth + "px")("transition", ctx_r6.transition);
            i0__namespace.ɵɵproperty("ngClass", i0__namespace.ɵɵpureFunction1(14, _c6, !ctx_r6.showLegend));
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("containerWidth", ctx_r6.legendWidth - 25)("increaseColor", ctx_r6.gradientLegend.increaseColor)("decreaseColor", ctx_r6.gradientLegend.decreaseColor)("zeroColor", ctx_r6.gradientLegend.zeroColor)("increaseText", ctx_r6.gradientLegend.increaseText)("decreaseText", ctx_r6.gradientLegend.decreaseText)("zeroText", ctx_r6.gradientLegend.zeroText)("height", ctx_r6.gradientLegend.height)("focusable", ctx_r6.showLegend);
        }
    }
    function AdaptChartComponent_div_30_Template(rf, ctx) {
        if (rf & 1) {
            var _r16_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "div", 20, 22);
            i0__namespace.ɵɵtext(2, "\n        ");
            i0__namespace.ɵɵelementStart(3, "adapt-chart-legend", 23, 24);
            i0__namespace.ɵɵlistener("categoryShow", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryShow_3_listener($event) { i0__namespace.ɵɵrestoreView(_r16_1); var ctx_r15 = i0__namespace.ɵɵnextContext(); return ctx_r15.categoryShow.emit($event); })("categoryHide", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryHide_3_listener($event) { i0__namespace.ɵɵrestoreView(_r16_1); var ctx_r17 = i0__namespace.ɵɵnextContext(); return ctx_r17.categoryHide.emit($event); })("categoryEnter", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryEnter_3_listener($event) { i0__namespace.ɵɵrestoreView(_r16_1); var ctx_r18 = i0__namespace.ɵɵnextContext(); return ctx_r18.categoryEnter.emit($event); })("categoryLeave", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryLeave_3_listener($event) { i0__namespace.ɵɵrestoreView(_r16_1); var ctx_r19 = i0__namespace.ɵɵnextContext(); return ctx_r19.categoryLeave.emit($event); })("categoryMove", function AdaptChartComponent_div_30_Template_adapt_chart_legend_categoryMove_3_listener($event) { i0__namespace.ɵɵrestoreView(_r16_1); var ctx_r20 = i0__namespace.ɵɵnextContext(); return ctx_r20.categoryMove.emit($event); });
            i0__namespace.ɵɵtext(5, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(6, "\n      ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r7 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵstyleProp("width", ctx_r7.isMobile ? "100%" : ctx_r7.legendWidth + "px")("transition", ctx_r7.transition);
            i0__namespace.ɵɵproperty("ngClass", i0__namespace.ɵɵpureFunction1(13, _c6, !ctx_r7.showLegend));
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("focusable", ctx_r7.showLegend)("activeHover", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.activeHover)("activeClick", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.activeClick)("customColors", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.customColors)("items", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.items)("width", ctx_r7.legendWidth - 30)("columns", ctx_r7.$this == null ? null : ctx_r7.$this.legend == null ? null : ctx_r7.$this.legend.columns)("colorsPalette", ctx_r7.colorsPalette);
        }
    }
    var _c7 = ["*", [["adapt-chart-slider"]], [["adapt-area-graph-slider"]]];
    var _c8 = ["*", "adapt-chart-slider", "adapt-area-graph-slider"];
    var CHART_ID = 1;
    var AdaptChartComponent = /** @class */ (function (_super) {
        __extends(AdaptChartComponent, _super);
        function AdaptChartComponent(_deviceDetectionService, _directionality, _domSanitizer, _injector, _ngZone, _changeDetectorRef, _overlayService) {
            var _this = _super.call(this) || this;
            _this._deviceDetectionService = _deviceDetectionService;
            _this._directionality = _directionality;
            _this._domSanitizer = _domSanitizer;
            _this._injector = _injector;
            _this._ngZone = _ngZone;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._overlayService = _overlayService;
            // TODO update types
            _this.$this = _this;
            /*
            * Useful to prevent legend rendering on view(eg. on chart slider component)
            * @since 11.4.0
            */
            _this.renderLegend = true;
            _this.categoryShow = new i0.EventEmitter();
            _this.categoryHide = new i0.EventEmitter();
            _this.categoryEnter = new i0.EventEmitter();
            _this.categoryLeave = new i0.EventEmitter();
            _this.categoryMove = new i0.EventEmitter();
            _this.clickChart = new i0.EventEmitter();
            _this.chartContainerId = 'chartContainer-';
            _this.isLegendHidden = false;
            _this.legendWidth = 250;
            _this.defaultMaxAxisWidth = 150;
            _this._emptyText = 'No data to show...';
            _this._tooltipOverlayDefaultOffset = 6;
            _this._tooltipDefaultCustomCls = 'adapt-chart-tooltip position-static';
            _this._showEmptyText = false;
            _this._chartBottomPadding = 0;
            _this._destroyed$ = new rxjs.ReplaySubject(1);
            var placements = i1.getOverlayConnectedPositions(_this._directionality.value, _this._tooltipOverlayDefaultOffset);
            _this._tooltipOverlayPlacements = {
                top: placements.top,
                bottom: placements.bottom,
                left: placements.left,
                right: placements.right
            };
            _this.id = CHART_ID;
            _this.chartContainerId += CHART_ID;
            CHART_ID++;
            return _this;
        }
        Object.defineProperty(AdaptChartComponent.prototype, "data", {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            set: function (v) {
                this._data = v;
                if (this._isDataExists()) {
                    this.hideTooltip();
                    this._drawChart();
                }
                else {
                    this._showEmptyText = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptChartComponent.prototype, "isMobile", {
            get: function () {
                return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptChartComponent.prototype, "showHeader", {
            get: function () {
                return !this.suppressHeader
                    && this.header
                    && this._isDataExists()
                    && (!lodashEs.isUndefined(this.header.title)
                        || !lodashEs.isUndefined(this.header.subtitle)
                        || !lodashEs.isUndefined(this.header.allowHideLegend));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptChartComponent.prototype, "showLegend", {
            get: function () {
                return !this.isLegendHidden && !this.suppressLegend
                    && (!lodashEs.isUndefined(this.legend) && !lodashEs.isUndefined(this.legend.items) && !!this.legend.items.length
                        || !lodashEs.isUndefined(this.gradientLegend));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptChartComponent.prototype, "chartWidth", {
            get: function () {
                return lodashEs.isUndefined(this.width) ? this.currentContainerWidth : this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptChartComponent.prototype, "chartHeight", {
            get: function () {
                return lodashEs.isUndefined(this.height) ? this.currentContainerHeight : this.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptChartComponent.prototype, "transition", {
            get: function () {
                return this._domSanitizer.bypassSecurityTrustStyle("all " + i1.ANIMATION_DURATION.fast + "\n      " + i1.ANIMATION_TIMING_FUNCTION.base.transitionIn);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptChartComponent.prototype, "chartBottomPadding", {
            get: function () {
                return this._chartBottomPadding;
            },
            set: function (value) {
                this._chartBottomPadding = value;
            },
            enumerable: false,
            configurable: true
        });
        AdaptChartComponent.prototype.ngOnInit = function () {
            if (this.legend && this.legend.width) {
                this.legendWidth = this.legend.width;
            }
        };
        AdaptChartComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            rxjs.timer(0, rxjs.asapScheduler)
                .pipe(operators.takeUntil(this._destroyed$))
                .subscribe(function () {
                _this.redrawChart();
            });
            if (!(this.width && this.height)) {
                if (this._showEmptyText) {
                    this._drawEmptyText();
                }
            }
        };
        AdaptChartComponent.prototype.ngOnDestroy = function () {
            this._removeListeners();
            this._destroyed$.next(true);
            this._destroyed$.complete();
            this.hideTooltip();
        };
        AdaptChartComponent.prototype.redrawChart = function () {
            var _a = this.chartContainerEl.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
            if (this.header && lodashEs.isUndefined(this.header.allowHideLegend)) {
                this.header.allowHideLegend = true;
            }
            if (width && this._isDataExists()) {
                this.currentContainerWidth = width;
                this.currentContainerHeight = height;
                this._initChart();
            }
            i1.SafeCdr.detectChanges(this._changeDetectorRef);
        };
        AdaptChartComponent.prototype.showTooltip = function (target, content, context, customCls, offset, sidePositionsFirst) {
            var _this = this;
            this.hideTooltip();
            this._ngZone.run(function () {
                if (target instanceof Element) {
                    _this._tooltipOverlayWithPortal = _this._overlayService.openOverlayWithPortal(new portal.ComponentPortal(i1.AdaptTooltipComponent, null, _this._injector), {
                        origin: target,
                        positionStrategy: 'connected',
                        scrollStrategy: 'close',
                        connectedPositions: _this._getTooltipPositions(offset, sidePositionsFirst)
                    });
                }
                else {
                    _this._tooltipOverlayWithPortal = _this._overlayService.openOverlayWithPortal(new portal.ComponentPortal(i1.AdaptTooltipComponent, null, _this._injector), {
                        origin: target,
                        positionStrategy: 'float',
                        scrollStrategy: 'close'
                    });
                    _this._tooltipOverlayWithPortal.overlayRef.updatePosition();
                }
                _this._tooltipOverlayWithPortal.componentRef.instance.content = content;
                _this._tooltipOverlayWithPortal.componentRef.instance.visible = true;
                _this._tooltipOverlayWithPortal.componentRef.instance.customCls = _this._tooltipDefaultCustomCls + " " + customCls;
                if (context) {
                    _this._tooltipOverlayWithPortal.componentRef.instance.context = context;
                }
            });
        };
        AdaptChartComponent.prototype.hideTooltip = function () {
            if (this._tooltipOverlayWithPortal) {
                this._tooltipOverlayWithPortal.destroy();
                this._tooltipOverlayWithPortal = null;
            }
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptChartComponent.prototype.updateTooltip = function (content, context) {
            if (this._tooltipOverlayWithPortal) {
                if (content) {
                    this._tooltipOverlayWithPortal.componentRef.instance.content = content;
                }
                if (context) {
                    this._tooltipOverlayWithPortal.componentRef.instance.context = context;
                }
                this._tooltipOverlayWithPortal.overlayRef.updatePosition();
            }
        };
        AdaptChartComponent.prototype.toggleLegend = function () {
            var width = this.chartAreaEl.nativeElement.getBoundingClientRect().width;
            var dim;
            this.isLegendHidden = !this.isLegendHidden;
            if (!this.isMobile) {
                dim = {
                    w: width + (this.isLegendHidden ? this.legendWidth : -this.legendWidth),
                    h: this.currentSVGHeight
                };
            }
            else {
                dim = {
                    w: width,
                    h: this.currentSVGHeight
                };
            }
            this._setChartSize(true, false);
            if (this.updateChart) {
                this.updateChart(dim);
            }
            if (!lodashEs.isUndefined(this.chartSliderCmp)) {
                this.chartSliderCmp.updateSlider(dim);
            }
            if (!lodashEs.isUndefined(this.areaChartSliderCmp)) {
                this.areaChartSliderCmp.updateSlider(dim);
            }
        };
        AdaptChartComponent.prototype.clear = function () {
            d3__namespace.select("#" + this.chartContainerId).selectAll('*').remove();
        };
        AdaptChartComponent.prototype.clickChartArea = function (e) {
            this.clickChart.emit(e);
        };
        AdaptChartComponent.prototype.updateLegend = function (items) {
            if (this.renderLegend) {
                this.legendComponent.update(items);
            }
        };
        AdaptChartComponent.prototype.getGroupAndDimensions = function () {
            var group = d3__namespace.select("#" + this.chartContainerId);
            this._setChartSize();
            return {
                group: group,
                w: this.currentSVGWidth,
                h: this.currentSVGHeight
            };
        };
        // Method creates hidden xAxis block to calculate maximum possible height.
        // Can be helpful when axis long titles need to be rotated
        AdaptChartComponent.prototype.updateChartBottomPadding = function (axisWidth, g, xAxis, rotateAxis) {
            if (rotateAxis === void 0) { rotateAxis = false; }
            if (!rotateAxis) {
                this.chartBottomPadding = 0;
                return;
            }
            var xScale = d3__namespace.scaleBand();
            xScale.range([0, axisWidth]).domain(xAxis.categories);
            var xScaleCall = d3__namespace.axisBottom(xScale).tickSizeOuter(0).tickPadding(12);
            g.select('g.fake-axis').remove();
            var axisBlock = g.append('g')
                .attr('class', 'fake-axis')
                .attr('style', 'display: none')
                .attr('aria-hidden', 'true')
                .call(xScaleCall);
            var textWidths = [];
            axisBlock.selectAll('text').each(function () {
                var text = d3__namespace.select(this);
                var length = text.node().getComputedTextLength();
                textWidths.push(length);
            });
            if (textWidths.length) {
                // TODO: Refactor this if possible
                // eslint-disable-next-line prefer-spread
                var largest = Math.max.apply(Math, textWidths);
                var diagonalHeight = largest > this.defaultMaxAxisWidth ? this.defaultMaxAxisWidth : largest;
                // Because we rotate string on 45 deg, we need to calculate height by Pythagoras theorem
                this.chartBottomPadding = Math.sqrt(Math.pow(diagonalHeight, 2) / 2);
            }
            else {
                this.chartBottomPadding = 0;
            }
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptChartComponent.prototype.transformAxisTitles = function (axisBlock, shouldRotate) {
            var axisTexts = axisBlock.selectAll('text');
            axisTexts
                .style('text-anchor', shouldRotate ? 'end' : 'middle')
                .attr('dx', shouldRotate ? '-.8em' : '0')
                .attr('dy', shouldRotate ? '.15em' : '9')
                .attr('transform', shouldRotate ? 'rotate(-45)' : 'rotate(0)');
            if (shouldRotate) {
                axisTexts.call(textWrap, this.defaultMaxAxisWidth);
            }
        };
        AdaptChartComponent.prototype._initChart = function () {
            this._setContainerSize();
            this._setChartSize();
            this._drawChart();
        };
        /**
         * This method manages the size of the main container element, dependently on
         * which size parameters have been set
         */
        AdaptChartComponent.prototype._setContainerSize = function () {
            var _a = this, width = _a.width, height = _a.height;
            this.currentContainerWidth = lodashEs.isUndefined(width) ? this.currentContainerWidth : width;
            this.currentContainerHeight = lodashEs.isUndefined(height) ? this.currentContainerHeight : height;
        };
        AdaptChartComponent.prototype._setChartSize = function (recalculateWidth, recalculateHeight) {
            if (recalculateWidth === void 0) { recalculateWidth = true; }
            if (recalculateHeight === void 0) { recalculateHeight = true; }
            if (recalculateHeight) {
                var height = this.chartAreaEl.nativeElement.getBoundingClientRect().height;
                var sliderHeight = this.chartSliderEl.nativeElement.getBoundingClientRect().height;
                // @TODO: For area chart slider height is 0 on init, because of that chart height recalculate incorrectly when legend toggle
                this.currentSVGHeight = height - sliderHeight;
            }
            if (recalculateWidth) {
                var width = this.chartContainerEl.nativeElement.getBoundingClientRect().width;
                this.currentSVGWidth = width - (this.showLegend && !this.isMobile ? this.legendWidth : 0);
            }
        };
        AdaptChartComponent.prototype._drawChart = function () {
            if (!this.dataBuilder) {
                return;
            }
            var options = this.getGroupAndDimensions();
            options.group.selectAll('*').remove();
            this.dataBuilder(options.group, {
                w: options.w,
                h: options.h
            });
        };
        AdaptChartComponent.prototype._isDataExists = function () {
            return !lodashEs.isUndefined(this._data) && !lodashEs.isNull(this._data);
        };
        AdaptChartComponent.prototype._drawEmptyText = function () {
            var group = d3__namespace.select("#" + this.chartContainerId);
            group.append('text')
                .attr('text-anchor', 'middle')
                .style('transform', 'translate(50%, 50%)')
                .style('font-size', '13px')
                .style('fill', 'currentcolor')
                .classed('text-default', true)
                .text(this.noDataText || this._emptyText);
        };
        AdaptChartComponent.prototype._removeListeners = function () {
            if (this._removeClickEventListener) {
                this._removeClickEventListener();
            }
            if (this._removeScrollEventListener) {
                this._removeScrollEventListener();
            }
        };
        AdaptChartComponent.prototype._getTooltipPositions = function (offset, sidePositionsFirst) {
            if (lodashEs.isNumber(offset) && (offset !== this._tooltipOverlayDefaultOffset)) {
                this._tooltipOverlayDefaultOffset = offset;
                this._tooltipOverlayPlacements.top.offsetY = -this._tooltipOverlayDefaultOffset;
                this._tooltipOverlayPlacements.bottom.offsetY = this._tooltipOverlayDefaultOffset;
                this._tooltipOverlayPlacements.left.offsetX = -this._tooltipOverlayDefaultOffset;
                this._tooltipOverlayPlacements.right.offsetX = this._tooltipOverlayDefaultOffset;
            }
            return sidePositionsFirst ?
                [
                    this._tooltipOverlayPlacements.right,
                    this._tooltipOverlayPlacements.left,
                    this._tooltipOverlayPlacements.top,
                    this._tooltipOverlayPlacements.bottom
                ] :
                [
                    this._tooltipOverlayPlacements.top,
                    this._tooltipOverlayPlacements.bottom,
                    this._tooltipOverlayPlacements.left,
                    this._tooltipOverlayPlacements.right
                ];
        };
        return AdaptChartComponent;
    }(AdaptChartAbstract));
    AdaptChartComponent.ɵfac = function AdaptChartComponent_Factory(t) { return new (t || AdaptChartComponent)(i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptDeviceDetectionService), i0__namespace.ɵɵdirectiveInject(i2__namespace.Directionality), i0__namespace.ɵɵdirectiveInject(i3__namespace$1.DomSanitizer), i0__namespace.ɵɵdirectiveInject(i0__namespace.Injector), i0__namespace.ɵɵdirectiveInject(i0__namespace.NgZone), i0__namespace.ɵɵdirectiveInject(i0__namespace.ChangeDetectorRef), i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptOverlayService)); };
    AdaptChartComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptChartComponent, selectors: [["adapt-chart"]], contentQueries: function AdaptChartComponent_ContentQueries(rf, ctx, dirIndex) {
            if (rf & 1) {
                i0__namespace.ɵɵcontentQuery(dirIndex, AdaptChartSliderComponent, 5);
                i0__namespace.ɵɵcontentQuery(dirIndex, AdaptAreaGraphSliderComponent, 5);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartSliderCmp = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.areaChartSliderCmp = _t.first);
            }
        }, viewQuery: function AdaptChartComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(_c0$7, 7);
                i0__namespace.ɵɵviewQuery(_c1$5, 7);
                i0__namespace.ɵɵviewQuery(_c2$3, 5);
                i0__namespace.ɵɵviewQuery(_c3$1, 5);
                i0__namespace.ɵɵviewQuery(_c4$1, 5);
                i0__namespace.ɵɵviewQuery(_c5, 7);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartContainerEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartAreaEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.svgContainerEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.legendEl = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.legendComponent = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartSliderEl = _t.first);
            }
        }, inputs: { title: "title", description: "description", backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", renderLegend: "renderLegend", gradientLegend: "gradientLegend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", noDataText: "noDataText", dataBuilder: "dataBuilder", updateChart: "updateChart", colorsPalette: "colorsPalette", topSectionTemplate: "topSectionTemplate", data: "data" }, outputs: { categoryShow: "categoryShow", categoryHide: "categoryHide", categoryEnter: "categoryEnter", categoryLeave: "categoryLeave", categoryMove: "categoryMove", clickChart: "clickChart" }, features: [i0__namespace.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 35, vars: 17, consts: [[1, "adapt-chart", 3, "click"], ["chartContainer", ""], ["class", "adapt-chart-header", 4, "ngIf"], [4, "ngTemplateOutlet"], [1, "adapt-chart-body"], [1, "adapt-chart-zone"], ["chartArea", ""], ["xmlns", "http://www.w3.org/2000/svg", "class", "adapt-chart-svg", "tabindex", "0", "role", "graphic/image", 3, "transition", 4, "ngIf"], [1, "adapt-chart-slider-wrapper"], ["chartSlider", ""], ["class", "adapt-legend-zone", 3, "width", "transition", "ngClass", 4, "ngIf"], [1, "adapt-chart-header"], ["class", "adapt-chart-header-title m-0", 4, "ngIf"], ["class", "adapt-chart-context-menu-btn", "role", "button", 3, "click", 4, "ngIf"], [1, "adapt-chart-header-title", "m-0"], ["role", "button", 1, "adapt-chart-context-menu-btn", 3, "click"], ["xmlns", "http://www.w3.org/2000/svg", "tabindex", "0", "role", "graphic/image", 1, "adapt-chart-svg"], ["svgContainer", ""], ["id", "desc"], [1, "adapt-chart-group"], [1, "adapt-legend-zone", 3, "ngClass"], [3, "containerWidth", "increaseColor", "decreaseColor", "zeroColor", "increaseText", "decreaseText", "zeroText", "height", "focusable"], ["legend", ""], [3, "focusable", "activeHover", "activeClick", "customColors", "items", "width", "columns", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave", "categoryMove"], ["legendComponent", ""]], template: function AdaptChartComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵprojectionDef(_c7);
                i0__namespace.ɵɵelementStart(0, "div");
                i0__namespace.ɵɵtext(1, "\n  ");
                i0__namespace.ɵɵelementStart(2, "div", 0, 1);
                i0__namespace.ɵɵlistener("click", function AdaptChartComponent_Template_div_click_2_listener($event) { return ctx.clickChartArea($event); });
                i0__namespace.ɵɵtext(4, "\n\n    ");
                i0__namespace.ɵɵtemplate(5, AdaptChartComponent_div_5_Template, 6, 2, "div", 2);
                i0__namespace.ɵɵtext(6, "\n\n    ");
                i0__namespace.ɵɵtext(7, "\n    ");
                i0__namespace.ɵɵtemplate(8, AdaptChartComponent_ng_container_8_Template, 1, 0, "ng-container", 3);
                i0__namespace.ɵɵtext(9, "\n\n    ");
                i0__namespace.ɵɵelementStart(10, "div", 4);
                i0__namespace.ɵɵtext(11, "\n      ");
                i0__namespace.ɵɵelementStart(12, "div", 5, 6);
                i0__namespace.ɵɵtext(14, "\n        ");
                i0__namespace.ɵɵprojection(15);
                i0__namespace.ɵɵtext(16, "\n        ");
                i0__namespace.ɵɵtemplate(17, AdaptChartComponent__svg_svg_17_Template, 8, 10, "svg", 7);
                i0__namespace.ɵɵtext(18, "\n        ");
                i0__namespace.ɵɵelementStart(19, "div", 8, 9);
                i0__namespace.ɵɵtext(21, "\n          ");
                i0__namespace.ɵɵprojection(22, 1);
                i0__namespace.ɵɵtext(23, "\n          ");
                i0__namespace.ɵɵprojection(24, 2);
                i0__namespace.ɵɵtext(25, "\n        ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(26, "\n      ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(27, "\n      ");
                i0__namespace.ɵɵtemplate(28, AdaptChartComponent_div_28_Template, 5, 16, "div", 10);
                i0__namespace.ɵɵtext(29, "\n      ");
                i0__namespace.ɵɵtemplate(30, AdaptChartComponent_div_30_Template, 7, 15, "div", 10);
                i0__namespace.ɵɵtext(31, "\n    ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(32, "\n  ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(33, "\n");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(34, "\n");
            }
            if (rf & 2) {
                i0__namespace.ɵɵstyleProp("height", ctx.chartHeight + ctx.chartBottomPadding, "px");
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵstyleProp("width", ctx.chartWidth, "px")("height", ctx.chartHeight, "px");
                i0__namespace.ɵɵclassProp("adapt-chart-mobile", ctx.isMobile);
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵproperty("ngIf", ctx.showHeader);
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵproperty("ngTemplateOutlet", ctx.topSectionTemplate);
                i0__namespace.ɵɵadvance(4);
                i0__namespace.ɵɵstyleProp("width", 0, "px")("background-color", ctx.$this.backgroundColor);
                i0__namespace.ɵɵadvance(5);
                i0__namespace.ɵɵproperty("ngIf", ctx.dataBuilder);
                i0__namespace.ɵɵadvance(11);
                i0__namespace.ɵɵproperty("ngIf", ctx.gradientLegend);
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵproperty("ngIf", ctx.legend && ctx.renderLegend);
            }
        }, directives: [i3__namespace.NgIf, i3__namespace.NgTemplateOutlet, i3__namespace.NgClass, ChartGradientLegendComponent, ChartLegendComponent], encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptChartComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-chart',
                        templateUrl: './chart.component.html',
                        encapsulation: i0.ViewEncapsulation.None
                    }]
            }], function () { return [{ type: i1__namespace.AdaptDeviceDetectionService }, { type: i2__namespace.Directionality }, { type: i3__namespace$1.DomSanitizer }, { type: i0__namespace.Injector }, { type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }, { type: i1__namespace.AdaptOverlayService }]; }, { title: [{
                    type: i0.Input
                }], description: [{
                    type: i0.Input
                }], backgroundColor: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], header: [{
                    type: i0.Input
                }], legend: [{
                    type: i0.Input
                }], renderLegend: [{
                    type: i0.Input
                }], gradientLegend: [{
                    type: i0.Input
                }], suppressHeader: [{
                    type: i0.Input
                }], suppressLegend: [{
                    type: i0.Input
                }], tooltip: [{
                    type: i0.Input
                }], noDataText: [{
                    type: i0.Input
                }], dataBuilder: [{
                    type: i0.Input
                }], updateChart: [{
                    type: i0.Input
                }], colorsPalette: [{
                    type: i0.Input
                }], topSectionTemplate: [{
                    type: i0.Input
                }], data: [{
                    type: i0.Input
                }], categoryShow: [{
                    type: i0.Output
                }], categoryHide: [{
                    type: i0.Output
                }], categoryEnter: [{
                    type: i0.Output
                }], categoryLeave: [{
                    type: i0.Output
                }], categoryMove: [{
                    type: i0.Output
                }], clickChart: [{
                    type: i0.Output
                }], chartContainerEl: [{
                    type: i0.ViewChild,
                    args: ['chartContainer', { static: true }]
                }], chartAreaEl: [{
                    type: i0.ViewChild,
                    args: ['chartArea', { static: true }]
                }], svgContainerEl: [{
                    type: i0.ViewChild,
                    args: ['svgContainer', { static: false }]
                }], legendEl: [{
                    type: i0.ViewChild,
                    args: ['legend', { static: false }]
                }], legendComponent: [{
                    type: i0.ViewChild,
                    args: ['legendComponent', { static: false }]
                }], chartSliderEl: [{
                    type: i0.ViewChild,
                    args: ['chartSlider', { static: true }]
                }], chartSliderCmp: [{
                    type: i0.ContentChild,
                    args: [AdaptChartSliderComponent, { static: false }]
                }], areaChartSliderCmp: [{
                    type: i0.ContentChild,
                    args: [AdaptAreaGraphSliderComponent, { static: false }]
                }] });
    })();

    var NumberPrefix = /** @class */ (function () {
        function NumberPrefix() {
        }
        return NumberPrefix;
    }());
    NumberPrefix.K = Math.pow(10, 3);
    NumberPrefix.M = Math.pow(10, 6);
    NumberPrefix.G = Math.pow(10, 9);
    NumberPrefix.T = Math.pow(10, 12);
    var CutNumberPipe = /** @class */ (function () {
        function CutNumberPipe() {
        }
        // TODO: Double check 'fractional' argument
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        CutNumberPipe.prototype.transform = function (value, fractional) {
            if (fractional === void 0) { fractional = 2; }
            var prefixes = Object.keys(NumberPrefix);
            var shortValue;
            prefixes.some(function (prefixCurrent, id) {
                var prefixPrevious = prefixes[id - 1];
                if (value < NumberPrefix[prefixCurrent]) {
                    if (prefixPrevious) {
                        var t = value % NumberPrefix[prefixPrevious];
                        shortValue = (value / NumberPrefix[prefixPrevious]).toFixed(t ? 1 : 0) + prefixPrevious;
                    }
                    else {
                        shortValue = Number(value.toFixed(6)).toString();
                    }
                }
                return value < NumberPrefix[prefixCurrent];
            });
            return shortValue;
        };
        return CutNumberPipe;
    }());
    CutNumberPipe.ɵfac = function CutNumberPipe_Factory(t) { return new (t || CutNumberPipe)(); };
    CutNumberPipe.ɵpipe = /*@__PURE__*/ i0__namespace.ɵɵdefinePipe({ name: "cutNumber", type: CutNumberPipe, pure: true });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(CutNumberPipe, [{
                type: i0.Pipe,
                args: [{
                        name: 'cutNumber'
                    }]
            }], null, null);
    })();

    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    function textEllipsis(textNode, text, ellipsisWidth) {
        var ellipsisText = '';
        var width = ellipsisWidth;
        var letters = text.split('');
        var lettersNum = letters.length;
        // Clear all children before inserting text
        textNode.selectAll('*').remove();
        var ellipsis = textNode.append('tspan').attr('class', 'ellipsis').text('...');
        var tSpan = textNode.insert('tspan', ':first-child').text(letters.join(''));
        if (tSpan.node().getComputedTextLength() > width && letters.length) {
            width = ellipsisWidth - ellipsis.node().getComputedTextLength();
        }
        // Try the whole line
        // While it's too long, and we have words left, keep removing words
        while (tSpan.node().getComputedTextLength() > width && letters.length) {
            letters.pop();
            tSpan.text(letters.join(''));
        }
        if (letters.length === lettersNum) {
            ellipsis.remove();
            ellipsisText = tSpan.text();
        }
        else {
            ellipsisText = tSpan.text() + '...';
        }
        return ellipsisText;
    }

    var _c0$6 = ["tooltipTpl"];
    var _c1$4 = ["tooltipListInfoTpl"];
    function AdaptStackedChartComponent_adapt_chart_slider_4_Template(rf, ctx) {
        if (rf & 1) {
            var _r7_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "adapt-chart-slider", 5);
            i0__namespace.ɵɵlistener("rangeChanged", function AdaptStackedChartComponent_adapt_chart_slider_4_Template_adapt_chart_slider_rangeChanged_0_listener($event) { i0__namespace.ɵɵrestoreView(_r7_1); var ctx_r6 = i0__namespace.ɵɵnextContext(); return ctx_r6.changeDataRange($event); });
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r1 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵproperty("slidePointsCount", ctx_r1.slidePointsCount)("height", ctx_r1.sliderHeight)("xAxis", ctx_r1.xAxis)("data", ctx_r1.sliderData)("containerWidth", ctx_r1.chartWidth)("customColors", ctx_r1.legend == null ? null : ctx_r1.legend.customColors)("leftShift", ctx_r1.leftShift)("type", ctx_r1.sliderType)("stackedChart", ctx_r1.getStackedChart());
        }
    }
    function AdaptStackedChartComponent_ng_template_7_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n      ");
            i0__namespace.ɵɵelementStart(1, "div", 6);
            i0__namespace.ɵɵtext(2, "\n        ");
            i0__namespace.ɵɵelementStart(3, "div");
            i0__namespace.ɵɵtext(4, "\n          ");
            i0__namespace.ɵɵelement(5, "span", 7);
            i0__namespace.ɵɵtext(6, "\n          ");
            i0__namespace.ɵɵelementStart(7, "span", 8);
            i0__namespace.ɵɵtext(8);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n          ");
            i0__namespace.ɵɵelementStart(10, "span");
            i0__namespace.ɵɵelementStart(11, "b");
            i0__namespace.ɵɵtext(12);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(13, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(14, "\n        ");
            i0__namespace.ɵɵelementStart(15, "div");
            i0__namespace.ɵɵtext(16, "\n          Total:\n          ");
            i0__namespace.ɵɵelementStart(17, "span");
            i0__namespace.ɵɵelementStart(18, "b");
            i0__namespace.ɵɵtext(19);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(20, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(21, "\n      ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(22, "\n    ");
        }
        if (rf & 2) {
            var data_r8 = ctx.data;
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵstyleProp("background-color", data_r8 == null ? null : data_r8.color);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate1("", data_r8.category, ":");
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate(data_r8.value);
            i0__namespace.ɵɵadvance(7);
            i0__namespace.ɵɵtextInterpolate(data_r8.total);
        }
    }
    function AdaptStackedChartComponent_ng_template_10_div_3_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementContainerStart(0);
            i0__namespace.ɵɵtext(1, "\n            ");
            i0__namespace.ɵɵelement(2, "span", 7);
            i0__namespace.ɵɵtext(3, "\n            ");
            i0__namespace.ɵɵelementStart(4, "span", 8);
            i0__namespace.ɵɵtext(5);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(6, "\n            ");
            i0__namespace.ɵɵelementStart(7, "span");
            i0__namespace.ɵɵelementStart(8, "b");
            i0__namespace.ɵɵtext(9);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(10, "\n          ");
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var d_r11 = i0__namespace.ɵɵnextContext().$implicit;
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵstyleProp("background-color", d_r11 == null ? null : d_r11.color);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate1("", d_r11.category, ":");
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate(d_r11.value);
        }
    }
    function AdaptStackedChartComponent_ng_template_10_div_3_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div");
            i0__namespace.ɵɵtext(1, "\n          ");
            i0__namespace.ɵɵtemplate(2, AdaptStackedChartComponent_ng_template_10_div_3_ng_container_2_Template, 11, 4, "ng-container", 12);
            i0__namespace.ɵɵtext(3, "\n        ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var d_r11 = ctx.$implicit;
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngIf", d_r11.value !== 0);
        }
    }
    function AdaptStackedChartComponent_ng_template_10_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n      ");
            i0__namespace.ɵɵelementStart(1, "div", 9);
            i0__namespace.ɵɵtext(2, "\n        ");
            i0__namespace.ɵɵtemplate(3, AdaptStackedChartComponent_ng_template_10_div_3_Template, 4, 1, "div", 10);
            i0__namespace.ɵɵtext(4, "\n        ");
            i0__namespace.ɵɵelement(5, "hr", 11);
            i0__namespace.ɵɵtext(6, "\n        ");
            i0__namespace.ɵɵelementStart(7, "div");
            i0__namespace.ɵɵtext(8, "\n          Total:\n          ");
            i0__namespace.ɵɵelementStart(9, "span");
            i0__namespace.ɵɵelementStart(10, "b");
            i0__namespace.ɵɵtext(11);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(12, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(13, "\n      ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(14, "\n    ");
        }
        if (rf & 2) {
            var data_r9 = ctx.data;
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("ngForOf", data_r9.seriesData);
            i0__namespace.ɵɵadvance(8);
            i0__namespace.ɵɵtextInterpolate(data_r9.total);
        }
    }
    var chartCounter$2 = 1;
    var DEFAULT_MARGIN = 10;
    // TODO update types
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    var AdaptStackedChartComponent = /** @class */ (function (_super) {
        __extends(AdaptStackedChartComponent, _super);
        function AdaptStackedChartComponent(_cutNumber, _colorService) {
            var _this_1 = _super.call(this) || this;
            _this_1._cutNumber = _cutNumber;
            _this_1._colorService = _colorService;
            _this_1.sliderType = exports.AdaptChartSliderType.bar;
            _this_1.sliderHeight = 36;
            _this_1.heightZero = 0;
            _this_1.showSlider = false;
            _this_1.hasTotalLabels = false;
            _this_1.rotateXAxis = false;
            _this_1.scientificMode = false;
            /*
            * Useful to prevent legend rendering on view(eg. on chart slider component)
            * @since 11.4.0
            */
            _this_1.renderLegend = true;
            _this_1.showEmptyColIndicator = true;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this_1.clickChart = new i0.EventEmitter();
            /**
             * Output that emits each time chart category shown
             * @since 12.11.0
             */
            _this_1.categoryShow = new i0.EventEmitter();
            /**
             * Output that emits each time chart category hidden
             * @since 12.11.0
             */
            _this_1.categoryHide = new i0.EventEmitter();
            _this_1.alreadyChanged = false;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this_1._data = [];
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this_1._dataFull = [];
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this_1._colors = [];
            _this_1._maxTicksCount = 7;
            _this_1._totalByCol = {};
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this_1._categoryFilter = [];
            // Default values of xAxis, yAxis and axisTitle thickness
            _this_1._axisXThickness = 50;
            _this_1._axisYThickness = 25;
            _this_1._axisTitleThickness = 20;
            _this_1._legend = {
                columns: 2,
                activeHover: true,
                activeClick: true,
                width: 250,
                customColors: null,
                items: []
            };
            _this_1._series = [];
            _this_1._startDataPiece = 0;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this_1._cls = {
                axis: 'adapt-chart-axis',
                axisHidden: 'adapt-chart-axis__hidden',
                axisTitle: 'adapt-chart-axis-title',
                axisXTitle: 'adapt-chart-axis-x-title',
                axisYTitle: 'adapt-chart-axis-y-title',
                barXAxis: 'bar-x-axis',
                barYAxis: 'bar-y-axis',
                colXAxis: 'col-x-axis',
                colYAxis: 'col-y-axis',
                category: 'adapt-chart-bars-category',
                areaGroup: 'adapt-chart-area-group',
                areaTooltipLines: 'adapt-chart-area-tooltip-lines',
                dataRect: 'adapt-chart-data-rect',
                totalLabelsGroup: 'total-labels-group',
                totalLabelsGroupItem: 'total-labels-group-item',
                totalLabelItem: 'total-label-item',
                thresholdLineArea: 'threshold-line-area'
            };
            _this_1._emptyColIndicatorWidth = 22;
            _this_1._emptyColIndicatorHeight = 24;
            _this_1.updateChart = _this_1.updateChart.bind(_this_1);
            _this_1._dataBuilder = _this_1._dataBuilder.bind(_this_1);
            _this_1._id = "stacked-chart-" + chartCounter$2++;
            return _this_1;
        }
        Object.defineProperty(AdaptStackedChartComponent.prototype, "isHorizontalSeries", {
            get: function () {
                return this.seriesDisplay === 'horizontal';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptStackedChartComponent.prototype, "series", {
            get: function () {
                return this._series;
            },
            set: function (s) {
                var _this_1 = this;
                this.sliderData = s;
                this._categoryFilter = [];
                s.forEach(function (series) {
                    if (series.hidden) {
                        _this_1._categoryFilter.push(series.name);
                    }
                });
                if (this.showSlider) {
                    this._series = this._getDataRange();
                }
                else {
                    this._series = s;
                }
                if (this.alreadyChanged) {
                    var options = this.chartComponent.getGroupAndDimensions();
                    this._g = options.group;
                    this._dim = {
                        w: options.w,
                        h: options.h
                    };
                }
                if (this._g && this._dim && this.chartComponent) {
                    this.chartComponent.updateLegend(this.series.map(function (item) { return ({
                        item: item.name,
                        hidden: !!item.hidden,
                        hover: false
                    }); }));
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptStackedChartComponent.prototype, "legend", {
            get: function () {
                return {
                    customColors: this._legend.customColors,
                    activeHover: this._legend.activeHover,
                    activeClick: this._legend.activeClick,
                    columns: this._legend.columns,
                    width: this._legend.width,
                    items: (this.series && this.series.map(function (series) { return ({
                        item: series.name,
                        hidden: !!series.hidden
                    }); }))
                };
            },
            set: function (legend) {
                this._legend = Object.assign(this._legend, legend);
                if (this.alreadyChanged) {
                    this.chartComponent.redrawChart();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptStackedChartComponent.prototype, "leftShift", {
            get: function () {
                return this._margin.left;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptStackedChartComponent.prototype, "chartWidth", {
            get: function () {
                return this.width || this.chartComponent.chartWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptStackedChartComponent.prototype, "duration", {
            get: function () {
                return parseFloat(i1.ANIMATION_DURATION.fast) * 1000;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptStackedChartComponent.prototype, "_margin", {
            get: function () {
                return {
                    top: 0,
                    left: !this.hideAxises && this.xAxis ?
                        (this.xAxis.thickness || this._axisXThickness) + (this.xAxis.title ? this._axisTitleThickness : 0) : 0,
                    right: 0,
                    bottom: !this.hideAxises && this.yAxis ?
                        (this.yAxis.thickness || this._axisYThickness) + (this.yAxis.title ? this._axisTitleThickness : 0) : 0
                };
            },
            enumerable: false,
            configurable: true
        });
        AdaptStackedChartComponent.prototype.ngOnInit = function () {
            if (this.scientificMode) {
                BigNumber__default["default"].config({ EXPONENTIAL_AT: 4 });
            }
            if (this.showSlider && !this.slidePointsCount) {
                this._initSlidePointsCount();
            }
            this.alreadyChanged = true;
        };
        AdaptStackedChartComponent.prototype.ngOnChanges = function (changes) {
            if ((changes[nameof('type')]
                || changes[nameof('showSlider')]
                || changes[nameof('thresholdLine')]
                || changes[nameof('seriesDisplay')]
                || changes[nameof('hasTotalLabels')]
                || changes[nameof('barWidth')]
                || changes[nameof('rotateXAxis')])
                && this.alreadyChanged && this._dim) {
                this.chartComponent.redrawChart();
            }
        };
        AdaptStackedChartComponent.prototype.updateChart = function (dim) {
            if (dim) {
                this._dim = dim;
            }
            else {
                dim = this._dim;
            }
            this._initData();
            this._prepareOrdinal();
            this._updateAxisX(dim);
            this._updateAxisY(dim);
            this._updateData();
            this._updateThresholdLineArea();
        };
        AdaptStackedChartComponent.prototype._dataBuilder = function (g, dim) {
            this._g = g;
            this._dim = dim;
            this._clear();
            this._initData();
            this._prepareOrdinal();
            this._drawAxisX(g, dim);
            this._drawAxisY(g, dim);
            this._drawData(g);
            this._updateThresholdLineArea();
        };
        AdaptStackedChartComponent.prototype.getStackedChart = function () {
            return this;
        };
        AdaptStackedChartComponent.prototype.categoryEnterHandler = function (categoryEvent) {
            var categoryGroup = this._g.select("[data-category-id='" + categoryEvent.id + "']");
            var categoryGroupColor = categoryGroup.attr('fill');
            var hoveredColor = this._colorService.getDarken(categoryGroupColor, .15, i1.ColorType.HEX);
            this._highlightColor = categoryGroupColor;
            categoryGroup.attr('fill', hoveredColor);
        };
        AdaptStackedChartComponent.prototype.categoryLeaveHandler = function (categoryEvent) {
            var categoryGroup = this._g.select("[data-category-id='" + categoryEvent.id + "']");
            categoryGroup.attr('fill', this._highlightColor);
        };
        AdaptStackedChartComponent.prototype.categoryShowHandler = function (category) {
            var categoryId = this._categoryFilter.indexOf(category);
            if (categoryId !== -1) {
                this._categoryFilter.splice(categoryId, 1);
            }
            this.updateChart(null);
            if (!i1.isUndefined(this.chartSliderComponent)) {
                this.chartSliderComponent.showCategory(category);
            }
            this.categoryShow.emit({ category: category });
        };
        AdaptStackedChartComponent.prototype.categoryHideHandler = function (category) {
            this._categoryFilter.push(category);
            this.updateChart(null);
            if (!i1.isUndefined(this.chartSliderComponent)) {
                this.chartSliderComponent.hideCategory(category);
            }
            this.categoryHide.emit({ category: category });
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype.clickChartArea = function (e) {
            var _this_1 = this;
            var target = e.target;
            var isRect = target.classList.contains(this._cls.dataRect);
            if (isRect) {
                var color = d3__namespace.select(target.parentNode).attr('fill');
                var categoryId = target.parentNode.getAttribute('data-category-id');
                var category_1 = this.series[categoryId].name;
                var id_1 = target.getAttribute('data-id');
                var value = this._data[id_1][category_1];
                var keys = Object.keys(this._data[id_1]);
                var axisCategory = this._data[id_1].name;
                var nameId = keys.indexOf('name');
                keys.splice(nameId, 1);
                var total = keys.reduce(function (acc, c) { return acc + _this_1._data[id_1][c]; }, 0);
                this.clickChart.emit({
                    event: e,
                    data: this.series.filter(function (d) { return category_1 === d.name; })[0],
                    axisCategory: axisCategory,
                    color: color,
                    categoryId: category_1,
                    value: value,
                    total: total
                });
            }
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype.changeDataRange = function (range) {
            this._startDataPiece = range.startPiece;
            this._endDataPiece = range.endPiece;
            this._series = this._getDataRange();
            this._totalByCol = {};
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype.getFormattedSeries = function (data) {
            var _this_1 = this;
            var formattedData = data.series.map(function (d) {
                return {
                    categoryName: d.name,
                    seriesValues: Object.entries(d).filter(function (v) { return v[0] !== 'name'; })
                };
            });
            var currentCategory = formattedData.find(function (d) { return d.categoryName === data.category; });
            var total = currentCategory.seriesValues.reduce(function (acc, cur) { return acc + cur[1]; }, 0);
            currentCategory.seriesValues = currentCategory.seriesValues.map(function (d, i) {
                return {
                    category: d[0],
                    value: d[1],
                    color: _this_1.legend.customColors ? _this_1._getCustomColorById(i) : _this_1._colorService.getColor(i)
                };
            });
            return {
                seriesData: currentCategory.seriesValues,
                total: total
            };
        };
        AdaptStackedChartComponent.prototype._initData = function () {
            var _this_1 = this;
            if (this.showSlider) {
                this._endDataPiece = this._endDataPiece || this.slidePointsCount;
            }
            var ctg = this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories;
            this._data = [];
            this._dataFull = [];
            ctg.forEach(function (c, index) {
                var o = {
                    name: c
                };
                _this_1.series.forEach(function (s) {
                    if (_this_1._categoryFilter.indexOf(s.name) === -1) {
                        o[s.name] = o[s.name] || 0;
                        o[s.name] += s.data[index];
                    }
                    else {
                        o[s.name] = 0;
                    }
                });
                _this_1._data.push(o);
            });
            this.xAxis.categories.forEach(function (c, index) {
                var o = {
                    name: c
                };
                _this_1.sliderData.forEach(function (s) {
                    if (_this_1._categoryFilter.indexOf(s.name) === -1) {
                        o[s.name] = o[s.name] || 0;
                        o[s.name] += s.data[index];
                    }
                    else {
                        o[s.name] = 0;
                    }
                });
                _this_1._dataFull.push(o);
            });
            this._data.forEach(function (data) {
                var name = data.name;
                var categories = Object.keys(data);
                _this_1._totalByCol[name] = 0;
                categories.forEach(function (category) {
                    if (category !== 'name') {
                        if (_this_1.scientificMode) {
                            _this_1._totalByCol[name] = new BigNumber__default["default"](_this_1._totalByCol[name]).plus(data[category]);
                        }
                        else {
                            _this_1._totalByCol[name] += data[category];
                        }
                    }
                });
            });
        };
        AdaptStackedChartComponent.prototype._prepareOrdinal = function () {
            var _this_1 = this;
            this._keys = this.series.map(function (s) { return s.name; });
            this._colors = [];
            this.series.forEach(function (s, id) {
                _this_1._colors.push(_this_1._legend.customColors ? _this_1._getCustomColorById(id) : _this_1._colorService.getColor(id));
            });
            this._ordinal = d3__namespace.scaleOrdinal()
                .range(this._colors)
                .domain(this._keys);
        };
        AdaptStackedChartComponent.prototype._drawAxisX = function (g, dim) {
            switch (this.type) {
                case exports.AdaptStackedChartType.Bar: {
                    this._drawAxisXForBar(g, dim);
                    break;
                }
                case exports.AdaptStackedChartType.Column: {
                    this._drawAxisXForColumn(g, dim);
                    break;
                }
                case exports.AdaptStackedChartType.Area: {
                    this._drawAxisXForArea(g, dim);
                    break;
                }
            }
        };
        AdaptStackedChartComponent.prototype._drawAxisXForBar = function (g, dim) {
            var _this_1 = this;
            var ticks = this._getTicks().reverse();
            this._drawAxisTitle(g, dim, this.xAxis.title, true);
            this._xScale = d3__namespace.scaleLinear();
            this._xScale.rangeRound([dim.w - this._margin.left - this._margin.right, 0]).domain([ticks[0], 0]);
            this._xAxisCall = d3__namespace.axisBottom(this._xScale)
                .tickValues(ticks)
                .tickSize(-dim.h + this._margin.top + this._margin.bottom)
                .tickFormat(function (d, i) { return lodashEs.isFunction(_this_1.xAxisTickFormatResolver) ? _this_1.xAxisTickFormatResolver(d, i) : _this_1._getTickFormatForNumber(d); })
                .tickPadding(15);
            g.append('g')
                .attr('role', 'axis')
                .attr('class', this._cls.axis + " " + this._cls.barXAxis + " " + (this.hideAxises ? this._cls.axisHidden : ''))
                .attr('transform', "translate(" + this._margin.left + ", " + (dim.h - this._margin.top - this._margin.bottom) + ")")
                .transition()
                .duration(this.duration)
                .call(this._xAxisCall);
        };
        AdaptStackedChartComponent.prototype._drawAxisXForColumn = function (g, dim) {
            var _this_1 = this;
            var axisWidth = dim.w - this._margin.left - this._margin.right;
            setTimeout(function () {
                var axisXTitleBlock = g.select("." + _this_1._cls.axisXTitle);
                axisXTitleBlock.remove();
                _this_1._drawAxisTitle(g, dim, _this_1.xAxis.title);
            }, this.duration + 100);
            this._xScale = d3__namespace.scaleBand();
            this._xScale
                .range([0, axisWidth])
                .padding(0.25)
                .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
            this._xAxisCall = d3__namespace.axisBottom(this._xScale)
                .tickFormat(lodashEs.isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
                .tickSizeOuter(0)
                .tickPadding(12);
            this.chartComponent.updateChartBottomPadding(axisWidth, this._g, this.xAxis, this.rotateXAxis);
            var axisBlock = g.append('g')
                .attr('role', 'title')
                .attr('class', this._cls.axis + " " + this._cls.colXAxis + " " + (this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''))
                .attr('transform', "translate(" + this._margin.left + ", " + (dim.h - this._margin.bottom) + ")");
            axisBlock
                .call(this._xAxisCall);
            if (this.rotateXAxis) {
                setTimeout(function () {
                    _this_1.chartComponent.transformAxisTitles(axisBlock, _this_1.rotateXAxis);
                    if (!_this_1.hideAxises) {
                        axisBlock.classed(_this_1._cls.axisHidden, null);
                    }
                }, this.duration);
            }
        };
        AdaptStackedChartComponent.prototype._drawAxisXForArea = function (g, dim) {
            var _this_1 = this;
            var axisWidth = dim.w - this._margin.left - this._margin.right;
            setTimeout(function () {
                var axisXTitleBlock = g.select("." + _this_1._cls.axisXTitle);
                axisXTitleBlock.remove();
                _this_1._drawAxisTitle(g, dim, _this_1.xAxis.title);
            }, this.duration + 100);
            this._xScale = d3__namespace.scalePoint()
                .range([0, this._dim.w - this._margin.left - this._margin.right])
                .domain(this.xAxis.categories);
            this._xAxisCall = d3__namespace.axisBottom(this._xScale)
                .tickFormat(lodashEs.isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
                .tickSizeOuter(0)
                .tickPadding(12);
            this.chartComponent.updateChartBottomPadding(axisWidth, this._g, this.xAxis, this.rotateXAxis);
            var axisBlock = g.append('g')
                .attr('role', 'title')
                .attr('class', this._cls.axis + " " + this._cls.colXAxis + " " + (this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''))
                .attr('transform', "translate(" + this._margin.left + ", " + (dim.h - this._margin.bottom) + ")");
            axisBlock
                .call(this._xAxisCall);
            if (this.rotateXAxis) {
                setTimeout(function () {
                    _this_1.chartComponent.transformAxisTitles(axisBlock, _this_1.rotateXAxis);
                    if (!_this_1.hideAxises) {
                        axisBlock.classed(_this_1._cls.axisHidden, null);
                    }
                }, this.duration);
            }
        };
        AdaptStackedChartComponent.prototype._drawAxisY = function (g, dim) {
            switch (this.type) {
                case exports.AdaptStackedChartType.Bar: {
                    this._drawAxisYForBar(g, dim);
                    break;
                }
                case exports.AdaptStackedChartType.Column: {
                    this._drawAxisYForColumn(g, dim);
                    break;
                }
                case exports.AdaptStackedChartType.Area: {
                    this._drawAxisYForColumn(g, dim);
                    break;
                }
            }
        };
        AdaptStackedChartComponent.prototype._drawAxisYForBar = function (g, dim) {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _self = this;
            this._drawAxisTitle(g, dim, this.yAxis.title);
            this._yScale = d3__namespace.scaleBand()
                .rangeRound([0, dim.h - this._margin.top - this._margin.bottom])
                .padding(0.25)
                .domain(this.xAxis.categories);
            this._yAxisCall = d3__namespace
                .axisLeft(this._yScale)
                .tickSizeOuter(0)
                .tickFormat(function (d) {
                return _self._getTickFormatForString(d, this);
            });
            g.append('g')
                .attr('role', 'axis')
                .attr('class', this._cls.axis + " " + this._cls.barYAxis + " " + (this.hideAxises ? this._cls.axisHidden : ''))
                .attr('transform', "translate(" + this._margin.left + ", 0)")
                .transition()
                .duration(this.duration)
                .call(this._yAxisCall);
        };
        AdaptStackedChartComponent.prototype._drawAxisYForColumn = function (g, dim) {
            var _this_1 = this;
            var ticks = this._getTicks().reverse();
            this._drawAxisTitle(g, dim, this.yAxis.title, true);
            this._yScale = d3__namespace.scaleLinear()
                .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
                .domain([ticks[0], 0]);
            this._yAxisCall = d3__namespace.axisLeft(this._yScale)
                .tickValues(ticks)
                .tickPadding(8)
                .tickFormat(function (d) { return _this_1._getTickFormatForNumber(d); })
                .tickSize(-dim.w + this._margin.left + this._margin.right);
            g.append('g')
                .attr('role', 'axis')
                .attr('class', this._cls.axis + " " + this._cls.colYAxis + " " + (this.hideAxises ? this._cls.axisHidden : ''))
                .attr('transform', "translate(" + this._margin.left + ", 0)")
                .transition()
                .duration(this.duration)
                .call(this._yAxisCall);
        };
        AdaptStackedChartComponent.prototype._drawData = function (g) {
            switch (this.type) {
                case exports.AdaptStackedChartType.Bar: {
                    this._drawDataBars(g);
                    break;
                }
                case exports.AdaptStackedChartType.Column: {
                    this._drawDataColumns(g);
                    break;
                }
                case exports.AdaptStackedChartType.Area: {
                    this._drawDataArea(g);
                    break;
                }
            }
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype._drawDataBars = function (g) {
            var _this_1 = this;
            var baseColor;
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _this = this;
            this._bars = g.append('g')
                .attr('role', 'data')
                .selectAll('g')
                .data(d3__namespace.stack().keys(this._keys)(this._data));
            var _xScale = this._xScale;
            this._bars
                .enter()
                .append('g')
                .attr('data-category-id', function (d, i) { return i; })
                .attr('role', 'group')
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('aria-label', function (d, i) {
                return _this.series[i].name;
            })
                .attr('class', function (d, i) { return "category-" + i; })
                .attr('class', this._cls.category)
                .attr('fill', function (d) { return _this_1._ordinal(d.key); })
                .selectAll('rect')
                .data(function (d) { return d; })
                .enter()
                .append('rect')
                .attr('class', this._cls.dataRect)
                .attr('role', 'item')
                .attr('data-id', function (d, id) { return id; })
                .attr('x', function (d) { return _xScale(d[0]) + _this_1._margin.left + 1; })
                .attr('y', function (d) { return _this_1._getBarYPosition(d.data.name); })
                .attr('width', function (d) { return _xScale(d[1]) - _xScale(d[0]) === 0 ? _this_1.heightZero : _xScale(d[1]) - _xScale(d[0]); })
                .attr('height', this.barWidth ? this.barWidth : this._yScale.bandwidth())
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .on('mouseenter', function (d) {
                var target = d3__namespace.event.target;
                var categoryId = target.parentNode.getAttribute('data-category-id');
                _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipTemplate, {
                    data: {
                        color: baseColor,
                        category: _this.series[categoryId].name,
                        value: _this._dividePoints(d[0], d[1]),
                        total: _this._totalByCol[d.data.name],
                        data: _this.series[categoryId],
                        event: d3__namespace.event
                    }
                });
            })
                .on('mouseleave', function () {
                var rect = d3__namespace.select(this);
                _this.chartComponent.hideTooltip();
                rect.attr('fill', null);
            })
                .on('mouseover', function () {
                var self = d3__namespace.select(this);
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                baseColor = self.select(function () {
                    return this.parentNode;
                }).attr('fill');
                var darkenColor = _this._colorService.getDarken(baseColor, .15, i1.ColorType.HEX);
                self.attr('fill', darkenColor);
            });
            if (this.showEmptyColIndicator) {
                // check for the bar(s) with no data
                var zeroBars = Object.keys(this._totalByCol).filter(function (key) { return _this_1._totalByCol[key] === 0; });
                // indicate bar with no data
                zeroBars.forEach(function (bar) {
                    var colYPos = _this_1._yScale(bar) - _this_1._margin.top;
                    var yAttr = colYPos + _this_1._yScale.bandwidth() / 2 - _this_1._emptyColIndicatorHeight / 2;
                    var xAttr = _this_1._margin.left + DEFAULT_MARGIN;
                    _this_1._drawEmptyDataIndicator(xAttr, yAttr, bar);
                });
            }
            this._bars.exit().remove();
        };
        AdaptStackedChartComponent.prototype._getBarYPosition = function (d) {
            return this.barWidth
                ? this._yScale(d) + this._margin.top + (this._yScale.bandwidth() / 2) - (this.barWidth / 2)
                : this._yScale(d) + this._margin.top;
        };
        AdaptStackedChartComponent.prototype._getWidthForColumn = function () {
            return this.barWidth
                ? this.barWidth
                : this.isHorizontalSeries
                    ? this._xScale.bandwidth() / this.series.length
                    : this._xScale.bandwidth();
        };
        AdaptStackedChartComponent.prototype._getColumnYPosForHorizontalSeries = function (d) {
            return this._yScale(d[0] ? d[1] - d[0] : d[1]);
        };
        AdaptStackedChartComponent.prototype._dividePoints = function (a, b) {
            return this.scientificMode
                ? new BigNumber__default["default"](b).minus(a).toString()
                : Number((b - a).toFixed(6)).toString();
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype._getColumnXPos = function (d, node) {
            var xPos = this._xScale(d) + this._margin.left;
            if (this.isHorizontalSeries) {
                if (this.barWidth) {
                    return xPos
                        // Based on category index calculate offset for each bar
                        + (this._getCurrentCategoryIndex(node) - (this.series.length / 2)) * this._getWidthForColumn()
                        + (this._xScale.bandwidth() / 2);
                }
                else {
                    return xPos + (this._getCurrentCategoryIndex(node) * this._getWidthForColumn());
                }
            }
            else {
                return this.barWidth
                    ? xPos + (this._xScale.bandwidth() / 2) - (this._getWidthForColumn() / 2)
                    : xPos;
            }
        };
        AdaptStackedChartComponent.prototype._getColumnYPos = function (d) {
            return this.isHorizontalSeries ?
                this._getColumnYPosForHorizontalSeries(d) :
                this._yScale(d[1]);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype._setYPos = function (d) {
            if (this._yScale(0) - this._getColumnYPosForHorizontalSeries(d) === 0) {
                return this._getColumnYPos(d) - this.heightZero;
            }
            else {
                return this._getColumnYPos(d);
            }
        };
        AdaptStackedChartComponent.prototype._setRectPositionAndScaleForColumnsType = function (selection) {
            var _this_1 = this;
            return selection
                .attr('x', function (d, i, groups) { return _this_1._getColumnXPos(d.data.name, groups[i]); })
                .attr('y', function (d) { return _this_1._setYPos(d); })
                .attr('height', function (d) { return _this_1.isHorizontalSeries ?
                (_this_1._yScale(0) - _this_1._getColumnYPosForHorizontalSeries(d) === 0 ?
                    _this_1.heightZero : _this_1._yScale(0) - _this_1._getColumnYPosForHorizontalSeries(d)) :
                (_this_1._yScale(d[0]) - _this_1._yScale(d[1]) === 0) ? _this_1.heightZero : _this_1._yScale(d[0]) - _this_1._yScale(d[1]); })
                .attr('width', function () { return _this_1._getWidthForColumn(); });
        };
        AdaptStackedChartComponent.prototype._drawDataColumns = function (g) {
            var _this_1 = this;
            var baseColor;
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _this = this;
            this._bars = g.append('g')
                .attr('role', 'data')
                .selectAll('g')
                .data(d3__namespace.stack().keys(this._keys)(this._data));
            var gContainer = this._bars
                .enter()
                .append('g')
                .attr('data-category-id', function (d, i) { return i; })
                .attr('role', 'group')
                .attr('aria-label', function (d, i) { return _this_1.series[i].name; })
                .attr('fill', function (d) { return _this_1._ordinal(d.key); })
                .attr('class', this._cls.category)
                .selectAll('rect')
                .data(function (d) { return d; })
                .enter();
            var selection = gContainer
                .append('rect')
                .attr('class', this._cls.dataRect)
                .attr('role', 'item')
                .attr('aria-label', function (d) { return d.data.name + ".: " + _this_1._dividePoints(d[0], d[1]); })
                .attr('data-id', function (d, id) { return id; });
            selection = this._setRectPositionAndScaleForColumnsType(selection);
            if (this.showEmptyColIndicator) {
                // check for the column(s) with no data
                var zeroCols = Object.keys(this._totalByCol).filter(function (key) { return _this_1._totalByCol[key] === 0; });
                // indicate column with no data
                zeroCols.forEach(function (col) {
                    var colXPos = _this_1._xScale(col) + _this_1._margin.left;
                    var xAttr = colXPos + _this_1._xScale.bandwidth() / 2 - _this_1._emptyColIndicatorWidth / 2;
                    var yAttr = _this_1._dim.h - _this_1._margin.bottom - _this_1._emptyColIndicatorHeight - DEFAULT_MARGIN;
                    _this_1._drawEmptyDataIndicator(xAttr, yAttr, col);
                });
            }
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            selection.on('mouseenter', function (d) {
                var target = d3__namespace.event.target;
                var sv = 0;
                var i = 0;
                var keys = Object.keys(d.data).filter(function (k) { return k !== 'name'; });
                for (i; i < keys.length; i++) {
                    if (d[0] === sv && d[1] === sv + d.data[keys[i]]) {
                        break;
                    }
                    else {
                        sv += d.data[keys[i]];
                    }
                }
                _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipTemplate, {
                    data: {
                        color: baseColor,
                        category: keys[i],
                        value: _this._dividePoints(d[0], d[1]),
                        total: _this._totalByCol[d.data.name],
                        data: _this.series.filter(function (r) { return r.name === keys[i]; }),
                        event: d3__namespace.event
                    }
                });
            })
                .on('mouseleave', function () {
                var self = d3__namespace.select(this);
                _this.chartComponent.hideTooltip();
                self.attr('fill', null);
            })
                .on('mouseover', function () {
                var self = d3__namespace.select(this);
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                baseColor = self.select(function () {
                    return this.parentNode;
                }).attr('fill');
                var darkenColor = _this._colorService.getDarken(baseColor, .15, i1.ColorType.HEX);
                self.attr('fill', darkenColor);
            });
            this._addTotalLabels(g);
            this._bars.exit().remove();
        };
        AdaptStackedChartComponent.prototype._drawDataArea = function (g) {
            var _this_1 = this;
            var series = d3__namespace.stack().keys(this._keys)(this._data);
            var ticks = this._getTicks();
            this._xScale = d3__namespace.scalePoint();
            this._xScale
                .range([this._margin.left + this._margin.right, this._dim.w])
                .domain(this.xAxis.categories);
            this._yScale = d3__namespace.scaleLinear();
            this._yScale
                .rangeRound([0, this._dim.h - this._margin.bottom - this._margin.top])
                .domain([ticks[ticks.length - 1], 0]);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var area = d3__namespace.area()
                .x(function (d, i) { return _this_1._xScale(_this_1.xAxis.categories[i]); })
                .y0(function (d) { return _this_1._yScale(d[0]); })
                .y1(function (d) { return _this_1._yScale(d[1]); });
            g.append('g')
                .attr('class', this._cls.areaGroup)
                .selectAll('path')
                .data(series)
                .join('path')
                .attr('data-category-id', function (d, i) { return i; })
                .attr('aria-label', function (d, i) { return _this_1.series[i].name; })
                .attr('fill', function (d) { return _this_1._ordinal(d.key); })
                .attr('class', this._cls.category)
                .attr('d', area);
            this._g.selectAll("." + this._cls.areaTooltipLines).remove();
            this._drawTooltipLinesForArea(g, this._dim);
        };
        AdaptStackedChartComponent.prototype._drawTooltipLinesForArea = function (g, dim) {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _this = this;
            var _xScale = d3__namespace.scalePoint()
                .range([0, dim.w - this._margin.left - this._margin.right])
                .domain(this.xAxis.categories);
            var _xAxisCall = d3__namespace.axisBottom(_xScale)
                .tickSize(-dim.h + this._margin.top + this._margin.bottom)
                .tickPadding(0);
            var areaBlock = g.append('g')
                .attr('role', 'axis')
                .attr('class', this._cls.colYAxis + " " + this._cls.areaTooltipLines)
                .attr('transform', "translate(" + this._margin.left + ", " + (dim.h - this._margin.top - this._margin.bottom) + ")");
            areaBlock.transition().duration(this.duration).call(_xAxisCall);
            areaBlock.select('path').attr('opacity', 0);
            areaBlock.selectAll('g text').remove();
            areaBlock.selectAll('g line').attr('opacity', 0);
            areaBlock
                .selectAll('g')
                .append('rect')
                .attr('pointer-events', 'all')
                .attr('width', 20)
                .attr('height', dim.h - this._margin.top - this._margin.bottom)
                .attr('x', -10)
                .attr('y', -dim.h + this._margin.top + this._margin.bottom)
                .on('mouseover', function (category) {
                var parent = d3__namespace.select(this.parentNode);
                parent.select('line').attr('opacity', 1);
                var target = d3__namespace.event.target;
                _this.chartComponent.showTooltip(target, _this.tooltip || _this.tooltipListInfoTemplate, { data: _this.getFormattedSeries({ category: category, series: _this._data, event: d3__namespace.event }) }, null, null, true);
            })
                .on('mouseout', function () {
                var parent = d3__namespace.select(this.parentNode);
                parent.select('line').attr('opacity', 0);
                _this.chartComponent.hideTooltip();
            });
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype._addTotalLabels = function (g) {
            var labelsGroup = g.append('g')
                .attr('class', this._cls.totalLabelsGroup)
                .attr('opacity', this.hasTotalLabels ? '1' : '0')
                .attr('text-anchor', 'middle');
            this._createTotalLabelsGroupsItems(labelsGroup);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype._createTotalLabelsGroupsItems = function (labelsGroup) {
            var _this_1 = this;
            labelsGroup
                .selectAll("g." + this._cls.totalLabelsGroupItem)
                .data(this._getTotalLabelsData())
                .enter()
                .append('g')
                .attr('class', this._cls.totalLabelsGroupItem)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('opacity', function (d) { return _this_1._getTotalLabelGroupOpacity(d); })
                .selectAll('g')
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .data(function (d) { return d; })
                .enter()
                .append('g')
                .attr('class', this._cls.totalLabelItem)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', function (d, i, groups) { return _this_1._getTotalLabelTransform(d, groups[i]); })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .append('text').text(function (d) { return _this_1._getTotalLabelText(d); })
                .attr('fill', 'currentColor')
                .exit().remove();
        };
        AdaptStackedChartComponent.prototype._getTotalLabelGroupOpacity = function (d) {
            return (!this.isHorizontalSeries || this._categoryFilter.indexOf(d.key) === -1) ? '1' : '0';
        };
        AdaptStackedChartComponent.prototype._getTotalLabelText = function (d) {
            var value = this.isHorizontalSeries ? d[1] - d[0] : this._totalByCol[d.data.name];
            if (this.totalLabelTextFormatter) {
                return this.totalLabelTextFormatter(value, d);
            }
            return value;
        };
        AdaptStackedChartComponent.prototype._getTotalLabelTransform = function (d, swg) {
            return "translate(" + (this._getColumnXPos(d.data.name, swg) + this._getWidthForColumn() / 2) + ", " + (this._getColumnYPos(d) - 9) + ")";
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype._getTotalLabelsData = function () {
            var labelsDataArr = d3__namespace.stack().keys(this._keys)(this._data);
            return this.isHorizontalSeries ?
                labelsDataArr :
                labelsDataArr.splice(-1);
        };
        AdaptStackedChartComponent.prototype._getCurrentCategoryIndex = function (group) {
            return d3__namespace.select(group.parentNode).datum().index;
        };
        AdaptStackedChartComponent.prototype._getTicks = function () {
            var _this_1 = this;
            var data = this._dataFull.map(function (row) {
                var keys = Object.keys(row)
                    .filter(function (key) { return key !== 'name'; });
                return _this_1.isHorizontalSeries ? Math.max.apply(Math, __spreadArray([], __read(keys.map(function (key) { return row[key]; })))) : keys.reduce(function (acc, value) {
                    return acc + row[value];
                }, 0);
            });
            var max = Math.max.apply(Math, __spreadArray([], __read(data)));
            if (max === 0) {
                max = 1;
            }
            if (this.thresholdLine && this.thresholdLine > max) {
                max = this.thresholdLine;
            }
            var currentStep = Math.pow(10, Math.floor(Math.log10(max))) / 2;
            var step = Math.pow(10, Math.floor(Math.log10(max))) / 2;
            var count = Math.floor(max / currentStep) + 1;
            while (count >= this._maxTicksCount) {
                currentStep += step;
                count = Math.floor(max / currentStep) + 1;
            }
            return (new Array(count)).fill(0).map(function (v, id) { return (id + 1) * currentStep; });
        };
        AdaptStackedChartComponent.prototype._clear = function () {
            this.chartComponent.clear();
            this._data = [];
        };
        AdaptStackedChartComponent.prototype._updateData = function () {
            var _this_1 = this;
            switch (this.type) {
                case exports.AdaptStackedChartType.Bar: {
                    var _xScale_1 = this._xScale;
                    this._g
                        .selectAll("." + this._cls.category)
                        .data(d3__namespace.stack().keys(this._keys)(this._data))
                        .selectAll('rect')
                        .data(function (d) { return d; })
                        .attr('y', function (d) { return _this_1._yScale(d.data.name) + (_this_1.barWidth ? Math.floor(_this_1._yScale.bandwidth() / 2 - _this_1.barWidth / 2) : 0) + _this_1._margin.top; })
                        .attr('height', this.barWidth || this._yScale.bandwidth())
                        .transition()
                        .duration(this.duration)
                        .attr('width', function (d) { return _xScale_1(d[1]) - _xScale_1(d[0]); })
                        .attr('x', function (d) { return _xScale_1(d[0]) + _this_1._margin.left + 1; });
                    break;
                }
                case exports.AdaptStackedChartType.Column: {
                    var selection = this._g
                        .selectAll("." + this._cls.category)
                        .data(d3__namespace.stack().keys(this._keys)(this._data))
                        .selectAll('rect')
                        .data(function (d) { return d; })
                        .transition()
                        .duration(this.duration);
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    this._setRectPositionAndScaleForColumnsType(selection);
                    if (this.showEmptyColIndicator) {
                        /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                        var _self_1 = this;
                        var emptyDataIndicatorLists = this._g.selectAll('g[class="tick empty-column"]');
                        emptyDataIndicatorLists.each(function () {
                            var elem = d3__namespace.select(this);
                            var col = elem.attr('aria-column');
                            var colXPos = _self_1._xScale(col) + _self_1._margin.left;
                            var xAttr = colXPos + _self_1._xScale.bandwidth() / 2 - _self_1._emptyColIndicatorWidth / 2;
                            var yAttr = _self_1._dim.h - _self_1._margin.bottom - _self_1._emptyColIndicatorHeight - DEFAULT_MARGIN;
                            elem.transition().duration(_self_1.duration).attr('transform', "translate(" + xAttr + ", " + yAttr + ")");
                        });
                    }
                    break;
                }
                case exports.AdaptStackedChartType.Area: {
                    this._g.selectAll("." + this._cls.areaGroup).remove();
                    this._drawDataArea(this._g);
                    break;
                }
            }
            var totalsGroup = this._g
                .selectAll("." + this._cls.totalLabelsGroup);
            totalsGroup.transition()
                .duration(this.duration)
                .attr('opacity', this.hasTotalLabels ? '1' : '0');
            if (this.hasTotalLabels) {
                var groupsItems = totalsGroup
                    .selectAll("." + this._cls.totalLabelsGroupItem)
                    .data(this._getTotalLabelsData());
                groupsItems.exit().remove();
                this._createTotalLabelsGroupsItems(totalsGroup);
                groupsItems
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    .attr('opacity', function (d) { return _this_1._getTotalLabelGroupOpacity(d); })
                    .selectAll("." + this._cls.totalLabelItem)
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    .data(function (d) { return d; })
                    .transition()
                    .duration(this.duration)
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    .attr('transform', function (d, i, groups) { return _this_1._getTotalLabelTransform(d, groups[i]); })
                    .selectAll('text')
                    .text(function (d) { return _this_1._getTotalLabelText(d); });
            }
        };
        AdaptStackedChartComponent.prototype._updateThresholdLineArea = function () {
            var _this_1 = this;
            var thresholdLineArea = this._g.select("." + this._cls.thresholdLineArea);
            if (!this.thresholdLine) {
                thresholdLineArea.remove();
                return;
            }
            if (thresholdLineArea.empty()) {
                thresholdLineArea = this._g.append('g')
                    .attr('class', this._cls.thresholdLineArea);
                thresholdLineArea.append('rect')
                    .attr('class', 'threshold-area-rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('fill', '#000000')
                    .attr('style', 'pointer-events: none; opacity: .1;');
                var defs = thresholdLineArea.append('defs');
                defs.append('marker')
                    .attr('class', 'threshold-line-marker')
                    .attr('id', this._id + "-marker-start")
                    .attr('viewBox', '0 0 6 8')
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 8)
                    .attr('refX', 5)
                    .attr('refY', 4)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M 0 0 L 6 4 L 0 8 z');
                defs.append('marker')
                    .attr('class', 'threshold-line-marker')
                    .attr('id', this._id + "-marker-end")
                    .attr('viewBox', '0 0 6 8')
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 8)
                    .attr('refX', 1)
                    .attr('refY', 4)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M 0 4 L 6 0 L 6 8 z');
                thresholdLineArea.append('line')
                    .attr('class', 'threshold-line')
                    .attr('stroke-width', 1)
                    .attr('marker-start', "url(#" + this._id + "-marker-start)")
                    .attr('marker-end', "url(#" + this._id + "-marker-end)");
                thresholdLineArea.append('text')
                    .attr('class', 'threshold-line-title-background');
                thresholdLineArea.append('text')
                    .attr('class', 'threshold-line-title');
            }
            var maxTick = this._getTicks().pop(); // get the max tick
            var chartDataAreaWidth = this._dim.w - this._margin.left - this._margin.right;
            var chartDataAreaHeight = this._dim.h - this._margin.top - this._margin.bottom;
            switch (this.type) {
                case exports.AdaptStackedChartType.Bar: {
                    var thresholdLineAreaWidth = chartDataAreaWidth - chartDataAreaWidth / maxTick * this.thresholdLine;
                    var thresholdLineAreaLeftShift = this._margin.left + chartDataAreaWidth - thresholdLineAreaWidth;
                    thresholdLineArea.select('rect.threshold-area-rect')
                        .transition()
                        .duration(this.duration)
                        .attr('transform', "translate(" + thresholdLineAreaLeftShift + ", 0)")
                        .attr('width', thresholdLineAreaWidth)
                        .attr('height', chartDataAreaHeight);
                    thresholdLineArea.select('line.threshold-line')
                        .transition()
                        .duration(this.duration)
                        .attr('x1', thresholdLineAreaLeftShift)
                        .attr('x2', thresholdLineAreaLeftShift)
                        .attr('y1', this._margin.top)
                        .attr('y2', this._margin.top + chartDataAreaHeight);
                    thresholdLineArea.select('text.threshold-line-title-background')
                        .transition()
                        .duration(this.duration)
                        .attr('x', thresholdLineAreaLeftShift)
                        .attr('y', this._margin.top + chartDataAreaHeight)
                        .attr('text-anchor', 'middle')
                        .attr('dy', '24')
                        .text(this.scientificMode ? new BigNumber__default["default"](this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                    thresholdLineArea.select('text.threshold-line-title')
                        .transition()
                        .duration(this.duration)
                        .attr('x', thresholdLineAreaLeftShift)
                        .attr('y', this._margin.top + chartDataAreaHeight)
                        .attr('text-anchor', 'middle')
                        .attr('dy', '24')
                        .text(this.scientificMode ? new BigNumber__default["default"](this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                    break;
                }
                case exports.AdaptStackedChartType.Column:
                case exports.AdaptStackedChartType.Area: {
                    var thresholdLineAreaHeight = chartDataAreaHeight - chartDataAreaHeight / maxTick * this.thresholdLine;
                    thresholdLineArea.select('rect.threshold-area-rect')
                        .transition()
                        .duration(this.duration)
                        .attr('transform', "translate(" + this._margin.left + ", 0)")
                        .attr('width', chartDataAreaWidth)
                        .attr('height', thresholdLineAreaHeight);
                    thresholdLineArea.select('line.threshold-line')
                        .transition()
                        .duration(this.duration)
                        .attr('x1', this._margin.left)
                        .attr('x2', this._dim.w)
                        .attr('y1', thresholdLineAreaHeight)
                        .attr('y2', thresholdLineAreaHeight);
                    thresholdLineArea.select('text.threshold-line-title-background')
                        .transition()
                        .duration(this.duration)
                        .attr('x', this._margin.left - 8)
                        .attr('y', thresholdLineAreaHeight)
                        .attr('text-anchor', 'end')
                        .attr('dy', '.32em')
                        .text(this.scientificMode ? new BigNumber__default["default"](this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                    thresholdLineArea.select('text.threshold-line-title')
                        .transition()
                        .duration(this.duration)
                        .attr('x', this._margin.left - 8)
                        .attr('y', thresholdLineAreaHeight)
                        .attr('text-anchor', 'end')
                        .attr('dy', '.32em')
                        .text(this.scientificMode ? new BigNumber__default["default"](this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                    break;
                }
            }
            // If we have the same tick as the thresholdLine - remove that
            d3__namespace.selectAll('g.tick')
                .filter(function (d) { return d === _this_1.thresholdLine; })
                .remove();
        };
        AdaptStackedChartComponent.prototype._drawAxisTitle = function (g, dim, text, rotate) {
            if (rotate === void 0) { rotate = false; }
            if (!i1.isString(text) || this.hideAxises) {
                return;
            }
            var translate;
            var axisTitle = g.append('g')
                .attr('class', this._cls.axisTitle + " " + (rotate ? this._cls.axisYTitle : this._cls.axisXTitle))
                .attr('role', 'title');
            if (rotate) {
                translate = "rotate(-90) translate(-" + (dim.h - this._axisTitleThickness) / 2 + " " + this._axisTitleThickness / 2 + ")";
            }
            else {
                translate = "translate(" + (dim.w + this._axisTitleThickness) / 2 + " " + (dim.h + this.chartComponent.chartBottomPadding) + ")";
            }
            axisTitle
                .attr('transform', translate)
                .append('text')
                .text(text)
                .attr('text-anchor', 'middle')
                .attr('transform', "translate(" + (this._axisTitleThickness / (rotate ? 2 : 1)) + " 0)");
        };
        AdaptStackedChartComponent.prototype._updateAxisTitle = function (g, dim) {
            g.select("." + this._cls.axisXTitle)
                .transition()
                .duration(this.duration)
                .attr('transform', "translate(" + (dim.w + this._axisTitleThickness) / 2 + " " + (dim.h + this.chartComponent.chartBottomPadding) + ")");
        };
        /* Update X Axis */
        AdaptStackedChartComponent.prototype._updateAxisX = function (dim) {
            switch (this.type) {
                case exports.AdaptStackedChartType.Bar: {
                    this._updateAxisXForBar(dim);
                    break;
                }
                case exports.AdaptStackedChartType.Column: {
                    this._updateAxisXForColumn(dim);
                    break;
                }
                case exports.AdaptStackedChartType.Area: {
                    this._updateAxisXForArea(dim);
                    break;
                }
            }
        };
        AdaptStackedChartComponent.prototype._updateAxisXForBar = function (dim) {
            var _this_1 = this;
            var ticks = this._getTicks().reverse();
            this._xScale = d3__namespace.scaleLinear();
            this._xScale.rangeRound([dim.w - this._margin.left - this._margin.right, 0]).domain([ticks[0], 0]);
            this._xAxisCall = d3__namespace.axisBottom(this._xScale)
                .tickValues(ticks)
                .tickSize(-dim.h + this._margin.top + this._margin.bottom)
                .tickFormat(function (d, i) { return lodashEs.isFunction(_this_1.xAxisTickFormatResolver) ? _this_1.xAxisTickFormatResolver(d, i) : _this_1._getTickFormatForNumber(d); })
                .tickPadding(15);
            this._g.select("." + this._cls.barXAxis)
                .transition()
                .duration(this.duration)
                .call(this._xAxisCall);
        };
        AdaptStackedChartComponent.prototype._updateAxisXForColumn = function (dim) {
            var _this_1 = this;
            this._xScale = d3__namespace.scaleBand();
            this._xScale
                .range([0, dim.w - this._margin.left - this._margin.right])
                .padding(0.25)
                .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
            this._xAxisCall = d3__namespace.axisBottom(this._xScale)
                .tickFormat(lodashEs.isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
                .tickSizeOuter(0)
                .tickPadding(12);
            this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
            var axisBlock = this._g.select("." + this._cls.colXAxis)
                .attr('class', this._cls.axis + " " + this._cls.colXAxis + " " + (this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''));
            axisBlock
                .transition()
                .duration(this.duration)
                .call(this._xAxisCall);
            setTimeout(function () {
                _this_1.chartComponent.transformAxisTitles(axisBlock, _this_1.rotateXAxis);
                if (!_this_1.hideAxises) {
                    axisBlock.classed(_this_1._cls.axisHidden, null);
                }
            }, this.rotateXAxis ? this.duration + 100 : 0);
            this._updateAxisTitle(this._g, dim);
        };
        AdaptStackedChartComponent.prototype._updateAxisXForArea = function (dim) {
            var _this_1 = this;
            this._xScale = d3__namespace.scalePoint();
            this._xScale
                .range([0, dim.w - this._margin.left - this._margin.right])
                .domain(this.showSlider ? this.xAxis.categories.slice(this._startDataPiece, this._endDataPiece) : this.xAxis.categories);
            this._xAxisCall = d3__namespace.axisBottom(this._xScale)
                .tickFormat(lodashEs.isFunction(this.xAxisTickFormatResolver) ? this.xAxisTickFormatResolver : null)
                .tickSizeOuter(0)
                .tickPadding(12);
            this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
            var axisBlock = this._g.select("." + this._cls.colXAxis)
                .attr('class', this._cls.axis + " " + this._cls.colXAxis + " " + (this.hideAxises || this.rotateXAxis ? this._cls.axisHidden : ''));
            axisBlock
                .transition()
                .duration(this.duration)
                .call(this._xAxisCall);
            setTimeout(function () {
                _this_1.chartComponent.transformAxisTitles(axisBlock, _this_1.rotateXAxis);
                if (!_this_1.hideAxises) {
                    axisBlock.classed(_this_1._cls.axisHidden, null);
                }
            }, this.rotateXAxis ? this.duration + 100 : 0);
            this._updateAxisTitle(this._g, dim);
        };
        /* Update Y Axis */
        AdaptStackedChartComponent.prototype._updateAxisY = function (dim) {
            switch (this.type) {
                case exports.AdaptStackedChartType.Bar: {
                    this._updateAxisYForBar(dim);
                    break;
                }
                case exports.AdaptStackedChartType.Column: {
                    this._updateAxisYForColumn(dim);
                    break;
                }
                case exports.AdaptStackedChartType.Area: {
                    this._updateAxisYForColumn(dim);
                    break;
                }
            }
        };
        AdaptStackedChartComponent.prototype._updateAxisYForBar = function (dim) {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _self = this;
            this._yScale = d3__namespace.scaleBand()
                .rangeRound([0, dim.h - this._margin.top - this._margin.bottom])
                .padding(0.25)
                .domain(this.xAxis.categories);
            this._yAxisCall = d3__namespace
                .axisLeft(this._yScale)
                .tickSizeOuter(0)
                .tickFormat(function (d) {
                return _self._getTickFormatForString(d, this);
            });
            this._g.select("." + this._cls.barYAxis)
                .transition()
                .duration(this.duration)
                .call(this._yAxisCall);
        };
        AdaptStackedChartComponent.prototype._updateAxisYForColumn = function (dim) {
            var _this_1 = this;
            var ticks = this._getTicks().reverse();
            this._yScale = d3__namespace.scaleLinear()
                .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
                .domain([ticks[0], 0]);
            this._yAxisCall = d3__namespace.axisLeft(this._yScale)
                .tickValues(ticks)
                .tickFormat(function (d) { return _this_1._getTickFormatForNumber(d); })
                .tickSize(-dim.w + this._margin.left + this._margin.right);
            this._g.select("." + this._cls.colYAxis)
                .transition()
                .duration(this.duration)
                .call(this._yAxisCall);
        };
        AdaptStackedChartComponent.prototype._getCustomColorById = function (id) {
            var customColors = this._legend.customColors;
            var len = customColors.length;
            var index = id % len;
            return customColors[index];
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype._getDataRange = function () {
            var _this_1 = this;
            return this.sliderData.map(function (item) {
                var name = item.name, hidden = item.hidden;
                var data = item.data;
                data = data.slice(_this_1._startDataPiece, _this_1._endDataPiece);
                return { name: name, data: data, hidden: hidden };
            });
        };
        AdaptStackedChartComponent.prototype._getDataLength = function () {
            return this._series[0].data.length;
        };
        AdaptStackedChartComponent.prototype._initSlidePointsCount = function () {
            var dataLength = this._getDataLength();
            if (dataLength < 12) {
                this.slidePointsCount = 4;
            }
            else if (dataLength >= 12 && dataLength < 36) {
                this.slidePointsCount = 6;
            }
            else {
                this.slidePointsCount = 12;
            }
            this.sliderMonitorsCount = Math.ceil(dataLength / this.slidePointsCount);
        };
        /* empty data indicator */
        AdaptStackedChartComponent.prototype._drawEmptyDataIndicator = function (x, y, column) {
            var emptyGroupInfo = this._g.select('g[role="data"]')
                .append('g')
                .attr('role', 'group')
                .attr('class', 'tick empty-column')
                .attr('aria-label', 'empty column')
                .attr('aria-column', column)
                .attr('transform', "translate(" + x + ", " + y + ")");
            emptyGroupInfo.append('rect')
                .attr('role', 'item')
                .attr('width', this._emptyColIndicatorWidth)
                .attr('height', this._emptyColIndicatorHeight)
                .attr('rx', 2);
            emptyGroupInfo.append('text')
                .attr('x', this._emptyColIndicatorWidth / 2)
                .attr('y', this._emptyColIndicatorHeight / 2)
                .attr('alignment-baseline', 'middle')
                .attr('text-anchor', 'middle')
                .attr('dy', '.1rem')
                .text('0');
        };
        AdaptStackedChartComponent.prototype._getTickFormatForNumber = function (d) {
            return this.scientificMode
                ? new BigNumber__default["default"](d).toPrecision(2, 2)
                : this._cutNumber.transform(d, 0);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptStackedChartComponent.prototype._getTickFormatForString = function (d, _this) {
            var _this_1 = this;
            var tickNode = d3__namespace.select(_this);
            var ellipsisText = textEllipsis(tickNode, d, this.xAxis ? (this.xAxis.thickness || this._axisXThickness) : 0);
            if (ellipsisText !== d) {
                tickNode
                    .on('mouseenter', function () {
                    var target = d3__namespace.event.target;
                    _this_1.chartComponent.showTooltip(target, d);
                })
                    .on('mouseleave', function () {
                    _this_1.chartComponent.hideTooltip();
                });
            }
            return ellipsisText;
        };
        return AdaptStackedChartComponent;
    }(AdaptStackedChartAbstract));
    AdaptStackedChartComponent.ɵfac = function AdaptStackedChartComponent_Factory(t) { return new (t || AdaptStackedChartComponent)(i0__namespace.ɵɵdirectiveInject(CutNumberPipe), i0__namespace.ɵɵdirectiveInject(ChartColorService)); };
    AdaptStackedChartComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptStackedChartComponent, selectors: [["adapt-stacked-chart"]], viewQuery: function AdaptStackedChartComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(_c0$6, 7);
                i0__namespace.ɵɵviewQuery(_c1$4, 7);
                i0__namespace.ɵɵviewQuery(AdaptChartComponent, 7);
                i0__namespace.ɵɵviewQuery(AdaptChartSliderComponent, 5);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.tooltipListInfoTemplate = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartSliderComponent = _t.first);
            }
        }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", type: "type", xAxis: "xAxis", yAxis: "yAxis", showSlider: "showSlider", hasTotalLabels: "hasTotalLabels", seriesDisplay: "seriesDisplay", totalLabelTextFormatter: "totalLabelTextFormatter", barWidth: "barWidth", slidePointsCount: "slidePointsCount", hideAxises: "hideAxises", rotateXAxis: "rotateXAxis", xAxisTickFormatResolver: "xAxisTickFormatResolver", scientificMode: "scientificMode", renderLegend: "renderLegend", thresholdLine: "thresholdLine", showEmptyColIndicator: "showEmptyColIndicator", series: "series", legend: "legend" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0__namespace.ɵɵProvidersFeature([CutNumberPipe]), i0__namespace.ɵɵInheritDefinitionFeature, i0__namespace.ɵɵNgOnChangesFeature], decls: 12, vars: 16, consts: [[3, "width", "title", "description", "height", "header", "legend", "renderLegend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "noDataText", "updateChart", "dataBuilder", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave", "clickChart"], ["chart", ""], [3, "slidePointsCount", "height", "xAxis", "data", "containerWidth", "customColors", "leftShift", "type", "stackedChart", "rangeChanged", 4, "ngIf"], ["tooltipTpl", ""], ["tooltipListInfoTpl", ""], [3, "slidePointsCount", "height", "xAxis", "data", "containerWidth", "customColors", "leftShift", "type", "stackedChart", "rangeChanged"], [1, "adapt-chart-tooltip-content-container"], [1, "adapt-chart-tooltip-color-spot"], [1, "adapt-chart-tooltip-category"], [1, "chart-tooltip-content-container", "align-start"], [4, "ngFor", "ngForOf"], [1, "mt-1", "mb-1"], [4, "ngIf"]], template: function AdaptStackedChartComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵtext(0, "\n    ");
                i0__namespace.ɵɵelementStart(1, "adapt-chart", 0, 1);
                i0__namespace.ɵɵlistener("categoryShow", function AdaptStackedChartComponent_Template_adapt_chart_categoryShow_1_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptStackedChartComponent_Template_adapt_chart_categoryHide_1_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptStackedChartComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx.categoryEnterHandler($event); })("categoryLeave", function AdaptStackedChartComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx.categoryLeaveHandler($event); })("clickChart", function AdaptStackedChartComponent_Template_adapt_chart_clickChart_1_listener($event) { return ctx.clickChartArea($event); });
                i0__namespace.ɵɵtext(3, "\n      ");
                i0__namespace.ɵɵtemplate(4, AdaptStackedChartComponent_adapt_chart_slider_4_Template, 1, 9, "adapt-chart-slider", 2);
                i0__namespace.ɵɵtext(5, "\n    ");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(6, "\n\n    ");
                i0__namespace.ɵɵtemplate(7, AdaptStackedChartComponent_ng_template_7_Template, 23, 5, "ng-template", null, 3, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(9, "\n    ");
                i0__namespace.ɵɵtemplate(10, AdaptStackedChartComponent_ng_template_10_Template, 15, 2, "ng-template", null, 4, i0__namespace.ɵɵtemplateRefExtractor);
            }
            if (rf & 2) {
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵproperty("width", ctx.width)("title", (ctx.header == null ? null : ctx.header.title) || "Graph chart")("description", (ctx.header == null ? null : ctx.header.subtitle) || "Graph chart")("height", ctx.height)("header", ctx.header)("legend", ctx.legend)("renderLegend", ctx.renderLegend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("noDataText", ctx.noDataText)("updateChart", ctx.updateChart)("dataBuilder", ctx._dataBuilder);
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵproperty("ngIf", ctx.showSlider);
            }
        }, directives: [AdaptChartComponent, i3__namespace.NgIf, AdaptChartSliderComponent, i3__namespace.NgForOf], encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptStackedChartComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-stacked-chart',
                        template: "\n    <adapt-chart #chart\n                 [width]=\"width\"\n                 [title]=\"header?.title || 'Graph chart'\"\n                 [description]=\"header?.subtitle || 'Graph chart'\"\n                 [height]=\"height\"\n                 [header]=\"header\"\n                 [legend]=\"legend\"\n                 [renderLegend]=\"renderLegend\"\n                 [data]=\"series\"\n                 [backgroundColor]=\"backgroundColor\"\n                 [suppressHeader]=\"suppressHeader\"\n                 [suppressLegend]=\"suppressLegend\"\n                 [tooltip]=\"tooltip\"\n                 (categoryShow)=\"categoryShowHandler($event)\"\n                 (categoryHide)=\"categoryHideHandler($event)\"\n                 (categoryEnter)=\"categoryEnterHandler($event)\"\n                 (categoryLeave)=\"categoryLeaveHandler($event)\"\n                 (clickChart)=\"clickChartArea($event)\"\n                 [noDataText]=\"noDataText\"\n                 [updateChart]=\"updateChart\"\n                 [dataBuilder]=\"_dataBuilder\">\n      <adapt-chart-slider *ngIf=\"showSlider\"\n                          (rangeChanged)=\"changeDataRange($event)\"\n                          [slidePointsCount]=\"slidePointsCount\"\n                          [height]=\"sliderHeight\"\n                          [xAxis]=\"xAxis\"\n                          [data]=\"sliderData\"\n                          [containerWidth]=\"chartWidth\"\n                          [customColors]=\"legend?.customColors\"\n                          [leftShift]=\"leftShift\"\n                          [type]=\"sliderType\"\n                          [stackedChart]=\"getStackedChart()\"></adapt-chart-slider>\n    </adapt-chart>\n\n    <ng-template #tooltipTpl let-data=\"data\">\n      <div class=\"adapt-chart-tooltip-content-container\">\n        <div>\n          <span class=\"adapt-chart-tooltip-color-spot\" [style.background-color]=\"data?.color\"></span>\n          <span class=\"adapt-chart-tooltip-category\">{{ data.category }}:</span>\n          <span><b>{{ data.value }}</b></span>\n        </div>\n        <div>\n          Total:\n          <span><b>{{ data.total }}</b></span>\n        </div>\n      </div>\n    </ng-template>\n    <ng-template #tooltipListInfoTpl let-data=\"data\">\n      <div class=\"chart-tooltip-content-container align-start\">\n        <div *ngFor=\"let d of data.seriesData\">\n          <ng-container *ngIf=\"d.value !== 0\">\n            <span class=\"adapt-chart-tooltip-color-spot\" [style.background-color]=\"d?.color\"></span>\n            <span class=\"adapt-chart-tooltip-category\">{{d.category}}:</span>\n            <span><b>{{ d.value }}</b></span>\n          </ng-container>\n        </div>\n        <hr class=\"mt-1 mb-1\">\n        <div>\n          Total:\n          <span><b>{{data.total}}</b></span>\n        </div>\n      </div>\n    </ng-template>",
                        encapsulation: i0.ViewEncapsulation.None,
                        providers: [CutNumberPipe]
                    }]
            }], function () { return [{ type: CutNumberPipe }, { type: ChartColorService }]; }, { tooltipTemplate: [{
                    type: i0.ViewChild,
                    args: ['tooltipTpl', { static: true }]
                }], tooltipListInfoTemplate: [{
                    type: i0.ViewChild,
                    args: ['tooltipListInfoTpl', { static: true }]
                }], chartComponent: [{
                    type: i0.ViewChild,
                    args: [AdaptChartComponent, { static: true }]
                }], chartSliderComponent: [{
                    type: i0.ViewChild,
                    args: [AdaptChartSliderComponent, { static: false }]
                }], backgroundColor: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], header: [{
                    type: i0.Input
                }], suppressHeader: [{
                    type: i0.Input
                }], suppressLegend: [{
                    type: i0.Input
                }], tooltip: [{
                    type: i0.Input
                }], dataBuilder: [{
                    type: i0.Input
                }], type: [{
                    type: i0.Input
                }], xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }], showSlider: [{
                    type: i0.Input
                }], hasTotalLabels: [{
                    type: i0.Input
                }], seriesDisplay: [{
                    type: i0.Input
                }], totalLabelTextFormatter: [{
                    type: i0.Input
                }], barWidth: [{
                    type: i0.Input
                }], slidePointsCount: [{
                    type: i0.Input
                }], hideAxises: [{
                    type: i0.Input
                }], rotateXAxis: [{
                    type: i0.Input
                }], xAxisTickFormatResolver: [{
                    type: i0.Input
                }], scientificMode: [{
                    type: i0.Input
                }], renderLegend: [{
                    type: i0.Input
                }], thresholdLine: [{
                    type: i0.Input
                }], showEmptyColIndicator: [{
                    type: i0.Input
                }], clickChart: [{
                    type: i0.Output
                }], categoryShow: [{
                    type: i0.Output
                }], categoryHide: [{
                    type: i0.Output
                }], series: [{
                    type: i0.Input
                }], legend: [{
                    type: i0.Input
                }] });
    })();

    var AdaptHeatmapAbstract = /** @class */ (function (_super) {
        __extends(AdaptHeatmapAbstract, _super);
        function AdaptHeatmapAbstract() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AdaptHeatmapAbstract;
    }(AdaptChartAbstract));
    AdaptHeatmapAbstract.ɵfac = /*@__PURE__*/ function () { var ɵAdaptHeatmapAbstract_BaseFactory; return function AdaptHeatmapAbstract_Factory(t) { return (ɵAdaptHeatmapAbstract_BaseFactory || (ɵAdaptHeatmapAbstract_BaseFactory = i0__namespace.ɵɵgetInheritedFactory(AdaptHeatmapAbstract)))(t || AdaptHeatmapAbstract); }; }();
    AdaptHeatmapAbstract.ɵdir = /*@__PURE__*/ i0__namespace.ɵɵdefineDirective({ type: AdaptHeatmapAbstract, inputs: { data: "data", xAxis: "xAxis", yAxis: "yAxis" }, features: [i0__namespace.ɵɵInheritDefinitionFeature] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptHeatmapAbstract, [{
                type: i0.Directive
            }], null, { data: [{
                    type: i0.Input
                }], xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }] });
    })();

    var _c0$5 = ["heatmapDefaultTooltip"];
    var _c1$3 = ["menuAnchor"];
    var _c2$2 = ["menuContainer"];
    function AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template(rf, ctx) {
        if (rf & 1) {
            var _r11_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "button", 12);
            i0__namespace.ɵɵlistener("click", function AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template_button_click_0_listener() { var restoredCtx = i0__namespace.ɵɵrestoreView(_r11_1); var action_r9 = restoredCtx.$implicit; var ctx_r10 = i0__namespace.ɵɵnextContext(4); return ctx_r10.callAction(ctx_r10.menuData.target, ctx_r10.menuData.event, ctx_r10.menuData.context, action_r9); });
            i0__namespace.ɵɵtext(1);
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var action_r9 = ctx.$implicit;
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate1("\n              ", action_r9.title, "\n            ");
        }
    }
    function AdaptHeatmapComponent_div_4_ng_template_6_div_3_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div");
            i0__namespace.ɵɵtext(1, "\n            ");
            i0__namespace.ɵɵtemplate(2, AdaptHeatmapComponent_div_4_ng_template_6_div_3_button_2_Template, 2, 1, "button", 11);
            i0__namespace.ɵɵtext(3, "\n          ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r7 = i0__namespace.ɵɵnextContext(3);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngForOf", ctx_r7.menuData.actions);
        }
    }
    function AdaptHeatmapComponent_div_4_ng_template_6_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n        ");
            i0__namespace.ɵɵelementStart(1, "div", 9);
            i0__namespace.ɵɵtext(2, "\n          ");
            i0__namespace.ɵɵtemplate(3, AdaptHeatmapComponent_div_4_ng_template_6_div_3_Template, 4, 1, "div", 10);
            i0__namespace.ɵɵtext(4, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(5, "\n      ");
        }
        if (rf & 2) {
            var ctx_r6 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("ngIf", ctx_r6.menuData && ctx_r6.menuData.actions && ctx_r6.menuData.actions.length);
        }
    }
    function AdaptHeatmapComponent_div_4_Template(rf, ctx) {
        if (rf & 1) {
            var _r13_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "div", 4, 5);
            i0__namespace.ɵɵlistener("popupAnimationDone", function AdaptHeatmapComponent_div_4_Template_div_popupAnimationDone_0_listener() { i0__namespace.ɵɵrestoreView(_r13_1); var ctx_r12 = i0__namespace.ɵɵnextContext(); return ctx_r12.popupAnimationDone(); });
            i0__namespace.ɵɵtext(2, "\n      ");
            i0__namespace.ɵɵelement(3, "button", 6, 7);
            i0__namespace.ɵɵtext(5, "\n      ");
            i0__namespace.ɵɵtemplate(6, AdaptHeatmapComponent_div_4_ng_template_6_Template, 6, 1, "ng-template", 8);
            i0__namespace.ɵɵtext(7, "\n    ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            i0__namespace.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true);
        }
    }
    function AdaptHeatmapComponent_ng_template_6_adapt_icon_5_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelement(0, "adapt-icon", 18);
        }
        if (rf & 2) {
            var c_r14 = i0__namespace.ɵɵnextContext().context;
            var ctx_r15 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵstyleProp("color", c_r14.status.iconColor || c_r14.status.color || ctx_r15.defaultColor);
            i0__namespace.ɵɵproperty("adaptRadarDisableEventSending", true)("name", c_r14.status.icon);
        }
    }
    function AdaptHeatmapComponent_ng_template_6_div_8_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div", 16);
            i0__namespace.ɵɵtext(1, "\n          ");
            i0__namespace.ɵɵelementStart(2, "small", 19);
            i0__namespace.ɵɵtext(3);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(4, "\n        ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var c_r14 = i0__namespace.ɵɵnextContext().context;
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(c_r14.info);
        }
    }
    function AdaptHeatmapComponent_ng_template_6_div_10_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div", 16);
            i0__namespace.ɵɵtext(1, "\n          ");
            i0__namespace.ɵɵelementStart(2, "label", 20);
            i0__namespace.ɵɵtext(3);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(4, "\n          ");
            i0__namespace.ɵɵelementStart(5, "div", 21);
            i0__namespace.ɵɵtext(6, "\n            ");
            i0__namespace.ɵɵelement(7, "div", 22);
            i0__namespace.ɵɵtext(8, "\n          ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n        ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var c_r14 = i0__namespace.ɵɵnextContext().context;
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵstyleProp("margin-left", c_r14.progress + "%");
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate1("", c_r14.progress, "%");
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵstyleProp("width", c_r14.progress + "%");
            i0__namespace.ɵɵattribute("aria-valuenow", c_r14.progress);
        }
    }
    function AdaptHeatmapComponent_ng_template_6_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n      ");
            i0__namespace.ɵɵelementStart(1, "div", 13);
            i0__namespace.ɵɵtext(2, "\n        ");
            i0__namespace.ɵɵelementStart(3, "div");
            i0__namespace.ɵɵtext(4, "\n          ");
            i0__namespace.ɵɵtemplate(5, AdaptHeatmapComponent_ng_template_6_adapt_icon_5_Template, 1, 4, "adapt-icon", 14);
            i0__namespace.ɵɵtext(6);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(7, "\n        ");
            i0__namespace.ɵɵtemplate(8, AdaptHeatmapComponent_ng_template_6_div_8_Template, 5, 1, "div", 15);
            i0__namespace.ɵɵtext(9, "\n        ");
            i0__namespace.ɵɵtemplate(10, AdaptHeatmapComponent_ng_template_6_div_10_Template, 10, 6, "div", 15);
            i0__namespace.ɵɵtext(11, "\n        ");
            i0__namespace.ɵɵelementStart(12, "div", 16);
            i0__namespace.ɵɵtext(13, "\n          ");
            i0__namespace.ɵɵelement(14, "div", 17);
            i0__namespace.ɵɵtext(15);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(16, "\n      ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(17, "\n    ");
        }
        if (rf & 2) {
            var c_r14 = ctx.context;
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵproperty("ngIf", c_r14.status.icon);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate1("\n          ", c_r14.name, "\n        ");
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngIf", c_r14.info);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngIf", c_r14.progress);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵstyleProp("background-color", c_r14.status.bg);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate1("\n          ", c_r14.status.name, "\n        ");
        }
    }
    var ICON_HEIGHT = 14;
    var LINE_HEIGHT = 18;
    var NODE_PADDING$1 = 15;
    // TODO update types
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    var AdaptHeatmapComponent = /** @class */ (function (_super) {
        __extends(AdaptHeatmapComponent, _super);
        function AdaptHeatmapComponent(_changeDetectorRef, _renderer, _iconConfig) {
            var _this = _super.call(this) || this;
            _this._changeDetectorRef = _changeDetectorRef;
            _this._renderer = _renderer;
            _this._iconConfig = _iconConfig;
            _this.hasActionMenu = false;
            _this.defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--gray-900');
            // Chart data builder
            _this._dataBuilder = (function (g, dim) {
                var _this = this;
                this._g = g;
                this._calculateMargin();
                var chartWidth = dim.w - (this._margin.left + this._margin.right);
                var chartHeight = dim.h - (this._margin.top + this._margin.bottom);
                var openTooltip = this._openTooltip.bind(this);
                var closeTooltip = this._closeTooltip.bind(this);
                var openMenu = this._openMenu.bind(this);
                var margin = this._margin;
                var ellipsis = this._ellipsis;
                var clickChart = this.clickChart;
                var _data = this._getPreparedData(chartWidth, chartHeight);
                var _getIcon = function (name) { return _this._iconConfig.getIcon(name); };
                // Draw chart
                var nodeGroup = this._g.selectAll('g')
                    .attr('transform', "translate(" + margin.left + " " + margin.top + ")")
                    .data(_data)
                    .enter()
                    .append('g')
                    .attr('class', function (d) { return "heatmap-node status-group-" + d.data.status.name.split(' ').join('_').toLowerCase(); })
                    .attr('id', function (d) { return d.data.name.split(' ').join('_'); })
                    .attr('transform', function (d) { return "translate(" + d.x0 + ", " + d.y0 + ")"; })
                    .on('mouseenter', function (d) {
                    var eventDetail = d3__namespace.event.detail;
                    var self = d3__namespace.select(this);
                    if (eventDetail === 0 || (eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.eventSource) !== 'legend') {
                        openTooltip(self.node(), { context: d.data });
                    }
                    d3__namespace.select(this)
                        .selectAll('rect')
                        .each(function () {
                        var _r = d3__namespace.select(this).node();
                        if (!_r.classList.contains('menu-icon')) {
                            _r.style.fill = d3__namespace.rgb(_r.style.fill).darker(.3).formatHex();
                        }
                    });
                })
                    .on('mouseleave', function () {
                    closeTooltip();
                    d3__namespace.select(this)
                        .selectAll('rect')
                        .each(function () {
                        var _r = d3__namespace.select(this).node();
                        if (!_r.classList.contains('menu-icon')) {
                            _r.style.fill = d3__namespace.rgb(_r.style.fill).brighter(.3).formatHex();
                        }
                    });
                })
                    .on('click', function (d) {
                    closeTooltip();
                    clickChart.emit(d.data);
                    d3__namespace.event.stopPropagation();
                });
                nodeGroup.append('g')
                    .attr('class', 'treemap-node-bg')
                    .each(function (d) {
                    var _node = d3__namespace.select(this);
                    _node.append('rect')
                        .attr('width', d.x1 - d.x0)
                        .attr('height', d.y1 - d.y0)
                        .attr('style', function () {
                        return "\n              fill: " + d.data.status.bg + ";\n              opacity: .6;\n              transition: fill .2s;\n              cursor: pointer;";
                    });
                    _node.append('rect')
                        .attr('width', function () {
                        var c = d.data.progress ? d.data.progress / 100 : 1;
                        return (d.x1 - d.x0) * c;
                    })
                        .attr('height', d.y1 - d.y0)
                        .attr('style', function () {
                        return "\n              fill: " + d.data.status.bg + ";\n              transition: fill .2s;\n              cursor: pointer;";
                    });
                });
                var _defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--gray-900');
                nodeGroup.append('g')
                    .attr('class', 'treemap-node-text')
                    .each(function (d) {
                    var _node = d3__namespace.select(this);
                    var _icon;
                    var _info;
                    if (d.data.status.icon && (d.y1 - d.y0 > 60)) {
                        _icon = _node.append('g')
                            .attr('transform', "translate(" + ((d.x1 - d.x0) / 2 - ICON_HEIGHT / 2) + ", 0)")
                            .html(_getIcon(d.data.status.icon))
                            .select('svg')
                            .attr('width', ICON_HEIGHT)
                            .attr('height', ICON_HEIGHT)
                            .attr('fill', d.data.status.iconColor || d.data.status.color || _defaultColor);
                    }
                    var _name = _node.append('text')
                        .attr('transform', "translate(" + (d.x1 - d.x0) / 2 + ", 0)")
                        .attr('dy', _icon ? LINE_HEIGHT + ICON_HEIGHT : 0)
                        .attr('text-anchor', 'middle')
                        .attr('fill', d.data.status.color || _defaultColor)
                        .attr('style', 'font-size: 13px;');
                    ellipsis(_name, d.data.name, d.x1 - d.x0 - NODE_PADDING$1);
                    if (_icon) {
                        _node.attr('transform', "translate(0, " + ((d.y1 - d.y0) / 2 - ICON_HEIGHT) + ")");
                    }
                    else {
                        _node.attr('transform', "translate(0, " + ((d.y1 - d.y0) / 2 + LINE_HEIGHT / 2) + ")");
                    }
                    if (d.data.info && (d.y1 - d.y0 > 40)) {
                        _info = _node.append('text')
                            .attr('transform', "translate(" + (d.x1 - d.x0) / 2 + ", 0)")
                            .attr('dy', _icon ? LINE_HEIGHT * 2 + ICON_HEIGHT : LINE_HEIGHT)
                            .attr('text-anchor', 'middle')
                            .attr('fill', d.data.status.color || _defaultColor)
                            .attr('style', 'font-size: 12px; opacity: .7');
                        ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING$1);
                        if (_icon) {
                            _node.attr('transform', "translate(0, " + ((d.y1 - d.y0) / 2 - ICON_HEIGHT - LINE_HEIGHT / 2) + ")");
                        }
                        else {
                            _node.attr('transform', "translate(0, " + (d.y1 - d.y0) / 2 + ")");
                        }
                    }
                });
                // Draw kebab menu icon
                nodeGroup
                    .append('g')
                    .attr('class', 'heatmap__actions-menu')
                    .each(function (d) {
                    if (d.data.actions) {
                        var _node = d3__namespace.select(this);
                        _node.append('rect')
                            .attr('class', 'menu-icon')
                            .attr('cursor', 'pointer')
                            .attr('fill', 'transparent')
                            .attr('height', 20)
                            .attr('width', 20)
                            .attr('transform', "translate(" + ((d.x1 - d.x0) - 24) + ", 10)");
                        _node.append('g')
                            .attr('transform', "translate(" + ((d.x1 - d.x0) - 24) + ", 10)")
                            .html(dplIconfont.ai_ellipsis.data)
                            .select('svg')
                            .attr('cursor', 'pointer')
                            .attr('fill', _defaultColor)
                            .attr('height', 20)
                            .attr('width', 20);
                    }
                })
                    .on('click', function (d) {
                    if (d.data.actions) {
                        var self = d3__namespace.select(this);
                        openMenu(self.node(), d3__namespace.event, d.data);
                        d3__namespace.event.stopPropagation();
                    }
                });
                // Draw Axises
                if (this.xAxis) {
                    var axisScaleX = d3__namespace
                        .scaleBand()
                        .domain(this.xAxis.categories)
                        .range([0, chartWidth]);
                    var xAxis = d3__namespace.axisBottom(axisScaleX)
                        .tickSizeOuter(0)
                        .tickSize(0)
                        .tickPadding(10);
                    this._g.append('g')
                        .attr('class', 'adapt-chart-axis xAxis')
                        .attr('transform', "translate(" + margin.left + ", " + chartHeight + ")")
                        .call(xAxis);
                }
                if (this.yAxis) {
                    var axisScaleY = d3__namespace
                        .scaleBand()
                        .domain(this.yAxis.categories)
                        .range([0, chartHeight]);
                    var yAxis = d3__namespace
                        .axisLeft(axisScaleY)
                        .tickSizeOuter(0)
                        .tickSize(0)
                        .tickPadding(10);
                    this._g.append('g')
                        .attr('class', 'adapt-chart-axis')
                        .attr('transform', "translate(" + margin.left + ", 0)")
                        .call(yAxis);
                }
                i1.SafeCdr.detectChanges(this._changeDetectorRef);
            }).bind(_this);
            // Chart update function
            _this._updateChart = (function (dim) {
                this._calculateMargin();
                var chartWidth = dim.w - (this._margin.left + this._margin.right);
                var chartHeight = dim.h - (this._margin.top + this._margin.bottom);
                var _data = this._getPreparedData(chartWidth, chartHeight);
                this._g.selectAll('g.heatmap-node')
                    .data(_data)
                    .transition()
                    .duration(200)
                    .attr('transform', function (d) { return "translate(" + d.x0 + ", " + d.y0 + ")"; });
                this._g.selectAll('g.treemap-node-bg rect:first-child')
                    .data(_data)
                    .transition()
                    .duration(200)
                    .attr('width', function (d) { return d.x1 - d.x0; });
                this._g.selectAll('g.treemap-node-bg rect:last-child')
                    .data(_data)
                    .transition()
                    .duration(200)
                    .attr('width', function (d) {
                    var c = d.data.progress ? d.data.progress / 100 : 1;
                    return (d.x1 - d.x0) * c;
                });
                this._g.selectAll('g.heatmap__actions-menu rect')
                    .data(_data.filter(function (d) { return d.data.actions; }))
                    .transition()
                    .duration(200)
                    .attr('transform', function (d) { return "translate(" + ((d.x1 - d.x0) - 24) + ", 10)"; });
                this._g.selectAll('g.heatmap__actions-menu use')
                    .data(_data.filter(function (d) { return d.data.actions; }))
                    .transition()
                    .duration(200)
                    .attr('transform', function (d) { return "translate(" + ((d.x1 - d.x0) - 24) + ", 10)"; });
                this._g.selectAll('.treemap-node-text')
                    .data(_data)
                    .each(function (d) {
                    d3__namespace.select(this).select('use')
                        .transition()
                        .duration(200)
                        .attr('transform', "translate(" + ((d.x1 - d.x0) / 2 - ICON_HEIGHT / 2) + ", 0)");
                    d3__namespace.select(this).selectAll('text')
                        .transition()
                        .duration(200)
                        .attr('transform', "translate(" + (d.x1 - d.x0) / 2 + ", 0)");
                });
                if (this.xAxis) {
                    var axisScaleX = d3__namespace
                        .scaleBand()
                        .domain(this.xAxis.categories)
                        .range([0, chartWidth]);
                    var xAxis = d3__namespace.axisBottom(axisScaleX)
                        .tickSizeOuter(0)
                        .tickSize(0)
                        .tickPadding(10);
                    this._g.select('g.adapt-chart-axis.xAxis')
                        .transition()
                        .duration(200)
                        .call(xAxis);
                }
            }).bind(_this);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this.clickChart = new i0.EventEmitter();
            _this._margin = {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            };
            _this._closeMenuBind = _this._closeMenu.bind(_this);
            return _this;
        }
        AdaptHeatmapComponent.prototype.ngOnInit = function () {
            if (this.legend) {
                this.legend.columns = 1;
                this.legend.activeHover = false;
                this.legend.activeClick = false;
            }
            this._initLegend();
        };
        AdaptHeatmapComponent.prototype.ngOnDestroy = function () {
            this._removeListeners();
        };
        AdaptHeatmapComponent.prototype.callAction = function (target, event, context, action) {
            action.callback(target, event, context);
        };
        AdaptHeatmapComponent.prototype.popupAnimationDone = function () {
            if (this.menuContainer.isOpen()) {
                this._removeClickEventListener = this._renderer.listen('document', 'click', this._closeMenuBind);
                this._removeScrollEventListener = this._renderer.listen('document', 'scroll', this._closeMenuBind);
            }
            else {
                this._removeListeners();
            }
        };
        AdaptHeatmapComponent.prototype._categoryEnter = function (categoryEvent) {
            // Pass "detail" via custom params to not show the tooltip when items highlighted through legend items hover
            this._g
                .selectAll(".status-group-" + this._legend.items[categoryEvent.id.toString()].split(' ').join('_').toLowerCase())
                .dispatch('mouseenter', { bubbles: true, cancelable: true, detail: { eventSource: 'legend' } });
        };
        AdaptHeatmapComponent.prototype._categoryLeave = function (categoryEvent) {
            this._g
                .selectAll(".status-group-" + this._legend.items[categoryEvent.id.toString()].split(' ').join('_').toLowerCase())
                .dispatch('mouseleave');
        };
        AdaptHeatmapComponent.prototype._calculateMargin = function () {
            this._margin.left = this.yAxis ? 60 : 0;
            this._margin.bottom = this.xAxis ? 38 : 0;
        };
        AdaptHeatmapComponent.prototype._getPreparedData = function (w, h) {
            var _this = this;
            var padding = 1;
            var chartWidth = Math.round(w);
            var rowCount = this.data.items.length;
            var rowHeight = Math.round(h / rowCount);
            var chartGrid = [];
            this.data.items.forEach(function (row, rIndex) {
                var rowWidth = 0;
                row.forEach(function (el) {
                    rowWidth += el.size;
                });
                var colWidth = _this._margin.left + 1;
                var colWidthMultiplier = chartWidth / rowWidth;
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                row.forEach(function (col) {
                    chartGrid.push({
                        data: col,
                        x0: Math.round(colWidth),
                        y0: Math.round(_this._margin.top + rowHeight * rIndex),
                        x1: Math.round(colWidth + colWidthMultiplier * col.size - padding),
                        y1: Math.round(_this._margin.top + rowHeight * rIndex + rowHeight - padding)
                    });
                    colWidth += colWidthMultiplier * col.size;
                });
            });
            // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
            this.hasActionMenu = chartGrid.some(function (item) { return item.data.actions && item.data.actions.length; });
            return chartGrid;
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptHeatmapComponent.prototype._openMenu = function (target, event, context) {
            this._closeTooltip();
            this.menuContainer.placement = 'bottom-right';
            this.menuContainer.positionTo = target;
            this.menuData = { target: target, event: event, context: context, actions: context.actions };
            this.menuAnchor.toggleOpen(event);
            i1.SafeCdr.detectChanges(this._changeDetectorRef);
        };
        AdaptHeatmapComponent.prototype._closeMenu = function () {
            if (this.menuContainer) {
                this.menuContainer.close();
            }
            this._removeListeners();
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptHeatmapComponent.prototype._openTooltip = function (target, context) {
            this.chartBase.showTooltip(target, this.tooltip || this.heatmapDefaultTooltip, context);
        };
        AdaptHeatmapComponent.prototype._closeTooltip = function () {
            this.chartBase.hideTooltip();
        };
        AdaptHeatmapComponent.prototype._initLegend = function () {
            if (this.suppressLegend) {
                return;
            }
            var legendItems = [];
            this.data.items.forEach(function (row) {
                row.forEach(function (col) {
                    if (col.status) {
                        var sameStatuses = legendItems.filter(function (lItem) {
                            return col.status.name === lItem.name;
                        });
                        if (!sameStatuses.length) {
                            legendItems.push({ name: col.status.name, color: col.status.bg });
                        }
                    }
                });
            });
            if (legendItems.length) {
                this._legend = {
                    columns: 1,
                    items: legendItems.map(function (el) { return el.name; }),
                    customColors: legendItems.map(function (el) { return el.color; }),
                    activeHover: false,
                    activeClick: false
                };
            }
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptHeatmapComponent.prototype._ellipsis = function (textNode, text, ellipsisWidth) {
            var letters = text.split('');
            var ellipsis = textNode.append('tspan').attr('class', 'ellipsis').text('...');
            var width = ellipsisWidth - ellipsis.node().getComputedTextLength();
            var numWords = letters.length;
            var tspan = textNode.insert('tspan', ':first-child').text(letters.join(''));
            // Try the whole line
            // While it's too long, and we have words left, keep removing words
            while (tspan.node().getComputedTextLength() > width && letters.length) {
                letters.pop();
                tspan.text(letters.join(''));
            }
            if (letters.length === numWords) {
                ellipsis.remove();
            }
        };
        AdaptHeatmapComponent.prototype._removeListeners = function () {
            if (this._removeClickEventListener) {
                this._removeClickEventListener();
                this._removeClickEventListener = null;
            }
            if (this._removeScrollEventListener) {
                this._removeScrollEventListener();
                this._removeScrollEventListener = null;
            }
        };
        return AdaptHeatmapComponent;
    }(AdaptHeatmapAbstract));
    AdaptHeatmapComponent.ɵfac = function AdaptHeatmapComponent_Factory(t) { return new (t || AdaptHeatmapComponent)(i0__namespace.ɵɵdirectiveInject(i0__namespace.ChangeDetectorRef), i0__namespace.ɵɵdirectiveInject(i0__namespace.Renderer2), i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptIconConfig)); };
    AdaptHeatmapComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptHeatmapComponent, selectors: [["adapt-heatmap"]], viewQuery: function AdaptHeatmapComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(AdaptChartComponent, 7);
                i0__namespace.ɵɵviewQuery(_c0$5, 7);
                i0__namespace.ɵɵviewQuery(_c1$3, 5, i1.AdaptDropdownToggleDirective);
                i0__namespace.ɵɵviewQuery(_c2$2, 5, i1.AdaptDropdownDirective);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartBase = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.heatmapDefaultTooltip = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.menuAnchor = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.menuContainer = _t.first);
            }
        }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", data: "data", xAxis: "xAxis", yAxis: "yAxis", noDataText: "noDataText" }, outputs: { clickChart: "clickChart" }, features: [i0__namespace.ɵɵInheritDefinitionFeature], decls: 9, vars: 13, consts: [[3, "data", "width", "height", "header", "legend", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "dataBuilder", "updateChart", "noDataText", "categoryEnter", "categoryLeave"], ["chartBase", ""], ["class", "dropdown heatmap-chart_hidden-menu", "adaptDropdown", "", 3, "adaptRadarDisableEventSending", "appendToBody", "popupAnimationDone", 4, "ngIf"], ["heatmapDefaultTooltip", ""], ["adaptDropdown", "", 1, "dropdown", "heatmap-chart_hidden-menu", 3, "adaptRadarDisableEventSending", "appendToBody", "popupAnimationDone"], ["menuContainer", ""], ["adaptDropdownToggle", "", "type", "button"], ["menuAnchor", ""], ["adaptDropdownMenuTemplate", ""], [1, "dropdown-menu"], [4, "ngIf"], ["class", "dropdown-item", "type", "button", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "dropdown-item", 3, "click"], [1, "text-left"], ["class", "icon-inline", 3, "adaptRadarDisableEventSending", "name", "color", 4, "ngIf"], ["class", "pt-2", 4, "ngIf"], [1, "pt-2"], [2, "width", "8px", "height", "8px", "margin", "0 4px 1px 2px", "display", "inline-block", "vertical-align", "middle"], [1, "icon-inline", 3, "adaptRadarDisableEventSending", "name"], [1, "text-secondary"], [1, "progress-label"], [1, "progress"], ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", 1, "progress-bar", "bg-primary-muted"]], template: function AdaptHeatmapComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵtext(0, "\n    ");
                i0__namespace.ɵɵelementStart(1, "adapt-chart", 0, 1);
                i0__namespace.ɵɵlistener("categoryEnter", function AdaptHeatmapComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx._categoryEnter($event); })("categoryLeave", function AdaptHeatmapComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx._categoryLeave($event); });
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(3, "\n\n    ");
                i0__namespace.ɵɵtemplate(4, AdaptHeatmapComponent_div_4_Template, 8, 2, "div", 2);
                i0__namespace.ɵɵtext(5, "\n\n    ");
                i0__namespace.ɵɵtemplate(6, AdaptHeatmapComponent_ng_template_6_Template, 18, 7, "ng-template", null, 3, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(8, "\n  ");
            }
            if (rf & 2) {
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵproperty("data", ctx.data)("width", ctx.width)("height", ctx.height)("header", ctx.header)("legend", ctx._legend)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("dataBuilder", ctx._dataBuilder)("updateChart", ctx._updateChart)("noDataText", ctx.noDataText);
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵproperty("ngIf", ctx.hasActionMenu);
            }
        }, directives: [AdaptChartComponent, i3__namespace.NgIf, i1__namespace.AdaptDropdownDirective, i1__namespace.AdaptDropdownToggleDirective, i1__namespace.AdaptDropdownMenuTemplateDirective, i3__namespace.NgForOf, i1__namespace.AdaptIconComponent], styles: [".heatmap-chart_hidden-menu[_ngcontent-%COMP%] {\n      opacity: 0;\n      visibility: hidden;\n      height: 0\n    }"] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptHeatmapComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-heatmap',
                        styles: ["\n    .heatmap-chart_hidden-menu {\n      opacity: 0;\n      visibility: hidden;\n      height: 0\n    }\n  "],
                        template: "\n    <adapt-chart #chartBase\n                 [data]=\"data\"\n                 [width]=\"width\"\n                 [height]=\"height\"\n                 [header]=\"header\"\n                 [legend]=\"_legend\"\n                 [backgroundColor]=\"backgroundColor\"\n                 [suppressHeader]=\"suppressHeader\"\n                 [suppressLegend]=\"suppressLegend\"\n                 [tooltip]=\"tooltip\"\n                 [dataBuilder]=\"_dataBuilder\"\n                 [updateChart]=\"_updateChart\"\n                 [noDataText]=\"noDataText\"\n                 (categoryEnter)=\"_categoryEnter($event)\"\n                 (categoryLeave)=\"_categoryLeave($event)\"></adapt-chart>\n\n    <div class=\"dropdown heatmap-chart_hidden-menu\"\n         adaptDropdown\n         #menuContainer\n         *ngIf=\"hasActionMenu\"\n         [adaptRadarDisableEventSending]=\"true\"\n         [appendToBody]=\"true\"\n         (popupAnimationDone)=\"popupAnimationDone()\">\n      <button #menuAnchor adaptDropdownToggle type=\"button\"></button>\n      <ng-template adaptDropdownMenuTemplate>\n        <div class=\"dropdown-menu\">\n          <div *ngIf=\"menuData && menuData.actions && menuData.actions.length\">\n            <button class=\"dropdown-item\"\n                    type=\"button\"\n                    *ngFor=\"let action of menuData.actions;\"\n                    (click)=\"callAction(menuData.target, menuData.event, menuData.context, action)\">\n              {{action.title}}\n            </button>\n          </div>\n        </div>\n      </ng-template>\n    </div>\n\n    <ng-template #heatmapDefaultTooltip let-c=\"context\">\n      <div class=\"text-left\">\n        <div>\n          <adapt-icon class=\"icon-inline\"\n                      [adaptRadarDisableEventSending]=\"true\"\n                      *ngIf=\"c.status.icon\"\n                      [name]=\"c.status.icon\"\n                      [style.color]=\"c.status.iconColor || c.status.color || defaultColor\"></adapt-icon>\n          {{c.name}}\n        </div>\n        <div class=\"pt-2\" *ngIf=\"c.info\">\n          <small class=\"text-secondary\">{{c.info}}</small>\n        </div>\n        <div class=\"pt-2\" *ngIf=\"c.progress\">\n          <label class=\"progress-label\" [style.marginLeft]=\"c.progress + '%'\">{{c.progress}}%</label>\n          <div class=\"progress\">\n            <div class=\"progress-bar bg-primary-muted\"\n                 role=\"progressbar\"\n                 [style.width]=\"c.progress + '%'\"\n                 [attr.aria-valuenow]=\"c.progress\"\n                 aria-valuemin=\"0\"\n                 aria-valuemax=\"100\"></div>\n          </div>\n        </div>\n        <div class=\"pt-2\">\n          <div style=\"width: 8px; height: 8px; margin: 0 4px 1px 2px; display: inline-block; vertical-align: middle\"\n               [style.backgroundColor]=\"c.status.bg\"></div>\n          {{c.status.name}}\n        </div>\n      </div>\n    </ng-template>\n  "
                    }]
            }], function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.Renderer2 }, { type: i1__namespace.AdaptIconConfig }]; }, { chartBase: [{
                    type: i0.ViewChild,
                    args: [AdaptChartComponent, { static: true }]
                }], heatmapDefaultTooltip: [{
                    type: i0.ViewChild,
                    args: ['heatmapDefaultTooltip', { static: true }]
                }], menuAnchor: [{
                    type: i0.ViewChild,
                    args: ['menuAnchor', {
                            read: i1.AdaptDropdownToggleDirective,
                            static: false
                        }]
                }], menuContainer: [{
                    type: i0.ViewChild,
                    args: ['menuContainer', { read: i1.AdaptDropdownDirective, static: false }]
                }], backgroundColor: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], header: [{
                    type: i0.Input
                }], legend: [{
                    type: i0.Input
                }], suppressHeader: [{
                    type: i0.Input
                }], suppressLegend: [{
                    type: i0.Input
                }], tooltip: [{
                    type: i0.Input
                }], data: [{
                    type: i0.Input
                }], xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }], noDataText: [{
                    type: i0.Input
                }], clickChart: [{
                    type: i0.Output
                }] });
    })();

    var AdaptLineGraphAbstract = /** @class */ (function (_super) {
        __extends(AdaptLineGraphAbstract, _super);
        function AdaptLineGraphAbstract() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AdaptLineGraphAbstract;
    }(AdaptChartAbstract));
    AdaptLineGraphAbstract.ɵfac = /*@__PURE__*/ function () { var ɵAdaptLineGraphAbstract_BaseFactory; return function AdaptLineGraphAbstract_Factory(t) { return (ɵAdaptLineGraphAbstract_BaseFactory || (ɵAdaptLineGraphAbstract_BaseFactory = i0__namespace.ɵɵgetInheritedFactory(AdaptLineGraphAbstract)))(t || AdaptLineGraphAbstract); }; }();
    AdaptLineGraphAbstract.ɵdir = /*@__PURE__*/ i0__namespace.ɵɵdefineDirective({ type: AdaptLineGraphAbstract, inputs: { xAxis: "xAxis", yAxis: "yAxis", series: "series", hideAxises: "hideAxises" }, features: [i0__namespace.ɵɵInheritDefinitionFeature] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptLineGraphAbstract, [{
                type: i0.Directive
            }], null, { xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }], series: [{
                    type: i0.Input
                }], hideAxises: [{
                    type: i0.Input
                }] });
    })();

    var _c0$4 = ["tooltipTpl"];
    function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template(rf, ctx) {
        if (rf & 1) {
            var _r4_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "adapt-area-graph-slider", 3);
            i0__namespace.ɵɵlistener("rangeChanged", function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_rangeChanged_0_listener($event) { i0__namespace.ɵɵrestoreView(_r4_1); var ctx_r3 = i0__namespace.ɵɵnextContext(); return ctx_r3.rangeChanged($event); })("scrollEnd", function AdaptLineGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_scrollEnd_0_listener() { i0__namespace.ɵɵrestoreView(_r4_1); var ctx_r5 = i0__namespace.ɵɵnextContext(); return ctx_r5.scrollEnd(); });
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r0 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵproperty("data", ctx_r0.sliderData)("xAxis", ctx_r0.xAxis)("slidePointsCount", ctx_r0.slidePointsCount)("customColors", ctx_r0.legend == null ? null : ctx_r0.legend.customColors)("xBrush", ctx_r0.xBrush)("leftShift", ctx_r0.leftShift)("containerWidth", ctx_r0.chartWidth);
        }
    }
    function AdaptLineGraphComponent_ng_template_5_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n  ");
            i0__namespace.ɵɵelementStart(1, "div", 4);
            i0__namespace.ɵɵtext(2, "\n    ");
            i0__namespace.ɵɵelementStart(3, "div", 5);
            i0__namespace.ɵɵtext(4, "\n      ");
            i0__namespace.ɵɵelement(5, "span", 6);
            i0__namespace.ɵɵtext(6, "\n      ");
            i0__namespace.ɵɵelementStart(7, "span", 7);
            i0__namespace.ɵɵtext(8);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(10, "\n    ");
            i0__namespace.ɵɵelementStart(11, "div");
            i0__namespace.ɵɵtext(12);
            i0__namespace.ɵɵelementStart(13, "span");
            i0__namespace.ɵɵelementStart(14, "b");
            i0__namespace.ɵɵtext(15);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(16, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(17, "\n\n    ");
            i0__namespace.ɵɵelementStart(18, "div");
            i0__namespace.ɵɵtext(19);
            i0__namespace.ɵɵelementStart(20, "span");
            i0__namespace.ɵɵelementStart(21, "b");
            i0__namespace.ɵɵtext(22);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(23, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(24, "\n  ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(25, "\n");
        }
        if (rf & 2) {
            var data_r6 = ctx.data;
            var ctx_r2 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵstyleProp("background", data_r6 == null ? null : data_r6.color);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r6.category);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate1("\n      ", ctx_r2.getTooltipXValueTitle(), ":\n      ");
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r6.xValue);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate1("\n      ", ctx_r2.yAxis == null ? null : ctx_r2.yAxis.title, ":\n      ");
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r6.yValue);
        }
    }
    var chartCounter$1 = 1;
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    var AdaptLineGraphComponent = /** @class */ (function (_super) {
        __extends(AdaptLineGraphComponent, _super);
        function AdaptLineGraphComponent(_cutNumber, _deviceDetectionService, _colorService, _ngZone, _changeDetectorRef) {
            var _this = _super.call(this) || this;
            _this._cutNumber = _cutNumber;
            _this._deviceDetectionService = _deviceDetectionService;
            _this._colorService = _colorService;
            _this._ngZone = _ngZone;
            _this._changeDetectorRef = _changeDetectorRef;
            _this.alreadyChanged = false;
            _this.sliderData = [];
            _this.sliderDomainData = [];
            _this._dataBuilderBind = _this._dataBuilder.bind(_this);
            _this._updateChartBind = _this._updateChart.bind(_this);
            _this.componentNumericalValues = {
                circleRadius: 6,
                maxTicksCount: 7,
                axisShift: {
                    top: 0,
                    right: 0,
                    bottom: 25,
                    left: 25
                },
                margin: {
                    top: 0,
                    right: 0,
                    bottom: 25,
                    left: 50
                },
                marginMobile: 40
            };
            _this.circleRadius = _this.componentNumericalValues.circleRadius;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this._series = [];
            _this._maxTicksCount = _this.componentNumericalValues.maxTicksCount;
            _this._data = [];
            _this._isDeselected = [];
            _this._colors = [];
            _this._destroy$ = new rxjs.ReplaySubject(1);
            _this._axisShift = Object.assign({}, _this.componentNumericalValues.axisShift);
            _this.colorsPalette = 'gradient';
            _this.supressAxles = false;
            _this.showLineCircles = true;
            _this.rotateXAxis = false;
            _this.showSlider = false;
            _this.disallowPadding = false;
            _this.scientificMode = false;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this.clickChart = new i0.EventEmitter();
            /**
             * Output that emits each time chart category shown
             * @since 12.11.0
             */
            _this.categoryShow = new i0.EventEmitter();
            /**
             * Output that emits each time chart category hidden
             * @since 12.11.0
             */
            _this.categoryHide = new i0.EventEmitter();
            _this._thresholdLine = null;
            _this._legend = {
                columns: 1,
                activeHover: true,
                activeClick: true,
                width: 250,
                customColors: null,
                items: []
            };
            _this._id = "line-graph-" + chartCounter$1++;
            return _this;
        }
        Object.defineProperty(AdaptLineGraphComponent.prototype, "_margin", {
            get: function () {
                return {
                    top: 0,
                    left: this.isMobile()
                        ? this.componentNumericalValues.marginMobile
                        : this.disallowPadding
                            ? 0
                            : this.yAxis && this.yAxis.title ? this.componentNumericalValues.margin.left + this._axisShift.left : this.componentNumericalValues.margin.left,
                    right: 0,
                    bottom: this.disallowPadding
                        ? 0
                        : this.xAxis && this.xAxis.title ? this.componentNumericalValues.margin.bottom + this._axisShift.bottom : this.componentNumericalValues.margin.bottom
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptLineGraphComponent.prototype, "duration", {
            get: function () {
                return parseFloat(i1.ANIMATION_DURATION.fast) * 1000;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptLineGraphComponent.prototype, "thresholdLine", {
            get: function () {
                return this._thresholdLine;
            },
            /**
             * Threshold line in a chart to help determine which data points are either below or above a significant value
             * @since 10.11.0
             */
            set: function (value) {
                this._thresholdLine = lodashEs.isNumber(value) ? value : null;
                if (this.alreadyChanged) {
                    this._updateThresholdLineArea();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptLineGraphComponent.prototype, "legend", {
            get: function () {
                return {
                    customColors: this._legend.customColors,
                    activeHover: this._legend.activeHover,
                    activeClick: this._legend.activeClick,
                    columns: this._legend.columns,
                    width: this._legend.width,
                    items: this.series.map(function (series) { return ({ item: series.name, hidden: !!series.hidden }); })
                };
            },
            set: function (legend) {
                this._legend = Object.assign(this._legend, legend);
                if (this.alreadyChanged) {
                    this.chartComponent.redrawChart();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptLineGraphComponent.prototype, "series", {
            get: function () {
                return this._series;
            },
            set: function (series) {
                var _this = this;
                this._series = series;
                this._isDeselected = [];
                series.forEach(function (s) {
                    if (s.hidden) {
                        _this._isDeselected.push(s.name);
                    }
                });
                // such transformation needed for proper display
                // of the slider for area graph
                this.sliderData = __spreadArray([], __read(this.mapDataFromSeries(series)));
                if (this.alreadyChanged) {
                    var options = this.chartComponent.getGroupAndDimensions();
                    this._g = options.group;
                    this._dim = {
                        w: options.w,
                        h: options.h
                    };
                }
                if (this._g && this._dim && this.chartComponent) {
                    this.chartComponent.updateLegend(this.series.map(function (item) { return ({
                        item: item.name,
                        hidden: !!item.hidden,
                        hover: false
                    }); }));
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptLineGraphComponent.prototype, "leftShift", {
            get: function () {
                return this._margin.left;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptLineGraphComponent.prototype, "chartWidth", {
            get: function () {
                return this.chartComponent.currentSVGWidth;
            },
            enumerable: false,
            configurable: true
        });
        AdaptLineGraphComponent.prototype.ngOnInit = function () {
            if (this.scientificMode) {
                BigNumber__default["default"].config({ EXPONENTIAL_AT: 4 });
            }
            this.alreadyChanged = true;
        };
        AdaptLineGraphComponent.prototype.ngOnChanges = function (changes) {
            if (this._dim && (changes[this.nameof('showLineCircles')]
                || changes[this.nameof('supressAxles')]
                || changes[this.nameof('rotateXAxis')]
                || changes[this.nameof('showSlider')])) {
                this._detectViewChanges();
            }
        };
        AdaptLineGraphComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        AdaptLineGraphComponent.prototype._dataBuilder = function (g, dim) {
            this._g = g;
            this._dim = dim;
            this._initClipPath();
            this._clear();
            this._initData();
            this._initAxis(g, dim);
            this._drawLines(g);
            this._drawDropShadow();
            this._updateThresholdLineArea();
        };
        AdaptLineGraphComponent.prototype._updateChart = function (dim, skipUpdateAxisX) {
            if (skipUpdateAxisX === void 0) { skipUpdateAxisX = false; }
            this._dim = dim; // after updating from toggling legend or create separate method for input
            this._initData();
            // update clipPath
            if (this._g) {
                this._g.select("#" + this._id + "_clip > rect")
                    .attr('width', dim.w - (this._margin.left + this._margin.right))
                    .attr('height', dim.h - (this._margin.top + this._margin.bottom));
            }
            if (!skipUpdateAxisX) {
                this._updateAxis(dim);
            }
            this._updateDataLines();
            this._updateThresholdLineArea();
        };
        AdaptLineGraphComponent.prototype.isMobile = function () {
            return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
        };
        AdaptLineGraphComponent.prototype.categoryShowHandler = function (category) {
            var _this = this;
            var index = this._isDeselected.indexOf(category);
            if (index !== -1) {
                this._isDeselected.splice(index, 1);
            }
            this._updateChart(this._dim, true);
            this.series.forEach(function (item, ind) {
                if (item.name.indexOf(category) !== -1) {
                    item.hidden = false;
                    _this._g
                        .select("[data-line-graph-id='" + ind + "']")
                        .style('display', 'block');
                }
            });
            if (!i1.isUndefined(this.chartSliderComponent)) {
                this.chartSliderComponent.showCategory(category);
            }
            this.categoryShow.emit({ category: category });
        };
        AdaptLineGraphComponent.prototype.categoryHideHandler = function (category) {
            var _this = this;
            this._isDeselected.push(category);
            this.series.forEach(function (item, index) {
                if (item.name.indexOf(category) !== -1) {
                    item.hidden = true;
                    _this._g
                        .select("[data-line-graph-id='" + index + "']")
                        .style('display', 'none');
                }
            });
            this._updateChart(this._dim, true);
            if (!i1.isUndefined(this.chartSliderComponent)) {
                this.chartSliderComponent.hideCategory(category);
            }
            this.categoryHide.emit({ category: category });
        };
        AdaptLineGraphComponent.prototype.categoryEnter = function (categoryEvent) {
            var _this = this;
            var ind = this._isDeselected.indexOf(this.series[categoryEvent.id].name);
            if (ind === -1) {
                var selectedGroup = this._g.select("g[data-line-graph-id='" + categoryEvent.id + "']");
                var selectedLine = selectedGroup.select('path');
                var linesWrapper = selectedGroup.node().parentNode;
                var colorLine_1 = selectedLine.attr('stroke');
                this._highLightColor = colorLine_1;
                this._pathLines = linesWrapper.querySelectorAll('.line-chart-lines');
                this._pathLines.forEach(function (line) {
                    var pathLineColor = line.getAttribute('stroke');
                    if (pathLineColor === colorLine_1) {
                        line.setAttribute('stroke-width', '3');
                        _this._pathLineCurrent = line;
                    }
                    else {
                        line.setAttribute('stroke-width', '1');
                    }
                });
                if (this.showLineCircles) {
                    var lineCirclesWrapper = this._g.select('.line-graph-circle-wrapper').node();
                    var circles = lineCirclesWrapper.querySelectorAll('.line-graph-circle');
                    circles.forEach(function (circle) {
                        if (circle.getAttribute('fill') !== colorLine_1) {
                            circle.setAttribute('r', '4');
                        }
                    });
                }
            }
        };
        AdaptLineGraphComponent.prototype.categoryLeave = function () {
            var _this = this;
            if (this._pathLineCurrent) {
                this._pathLineCurrent.setAttribute('stroke-width', '2');
            }
            if (this._pathLines) {
                this._pathLines.forEach(function (line) {
                    line.classList.remove('line-graph-transition');
                    line.setAttribute('stroke-width', '2');
                });
            }
            if (this.showLineCircles) {
                var lineCirclesWrapper = this._g.select('.line-graph-circle-wrapper').node();
                var circles = lineCirclesWrapper.querySelectorAll('.line-graph-circle');
                circles.forEach(function (circle) {
                    if (circle.getAttribute('fill') !== _this._highLightColor) {
                        circle.classList.remove('line-graph-transition');
                        circle.setAttribute('r', '6');
                    }
                });
            }
        };
        AdaptLineGraphComponent.prototype.getTooltipXValueTitle = function () {
            return this.xAxis ? this.xAxis.title : '';
        };
        AdaptLineGraphComponent.prototype.rangeChanged = function (data) {
            this.sliderDomainData = data;
            // In case X axes text are rotated call update on the scroll end.
            // This is prevent incorrect text splitting on multiple lines
            if (!this.rotateXAxis) {
                this._updateXAxis(this._dim);
            }
            this._updateDataLines();
        };
        AdaptLineGraphComponent.prototype.scrollEnd = function () {
            if (this.rotateXAxis) {
                this._updateXAxis(this._dim);
            }
        };
        AdaptLineGraphComponent.prototype.getXAxisLineRenderer = function (dim) {
            return d3__namespace.axisBottom(this._x)
                .tickPadding(10)
                .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
                .tickSizeOuter(0);
        };
        AdaptLineGraphComponent.prototype.getYPosFunc = function (dim, ticksVal) {
            return d3__namespace.scaleLinear()
                .rangeRound([0, dim.h - this._margin.bottom - this._margin.top])
                .domain([ticksVal[0], 0]);
        };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        AdaptLineGraphComponent.prototype.getXPosFunc = function (dim, domain) {
            if (domain === void 0) { domain = []; }
            return d3__namespace.scalePoint()
                .range([0, dim.w - (this._margin.left + this._margin.right)])
                .domain(this.xAxis.categories);
        };
        AdaptLineGraphComponent.prototype._getCustomColorById = function (id) {
            var customColors = this.legend.customColors;
            var len = customColors.length;
            var index = id % len;
            return customColors[index];
        };
        AdaptLineGraphComponent.prototype._drawLines = function (g) {
            var _this = this;
            // TODO check if it can be refactored
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _self = this;
            this._gW = g.append('g')
                .attr('class', 'area-chart-data')
                .attr('transform', "translate(" + this._margin.left + ", 0)");
            this._line = this.getLineRenderer();
            this._colors = [];
            this._data.forEach(function (dt, i) {
                var _a;
                _this._colors.push(((_a = _this.legend.customColors) === null || _a === void 0 ? void 0 : _a.length) ? _this._getCustomColorById(i) : _this._colorService.getColor(i, _this.colorsPalette));
                var lineWrapper = _this._gW
                    .append('g')
                    .attr('class', 'line-chart-line-g')
                    .attr('display', dt.hidden ? 'none' : 'block')
                    .attr('id', _this._colors[i])
                    .attr('data-line-graph-id', i);
                _this.drawLineForSeries(lineWrapper, dt, i);
                _this.drawAreaForSeries(lineWrapper, dt, i);
                _this.drawLineCircles(lineWrapper, i, dt)
                    .on('mouseover', function (d) {
                    /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                    var circleEl = this;
                    _self.onCircleMouseover(circleEl, dt, d);
                })
                    .on('mouseout', function () {
                    /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                    var circleEl = this;
                    _self.onCircleMouseout(circleEl);
                });
            });
            this.toggleLineCirclesVisibility(this._g, this.showLineCircles);
        };
        AdaptLineGraphComponent.prototype.onCircleMouseout = function (circleEl) {
            var circleRadius = this.circleRadius;
            var circleParentLineEl = this.getCircleLine(circleEl);
            circleParentLineEl.attr('stroke-width', '2');
            var circleSelection = d3__namespace.select(circleEl);
            this._gW.selectAll('.line-chart-lines')
                .classed('line-graph-transition', false)
                .attr('stroke-width', '2');
            var baseColor = circleSelection.attr('fill-old');
            d3__namespace.selectAll('.line-graph-circle-wrapper .line-graph-circle').each(function () {
                if (d3__namespace.select(this).attr('fill') !== baseColor) {
                    d3__namespace.select(this)
                        .classed('line-graph-transition', false)
                        .attr('r', circleRadius);
                }
            });
            circleSelection
                .attr('fill', baseColor)
                .style('filter', null)
                .attr('fill-old', null);
            this.chartComponent.hideTooltip();
        };
        AdaptLineGraphComponent.prototype.onCircleMouseover = function (circleEl, dt, d) {
            var circleSelection = d3__namespace.select(circleEl);
            var circleParentLineSelection = this.getCircleLine(circleEl);
            var circleParentLineEl = circleParentLineSelection.node();
            var baseColor = circleSelection.attr('fill');
            circleSelection.attr('fill-old', baseColor);
            var colorHex = this.getCircleDarkenColor(baseColor, circleParentLineSelection);
            d3__namespace.selectAll('.line-chart-line-g').each(function () {
                if (d3__namespace.select(this).attr('data-id') === baseColor && this.nextElementSibling !== null) {
                    this.parentNode.appendChild(this);
                }
            });
            this._gW.selectAll('.line-chart-lines').each(function () {
                if (circleParentLineEl === this) {
                    d3__namespace.select(this).attr('stroke-width', '3');
                }
                else {
                    d3__namespace.select(this).classed('line-graph-transition', true).attr('stroke-width', '1');
                }
            });
            d3__namespace.selectAll('.line-graph-circle-wrapper .line-graph-circle').each(function () {
                if (d3__namespace.select(this).attr('fill') !== baseColor) {
                    d3__namespace.select(this).classed('line-graph-transition', true).attr('r', 4);
                }
            });
            this.showCircleTooltip(circleParentLineSelection.attr('stroke'), dt, d);
            circleSelection
                .attr('r', 8)
                .style('filter', 'url(#drop-shadow)')
                .attr('fill', colorHex);
        };
        AdaptLineGraphComponent.prototype.showCircleTooltip = function (baseColor, dt, 
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        d) {
            this.chartComponent.showTooltip(d3__namespace.event.target, this.tooltip || this.tooltipTemplate, {
                data: this.getTooltipData(baseColor, dt, d)
            });
        };
        AdaptLineGraphComponent.prototype.getTooltipData = function (baseColor, dt, 
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        d) {
            return {
                color: baseColor,
                category: dt.name,
                xValue: d.date,
                yValue: this.scientificMode ? new BigNumber__default["default"](d.data) : d.data
            };
        };
        // TODO check if useless arg can be removed
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        AdaptLineGraphComponent.prototype.getCircleDarkenColor = function (baseColor, circleParentLineSelection) {
            return this._colorService.getDarken(baseColor, .15, i1.ColorType.HEX);
        };
        AdaptLineGraphComponent.prototype.drawLineCircles = function (lineWrapper, i, dt) {
            var circleSel = lineWrapper
                .append('g')
                .attr('class', 'line-graph-circle-wrapper')
                .attr('data-id', this._colors[i])
                .selectAll('dots')
                .data(this.getDataForCirclesOrLines(dt))
                .enter()
                .append('circle')
                .attr('r', this.circleRadius)
                .attr('class', 'line-graph-circle')
                .attr('fill', this.getCircleColor(i));
            return this.setCirclePosition(circleSel);
        };
        AdaptLineGraphComponent.prototype.toggleLineCirclesVisibility = function (g, isShown) {
            if (g) {
                g.selectAll('.line-graph-circle-wrapper').style('display', isShown ? 'block' : 'none');
            }
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptLineGraphComponent.prototype.getDataForCirclesOrLines = function (dt) {
            return dt.data;
        };
        AdaptLineGraphComponent.prototype.setCirclePosition = function (
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        circleSel) {
            var _this = this;
            return circleSel
                .attr('cx', function (d) { return _this._x(d.date); })
                .attr('cy', function (d) { return _this._y(d.data); });
        };
        AdaptLineGraphComponent.prototype.drawLineForSeries = function (lineWrapper, dt, i) {
            return lineWrapper
                .append('path')
                .datum(this.getDataForCirclesOrLines(dt))
                .attr('clip-path', "url(#" + this._id + "_clip)")
                .attr('fill', 'none')
                .attr('class', 'line-chart-lines')
                .attr('stroke', this._colors[i])
                .attr('stroke-width', '2')
                .attr('d', this._line);
        };
        AdaptLineGraphComponent.prototype.getCircleColor = function (i) {
            return this._colors[i];
        };
        // for overriding
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        AdaptLineGraphComponent.prototype.drawAreaForSeries = function (lineWrapper, dt, i) {
            // Nothing to draw
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptLineGraphComponent.prototype.getLineRenderer = function () {
            var _this = this;
            return d3__namespace.line()
                .x(function (d) { return _this._x(d.date); })
                .y(function (d) { return _this._y(d.data); });
        };
        // for overriding
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        AdaptLineGraphComponent.prototype.updateLinesAreas = function () {
        };
        // for overriding
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        AdaptLineGraphComponent.prototype.restrictXPosTicks = function () {
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptLineGraphComponent.prototype.mapDataFromSeries = function (series) {
            var _this = this;
            return series.map(function (item) {
                var data = item.data.map(function (tt, index) {
                    return {
                        date: _this.xAxis.categories[index],
                        data: tt
                    };
                });
                return {
                    name: item.name,
                    hidden: item.hidden,
                    data: data
                };
            });
        };
        AdaptLineGraphComponent.prototype.getDataYValues = function (row) {
            return row.data.map(function (item) { return item.data; });
        };
        AdaptLineGraphComponent.prototype.nameof = function (key) {
            return nameof(key);
        };
        AdaptLineGraphComponent.prototype._detectViewChanges = function () {
            var _this = this;
            this._updateChart(this._dim); // Update chart data
            i1.SafeCdr.detectChanges(this._changeDetectorRef);
            this._ngZone.onStable
                .pipe(operators.take(1), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._ngZone.run(function () {
                    _this.chartComponent.redrawChart(); // Redraw chart using the latest dimensions
                    i1.SafeCdr.detectChanges(_this._changeDetectorRef);
                });
            });
        };
        AdaptLineGraphComponent.prototype._initAxis = function (g, dim) {
            var axisWidth = dim.w - this._margin.left - this._margin.right;
            var ticks = this._getTicks().reverse();
            if (this.yAxis && this.yAxis.title) {
                g.append('g')
                    .attr('class', 'adapt-chart-axis-title')
                    .attr('transform', "rotate(-90) translate(-" + (dim.h - this._axisShift.bottom) / 2 + " " + this._axisShift.left / 2 + ")")
                    .style('opacity', this.supressAxles ? 0 : 1)
                    .append('text').text(this.yAxis.title)
                    .attr('text-anchor', 'middle')
                    .attr('transform', "translate(" + (this._axisShift.bottom / 2) + " 0)");
            }
            if (this.xAxis && this.xAxis.title) {
                g.append('g')
                    .attr('class', 'adapt-chart-axis-title adapt-chart-axis-title--x')
                    .attr('transform', "translate(" + (dim.w + this._axisShift.left) / 2 + " " + (dim.h + this.chartComponent.chartBottomPadding) + ")")
                    .style('opacity', this.supressAxles ? 0 : 1)
                    .append('text').text(this.xAxis.title)
                    .attr('text-anchor', 'middle')
                    .attr('transform', "translate(" + (this._axisShift.left) + " 0)");
            }
            if (this.xAxis && this.xAxis.categories) {
                this._x = this.xBrush = this.getXPosFunc(dim);
                this.restrictXPosTicks();
            }
            var axisBlock = g.append('g').attr('class', 'axis axis--x');
            this.renderXAxis(dim, axisBlock);
            if (this.rotateXAxis) {
                this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
                this.chartComponent.updateChartBottomPadding(axisWidth, g, this.xAxis, this.rotateXAxis);
            }
            var ticksOrCategs = i1.isUndefined(this.yAxis.categories) ? ticks : this.yAxis.categories.reverse();
            // TODO: can be y axis categories?
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this._y = this.getYPosFunc(dim, ticksOrCategs);
            this.renderYAxis(g.append('g').attr('class', 'axis axis--y'), ticksOrCategs, dim);
        };
        AdaptLineGraphComponent.prototype.renderYAxis = function (g, ticksVal, dim) {
            g.attr('transform', "translate(" + this._margin.left + ", 0)")
                .style('opacity', this.supressAxles ? 0 : 1)
                .call(this.getYAxisRenderer(ticksVal, dim));
        };
        AdaptLineGraphComponent.prototype.getYAxisRenderer = function (ticksVal, dim) {
            var _this = this;
            return d3__namespace.axisLeft(this._y)
                .ticks(ticksVal)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .tickValues(ticksVal)
                .tickFormat(function (d) {
                if (_this.scientificMode) {
                    return new BigNumber__default["default"](d).toPrecision(2, 2);
                }
                else {
                    return _this._cutNumber.transform(d, 0);
                }
            })
                .tickSize(-dim.w + (this._margin.left + this._margin.right))
                .tickPadding(3);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptLineGraphComponent.prototype.renderXAxis = function (dim, el) {
            el.attr('transform', "translate(" + this._margin.left + ", " + (dim.h - this._margin.top - this._margin.bottom) + ")")
                .style('opacity', this.supressAxles ? 0 : 1)
                .call(
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this.getXAxisLineRenderer(dim));
        };
        AdaptLineGraphComponent.prototype._updateXAxis = function (dim) {
            this._x = this.getXPosFunc(dim, this.showSlider && this.slidePointsCount ? this.sliderDomainData : []);
            if (this._g) {
                var axisBlock = this._g.select('.axis--x');
                axisBlock.attr('class', "axis axis--x " + (this.rotateXAxis ? 'adapt-chart-axis__hidden' : ''));
                this.renderXAxis(dim, axisBlock);
                this.chartComponent.transformAxisTitles(axisBlock, this.rotateXAxis);
                this.chartComponent.updateChartBottomPadding(dim.w - this._margin.left - this._margin.right, this._g, this.xAxis, this.rotateXAxis);
                axisBlock.classed('adapt-chart-axis__hidden', null);
                this._g.select('.adapt-chart-axis-title--x')
                    .transition()
                    .duration(this.duration)
                    .attr('transform', "translate(" + (dim.w + this._axisShift.left) / 2 + " " + (dim.h + this.chartComponent.chartBottomPadding) + ")");
                this._g.selectAll('.adapt-chart-axis-title')
                    .style('opacity', this.supressAxles ? 0 : 1);
            }
        };
        AdaptLineGraphComponent.prototype._updateYAxis = function (dim) {
            var ticks = this._getTicks().reverse();
            var ticksOrCategs = i1.isUndefined(this.yAxis.categories) ? ticks : this.yAxis.categories.reverse();
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this._y = this.getYPosFunc(dim, ticksOrCategs);
            if (this._g) {
                this._g.select('.axis--y')
                    .attr('transform', "translate(" + this._margin.left + ", 0)")
                    .transition()
                    .duration(this.duration)
                    .call(
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                this.getYAxisRenderer(ticksOrCategs, dim));
                this.renderYAxis(this._g.select('.axis--y')
                    .transition()
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    .duration(this.duration), ticksOrCategs, dim);
            }
        };
        AdaptLineGraphComponent.prototype._updateAxis = function (dim) {
            this._updateXAxis(dim);
            this._updateYAxis(dim);
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptLineGraphComponent.prototype.getCircleLine = function (el) {
            return d3__namespace
                .select(el.closest('.line-chart-line-g'))
                .select('.line-chart-lines');
        };
        AdaptLineGraphComponent.prototype._updateDataLines = function () {
            var _this = this;
            this._line = this.getLineRenderer();
            if (this._g) {
                this._g.selectAll('.line-chart-lines').attr('d', this._line);
                this._g.selectAll('.line-graph-circle').each(function (d, i, g) {
                    _this.setCirclePosition(d3__namespace.select(g[i]));
                });
            }
            this.toggleLineCirclesVisibility(this._g, this.showLineCircles);
            this.updateLinesAreas();
        };
        AdaptLineGraphComponent.prototype._initData = function () {
            this._data = this.mapDataFromSeries(this.series);
        };
        AdaptLineGraphComponent.prototype._getTicks = function () {
            var _this = this;
            var data = [];
            this._data.forEach(function (row) {
                data = data.concat(_this.getDataYValues(row));
            });
            var max = Math.max.apply(Math, __spreadArray([], __read(data)));
            if (max === 0) {
                max = 1;
            }
            if (this.thresholdLine && this.thresholdLine > max) {
                max = this.thresholdLine;
            }
            var currentStep = Math.pow(10, Math.floor(Math.log10(max))) / 2;
            var step = Math.pow(10, Math.floor(Math.log10(max))) / 2;
            var count = Math.floor(max / currentStep) + 1;
            while (count >= this._maxTicksCount) {
                currentStep += step;
                count = Math.floor(max / currentStep) + 1;
            }
            return (new Array(count)).fill(0).map(function (v, id) { return (id + 1) * currentStep; });
        };
        AdaptLineGraphComponent.prototype._initClipPath = function () {
            // Add a clipPath: we restrict lines appearing by explicitly setting width and height - everything out of this area won't be drawn
            // useful for the situation once we show the graph slider
            this._g.append('defs').append('svg:clipPath')
                .attr('id', this._id + "_clip")
                .append('svg:rect')
                .attr('width', this._dim.w - (this._margin.left + this._margin.right))
                .attr('height', this._dim.h - (this._margin.top + this._margin.bottom))
                .attr('x', 0)
                .attr('y', 0);
        };
        AdaptLineGraphComponent.prototype._clear = function () {
            this._data = [];
        };
        AdaptLineGraphComponent.prototype._updateThresholdLineArea = function () {
            var _this = this;
            var thresholdLineAreaClass = 'threshold-line-area';
            var thresholdLineArea;
            if (this._g) {
                thresholdLineArea = this._g.select("." + thresholdLineAreaClass);
            }
            if (!this.thresholdLine && thresholdLineArea) {
                thresholdLineArea.remove();
                return;
            }
            if (thresholdLineArea === null || thresholdLineArea === void 0 ? void 0 : thresholdLineArea.empty()) {
                thresholdLineArea = this._g.append('g')
                    .attr('class', thresholdLineAreaClass);
                thresholdLineArea.append('rect')
                    .attr('class', 'threshold-area-rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('fill', '#000000')
                    .attr('style', 'pointer-events: none; opacity: .1;');
                var defs = thresholdLineArea.append('defs');
                defs.append('marker')
                    .attr('class', 'threshold-line-marker')
                    .attr('id', this._id + "-marker-start")
                    .attr('viewBox', '0 0 6 8')
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 8)
                    .attr('refX', 5)
                    .attr('refY', 4)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M 0 0 L 6 4 L 0 8 z');
                defs.append('marker')
                    .attr('class', 'threshold-line-marker')
                    .attr('id', this._id + "-marker-end")
                    .attr('viewBox', '0 0 6 8')
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 8)
                    .attr('refX', 1)
                    .attr('refY', 4)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M 0 4 L 6 0 L 6 8 z');
                thresholdLineArea.append('line')
                    .attr('class', 'threshold-line')
                    .attr('stroke-width', 1)
                    .attr('marker-start', "url(#" + this._id + "-marker-start)")
                    .attr('marker-end', "url(#" + this._id + "-marker-end)");
                thresholdLineArea.append('text')
                    .attr('class', 'threshold-line-title-background');
                thresholdLineArea.append('text')
                    .attr('class', 'threshold-line-title');
            }
            var maxTick = this._getTicks().pop(); // get the max tick
            var chartDataAreaWidth = this._dim.w - this._margin.left - this._margin.right;
            var chartDataAreaHeight = this._dim.h - this._margin.top - this._margin.bottom;
            var thresholdLineAreaHeight = chartDataAreaHeight - chartDataAreaHeight / maxTick * this.thresholdLine;
            if (thresholdLineArea) {
                thresholdLineArea.select('rect.threshold-area-rect')
                    .transition()
                    .duration(this.duration)
                    .attr('transform', "translate(" + this._margin.left + ", 0)")
                    .attr('width', chartDataAreaWidth)
                    .attr('height', thresholdLineAreaHeight);
                thresholdLineArea.select('line.threshold-line')
                    .transition()
                    .duration(this.duration)
                    .attr('x1', this._margin.left)
                    .attr('x2', this._dim.w)
                    .attr('y1', thresholdLineAreaHeight)
                    .attr('y2', thresholdLineAreaHeight);
                thresholdLineArea.select('text.threshold-line-title-background')
                    .transition()
                    .duration(this.duration)
                    .attr('x', this._margin.left - 8)
                    .attr('y', thresholdLineAreaHeight)
                    .attr('text-anchor', 'end')
                    .attr('dy', '.32em')
                    .text(this.scientificMode ? new BigNumber__default["default"](this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
                thresholdLineArea.select('text.threshold-line-title')
                    .transition()
                    .duration(this.duration)
                    .attr('x', this._margin.left - 8)
                    .attr('y', thresholdLineAreaHeight)
                    .attr('text-anchor', 'end')
                    .attr('dy', '.32em')
                    .text(this.scientificMode ? new BigNumber__default["default"](this.thresholdLine).toPrecision(2, 2) : this.thresholdLine);
            }
            // If we have the same tick as the thresholdLine - remove that
            d3__namespace.selectAll('g.tick')
                .filter(function (d) { return d === _this.thresholdLine; })
                .remove();
        };
        AdaptLineGraphComponent.prototype._drawDropShadow = function () {
            var defs = this._g
                .append('defs');
            var filter = defs.append('filter')
                .attr('id', 'drop-shadow')
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '180%')
                .attr('height', '180%')
                .attr('filterUnits', 'userSpaceOnUse');
            filter
                .append('feGaussianBlur')
                .attr('in', 'SourceAlpha')
                .attr('stdDeviation', 3);
            filter
                .append('feOffset')
                .attr('dx', 0)
                .attr('dy', 1)
                .attr('result', 'offsetBlur');
            filter
                .append('feOffset')
                .attr('dx', 0)
                .attr('dy', 2)
                .attr('result', 'offsetBlur');
            filter
                .append('feColorMatrix')
                .attr('type', 'matrix')
                .attr('values', '0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.22 0');
            var feMerge = filter
                .append('feMerge');
            feMerge
                .append('feMergeNode');
            feMerge
                .append('feMergeNode')
                .attr('in', 'SourceGraphic');
            feMerge
                .append('feMergeNode')
                .attr('in', 'SourceGraphic');
        };
        return AdaptLineGraphComponent;
    }(AdaptLineGraphAbstract));
    AdaptLineGraphComponent.ɵfac = function AdaptLineGraphComponent_Factory(t) { return new (t || AdaptLineGraphComponent)(i0__namespace.ɵɵdirectiveInject(CutNumberPipe), i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptDeviceDetectionService), i0__namespace.ɵɵdirectiveInject(ChartColorService), i0__namespace.ɵɵdirectiveInject(i0__namespace.NgZone), i0__namespace.ɵɵdirectiveInject(i0__namespace.ChangeDetectorRef)); };
    AdaptLineGraphComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptLineGraphComponent, selectors: [["adapt-line-graph"]], viewQuery: function AdaptLineGraphComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(_c0$4, 7);
                i0__namespace.ɵɵviewQuery(AdaptChartComponent, 7);
                i0__namespace.ɵɵviewQuery(AdaptAreaGraphSliderComponent, 5);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartSliderComponent = _t.first);
            }
        }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", colorsPalette: "colorsPalette", supressAxles: "supressAxles", noDataText: "noDataText", xAxis: "xAxis", yAxis: "yAxis", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", updateChart: "updateChart", showLineCircles: "showLineCircles", rotateXAxis: "rotateXAxis", showSlider: "showSlider", slidePointsCount: "slidePointsCount", disallowPadding: "disallowPadding", scientificMode: "scientificMode", thresholdLine: "thresholdLine", legend: "legend", series: "series" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0__namespace.ɵɵProvidersFeature([CutNumberPipe]), i0__namespace.ɵɵInheritDefinitionFeature, i0__namespace.ɵɵNgOnChangesFeature], decls: 8, vars: 14, consts: [[3, "width", "height", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "header", "noDataText", "updateChart", "dataBuilder", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd", 4, "ngIf"], ["tooltipTpl", ""], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd"], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptLineGraphComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵelementStart(0, "adapt-chart", 0);
                i0__namespace.ɵɵlistener("categoryShow", function AdaptLineGraphComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptLineGraphComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptLineGraphComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptLineGraphComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
                i0__namespace.ɵɵtext(1, "\n  ");
                i0__namespace.ɵɵtemplate(2, AdaptLineGraphComponent_adapt_area_graph_slider_2_Template, 1, 7, "adapt-area-graph-slider", 1);
                i0__namespace.ɵɵtext(3, "\n");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(4, "\n\n");
                i0__namespace.ɵɵtemplate(5, AdaptLineGraphComponent_ng_template_5_Template, 26, 7, "ng-template", null, 2, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(7, "\n");
            }
            if (rf & 2) {
                i0__namespace.ɵɵproperty("width", ctx.width)("height", ctx.height)("legend", ctx.legend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("header", ctx.header)("noDataText", ctx.noDataText)("updateChart", ctx._updateChartBind)("dataBuilder", ctx._dataBuilderBind)("colorsPalette", ctx.colorsPalette);
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵproperty("ngIf", ctx.showSlider && ctx.slidePointsCount && ctx.chartWidth);
            }
        }, directives: [AdaptChartComponent, i3__namespace.NgIf, AdaptAreaGraphSliderComponent], encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptLineGraphComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-line-graph',
                        templateUrl: './line-graph.component.html',
                        providers: [CutNumberPipe],
                        encapsulation: i0.ViewEncapsulation.None
                    }]
            }], function () { return [{ type: CutNumberPipe }, { type: i1__namespace.AdaptDeviceDetectionService }, { type: ChartColorService }, { type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }]; }, { tooltipTemplate: [{
                    type: i0.ViewChild,
                    args: ['tooltipTpl', { static: true }]
                }], chartComponent: [{
                    type: i0.ViewChild,
                    args: [AdaptChartComponent, { static: true }]
                }], chartSliderComponent: [{
                    type: i0.ViewChild,
                    args: [AdaptAreaGraphSliderComponent, { static: false }]
                }], backgroundColor: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], header: [{
                    type: i0.Input
                }], colorsPalette: [{
                    type: i0.Input
                }], supressAxles: [{
                    type: i0.Input
                }], noDataText: [{
                    type: i0.Input
                }], xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }], suppressHeader: [{
                    type: i0.Input
                }], suppressLegend: [{
                    type: i0.Input
                }], tooltip: [{
                    type: i0.Input
                }], dataBuilder: [{
                    type: i0.Input
                }], updateChart: [{
                    type: i0.Input
                }], showLineCircles: [{
                    type: i0.Input
                }], rotateXAxis: [{
                    type: i0.Input
                }], showSlider: [{
                    type: i0.Input
                }], slidePointsCount: [{
                    type: i0.Input
                }], disallowPadding: [{
                    type: i0.Input
                }], scientificMode: [{
                    type: i0.Input
                }], thresholdLine: [{
                    type: i0.Input
                }], legend: [{
                    type: i0.Input
                }], series: [{
                    type: i0.Input
                }], clickChart: [{
                    type: i0.Output
                }], categoryShow: [{
                    type: i0.Output
                }], categoryHide: [{
                    type: i0.Output
                }] });
    })();

    function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template(rf, ctx) {
        if (rf & 1) {
            var _r4_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "adapt-area-graph-slider", 3);
            i0__namespace.ɵɵlistener("rangeChanged", function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_rangeChanged_0_listener($event) { i0__namespace.ɵɵrestoreView(_r4_1); var ctx_r3 = i0__namespace.ɵɵnextContext(); return ctx_r3.rangeChanged($event); })("scrollEnd", function AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template_adapt_area_graph_slider_scrollEnd_0_listener() { i0__namespace.ɵɵrestoreView(_r4_1); var ctx_r5 = i0__namespace.ɵɵnextContext(); return ctx_r5.scrollEnd(); });
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r0 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵproperty("data", ctx_r0.sliderData)("xAxis", ctx_r0.xAxis)("slidePointsCount", ctx_r0.slidePointsCount)("customColors", ctx_r0.legend == null ? null : ctx_r0.legend.customColors)("xBrush", ctx_r0.xBrush)("leftShift", ctx_r0.leftShift)("containerWidth", ctx_r0.chartWidth);
        }
    }
    function AdaptAreaGraphComponent_ng_template_5_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n  ");
            i0__namespace.ɵɵelementStart(1, "div", 4);
            i0__namespace.ɵɵtext(2, "\n    ");
            i0__namespace.ɵɵelementStart(3, "div", 5);
            i0__namespace.ɵɵtext(4, "\n      ");
            i0__namespace.ɵɵelement(5, "span", 6);
            i0__namespace.ɵɵtext(6, "\n      ");
            i0__namespace.ɵɵelementStart(7, "span", 7);
            i0__namespace.ɵɵtext(8);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(10, "\n    ");
            i0__namespace.ɵɵelementStart(11, "div");
            i0__namespace.ɵɵtext(12);
            i0__namespace.ɵɵelementStart(13, "span");
            i0__namespace.ɵɵelementStart(14, "b");
            i0__namespace.ɵɵtext(15);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(16, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(17, "\n\n    ");
            i0__namespace.ɵɵelementStart(18, "div");
            i0__namespace.ɵɵtext(19);
            i0__namespace.ɵɵelementStart(20, "span");
            i0__namespace.ɵɵelementStart(21, "b");
            i0__namespace.ɵɵtext(22);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(23, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(24, "\n  ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(25, "\n");
        }
        if (rf & 2) {
            var data_r6 = ctx.data;
            var ctx_r2 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵstyleProp("background", data_r6 == null ? null : data_r6.color);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r6.category);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate1("\n      ", ctx_r2.getTooltipXValueTitle(), ":\n      ");
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r6.xValue);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate1("\n      ", ctx_r2.yAxis == null ? null : ctx_r2.yAxis.title, ":\n      ");
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r6.yValue);
        }
    }
    var chartCounter = 1;
    var AdaptAreaGraphComponent = /** @class */ (function (_super) {
        __extends(AdaptAreaGraphComponent, _super);
        function AdaptAreaGraphComponent() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this._data = [];
            _this._series = [];
            _this.circleRadius = 4;
            _this.areaOpacity = 0.25;
            _this.areaOpacityForHovered = 0.75;
            /**
             * Output that emits each time chart category shown
             * @since 12.11.0
             */
            _this.categoryShow = new i0.EventEmitter();
            /**
             * Output that emits each time chart category hidden
             * @since 12.11.0
             */
            _this.categoryHide = new i0.EventEmitter();
            return _this;
        }
        AdaptAreaGraphComponent.prototype.getTooltipXValueTitle = function () {
            return 'x';
        };
        AdaptAreaGraphComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this._id = "area-graph-" + chartCounter++;
        };
        AdaptAreaGraphComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // The change consists of two line graphs (one is the main, second in the slider),
            // so need to check the chart view after they both have been drawn
            rxjs.timer(0, rxjs.asapScheduler)
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._detectViewChanges();
            });
        };
        AdaptAreaGraphComponent.prototype.getXMaxValue = function (data) {
            var maxYVal = data[0].xyPointData[0].x;
            data.forEach(function (dataItem) {
                // assume that last value is the biggest value
                var value = dataItem.xyPointData[dataItem.xyPointData.length - 1].x;
                if (value > maxYVal) {
                    maxYVal = value;
                }
            });
            return maxYVal;
        };
        AdaptAreaGraphComponent.prototype.getXMinValue = function (data) {
            var minYVal = data[0].xyPointData[0].x;
            data.forEach(function (dataItem) {
                // assume that first value is the lowest value
                var value = dataItem.xyPointData[0].x;
                if (value < minYVal) {
                    minYVal = value;
                }
            });
            return minYVal;
        };
        AdaptAreaGraphComponent.prototype.getCircleColor = function () {
            return 'transparent';
        };
        AdaptAreaGraphComponent.prototype.getLineRenderer = function () {
            var _this = this;
            return d3__namespace.line()
                .x(function (d) { return _this._xPos(d.x); })
                .y(function (d) { return _this._y(d.y); });
        };
        AdaptAreaGraphComponent.prototype.getXPosFunc = function (dim, domain) {
            if (domain === void 0) { domain = []; }
            var _b = __read(domain, 2), min = _b[0], max = _b[1];
            return d3__namespace.scaleLinear()
                .range([0, dim.w - (this._margin.left + this._margin.right)])
                .domain([min || this.getXMinValue(this._data), max || this.getXMaxValue(this._data)]);
        };
        AdaptAreaGraphComponent.prototype.getYPosFunc = function (dim, ticksVal) {
            return d3__namespace.scaleLinear()
                .range([0, dim.h - this._margin.bottom - this._margin.top])
                .domain([ticksVal[0], 0]);
        };
        AdaptAreaGraphComponent.prototype.getXAxisLineRenderer = function (dim) {
            var _a;
            var baseRenderer = _super.prototype.getXAxisLineRenderer.call(this, dim);
            var cats = __spreadArray([], __read(this.xAxis.categories));
            if (cats && cats.length) {
                // for proper rendering with categories
                var maxX = this.getXMaxValue(this._data);
                var minX_1 = this.getXMinValue(this._data);
                var minMaxRange = maxX - minX_1;
                var tickStep_1 = minMaxRange / (cats.length - 1);
                var tickValuesArray = cats.map(function (category, index) { return minX_1 + tickStep_1 * index; });
                if (this.showSlider && ((_a = this.sliderDomainData) === null || _a === void 0 ? void 0 : _a.length)) {
                    var _b = __read(this.sliderDomainData, 2), min_1 = _b[0], max_1 = _b[1];
                    tickValuesArray = tickValuesArray.filter(function (tick, index) {
                        if (lodashEs.inRange(tick, min_1, max_1)) {
                            return true;
                        }
                        cats[index] = null;
                    });
                }
                return baseRenderer
                    .tickValues(tickValuesArray)
                    .tickFormat(function (val, ind) { return cats.filter(function (category) { return !!category; })[ind]; });
            }
            if (this.showSlider && this.slidePointsCount) {
                baseRenderer.ticks(this.slidePointsCount);
            }
            if (this.formatXAxisValue) {
                return baseRenderer.tickFormat(this.formatXAxisValue);
            }
            return baseRenderer;
        };
        AdaptAreaGraphComponent.prototype.mapDataFromSeries = function (series) {
            return series.map(function (item) {
                return {
                    name: item.name,
                    hidden: item.hidden,
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    data: item.data,
                    xyPointData: item.data, // used in area
                };
            });
        };
        // TODO check for type improvement
        // eslint-disable-next-line
        AdaptAreaGraphComponent.prototype.drawAreaForSeries = function (lineWrapper, dt, i) {
            var _this = this;
            lineWrapper.append('path')
                .datum(dt.xyPointData)
                .classed('line-graph-transition line-chart-area', true)
                .attr('clip-path', "url(#" + this._id + "_clip)")
                .attr('fill', this._colors[i])
                .attr('fill-opacity', this.areaOpacity)
                .attr('stroke', 'none')
                .attr('d', this.getAreaFilling())
                .on('mouseover', function (data, ind, group) {
                _this.fillAreaDarkerColor(group[ind]);
            })
                .on('mouseout', function (data, ind, group) {
                _this.fillAreaDefaultColor(group[ind]);
            });
        };
        AdaptAreaGraphComponent.prototype.onCircleMouseover = function (circleEl, dt, d) {
            _super.prototype.onCircleMouseover.call(this, circleEl, dt, d);
            this.fillAreaDarkerColor(d3__namespace.select(circleEl.closest('.line-chart-line-g')).select('.line-chart-area').node());
        };
        AdaptAreaGraphComponent.prototype.onCircleMouseout = function (circleEl) {
            _super.prototype.onCircleMouseout.call(this, circleEl);
            this.fillAreaDefaultColor(d3__namespace.select(circleEl.closest('.line-chart-line-g')).select('.line-chart-area').node());
        };
        AdaptAreaGraphComponent.prototype.getCircleDarkenColor = function (baseColor, circleParentLineSelection) {
            return this._colorService.getDarken(circleParentLineSelection.attr('stroke'), .15, i1.ColorType.HEX);
        };
        AdaptAreaGraphComponent.prototype.getDataForCirclesOrLines = function (dt) {
            return dt.xyPointData;
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptAreaGraphComponent.prototype.setCirclePosition = function (circleSel) {
            var _this = this;
            return circleSel
                .attr('cx', function (d) { return _this._xPos(d.x); })
                .attr('cy', function (d) { return _this._y(d.y); });
        };
        AdaptAreaGraphComponent.prototype.updateLinesAreas = function () {
            var _this = this;
            this._g.selectAll('.line-chart-area').each(function (dat, i, g) {
                d3__namespace.select(g[i]).attr('d', _this.getAreaFilling());
            });
        };
        AdaptAreaGraphComponent.prototype.restrictXPosTicks = function () {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var ticksCount = this._x.ticks();
            if (this.showSlider && this.slidePointsCount) {
                this._x = d3__namespace.scaleLinear()
                    .range([0, this._dim.w - (this._margin.left + this._margin.right)])
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    .domain([ticksCount[0], ticksCount[this.slidePointsCount]]);
            }
        };
        AdaptAreaGraphComponent.prototype.getTooltipData = function (baseColor, dt, d) {
            return {
                color: baseColor,
                category: dt.name,
                xValue: d.x,
                yValue: this.scientificMode ? new BigNumber__default["default"](d.y).toPrecision(2, 2) : d.y,
            };
        };
        AdaptAreaGraphComponent.prototype.getDataYValues = function (row) {
            return row.xyPointData.map(function (item) { return item.y; });
        };
        Object.defineProperty(AdaptAreaGraphComponent.prototype, "_xPos", {
            get: function () {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                return this._x;
            },
            enumerable: false,
            configurable: true
        });
        AdaptAreaGraphComponent.prototype.getAreaFilling = function () {
            var _this = this;
            return d3__namespace.area()
                .x(function (d) { return _this._xPos(d.x); })
                .y0(this._y(0))
                .y1(function (d) { return _this._y(d.y); });
        };
        AdaptAreaGraphComponent.prototype.fillAreaDarkerColor = function (el) {
            d3__namespace.select(el).attr('fill-opacity', this.areaOpacityForHovered);
        };
        AdaptAreaGraphComponent.prototype.fillAreaDefaultColor = function (el) {
            d3__namespace.select(el).attr('fill-opacity', this.areaOpacity);
        };
        return AdaptAreaGraphComponent;
    }(AdaptLineGraphComponent));
    AdaptAreaGraphComponent.ɵfac = /*@__PURE__*/ function () { var ɵAdaptAreaGraphComponent_BaseFactory; return function AdaptAreaGraphComponent_Factory(t) { return (ɵAdaptAreaGraphComponent_BaseFactory || (ɵAdaptAreaGraphComponent_BaseFactory = i0__namespace.ɵɵgetInheritedFactory(AdaptAreaGraphComponent)))(t || AdaptAreaGraphComponent); }; }();
    AdaptAreaGraphComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptAreaGraphComponent, selectors: [["adapt-area-graph"]], inputs: { formatXAxisValue: "formatXAxisValue", getTooltipXValueTitle: "getTooltipXValueTitle" }, outputs: { categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0__namespace.ɵɵProvidersFeature([CutNumberPipe]), i0__namespace.ɵɵInheritDefinitionFeature], decls: 8, vars: 14, consts: [[3, "width", "height", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "header", "noDataText", "updateChart", "dataBuilder", "colorsPalette", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd", 4, "ngIf"], ["tooltipTpl", ""], [3, "data", "xAxis", "slidePointsCount", "customColors", "xBrush", "leftShift", "containerWidth", "rangeChanged", "scrollEnd"], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptAreaGraphComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵelementStart(0, "adapt-chart", 0);
                i0__namespace.ɵɵlistener("categoryShow", function AdaptAreaGraphComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptAreaGraphComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptAreaGraphComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptAreaGraphComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
                i0__namespace.ɵɵtext(1, "\n  ");
                i0__namespace.ɵɵtemplate(2, AdaptAreaGraphComponent_adapt_area_graph_slider_2_Template, 1, 7, "adapt-area-graph-slider", 1);
                i0__namespace.ɵɵtext(3, "\n");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(4, "\n\n");
                i0__namespace.ɵɵtemplate(5, AdaptAreaGraphComponent_ng_template_5_Template, 26, 7, "ng-template", null, 2, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(7, "\n");
            }
            if (rf & 2) {
                i0__namespace.ɵɵproperty("width", ctx.width)("height", ctx.height)("legend", ctx.legend)("data", ctx.series)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("tooltip", ctx.tooltip)("header", ctx.header)("noDataText", ctx.noDataText)("updateChart", ctx._updateChartBind)("dataBuilder", ctx._dataBuilderBind)("colorsPalette", ctx.colorsPalette);
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵproperty("ngIf", ctx.showSlider && ctx.slidePointsCount && ctx.chartWidth);
            }
        }, directives: [AdaptChartComponent, i3__namespace.NgIf, AdaptAreaGraphSliderComponent], encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptAreaGraphComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-area-graph',
                        templateUrl: '../line-graph/line-graph.component.html',
                        providers: [CutNumberPipe],
                        encapsulation: i0.ViewEncapsulation.None
                    }]
            }], null, { formatXAxisValue: [{
                    type: i0.Input
                }], categoryShow: [{
                    type: i0.Output
                }], categoryHide: [{
                    type: i0.Output
                }], getTooltipXValueTitle: [{
                    type: i0.Input
                }] });
    })();

    var AdaptPieChartAbstract = /** @class */ (function (_super) {
        __extends(AdaptPieChartAbstract, _super);
        function AdaptPieChartAbstract() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AdaptPieChartAbstract;
    }(AdaptChartAbstract));
    AdaptPieChartAbstract.ɵfac = /*@__PURE__*/ function () { var ɵAdaptPieChartAbstract_BaseFactory; return function AdaptPieChartAbstract_Factory(t) { return (ɵAdaptPieChartAbstract_BaseFactory || (ɵAdaptPieChartAbstract_BaseFactory = i0__namespace.ɵɵgetInheritedFactory(AdaptPieChartAbstract)))(t || AdaptPieChartAbstract); }; }();
    AdaptPieChartAbstract.ɵdir = /*@__PURE__*/ i0__namespace.ɵɵdefineDirective({ type: AdaptPieChartAbstract, inputs: { innerRadius: "innerRadius", series: "series" }, features: [i0__namespace.ɵɵInheritDefinitionFeature] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptPieChartAbstract, [{
                type: i0.Directive
            }], null, { innerRadius: [{
                    type: i0.Input
                }], series: [{
                    type: i0.Input
                }] });
    })();

    var _c0$3 = ["chart"];
    var _c1$2 = ["tooltipTpl"];
    function AdaptPieChartComponent_ng_template_4_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n      ");
            i0__namespace.ɵɵelementStart(1, "div", 3);
            i0__namespace.ɵɵtext(2, "\n        ");
            i0__namespace.ɵɵelement(3, "span", 4);
            i0__namespace.ɵɵtext(4, "\n        ");
            i0__namespace.ɵɵelementStart(5, "span", 5);
            i0__namespace.ɵɵtext(6);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(7, "\n        ");
            i0__namespace.ɵɵelementStart(8, "b");
            i0__namespace.ɵɵtext(9, "\n          ");
            i0__namespace.ɵɵelementStart(10, "span");
            i0__namespace.ɵɵtext(11);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(12, "\n          ");
            i0__namespace.ɵɵelementStart(13, "span");
            i0__namespace.ɵɵtext(14);
            i0__namespace.ɵɵpipe(15, "percent");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(16, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(17, "\n      ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(18, "\n    ");
        }
        if (rf & 2) {
            var data_r3 = ctx.data;
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵstyleProp("background-color", data_r3.color);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r3.category);
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵtextInterpolate(data_r3.value);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate1("(", i0__namespace.ɵɵpipeBind1(15, 5, data_r3.value / data_r3.total), ")");
        }
    }
    // TODO fix types
    var AdaptPieChartComponent = /** @class */ (function (_super) {
        __extends(AdaptPieChartComponent, _super);
        function AdaptPieChartComponent(_colorService) {
            var _this = _super.call(this) || this;
            _this._colorService = _colorService;
            _this.$this = _this;
            _this.showLegendTooltip = false;
            _this.clickChart = new i0.EventEmitter();
            /**
             * Output that emits each time chart category shown
             * @since 12.11.0
             */
            _this.categoryShow = new i0.EventEmitter();
            /**
             * Output that emits each time chart category hidden
             * @since 12.11.0
             */
            _this.categoryHide = new i0.EventEmitter();
            _this.alreadyChanged = false;
            _this._dataBuilder = (function (g, dim) {
                this._clear();
                this._g = g;
                this._dim = dim;
                this._renderChart();
            }).bind(_this);
            // TODO check if it can be refactored
            _this._updateChart = (function () {
                var _this = this;
                /* eslint-disable-next-line @typescript-eslint/no-this-alias */
                var __this = this;
                var oldData = this._pie(this._data);
                var data = this.series.map(function (d) {
                    return {
                        name: d.name,
                        y: _this._filter.indexOf(d.name) === -1 ? d.y : 0
                    };
                });
                this.total = data.reduce(function (acc, cur) {
                    acc += cur.y;
                    return acc;
                }, 0);
                this._initData();
                this._path = this._path.data(this._pie(this._data));
                this._path
                    .transition()
                    .duration(this.duration)
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    .attrTween('d', function (d, index) {
                    var startInter = d3__namespace.interpolate(oldData[index].startAngle, d.startAngle);
                    var endInter = d3__namespace.interpolate(oldData[index].endAngle, d.endAngle);
                    return function (t) {
                        d.startAngle = startInter(t);
                        d.endAngle = endInter(t);
                        return __this._arc(d);
                    };
                });
                if (this.innerRadius > 1) {
                    this._g
                        .selectAll('.adapt-pie-chart-main-label-sum')
                        .text("" + this.total);
                }
            }).bind(_this);
            _this.donutProportion = 16 / 25;
            _this._filter = [];
            _this._cls = {
                arc: 'arc',
                arcPart: 'arc-part',
                segment: 'arc-segment',
                sectorIdentifier: 'adapt-pie-chart-sector',
                summary: 'adapt-pie-chart-summary',
                summaryLabel: 'adapt-pie-chart-main-label',
                summaryText: 'adapt-pie-chart-main-label-sum'
            };
            _this._legend = {
                columns: 1,
                activeHover: true,
                activeClick: true,
                width: 250,
                customColors: null,
                items: []
            };
            _this._series = [];
            _this._legendTooltipPoint = { x: 0, y: 0 };
            return _this;
        }
        Object.defineProperty(AdaptPieChartComponent.prototype, "series", {
            get: function () {
                return this._series;
            },
            set: function (s) {
                this._series = s;
                if (s) {
                    this._updateFilter(s);
                }
                if (this.alreadyChanged) {
                    var options = this.chartComponent.getGroupAndDimensions();
                    this._g = options.group;
                    this._dim = {
                        w: options.w,
                        h: options.h
                    };
                }
                if (this._g && this._dim && this.chartComponent) {
                    this.chartComponent.updateLegend(this.series.map(function (item) { return ({
                        item: item.name,
                        hidden: !!item.hidden,
                        hover: false
                    }); }));
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptPieChartComponent.prototype, "legend", {
            get: function () {
                return {
                    customColors: this._legend.customColors,
                    activeHover: this._legend.activeHover,
                    activeClick: this._legend.activeClick,
                    columns: this._legend.columns,
                    width: this._legend.width,
                    items: (this.series && this.series.map(function (series) { return ({
                        item: series.name,
                        hidden: !!series.hidden
                    }); }))
                };
            },
            set: function (legend) {
                this._legend = Object.assign(this._legend, legend);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptPieChartComponent.prototype, "duration", {
            get: function () {
                return parseFloat(i1.ANIMATION_DURATION.fast) * 1000;
            },
            enumerable: false,
            configurable: true
        });
        AdaptPieChartComponent.prototype.ngOnInit = function () {
            if (this.header) {
                this.header.allowHideLegend = false;
            }
        };
        AdaptPieChartComponent.prototype.ngOnChanges = function () {
            if (this.alreadyChanged && this._g && this._dim) {
                this._data = [];
                this._updateFilter(this.series);
                this._clear();
                this._renderChart();
                this._updateChart();
            }
            this.alreadyChanged = true;
        };
        AdaptPieChartComponent.prototype.categoryEnter = function (categoryEvent) {
            var _this = this;
            var group = this._g.select("#adapt-pie-chart-sector-" + categoryEvent.id);
            var color = group.attr('fill');
            var hoverColor = this._colorService.getDarken(color, .15, i1.ColorType.HEX);
            this._initialColor = color;
            group.attr('fill', hoverColor);
            if (this.showLegendTooltip) {
                this._legendTooltipPoint.x = categoryEvent.event.clientX;
                this._legendTooltipPoint.y = categoryEvent.event.clientY;
                var id = categoryEvent.id;
                var tooltipTpl = this.tooltip || this.tooltipTemplate;
                var data = this.series.map(function (d) {
                    return {
                        name: d.name,
                        y: _this._filter.indexOf(d.name) === -1 ? d.y : 0
                    };
                });
                this.chartComponent.showTooltip(this._legendTooltipPoint, tooltipTpl, {
                    data: {
                        color: this._legend.customColors ? this._getCustomColorById(id) : this._colorService.getColor(id),
                        category: data[id].name,
                        value: this.series[id].y,
                        total: this.total,
                        data: this.series[id],
                        event: categoryEvent.event
                    }
                });
            }
        };
        AdaptPieChartComponent.prototype.categoryLeave = function (categoryEvent) {
            var group = this._g.select("#adapt-pie-chart-sector-" + categoryEvent.id);
            group.attr('fill', this._initialColor);
            if (this.showLegendTooltip) {
                this.chartComponent.hideTooltip();
            }
        };
        AdaptPieChartComponent.prototype.categoryMove = function (categoryEvent) {
            this._legendTooltipPoint.x = categoryEvent.event.clientX;
            this._legendTooltipPoint.y = categoryEvent.event.clientY;
            this.chartComponent.updateTooltip();
        };
        AdaptPieChartComponent.prototype.categoryShowHandler = function (category) {
            var categoryId = this._filter.indexOf(category);
            if (categoryId !== -1) {
                this._filter.splice(categoryId, 1);
                this._updateChart();
            }
            this.categoryShow.emit({ category: category });
        };
        AdaptPieChartComponent.prototype.categoryHideHandler = function (category) {
            this._filter.push(category);
            this._updateChart();
            this.categoryHide.emit({ category: category });
        };
        AdaptPieChartComponent.prototype.clickChartArea = function (e) {
            var _a;
            var target = e.target;
            var isSector = target.classList.contains(this._cls.segment);
            if (isSector) {
                var id = (_a = target.parentNode) === null || _a === void 0 ? void 0 : _a.getAttribute('id');
                var index = id.split('-').reverse()[0];
                var total = this.series.reduce(function (acc, v) { return acc + v.y; }, 0);
                var color = d3__namespace.select(target.parentNode).attr('fill');
                this.clickChart.emit({
                    event: e,
                    data: this.series[index],
                    color: color,
                    category: this.series[index].name,
                    value: this.series[index].y,
                    total: total
                });
            }
        };
        AdaptPieChartComponent.prototype._renderChart = function () {
            this._initData();
            if (this.innerRadius > 0) {
                this._addSummary();
            }
            this._createColor();
            this._createPie();
            this._createDataChart();
        };
        AdaptPieChartComponent.prototype._initData = function () {
            var _this = this;
            this._data = this.series.map(function (d) { return _this._filter.indexOf(d.name) === -1 ? d.y : 0; });
        };
        AdaptPieChartComponent.prototype._createColor = function () {
            var _this = this;
            this._colors = this._data.map(function (d, id) {
                return _this._legend.customColors ? _this._getCustomColorById(id) : _this._colorService.getColor(id);
            });
            this._radius = Math.min(this._dim.w, this._dim.h) / 2;
            this._g.attr('transform', "translate(" + this._radius + " " + this._radius + ")");
            this._arc = d3__namespace.arc()
                .innerRadius(this._getInnerRadius())
                .outerRadius(this._radius);
        };
        AdaptPieChartComponent.prototype._createPie = function () {
            this._pie = d3__namespace.pie()
                .sort(null);
        };
        AdaptPieChartComponent.prototype._createDataChart = function () {
            var _this = this;
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var __this = this;
            var tooltipTpl = this.tooltip || this.tooltipTemplate;
            var data = this.series.map(function (d) {
                return {
                    name: d.name,
                    y: _this._filter.indexOf(d.name) === -1 ? d.y : 0
                };
            });
            var arc = this._g.selectAll("." + this._cls.arc)
                .data(this._pie(this._data))
                .enter()
                .each(function (d) {
                d.outerRadius = _this._radius;
            })
                .append('g')
                .attr('class', this._cls.arcPart)
                .attr('id', function (d, id) { return _this._cls.sectorIdentifier + "-" + id; })
                .attr('fill', function (d, colorId) { return _this._colors[colorId]; });
            this.total = data.reduce(function (acc, cur) {
                acc += cur.y;
                return acc;
            }, 0);
            this._path = arc.append('path')
                .attr('class', this._cls.segment)
                .attr('d', this._arc);
            var tooltipAnchorPoint = { x: 0, y: 0 };
            this._path.on('mouseenter', function (d) {
                var _b = d3__namespace.event, clientX = _b.clientX, clientY = _b.clientY;
                var index = d.index, value = d.value;
                tooltipAnchorPoint.x = clientX;
                tooltipAnchorPoint.y = clientY;
                _this.chartComponent.showTooltip(tooltipAnchorPoint, tooltipTpl, {
                    data: {
                        color: __this._legend.customColors ? __this._getCustomColorById(index) : __this._colorService.getColor(index),
                        category: data[index].name,
                        value: value,
                        total: _this.total,
                        data: __this.series[index],
                        event: d3__namespace.event
                    }
                });
            });
            this._path.on('mousemove', function () {
                var _b = d3__namespace.event, clientX = _b.clientX, clientY = _b.clientY;
                tooltipAnchorPoint.x = clientX;
                tooltipAnchorPoint.y = clientY;
                _this.chartComponent.updateTooltip();
            });
            arc.on('mouseenter', function () {
                __this._initialColor = d3__namespace.select(this)
                    .attr('fill');
                d3__namespace.select(this)
                    .attr('fill', __this._colorService.getDarken(__this._initialColor, .15, i1.ColorType.HEX));
            })
                .on('mouseout', function () {
                __this.chartComponent.hideTooltip();
                d3__namespace.select(this)
                    .attr('fill', __this._initialColor);
            });
        };
        AdaptPieChartComponent.prototype._getInnerRadius = function () {
            var maxInnerRadius = this._radius * (1 + this.donutProportion) / 2;
            var minInnerRadius = this._radius * (1 - (1 - this.donutProportion) * 2);
            var innerRadius = 0;
            if (this.innerRadius > 0) {
                var node = this._g
                    .select("." + this._cls.summary)
                    .node();
                var width = node ? node.getBoundingClientRect().width : 0;
                minInnerRadius = Math.floor(width / 2) + 15;
            }
            if (!i1.isUndefined(this.innerRadius) || this.innerRadius > 0) {
                innerRadius = this.innerRadius;
                innerRadius = innerRadius < minInnerRadius ? minInnerRadius : innerRadius;
                innerRadius = innerRadius > maxInnerRadius ? maxInnerRadius : innerRadius;
            }
            return innerRadius;
        };
        AdaptPieChartComponent.prototype._clear = function () {
            if (this._g) {
                this._g.selectAll('*').remove();
            }
        };
        AdaptPieChartComponent.prototype._addSummary = function () {
            var _this = this;
            var data = this.series.map(function (d) {
                return {
                    name: d.name,
                    y: _this._filter.indexOf(d.name) === -1 ? d.y : 0
                };
            });
            var text = this._g
                .append('text')
                .attr('class', this._cls.summary);
            this.total = data.reduce(function (acc, cur) {
                acc += cur.y;
                return acc;
            }, 0);
            text.append('tspan')
                .attr('text-anchor', 'middle')
                .attr('x', 0)
                .attr('y', '-.4em')
                .attr('class', this._cls.summaryLabel)
                .text('Total');
            text.append('tspan')
                .attr('text-anchor', 'middle')
                .attr('x', 0)
                .attr('y', '.8em')
                .attr('class', this._cls.summaryText)
                .text("" + this.total);
        };
        AdaptPieChartComponent.prototype._getCustomColorById = function (id) {
            var customColors = this._legend.customColors;
            var len = customColors.length;
            var index = id % len;
            return customColors[index];
        };
        AdaptPieChartComponent.prototype._updateFilter = function (series) {
            var _this = this;
            this._filter = [];
            series.forEach(function (s) {
                if (s.hidden) {
                    _this._filter.push(s.name);
                }
            });
        };
        return AdaptPieChartComponent;
    }(AdaptPieChartAbstract));
    AdaptPieChartComponent.ɵfac = function AdaptPieChartComponent_Factory(t) { return new (t || AdaptPieChartComponent)(i0__namespace.ɵɵdirectiveInject(ChartColorService)); };
    AdaptPieChartComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptPieChartComponent, selectors: [["adapt-pie-chart"]], viewQuery: function AdaptPieChartComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(AdaptChartComponent, 7);
                i0__namespace.ɵɵviewQuery(_c0$3, 7);
                i0__namespace.ɵɵviewQuery(_c1$2, 7);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chart = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
            }
        }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", innerRadius: "innerRadius", showLegendTooltip: "showLegendTooltip", series: "series", legend: "legend" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0__namespace.ɵɵInheritDefinitionFeature, i0__namespace.ɵɵNgOnChangesFeature], decls: 7, vars: 12, consts: [[3, "width", "height", "header", "legend", "data", "backgroundColor", "suppressHeader", "suppressLegend", "tooltip", "noDataText", "updateChart", "dataBuilder", "categoryEnter", "categoryLeave", "categoryMove", "categoryShow", "categoryHide", "clickChart"], ["chart", ""], ["tooltipTpl", ""], [1, "adapt-pie-chart-tooltip"], [1, "adapt-pie-chart-tooltip__color"], [1, "adapt-pie-chart-tooltip__category"]], template: function AdaptPieChartComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵtext(0, "\n    ");
                i0__namespace.ɵɵelementStart(1, "adapt-chart", 0, 1);
                i0__namespace.ɵɵlistener("categoryEnter", function AdaptPieChartComponent_Template_adapt_chart_categoryEnter_1_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptPieChartComponent_Template_adapt_chart_categoryLeave_1_listener($event) { return ctx.categoryLeave($event); })("categoryMove", function AdaptPieChartComponent_Template_adapt_chart_categoryMove_1_listener($event) { return ctx.categoryMove($event); })("categoryShow", function AdaptPieChartComponent_Template_adapt_chart_categoryShow_1_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptPieChartComponent_Template_adapt_chart_categoryHide_1_listener($event) { return ctx.categoryHideHandler($event); })("clickChart", function AdaptPieChartComponent_Template_adapt_chart_clickChart_1_listener($event) { return ctx.clickChartArea($event); });
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(3, "\n\n    ");
                i0__namespace.ɵɵtemplate(4, AdaptPieChartComponent_ng_template_4_Template, 19, 7, "ng-template", null, 2, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(6, "\n  ");
            }
            if (rf & 2) {
                i0__namespace.ɵɵadvance(1);
                i0__namespace.ɵɵproperty("width", ctx.$this.width)("height", ctx.$this.height)("header", ctx.$this.header)("legend", ctx.$this.legend)("data", ctx.series)("backgroundColor", ctx.$this.backgroundColor)("suppressHeader", ctx.$this.suppressHeader)("suppressLegend", ctx.$this.suppressLegend)("tooltip", ctx.$this.tooltip)("noDataText", ctx.noDataText)("updateChart", ctx._updateChart)("dataBuilder", ctx._dataBuilder);
            }
        }, directives: [AdaptChartComponent], pipes: [i3__namespace.PercentPipe], encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptPieChartComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-pie-chart',
                        template: "\n    <adapt-chart #chart\n                 [width]=\"$this.width\"\n                 [height]=\"$this.height\"\n                 [header]=\"$this.header\"\n                 [legend]=\"$this.legend\"\n                 [data]=\"series\"\n                 [backgroundColor]=\"$this.backgroundColor\"\n                 [suppressHeader]=\"$this.suppressHeader\"\n                 [suppressLegend]=\"$this.suppressLegend\"\n                 [tooltip]=\"$this.tooltip\"\n                 (categoryEnter)=\"categoryEnter($event)\"\n                 (categoryLeave)=\"categoryLeave($event)\"\n                 (categoryMove)=\"categoryMove($event)\"\n                 (categoryShow)=\"categoryShowHandler($event)\"\n                 (categoryHide)=\"categoryHideHandler($event)\"\n                 (clickChart)=\"clickChartArea($event)\"\n                 [noDataText]=\"noDataText\"\n                 [updateChart]=\"_updateChart\"\n                 [dataBuilder]=\"_dataBuilder\"></adapt-chart>\n\n    <ng-template #tooltipTpl let-data=\"data\">\n      <div class=\"adapt-pie-chart-tooltip\">\n        <span [style.background-color]=\"data.color\" class=\"adapt-pie-chart-tooltip__color\"></span>\n        <span class=\"adapt-pie-chart-tooltip__category\">{{data.category}}</span>\n        <b>\n          <span>{{data.value}}</span>\n          <span>({{data.value / data.total | percent}})</span>\n        </b>\n      </div>\n    </ng-template>\n  ",
                        encapsulation: i0.ViewEncapsulation.None
                    }]
            }], function () { return [{ type: ChartColorService }]; }, { backgroundColor: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], header: [{
                    type: i0.Input
                }], suppressHeader: [{
                    type: i0.Input
                }], suppressLegend: [{
                    type: i0.Input
                }], tooltip: [{
                    type: i0.Input
                }], dataBuilder: [{
                    type: i0.Input
                }], innerRadius: [{
                    type: i0.Input
                }], showLegendTooltip: [{
                    type: i0.Input
                }], series: [{
                    type: i0.Input
                }], clickChart: [{
                    type: i0.Output
                }], categoryShow: [{
                    type: i0.Output
                }], categoryHide: [{
                    type: i0.Output
                }], legend: [{
                    type: i0.Input
                }], chartComponent: [{
                    type: i0.ViewChild,
                    args: [AdaptChartComponent, { static: true }]
                }], chart: [{
                    type: i0.ViewChild,
                    args: ['chart', { static: true }]
                }], tooltipTemplate: [{
                    type: i0.ViewChild,
                    args: ['tooltipTpl', { static: true }]
                }] });
    })();

    var AdaptScatterPlotAbstract = /** @class */ (function (_super) {
        __extends(AdaptScatterPlotAbstract, _super);
        function AdaptScatterPlotAbstract() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AdaptScatterPlotAbstract;
    }(AdaptChartAbstract));
    AdaptScatterPlotAbstract.ɵfac = /*@__PURE__*/ function () { var ɵAdaptScatterPlotAbstract_BaseFactory; return function AdaptScatterPlotAbstract_Factory(t) { return (ɵAdaptScatterPlotAbstract_BaseFactory || (ɵAdaptScatterPlotAbstract_BaseFactory = i0__namespace.ɵɵgetInheritedFactory(AdaptScatterPlotAbstract)))(t || AdaptScatterPlotAbstract); }; }();
    AdaptScatterPlotAbstract.ɵdir = /*@__PURE__*/ i0__namespace.ɵɵdefineDirective({ type: AdaptScatterPlotAbstract, inputs: { xAxis: "xAxis", yAxis: "yAxis", series: "series", hideAxises: "hideAxises" }, features: [i0__namespace.ɵɵInheritDefinitionFeature] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptScatterPlotAbstract, [{
                type: i0.Directive
            }], null, { xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }], series: [{
                    type: i0.Input
                }], hideAxises: [{
                    type: i0.Input
                }] });
    })();

    var _c0$2 = ["tooltipTpl"];
    function AdaptScatterPlotComponent_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n  ");
            i0__namespace.ɵɵelementStart(1, "div", 2);
            i0__namespace.ɵɵtext(2, "\n    ");
            i0__namespace.ɵɵelementStart(3, "div", 3);
            i0__namespace.ɵɵtext(4, "\n      ");
            i0__namespace.ɵɵelement(5, "span", 4);
            i0__namespace.ɵɵtext(6, "\n      ");
            i0__namespace.ɵɵelementStart(7, "span", 5);
            i0__namespace.ɵɵtext(8);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(10, "\n    ");
            i0__namespace.ɵɵelementStart(11, "div");
            i0__namespace.ɵɵtext(12);
            i0__namespace.ɵɵelementStart(13, "span");
            i0__namespace.ɵɵelementStart(14, "b");
            i0__namespace.ɵɵtext(15);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(16, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(17, "\n\n    ");
            i0__namespace.ɵɵelementStart(18, "div");
            i0__namespace.ɵɵtext(19);
            i0__namespace.ɵɵelementStart(20, "span");
            i0__namespace.ɵɵelementStart(21, "b");
            i0__namespace.ɵɵtext(22);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(23, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(24, "\n  ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(25, "\n");
        }
        if (rf & 2) {
            var data_r2 = ctx.data;
            var ctx_r1 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵstyleProp("background", data_r2 == null ? null : data_r2.color);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r2 == null ? null : data_r2.category);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate1("\n      ", ctx_r1.xAxis == null ? null : ctx_r1.xAxis.title, ":\n      ");
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r2.xValue);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate1("\n      ", ctx_r1.yAxis == null ? null : ctx_r1.yAxis.title, ":\n      ");
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(data_r2.yValue);
        }
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    var AdaptScatterPlotComponent = /** @class */ (function (_super) {
        __extends(AdaptScatterPlotComponent, _super);
        function AdaptScatterPlotComponent(_cutNumber, _deviceDetectionService, _colorService) {
            var _this = _super.call(this) || this;
            _this._cutNumber = _cutNumber;
            _this._deviceDetectionService = _deviceDetectionService;
            _this._colorService = _colorService;
            _this.alreadyChanged = false;
            _this.scientificMode = false;
            _this.clickChart = new i0.EventEmitter();
            /**
             * Output that emits each time chart category shown
             * @since 12.11.0
             */
            _this.categoryShow = new i0.EventEmitter();
            /**
             * Output that emits each time chart category hidden
             * @since 12.11.0
             */
            _this.categoryHide = new i0.EventEmitter();
            _this._series = [];
            _this._margin = {
                top: 0,
                right: 0,
                bottom: 25,
                left: 30
            };
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this._colors = [];
            _this._axisShift = {
                top: 0,
                right: 0,
                bottom: 25,
                left: 25
            };
            _this._axisScientificLeftShift = 60;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            _this._generatedData = [];
            _this._isDeselected = [];
            _this._legend = {
                columns: 1,
                activeHover: true,
                activeClick: true,
                width: 250,
                customColors: null,
                items: []
            };
            _this._updateChart = function (dim) {
                _this._updatedScatterChart(dim);
            };
            _this._dataBuilder = function (g, dim) {
                _this._g = g;
                _this._dim = dim;
                _this._initAxis(g, dim);
                _this._drawLines(g);
                _this._drawDropShadow();
            };
            return _this;
        }
        Object.defineProperty(AdaptScatterPlotComponent.prototype, "series", {
            get: function () {
                return this._series;
            },
            set: function (s) {
                var _this = this;
                this._series = s;
                this._isDeselected = [];
                s.forEach(function (series) {
                    if (series.hidden) {
                        _this._isDeselected.push(series.name);
                    }
                });
                if (this.alreadyChanged) {
                    var options = this.chartComponent.getGroupAndDimensions();
                    this._g = options.group;
                    this._dim = {
                        w: options.w,
                        h: options.h
                    };
                }
                if (this._g && this._dim && this.chartComponent) {
                    this.chartComponent.updateLegend(this.series.map(function (item) { return item.name; }));
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptScatterPlotComponent.prototype, "legend", {
            get: function () {
                return {
                    customColors: this._legend.customColors,
                    activeHover: this._legend.activeHover,
                    activeClick: this._legend.activeClick,
                    columns: this._legend.columns,
                    width: this._legend.width,
                    items: (this.series && this.series.map(function (series) { return ({
                        item: series.name,
                        hidden: !!series.hidden
                    }); }))
                };
            },
            set: function (legend) {
                this._legend = Object.assign(this._legend, legend);
                if (this.alreadyChanged) {
                    this.chartComponent.redrawChart();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptScatterPlotComponent.prototype, "duration", {
            get: function () {
                return parseFloat(i1.ANIMATION_DURATION.fast) * 1000;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AdaptScatterPlotComponent.prototype, "axisShiftLeft", {
            get: function () {
                return this.scientificMode ? this._axisScientificLeftShift : this._axisShift.left;
            },
            enumerable: false,
            configurable: true
        });
        AdaptScatterPlotComponent.prototype.ngOnInit = function () {
            if (this.isMobile()) {
                this._margin.left = 40;
            }
            if (this.xAxis && this.xAxis.title) {
                this._margin.bottom += this._axisShift.bottom;
            }
            if (this.yAxis && this.yAxis.title) {
                this._margin.left += this.axisShiftLeft;
            }
            this.alreadyChanged = true;
        };
        AdaptScatterPlotComponent.prototype.isMobile = function () {
            return this._deviceDetectionService.deviceMobile() || this._deviceDetectionService.deviceTablet();
        };
        AdaptScatterPlotComponent.prototype.categoryShowHandler = function (category) {
            var _this = this;
            var ind = this._isDeselected.indexOf(category);
            if (ind !== -1) {
                this._isDeselected.splice(ind, 1);
            }
            this._updatedScatterChart(this._dim);
            this.series.forEach(function (item, index) {
                if (item.name.indexOf(category) !== -1) {
                    item.hidden = false;
                    _this._g
                        .select("[data-line-graph-id='" + index + "']")
                        .style('transition', 'all .3s ease')
                        .style('opacity', '1')
                        .style('visibility', 'visible')
                        .attr('data-disabled', 'false');
                }
            });
            this.categoryShow.emit({ category: category });
        };
        AdaptScatterPlotComponent.prototype.categoryHideHandler = function (category) {
            var _this = this;
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _self = this;
            this._isDeselected.push(category);
            this.series.forEach(function (item, index) {
                if (item.name.indexOf(category) !== -1) {
                    item.hidden = true;
                    _this._g
                        .select("[data-line-graph-id='" + index + "']")
                        .style('transition', 'all .3s ease')
                        .style('opacity', '0')
                        .style('visibility', 'hidden');
                }
            });
            d3__namespace.selectAll('.scatter-regression-line')
                .each(function () {
                if (d3__namespace.select(this).attr('id') === _self._highLightColor) {
                    _self._regLine = d3__namespace.select(this);
                    _self._regLine
                        .style('visibility', 'hidden')
                        .style('opacity', '0');
                }
            });
            this._updatedScatterChart(this._dim);
            this.categoryHide.emit({ category: category });
        };
        AdaptScatterPlotComponent.prototype.categoryEnter = function (categoryEvent) {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _self = this;
            var ind = this._isDeselected.indexOf(this.series[categoryEvent.id].name);
            if (ind === -1) {
                var selectedLine = this._g.select("[data-line-graph-id='" + categoryEvent.id + "']  .scatter-plot-circle");
                var colorLine_1 = selectedLine.attr('fill');
                var colorHexLine_1 = _self._colorService.getDarken(colorLine_1, .22, i1.ColorType.HEX);
                this._highLightColor = colorLine_1;
                d3__namespace.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                    if (d3__namespace.select(this).attr('fill').toLowerCase().trim() !== colorLine_1.toLowerCase().trim()) {
                        d3__namespace.select(this).classed('scatter-transition', true).attr('r', 3.5);
                    }
                });
                d3__namespace.selectAll('.scatter-chart-line-g').each(function () {
                    if (d3__namespace.select(this).attr('id').toLowerCase().trim() === colorLine_1.toLowerCase().trim() &&
                        this.nextElementSibling !== null) {
                        this.parentNode.appendChild(this);
                    }
                });
                d3__namespace.selectAll('.scatter-regression-line').each(function () {
                    if (d3__namespace.select(this).attr('id').toLowerCase().trim() === colorLine_1.toLowerCase().trim()) {
                        _self._regLine = d3__namespace.select(this);
                        _self._regLine
                            .style('visibility', 'visible')
                            .attr('stroke', colorHexLine_1)
                            .style('opacity', '1');
                    }
                });
            }
        };
        AdaptScatterPlotComponent.prototype.categoryLeave = function () {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _self = this;
            d3__namespace.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                var _a;
                if (d3__namespace.select(this).attr('fill').toLowerCase().trim() !== ((_a = _self._highLightColor) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim())) {
                    d3__namespace.select(this).classed('scatter-transition', false).attr('r', 5);
                }
            });
            if (this._regLine) {
                this._regLine
                    .attr('stroke', this._highLightColor)
                    .style('visibility', 'hidden')
                    .style('opacity', '0');
            }
        };
        AdaptScatterPlotComponent.prototype._getCustomColorById = function (id) {
            var customColors = this.legend.customColors;
            var len = customColors.length;
            var index = id % len;
            return customColors[index];
        };
        AdaptScatterPlotComponent.prototype._updatedScatterChart = function (dim) {
            this._generatedData = [];
            this._updateAxis(dim);
            this._updateDataLines();
        };
        AdaptScatterPlotComponent.prototype._initAxis = function (g, dim) {
            var _this = this;
            this._generatedData = [];
            if (this.series) {
                this.series.forEach(function (dt) { return dt.data.map(function (d) { return _this._generatedData.push({ data1: d[0], data2: d[1] }); }); });
                if (this.yAxis && this.yAxis.title) {
                    g.append('g')
                        .attr('class', 'adapt-chart-axis-title')
                        .attr('transform', "rotate(-90) translate(-" + (dim.h - this._axisShift.bottom) / 2 + " " + this.axisShiftLeft / 4 + ")")
                        .append('text')
                        .text(this.yAxis.title)
                        .attr('text-anchor', 'middle')
                        .attr('transform', "translate(" + (this._axisShift.bottom / 2) + " 0)");
                }
                if (this.xAxis && this.xAxis.title) {
                    g.append('g')
                        .attr('class', 'adapt-chart-axis-title adapt-chart-axis-title--x')
                        .attr('transform', "translate(" + (dim.w + this.axisShiftLeft) / 2 + " " + dim.h + ")")
                        .append('text')
                        .text(this.xAxis.title)
                        .attr('text-anchor', 'middle')
                        .attr('transform', "translate(" + (this.axisShiftLeft) + " 0)");
                }
                this._x = d3__namespace
                    .scaleLinear()
                    .domain([d3__namespace.min(this._generatedData, function (d) { return d.data1; }), d3__namespace.max(this._generatedData, function (d) { return d.data1; })])
                    .range([0, dim.w - (this._margin.left + this._margin.right)]);
                this._y = d3__namespace
                    .scaleLinear()
                    .domain([d3__namespace.min(this._generatedData, function (d) { return d.data2; }), d3__namespace.max(this._generatedData, function (d) { return d.data2; })])
                    .range([dim.h - this._margin.top - this._margin.bottom, 0]);
                g.append('g')
                    .attr('class', 'axis axis--y')
                    .attr('transform', "translate(" + this._margin.left + ", 0)")
                    .transition()
                    .duration(this.duration)
                    .call(d3__namespace.axisLeft(this._y)
                    .ticks(7)
                    .tickPadding(10)
                    .tickFormat(function (d) { return _this._getTickFormatForNumber(d); })
                    .tickSize(-dim.w + (this._margin.left + this._margin.right))
                    .tickSizeOuter(0));
                g.append('g')
                    .attr('class', 'axis axis--x')
                    .attr('transform', "translate(" + this._margin.left + ", " + (dim.h - this._margin.top - this._margin.bottom) + ")")
                    .transition()
                    .duration(this.duration)
                    .call(d3__namespace.axisBottom(this._x)
                    .tickPadding(10)
                    .tickFormat(function (d) { return _this._getTickFormatForNumber(d); })
                    .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
                    .tickSizeOuter(0));
                var xAxis = this._generatedData.map(function (d) { return d.data1; });
                var yAxis = this._generatedData.map(function (d) { return d.data2; });
                var regression_1 = this._leastSquaresequation(xAxis, yAxis);
                this._line = d3__namespace.line()
                    .x(function (d) { return _this._x(d['data1']); })
                    .y(function (d) { return _this._y(regression_1(d['data1'])); });
            }
        };
        AdaptScatterPlotComponent.prototype._updateAxis = function (dim) {
            var _this = this;
            this.series.forEach(function (dt) { return dt.data.map(function (d) {
                if (_this._isDeselected.indexOf(dt.name) === -1) {
                    return _this._generatedData.push({ data1: d[0], data2: d[1] });
                }
            }); });
            this._g.select('.adapt-chart-axis-title--x')
                .transition()
                .duration(this.duration)
                .attr('transform', "translate(" + (dim.w + this.axisShiftLeft) / 2 + " " + dim.h + ")");
            this._x = d3__namespace
                .scaleLinear()
                .domain([d3__namespace.min(this._generatedData, function (d) { return d.data1; }), d3__namespace.max(this._generatedData, function (d) { return d.data1; })])
                .range([0, dim.w - (this._margin.left + this._margin.right)]);
            this._g.select('.axis--x')
                .transition()
                .duration(this.duration)
                .attr('transform', "translate(" + this._margin.left + ", " + (dim.h - this._margin.top - this._margin.bottom) + ")")
                .call(d3__namespace.axisBottom(this._x)
                .tickPadding(10)
                .tickFormat(function (d) { return _this._getTickFormatForNumber(d); })
                .tickSize(-dim.h + (this._margin.top + this._margin.bottom))
                .tickSizeOuter(0));
            this._y = d3__namespace
                .scaleLinear()
                .domain([d3__namespace.min(this._generatedData, function (d) { return d.data2; }), d3__namespace.max(this._generatedData, function (d) { return d.data2; })])
                .range([dim.h - this._margin.top - this._margin.bottom, 0]);
            this._g.select('.axis--y')
                .transition()
                .duration(this.duration)
                .attr('transform', "translate(" + this._margin.left + ", 0)")
                .call(d3__namespace.axisLeft(this._y)
                .ticks(7)
                .tickPadding(10)
                .tickFormat(function (d) { return _this._getTickFormatForNumber(d); })
                .tickSize(-dim.w + (this._margin.left + this._margin.right))
                .tickSizeOuter(0));
            var xAxis = this._generatedData.map(function (d) { return d.data1; });
            var yAxis = this._generatedData.map(function (d) { return d.data2; });
            var regression = this._leastSquaresequation(xAxis, yAxis);
            this._line = d3__namespace.line()
                .x(function (d) { return _this._x(d['data1']); })
                .y(function (d) { return _this._y(regression(d['data1'])); });
        };
        AdaptScatterPlotComponent.prototype._updateDataLines = function () {
            var _this = this;
            this._g.selectAll('.scatter-plot-circle').attr('cx', function (d) { return _this._x(d.data1); }).attr('cy', function (d) { return _this._y(d.data2); });
            this._g.selectAll('.scatter-regression-line').attr('d', this._line);
        };
        AdaptScatterPlotComponent.prototype._drawLines = function (g) {
            var _this = this;
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _self = this;
            var baseColor;
            var colorHex;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var regLine;
            var colorHexLine;
            this._gW = g.append('g')
                .attr('transform', "translate(" + this._margin.left + ", 0)");
            if (this.series) {
                this._colors = [];
                this.series.map(function (dt, i) { return _this._colors.push(_this.legend.customColors ? _this._getCustomColorById(i) : _this._colorService.getColor(i)); });
                this.series.forEach(function (dt, i) {
                    _this._generatedData = dt.data.map(function (d) {
                        return {
                            data1: d[0],
                            data2: d[1]
                        };
                    });
                    g.append('g')
                        .attr('transform', "translate(" + _this._margin.left + ", 0)")
                        .append('path')
                        .datum(_this._generatedData)
                        .attr('id', _this._colors[i])
                        .attr('stroke', _this._colors[i])
                        .attr('fill', 'none')
                        .attr('stroke-width', '2px')
                        .classed('scatter-regression-line', true)
                        .style('opacity', '0')
                        .style('visibility', 'hidden')
                        .attr('d', _this._line);
                    var lineWrapper = _this._gW
                        .append('g')
                        .attr('class', 'scatter-chart-line-g')
                        .style('opacity', dt.hidden ? 0 : 1)
                        .style('visibility', dt.hidden ? 'hidden' : 'visible')
                        .attr('id', _this._colors[i])
                        .attr('data-line-graph-id', i);
                    lineWrapper
                        .append('g')
                        .attr('class', 'scatter-plot-circle-wrapper')
                        .attr('id', _this._colors[i])
                        .selectAll('dots')
                        .data(_this._generatedData)
                        .enter()
                        .append('circle')
                        .attr('r', 5)
                        .attr('class', 'scatter-plot-circle')
                        .attr('fill', _this._colors[i])
                        .attr('cx', function (d) { return _this._x(d.data1); })
                        .attr('cy', function (d) { return _this._y(d.data2); })
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        .on('mouseover', function (d) {
                        var __this = d3__namespace.select(this);
                        baseColor = __this.attr('fill');
                        colorHex = _self._colorService.getDarken(baseColor, .15, i1.ColorType.HEX);
                        colorHexLine = _self._colorService.getDarken(baseColor, .22, i1.ColorType.HEX);
                        d3__namespace.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                            if (d3__namespace.select(this).attr('fill') !== baseColor) {
                                d3__namespace.select(this)
                                    .classed('scatter-transition', true)
                                    .attr('r', 3.5);
                            }
                        });
                        d3__namespace.selectAll('.scatter-chart-line-g').each(function () {
                            if (d3__namespace.select(this).attr('id') === baseColor && this.nextElementSibling !== null) {
                                this.parentNode.appendChild(this);
                            }
                        });
                        d3__namespace.selectAll('.scatter-regression-line').each(function () {
                            if (d3__namespace.select(this).attr('id').toLowerCase().trim() === baseColor.toLowerCase().trim()) {
                                regLine = d3__namespace.select(this);
                                regLine
                                    .style('visibility', 'visible')
                                    .attr('stroke', colorHexLine)
                                    .style('opacity', '1');
                            }
                        });
                        __this
                            .attr('r', 7)
                            .style('opacity', '1')
                            .style('filter', 'url(#drop-shadow)')
                            .attr('fill', colorHex);
                        _self.chartComponent.showTooltip(d3__namespace.event.target, _self.tooltipTemplate, {
                            data: {
                                color: baseColor,
                                category: dt.name,
                                xValue: _self.scientificMode ? new BigNumber__default["default"](d.data1).toPrecision(2, 2) : d.data1,
                                yValue: _self.scientificMode ? new BigNumber__default["default"](d.data2).toPrecision(2, 2) : d.data2,
                            }
                        });
                    })
                        .on('mouseout', function () {
                        d3__namespace.selectAll('.scatter-plot-circle-wrapper .scatter-plot-circle').each(function () {
                            if (d3__namespace.select(this).attr('fill').toLowerCase().trim() !== baseColor.toLowerCase().trim()) {
                                d3__namespace.select(this)
                                    .classed('scatter-transition', false)
                                    .attr('r', 5);
                            }
                        });
                        regLine
                            .attr('stroke', baseColor)
                            .style('visibility', 'hidden')
                            .style('opacity', '0');
                        d3__namespace.select(this)
                            .style('opacity', '.8')
                            .style('filter', null)
                            .attr('fill', baseColor);
                        _self.chartComponent.hideTooltip();
                    });
                });
            }
        };
        /**
         * http://bl.ocks.org/tommyogden/f416a5c27971908845a9
         */
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptScatterPlotComponent.prototype._leastSquaresequation = function (xAxisData, yAxisData) {
            var ReduceAddition = function (prev, cur) { return prev + cur; };
            // finding the mean of Xaxis and Yaxis data
            var xBar = xAxisData.reduce(ReduceAddition) * 1.0 / xAxisData.length;
            var yBar = yAxisData.reduce(ReduceAddition) * 1.0 / yAxisData.length;
            var SquareXX = xAxisData.map(function (d) { return Math.pow(d - xBar, 2); }).reduce(ReduceAddition);
            // const ssYY = yAxisData.map(d => Math.pow(d - yBar, 2)).reduce(ReduceAddition);
            var MeanDiffXY = xAxisData.map(function (d, i) { return (d - xBar) * (yAxisData[i] - yBar); }).reduce(ReduceAddition);
            var slope = MeanDiffXY / SquareXX;
            var intercept = yBar - (xBar * slope);
            // returning regression function
            return function (x) {
                return x * slope + intercept;
            };
        };
        AdaptScatterPlotComponent.prototype._drawDropShadow = function () {
            var defs = this._g
                .append('defs');
            var filter = defs
                .append('filter')
                .attr('id', 'drop-shadow')
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '180%')
                .attr('height', '180%')
                .attr('filterUnits', 'userSpaceOnUse');
            filter
                .append('feGaussianBlur')
                .attr('in', 'SourceAlpha')
                .attr('stdDeviation', 3);
            filter
                .append('feOffset')
                .attr('dx', 0)
                .attr('dy', 1)
                .attr('result', 'offsetblur');
            filter
                .append('feOffset')
                .attr('dx', 0)
                .attr('dy', 2)
                .attr('result', 'offsetblur');
            filter
                .append('feColorMatrix')
                .attr('type', 'matrix')
                .attr('values', '0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.22 0');
            var feMerge = filter
                .append('feMerge');
            feMerge
                .append('feMergeNode');
            feMerge
                .append('feMergeNode')
                .attr('in', 'SourceGraphic');
            feMerge
                .append('feMergeNode')
                .attr('in', 'SourceGraphic');
        };
        AdaptScatterPlotComponent.prototype._getTickFormatForNumber = function (d) {
            return this.scientificMode
                ? new BigNumber__default["default"](d).toPrecision(2, 2)
                : this._cutNumber.transform(d, 0);
        };
        return AdaptScatterPlotComponent;
    }(AdaptScatterPlotAbstract));
    AdaptScatterPlotComponent.ɵfac = function AdaptScatterPlotComponent_Factory(t) { return new (t || AdaptScatterPlotComponent)(i0__namespace.ɵɵdirectiveInject(CutNumberPipe), i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptDeviceDetectionService), i0__namespace.ɵɵdirectiveInject(ChartColorService)); };
    AdaptScatterPlotComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptScatterPlotComponent, selectors: [["adapt-scatter-plot"]], viewQuery: function AdaptScatterPlotComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(_c0$2, 7);
                i0__namespace.ɵɵviewQuery(AdaptChartComponent, 7);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartComponent = _t.first);
            }
        }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", series: "series", xAxis: "xAxis", yAxis: "yAxis", noDataText: "noDataText", legend: "legend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", dataBuilder: "dataBuilder", updateChart: "updateChart", scientificMode: "scientificMode" }, outputs: { clickChart: "clickChart", categoryShow: "categoryShow", categoryHide: "categoryHide" }, features: [i0__namespace.ɵɵProvidersFeature([CutNumberPipe]), i0__namespace.ɵɵInheritDefinitionFeature], decls: 5, vars: 11, consts: [[3, "width", "height", "header", "data", "dataBuilder", "legend", "updateChart", "backgroundColor", "suppressHeader", "suppressLegend", "noDataText", "categoryShow", "categoryHide", "categoryEnter", "categoryLeave"], ["tooltipTpl", ""], [1, "chart-tooltip-content-container"], [1, "chart-tooltip-content-wrapper"], [1, "chart-tooltip-color-spot"], [1, "chart-tooltip-category"]], template: function AdaptScatterPlotComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵelementStart(0, "adapt-chart", 0);
                i0__namespace.ɵɵlistener("categoryShow", function AdaptScatterPlotComponent_Template_adapt_chart_categoryShow_0_listener($event) { return ctx.categoryShowHandler($event); })("categoryHide", function AdaptScatterPlotComponent_Template_adapt_chart_categoryHide_0_listener($event) { return ctx.categoryHideHandler($event); })("categoryEnter", function AdaptScatterPlotComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptScatterPlotComponent_Template_adapt_chart_categoryLeave_0_listener() { return ctx.categoryLeave(); });
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(1, "\n\n");
                i0__namespace.ɵɵtemplate(2, AdaptScatterPlotComponent_ng_template_2_Template, 26, 7, "ng-template", null, 1, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(4, "\n");
            }
            if (rf & 2) {
                i0__namespace.ɵɵproperty("width", ctx.width)("height", ctx.height)("header", ctx.header)("data", ctx.series)("dataBuilder", ctx._dataBuilder)("legend", ctx.legend)("updateChart", ctx._updateChart)("backgroundColor", ctx.backgroundColor)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("noDataText", ctx.noDataText);
            }
        }, directives: [AdaptChartComponent], encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptScatterPlotComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-scatter-plot',
                        templateUrl: './scatter-plot.component.html',
                        providers: [CutNumberPipe],
                        encapsulation: i0.ViewEncapsulation.None
                    }]
            }], function () { return [{ type: CutNumberPipe }, { type: i1__namespace.AdaptDeviceDetectionService }, { type: ChartColorService }]; }, { backgroundColor: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], header: [{
                    type: i0.Input
                }], series: [{
                    type: i0.Input
                }], xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }], noDataText: [{
                    type: i0.Input
                }], legend: [{
                    type: i0.Input
                }], suppressHeader: [{
                    type: i0.Input
                }], suppressLegend: [{
                    type: i0.Input
                }], tooltip: [{
                    type: i0.Input
                }], dataBuilder: [{
                    type: i0.Input
                }], updateChart: [{
                    type: i0.Input
                }], scientificMode: [{
                    type: i0.Input
                }], clickChart: [{
                    type: i0.Output
                }], categoryShow: [{
                    type: i0.Output
                }], categoryHide: [{
                    type: i0.Output
                }], tooltipTemplate: [{
                    type: i0.ViewChild,
                    args: ['tooltipTpl', { static: true }]
                }], chartComponent: [{
                    type: i0.ViewChild,
                    args: [AdaptChartComponent, { static: true }]
                }] });
    })();

    var AdaptTreemapAbstract = /** @class */ (function (_super) {
        __extends(AdaptTreemapAbstract, _super);
        function AdaptTreemapAbstract() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return AdaptTreemapAbstract;
    }(AdaptChartAbstract));
    AdaptTreemapAbstract.ɵfac = /*@__PURE__*/ function () { var ɵAdaptTreemapAbstract_BaseFactory; return function AdaptTreemapAbstract_Factory(t) { return (ɵAdaptTreemapAbstract_BaseFactory || (ɵAdaptTreemapAbstract_BaseFactory = i0__namespace.ɵɵgetInheritedFactory(AdaptTreemapAbstract)))(t || AdaptTreemapAbstract); }; }();
    AdaptTreemapAbstract.ɵdir = /*@__PURE__*/ i0__namespace.ɵɵdefineDirective({ type: AdaptTreemapAbstract, inputs: { data: "data" }, features: [i0__namespace.ɵɵInheritDefinitionFeature] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptTreemapAbstract, [{
                type: i0.Directive
            }], null, { data: [{
                    type: i0.Input
                }] });
    })();

    var _c0$1 = ["treemapDefaultTooltip"];
    var _c1$1 = ["treemapGroupTooltip"];
    var _c2$1 = ["menuAnchor"];
    var _c3 = ["menuContainer"];
    var _c4 = ["optionsListRef"];
    function AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template(rf, ctx) {
        if (rf & 1) {
            var _r17_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "button", 15);
            i0__namespace.ɵɵlistener("click", function AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template_button_click_0_listener() { var restoredCtx = i0__namespace.ɵɵrestoreView(_r17_1); var action_r14 = restoredCtx.$implicit; var ctx_r16 = i0__namespace.ɵɵnextContext(4); return ctx_r16.callAction(ctx_r16.menuData.target, ctx_r16.menuData.event, ctx_r16.menuData.context, action_r14); });
            i0__namespace.ɵɵtext(1);
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var action_r14 = ctx.$implicit;
            var index_r15 = ctx.index;
            var ctx_r13 = i0__namespace.ɵɵnextContext(4);
            i0__namespace.ɵɵclassProp("text-active", ctx_r13.isActiveDescendant(index_r15));
            i0__namespace.ɵɵpropertyInterpolate1("id", "treemap__actions__action-", index_r15, "");
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate1("\n          ", action_r14.title, "\n        ");
        }
    }
    function AdaptTreemapComponent_div_3_ng_template_6_div_4_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div");
            i0__namespace.ɵɵtext(1, "\n        ");
            i0__namespace.ɵɵtemplate(2, AdaptTreemapComponent_div_3_ng_template_6_div_4_button_2_Template, 2, 4, "button", 14);
            i0__namespace.ɵɵtext(3, "\n      ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r12 = i0__namespace.ɵɵnextContext(3);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngForOf", ctx_r12.menuData.actions);
        }
    }
    function AdaptTreemapComponent_div_3_ng_template_6_Template(rf, ctx) {
        if (rf & 1) {
            var _r19_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵtext(0, "\n    ");
            i0__namespace.ɵɵelementStart(1, "div", 11, 12);
            i0__namespace.ɵɵlistener("keydown", function AdaptTreemapComponent_div_3_ng_template_6_Template_div_keydown_1_listener($event) { i0__namespace.ɵɵrestoreView(_r19_1); var ctx_r18 = i0__namespace.ɵɵnextContext(2); return ctx_r18.keydownHandler($event); });
            i0__namespace.ɵɵtext(3, "\n      ");
            i0__namespace.ɵɵtemplate(4, AdaptTreemapComponent_div_3_ng_template_6_div_4_Template, 4, 1, "div", 13);
            i0__namespace.ɵɵtext(5, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(6, "\n  ");
        }
        if (rf & 2) {
            var ctx_r10 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵattribute("aria-activedescendant", ctx_r10.getActiveDescendant());
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("ngIf", ctx_r10.menuData && ctx_r10.menuData.actions && ctx_r10.menuData.actions.length);
        }
    }
    function AdaptTreemapComponent_div_3_Template(rf, ctx) {
        if (rf & 1) {
            var _r21_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "div", 6, 7);
            i0__namespace.ɵɵlistener("popupAnimationDone", function AdaptTreemapComponent_div_3_Template_div_popupAnimationDone_0_listener() { i0__namespace.ɵɵrestoreView(_r21_1); var ctx_r20 = i0__namespace.ɵɵnextContext(); return ctx_r20.popupAnimationDone(); });
            i0__namespace.ɵɵtext(2, "\n  ");
            i0__namespace.ɵɵelement(3, "button", 8, 9);
            i0__namespace.ɵɵtext(5, "\n  ");
            i0__namespace.ɵɵtemplate(6, AdaptTreemapComponent_div_3_ng_template_6_Template, 7, 2, "ng-template", 10);
            i0__namespace.ɵɵtext(7, "\n");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            i0__namespace.ɵɵproperty("adaptRadarDisableEventSending", true)("appendToBody", true)("restoreFocusAfterClose", true);
        }
    }
    function AdaptTreemapComponent_ng_template_5_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n  ");
            i0__namespace.ɵɵelementStart(1, "div");
            i0__namespace.ɵɵtext(2, "\n    ");
            i0__namespace.ɵɵelementStart(3, "strong");
            i0__namespace.ɵɵtext(4);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(5, "\n    ");
            i0__namespace.ɵɵelementStart(6, "div");
            i0__namespace.ɵɵtext(7);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(8, "\n  ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n");
        }
        if (rf & 2) {
            var context_r22 = ctx.context;
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate(context_r22.name);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵtextInterpolate(context_r22.size);
        }
    }
    function AdaptTreemapComponent_ng_template_8_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n  ");
            i0__namespace.ɵɵelementStart(1, "div", 16);
            i0__namespace.ɵɵtext(2, "\n    ");
            i0__namespace.ɵɵelement(3, "span", 17);
            i0__namespace.ɵɵtext(4);
            i0__namespace.ɵɵelementStart(5, "strong");
            i0__namespace.ɵɵtext(6);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(7, "\n  ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(8, "\n");
        }
        if (rf & 2) {
            var parentContext_r23 = ctx.parentContext;
            var childContext_r24 = ctx.childContext;
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵstyleProp("background-color", parentContext_r23.color);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate1("\n    ", parentContext_r23.name, ": ");
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵtextInterpolate(childContext_r24.name);
        }
    }
    function AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template(rf, ctx) {
        if (rf & 1) {
            var _r33_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "a", 23);
            i0__namespace.ɵɵlistener("click", function AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template_a_click_0_listener($event) { i0__namespace.ɵɵrestoreView(_r33_1); var breadCrumb_r27 = i0__namespace.ɵɵnextContext().$implicit; var ctx_r31 = i0__namespace.ɵɵnextContext(3); return ctx_r31.navigateToGroup($event, breadCrumb_r27, ctx_r31.data); });
            i0__namespace.ɵɵtext(1);
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var breadCrumb_r27 = i0__namespace.ɵɵnextContext().$implicit;
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate(breadCrumb_r27);
        }
    }
    function AdaptTreemapComponent_ng_template_11_ol_1_li_2_ng_container_4_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementContainerStart(0);
            i0__namespace.ɵɵtext(1);
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var breadCrumb_r27 = i0__namespace.ɵɵnextContext().$implicit;
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵtextInterpolate(breadCrumb_r27);
        }
    }
    function AdaptTreemapComponent_ng_template_11_ol_1_li_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "li", 21);
            i0__namespace.ɵɵtext(1, "\n      ");
            i0__namespace.ɵɵtemplate(2, AdaptTreemapComponent_ng_template_11_ol_1_li_2_a_2_Template, 2, 1, "a", 22);
            i0__namespace.ɵɵtext(3, "\n      ");
            i0__namespace.ɵɵtemplate(4, AdaptTreemapComponent_ng_template_11_ol_1_li_2_ng_container_4_Template, 2, 1, "ng-container", 13);
            i0__namespace.ɵɵtext(5, "\n    ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var last_r28 = ctx.last;
            i0__namespace.ɵɵclassProp("active", last_r28);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngIf", !last_r28);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngIf", last_r28);
        }
    }
    function AdaptTreemapComponent_ng_template_11_ol_1_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "ol", 19);
            i0__namespace.ɵɵtext(1, "\n    ");
            i0__namespace.ɵɵtemplate(2, AdaptTreemapComponent_ng_template_11_ol_1_li_2_Template, 6, 4, "li", 20);
            i0__namespace.ɵɵtext(3, "\n  ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r25 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngForOf", ctx_r25.breadCrumbs);
        }
    }
    function AdaptTreemapComponent_ng_template_11_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n  ");
            i0__namespace.ɵɵtemplate(1, AdaptTreemapComponent_ng_template_11_ol_1_Template, 4, 1, "ol", 18);
            i0__namespace.ɵɵtext(2, "\n");
        }
        if (rf & 2) {
            var ctx_r7 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵproperty("ngIf", ctx_r7.breadCrumbs.length);
        }
    }
    var NODE_PADDING = 15;
    // TODO update types
    var AdaptTreemapComponent = /** @class */ (function (_super) {
        __extends(AdaptTreemapComponent, _super);
        function AdaptTreemapComponent(_renderer, _chartColorService, _changeDetectorRef) {
            var _this_1 = _super.call(this) || this;
            _this_1._renderer = _renderer;
            _this_1._chartColorService = _chartColorService;
            _this_1._changeDetectorRef = _changeDetectorRef;
            _this_1.hasActionMenu = false;
            _this_1.breadCrumbs = [];
            // Chart data builder
            _this_1.dataBuilderBind = _this_1._dataBuilder.bind(_this_1);
            // Chart update function
            _this_1.updateChartBind = _this_1._updateChart.bind(_this_1);
            // Chart data builder for grouped treemap
            _this_1.dataBuilderForGroupsBind = _this_1._dataBuilderForGroups.bind(_this_1);
            // Chart update function for grouped treemap
            _this_1.updateChartForGroupsBind = _this_1._updateChartForGroups.bind(_this_1);
            _this_1.showSizeInName = true;
            /**
             * @since 10.14.0
             */
            _this_1.groupView = false;
            // Outputs
            _this_1.clickChart = new i0.EventEmitter();
            _this_1.groupEntered = new i0.EventEmitter();
            _this_1._tooltipPoint = { x: 0, y: 0 };
            _this_1._closeMenuBind = _this_1._closeMenu.bind(_this_1);
            return _this_1;
        }
        AdaptTreemapComponent.prototype.categoryEnter = function (categoryEvent) {
            this._getRelatedToLegendNodes(categoryEvent.id.toString()).dispatch('mouseenter', {
                bubbles: true,
                cancelable: true,
                detail: { eventSource: 'legend' }
            });
        };
        AdaptTreemapComponent.prototype.categoryLeave = function (categoryEvent) {
            this._getRelatedToLegendNodes(categoryEvent.id.toString()).dispatch('mouseleave');
        };
        AdaptTreemapComponent.prototype.ngOnInit = function () {
            this.innerData = lodashEs.cloneDeep(this.data);
            this._initLegend();
        };
        AdaptTreemapComponent.prototype.ngOnChanges = function (changes) {
            if (changes['data']) {
                this.innerData = changes['data'].currentValue;
                this.breadCrumbs = [];
                this._updateLegend(changes['data'].firstChange);
            }
        };
        AdaptTreemapComponent.prototype.ngOnDestroy = function () {
            this._removeListeners();
        };
        AdaptTreemapComponent.prototype.popupAnimationDone = function () {
            if (this.menuContainer.isOpen()) {
                this.optionsListRef.nativeElement.focus();
                this._listKeyManager = new a11y.ListKeyManager(this.items)
                    .withWrap(false)
                    .withHomeAndEnd();
                this._listKeyManager.setFirstItemActive();
                this._removeClickEventListener = this._renderer.listen('document', 'click', this._closeMenuBind);
                this._removeScrollEventListener = this._renderer.listen('document', 'scroll', this._closeMenuBind);
            }
            else {
                this._listKeyManager = null;
                this._removeListeners();
            }
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptTreemapComponent.prototype.keydownHandler = function (event) {
            if (this._listKeyManager) {
                switch (i1.getEventKeyCode(event)) {
                    case keycodes.DOWN_ARROW:
                    case keycodes.UP_ARROW: {
                        this._listKeyManager.onKeydown(event);
                        break;
                    }
                    case keycodes.ENTER: {
                        this.callAction(this.menuData.target, this.menuData.event, this.menuData.context, this.menuData.actions[this._listKeyManager.activeItemIndex]);
                        this.menuContainer.close();
                        break;
                    }
                    case keycodes.TAB: {
                        if (this.menuContainer.isOpen()) {
                            this.menuContainer.close();
                        }
                        break;
                    }
                }
            }
        };
        AdaptTreemapComponent.prototype.getActiveDescendant = function () {
            return this._listKeyManager ? "treemap__actions__action-" + this._listKeyManager.activeItemIndex : undefined;
        };
        AdaptTreemapComponent.prototype.isActiveDescendant = function (index) {
            var _a;
            return index === ((_a = this._listKeyManager) === null || _a === void 0 ? void 0 : _a.activeItemIndex);
        };
        AdaptTreemapComponent.prototype.callAction = function (target, event, context, action) {
            action.callback(target, event, context);
        };
        AdaptTreemapComponent.prototype.enterGroup = function (event, d) {
            this.innerData = d.data;
            this._legend = this._prepareGroupLegend();
            this.chartBase.updateLegend(this._legend.items);
            this.groupEntered.emit({ event: event, data: d.data, node: d });
            i1.SafeCdr.detectChanges(this._changeDetectorRef);
        };
        AdaptTreemapComponent.prototype.updateBreadCrumbs = function (d) {
            if (!this.breadCrumbs.length) {
                this.breadCrumbs.push(this.innerData.name);
            }
            this.breadCrumbs.push(d.data.name);
        };
        AdaptTreemapComponent.prototype.navigateToGroup = function (event, name, data) {
            var _this_1 = this;
            if (data.name === name) {
                this.innerData = lodashEs.cloneDeep(data);
                this.breadCrumbs = this.breadCrumbs.slice(0, this.breadCrumbs.indexOf(name) + 1);
                if (this.breadCrumbs.length === 1) {
                    this.breadCrumbs = [];
                }
                this._legend = this._prepareGroupLegend();
                this.chartBase.updateLegend(this._legend.items);
                this.groupEntered.emit({ event: event, data: data });
                i1.SafeCdr.detectChanges(this._changeDetectorRef);
                return;
            }
            if (data.children) {
                data.children.forEach(function (child) {
                    _this_1.navigateToGroup(event, name, child);
                });
            }
        };
        AdaptTreemapComponent.prototype._dataBuilder = function (g, dim) {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _this = this;
            this._g = g;
            var data = this.innerData;
            var openTooltip = this._openTooltip.bind(this);
            var closeTooltip = this._closeTooltip.bind(this);
            var ellipsis = this._ellipsis;
            var clickChart = this.clickChart;
            var openMenu = this._openMenu.bind(this);
            var showSizeInName = this.showSizeInName;
            var chartColorService = this._chartColorService;
            // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
            this.hasActionMenu = this._isDataContainsActions(data);
            var treemap = d3__namespace.treemap()
                .tile(d3__namespace.treemapResquarify)
                .size([dim.w, dim.h])
                .round(true)
                .paddingInner(1);
            var root = d3__namespace.hierarchy(data)
                .eachBefore(function (d) {
                d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
            })
                .sum(function (d) { return d.size; })
                .sort(function (a, b) { return b.height - a.height || b.value - a.value; });
            treemap(root);
            var _currColorGroup = '';
            var _currColorRange = [];
            var _currColorRangeCounter = 0;
            var nodeGroup = this._g.selectAll('g')
                .data(root.leaves())
                .enter()
                .append('g')
                .attr('class', function (d) { return "treemap-node status-group-" + d.data.id.split(' ').join('_'); })
                .attr('id', function (d) { return d.data.id.split(' ').join('_'); })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', function (d) { return "translate(" + d.x0 + ", " + d.y0 + ")"; });
            var nodeGroupInnerElem = nodeGroup
                .append('g')
                .attr('class', 'treemap-node__inner')
                .attr('tabindex', 0)
                .attr('aria-label', function (d) { return "" + d.data.name + (showSizeInName ? " (" + d.data.size + ")" : ''); })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .on('mouseenter', function (d) {
                var rect = d3__namespace.select(this).select('rect');
                var oldColor = rect.node().style.fill;
                var target = d3__namespace.select(this);
                var tooltipCustomCls = d.data.id.split('.').join('_').split(' ').join('_');
                var eventDetail = d3__namespace.event.detail;
                if (eventDetail === 0 || (eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.eventSource) !== 'legend') {
                    openTooltip(target, { context: d.data }, "treemap_tooltip treemap_tooltip__" + tooltipCustomCls, 1);
                    _this._tooltipEl = window.document.querySelector(".treemap_tooltip__" + tooltipCustomCls);
                    if (i1.isDefined(_this._tooltipEl)) {
                        _this._tooltipMouseleaveHandler = function () {
                            closeTooltip();
                            _this._tooltipEl.removeEventListener('mouseleave', _this._tooltipMouseleaveHandler);
                        };
                        _this._tooltipEl.addEventListener('mouseleave', _this._tooltipMouseleaveHandler);
                    }
                }
                rect.node().style.fill = d3__namespace.rgb(oldColor).darker(.3).formatHex();
            })
                .on('mouseleave', function () {
                var _a, _b, _c;
                var rect = d3__namespace.select(this).select('rect');
                var oldColor = rect.node().style.fill;
                if (!((_c = (_b = (_a = d3__namespace.event) === null || _a === void 0 ? void 0 : _a.toElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null || _c === void 0 ? void 0 : _c.classList.contains('adapt-tooltip-inner'))) {
                    closeTooltip();
                    _this._removeTooltipMouseleaveListener();
                }
                rect.node().style.fill = d3__namespace.rgb(oldColor).brighter(.3).formatHex();
            })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .on('click', function (d) {
                closeTooltip();
                _this._removeTooltipMouseleaveListener();
                clickChart.emit(d.data);
                d3__namespace.event.stopPropagation();
            });
            nodeGroupInnerElem.append('rect')
                .attr('class', 'treemap__node-rect')
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('width', function (d) { return d.x1 - d.x0; })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('height', function (d) { return d.y1 - d.y0; })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('style', function (d) {
                if (!_currColorGroup || !(_currColorGroup === d.parent.data.id)) {
                    var customColorsRange = d.parent.data.customColorsRange;
                    if (i0.isDevMode && customColorsRange && customColorsRange.length !== 2
                        || customColorsRange && customColorsRange[0] && customColorsRange[0].length !== 7
                        || customColorsRange && customColorsRange[1] && customColorsRange[1].length !== 7) {
                        i1.adaptError('ADAPT-ANGULAR Error! \n Treemap component! \n Please pass correct color range. "customColorsRange" property should be an array of 2 values, and each value should be HEX format color 7 chars length each. (eg. customColorsRange: ["#000000", "#ffffff"])');
                    }
                    _currColorGroup = d.parent.data.id;
                    _currColorRange = ChartColorService.getColorRange(d.parent.data.status === exports.AdaptChartColorStatus.Custom
                        ? customColorsRange
                        : d.parent.data.status, d.parent.children.length);
                    _currColorRangeCounter = 0;
                }
                var bg = d.data.color ? d.data.color : _currColorRange[_currColorRangeCounter];
                var currentChild = d.parent.children[_currColorRangeCounter];
                if (i1.isDefined(currentChild)) {
                    currentChild.bg = bg;
                    currentChild.textColor = chartColorService.getContrast(bg, i1.ColorType.HEX);
                }
                _currColorRangeCounter++;
                return "\n          fill: " + bg + ";\n          transition: fill .2s;\n          cursor: pointer;\n        ";
            });
            nodeGroupInnerElem.append('g')
                .attr('class', 'treemap-node-text')
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .each(function (d) {
                var _node = d3__namespace.select(this);
                _node.attr('id', d.data.id.split(' ').join('_') + "_text");
                var _name = _node.append('text')
                    .attr('class', 'treemap__node-name')
                    .attr('transform', "translate(" + (d.x1 - d.x0) / 2 + ", " + (d.y1 - d.y0) / 2 + ")")
                    .attr('style', function () {
                    return "\n              text-anchor: middle;\n              dominant-baseline: middle;\n              font-size: 13px;\n              fill: " + d.textColor + ";\n            ";
                });
                ellipsis(_name, "" + d.data.name + (showSizeInName ? " (" + d.data.size + ")" : ''), d.x1 - d.x0 - NODE_PADDING);
                var lineHeight = 22;
                var _info = _node.append('text')
                    .attr('class', 'treemap__node-info-text')
                    .attr('transform', "translate(" + (d.x1 - d.x0) / 2 + ", " + (d.y1 - d.y0) / 2 + ")")
                    .attr('dy', lineHeight)
                    .attr('text-anchor', 'middle')
                    .attr('style', "font-size: 12px; opacity: .7; fill: " + d.textColor);
                if (d.data.info && (d.y1 - d.y0 > 40)) {
                    ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING);
                }
            });
            this._buildActionsMenu(nodeGroup, openMenu);
            i1.SafeCdr.detectChanges(this._changeDetectorRef);
        };
        AdaptTreemapComponent.prototype._updateChart = function (dim) {
            var data = this.innerData;
            var ellipsis = this._ellipsis;
            var showSizeInName = this.showSizeInName;
            // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
            this.hasActionMenu = this._isDataContainsActions(data);
            var treemap = d3__namespace.treemap()
                .tile(d3__namespace.treemapResquarify)
                .size([dim.w, dim.h])
                .round(true)
                .paddingInner(1);
            var root = d3__namespace.hierarchy(data)
                .eachBefore(function (d) {
                d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
            })
                .sum(function (d) { return d.size; })
                .sort(function (a, b) { return b.height - a.height || b.value - a.value; });
            treemap(root);
            var leaves = root.leaves();
            this._g.selectAll('g.treemap-node')
                .data(leaves)
                .transition()
                .duration(200)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', function (d) { return "translate(" + d.x0 + ", " + d.y0 + ")"; });
            this._g.selectAll('g.treemap__actions-menu rect')
                .data(leaves.filter(function (d) { return d.data.actions; }))
                .transition()
                .duration(200)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', function (d) { return "translate(" + ((d.x1 - d.x0) - 24) + ", 10)"; });
            this._g.selectAll('g.treemap__actions-menu use')
                .data(leaves.filter(function (d) { return d.data.actions; }))
                .transition()
                .duration(200)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', function (d) { return "translate(" + ((d.x1 - d.x0) - 24) + ", 10)"; });
            this._g.selectAll('rect.treemap__node-rect')
                .data(leaves)
                .transition()
                .duration(200)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('width', function (d) { return d.x1 - d.x0; })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('height', function (d) { return d.y1 - d.y0; });
            this._g.selectAll('text.treemap__node-name')
                .data(leaves)
                .transition()
                .duration(200)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', function (d) { return "translate(" + (d.x1 - d.x0) / 2 + ", " + (d.y1 - d.y0) / 2 + ")"; })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .each(function (d) {
                d3__namespace.select(this).text('');
                ellipsis(d3__namespace.select(this), "" + d.data.name + (showSizeInName ? " (" + d.data.size + ")" : ''), d.x1 - d.x0 - NODE_PADDING);
            });
            this._g.selectAll('text.treemap__node-info-text')
                .data(leaves)
                .transition()
                .duration(200)
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .attr('transform', function (d) { return "translate(" + (d.x1 - d.x0) / 2 + ", " + (d.y1 - d.y0) / 2 + ")"; })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .each(function (d) {
                d3__namespace.select(this).text('');
                if (d.data.info && (d.y1 - d.y0 > 40)) {
                    ellipsis(d3__namespace.select(this), d.data.info, d.x1 - d.x0 - NODE_PADDING);
                }
            });
        };
        AdaptTreemapComponent.prototype._dataBuilderForGroups = function (g, dim) {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _this = this;
            this._g = g;
            var data = this.innerData;
            var ellipsis = this._ellipsis;
            var clickChart = this.clickChart;
            var showSizeInName = this.showSizeInName;
            var openMenu = this._openMenu.bind(this);
            // Check if there is at least one item with action. If there are no actions no sense to render dropdown component
            this.hasActionMenu = this._isDataContainsActions(data);
            var treemap = d3__namespace.treemap()
                .tile(d3__namespace.treemapResquarify)
                .size([dim.w, dim.h])
                .round(true)
                .paddingInner(1)
                .paddingOuter(1);
            var root = d3__namespace.hierarchy(data)
                .eachBefore(function (d) {
                d.data.id = (d.parent ? d.parent.data.id + '.' : '') + d.data.name;
            })
                // Ignore size value of node if it has children, because only it's children should be calculated to create correct view
                .sum(function (d) { var _a; return ((_a = d.children) === null || _a === void 0 ? void 0 : _a.length) ? 0 : d.size; })
                .sort(function (a, b) { return b.height - a.height || b.value - a.value; });
            treemap(root);
            var nodeGroup = this._g.selectAll('g')
                .data(root.children)
                .enter()
                .append('g')
                .attr('class', function (d) { var _a; return "treemap-node " + (((_a = d.data.children) === null || _a === void 0 ? void 0 : _a.length) ? 'treemap-node__parent' : 'treemap-node__child'); })
                .attr('id', function (d) { return d.data.id.split(' ').join('_'); })
                .attr('transform', function (d) { return "translate(" + d.x0 + ", " + d.y0 + ")"; });
            var nodeGroupInnerElem = nodeGroup
                .append('g')
                .attr('class', 'treemap-node__inner')
                .attr('tabindex', 0)
                .attr('aria-label', function (d) { return "" + d.data.name + (showSizeInName ? " (" + d.data.size + ")" : ''); })
                .each(function (d) {
                if (_this.groupView && d.children) {
                    var node = d3__namespace.select(this);
                    node.attr('role', 'button')
                        .attr('aria-expanded', false);
                }
            })
                .on('click', function (d) {
                d3__namespace.event.stopPropagation();
                if (_this.groupView && d.children) {
                    _this._activeNode = d;
                    _this.chartBase.hideTooltip();
                    _this.updateBreadCrumbs(d);
                    _this.enterGroup(d3__namespace.event, d);
                }
            })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .on('keydown', function (d) {
                if (d3__namespace.event.keyCode === keycodes.ENTER || d3__namespace.event.keyCode === keycodes.SPACE) {
                    if (_this.groupView && d.children) {
                        _this._activeNode = d;
                        _this.chartBase.hideTooltip();
                        _this.updateBreadCrumbs(d);
                        _this.enterGroup(d3__namespace.event, d);
                    }
                }
            });
            var itemsWithChildren = nodeGroupInnerElem.filter(function (d) { var _a; return !!((_a = d.children) === null || _a === void 0 ? void 0 : _a.length); });
            var itemsWithoutChildren = nodeGroupInnerElem.filter(function (d) { var _a; return !((_a = d.children) === null || _a === void 0 ? void 0 : _a.length); });
            if (itemsWithChildren.size() > 0) {
                itemsWithChildren
                    .each(function (parentData) {
                    var parentItem = d3__namespace.select(this);
                    parentItem
                        .append('rect')
                        .attr('width', parentData.x1 - parentData.x0)
                        .attr('height', parentData.y1 - parentData.y0)
                        .attr('fill', 'transparent')
                        .on('mouseenter', function () {
                        _this._hideParentLabel(parentItem);
                    })
                        .on('mouseleave', function () {
                        _this._showParentLabel(parentItem, parentData);
                    });
                    parentData.children.forEach(function (childData) {
                        var childItem = parentItem
                            .append('g')
                            .attr('class', 'treemap-node__child')
                            .attr('tabindex', 0)
                            .attr('aria-label', childData.data.name);
                        var childRect = childItem
                            .append('rect')
                            .attr('class', 'treemap__node-rect')
                            .attr('transform', "translate(" + (childData.x0 - parentData.x0) + ", " + (childData.y0 - parentData.y0) + ")")
                            .attr('width', childData.x1 - childData.x0)
                            .attr('height', childData.y1 - childData.y0)
                            .attr('style', "fill: " + childData.data.color + "; transition: fill .2s; cursor: pointer;");
                        childItem
                            .on('mouseenter', function () {
                            var oldColor = childRect.node().style.fill;
                            childRect.node().style.fill = d3__namespace.rgb(oldColor).darker(.3).formatHex();
                            _this._hideParentLabel(parentItem);
                            var _d = d3__namespace.event, clientX = _d.clientX, clientY = _d.clientY;
                            _this._tooltipPoint.x = clientX;
                            _this._tooltipPoint.y = clientY;
                            _this.chartBase.showTooltip(_this._tooltipPoint, _this.treemapGroupTooltip, {
                                parentContext: parentData.data,
                                childContext: childData.data
                            });
                        })
                            .on('mousemove', function () {
                            var _d = d3__namespace.event, clientX = _d.clientX, clientY = _d.clientY;
                            _this._tooltipPoint.x = clientX;
                            _this._tooltipPoint.y = clientY;
                            _this.chartBase.updateTooltip();
                        })
                            .on('mouseleave', function () {
                            var oldColor = childRect.node().style.fill;
                            childRect.node().style.fill = d3__namespace.rgb(oldColor).brighter(.3).formatHex();
                            _this._showParentLabel(parentItem, parentData);
                            _this.chartBase.hideTooltip();
                        });
                        var _name = childItem
                            .append('text')
                            .attr('class', 'treemap__node-child-label')
                            .attr('opacity', '0')
                            .attr('transform', "translate(" + (childData.x0 - parentData.x0 + ((childData.x1 - childData.x0) / 2)) + ", " + (childData.y0 - parentData.y0 + ((childData.y1 - childData.y0) / 2)) + ")")
                            .attr('style', "text-anchor: middle; dominant-baseline: middle; font-size: 13px; fill: " + _this._chartColorService.getContrast(childData.data.color, i1.ColorType.HEX) + ";");
                        ellipsis(_name, "" + childData.data.name + (showSizeInName ? " (" + childData.data.size + ")" : ''), childData.x1 - childData.x0 - NODE_PADDING);
                    });
                })
                    .on('mouseenter', function () {
                    var texts = d3__namespace.select(this).selectAll('.treemap__node-child-label');
                    texts.attr('opacity', '1');
                })
                    .on('mouseleave', function () {
                    var texts = d3__namespace.select(this).selectAll('.treemap__node-child-label');
                    texts.attr('opacity', '0');
                });
                itemsWithChildren
                    .append('g')
                    .attr('class', 'treemap-node-parent-label')
                    .each(function (parentData) {
                    var _node = d3__namespace.select(this);
                    var tooltipWrapperHeight = 60;
                    _node
                        .append('foreignObject')
                        .attr('width', parentData.x1 - parentData.x0)
                        .attr('height', 1)
                        .attr('overflow', 'visible')
                        .attr('transform', "translate(0, " + (((parentData.y1 - parentData.y0) / 2) - (tooltipWrapperHeight / 2)) + ")")
                        .append('xhtml:div')
                        .html("\n                <div class=\"treemap__group-parent-tooltip shadow-1\">\n                    <div class=\"treemap__group-parent-tooltip-color\"\n                         style=\"background-color: " + parentData.data.color + "; border-color: " + _this._chartColorService.getDarken(parentData.data.color, .14, i1.ColorType.HEX) + ";\">&nbsp;</div>\n                    <div class=\"treemap__group-parent-tooltip-text align-start\" id=\"" + parentData.data.id.split(' ').join('_') + "_text\">" + parentData.data.name + "</div>\n                </div>\n            ")
                        .attr('class', 'treemap__group-parent-tooltip-wrapper');
                });
            }
            if (itemsWithoutChildren.size() > 0) {
                itemsWithoutChildren.append('rect')
                    .attr('class', 'treemap__node-rect')
                    .attr('width', function (d) { return d.x1 - d.x0; })
                    .attr('height', function (d) { return d.y1 - d.y0; })
                    .attr('style', function (d) { return "fill: " + d.data.color + "; transition: fill .2s; cursor: pointer;"; })
                    .on('click', function (d) {
                    clickChart.emit(d.data);
                });
                itemsWithoutChildren.append('g')
                    .attr('class', 'treemap-node-text treemap-node-text_no-child')
                    .each(function (d) {
                    var _node = d3__namespace.select(this);
                    var _name = _node.append('text')
                        .attr('class', 'treemap__node-name')
                        .attr('transform', "translate(" + (d.x1 - d.x0) / 2 + ", " + (d.y1 - d.y0) / 2 + ")")
                        .attr('style', "text-anchor: middle; dominant-baseline: middle; font-size: 13px; fill: " + _this._chartColorService.getContrast(d.data.color, i1.ColorType.HEX) + ";");
                    ellipsis(_name, "" + d.data.name + (showSizeInName ? " (" + d.data.size + ")" : ''), d.x1 - d.x0 - NODE_PADDING);
                    var lineHeight = 22;
                    var _info = _node.append('text')
                        .attr('class', 'treemap__node-info-text')
                        .attr('transform', "translate(" + (d.x1 - d.x0) / 2 + ", " + (d.y1 - d.y0) / 2 + ")")
                        .attr('dy', lineHeight)
                        .attr('text-anchor', 'middle')
                        .attr('style', "font-size: 12px; opacity: .7; fill: " + _this._chartColorService.getContrast(d.data.color, i1.ColorType.HEX));
                    if (d.data.info && (d.y1 - d.y0 > 40)) {
                        ellipsis(_info, d.data.info, d.x1 - d.x0 - NODE_PADDING);
                    }
                });
            }
            this._buildActionsMenu(nodeGroup, openMenu);
        };
        AdaptTreemapComponent.prototype._updateChartForGroups = function (dim) {
            this._g.selectAll('g').remove();
            this._dataBuilderForGroups(this._g, dim);
        };
        AdaptTreemapComponent.prototype._showParentLabel = function (item, data) {
            item
                .select('.treemap-node-parent-label > foreignObject')
                .attr('style', "opacity: 1; height: 1px; overflow: visible; width: " + (data.x1 - data.x0) + "px;");
        };
        AdaptTreemapComponent.prototype._hideParentLabel = function (item) {
            item
                .select('.treemap-node-parent-label > foreignObject')
                .attr('style', 'opacity: 0; height: 1px; overflow: hidden; width: 0;');
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptTreemapComponent.prototype._buildActionsMenu = function (nodeGroup, openMenu) {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var _this = this;
            // Draw kebab menu icon
            nodeGroup
                .append('g')
                .attr('class', 'treemap__actions-menu')
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .each(function (d) {
                if (d.data.actions) {
                    var _node = d3__namespace.select(this);
                    _node.attr('tabindex', 0)
                        .attr('role', 'button')
                        .attr('aria-haspopup', true)
                        .attr('aria-expanded', false);
                    _node.append('rect')
                        .attr('cursor', 'pointer')
                        .attr('fill', 'transparent')
                        .attr('height', 20)
                        .attr('width', 20)
                        .attr('transform', "translate(" + ((d.x1 - d.x0) - 24) + ", 10)");
                    _node.append('g')
                        .attr('transform', "translate(" + ((d.x1 - d.x0) - 24) + ", 10)")
                        .html(dplIconfont.ai_ellipsis.data)
                        .select('svg')
                        .attr('cursor', 'pointer')
                        .attr('fill', d.textColor)
                        .attr('height', 20)
                        .attr('width', 20);
                }
            })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .on('click', function (d) {
                if (d.data.actions) {
                    d3__namespace.event.stopPropagation();
                    _this._targetWithActions = d3__namespace.select(this);
                    openMenu(d3__namespace.event, d.data);
                }
            })
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                .on('keydown', function (d) {
                var _a, _b;
                if (!((_b = (_a = d.data) === null || _a === void 0 ? void 0 : _a.actions) === null || _b === void 0 ? void 0 : _b.length)) {
                    return;
                }
                if (d3__namespace.event.keyCode === keycodes.ENTER || d3__namespace.event.keyCode === keycodes.DOWN_ARROW || d3__namespace.event.keyCode === keycodes.SPACE) {
                    d3__namespace.event.preventDefault();
                    _this._targetWithActions = d3__namespace.select(this);
                    openMenu(d3__namespace.event, d.data);
                }
                if ((d3__namespace.event.keyCode === keycodes.ESCAPE) && _this.menuContainer.isOpen()) {
                    d3__namespace.event.preventDefault();
                    _this._closeMenu();
                }
            });
        };
        AdaptTreemapComponent.prototype._openMenu = function (event, context) {
            this._closeTooltip();
            this.menuContainer.placement = ['bottom-right', 'top-right', 'right', 'left'];
            this.menuContainer.positionTo = this._targetWithActions.node();
            this.menuData = { target: this._targetWithActions.node(), event: event, context: context, actions: context.actions };
            if (this.menuContainer.isOpen()) {
                this._closeMenu();
            }
            else {
                this.menuContainer.open(event);
                this._targetWithActions.attr('aria-expanded', true);
            }
            i1.SafeCdr.detectChanges(this._changeDetectorRef);
        };
        AdaptTreemapComponent.prototype._closeMenu = function () {
            var _a;
            if (this.menuContainer) {
                this.menuContainer.close();
                (_a = this._targetWithActions) === null || _a === void 0 ? void 0 : _a.attr('aria-expanded', false);
            }
            this._removeListeners();
        };
        AdaptTreemapComponent.prototype._isDataContainsActions = function (data) {
            return data.children.some(function (item) { return item.actions && item.actions.length
                || item.children && item.children.some(function (childrenItem) { return childrenItem.actions && childrenItem.actions.length; }); });
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptTreemapComponent.prototype._openTooltip = function (target, context, customCls, offset) {
            this.chartBase.showTooltip(target.node(), this.tooltip || this.treemapDefaultTooltip, context, customCls, offset);
        };
        AdaptTreemapComponent.prototype._closeTooltip = function () {
            this.chartBase.hideTooltip();
            this._removeListeners();
        };
        AdaptTreemapComponent.prototype._prepareLegend = function () {
            var legendItems = [];
            var data = this.innerData;
            var flattenData = this._flattenByChildren(data.children);
            // In case if data contains "color" property assume that user use "custom colors" approach to control colors
            if (flattenData.some(function (d) { return d.color; })) {
                legendItems = flattenData;
            }
            else {
                if (i1.isDefined(data.status)) {
                    legendItems.push({
                        name: data.name,
                        status: data.status,
                        color: data.status === exports.AdaptChartColorStatus.Custom
                            ? data.customColorsRange
                            : ChartColorService.getColorRange(data.status, 1)
                    });
                }
                data.children.forEach(function (elem) {
                    if (i1.isDefined(elem.status)) {
                        var sameStatuses = legendItems.filter(function (lItem) {
                            return elem.status !== exports.AdaptChartColorStatus.Custom && elem.status === lItem.status;
                        });
                        if (!sameStatuses.length) {
                            legendItems.push({
                                name: elem.name,
                                status: elem.status,
                                color: elem.status === exports.AdaptChartColorStatus.Custom
                                    ? elem.customColorsRange
                                    : ChartColorService.getColorRange(elem.status, 1)
                            });
                        }
                    }
                });
            }
            if (legendItems.length) {
                legendItems.sort(function (a, b) {
                    return a.status - b.status;
                });
                return Object.assign({ columns: 1, items: legendItems.map(function (el) { return el.name; }), customColors: legendItems.map(function (el) { return lodashEs.isArray(el.color) ? el.color[0] : el.color; }), activeHover: false, activeClick: false }, this.legend);
            }
        };
        AdaptTreemapComponent.prototype._prepareGroupLegend = function () {
            var data = this.innerData;
            if (data.children) {
                return Object.assign({ columns: 1, items: data.children.map(function (el) { return el.name; }), customColors: data.children.map(function (el) { return lodashEs.isArray(el.color) ? el.color[0] : el.color; }), activeHover: false, activeClick: false }, this.legend);
            }
        };
        AdaptTreemapComponent.prototype._initLegend = function () {
            if (this.suppressLegend) {
                return;
            }
            if (!this.gradientLegend) {
                this._legend = this.groupView ? this._prepareGroupLegend() : this._prepareLegend();
            }
        };
        AdaptTreemapComponent.prototype._updateLegend = function (isFirstChange) {
            if (this.suppressLegend) {
                return;
            }
            if (!isFirstChange) {
                if (!this.gradientLegend) {
                    this._legend = this.groupView ? this._prepareGroupLegend() : this._prepareLegend();
                    this.chartBase.updateLegend(this._legend.items);
                }
            }
        };
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        AdaptTreemapComponent.prototype._ellipsis = function (textNode, text, ellipsisWidth) {
            var letters = text.split('');
            var ellipsis = textNode.append('tspan').attr('class', 'ellipsis').text('...');
            var width = ellipsisWidth - ellipsis.node().getComputedTextLength();
            var numWords = letters.length;
            var tspan = textNode.insert('tspan', ':first-child').text(letters.join(''));
            // Try the whole line
            // While it's too long, and we have words left, keep removing words
            while (tspan.node().getComputedTextLength() > width && letters.length) {
                letters.pop();
                tspan.text(letters.join(''));
            }
            if (letters.length === numWords) {
                ellipsis.remove();
            }
        };
        AdaptTreemapComponent.prototype._removeListeners = function () {
            if (this._removeClickEventListener) {
                this._removeClickEventListener();
                this._removeClickEventListener = null;
            }
            if (this._removeScrollEventListener) {
                this._removeScrollEventListener();
                this._removeScrollEventListener = null;
            }
        };
        AdaptTreemapComponent.prototype._removeTooltipMouseleaveListener = function () {
            if (i1.isDefined(this._tooltipEl) && i1.isFunction(this._tooltipMouseleaveHandler)) {
                this._tooltipEl.removeEventListener('mouseleave', this._tooltipMouseleaveHandler);
                this._tooltipEl = null;
                this._tooltipMouseleaveHandler = null;
            }
        };
        AdaptTreemapComponent.prototype._flattenByChildren = function (array, result) {
            var _this_1 = this;
            if (result === void 0) { result = []; }
            array.forEach(function (el) {
                if (el.children) {
                    _this_1._flattenByChildren(el.children, result);
                }
                else {
                    result.push(el);
                }
            });
            return result;
        };
        AdaptTreemapComponent.prototype._getRelatedToLegendNodes = function (index) {
            var currentLegendItem = this._legend.items[parseInt(index, 10)];
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var allNodes = this._g.selectAll('.treemap-node');
            return allNodes.filter(function (node) { return node.data.id.indexOf(currentLegendItem) > -1; });
        };
        return AdaptTreemapComponent;
    }(AdaptTreemapAbstract));
    AdaptTreemapComponent.ɵfac = function AdaptTreemapComponent_Factory(t) { return new (t || AdaptTreemapComponent)(i0__namespace.ɵɵdirectiveInject(i0__namespace.Renderer2), i0__namespace.ɵɵdirectiveInject(ChartColorService), i0__namespace.ɵɵdirectiveInject(i0__namespace.ChangeDetectorRef)); };
    AdaptTreemapComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptTreemapComponent, selectors: [["adapt-treemap"]], viewQuery: function AdaptTreemapComponent_Query(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵviewQuery(AdaptChartComponent, 7);
                i0__namespace.ɵɵviewQuery(_c0$1, 7);
                i0__namespace.ɵɵviewQuery(_c1$1, 7);
                i0__namespace.ɵɵviewQuery(_c2$1, 5, i1.AdaptDropdownToggleDirective);
                i0__namespace.ɵɵviewQuery(_c3, 5, i1.AdaptDropdownDirective);
                i0__namespace.ɵɵviewQuery(_c4, 5);
                i0__namespace.ɵɵviewQuery(i1.AdaptListKeyManagerItemDirective, 5);
            }
            if (rf & 2) {
                var _t = void 0;
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.chartBase = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.treemapDefaultTooltip = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.treemapGroupTooltip = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.menuAnchor = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.menuContainer = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.optionsListRef = _t.first);
                i0__namespace.ɵɵqueryRefresh(_t = i0__namespace.ɵɵloadQuery()) && (ctx.items = _t);
            }
        }, inputs: { backgroundColor: "backgroundColor", width: "width", height: "height", header: "header", legend: "legend", gradientLegend: "gradientLegend", suppressHeader: "suppressHeader", suppressLegend: "suppressLegend", tooltip: "tooltip", data: "data", noDataText: "noDataText", showSizeInName: "showSizeInName", groupView: "groupView" }, outputs: { clickChart: "clickChart", groupEntered: "groupEntered" }, exportAs: ["treemap"], features: [i0__namespace.ɵɵInheritDefinitionFeature, i0__namespace.ɵɵNgOnChangesFeature], decls: 14, vars: 14, consts: [[3, "data", "width", "height", "backgroundColor", "header", "legend", "gradientLegend", "suppressHeader", "suppressLegend", "dataBuilder", "updateChart", "noDataText", "topSectionTemplate", "categoryEnter", "categoryLeave"], ["chartBase", ""], ["class", "dropdown treemap-chart_hidden-menu", "adaptDropdown", "", 3, "adaptRadarDisableEventSending", "appendToBody", "restoreFocusAfterClose", "popupAnimationDone", 4, "ngIf"], ["treemapDefaultTooltip", ""], ["treemapGroupTooltip", ""], ["treemapBreadCrumbsTemplate", ""], ["adaptDropdown", "", 1, "dropdown", "treemap-chart_hidden-menu", 3, "adaptRadarDisableEventSending", "appendToBody", "restoreFocusAfterClose", "popupAnimationDone"], ["menuContainer", ""], ["adaptDropdownToggle", "", "type", "button"], ["menuAnchor", ""], ["adaptDropdownMenuTemplate", ""], ["tabindex", "0", "aria-labelledby", "dropdownMenu", 1, "dropdown-menu", 3, "keydown"], ["optionsListRef", ""], [4, "ngIf"], ["class", "dropdown-item", "type", "button", "role", "button", "tabindex", "-1", "adaptListKeyManagerItem", "", 3, "text-active", "id", "click", 4, "ngFor", "ngForOf"], ["type", "button", "role", "button", "tabindex", "-1", "adaptListKeyManagerItem", "", 1, "dropdown-item", 3, "id", "click"], [1, "treemap__group-tooltip"], [1, "adapt-chart-tooltip-color-spot", "mr-1"], ["class", "breadcrumb mb-0", 4, "ngIf"], [1, "breadcrumb", "mb-0"], ["class", "breadcrumb-item", 3, "active", 4, "ngFor", "ngForOf"], [1, "breadcrumb-item"], ["href", "javascript:void(0)", 3, "click", 4, "ngIf"], ["href", "javascript:void(0)", 3, "click"]], template: function AdaptTreemapComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵelementStart(0, "adapt-chart", 0, 1);
                i0__namespace.ɵɵlistener("categoryEnter", function AdaptTreemapComponent_Template_adapt_chart_categoryEnter_0_listener($event) { return ctx.categoryEnter($event); })("categoryLeave", function AdaptTreemapComponent_Template_adapt_chart_categoryLeave_0_listener($event) { return ctx.categoryLeave($event); });
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(2, "\n\n");
                i0__namespace.ɵɵtemplate(3, AdaptTreemapComponent_div_3_Template, 8, 3, "div", 2);
                i0__namespace.ɵɵtext(4, "\n\n");
                i0__namespace.ɵɵtemplate(5, AdaptTreemapComponent_ng_template_5_Template, 10, 2, "ng-template", null, 3, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(7, "\n\n");
                i0__namespace.ɵɵtemplate(8, AdaptTreemapComponent_ng_template_8_Template, 9, 4, "ng-template", null, 4, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(10, "\n\n");
                i0__namespace.ɵɵtemplate(11, AdaptTreemapComponent_ng_template_11_Template, 3, 1, "ng-template", null, 5, i0__namespace.ɵɵtemplateRefExtractor);
                i0__namespace.ɵɵtext(13, "\n");
            }
            if (rf & 2) {
                var _r6 = i0__namespace.ɵɵreference(12);
                i0__namespace.ɵɵproperty("data", ctx.innerData)("width", ctx.width)("height", ctx.height)("backgroundColor", ctx.backgroundColor)("header", ctx.header)("legend", ctx._legend)("gradientLegend", ctx.gradientLegend)("suppressHeader", ctx.suppressHeader)("suppressLegend", ctx.suppressLegend)("dataBuilder", ctx.groupView ? ctx.dataBuilderForGroupsBind : ctx.dataBuilderBind)("updateChart", ctx.groupView ? ctx.updateChartForGroupsBind : ctx.updateChartBind)("noDataText", ctx.noDataText)("topSectionTemplate", _r6);
                i0__namespace.ɵɵadvance(3);
                i0__namespace.ɵɵproperty("ngIf", ctx.hasActionMenu);
            }
        }, directives: [AdaptChartComponent, i3__namespace.NgIf, i1__namespace.AdaptDropdownDirective, i1__namespace.AdaptDropdownToggleDirective, i1__namespace.AdaptDropdownMenuTemplateDirective, i3__namespace.NgForOf, i1__namespace.AdaptListKeyManagerItemDirective], encapsulation: 2 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptTreemapComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-treemap',
                        templateUrl: './treemap.component.html',
                        exportAs: 'treemap'
                    }]
            }], function () { return [{ type: i0__namespace.Renderer2 }, { type: ChartColorService }, { type: i0__namespace.ChangeDetectorRef }]; }, { chartBase: [{
                    type: i0.ViewChild,
                    args: [AdaptChartComponent, { static: true }]
                }], treemapDefaultTooltip: [{
                    type: i0.ViewChild,
                    args: ['treemapDefaultTooltip', { static: true }]
                }], treemapGroupTooltip: [{
                    type: i0.ViewChild,
                    args: ['treemapGroupTooltip', { static: true }]
                }], menuAnchor: [{
                    type: i0.ViewChild,
                    args: ['menuAnchor', {
                            read: i1.AdaptDropdownToggleDirective,
                            static: false
                        }]
                }], menuContainer: [{
                    type: i0.ViewChild,
                    args: ['menuContainer', { read: i1.AdaptDropdownDirective, static: false }]
                }], optionsListRef: [{
                    type: i0.ViewChild,
                    args: ['optionsListRef', { static: false }]
                }], items: [{
                    type: i0.ViewChildren,
                    args: [i1.AdaptListKeyManagerItemDirective]
                }], backgroundColor: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], header: [{
                    type: i0.Input
                }], legend: [{
                    type: i0.Input
                }], gradientLegend: [{
                    type: i0.Input
                }], suppressHeader: [{
                    type: i0.Input
                }], suppressLegend: [{
                    type: i0.Input
                }], tooltip: [{
                    type: i0.Input
                }], data: [{
                    type: i0.Input
                }], noDataText: [{
                    type: i0.Input
                }], showSizeInName: [{
                    type: i0.Input
                }], groupView: [{
                    type: i0.Input
                }], clickChart: [{
                    type: i0.Output
                }], groupEntered: [{
                    type: i0.Output
                }] });
    })();

    exports.AdaptFlowChartOrientation = void 0;
    (function (AdaptFlowChartOrientation) {
        AdaptFlowChartOrientation["LEFT_TO_RIGHT"] = "LR";
        AdaptFlowChartOrientation["RIGHT_TO_LEFT"] = "RL";
        AdaptFlowChartOrientation["TOP_TO_BOTTOM"] = "TB";
        AdaptFlowChartOrientation["BOTTOM_TO_TOP"] = "BT";
    })(exports.AdaptFlowChartOrientation || (exports.AdaptFlowChartOrientation = {}));

    var AdaptTextEllipsisDirective = /** @class */ (function () {
        function AdaptTextEllipsisDirective(_el) {
            this._el = _el;
        }
        AdaptTextEllipsisDirective.prototype.ngOnChanges = function (changes) {
            if (changes) {
                var el = d3.select(this._el.nativeElement);
                textEllipsis(el, this.text, this.width);
            }
        };
        return AdaptTextEllipsisDirective;
    }());
    AdaptTextEllipsisDirective.ɵfac = function AdaptTextEllipsisDirective_Factory(t) { return new (t || AdaptTextEllipsisDirective)(i0__namespace.ɵɵdirectiveInject(i0__namespace.ElementRef)); };
    AdaptTextEllipsisDirective.ɵdir = /*@__PURE__*/ i0__namespace.ɵɵdefineDirective({ type: AdaptTextEllipsisDirective, selectors: [["text", "adaptTextEllipsis", ""]], inputs: { text: "text", width: "width" }, features: [i0__namespace.ɵɵNgOnChangesFeature] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptTextEllipsisDirective, [{
                type: i0.Directive,
                args: [{ selector: 'svg text[adaptTextEllipsis]' }]
            }], function () { return [{ type: i0__namespace.ElementRef }]; }, { text: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }] });
    })();

    function AdaptFlowChartComponent_div_0_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div", 5);
            i0__namespace.ɵɵtext(1, "\n  ");
            i0__namespace.ɵɵelement(2, "div", 6);
            i0__namespace.ɵɵtext(3, "\n");
            i0__namespace.ɵɵelementEnd();
        }
    }
    function AdaptFlowChartComponent_div_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementStart(0, "div", 7);
            i0__namespace.ɵɵtext(1, "\n  ");
            i0__namespace.ɵɵelement(2, "adapt-empty-state", 8);
            i0__namespace.ɵɵtext(3, "\n");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r1 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("type", "chart")("inverted", ctx_r1.emptyStateConfig.inverted)("label", ctx_r1.emptyStateConfig.label);
        }
    }
    function AdaptFlowChartComponent_div_6_Template(rf, ctx) {
        if (rf & 1) {
            var _r5_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "div");
            i0__namespace.ɵɵtext(1, "\n    ");
            i0__namespace.ɵɵelementStart(2, "adapt-slider", 9);
            i0__namespace.ɵɵlistener("ngModelChange", function AdaptFlowChartComponent_div_6_Template_adapt_slider_ngModelChange_2_listener($event) { i0__namespace.ɵɵrestoreView(_r5_1); var ctx_r4 = i0__namespace.ɵɵnextContext(); return ctx_r4.zoomLevel = $event; });
            i0__namespace.ɵɵtext(3, "\n    ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(4, "\n    ");
            i0__namespace.ɵɵelementStart(5, "button", 10);
            i0__namespace.ɵɵlistener("click", function AdaptFlowChartComponent_div_6_Template_button_click_5_listener() { i0__namespace.ɵɵrestoreView(_r5_1); var ctx_r6 = i0__namespace.ɵɵnextContext(); return ctx_r6.fitGraph(); });
            i0__namespace.ɵɵtext(6);
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(7, "\n  ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r2 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngModel", ctx_r2.zoomLevel)("customStepChange", true)("min", ctx_r2.minZoomLevel)("max", ctx_r2.maxZoomLevel)("formatter", ctx_r2.sliderValueFormatter)("step", 0.05)("styleClass", "adapt-flow-chart__zoom-slider");
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵtextInterpolate1("\n      ", ctx_r2.texts.fitGraphButton, "\n    ");
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_ng_template_2_Template(rf, ctx) { }
    var _c0 = function (a0) { return { $implicit: a0 }; };
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementContainerStart(0);
            i0__namespace.ɵɵtext(1, "\n      ");
            i0__namespace.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 17);
            i0__namespace.ɵɵtext(3, "\n    ");
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var node_r13 = i0__namespace.ɵɵnextContext().$implicit;
            var ctx_r14 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngTemplateOutlet", ctx_r14.customTemplateConfig.nodeTemplate)("ngTemplateOutletContext", i0__namespace.ɵɵpureFunction1(2, _c0, node_r13));
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_svg_62_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(0, "svg");
            i0__namespace.ɵɵtext(1, "\n            ");
            i0__namespace.ɵɵelement(2, "g", 40);
            i0__namespace.ɵɵtext(3, "\n          ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var node_r13 = i0__namespace.ɵɵnextContext(3).$implicit;
            var ctx_r20 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵattribute("class", node_r13.iconCustomClass)("fill", ctx_r20.getStatusColor(node_r13.status))("height", ctx_r20.mainIconDimension)("width", ctx_r20.mainIconDimension)("x", ctx_r20.mainIconLeftPadding)("y", ctx_r20.mainIconTopPadding);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("innerHTML", ctx_r20.getSvgIcon(node_r13.icon), i0__namespace.ɵɵsanitizeHtml);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_line_72_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelement(0, "line", 41);
        }
        if (rf & 2) {
            var node_r13 = i0__namespace.ɵɵnextContext(3).$implicit;
            var ctx_r21 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵattribute("x1", 0)("y1", ctx_r21.defaultNodeHeight)("x2", node_r13.dimension.width)("y2", ctx_r21.defaultNodeHeight);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_svg_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(0, "svg");
            i0__namespace.ɵɵtext(1, "\n              ");
            i0__namespace.ɵɵelement(2, "g", 40);
            i0__namespace.ɵɵtext(3, "\n            ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r31 = i0__namespace.ɵɵnextContext();
            var info_r26 = ctx_r31.$implicit;
            var i_r27 = ctx_r31.index;
            var ctx_r29 = i0__namespace.ɵɵnextContext(6);
            i0__namespace.ɵɵattribute("class", info_r26.iconCustomClass)("fill", ctx_r29.getStatusColor(info_r26.status) || ctx_r29.defaultLabelColor)("height", ctx_r29.additionalIconDimension)("width", ctx_r29.additionalIconDimension)("x", ctx_r29.basicLeftPadding + ctx_r29.additionalLeftPadding)("y", ctx_r29.additionalIconTopPadding + i_r27 * ctx_r29.additionalInfoRowHeight);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("innerHTML", ctx_r29.getSvgIcon(info_r26.icon), i0__namespace.ɵɵsanitizeHtml);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_line_8_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelement(0, "line", 41);
        }
        if (rf & 2) {
            var i_r27 = i0__namespace.ɵɵnextContext().index;
            var node_r13 = i0__namespace.ɵɵnextContext(4).$implicit;
            var ctx_r30 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵattribute("x1", 0)("y1", ctx_r30.additionalLineTopPadding + i_r27 * ctx_r30.additionalInfoRowHeight)("x2", node_r13.dimension.width)("y2", ctx_r30.additionalLineTopPadding + i_r27 * ctx_r30.additionalInfoRowHeight);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(0, "g");
            i0__namespace.ɵɵtext(1, "\n            ");
            i0__namespace.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_svg_2_Template, 4, 7, "svg", 3);
            i0__namespace.ɵɵtext(3, "\n            ");
            i0__namespace.ɵɵtext(4, "\n            ");
            i0__namespace.ɵɵelementStart(5, "text", 43);
            i0__namespace.ɵɵtext(6, "\n            ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(7, "\n            ");
            i0__namespace.ɵɵtemplate(8, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2__svg_line_8_Template, 1, 4, "line", 39);
            i0__namespace.ɵɵtext(9, "\n          ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var info_r26 = ctx.$implicit;
            var i_r27 = ctx.index;
            var last_r28 = ctx.last;
            var node_r13 = i0__namespace.ɵɵnextContext(4).$implicit;
            var ctx_r25 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngIf", info_r26.icon);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("text", info_r26.text)("width", node_r13.dimension.width - ctx_r25.basicLeftPadding * 3 - ctx_r25.additionalIconDimension);
            i0__namespace.ɵɵattribute("fill", ctx_r25.defaultColor)("x", info_r26.icon ? ctx_r25.basicLeftPadding * 3 : ctx_r25.basicLeftPadding + ctx_r25.additionalLeftPadding)("y", ctx_r25.additionalTextTopPadding + i_r27 * ctx_r25.additionalInfoRowHeight);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("ngIf", !last_r28);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(0, "g");
            i0__namespace.ɵɵtext(1, "\n          ");
            i0__namespace.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75__svg_g_2_Template, 10, 7, "g", 42);
            i0__namespace.ɵɵtext(3, "\n        ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var node_r13 = i0__namespace.ɵɵnextContext(3).$implicit;
            var ctx_r22 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngForOf", node_r13.data)("ngForTrackBy", ctx_r22.trackByForNodeData);
        }
    }
    var _c1 = function (a0) { return { "filter": a0 }; };
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template(rf, ctx) {
        if (rf & 1) {
            var _r38_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(0, "g", 19);
            i0__namespace.ɵɵlistener("click", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_click_0_listener($event) { i0__namespace.ɵɵrestoreView(_r38_1); var node_r13 = i0__namespace.ɵɵnextContext(2).$implicit; var ctx_r36 = i0__namespace.ɵɵnextContext(2); return ctx_r36.handleNodeClick($event, node_r13); })("mouseover", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_mouseover_0_listener() { i0__namespace.ɵɵrestoreView(_r38_1); var node_r13 = i0__namespace.ɵɵnextContext(2).$implicit; var ctx_r39 = i0__namespace.ɵɵnextContext(2); return ctx_r39.handleMouseOver(node_r13); })("mouseleave", function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template__svg_g_mouseleave_0_listener() { i0__namespace.ɵɵrestoreView(_r38_1); var ctx_r41 = i0__namespace.ɵɵnextContext(4); return ctx_r41.nodeHoverId = ""; });
            i0__namespace.ɵɵtext(1, "\n        ");
            i0__namespace.ɵɵelementStart(2, "defs");
            i0__namespace.ɵɵtext(3, "\n          ");
            i0__namespace.ɵɵelementStart(4, "filter", 20);
            i0__namespace.ɵɵtext(5, "\n            ");
            i0__namespace.ɵɵelement(6, "feGaussianBlur", 21);
            i0__namespace.ɵɵtext(7, "\n            ");
            i0__namespace.ɵɵelement(8, "feOffset", 22);
            i0__namespace.ɵɵtext(9, "\n            ");
            i0__namespace.ɵɵelement(10, "feOffset", 23);
            i0__namespace.ɵɵtext(11, "\n            ");
            i0__namespace.ɵɵelement(12, "feFlood", 24);
            i0__namespace.ɵɵtext(13, "\n            ");
            i0__namespace.ɵɵelement(14, "feFlood", 25);
            i0__namespace.ɵɵtext(15, "\n            ");
            i0__namespace.ɵɵelement(16, "feComposite", 26);
            i0__namespace.ɵɵtext(17, "\n            ");
            i0__namespace.ɵɵelement(18, "feComposite", 27);
            i0__namespace.ɵɵtext(19, "\n            ");
            i0__namespace.ɵɵelementStart(20, "feMerge");
            i0__namespace.ɵɵtext(21, "\n              ");
            i0__namespace.ɵɵelement(22, "feMergeNode", 28);
            i0__namespace.ɵɵtext(23, "\n              ");
            i0__namespace.ɵɵelement(24, "feMergeNode", 29);
            i0__namespace.ɵɵtext(25, "\n              ");
            i0__namespace.ɵɵelement(26, "feMergeNode", 30);
            i0__namespace.ɵɵtext(27, "\n            ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(28, "\n          ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(29, "\n\n          ");
            i0__namespace.ɵɵelementStart(30, "filter", 20);
            i0__namespace.ɵɵtext(31, "\n            ");
            i0__namespace.ɵɵelement(32, "feGaussianBlur", 31);
            i0__namespace.ɵɵtext(33, "\n            ");
            i0__namespace.ɵɵelement(34, "feOffset", 32);
            i0__namespace.ɵɵtext(35, "\n            ");
            i0__namespace.ɵɵelement(36, "feOffset", 33);
            i0__namespace.ɵɵtext(37, "\n            ");
            i0__namespace.ɵɵelement(38, "feFlood", 34);
            i0__namespace.ɵɵtext(39, "\n            ");
            i0__namespace.ɵɵelement(40, "feFlood", 35);
            i0__namespace.ɵɵtext(41, "\n            ");
            i0__namespace.ɵɵelement(42, "feComposite", 26);
            i0__namespace.ɵɵtext(43, "\n            ");
            i0__namespace.ɵɵelement(44, "feComposite", 27);
            i0__namespace.ɵɵtext(45, "\n            ");
            i0__namespace.ɵɵelementStart(46, "feMerge");
            i0__namespace.ɵɵtext(47, "\n              ");
            i0__namespace.ɵɵelement(48, "feMergeNode", 28);
            i0__namespace.ɵɵtext(49, "\n              ");
            i0__namespace.ɵɵelement(50, "feMergeNode", 29);
            i0__namespace.ɵɵtext(51, "\n              ");
            i0__namespace.ɵɵelement(52, "feMergeNode", 30);
            i0__namespace.ɵɵtext(53, "\n            ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(54, "\n          ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(55, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(56, "\n        ");
            i0__namespace.ɵɵelementStart(57, "rect", 36);
            i0__namespace.ɵɵtext(58, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(59, "\n        ");
            i0__namespace.ɵɵelementStart(60, "g");
            i0__namespace.ɵɵtext(61, "\n          ");
            i0__namespace.ɵɵtemplate(62, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_svg_62_Template, 4, 7, "svg", 3);
            i0__namespace.ɵɵtext(63, "\n          ");
            i0__namespace.ɵɵelementStart(64, "text", 37);
            i0__namespace.ɵɵtext(65, "\n          ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(66, "\n          ");
            i0__namespace.ɵɵtext(67, "\n          ");
            i0__namespace.ɵɵtext(68, "\n          ");
            i0__namespace.ɵɵelementStart(69, "text", 38);
            i0__namespace.ɵɵtext(70, "\n          ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(71, "\n          ");
            i0__namespace.ɵɵtemplate(72, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_line_72_Template, 1, 4, "line", 39);
            i0__namespace.ɵɵtext(73, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(74, "\n        ");
            i0__namespace.ɵɵtemplate(75, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1__svg_g_75_Template, 4, 2, "g", 3);
            i0__namespace.ɵɵtext(76, "\n      ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var node_r13 = i0__namespace.ɵɵnextContext(2).$implicit;
            var ctx_r19 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵpropertyInterpolate1("id", "shadow", ctx_r19.componentLevelId, "");
            i0__namespace.ɵɵadvance(26);
            i0__namespace.ɵɵpropertyInterpolate1("id", "shadow-hover", ctx_r19.componentLevelId, "");
            i0__namespace.ɵɵadvance(27);
            i0__namespace.ɵɵproperty("ngStyle", i0__namespace.ɵɵpureFunction1(20, _c1, ctx_r19.nodeHoverId && ctx_r19.nodeHoverId === node_r13.id ? "url(#shadow-hover" + ctx_r19.componentLevelId + ")" : "url(#shadow" + ctx_r19.componentLevelId + ")"));
            i0__namespace.ɵɵattribute("rx", node_r13.type === "rounded" ? ctx_r19.nodeRoundRadix : 0)("width", node_r13.dimension.width)("height", node_r13.dimension.height)("fill", ctx_r19.defaultBackgroundColor);
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵproperty("ngIf", node_r13.icon);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("text", node_r13.label)("width", node_r13.dimension.width - ctx_r19.mainIconLeftPadding * 3 - ctx_r19.mainIconDimension);
            i0__namespace.ɵɵattribute("fill", ctx_r19.defaultLabelColor)("x", node_r13.icon ? ctx_r19.mainTextLeftPadding : ctx_r19.basicLeftPadding + ctx_r19.additionalLeftPadding)("y", ctx_r19.mainTextTopPadding);
            i0__namespace.ɵɵadvance(5);
            i0__namespace.ɵɵproperty("text", node_r13.description)("width", node_r13.dimension.width - ctx_r19.mainIconLeftPadding * 3 - ctx_r19.mainIconDimension);
            i0__namespace.ɵɵattribute("fill", ctx_r19.defaultColor)("x", node_r13.icon ? ctx_r19.mainTextLeftPadding : ctx_r19.basicLeftPadding + ctx_r19.additionalLeftPadding)("y", (ctx_r19.mainTextTopPadding - ctx_r19.mainTextTopGap) * 2);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("ngIf", node_r13.data && node_r13.data.length);
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("ngIf", node_r13.data && node_r13.data.length);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n      ");
            i0__namespace.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3__svg_g_1_Template, 77, 22, "g", 18);
            i0__namespace.ɵɵtext(2, "\n    ");
        }
        if (rf & 2) {
            var node_r13 = i0__namespace.ɵɵnextContext().$implicit;
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵproperty("ngIf", node_r13 && node_r13.dimension && node_r13.dimension.width);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n    ");
            i0__namespace.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_container_1_Template, 4, 4, "ng-container", 15);
            i0__namespace.ɵɵtext(2, "\n\n    ");
            i0__namespace.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_ng_template_3_Template, 3, 1, "ng-template", null, 16, i0__namespace.ɵɵtemplateRefExtractor);
            i0__namespace.ɵɵtext(5, "\n  ");
        }
        if (rf & 2) {
            var _r15 = i0__namespace.ɵɵreference(4);
            var ctx_r8 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵproperty("ngIf", ctx_r8.customTemplateConfig == null ? null : ctx_r8.customTemplateConfig.nodeTemplate)("ngIfElse", _r15);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_ng_template_2_Template(rf, ctx) { }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementContainerStart(0);
            i0__namespace.ɵɵtext(1, "\n      ");
            i0__namespace.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 45);
            i0__namespace.ɵɵtext(3, "\n    ");
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var ctx_r44 = i0__namespace.ɵɵnextContext(3);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngTemplateOutlet", ctx_r44.customTemplateConfig.defsTemplate);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_template_3_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n      ");
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(1, "marker", 46);
            i0__namespace.ɵɵtext(2, "\n        ");
            i0__namespace.ɵɵelement(3, "polygon", 47);
            i0__namespace.ɵɵtext(4, "\n      ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(5, "\n    ");
        }
        if (rf & 2) {
            var ctx_r46 = i0__namespace.ɵɵnextContext(3);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵpropertyInterpolate1("id", "arrow", ctx_r46.componentLevelId, "");
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_5_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n    ");
            i0__namespace.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_container_1_Template, 4, 1, "ng-container", 15);
            i0__namespace.ɵɵtext(2, "\n\n    ");
            i0__namespace.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_ng_template_3_Template, 6, 1, "ng-template", null, 44, i0__namespace.ɵɵtemplateRefExtractor);
            i0__namespace.ɵɵtext(5, "\n  ");
        }
        if (rf & 2) {
            var _r45 = i0__namespace.ɵɵreference(4);
            var ctx_r10 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵproperty("ngIf", ctx_r10.customTemplateConfig == null ? null : ctx_r10.customTemplateConfig.defsTemplate)("ngIfElse", _r45);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_ng_template_2_Template(rf, ctx) { }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵelementContainerStart(0);
            i0__namespace.ɵɵtext(1, "\n      ");
            i0__namespace.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_ng_template_2_Template, 0, 0, "ng-template", 17);
            i0__namespace.ɵɵtext(3, "\n    ");
            i0__namespace.ɵɵelementContainerEnd();
        }
        if (rf & 2) {
            var link_r48 = i0__namespace.ɵɵnextContext().$implicit;
            var ctx_r49 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵproperty("ngTemplateOutlet", ctx_r49.customTemplateConfig.linkTemplate)("ngTemplateOutletContext", i0__namespace.ɵɵpureFunction1(2, _c0, link_r48));
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3__svg_g_7_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(0, "g");
            i0__namespace.ɵɵtext(1, "\n          ");
            i0__namespace.ɵɵelementStart(2, "rect", 51);
            i0__namespace.ɵɵtext(3, "\n          ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(4, "\n          ");
            i0__namespace.ɵɵelementStart(5, "text", 52);
            i0__namespace.ɵɵtext(6, "\n          ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(7, "\n        ");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var link_r48 = i0__namespace.ɵɵnextContext(2).$implicit;
            var ctx_r54 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵattribute("transform", "translate(" + link_r48.midPoint.x + "," + link_r48.midPoint.y + ")");
            i0__namespace.ɵɵadvance(2);
            i0__namespace.ɵɵattribute("filter", "url(#shadow" + ctx_r54.componentLevelId + ")");
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("text", link_r48.label)("width", 70);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n      ");
            i0__namespace.ɵɵnamespaceSVG();
            i0__namespace.ɵɵelementStart(1, "g", 49);
            i0__namespace.ɵɵtext(2, "\n        ");
            i0__namespace.ɵɵtext(3, "\n        ");
            i0__namespace.ɵɵelementStart(4, "path", 50);
            i0__namespace.ɵɵtext(5, "\n        ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(6, "\n        ");
            i0__namespace.ɵɵtemplate(7, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3__svg_g_7_Template, 8, 4, "g", 3);
            i0__namespace.ɵɵtext(8, "\n      ");
            i0__namespace.ɵɵelementEnd();
            i0__namespace.ɵɵtext(9, "\n    ");
        }
        if (rf & 2) {
            var link_r48 = i0__namespace.ɵɵnextContext().$implicit;
            var ctx_r51 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(4);
            i0__namespace.ɵɵattribute("stroke-dasharray", link_r48.type === "stroke" ? ctx_r51.strokeLineLength : 0)("marker-end", "url(#arrow" + ctx_r51.componentLevelId + ")");
            i0__namespace.ɵɵadvance(3);
            i0__namespace.ɵɵproperty("ngIf", link_r48.label && link_r48.midPoint);
        }
    }
    function AdaptFlowChartComponent_ngx_graph_10_ng_template_8_Template(rf, ctx) {
        if (rf & 1) {
            i0__namespace.ɵɵtext(0, "\n    ");
            i0__namespace.ɵɵtemplate(1, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_container_1_Template, 4, 4, "ng-container", 15);
            i0__namespace.ɵɵtext(2, "\n\n    ");
            i0__namespace.ɵɵtemplate(3, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_ng_template_3_Template, 10, 3, "ng-template", null, 48, i0__namespace.ɵɵtemplateRefExtractor);
            i0__namespace.ɵɵtext(5, "\n  ");
        }
        if (rf & 2) {
            var _r50 = i0__namespace.ɵɵreference(4);
            var ctx_r12 = i0__namespace.ɵɵnextContext(2);
            i0__namespace.ɵɵadvance(1);
            i0__namespace.ɵɵproperty("ngIf", ctx_r12.customTemplateConfig == null ? null : ctx_r12.customTemplateConfig.linkTemplate)("ngIfElse", _r50);
        }
    }
    var _c2 = function () { return []; };
    function AdaptFlowChartComponent_ngx_graph_10_Template(rf, ctx) {
        if (rf & 1) {
            var _r58_1 = i0__namespace.ɵɵgetCurrentView();
            i0__namespace.ɵɵelementStart(0, "ngx-graph", 11);
            i0__namespace.ɵɵlistener("zoomChange", function AdaptFlowChartComponent_ngx_graph_10_Template_ngx_graph_zoomChange_0_listener($event) { i0__namespace.ɵɵrestoreView(_r58_1); var ctx_r57 = i0__namespace.ɵɵnextContext(); return ctx_r57.handleZoomChangeDebounced($event); });
            i0__namespace.ɵɵtext(1, "\n\n  ");
            i0__namespace.ɵɵtemplate(2, AdaptFlowChartComponent_ngx_graph_10_ng_template_2_Template, 6, 2, "ng-template", null, 12, i0__namespace.ɵɵtemplateRefExtractor);
            i0__namespace.ɵɵtext(4, "\n\n  ");
            i0__namespace.ɵɵtemplate(5, AdaptFlowChartComponent_ngx_graph_10_ng_template_5_Template, 6, 2, "ng-template", null, 13, i0__namespace.ɵɵtemplateRefExtractor);
            i0__namespace.ɵɵtext(7, "\n\n  ");
            i0__namespace.ɵɵtemplate(8, AdaptFlowChartComponent_ngx_graph_10_ng_template_8_Template, 6, 2, "ng-template", null, 14, i0__namespace.ɵɵtemplateRefExtractor);
            i0__namespace.ɵɵtext(10, "\n");
            i0__namespace.ɵɵelementEnd();
        }
        if (rf & 2) {
            var ctx_r3 = i0__namespace.ɵɵnextContext();
            i0__namespace.ɵɵproperty("links", ctx_r3.links || i0__namespace.ɵɵpureFunction0(17, _c2))("nodes", ctx_r3.nodes)("curve", ctx_r3.curve)("draggingEnabled", false)("layoutSettings", ctx_r3.layoutSettings)("enableZoom", ctx_r3.enableZoom)("zoomSpeed", ctx_r3.zoomSpeed)("autoZoom", ctx_r3.autoZoom)("autoCenter", ctx_r3.autoCenter)("center$", ctx_r3.center$)("zoomToFit$", ctx_r3.zoomToFit$)("update$", ctx_r3.update$)("panToNode$", ctx_r3.panToNode$)("panningEnabled", !ctx_r3.isIE)("zoomLevel", ctx_r3.zoomLevel)("minZoomLevel", ctx_r3.minZoomLevel)("maxZoomLevel", ctx_r3.maxZoomLevel);
        }
    }
    var AdaptFlowChartComponent = /** @class */ (function () {
        function AdaptFlowChartComponent(_deviceDetection, _changeDetectorRef, _domSanitizer, _iconConfig) {
            this._deviceDetection = _deviceDetection;
            this._changeDetectorRef = _changeDetectorRef;
            this._domSanitizer = _domSanitizer;
            this._iconConfig = _iconConfig;
            this.center$ = new rxjs.Subject();
            this.zoomToFit$ = new rxjs.Subject();
            this.panToNode$ = new rxjs.Subject();
            this.update$ = new rxjs.Subject();
            this.mainTextLeftPadding = 70;
            this.mainTextTopPadding = 34;
            this.mainTextTopGap = 6;
            this.mainIconDimension = 40;
            this.mainIconLeftPadding = 15;
            this.mainIconTopPadding = 20;
            this.defaultNodeHeight = 78;
            this.defaultNodeWidth = 280;
            this.nodeRoundRadix = 45;
            this.additionalInfoRowHeight = 42;
            this.additionalIconDimension = 13;
            this.basicLeftPadding = 12;
            this.additionalLeftPadding = 4;
            this.additionalIconTopPadding = 93;
            this.additionalTextTopPadding = 103;
            this.additionalLineTopPadding = 120;
            this.defaultColor = 'currentcolor';
            this.defaultLabelColor = 'var(--color-active)';
            this.defaultBackgroundColor = '#fff';
            this.strokeLineLength = 4;
            this.layoutSettings = {
                orientation: exports.AdaptFlowChartOrientation.BOTTOM_TO_TOP
            };
            this.minZoomLevel = 0.1;
            this.maxZoomLevel = 4;
            this.handleZoomChangeDebounced = i1.debounce(this.handleZoomChange.bind(this), 200);
            this.loading = true;
            this.isIE = false;
            this.nodeHoverId = '';
            this.curve = shape__namespace.curveCatmullRom;
            this.orientation = exports.AdaptFlowChartOrientation.BOTTOM_TO_TOP;
            this.zoomSpeed = 0.04;
            // @Input() draggingEnabled = false;
            this.enableZoom = true;
            this.autoZoom = false;
            this.autoCenter = false;
            this.hasEmptyState = true;
            this.clickNode = new i0.EventEmitter();
            this.class = 'adapt-flow-chart';
            this._defaultTexts = {
                fitGraphButton: 'Fit to screen'
            };
            this._defaultEmptyStateConfig = {
                label: '',
                inverted: false
            };
        }
        AdaptFlowChartComponent.prototype.ngOnInit = function () {
            this.componentLevelId = Math.floor(Math.random() * 1000000).toString();
            this.isIE = this._deviceDetection.isIE();
            this.texts = Object.assign(Object.assign({}, this._defaultTexts), this.texts);
            this.emptyStateConfig = Object.assign(Object.assign({}, this._defaultEmptyStateConfig), this.emptyStateConfig);
            this.layoutSettings.orientation = this.orientation;
        };
        AdaptFlowChartComponent.prototype.ngOnChanges = function (changes) {
            var _this = this;
            var nodes = changes.nodes;
            if (this.nodes && nodes && nodes.previousValue !== nodes.currentValue) {
                this.nodes.forEach(function (node) {
                    node.dimension = {
                        width: node.dimension && node.dimension.width || _this.defaultNodeWidth,
                        height: _this.getNodeHeight(node)
                    };
                });
                if (this.autoCenterToNode) {
                    if (this.autoCenter) {
                        this.autoCenter = false;
                        i1.adaptWarn("ADAPT-ANGULAR Warning! Flow chart component!\n          Seems like \"autoCenter\" is enabled with \"autoCenterToNode\".\n          In this case \"autoCenter\" will be disabled for correct work of \"autoCenterToNode\"");
                    }
                    setTimeout(function () {
                        _this.panToNode$.next(_this.autoCenterToNode);
                        _this.autoCenterToNode = null;
                    });
                }
                this.loading = false;
            }
        };
        AdaptFlowChartComponent.prototype.showEmptyState = function () {
            return this.hasEmptyState && !this.loading && (!this.nodes || this.nodes.length === 0);
        };
        AdaptFlowChartComponent.prototype.showGraph = function () {
            return i1.toBoolean(!this.loading && this.nodes && this.nodes.length !== 0);
        };
        AdaptFlowChartComponent.prototype.getStatusColor = function (status) {
            return status || status === 0 ? ChartColorService.getColorRange(status, 1)[0] : this.defaultColor;
        };
        AdaptFlowChartComponent.prototype.getSvgIcon = function (name) {
            return this._domSanitizer.bypassSecurityTrustHtml(this._iconConfig.getIcon(name));
        };
        AdaptFlowChartComponent.prototype.fitGraph = function () {
            this.zoomToFit$.next(true);
            // At the same time centring graph for better user experience
            this.center$.next(true);
        };
        AdaptFlowChartComponent.prototype.handleNodeClick = function (event, node) {
            this.clickNode.emit({ event: event, node: node });
        };
        AdaptFlowChartComponent.prototype.handleMouseOver = function (node) {
            this.nodeHoverId = node.id;
        };
        AdaptFlowChartComponent.prototype.handleZoomMouseDown = function () {
            this._disableAutoZoom();
        };
        AdaptFlowChartComponent.prototype.handleZoomChange = function (zoomLevel) {
            this._disableAutoZoom();
            this.zoomLevel = zoomLevel;
            i1.SafeCdr.markForCheck(this._changeDetectorRef);
        };
        AdaptFlowChartComponent.prototype.getNodeHeight = function (node) {
            if (node.data && node.data.length) {
                return this.defaultNodeHeight + node.data.length * this.additionalInfoRowHeight;
            }
            else {
                return node.dimension && node.dimension.height || this.defaultNodeHeight;
            }
        };
        AdaptFlowChartComponent.prototype.trackByForNodeData = function (index) {
            return index;
        };
        AdaptFlowChartComponent.prototype.sliderValueFormatter = function (value) {
            if ((value ^ 0) === value) {
                return value.toString();
            }
            else {
                var digitsAfterComma = value.toString().split('.')[1].length;
                var roundTo = digitsAfterComma > 2 ? 2 : 1;
                return value.toFixed(roundTo);
            }
        };
        AdaptFlowChartComponent.prototype._disableAutoZoom = function () {
            // This hack need to be done to allow zooming with slider if autoZoom feature was enabled by default
            if (this.autoZoom) {
                this.autoZoom = false;
            }
            // Also need to disable autoCenter to avoid centring on zooming
            if (this.autoCenter) {
                this.autoCenter = false;
            }
        };
        return AdaptFlowChartComponent;
    }());
    AdaptFlowChartComponent.ɵfac = function AdaptFlowChartComponent_Factory(t) { return new (t || AdaptFlowChartComponent)(i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptDeviceDetectionService), i0__namespace.ɵɵdirectiveInject(i0__namespace.ChangeDetectorRef), i0__namespace.ɵɵdirectiveInject(i3__namespace$1.DomSanitizer), i0__namespace.ɵɵdirectiveInject(i1__namespace.AdaptIconConfig)); };
    AdaptFlowChartComponent.ɵcmp = /*@__PURE__*/ i0__namespace.ɵɵdefineComponent({ type: AdaptFlowChartComponent, selectors: [["adapt-flow-chart"]], hostVars: 4, hostBindings: function AdaptFlowChartComponent_HostBindings(rf, ctx) {
            if (rf & 2) {
                i0__namespace.ɵɵclassMap(ctx.class);
                i0__namespace.ɵɵstyleProp("background-color", ctx.backgroundColor);
            }
        }, inputs: { links: "links", nodes: "nodes", curve: "curve", orientation: "orientation", zoomSpeed: "zoomSpeed", enableZoom: "enableZoom", autoZoom: "autoZoom", autoCenter: "autoCenter", texts: "texts", autoCenterToNode: "autoCenterToNode", hasEmptyState: "hasEmptyState", emptyStateConfig: "emptyStateConfig", customTemplateConfig: "customTemplateConfig", backgroundColor: "backgroundColor" }, outputs: { clickNode: "clickNode" }, features: [i0__namespace.ɵɵNgOnChangesFeature], decls: 12, vars: 4, consts: [["class", "loader-container adapt-flow-chart__loader", 4, "ngIf"], ["class", "adapt-flow-chart__empty-state", 4, "ngIf"], [1, "adapt-flow-chart__zoom-slider-wrapper"], [4, "ngIf"], ["version", "1.1", 0, "xmlns", "svg", "http://www.w3.org/2000/svg", 3, "links", "nodes", "curve", "draggingEnabled", "layoutSettings", "enableZoom", "zoomSpeed", "autoZoom", "autoCenter", "center$", "zoomToFit$", "update$", "panToNode$", "panningEnabled", "zoomLevel", "minZoomLevel", "maxZoomLevel", "zoomChange", 4, "ngIf"], [1, "loader-container", "adapt-flow-chart__loader"], [1, "loader-section"], [1, "adapt-flow-chart__empty-state"], [3, "type", "inverted", "label"], ["orientation", "vertical", 3, "ngModel", "customStepChange", "min", "max", "formatter", "step", "styleClass", "ngModelChange"], [1, "adapt-flow-chart__zoom-fit-button", 3, "click"], ["version", "1.1", 0, "xmlns", "svg", "http://www.w3.org/2000/svg", 3, "links", "nodes", "curve", "draggingEnabled", "layoutSettings", "enableZoom", "zoomSpeed", "autoZoom", "autoCenter", "center$", "zoomToFit$", "update$", "panToNode$", "panningEnabled", "zoomLevel", "minZoomLevel", "maxZoomLevel", "zoomChange"], ["nodeTemplate", ""], ["defsTemplate", ""], ["linkTemplate", ""], [4, "ngIf", "ngIfElse"], ["defaultNodeTemplate", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "node", 3, "click", "mouseover", "mouseleave", 4, "ngIf"], [1, "node", 3, "click", "mouseover", "mouseleave"], ["height", "150%", 3, "id"], ["in", "SourceAlpha", "stdDeviation", "2.5", "result", "blur"], ["dx", "0", "dy", "2", "result", "offsetBlur"], ["dx", "0", "dy", "4", "result", "offsetBlur2", "in", "blur"], ["flood-color", "black", "flood-opacity", "0.14", "result", "offsetColor"], ["flood-color", "black", "flood-opacity", "0.06", "result", "offsetColor2"], ["in", "offsetColor", "in2", "offsetBlur", "operator", "in", "result", "offsetBlur"], ["in", "offsetColor2", "in2", "offsetBlur2", "operator", "in", "result", "offsetBlur2"], ["in", "offsetBlur"], ["in", "offsetBlur2"], ["in", "SourceGraphic"], ["in", "SourceAlpha", "stdDeviation", "7", "result", "blur"], ["dx", "0", "dy", "4", "result", "offsetBlur"], ["dx", "0", "dy", "9", "result", "offsetBlur2", "in", "blur"], ["flood-color", "black", "flood-opacity", "0.17", "result", "offsetColor"], ["flood-color", "black", "flood-opacity", "0.09", "result", "offsetColor2"], [1, "adapt-flow-chart__box", 3, "ngStyle"], ["alignment-baseline", "central", "adaptTextEllipsis", "", 1, "adapt-flow-chart__label", 3, "text", "width"], ["alignment-baseline", "central", "adaptTextEllipsis", "", 3, "text", "width"], ["stroke", "lightgrey", 4, "ngIf"], [3, "innerHTML"], ["stroke", "lightgrey"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["adaptTextEllipsis", "", 3, "text", "width"], ["defaultDefsTemplate", ""], [3, "ngTemplateOutlet"], ["markerWidth", "8", "markerHeight", "7", "refX", "7", "refY", "3", "orient", "auto", 3, "id"], ["points", "0 0, 8 3, 0 6", "fill", "#333"], ["defaultLinkTemplate", ""], [1, "edge"], ["stroke-width", "2", "stroke", "#333", 1, "line"], ["width", "90", "height", "30", "x", "-45", "y", "-18", "rx", "3", 1, "adapt-flow-chart__edge-label-bg"], ["adaptTextEllipsis", "", "alignment-baseline", "central", 1, "adapt-flow-chart__edge-label-text", 3, "text", "width"]], template: function AdaptFlowChartComponent_Template(rf, ctx) {
            if (rf & 1) {
                i0__namespace.ɵɵtemplate(0, AdaptFlowChartComponent_div_0_Template, 4, 0, "div", 0);
                i0__namespace.ɵɵtext(1, "\n\n");
                i0__namespace.ɵɵtemplate(2, AdaptFlowChartComponent_div_2_Template, 4, 3, "div", 1);
                i0__namespace.ɵɵtext(3, "\n\n");
                i0__namespace.ɵɵelementStart(4, "div", 2);
                i0__namespace.ɵɵtext(5, "\n  ");
                i0__namespace.ɵɵtemplate(6, AdaptFlowChartComponent_div_6_Template, 8, 8, "div", 3);
                i0__namespace.ɵɵtext(7, "\n");
                i0__namespace.ɵɵelementEnd();
                i0__namespace.ɵɵtext(8, "\n\n");
                i0__namespace.ɵɵtext(9, "\n");
                i0__namespace.ɵɵtemplate(10, AdaptFlowChartComponent_ngx_graph_10_Template, 11, 18, "ngx-graph", 4);
                i0__namespace.ɵɵtext(11, "\n");
            }
            if (rf & 2) {
                i0__namespace.ɵɵproperty("ngIf", ctx.loading);
                i0__namespace.ɵɵadvance(2);
                i0__namespace.ɵɵproperty("ngIf", ctx.showEmptyState());
                i0__namespace.ɵɵadvance(4);
                i0__namespace.ɵɵproperty("ngIf", ctx.showGraph() && ctx.enableZoom);
                i0__namespace.ɵɵadvance(4);
                i0__namespace.ɵɵproperty("ngIf", ctx.showGraph());
            }
        }, directives: [i3__namespace.NgIf, i1__namespace.AdaptEmptyStateComponent, i1__namespace.AdaptSliderComponent, i4__namespace.NgControlStatus, i4__namespace.NgModel, i5__namespace.GraphComponent, i3__namespace.NgTemplateOutlet, i3__namespace.NgStyle, AdaptTextEllipsisDirective, i3__namespace.NgForOf], encapsulation: 2, changeDetection: 0 });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptFlowChartComponent, [{
                type: i0.Component,
                args: [{
                        selector: 'adapt-flow-chart',
                        templateUrl: './flow-chart.component.html',
                        encapsulation: i0.ViewEncapsulation.None,
                        changeDetection: i0.ChangeDetectionStrategy.OnPush
                    }]
            }], function () { return [{ type: i1__namespace.AdaptDeviceDetectionService }, { type: i0__namespace.ChangeDetectorRef }, { type: i3__namespace$1.DomSanitizer }, { type: i1__namespace.AdaptIconConfig }]; }, { links: [{
                    type: i0.Input
                }], nodes: [{
                    type: i0.Input
                }], curve: [{
                    type: i0.Input
                }], orientation: [{
                    type: i0.Input
                }], zoomSpeed: [{
                    type: i0.Input
                }], enableZoom: [{
                    type: i0.Input
                }], autoZoom: [{
                    type: i0.Input
                }], autoCenter: [{
                    type: i0.Input
                }], texts: [{
                    type: i0.Input
                }], autoCenterToNode: [{
                    type: i0.Input
                }], hasEmptyState: [{
                    type: i0.Input
                }], emptyStateConfig: [{
                    type: i0.Input
                }], customTemplateConfig: [{
                    type: i0.Input
                }], clickNode: [{
                    type: i0.Output
                }], class: [{
                    type: i0.HostBinding,
                    args: ['class']
                }], backgroundColor: [{
                    type: i0.HostBinding,
                    args: ['style.background-color']
                }, {
                    type: i0.Input
                }] });
    })();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @publicApi
     */
    var ADAPT_CHARTS_VERSION = new i0.Version('12.25.0');

    var AdaptChartsModule = /** @class */ (function () {
        function AdaptChartsModule() {
        }
        return AdaptChartsModule;
    }());
    AdaptChartsModule.ɵfac = function AdaptChartsModule_Factory(t) { return new (t || AdaptChartsModule)(); };
    AdaptChartsModule.ɵmod = /*@__PURE__*/ i0__namespace.ɵɵdefineNgModule({ type: AdaptChartsModule });
    AdaptChartsModule.ɵinj = /*@__PURE__*/ i0__namespace.ɵɵdefineInjector({ providers: [
            ChartColorService
        ], imports: [[
                i1.AdaptTooltipModule,
                i5.NgxGraphModule,
                i4.FormsModule,
                i1.AdaptSliderModule,
                i1.AdaptEmptyStateModule,
                i1.AdaptDropdownModule,
                i3.CommonModule,
                i1.AdaptListKeyManagerModule,
                i1.AdaptIconModule
            ]] });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0__namespace.ɵsetClassMetadata(AdaptChartsModule, [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i1.AdaptTooltipModule,
                            i5.NgxGraphModule,
                            i4.FormsModule,
                            i1.AdaptSliderModule,
                            i1.AdaptEmptyStateModule,
                            i1.AdaptDropdownModule,
                            i3.CommonModule,
                            i1.AdaptListKeyManagerModule,
                            i1.AdaptIconModule
                        ],
                        declarations: [
                            AdaptChartComponent,
                            AdaptHeatmapComponent,
                            AdaptLineGraphComponent,
                            AdaptScatterPlotComponent,
                            AdaptTreemapComponent,
                            ChartLegendComponent,
                            ChartGradientLegendComponent,
                            CutNumberPipe,
                            AdaptPieChartComponent,
                            AdaptStackedChartComponent,
                            AdaptChartSliderComponent,
                            AdaptAreaGraphSliderComponent,
                            AdaptAreaGraphComponent,
                            AdaptFlowChartComponent,
                            AdaptTextEllipsisDirective,
                        ],
                        providers: [
                            ChartColorService
                        ],
                        exports: [
                            AdaptChartComponent,
                            AdaptHeatmapComponent,
                            AdaptLineGraphComponent,
                            AdaptScatterPlotComponent,
                            AdaptTreemapComponent,
                            ChartLegendComponent,
                            ChartGradientLegendComponent,
                            AdaptPieChartComponent,
                            AdaptStackedChartComponent,
                            AdaptAreaGraphComponent,
                            AdaptFlowChartComponent,
                            AdaptTextEllipsisDirective
                        ],
                        schemas: [i0.NO_ERRORS_SCHEMA]
                    }]
            }], null, null);
    })();
    (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && i0__namespace.ɵɵsetNgModuleScope(AdaptChartsModule, { declarations: [AdaptChartComponent,
                AdaptHeatmapComponent,
                AdaptLineGraphComponent,
                AdaptScatterPlotComponent,
                AdaptTreemapComponent,
                ChartLegendComponent,
                ChartGradientLegendComponent,
                CutNumberPipe,
                AdaptPieChartComponent,
                AdaptStackedChartComponent,
                AdaptChartSliderComponent,
                AdaptAreaGraphSliderComponent,
                AdaptAreaGraphComponent,
                AdaptFlowChartComponent,
                AdaptTextEllipsisDirective], imports: [i1.AdaptTooltipModule,
                i5.NgxGraphModule,
                i4.FormsModule,
                i1.AdaptSliderModule,
                i1.AdaptEmptyStateModule,
                i1.AdaptDropdownModule,
                i3.CommonModule,
                i1.AdaptListKeyManagerModule,
                i1.AdaptIconModule], exports: [AdaptChartComponent,
                AdaptHeatmapComponent,
                AdaptLineGraphComponent,
                AdaptScatterPlotComponent,
                AdaptTreemapComponent,
                ChartLegendComponent,
                ChartGradientLegendComponent,
                AdaptPieChartComponent,
                AdaptStackedChartComponent,
                AdaptAreaGraphComponent,
                AdaptFlowChartComponent,
                AdaptTextEllipsisDirective] });
    })();
    i0__namespace.ɵɵsetComponentScope(AdaptChartSliderComponent, [i3__namespace.NgClass, i3__namespace.NgIf, i3__namespace.NgSwitch, i3__namespace.NgSwitchCase, AdaptStackedChartComponent], []);
    i0__namespace.ɵɵsetComponentScope(AdaptAreaGraphSliderComponent, [AdaptAreaGraphComponent, i3__namespace.NgIf, i3__namespace.NgClass], []);

    /*
     * Public API Surface of adapt-charts
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ADAPT_CHARTS_VERSION = ADAPT_CHARTS_VERSION;
    exports.AdaptAreaGraphComponent = AdaptAreaGraphComponent;
    exports.AdaptChartAbstract = AdaptChartAbstract;
    exports.AdaptChartComponent = AdaptChartComponent;
    exports.AdaptChartsModule = AdaptChartsModule;
    exports.AdaptFlowChartComponent = AdaptFlowChartComponent;
    exports.AdaptHeatmapAbstract = AdaptHeatmapAbstract;
    exports.AdaptHeatmapComponent = AdaptHeatmapComponent;
    exports.AdaptLineGraphAbstract = AdaptLineGraphAbstract;
    exports.AdaptLineGraphComponent = AdaptLineGraphComponent;
    exports.AdaptPieChartAbstract = AdaptPieChartAbstract;
    exports.AdaptPieChartComponent = AdaptPieChartComponent;
    exports.AdaptScatterPlotAbstract = AdaptScatterPlotAbstract;
    exports.AdaptScatterPlotComponent = AdaptScatterPlotComponent;
    exports.AdaptStackedChartAbstract = AdaptStackedChartAbstract;
    exports.AdaptStackedChartComponent = AdaptStackedChartComponent;
    exports.AdaptTextEllipsisDirective = AdaptTextEllipsisDirective;
    exports.AdaptTreemapAbstract = AdaptTreemapAbstract;
    exports.AdaptTreemapComponent = AdaptTreemapComponent;
    exports.ChartColorService = ChartColorService;
    exports.ChartColorsFactory = ChartColorsFactory;
    exports.ChartGradientLegendComponent = ChartGradientLegendComponent;
    exports.ChartLegendComponent = ChartLegendComponent;
    exports.STATUS_COLOR_RANGE = STATUS_COLOR_RANGE;
    exports.textEllipsis = textEllipsis;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=bmc-ux-adapt-charts.umd.js.map
