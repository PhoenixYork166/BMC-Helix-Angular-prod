//
//### Gulp tasks description
//
// iconfont:indexing        Synchronization of svg icon list with config file
// iconfont:build           Bundle of gulp commands: create:fonts, create:svg-sprite, create:styles

// icons:prepare            Batch conversion of svg files                               <-- FOR DEVELOPERS ONLY!
// demoPage:compileSASS     Compile scss files for demo page                            <-- FOR DEVELOPERS ONLY!

// create:fonts             Create .svg, .ttf, .eot, .woff and .woff2 font files        <-- FOR DEVELOPERS ONLY!
// create:svg-sprite        Create svg-sprite file                                      <-- FOR DEVELOPERS ONLY!
// create:styles            Create/compile .sass and .css files                         <-- FOR DEVELOPERS ONLY!

'use strict';

const fs = require('fs');
const mkdirp = require('mkdirp');
const rename = require('gulp-rename');
const path = require('path');
const map = require('map-stream');
const consolidate = require('gulp-consolidate');
const sass = require('gulp-sass')(require('node-sass'));
const gulp = require('gulp');
const spawn = require('gulp-spawn');

const svgmin = require('gulp-svgmin');
const svgicons2svgfont = require('svgicons2svgfont');
const svg2ttf = require('svg2ttf');
const ttf2eot = require('ttf2eot');
const ttf2woff = require('ttf2woff');
const ttf2woff2 = require('ttf2woff2');
const SVGSpriter = require('svg-sprite');

const settings = {
    pathToConfig: 'config/if_dpl.json',
    pathToIcons: 'src/icons/',
    pathToTemplates: 'src/templates/',
    outputFolder: 'dist/',
    fontFolder: 'fonts/',
    moduleFolder: 'module/',
    fontName: 'dpl-iconfont',
    fontNameCSS: 'dpl-icon-font',
    fontFileName: 'dpl-iconfont',
    version: JSON.parse(fs.readFileSync('config/if_dpl.json', {encoding: 'utf-8'})).version
};

gulp.task('icons:prepare', gulp.series(() => {
    return gulp.src(path.join(settings.pathToIcons, '*.svg'))
        .pipe(svgmin({
            plugins: [
                {
                    removeDoctype: true
                },
                {
                    removeComments: true
                },
                {
                    removeStyleElement: true
                },
                {
                    removeDimensions: true
                },
                {
                    removeAttrs: {attrs: '(id|class)'}
                },
                {
                    cleanupAttrs: true
                },
                {
                    cleanupIDs: true
                },
                {
                    collapseGroups: true
                },
                {
                    js2svg: {
                        pretty: true
                    }
                }]
        }))
        .pipe(gulp.dest('./'));
}));

gulp.task('create:fonts', gulp.series((done) => {
    // Creating font-output folder
    mkdirp.sync(settings.outputFolder + settings.fontFolder);

    const pathToFont = settings.outputFolder + settings.fontFolder + settings.fontFileName;

    const fontStream = new svgicons2svgfont({
        fontName: settings.fontName,
        normalize: true,
        fontHeight: 1001,
        prependUnicode: true,
        descent: 150,
        copyright: 'BMC'
    });

    const spaceGlyph = {
        path: settings.pathToIcons + 'u0020-space.svg',
        content: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 24"></svg>'
    };

    fs.writeFileSync(spaceGlyph.path, spaceGlyph.content);

    fontStream.pipe(fs.createWriteStream(pathToFont + '.svg'))
        .on('finish', () => {
            console.log('Creating ttf, eot, woff, woff2...');
            createIconfont();
            fs.unlinkSync(spaceGlyph.path);
            console.log('Success!');
        })
        .on('error', (err) => {
            console.log('fontStream on error: ', err);
        });

    fs.readdirSync(settings.pathToIcons, {withFileTypes: true}).forEach((dirFile) => {
        const filePath = dirFile.name;
        const iconName = filePath.slice(filePath.lastIndexOf('/') + 7, -4); // filename without extension
        const iconUnicode = filePath.substr(filePath.lastIndexOf('/') + 2, 5); // only HEX value

        const glyph = fs.createReadStream(settings.pathToIcons + filePath);

        glyph.metadata = {
            unicode: [String.fromCharCode(parseInt(iconUnicode, 16))],
            name: iconName
        };

        fontStream.write(glyph, 'utf-8', (error) => {
            if (error) {
                console.log('fontStream.write error: ', error);
            }
        });
    });

    fontStream.end();
    done();

    function createIconfont() {
        const svgFont = fs.readFileSync(pathToFont + '.svg', {encoding: 'utf-8'});

        const ttfContent = svg2ttf(svgFont,
            {
                copyright: settings.copyright,
                version: settings.version.substr(0, settings.version.lastIndexOf('.')) // Version in format 'x.y' without fixes
            });

        const ttfFont = new Buffer(ttfContent.buffer);

        fs.writeFileSync(pathToFont + '.ttf', ttfFont);

        const eotContent = ttf2eot(ttfFont);
        fs.writeFileSync(pathToFont + '.eot', new Buffer(eotContent.buffer));

        const woffContent = ttf2woff(ttfFont);
        fs.writeFileSync(pathToFont + '.woff', new Buffer(woffContent.buffer));

        const woff2Content = ttf2woff2(ttfFont);
        fs.writeFileSync(pathToFont + '.woff2', new Buffer(woff2Content.buffer));
    }
}));

gulp.task('create:svg-sprite', gulp.series((done) => {
    const icons = fs.readdirSync(settings.pathToIcons).filter((elem) => {
        return /[.svg]$/.test(elem);
    });

    const spriter = new SVGSpriter({
        dest: settings.outputFolder + 'svg/',

        shape: {
            id: {                               // SVG shape ID related options
                separator: '--',                // Separator for directory name traversal
                generator: (name) => {
                    return name.slice(6, -4);
                },                              // SVG shape ID generator callback
                pseudo: '~',                    // File name separator for shape states (e.g. ':hover')
                whitespace: '_'                 // Whitespace replacement for shape IDs
            },
            dimension: {                        // Dimension related options
                maxWidth: 2000,                 // Max. shape width
                maxHeight: 2000,                // Max. shape height
                precision: 2,                   // Floating point precision
                attributes: false               // Width and height attributes on embedded shapes
            },
            spacing: {                          // Spacing related options
                padding: 0,                     // Padding around all shapes
                box: 'border'                   // Padding strategy (similar to CSS `box-sizing`)
            },
            transform: ['svgo'],                // List of transformations / optimizations
            sort: () => {                 // SVG shape sorting callback
            },
            meta: null,                         // Path to YAML file with meta / accessibility data
            align: null,                        // Path to YAML file with extended alignment data
            //dest: null                          // Output directory for optimized intermediate SVG shapes
        },

        svg: {                                  // General options for created SVG files
            xmlDeclaration: true,               // Add XML declaration to SVG sprite
            doctypeDeclaration: true,           // Add DOCTYPE declaration to SVG sprite
            namespaceIDs: true,                 // Add namespace token to all IDs in SVG shapes
            dimensionAttributes: true,          // Width and height attributes on the sprite
            rootAttribute: {}
        },

        mode: {
            defs: {
                dest: '',
                sprite: settings.fontFileName + '-sprite.svg',
                example: false
            }
        }
    });

    icons.forEach((elem) => {
        spriter.add(
            path.resolve(settings.pathToIcons + elem),
            elem,
            fs.readFileSync(settings.pathToIcons + elem, {encoding: 'utf-8'})
        );
    });

    spriter.compile((error, result) => {
        for (const mode in result) {
            for (const type in result[mode]) {
                mkdirp.sync(path.dirname(result[mode][type].path));
                fs.writeFileSync(result[mode][type].path, result[mode][type].contents);
            }
        }
    });

    done();
}));

gulp.task('create:styles', gulp.series(
    () => {
        const glyphs = JSON.parse(fs.readFileSync('config/if_dpl.json', {encoding: 'utf-8'})).glyphs;

        return gulp.src(settings.pathToTemplates + '*.scss')
            .pipe(consolidate('lodash', {
                glyphs: glyphs,
                fontName: settings.fontNameCSS,
                fontFileName: settings.fontFileName,
                fontPath: '../fonts/',
                className: 'd-icon',
                version: settings.version
            }))
            .pipe(gulp.dest(settings.outputFolder + 'scss/'));
    }, () => {
        return gulp.src(settings.outputFolder + 'scss/' + '*.scss')
            .pipe(sass())
            .pipe(gulp.dest(settings.outputFolder + 'css/'))
            .pipe(sass({outputStyle: 'compressed'}))
            .pipe(rename({suffix: '.min'}))
            .pipe(gulp.dest(settings.outputFolder + 'css/'));
    })
);

gulp.task('create:module', gulp.series((done) => {
    // Output folder path
    const outputFolder = settings.outputFolder + settings.moduleFolder;

    // Write output folder structure
    mkdirp.sync(outputFolder);

    // Helper arrays
    let iconNamesArray = [];
    let iconConstNamesArray = [];
    let iconModulesArray = [];

    // Each icon in separate module
    fs.readdirSync(settings.pathToIcons, {withFileTypes: true, encoding: 'utf-8'})
        .forEach((dirFile) => {
            const filePath = dirFile.name;
            const iconName = filePath.slice(filePath.lastIndexOf('/') + 7, -4); // filename without extension
            const iconConstName = 'ai_' + iconName;
            const iconContent = fs.readFileSync(settings.pathToIcons + filePath, {encoding: 'utf-8'});
            const iconModule = {
                name: iconName,
                data: iconContent
            };

            iconNamesArray.push(iconName);
            iconConstNamesArray.push(iconConstName);
            iconModulesArray.push(iconModule);

            //
            // - - - - - - - - - - - Icon - - - - - - - - - - - - - - -
            //
            const pathToIconFile = outputFolder + iconConstName + '.js';
            const iconFileContent =
                'module.exports = {name: \'' + iconModule.name + '\', data: \'' + iconModule.data + '\'};';
            fs.writeFileSync(pathToIconFile, iconFileContent);

            const pathToIconDefFile = outputFolder + iconConstName + '.d.ts';
            const iconDefFileContent =
                'import {AdaptSvgIcon} from \'./model\';\n' +
                'export declare const ' + iconConstName + ': AdaptSvgIcon;';
            fs.writeFileSync(pathToIconDefFile, iconDefFileContent);
        });

    //
    // - - - - - - - - - - - Icons set const - - - - - - - - - - - - - - -
    //
    const pathToIconsConstFile = outputFolder + 'ai.js';
    const iconsConstFileContent =
        'module.exports = {\n' + iconModulesArray.map(iconModule => '\t' + iconModule.name + ': \'' + iconModule.data + '\'').join(',\n') + '\n};';
    fs.writeFileSync(pathToIconsConstFile, iconsConstFileContent);

    const pathToIconsConstDefFile = outputFolder + 'ai.d.ts';
    const iconsConstDefFileContent = 'import {AdaptSvgIconName} from \'./model\';\n' +
        'export declare const ADAPT_SVG_ICONS: {[key in AdaptSvgIconName]: string;};';
    fs.writeFileSync(pathToIconsConstDefFile, iconsConstDefFileContent);

    //
    // - - - - - - - - - - - Icons modules set - - - - - - - - - - - - - - -
    //
    const pathToIconsSetFile = outputFolder + 'ai_set.js';
    const iconsSetFileContent =
        'module.exports = [\n' + iconModulesArray.map(iconModule => '\tmodule.exports.ai_' + iconModule.name + ' = {name: \'' + iconModule.name + '\', data: \'' + iconModule.data + '\'},\n').join('') + '];';
    fs.writeFileSync(pathToIconsSetFile, iconsSetFileContent);

    const pathToIconsSetDefFile = outputFolder + 'ai_set.d.ts';
    const iconsSetDefFileContent = 'import {AdaptSvgIcon} from \'./model\';\n' +
        'export declare const ADAPT_SVG_ICON_SET: AdaptSvgIcon[];';
    fs.writeFileSync(pathToIconsSetDefFile, iconsSetDefFileContent);

    //
    // - - - - - - - - - - - Model - - - - - - - - - - - - - - -
    //
    const pathToModelFile = outputFolder + 'model.js';
    fs.writeFileSync(pathToModelFile, '');

    const pathToModelDefFile = outputFolder + 'model.d.ts';
    const modelDefFileContent =
        'export declare type AdaptSvgIconName = ' + iconNamesArray.map(name => '\'' + name + '\'').join(' | ') + ';\n' +
        'export interface AdaptSvgIcon {name: AdaptSvgIconName, data: string}';
    fs.writeFileSync(pathToModelDefFile, modelDefFileContent);

    //
    // - - - - - - - - - - - Index - - - - - - - - - - - - - - -
    //
    const pathToIndexFile = outputFolder + 'index.js';
    const indexFileContent =
        iconConstNamesArray.map(name => 'module.exports.' + name + ' = require(\'./' + name + '.js\');\n').join('') +
        'module.exports.ADAPT_SVG_ICONS = require(\'./ai.js\');\n' +
        'module.exports.ADAPT_SVG_ICON_SET = require(\'./ai_set.js\');';
    fs.writeFileSync(pathToIndexFile, indexFileContent);

    const pathToIndexDefFile = outputFolder + 'index.d.ts';
    const indexFileDefContent =
        iconConstNamesArray.map(name => 'export {' + name + '} from \'./' + name + '\';\n').join('') +
        'export {ADAPT_SVG_ICONS} from \'./ai\';\n' +
        'export {ADAPT_SVG_ICON_SET} from \'./ai_set\';\n' +
        'export {AdaptSvgIconName, AdaptSvgIcon} from \'./model\';';
    fs.writeFileSync(pathToIndexDefFile, indexFileDefContent);

    done();
}));

// gulp.task('post-process__ttf', function () {
//     return gulp.src(path.join(settings.outputFolder, settings.fontFolder, settings.fontFileName, '*.ttf'), {buffer: false})
//         .pipe(
//             spawn({
//                 cmd: "./ttfautohint/ttfautohint",
//                 args: [
//                     '--no-info',
//                     '--symbol',
//                     '--fallback-script=latn'
//                 ]
//             })
//         )
//         .pipe(gulp.dest("./"));
// });


gulp.task('demoPage:compileSASS', gulp.series(() => {
    return gulp.src('demo/style/*.scss')
        .pipe(sass())
        .pipe(gulp.dest('demo/style/'));
}));


gulp.task('iconfont:indexing', gulp.series((done) => {
    console.log('- - - - - - - - - - - -');

    applyUnicode();

    const newIcons = checkNewIcons();

    if (newIcons.length > 0) {
        indexingNewIcons(newIcons);
        applyUnicode();

        settings.gitCommitMessage = 'New Icons: ' + newIcons.join(', ');
    }

    console.log('      Version:\t%s', getConfigObj().version);
    console.log('  Total icons:\t%s', getIconsList().length);
    console.log('    New icons:\t%s', newIcons);
    console.log('Missing icons:\t%s', checkMissingIcons());

    saveConfigAsVar();

    console.log('- - - - - - - - - - - -');


    /**
     * Add unicode in start of icons name, in case if it exist in config.json
     */
    function applyUnicode() {
        const glyphs = getConfigObj().glyphs;
        const icons = getIconsList();

        glyphs.forEach((elem) => {
            const iconIndex = icons.indexOf(elem.id);

            if (iconIndex !== -1) {
                renameIcon(icons[iconIndex], 'u' + elem.unicode.toUpperCase() + '-' + icons[iconIndex]);
            }
        });
    }

    /**
     * Find new icons from icons list
     * @returns newIconsArray
     */
    function checkNewIcons() {
        const configObj = getConfigObj();
        const glyphs = configObj.glyphs;
        let icons = getIconsList();

        const newIcons = [];

        icons = icons.filter((elem) => {
            if (!elem.slice(0, 6).match(/^u([A-Z]|[0-9]){4}-/)) {
                newIcons.push(elem);
                return false;
            } else {
                return true;
            }
        });

        glyphs.forEach((elem) => {
            const iconIndex = icons.indexOf('u' + elem.unicode.toUpperCase() + '-' + elem.id);

            if (iconIndex !== -1) {
                icons.splice(iconIndex, 1);
            }
        });

        if (icons.length) {
            icons.forEach((elem) => {
                newIcons.push(elem);
            })
        }

        return newIcons;
    }

    /**
     * Add new icons to config.json
     * @param newIcons
     */
    function indexingNewIcons(newIcons) {
        const configObj = deleteNewIndicator(getConfigObj());

        let lastGlyphPosition = configObj.glyphs.length > 0 ? parseInt(configObj.glyphs[configObj.glyphs.length - 1].unicode, 16) : parseInt('e600', 16);

        newIcons.forEach((elem) => {
            configObj.glyphs.sort((a, b) => {
                return parseInt(a.unicode, 16) - parseInt(b.unicode, 16);
            });

            if (elem.slice(0, 6).match(/^u([A-Z]|[0-9]){4}-/)) {

                configObj.glyphs.push({
                    unicode: elem.slice(1, 5).toLowerCase(),
                    id: elem.slice(6),
                    name: '',
                    tags: '',
                    description: '',
                    new: true
                });
            } else {
                lastGlyphPosition++;

                configObj.glyphs.push({
                    unicode: lastGlyphPosition.toString(16),
                    id: elem,
                    name: '',
                    tags: '',
                    description: '',
                    new: true
                });


                configObj.glyphs.sort((a, b) => {
                    return parseInt(a.unicode, 16) - parseInt(b.unicode, 16);
                });
            }
        });

        rewriteConfig(configObj);
    }

    /**
     * Return icons list which exist in config.json but missing in folder
     * @returns missingIconsArray
     */
    function checkMissingIcons() {
        const glyphs = getConfigObj().glyphs;
        const iconFiles = getIconsList();

        const missingIcons = [];

        glyphs.forEach((elem) => {
            const iconIndex = iconFiles.indexOf('u' + elem.unicode.toUpperCase() + '-' + elem.id);

            if (iconIndex === -1) {
                missingIcons.push(elem.id + '(' + 'u' + elem.unicode.toUpperCase() + ')');
            }
        });

        return missingIcons;
    }

    /**
     * Wrapper for fs.renameSync(). Adding path to files and extension
     * @param oldName
     * @param newName
     */
    function renameIcon(oldName, newName) {
        fs.renameSync(settings.pathToIcons + oldName + '.svg', settings.pathToIcons + newName + '.svg');
    }

    /**
     * Get list of svg files
     * @returns iconsArray
     */
    function getIconsList() {
        let icons = fs.readdirSync(settings.pathToIcons).filter((elem) => {
            return /[.svg]$/.test(elem);
        });

        icons = icons.map((elem) => {
            return elem.slice(0, -4);
        });

        return icons;
    }

    /**
     * Get object from config.json file
     */
    function getConfigObj() {
        return JSON.parse(fs.readFileSync(settings.pathToConfig, {encoding: 'utf-8'}));
    }

    /**
     * Rewrite json.config to new version
     * @param newConfig
     */
    function rewriteConfig(newConfig) {
        fs.writeFileSync(settings.pathToConfig, JSON.stringify(newConfig, null, '\t'));
    }

    /**
     * Delete 'new' property from all glyphs in configObj
     * @param configObj
     * @returns updatedConfigObj
     */
    function deleteNewIndicator(configObj) {
        configObj.glyphs.map((elem) => {
            if (elem.new) {
                delete elem.new;
            }

            return elem;
        });

        return configObj;
    }

    /**
     * Save json.config as a variable. It need for run demo page without localhost
     */
    function saveConfigAsVar() {
        fs.writeFileSync('demo/script/fontConfig.js', 'var fontConfig = ' + JSON.stringify(getConfigObj()) + ';');
    }

    done();
}));

gulp.task('iconfont:build', gulp.series('create:fonts', 'create:svg-sprite', 'create:styles', 'create:module'));
