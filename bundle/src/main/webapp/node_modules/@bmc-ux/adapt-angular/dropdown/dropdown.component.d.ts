import { AfterViewInit, ApplicationRef, ChangeDetectorRef, ComponentFactoryResolver, ComponentRef, ElementRef, EventEmitter, Injector, NgZone, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChanges, TemplateRef, ViewContainerRef } from '@angular/core';
import { AnimationEvent } from '@angular/animations';
import { EventManager } from '@angular/platform-browser';
import { FocusOrigin } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { AdaptDeviceDetectionService } from '../common/device-detection.service';
import { AdaptOverlayService } from '../common/overlay/index';
import { AdaptTranslateService } from '../common/i18n/index';
import { KeyValueObject } from '../common/common.models';
import { LayerService } from '../common/layer-service';
import { ResizeService } from '../common/resize/resize.service';
import { ScrollManageService } from '../common/scroll-manage.service';
import { Placement, PlacementArray } from '../common/positioning';
import { AdaptAnchorPositionChangeEvent, AdaptDropdownAnimationEvent, AdaptDropdownCloseReason, AdaptDropdownConfig, AdaptDropdownMobileView, AdaptDropdownTogglerType } from './dropdown.model';
import { AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
export declare class AdaptDropdownWindowComponent implements AfterViewInit, OnDestroy {
    private _elementRef;
    private _renderer;
    _cdr: ChangeDetectorRef;
    _ngZone: NgZone;
    anchorPositionChange: EventEmitter<AdaptAnchorPositionChangeEvent>;
    popupAnimationDone: EventEmitter<AdaptDropdownAnimationEvent>;
    _isOpen: boolean;
    content: any;
    templateRef: TemplateRef<any>;
    anchor: HTMLElement;
    placement: PlacementArray;
    appendTo: HTMLElement | 'body';
    positionTo: HTMLElement;
    isMobile: boolean;
    isTablet: boolean;
    customClass: string;
    mobileView: AdaptDropdownMobileView;
    animationMode: any;
    animationPlacement: 'auto' | 'center';
    holdFocusInMenu: boolean;
    holdFocusOnOpen: boolean;
    autoFocusFirst: boolean;
    eventInvokedFrom?: FocusOrigin;
    restoreFocusAfterClose: boolean;
    focusNextElementAfterClose: boolean;
    anchorPositionTrackingTimerId: number;
    anchorPositionTrackingIntervalMs: number;
    enableAnchorPositionTracking: boolean;
    isMobilePlacement: boolean;
    dataPlacement: Placement | 'center';
    container: ElementRef<HTMLDivElement>;
    defaultClass: boolean;
    get mobileClass(): boolean;
    get positionAttr(): Placement | 'center';
    get backdropAnimation(): boolean;
    get popupAnimation(): boolean;
    private _closeAnimationDone;
    private _currentPlacement;
    private _destroyed$;
    constructor(_elementRef: ElementRef<HTMLElement>, _renderer: Renderer2, _cdr: ChangeDetectorRef, _ngZone: NgZone);
    afterAnimationDone(e: AnimationEvent): void;
    ngAfterViewInit(): void;
    recalculatePosition(): void;
    enableTrackingAnchorPosition(): void;
    ngOnDestroy(): void;
    /**
     * Check if click event from this window
     */
    isEventFrom(event: Event): boolean;
    /**
     * Close window
     */
    close(): EventEmitter<void>;
    focusFirstItemInPopup(): void;
    private _applyPosition;
    private _applyTransformOrigin;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptDropdownWindowComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AdaptDropdownWindowComponent, "adapt-dropdown-window", never, {}, {}, never, never>;
}
/**
 * Dropdown menu container
 */
export declare class AdaptDropdownMenuDirective {
    dropdown: any;
    _elementRef: ElementRef;
    isOpen: boolean;
    get transformOrigin(): string;
    transitionStyle: string;
    get transformOriginStyle(): string;
    private _currentPlacement;
    constructor(dropdown: any, _elementRef: ElementRef);
    isEventFrom(event: Event): boolean;
    position(triggerEl: HTMLElement, placement: string | Placement | PlacementArray): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptDropdownMenuDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AdaptDropdownMenuDirective, "[adaptDropdownMenu]", never, {}, {}, never>;
}
export declare class AdaptDropdownMenuTemplateDirective {
    menuTemplateRef: TemplateRef<void>;
    constructor(menuTemplateRef: TemplateRef<void>);
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptDropdownMenuTemplateDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AdaptDropdownMenuTemplateDirective, "ng-template[adaptDropdownMenuTemplate]", never, {}, {}, never>;
}
export declare class AdaptDropdownMenuTemplateComponent {
    templateRef: TemplateRef<void>;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptDropdownMenuTemplateComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AdaptDropdownMenuTemplateComponent, "adapt-dropdown-menu-template", never, {}, {}, never, ["*"]>;
}
/**
 * Marks an element to which dropdown menu will be anchored. This is a simple version
 * of the AdaptDropdownToggle directive. It plays the same role as adaptDropdownToggle but
 * doesn't listen to click events to toggle dropdown menu thus enabling support for
 * events other than click.
 *
 * @since 1.1.0
 */
export declare class AdaptDropdownAnchorDirective implements OnInit, OnDestroy {
    dropdown: AdaptDropdownDirective | any;
    private _elementRef;
    private _renderer;
    anchorEl: any;
    ariaHasPopupAttr: boolean;
    ariaExpandedAttr: boolean;
    private _destroyed$;
    private _shouldFocusPopup;
    constructor(dropdown: AdaptDropdownDirective | any, _elementRef: ElementRef, _renderer: Renderer2);
    ngOnInit(): void;
    ngOnDestroy(): void;
    isEventFrom(event: Event): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptDropdownAnchorDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AdaptDropdownAnchorDirective, "[adaptDropdownAnchor]", never, {}, {}, never>;
}
/**
 * Allows the dropdown to be toggled via click. This directive is optional: you can use AdaptDropdownAnchor as an alternative.
 */
export declare class AdaptDropdownToggleDirective extends AdaptDropdownAnchorDirective {
    /**
     * Uses to control caret visibility
     * @docs-default true
     * @since v10.14.0
     */
    showCaret: boolean;
    /**
     * Set caret color type. Can be useful for instance if the button looks like a link so the caret should reflect link styles
     * @docs-default default
     * @since v10.17.0
     */
    dropdownTogglerType: AdaptDropdownTogglerType;
    ariaExpandedAttr: boolean;
    get toggleClass(): boolean;
    get toggleUpClass(): boolean;
    get toggleLinkClass(): boolean;
    ariaHasPopupAttr: boolean;
    constructor(dropdown: any, elementRef: ElementRef, renderer: Renderer2);
    click(e: MouseEvent | KeyboardEvent): void;
    isDropUp(): boolean;
    toggleOpen(e?: MouseEvent | KeyboardEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptDropdownToggleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<AdaptDropdownToggleDirective, "[adaptDropdownToggle]", never, { "showCaret": "showCaret"; "dropdownTogglerType": "dropdownTogglerType"; }, {}, never>;
}
/**
 * Transforms a node into a dropdown.
 */
export declare class AdaptDropdownDirective extends AdaptRadarAngularGenericDirective implements OnInit, OnDestroy, OnChanges {
    private _componentFactoryResolver;
    private _deviceDetector;
    private _dir;
    private _el;
    private _injector;
    private _renderer;
    private _scrollService;
    private _layerService;
    private _eventManager;
    private _resizeService;
    private _overlayService;
    private _applicationRef;
    private ts;
    private _parentDropdownDirective;
    static LAST_ID: number;
    static ActivePicker: AdaptDropdownDirective;
    menuWindowRef: ComponentRef<AdaptDropdownWindowComponent>;
    dropdownId: number;
    defaultTexts: {
        doneBtnTitle?: string;
        cancelBtnTitle?: string;
    };
    eventInvokedFrom: FocusOrigin;
    /**
     * Indicates that dropdown should be closed when selecting one of dropdown items (click) or pressing ESC.
     * When it is true (default) dropdowns are automatically closed on both outside and inside (menu) clicks.
     * When it is false dropdowns are never automatically closed.
     * When it is 'outside' dropdowns are automatically closed on outside clicks but not on menu clicks.
     * When it is 'inside' dropdowns are automatically on menu clicks but not on outside clicks.
     * @docs-default
     */
    autoClose: boolean | 'outside' | 'inside';
    /**
     * Class for dropdown window component, need to differentiate tablet/mobile sizes per component
     * @docs-default
     */
    customClass: string;
    /**
     * Automatically is 'true' if autoClose != false
     * @docs-default
     */
    closeOnEscape: boolean;
    /**
     * Placement of a popover accepts:
     *    "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
     *    "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
     * and array of above values.
     * @docs-default auto
     */
    placement: PlacementArray;
    /**
     * Animation transform-origin property
     * @docs-default auto
     */
    animationPlacement: 'auto' | 'center';
    /**
     *  Hold `Tab` key focus in the dropdownMenu area
     *  @docs-default false
     */
    holdFocusInMenu: boolean;
    /**
     *  Auto holding focus on dropdownMenu open
     *  @docs-default false
     */
    holdFocusOnOpen: boolean;
    /**
     * Focus first menu item on open
     * @docs-default true
     */
    autoFocusFirst: boolean;
    /**
     *  After menu close, restore focus the element which was in focus before menu open
     *  @docs-default false
     */
    restoreFocusAfterClose: boolean;
    /**
     *  After menu close, focus the next element which was in focus before menu open
     *  @docs-default true
     */
    focusNextElementAfterClose: boolean;
    /**
     * When specified, the drop-down list will be attached to the body
     * @docs-default false
     */
    set appendToBody(state: boolean);
    /**
     * When specified, the drop-down list will be attached to the selected element
     * @docs-default
     */
    set appendTo(element: HTMLElement | 'body');
    /**
     * When specified, the drop-down list will be anchored to the selected element
     * @docs-default
     */
    positionTo: HTMLElement;
    /**
     *  Interval of anchor position tracking when the menu is attached to the body.
     *  Change the value if you have some performance problems or you have a delay in the menu
     *  positioning
     *  @docs-default 30
     */
    anchorPositionTrackingIntervalMs: number;
    /**
     *  Enable an anchor position tracking when the menu is attached to the body
     *  @docs-default true
     */
    enableAnchorPositionTracking: boolean;
    /**
     * Add resize listener on passed HTML element and recalculate dropdown position when element resize. Can be helpful when dropdown has dynamic height
     * @docs-default
     */
    recalculatePositionOnElementResize: HTMLElement;
    /**
     * In some specific cases there is need to manually control mobile checking.
     * One of such cases is typeahead component where usage of "desktop" view of dropdown is much comfortable from UX perspective
     * @docs-default
     */
    setMobileState: boolean;
    /**
     *  An event fired when the dropdown is open
     *  @since v10.9.0
     */
    readonly onOpen: EventEmitter<null>;
    /**
     *  An event fired when the dropdown is closed via internal reason:
     *  escape button click, click inside, click outside or component destroy
     *  @since v10.9.0
     */
    readonly onClose: EventEmitter<AdaptDropdownCloseReason>;
    readonly anchorPositionChange: EventEmitter<AdaptAnchorPositionChangeEvent>;
    readonly popupAnimationDone: EventEmitter<AdaptDropdownAnimationEvent>;
    defaultClass: boolean;
    contentPlacement: ViewContainerRef;
    private _menu;
    private _menuTemplate;
    private _menuTemplateComponent;
    private _anchor;
    private _mobileView;
    private _appendTo;
    /**
     * Setup for mobile view
     * @docs-default
     */
    set mobileView(obj: AdaptDropdownMobileView);
    /**
     * Subject for trapping [open] setter till OnInit complete
     */
    private _init$;
    private _popupWindowService;
    /**
     * An object for manage wrapper's scroll.
     */
    private _scrollManager;
    private _isMobile;
    private _isTablet;
    private _animationMode;
    private _open;
    private _removeTapEventListener;
    private _eventType;
    private _closing;
    private _closeSubscription;
    private _removeMenuWindowRef$;
    private _openTimeout;
    private _overlayWithPortal;
    private _overlayConnectedPositions;
    constructor(config: AdaptDropdownConfig, _componentFactoryResolver: ComponentFactoryResolver, _deviceDetector: AdaptDeviceDetectionService, _dir: Directionality, _el: ElementRef, _injector: Injector, _renderer: Renderer2, _scrollService: ScrollManageService, _layerService: LayerService, _eventManager: EventManager, _resizeService: ResizeService, _overlayService: AdaptOverlayService, _applicationRef: ApplicationRef, ts: AdaptTranslateService, _parentDropdownDirective: AdaptDropdownDirective, _adaptRadarService: AdaptRadarAngularService);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    setDefaultTexts(translation: KeyValueObject): void;
    /**
     * Checks if the dropdown menu is open or not.
     */
    isOpen(): boolean;
    /**
     * Opens the dropdown menu of a given navbar or tabbed navigation.
     */
    open(event?: MouseEvent | KeyboardEvent): void;
    /**
     * Closes the dropdown menu of a given navbar or tabbed navigation.
     */
    close(reason?: AdaptDropdownCloseReason): void;
    /**
     * Toggles the dropdown menu of a given navbar or tabbed navigation.
     */
    toggle(e: MouseEvent | KeyboardEvent): void;
    focusFirstItemInPopup(): void;
    isEventFromMenu(e: Event): boolean;
    private _createMenuWindowRef;
    private _removeMenuWindowRef;
    private _openOverlay;
    private _closeOverlay;
    private _closeFromClick;
    private _isEventFromToggle;
    private _markAsActive;
    private _closeIfActive;
    private _closeActive;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptDropdownDirective, [null, null, null, null, null, null, null, null, null, null, null, null, null, null, { optional: true; skipSelf: true; }, null]>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AdaptDropdownDirective, "adapt-dropdown, [adaptDropdown]", ["adaptDropdown"], { "autoClose": "autoClose"; "customClass": "customClass"; "closeOnEscape": "closeOnEscape"; "placement": "placement"; "animationPlacement": "animationPlacement"; "holdFocusInMenu": "holdFocusInMenu"; "holdFocusOnOpen": "holdFocusOnOpen"; "autoFocusFirst": "autoFocusFirst"; "restoreFocusAfterClose": "restoreFocusAfterClose"; "focusNextElementAfterClose": "focusNextElementAfterClose"; "appendToBody": "appendToBody"; "appendTo": "appendTo"; "positionTo": "positionTo"; "anchorPositionTrackingIntervalMs": "anchorPositionTrackingIntervalMs"; "enableAnchorPositionTracking": "enableAnchorPositionTracking"; "recalculatePositionOnElementResize": "recalculatePositionOnElementResize"; "setMobileState": "setMobileState"; "mobileView": "mobileView"; }, { "onOpen": "onOpen"; "onClose": "onClose"; "anchorPositionChange": "anchorPositionChange"; "popupAnimationDone": "popupAnimationDone"; }, ["_menu", "_menuTemplate", "_menuTemplateComponent", "_anchor"], ["[adaptDropdownAnchor]", "[adaptDropdownToggle]"]>;
}
