import { RxDatetimeStruct } from '../adapt-rx-datetime.types';
/**
 * parseDateFromString() function
 *
 * Parses a string representation of a date into a Date object by matching
 * specified date formats in a specified locale
 */
export declare function parseDateFromString(value: string, formats: string[], locale: string): Date;
/**
 * dateFromUnixTime() function
 *
 * Converts an input unix timestamp into a Date object
 */
export declare function dateFromUnixTime(value: number): Date;
/**
 * getDateFromParts() function
 *
 * Converts an extended datetime struct object into a Date object, respecting the time zone specified in the struct.
 *
 * Note: if a timezone observes Daylight Savings, datetime structs whose parts fall during the "lost" hour
 * during spring ahead to daylight savings technically have no matching Date object; in that case the
 * the resulting Date will be adjusted forward 1 hour (for example, there is no 2am on March 14, 2021 in Vancouver,
 * so a struct specifying these parts will translate into a Date object at 3am on that day.
 * Conversely, datetime structs whose parts fall during the "repeated" hour during fall back from daylight
 * savings are technically ambiguous because they match 2 separate Date objects; in that case, the resulting
 * Date is the earlier of the 2 matches (for example, there are two separate moments in time corresponding
 * to 1am on November 7, 2021 in Vancouver, so a struct specifying these parts translates to 1am before the time
 * falls back to standard time). In particular, there is no struct that converts to the second of the repeated hours
 * during the fall back to standard time.
 * This behaviour matches that of the Date constructor when applied to the same date parts in the client timezone.
 */
export declare function getDateFromParts(parts: RxDatetimeStruct): Date;
