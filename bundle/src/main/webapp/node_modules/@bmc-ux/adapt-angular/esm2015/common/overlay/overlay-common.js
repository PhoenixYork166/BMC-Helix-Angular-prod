import { ConnectionPositionPair } from '@angular/cdk/overlay';
import { AdaptBlockScrollStrategy } from './scroll/block-scroll-strategy';
import { AdaptRepositionScrollStrategy } from './scroll/reposition-scroll-strategy';
import { AdaptFlexibleConnectedPositionStrategy } from './position/flexible-connected-position-strategy';
const OVERLAY_DEFAULT_OFFSET = 0;
const OVERLAY_FLOAT_CURSOR_DEFAULT_OFFSET = {
    bottomOffsetX: 0,
    bottomOffsetY: 30,
    topOffsetX: 0,
    topOffsetY: -20
};
const ORIGIN_CONNECTION_POSITION = {
    topCenter: { originX: 'center', originY: 'top' },
    topStart: { originX: 'start', originY: 'top' },
    topEnd: { originX: 'end', originY: 'top' },
    startCenter: { originX: 'start', originY: 'center' },
    startTop: { originX: 'start', originY: 'top' },
    startBottom: { originX: 'start', originY: 'bottom' },
    endCenter: { originX: 'end', originY: 'center' },
    endTop: { originX: 'end', originY: 'top' },
    endBottom: { originX: 'end', originY: 'bottom' },
    bottomCenter: { originX: 'center', originY: 'bottom' },
    bottomStart: { originX: 'start', originY: 'bottom' },
    bottomEnd: { originX: 'end', originY: 'bottom' }
};
const OVERLAY_CONNECTION_POSITION = {
    topCenter: { overlayX: 'center', overlayY: 'top' },
    topStart: { overlayX: 'start', overlayY: 'top' },
    topEnd: { overlayX: 'end', overlayY: 'top' },
    startCenter: { overlayX: 'start', overlayY: 'center' },
    startTop: { overlayX: 'start', overlayY: 'top' },
    startBottom: { overlayX: 'start', overlayY: 'bottom' },
    endCenter: { overlayX: 'end', overlayY: 'center' },
    endTop: { overlayX: 'end', overlayY: 'top' },
    endBottom: { overlayX: 'end', overlayY: 'bottom' },
    bottomCenter: { overlayX: 'center', overlayY: 'bottom' },
    bottomStart: { overlayX: 'start', overlayY: 'bottom' },
    bottomEnd: { overlayX: 'end', overlayY: 'bottom' }
};
const CONNECTED_POSITION = {
    topCenter: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.topCenter), OVERLAY_CONNECTION_POSITION.bottomCenter),
    topStart: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.topStart), OVERLAY_CONNECTION_POSITION.bottomStart),
    topEnd: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.topEnd), OVERLAY_CONNECTION_POSITION.bottomEnd),
    startCenter: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.startCenter), OVERLAY_CONNECTION_POSITION.endCenter),
    startTop: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.startTop), OVERLAY_CONNECTION_POSITION.endTop),
    startBottom: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.startBottom), OVERLAY_CONNECTION_POSITION.endBottom),
    endCenter: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.endCenter), OVERLAY_CONNECTION_POSITION.startCenter),
    endTop: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.endTop), OVERLAY_CONNECTION_POSITION.startTop),
    endBottom: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.endBottom), OVERLAY_CONNECTION_POSITION.startBottom),
    bottomCenter: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.bottomCenter), OVERLAY_CONNECTION_POSITION.topCenter),
    bottomStart: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.bottomStart), OVERLAY_CONNECTION_POSITION.topStart),
    bottomEnd: Object.assign(Object.assign({}, ORIGIN_CONNECTION_POSITION.bottomEnd), OVERLAY_CONNECTION_POSITION.topEnd),
};
function getLTRConnectedPositions(offset = OVERLAY_DEFAULT_OFFSET) {
    return {
        'top': Object.assign(Object.assign({}, CONNECTED_POSITION.topCenter), { offsetY: -offset }),
        'left': Object.assign(Object.assign({}, CONNECTED_POSITION.startCenter), { offsetX: -offset }),
        'right': Object.assign(Object.assign({}, CONNECTED_POSITION.endCenter), { offsetX: offset }),
        'bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomCenter), { offsetY: offset }),
        'top-left': Object.assign(Object.assign({}, CONNECTED_POSITION.topStart), { offsetY: -offset }),
        'top-right': Object.assign(Object.assign({}, CONNECTED_POSITION.topEnd), { offsetY: -offset }),
        'left-top': Object.assign(Object.assign({}, CONNECTED_POSITION.startTop), { offsetX: -offset }),
        'left-bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.startBottom), { offsetX: -offset }),
        'right-top': Object.assign(Object.assign({}, CONNECTED_POSITION.endTop), { offsetX: offset }),
        'right-bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.endBottom), { offsetX: offset }),
        'bottom-left': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomStart), { offsetY: offset }),
        'bottom-right': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomEnd), { offsetY: offset }),
        'start': Object.assign(Object.assign({}, CONNECTED_POSITION.startCenter), { offsetX: -offset }),
        'end': Object.assign(Object.assign({}, CONNECTED_POSITION.endCenter), { offsetX: offset }),
        'top-start': Object.assign(Object.assign({}, CONNECTED_POSITION.topStart), { offsetY: -offset }),
        'top-end': Object.assign(Object.assign({}, CONNECTED_POSITION.topEnd), { offsetY: -offset }),
        'start-top': Object.assign(Object.assign({}, CONNECTED_POSITION.startTop), { offsetX: -offset }),
        'start-bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.startBottom), { offsetX: -offset }),
        'end-top': Object.assign(Object.assign({}, CONNECTED_POSITION.endTop), { offsetX: offset }),
        'end-bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.endBottom), { offsetX: offset }),
        'bottom-start': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomStart), { offsetY: offset }),
        'bottom-end': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomEnd), { offsetY: offset })
    };
}
function getRTLConnectedPositions(offset = OVERLAY_DEFAULT_OFFSET) {
    return {
        'top': Object.assign(Object.assign({}, CONNECTED_POSITION.topCenter), { offsetY: -offset }),
        'left': Object.assign(Object.assign({}, CONNECTED_POSITION.endCenter), { offsetX: offset }),
        'right': Object.assign(Object.assign({}, CONNECTED_POSITION.startCenter), { offsetX: -offset }),
        'bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomCenter), { offsetY: offset }),
        'top-left': Object.assign(Object.assign({}, CONNECTED_POSITION.topEnd), { offsetY: -offset }),
        'top-right': Object.assign(Object.assign({}, CONNECTED_POSITION.topStart), { offsetY: -offset }),
        'left-top': Object.assign(Object.assign({}, CONNECTED_POSITION.endTop), { offsetX: offset }),
        'left-bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.endBottom), { offsetX: offset }),
        'right-top': Object.assign(Object.assign({}, CONNECTED_POSITION.startTop), { offsetX: -offset }),
        'right-bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.startBottom), { offsetX: -offset }),
        'bottom-left': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomEnd), { offsetY: -offset }),
        'bottom-right': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomStart), { offsetY: -offset }),
        'start': Object.assign(Object.assign({}, CONNECTED_POSITION.startCenter), { offsetX: offset }),
        'end': Object.assign(Object.assign({}, CONNECTED_POSITION.endCenter), { offsetX: -offset }),
        'top-start': Object.assign(Object.assign({}, CONNECTED_POSITION.topStart), { offsetY: -offset }),
        'top-end': Object.assign(Object.assign({}, CONNECTED_POSITION.topEnd), { offsetY: -offset }),
        'start-top': Object.assign(Object.assign({}, CONNECTED_POSITION.startTop), { offsetX: offset }),
        'start-bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.startBottom), { offsetX: offset }),
        'end-top': Object.assign(Object.assign({}, CONNECTED_POSITION.endTop), { offsetX: -offset }),
        'end-bottom': Object.assign(Object.assign({}, CONNECTED_POSITION.endBottom), { offsetX: -offset }),
        'bottom-start': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomStart), { offsetY: offset }),
        'bottom-end': Object.assign(Object.assign({}, CONNECTED_POSITION.bottomEnd), { offsetY: offset })
    };
}
export function getOverlayConnectedPositions(direction, offset = OVERLAY_DEFAULT_OFFSET) {
    return direction === 'rtl' ? getRTLConnectedPositions(offset) : getLTRConnectedPositions(offset);
}
export function getOverlayConnectedPosition(positionName, direction, config) {
    const positionList = getOverlayConnectedPositions(direction);
    return Object.assign(Object.assign({}, positionList[positionName.replace('left', 'start').replace('right', 'end')]), (config || {}));
}
export function getPositionStrategy(connectedPositions, origin, positionStrategy, transformOriginSelector, direction, document, overlay, overlayContainer, platform, viewportRuler) {
    let overlayPositionStrategy;
    switch (positionStrategy) {
        case 'center': {
            overlayPositionStrategy = overlay
                .position()
                .global()
                .centerHorizontally()
                .centerVertically();
            break;
        }
        case 'float': {
            overlayPositionStrategy = overlay
                .position()
                .flexibleConnectedTo(origin)
                .withPositions([
                // Bottom
                new ConnectionPositionPair({ originX: 'center', originY: 'bottom' }, { overlayX: direction === 'rtl' ? 'end' : 'start', overlayY: 'top' }, OVERLAY_FLOAT_CURSOR_DEFAULT_OFFSET.bottomOffsetX, OVERLAY_FLOAT_CURSOR_DEFAULT_OFFSET.bottomOffsetY),
                // Top
                new ConnectionPositionPair({ originX: 'center', originY: 'top' }, { overlayX: direction === 'rtl' ? 'end' : 'start', overlayY: 'bottom' }, OVERLAY_FLOAT_CURSOR_DEFAULT_OFFSET.topOffsetX, OVERLAY_FLOAT_CURSOR_DEFAULT_OFFSET.topOffsetY)
            ]);
            break;
        }
        case 'connected': {
            if (!origin) {
                throw (new Error('ADAPT-ANGULAR Error! Overlay with positionStrategy: \'connected\' should have origin'));
            }
            const overlayPositions = connectedPositions && connectedPositions.length ? connectedPositions : [
                getOverlayConnectedPosition('top'),
                getOverlayConnectedPosition('start', direction),
                getOverlayConnectedPosition('end', direction),
                getOverlayConnectedPosition('bottom')
            ];
            const adaptFlexibleConnectedPositionStrategy = new AdaptFlexibleConnectedPositionStrategy(origin, viewportRuler, document, platform, overlayContainer);
            overlayPositionStrategy = adaptFlexibleConnectedPositionStrategy
                .withTransformOriginOn(transformOriginSelector)
                .withPush(false)
                .withFlexibleDimensions(true)
                .withGrowAfterOpen(true)
                .withPositions(overlayPositions);
            break;
        }
        default: {
            overlayPositionStrategy = overlay.position().global();
        }
    }
    return overlayPositionStrategy;
}
export function getScrollStrategy(scrollStrategy, overlay, viewportRuler, ngZone, repositionScrollStrategyConfig) {
    let _scrollStrategy = overlay.scrollStrategies.noop();
    switch (scrollStrategy) {
        case 'block': {
            _scrollStrategy = new AdaptBlockScrollStrategy(viewportRuler, document);
            break;
        }
        case 'close': {
            _scrollStrategy = overlay.scrollStrategies.close();
            break;
        }
        case 'reposition': {
            _scrollStrategy = new AdaptRepositionScrollStrategy(viewportRuler, ngZone, repositionScrollStrategyConfig);
            break;
        }
    }
    return _scrollStrategy;
}
export function getCalculatedOverlayConfig(adaptOverlayConfig, overlayConfig, overlay, direction, viewportRuler, ngZone, document, platform, overlayContainer) {
    const calculatedOverlayConfig = {
        positionStrategy: getPositionStrategy(adaptOverlayConfig === null || adaptOverlayConfig === void 0 ? void 0 : adaptOverlayConfig.connectedPositions, adaptOverlayConfig === null || adaptOverlayConfig === void 0 ? void 0 : adaptOverlayConfig.origin, adaptOverlayConfig === null || adaptOverlayConfig === void 0 ? void 0 : adaptOverlayConfig.positionStrategy, adaptOverlayConfig === null || adaptOverlayConfig === void 0 ? void 0 : adaptOverlayConfig.transformOriginSelector, direction, document, overlay, overlayContainer, platform, viewportRuler),
        scrollStrategy: getScrollStrategy(adaptOverlayConfig === null || adaptOverlayConfig === void 0 ? void 0 : adaptOverlayConfig.scrollStrategy, overlay, viewportRuler, ngZone, adaptOverlayConfig.repositionScrollStrategyConfig),
        direction: direction,
        minWidth: 10,
        minHeight: 10 // withFlexibleDimensions requires some default value for correct work
    };
    return Object.assign(Object.assign({}, calculatedOverlayConfig), (overlayConfig || {}));
}
//# sourceMappingURL=overlay-common.js.map