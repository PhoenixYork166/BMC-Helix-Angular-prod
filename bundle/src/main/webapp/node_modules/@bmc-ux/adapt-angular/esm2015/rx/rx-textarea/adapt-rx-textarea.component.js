import { ChangeDetectorRef, Component, ElementRef, Input, NgZone, Optional, Renderer2, Self, ViewChild, ViewEncapsulation } from '@angular/core';
import { NgControl } from '@angular/forms';
import { take, takeUntil } from 'rxjs/operators';
import { isString } from 'lodash-es';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularCustomEventType, AdaptRadarAngularService } from '../../common/radar/adapt-radar';
import { AdaptRxFeedbackComponent, AdaptRxFormControlDirective } from '../form-control/index';
import { AdaptRxTextareaConfigService } from './adapt-rx-textarea-config.service';
import { AdaptTranslateService } from '../../common/i18n/index';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "./adapt-rx-textarea-config.service";
import * as i3 from "../../common/i18n/index";
import * as i4 from "../../common/radar/adapt-radar";
import * as i5 from "../form-control/rx-control-label/adapt-rx-control-label.component";
import * as i6 from "../form-control/rx-feedback/adapt-rx-feedback.component";
const _c0 = ["textareaRef"];
const _c1 = ["adaptRxFeedbackRef"];
export class AdaptRxTextareaComponent extends AdaptRxFormControlDirective {
    constructor(ngControl, _renderer, _ngZone, adaptRxTextareaConfigService, _changeDetectorRef, ts, _adaptRadarService, _elem) {
        super(ngControl, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRxTextarea, _changeDetectorRef);
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        this.ts = ts;
        this.controlName = 'textarea';
        this.analyticsComponentName = AdaptRadarAngularCustomEventName;
        /**
         * Control size
         * @docs-default default
         */
        this.size = 'default';
        /**
         * Show success appearance when no errors
         * @docs-default false
         */
        this.showValidState = false;
        /**
         * Show success icon when no errors
         * @docs-default false
         */
        this.showValidStateIcon = false;
        /**
         * Show error icon when errors
         * @docs-default false
         */
        this.showInvalidStateIcon = false;
        /**
         * Use disable styles for readonly state
         * @docs-default false
         */
        this.disabledStyleForReadonlyState = false;
        this._initComplete = false;
        this._isAutoRowsCalculation = false;
        this.size = adaptRxTextareaConfigService.size;
        this._rows = adaptRxTextareaConfigService.rows;
        this._maxRows = adaptRxTextareaConfigService.maxRows;
        this.showValidState = adaptRxTextareaConfigService.showValidState;
        this.showValidStateIcon = adaptRxTextareaConfigService.showValidStateIcon;
        this.showInvalidStateIcon = adaptRxTextareaConfigService.showInvalidStateIcon;
        this.disabledStyleForReadonlyState = adaptRxTextareaConfigService.disabledStyleForReadonlyState;
    }
    // Textarea [rows] attribute
    /**
     * Native textarea rows count
     * @docs-default
     */
    set rows(value) {
        this._rows = value;
        this._checkForAutoHeight();
    }
    // Max rows for auto expanding
    /**
     * Native textarea maximum rows count
     * @docs-default
     */
    set maxRows(value) {
        this._maxRows = value;
        this._checkForAutoHeight();
    }
    ngOnInit() {
        super.ngOnInit();
        this._initComplete = true;
        this._checkForAutoHeight();
    }
    get value() {
        return this._value;
    }
    set value(value) {
        if (value !== this._value) {
            this._value = value;
            this._onChange(this._value);
            this.stateChanges$.next();
        }
    }
    /**
     * Returns autocomplete attribute value for native element
     */
    get getAutocompleteValue() {
        return isString(this.autocomplete) ? this.autocomplete : (this.autocomplete ? 'on' : 'off');
    }
    /**
     * Check if the control has UI error state
     */
    get hasDangerState() {
        return this.adaptRxFeedbackRef.hasUIErrorState;
    }
    /**
     * Check if component should have success appearance if no errors
     */
    get hasSuccessState() {
        return this.showValidState && this.ngControl.touched && !this.ngControl.errors;
    }
    /**
     * Check if the invalid state icon should be displayed when has danger state
     */
    get hasDangerStateIcon() {
        return this.hasDangerState && this.showInvalidStateIcon;
    }
    /**
     * Check if the valid state icon should be displayed when has success state
     */
    get hasSuccessStateIcon() {
        return this.hasSuccessState && this.showValidStateIcon;
    }
    /**
     * Textarea element (input) event handler
     */
    inputValueChange() {
        this._checkNativeValue();
    }
    /**
     * Extend super.writeValue for auto expand detection
     */
    writeValue(value) {
        if (value !== undefined) {
            this._value = value;
            this._previousNativeValue = undefined;
        }
        if (this._isAutoRowsCalculation) {
            // Timeout is needed to prevent auto calculation before the textarea native value updated
            this._ngZone.onStable
                .pipe(takeUntil(this.destroy$), take(1))
                .subscribe(() => {
                this._calculateHeight();
            });
        }
    }
    /**
     * Extend parent method
     */
    blurHandler(event) {
        var _a;
        super.blurHandler(event);
        this._onTouched();
        this._adaptRadarService.sendCustomEventForAllProviders(AdaptRadarAngularCustomEventName.AdaptRxTextarea, {
            GroupName: this.adaptRadarGroupName,
            EventType: AdaptRadarAngularCustomEventType.Blur,
            Label: this.label,
            Subtext: !!this.subLabel,
            TextEntered: !!this.value,
            CharCount: (_a = this.value) === null || _a === void 0 ? void 0 : _a.length,
            Hinted: !!this.tooltip,
            Required: this.required,
            Disabled: this.disabled,
            ReadOnly: this.readonly,
            FieldSize: this.size,
            // DynamicEntry: false
        });
    }
    /**
     * Extend parent method
     */
    focusHandler(event) {
        var _a;
        super.focusHandler(event);
        this._adaptRadarService.sendCustomEventForAllProviders(AdaptRadarAngularCustomEventName.AdaptRxTextarea, {
            GroupName: this.adaptRadarGroupName,
            EventType: AdaptRadarAngularCustomEventType.Focus,
            Label: this.label,
            Subtext: !!this.subLabel,
            TextEntered: !!this.value,
            CharCount: (_a = this.value) === null || _a === void 0 ? void 0 : _a.length,
            Hinted: !!this.tooltip,
            Required: this.required,
            Disabled: this.disabled,
            ReadOnly: this.readonly,
            FieldSize: this.size,
            // DynamicEntry: false
        });
    }
    /**
     * Implementation from the base class
     * Focus the native element if [autofocus] == true
     */
    _focusNativeElement() {
        this.textareaRef.nativeElement.focus();
    }
    /**
     * Detect if auto expand mode enabled
     */
    _checkForAutoHeight() {
        if (!this._initComplete) {
            return;
        }
        if (this._rows && this._maxRows && this._rows < this._maxRows) {
            this._isAutoRowsCalculation = true;
            const textarea = this.textareaRef.nativeElement;
            textarea.rows = this._maxRows;
            this._renderer.setStyle(this.textareaRef.nativeElement, 'max-height', `${textarea.offsetHeight}px`);
            textarea.rows = this._rows;
            this._renderer.setStyle(this.textareaRef.nativeElement, 'min-height', `${textarea.offsetHeight}px`);
            this._renderer.setStyle(this.textareaRef.nativeElement, 'resize', 'none');
        }
        else {
            this._isAutoRowsCalculation = false;
            this._renderer.removeStyle(this.textareaRef.nativeElement, 'min-height');
            this._renderer.removeStyle(this.textareaRef.nativeElement, 'max-height');
            this._renderer.removeStyle(this.textareaRef.nativeElement, 'resize');
        }
    }
    /**
     * Auto calculate textarea height according to content
     */
    _calculateHeight() {
        const textarea = this.textareaRef.nativeElement;
        // Reset field height
        textarea.style.height = 'inherit';
        // Get the computed styles for the element
        const computed = window.getComputedStyle(textarea);
        // Calculate the height
        const height = parseInt(computed.getPropertyValue('border-top-width'), 10)
            + textarea.scrollHeight
            + parseInt(computed.getPropertyValue('border-bottom-width'), 10);
        textarea.style.height = height + 'px';
    }
    /**
     * Check if the native element value was changed and propagate change
     */
    _checkNativeValue() {
        const newValue = this.textareaRef.nativeElement.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.value = newValue;
            if (this._isAutoRowsCalculation) {
                this._calculateHeight();
            }
        }
    }
}
AdaptRxTextareaComponent.ɵfac = function AdaptRxTextareaComponent_Factory(t) { return new (t || AdaptRxTextareaComponent)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptRxTextareaConfigService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.AdaptTranslateService), i0.ɵɵdirectiveInject(i4.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRxTextareaComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxTextareaComponent, selectors: [["adapt-rx-textarea"]], viewQuery: function AdaptRxTextareaComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textareaRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptRxFeedbackRef = _t.first);
    } }, inputs: { rows: "rows", maxRows: "maxRows", autocomplete: "autocomplete", placeholder: "placeholder", size: "size", showValidState: "showValidState", showValidStateIcon: "showValidStateIcon", showInvalidStateIcon: "showInvalidStateIcon", validStateMessage: "validStateMessage", disabledStyleForReadonlyState: "disabledStyleForReadonlyState" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 11, vars: 48, consts: [[3, "for", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"], [1, "form-control", "rx-form-control", 3, "id", "value", "required", "disabled", "readOnly", "autofocus", "input", "focus", "blur"], ["textareaRef", ""], [3, "ariaErrorMessage", "errors", "successMessage", "warningMessage", "controlTouched", "messageAppeared"], ["adaptRxFeedbackRef", ""]], template: function AdaptRxTextareaComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div");
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelement(2, "adapt-rx-control-label", 0);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵelementStart(4, "textarea", 1, 2);
        i0.ɵɵlistener("input", function AdaptRxTextareaComponent_Template_textarea_input_4_listener() { return ctx.inputValueChange(); })("focus", function AdaptRxTextareaComponent_Template_textarea_focus_4_listener($event) { return ctx.focusHandler($event); })("blur", function AdaptRxTextareaComponent_Template_textarea_blur_4_listener($event) { return ctx.blurHandler($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n\n  ");
        i0.ɵɵelementStart(7, "adapt-rx-feedback", 3, 4);
        i0.ɵɵlistener("messageAppeared", function AdaptRxTextareaComponent_Template_adapt_rx_feedback_messageAppeared_7_listener($event) { return ctx.handleMessageAppeared($event, ctx.analyticsComponentName.AdaptRxTextarea); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(9, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n");
    } if (rf & 2) {
        i0.ɵɵclassProp("has-danger", ctx.hasDangerState)("has-success", ctx.hasSuccessState)("has-warning", ctx.warningMessage);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("subLabel", ctx.subLabel)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltip)("testID", ctx.testID);
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("form-control-disabled-look", ctx.readonly && ctx.disabledStyleForReadonlyState)("form-control-danger", ctx.hasDangerStateIcon)("form-control-success", ctx.hasSuccessStateIcon)("form-control-sm", ctx.size === "sm")("form-control-lg", ctx.size === "lg");
        i0.ɵɵproperty("id", ctx.id)("value", ctx.value)("required", ctx.required)("disabled", ctx.disabled)("readOnly", ctx.readonly)("autofocus", ctx.autofocus);
        i0.ɵɵattribute("rows", ctx._rows)("autocomplete", ctx.getAutocompleteValue)("tabindex", ctx.tabIndex)("placeholder", ctx.placeholder)("name", ctx.name)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy)("aria-required", ctx.required)("aria-invalid", ctx.hasDangerState)("aria-errormessage", ctx.ariaErrorMessage)("aria-readonly", ctx.readonly)("aria-disabled", ctx.disabled)("data-testid", ctx.testID);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ariaErrorMessage", ctx.ariaErrorMessage)("errors", ctx.ngControl.errors)("successMessage", ctx.validStateMessage)("warningMessage", ctx.warningMessage)("controlTouched", ctx.ngControl.touched);
    } }, directives: [i5.AdaptRxControlLabelComponent, i6.AdaptRxFeedbackComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxTextareaComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-textarea',
                templateUrl: './adapt-rx-textarea.component.html',
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i2.AdaptRxTextareaConfigService }, { type: i0.ChangeDetectorRef }, { type: i3.AdaptTranslateService }, { type: i4.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { rows: [{
            type: Input
        }], maxRows: [{
            type: Input
        }], autocomplete: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], size: [{
            type: Input
        }], showValidState: [{
            type: Input
        }], showValidStateIcon: [{
            type: Input
        }], showInvalidStateIcon: [{
            type: Input
        }], validStateMessage: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], textareaRef: [{
            type: ViewChild,
            args: ['textareaRef', { static: true }]
        }], adaptRxFeedbackRef: [{
            type: ViewChild,
            args: ['adaptRxFeedbackRef', { static: true }]
        }] }); })();
//# sourceMappingURL=adapt-rx-textarea.component.js.map