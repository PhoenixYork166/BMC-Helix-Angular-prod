import { Component, ContentChild, ContentChildren, ElementRef, EventEmitter, Input, NgZone, Output, QueryList, Renderer2 } from '@angular/core';
import { asyncScheduler, BehaviorSubject, Subject } from 'rxjs';
import { distinctUntilChanged, take, takeUntil, throttleTime } from 'rxjs/operators';
import { ResizeService } from '../common/resize/resize.service';
import { AdaptSubnavItemComponent } from './subnav-item.component';
import { AdaptSubnavDropdownComponent } from './subnav-dropdown.component';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "../common/resize/resize.service";
import * as i2 from "../common/radar/adapt-radar";
const _c0 = ["*"];
export class AdaptSubnavComponent extends AdaptRadarAngularGenericDirective {
    constructor(_elementRef, _resizeService, _renderer, _ngZone, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptSubnav);
        this._elementRef = _elementRef;
        this._resizeService = _resizeService;
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        /**
         * The minimum free space when overflow items start collapsing
         * @docs-default 20
         */
        this.gutter = 20;
        /**
         * Default css class list for host element
         * @docs-default d-flex flex-nowrap text-no-wrap
         */
        this.defaultCssClass = 'd-flex flex-nowrap text-no-wrap';
        this.visibilityChanged = new EventEmitter();
        this.hasHiddenItems$ = new BehaviorSubject(false);
        this._destroyed$ = new Subject();
        this.subnavItemsByHidePriority = [];
    }
    ngOnInit() {
        this.defaultCssClass.split(' ').forEach(cssClass => {
            this._renderer.addClass(this._elementRef.nativeElement, cssClass);
        });
    }
    ngAfterContentInit() {
        this.subnavItemsByHidePriority = this.getSubnavItemsByHidePriority();
        this.subnavDropdown.subnavItemsList = this.subnavItemsList;
        this.hasHiddenItems$
            .pipe(distinctUntilChanged())
            .subscribe(value => {
            this.subnavDropdown.showDropdown$.next(value);
        });
        // In case items changed need to recalculate visibility
        this.subnavItemsList.changes.subscribe(() => {
            this.subnavItemsByHidePriority = this.getSubnavItemsByHidePriority();
            this.subnavDropdown.subnavItemsList = this.subnavItemsList;
            this.checkSubnavItemsVisibility();
        });
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        const resize$ = new Subject();
        resize$
            .pipe(takeUntil(this._destroyed$), throttleTime(100, asyncScheduler, { trailing: true }))
            .subscribe(() => {
            this.checkSubnavItemsVisibility();
        });
        this._resizeService.addResizeEventListener(this._elementRef.nativeElement, resize$.next.bind(resize$));
        this._ngZone.onStable.pipe(takeUntil(this._destroyed$), take(1)).subscribe(() => {
            this.checkSubnavItemsVisibility();
        });
    }
    ngOnDestroy() {
        this._resizeService.removeResizeEventListener(this._elementRef.nativeElement);
        this._destroyed$.next();
        this._destroyed$.complete();
    }
    getSubnavItemsByHidePriority() {
        return this.subnavItemsList
            .toArray()
            .sort((prevItem, nextItem) => prevItem.priority - nextItem.priority);
    }
    checkSubnavItemsVisibility() {
        const subnavContainerWidth = Math.floor(this._elementRef.nativeElement.offsetWidth - this.subnavDropdown.width - this.gutter);
        let totalContentWidth = this.subnavItemsByHidePriority.reduce((sum, curr) => {
            return sum + (curr.preventHiding ? curr.width : 0);
        }, 0);
        this.subnavItemsByHidePriority.forEach((subnavItem) => {
            if (subnavItem.preventHiding) {
                return;
            }
            totalContentWidth += subnavItem.width;
            const containerFitsButton = Math.floor(subnavContainerWidth) >= Math.ceil(totalContentWidth);
            subnavItem.isHidden = !containerFitsButton;
        });
        this.hasHiddenItems$.next(Boolean(this.subnavItemsByHidePriority.find(elem => elem.isHidden)));
        this.visibilityChanged.emit(this.subnavItemsByHidePriority);
    }
}
AdaptSubnavComponent.ɵfac = function AdaptSubnavComponent_Factory(t) { return new (t || AdaptSubnavComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.ResizeService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptSubnavComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSubnavComponent, selectors: [["adapt-subnav"], ["", "adaptSubnav", ""]], contentQueries: function AdaptSubnavComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, AdaptSubnavDropdownComponent, 7);
        i0.ɵɵcontentQuery(dirIndex, AdaptSubnavItemComponent, 4);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.subnavDropdown = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.subnavItemsList = _t);
    } }, inputs: { adaptSubnav: "adaptSubnav", gutter: "gutter", defaultCssClass: "defaultCssClass" }, outputs: { visibilityChanged: "visibilityChanged" }, features: [i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 3, vars: 0, template: function AdaptSubnavComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵprojection(1);
        i0.ɵɵtext(2, "\n  ");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSubnavComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-subnav, [adaptSubnav]',
                template: `
    <ng-content></ng-content>
  `
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i1.ResizeService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i2.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { adaptSubnav: [{
            type: Input
        }], gutter: [{
            type: Input
        }], defaultCssClass: [{
            type: Input
        }], visibilityChanged: [{
            type: Output
        }], subnavDropdown: [{
            type: ContentChild,
            args: [AdaptSubnavDropdownComponent, { static: true }]
        }], subnavItemsList: [{
            type: ContentChildren,
            args: [AdaptSubnavItemComponent]
        }] }); })();
//# sourceMappingURL=subnav.component.js.map