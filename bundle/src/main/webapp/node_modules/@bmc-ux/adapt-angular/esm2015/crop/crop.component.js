import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgZone, Output } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { transition, trigger, useAnimation } from '@angular/animations';
import { BehaviorSubject } from 'rxjs';
import { map } from 'rxjs/operators';
import { CropToolError, CropToolState } from './crop.model';
import { GetDragNDrop } from '../common/drag-n-drop';
import { isImgTypeValid } from '../common/utilities';
import { ANIMATION_NAME } from '../common/animation';
import { AdaptTranslateService } from '../common/i18n/index';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@angular/platform-browser";
import * as i2 from "../common/i18n/index";
import * as i3 from "../common/radar/adapt-radar";
import * as i4 from "@angular/common";
function AdaptCropComponent_img_5_Template(rf, ctx) { if (rf & 1) {
    const _r6 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "img", 9);
    i0.ɵɵlistener("load", function AdaptCropComponent_img_5_Template_img_load_0_listener($event) { i0.ɵɵrestoreView(_r6); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.onImageLoad($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("left", ctx_r0.cropImg.pos.x, "px")("top", ctx_r0.cropImg.pos.y, "px")("width", ctx_r0.cropImg.dim.width, "px")("height", ctx_r0.cropImg.dim.height, "px");
    i0.ɵɵproperty("src", ctx_r0.imgURL, i0.ɵɵsanitizeUrl);
} }
function AdaptCropComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 10);
    i0.ɵɵelementStart(1, "i");
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3);
    i0.ɵɵelementStart(4, "i");
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r1.cropArea.width);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r1.texts.px, " \u00D7\n        ");
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r1.cropArea.height);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", ctx_r1.texts.px, "\n      ");
} }
function AdaptCropComponent_img_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "img", 11);
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("left", ctx_r2.cropImg.pos.x, "px")("top", ctx_r2.cropImg.pos.y, "px")("width", ctx_r2.cropImg.dim.width, "px")("height", ctx_r2.cropImg.dim.height, "px");
    i0.ɵɵproperty("src", ctx_r2.imgURL, i0.ɵɵsanitizeUrl);
} }
function AdaptCropComponent_div_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 12);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "div", 13);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelement(4, "div", 14);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵproperty("@fadeOutAnimation", undefined);
} }
function AdaptCropComponent_div_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@fadeOutAnimation", undefined);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r4.placeholder);
} }
export class AdaptCropComponent extends AdaptRadarAngularGenericDirective {
    constructor(_elRef, _domSanitizer, _ngZone, _changeDetectorRef, _ts, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptCrop);
        this._elRef = _elRef;
        this._domSanitizer = _domSanitizer;
        this._ngZone = _ngZone;
        this._changeDetectorRef = _changeDetectorRef;
        this._ts = _ts;
        this.cropArea = {
            width: 100,
            height: 100
        };
        this.cropImg = {
            source: null,
            naturalDim: {
                width: 0,
                height: 0
            },
            dim: {
                width: 0,
                height: 0
            },
            pos: {
                x: 0,
                y: 0
            },
            scale: 100,
            fitScale: 100,
            tolerance: {
                width: 0,
                height: 0
            }
        };
        this.defaultTexts = {};
        this.texts = {};
        /**
         * The color of area out of crop
         * @docs-default rgba(255, 255, 255, .5)
         */
        this.offcutColor = 'rgba(255, 255, 255, .5)';
        /**
         * Label with crop area dimensions
         * @docs-default false
         */
        this.cropAreaLabel = false;
        /**
         * An event fires on image position/scale change.
         * Returns new position
         */
        this.positionChange = new EventEmitter();
        /**
         * An event fires on image cropped.
         * Returns new image as base64 string
         */
        this.cropToBase64 = new EventEmitter();
        /**
         * An event fires on image cropped.
         * Returns new image as Blob
         */
        this.cropToFile = new EventEmitter();
        /* eslint-disable @angular-eslint/no-output-native */
        /**
         * An event fires on error relative to image source, size, load or crop
         */
        this.error = new EventEmitter();
        this._states = CropToolState;
        // eslint-disable-next-line @typescript-eslint/member-ordering
        this.currentState$ = new BehaviorSubject(this._states.Pending);
        this.setDefaultTexts(_ts.getCurrentLanguage());
    }
    /**
     * Crop area width
     * @param v: number
     * @docs-default 100
     */
    set cropWidth(v) {
        if (v && v >= 0) {
            this.cropArea.width = v;
            if (this.currentState$.value === this._states.Ready) {
                this._initImgScale();
                this._updateImgDim();
                this._checkImgPos();
                this._cropImg();
            }
        }
    }
    /**
     * Crop area height
     * @param v: number
     * @docs-default 100
     */
    set cropHeight(v) {
        if (v && v >= 0) {
            this.cropArea.height = v;
            if (this.currentState$.value === this._states.Ready) {
                this._initImgScale();
                this._updateImgDim();
                this._checkImgPos();
                this._cropImg();
            }
        }
    }
    /**
     * Cropping image scale
     * @param v: number
     * @docs-default 100
     */
    set scale(v) {
        if (v >= 0 && v <= 100) {
            this.cropImg.scale = v;
            if (this.currentState$.value === this._states.Ready) {
                this._updateImgDim();
                this._checkImgPos();
                this._cropImg();
                this.positionChange.emit({ x: this.cropImg.pos.x, y: this.cropImg.pos.y, scale: this.cropImg.scale });
            }
        }
    }
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    get showPlaceholder() {
        return this.currentState$.value === this._states.Pending;
    }
    get showLoader() {
        return this.currentState$.value === this._states.Loading;
    }
    get getOffcutColor() {
        return this._domSanitizer.bypassSecurityTrustStyle(this.offcutColor);
    }
    ngOnInit() {
        this.texts.placeholder = this.placeholder;
        this.texts = Object.assign(Object.assign({}, this.defaultTexts), this.texts);
        if (this.image) {
            this._loadImage();
        }
        else {
            this.currentState$.next(this._states.Error);
            this.error.emit({ errCode: CropToolError.Source, errBody: this.texts.empty });
        }
        if (this.cropApi) {
            this.cropApi.fitToCropArea = this._fitToCropArea.bind(this);
            this.cropApi.centerCropImage = this._centerCropImage.bind(this);
        }
    }
    ngOnDestroy() {
        if (this._dragSubscription) {
            this._dragSubscription.unsubscribe();
            this._dragSubscription = null;
        }
    }
    setDefaultTexts(translation) {
        this.defaultTexts.placeholder = translation['adapt.crop.placeholder'];
        this.defaultTexts.empty = translation['adapt.crop.error.empty'];
        this.defaultTexts.type = translation['adapt.crop.error.type'];
        this.defaultTexts.size = translation['adapt.crop.error.size'];
        this.defaultTexts.px = translation['adapt.common.px'];
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    onImageLoad(event) {
        this.cropImg.source = event.target;
        this.cropImg.naturalDim.width = event.target.naturalWidth;
        this.cropImg.naturalDim.height = event.target.naturalHeight;
        this._initImgScale();
        this._updateImgDim();
        this._setInitialImgPos();
        this._initImgDrag();
        this.currentState$.next(this._states.Ready);
        this._cropImg();
    }
    _loadImage() {
        if (typeof this.image === 'string') {
            this.currentState$.next(this._states.Loading);
            this.imgURL = this._domSanitizer.bypassSecurityTrustUrl(this.image);
        }
        else {
            this.image.subscribe(this._loadImageFile.bind(this));
            if (this.image.value) {
                this._loadImageFile(this.image.value);
            }
        }
    }
    _loadImageFile(file) {
        if (!file) {
            return;
        }
        if (isImgTypeValid(file.type)) {
            this.currentState$.next(this._states.Loading);
            const fileReader = new FileReader();
            fileReader.readAsDataURL(file);
            fileReader.onload = (event) => {
                this.imgURL = this._domSanitizer.bypassSecurityTrustUrl(event.target.result);
            };
        }
        else {
            this.currentState$.next(this._states.Error);
            this.error.emit({ errCode: CropToolError.Load, errBody: this.texts.type });
        }
    }
    _initImgScale() {
        const maxScaleSize = {
            width: this.cropImg.naturalDim.width,
            height: this.cropImg.naturalDim.height
        };
        const minScaleSize = {
            width: 0,
            height: 0
        };
        const widthRatio = this.cropArea.width / this.cropImg.naturalDim.width;
        const heightRatio = this.cropArea.height / this.cropImg.naturalDim.height;
        const sizeError = this.cropImg.naturalDim.width < this.cropArea.width || this.cropImg.naturalDim.height < this.cropArea.height;
        if (widthRatio > heightRatio) {
            minScaleSize.height = this.cropArea.height;
            minScaleSize.width = this.cropImg.naturalDim.width * (minScaleSize.height / this.cropImg.naturalDim.height);
            if (sizeError) {
                this.cropImg.naturalDim.width =
                    maxScaleSize.width = this.cropArea.width;
                this.cropImg.naturalDim.height =
                    maxScaleSize.height = this.cropImg.naturalDim.height * (this.cropImg.naturalDim.width / minScaleSize.width);
            }
        }
        else {
            minScaleSize.width = this.cropArea.width;
            minScaleSize.height = this.cropImg.naturalDim.height * (minScaleSize.width / this.cropImg.naturalDim.width);
            if (sizeError) {
                this.cropImg.naturalDim.height = maxScaleSize.height =
                    this.cropArea.height;
                this.cropImg.naturalDim.width = maxScaleSize.width =
                    this.cropImg.naturalDim.width * (this.cropImg.naturalDim.height / minScaleSize.height);
            }
        }
        this.cropImg.dim.width = maxScaleSize.width;
        this.cropImg.dim.height = maxScaleSize.height;
        this.cropImg.tolerance.width = (maxScaleSize.width - minScaleSize.width) / 100;
        this.cropImg.tolerance.height = (maxScaleSize.height - minScaleSize.height) / 100;
        if (sizeError) {
            this.cropImg.fitScale = 100;
            this.error.emit({ errCode: CropToolError.Size, errBody: this.texts.size });
        }
        else {
            this.cropImg.fitScale = minScaleSize.width < minScaleSize.height ?
                (this.cropArea.width - minScaleSize.width) / this.cropImg.tolerance.width :
                (this.cropArea.height - minScaleSize.height) / this.cropImg.tolerance.height;
        }
    }
    _updateImgDim() {
        this.cropImg.dim.width = this.cropImg.naturalDim.width - this.cropImg.tolerance.width * (100 - this.cropImg.scale);
        this.cropImg.dim.height = this.cropImg.naturalDim.height - this.cropImg.tolerance.height * (100 - this.cropImg.scale);
    }
    _setInitialImgPos() {
        if (this.initPosition) {
            this.cropImg.pos.x = this.initPosition.x;
            this.cropImg.pos.y = this.initPosition.y;
        }
        else {
            this.cropImg.pos.x = (this.cropArea.width - this.cropImg.dim.width) / 2;
            this.cropImg.pos.y = (this.cropArea.height - this.cropImg.dim.height) / 2;
        }
        this._checkImgPos();
    }
    _checkImgPos() {
        if (this.cropImg.dim.width < this.cropArea.width) {
            this.cropImg.pos.x = (this.cropArea.width - this.cropImg.dim.width) / 2;
        }
        else {
            if ((Math.abs(this.cropImg.pos.x) + this.cropArea.width) > this.cropImg.dim.width) {
                this.cropImg.pos.x = this.cropArea.width - this.cropImg.dim.width;
            }
            this.cropImg.pos.x = this.cropImg.pos.x <= 0 ? this.cropImg.pos.x : 0;
        }
        if (this.cropImg.dim.height < this.cropArea.height) {
            this.cropImg.pos.y = (this.cropArea.height - this.cropImg.dim.height) / 2;
        }
        else {
            if ((Math.abs(this.cropImg.pos.y) + this.cropArea.height) > this.cropImg.dim.height) {
                this.cropImg.pos.y = this.cropArea.height - this.cropImg.dim.height;
            }
            this.cropImg.pos.y = this.cropImg.pos.y <= 0 ? this.cropImg.pos.y : 0;
        }
    }
    _initImgDrag() {
        if (this._dragSubscription) {
            this._dragSubscription.unsubscribe();
            this._dragSubscription = null;
        }
        let startMoveCoords;
        let startImgCoords;
        const dragStart = (c) => {
            startMoveCoords = c;
            startImgCoords = {
                x: this.cropImg.pos.x,
                y: this.cropImg.pos.y
            };
        };
        const dragEnd = () => {
            this._cropImg();
        };
        this._dragSubscription = GetDragNDrop(this._elRef.nativeElement, null, null, dragStart, dragEnd)
            .pipe(map(moveCoords => {
            return { x: moveCoords.x - startMoveCoords.x, y: moveCoords.y - startMoveCoords.y };
        }))
            .subscribe((value) => {
            const newX = startImgCoords.x + value.x;
            const newY = startImgCoords.y + value.y;
            if (this.cropImg.dim.width >= this.cropArea.width) {
                this.cropImg.pos.x =
                    newX <= 0 ? (Math.abs(newX) > this.cropImg.dim.width - this.cropArea.width ?
                        -this.cropImg.dim.width + this.cropArea.width : newX) : 0;
            }
            else {
                this.cropImg.pos.x = (this.cropArea.width - this.cropImg.dim.width) / 2;
            }
            if (this.cropImg.dim.height >= this.cropArea.height) {
                this.cropImg.pos.y = newY <= 0 ?
                    (Math.abs(newY) > this.cropImg.dim.height - this.cropArea.height ? -this.cropImg.dim.height + this.cropArea.height : newY) : 0;
            }
            else {
                this.cropImg.pos.y = (this.cropArea.height - this.cropImg.dim.height) / 2;
            }
            this._changeDetectorRef.detectChanges();
            this.positionChange.emit({ x: this.cropImg.pos.x, y: this.cropImg.pos.y, scale: this.cropImg.scale });
        });
    }
    _cropImg() {
        // Resize source image
        const sourceCanvas = document.createElement('canvas');
        const sourceContext = sourceCanvas.getContext('2d');
        sourceCanvas.width = this.cropImg.dim.width;
        sourceCanvas.height = this.cropImg.dim.height;
        sourceContext.drawImage(this.cropImg.source, 0, 0, this.cropImg.dim.width, this.cropImg.dim.height);
        // Target image portion
        const cropCanvas = document.createElement('canvas');
        const cropContext = cropCanvas.getContext('2d');
        cropCanvas.width = this.cropArea.width;
        cropCanvas.height = this.cropArea.height;
        cropContext.drawImage(sourceCanvas, -this.cropImg.pos.x, -this.cropImg.pos.y, this.cropArea.width, this.cropArea.height, 0, 0, this.cropArea.width, this.cropArea.height);
        try {
            const imageBase64 = cropCanvas.toDataURL('image/png');
            new Promise((resolve) => {
                cropCanvas.toBlob((result) => this._ngZone.run(() => resolve(result)), 'image/png', 1);
            }).then((result) => {
                if (result) {
                    this.cropToFile.emit(result);
                }
            });
            this.cropToBase64.emit(imageBase64);
        }
        catch (e) {
            this.error.emit({ errCode: CropToolError.Crop, errBody: e });
        }
    }
    _fitToCropArea() {
        if (this.cropImg.scale !== this.cropImg.fitScale) {
            this.scale = this.cropImg.fitScale;
        }
    }
    _centerCropImage() {
        if (this.currentState$.value !== this._states.Ready) {
            return;
        }
        let hasChanges = false;
        if (this.cropImg.dim.width > this.cropArea.width) {
            const newX = -(this.cropImg.dim.width - this.cropArea.width) / 2;
            if (this.cropImg.pos.x !== newX) {
                this.cropImg.pos.x = newX;
                hasChanges = true;
            }
        }
        if (this.cropImg.dim.height > this.cropArea.height) {
            const newY = -(this.cropImg.dim.height - this.cropArea.height) / 2;
            if (this.cropImg.pos.y !== newY) {
                this.cropImg.pos.y = newY;
                hasChanges = true;
            }
        }
        if (hasChanges) {
            this._updateImgDim();
            this._checkImgPos();
            this._cropImg();
            this.positionChange.emit({ x: this.cropImg.pos.x, y: this.cropImg.pos.y, scale: this.cropImg.scale });
        }
    }
}
AdaptCropComponent.ɵfac = function AdaptCropComponent_Factory(t) { return new (t || AdaptCropComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.DomSanitizer), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.AdaptTranslateService), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptCropComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptCropComponent, selectors: [["adapt-crop"]], hostVars: 2, hostBindings: function AdaptCropComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("adapt-crop", true);
    } }, inputs: { image: "image", initPosition: "initPosition", offcutColor: "offcutColor", placeholder: "placeholder", cropAreaLabel: "cropAreaLabel", cropApi: "cropApi", cropWidth: "cropWidth", cropHeight: "cropHeight", scale: "scale" }, outputs: { positionChange: "positionChange", cropToBase64: "cropToBase64", cropToFile: "cropToFile", error: "error" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 21, vars: 15, consts: [[1, "adapt-crop--cut-area-result"], [1, "adapt-crop--img-wrapper"], ["class", "adapt-crop--img", "draggable", "false", "aria-hidden", "true", 3, "src", "left", "top", "width", "height", "load", 4, "ngIf"], ["class", "adapt-crop--dim-label", 4, "ngIf"], [1, "adapt-crop--cut-area-fade"], [1, "adapt-crop--cut-area-offcut"], ["class", "adapt-crop--img", "draggable", "false", "aria-hidden", "true", 3, "src", "left", "top", "width", "height", 4, "ngIf"], ["class", "adapt-crop--overlay-loader", 4, "ngIf"], ["class", "adapt-crop--overlay-placeholder", 4, "ngIf"], ["draggable", "false", "aria-hidden", "true", 1, "adapt-crop--img", 3, "src", "load"], [1, "adapt-crop--dim-label"], ["draggable", "false", "aria-hidden", "true", 1, "adapt-crop--img", 3, "src"], [1, "adapt-crop--overlay-loader"], [1, "loader-container"], [1, "loader-section"], [1, "adapt-crop--overlay-placeholder"]], template: function AdaptCropComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵelementStart(3, "div", 1);
        i0.ɵɵtext(4, "\n        ");
        i0.ɵɵtemplate(5, AdaptCropComponent_img_5_Template, 1, 9, "img", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(6, "\n\n      ");
        i0.ɵɵtemplate(7, AdaptCropComponent_div_7_Template, 7, 4, "div", 3);
        i0.ɵɵtext(8, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(9, "\n\n    ");
        i0.ɵɵelement(10, "div", 4);
        i0.ɵɵtext(11, "\n\n    ");
        i0.ɵɵelementStart(12, "div", 5);
        i0.ɵɵtext(13, "\n      ");
        i0.ɵɵtemplate(14, AdaptCropComponent_img_14_Template, 1, 9, "img", 6);
        i0.ɵɵtext(15, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n\n    ");
        i0.ɵɵtemplate(17, AdaptCropComponent_div_17_Template, 7, 1, "div", 7);
        i0.ɵɵtext(18, "\n\n    ");
        i0.ɵɵtemplate(19, AdaptCropComponent_div_19_Template, 2, 2, "div", 8);
        i0.ɵɵtext(20, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵstyleProp("width", ctx.cropArea.width, "px")("height", ctx.cropArea.height, "px");
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("ngIf", ctx.imgURL);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.cropAreaLabel);
        i0.ɵɵadvance(3);
        i0.ɵɵstyleProp("background", ctx.getOffcutColor);
        i0.ɵɵadvance(2);
        i0.ɵɵstyleProp("width", ctx.cropArea.width, "px")("height", ctx.cropArea.height, "px");
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.imgURL);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.showLoader);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.showPlaceholder);
    } }, directives: [i4.NgIf], encapsulation: 2, data: { animation: [
            trigger('fadeOutAnimation', [
                transition('* => void', [
                    useAnimation(ANIMATION_NAME.opacity, {
                        params: {
                            from: '*',
                            to: '0'
                        }
                    })
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptCropComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-crop',
                template: `
    <div class="adapt-crop--cut-area-result"
         [style.width.px]="cropArea.width"
         [style.height.px]="cropArea.height">
      <div class="adapt-crop--img-wrapper">
        <img *ngIf="imgURL"
             class="adapt-crop--img"
             [src]="imgURL"
             [style.left.px]="cropImg.pos.x"
             [style.top.px]="cropImg.pos.y"
             [style.width.px]="cropImg.dim.width"
             [style.height.px]="cropImg.dim.height"
             (load)="onImageLoad($event)"
             draggable="false"
             aria-hidden="true"></div>

      <div class="adapt-crop--dim-label" *ngIf="cropAreaLabel"><i>{{cropArea.width}}</i>{{texts.px}} &#215;
        <i>{{cropArea.height}}</i>{{texts.px}}
      </div>
    </div>

    <div class="adapt-crop--cut-area-fade" [style.background]="getOffcutColor"></div>

    <div class="adapt-crop--cut-area-offcut"
         [style.width.px]="cropArea.width"
         [style.height.px]="cropArea.height">
      <img *ngIf="imgURL"
           class="adapt-crop--img"
           [src]="imgURL"
           [style.left.px]="cropImg.pos.x"
           [style.top.px]="cropImg.pos.y"
           [style.width.px]="cropImg.dim.width"
           [style.height.px]="cropImg.dim.height"
           draggable="false"
           aria-hidden="true">
    </div>

    <div class="adapt-crop--overlay-loader" *ngIf="showLoader" [@fadeOutAnimation]>
      <div class="loader-container">
        <div class="loader-section"></div>
      </div>
    </div>

    <div class="adapt-crop--overlay-placeholder" *ngIf="showPlaceholder" [@fadeOutAnimation]>{{placeholder}}</div>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.adapt-crop]': 'true',
                },
                animations: [
                    trigger('fadeOutAnimation', [
                        transition('* => void', [
                            useAnimation(ANIMATION_NAME.opacity, {
                                params: {
                                    from: '*',
                                    to: '0'
                                }
                            })
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i1.DomSanitizer }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i2.AdaptTranslateService }, { type: i3.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { image: [{
            type: Input
        }], initPosition: [{
            type: Input
        }], offcutColor: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], cropAreaLabel: [{
            type: Input
        }], cropApi: [{
            type: Input
        }], positionChange: [{
            type: Output
        }], cropToBase64: [{
            type: Output
        }], cropToFile: [{
            type: Output
        }], error: [{
            type: Output
        }], cropWidth: [{
            type: Input
        }], cropHeight: [{
            type: Input
        }], scale: [{
            type: Input
        }] }); })();
//# sourceMappingURL=crop.component.js.map