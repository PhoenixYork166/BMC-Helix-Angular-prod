import { __rest } from "tslib";
import { Inject, Injectable, Optional } from '@angular/core';
import { HttpErrorResponse, HttpEventType } from '@angular/common/http';
import { Observable, Subject } from 'rxjs';
import { isNil } from 'lodash-es';
import { bufferCount, mergeMap, retry, takeWhile, tap } from 'rxjs/operators';
import { v4 as uuid } from 'uuid';
import { FILE_IS_UPLOADED_PERCENTAGE, INITIAL_CHUNK_NUMBER, MAX_UPLOADING_QUEUE_LENGTH, RETRY_REQUEST_TIMES } from '../consts/uploader.consts';
import { formatFileSize } from '../uploader';
import { SendFileService } from './send.file.service';
import { MessageStatus } from '../../common.enums';
import { UploaderMode } from '../enums/uploader.enum';
import { isUndefined } from '../../utilities';
import { AdaptTranslateService } from '../../i18n/index';
import * as i0 from "@angular/core";
import * as i1 from "./send.file.service";
import * as i2 from "../../i18n/index";
export class FileManager {
    constructor(uploadService, defaultUploadService, ts) {
        this.uploadService = uploadService;
        this.defaultUploadService = defaultUploadService;
        this.ts = ts;
        this.messagesSubject = new Subject();
        this.uploadedSubject = new Subject();
        this.canceledSubject = new Subject();
        this.uploadingStartSubject = new Subject();
        this.errorUploadingSubject = new Subject();
        this.uploadingProcessSubject = new Subject();
        this.uploadingFinishedSubject = new Subject();
        this.fileErrors = {};
        this._maxUploadingQueue = MAX_UPLOADING_QUEUE_LENGTH;
        this._uploadingQueue = [];
        this._retryTimes = RETRY_REQUEST_TIMES;
        this._duplicate = [];
        this._storage = [];
        this._messages = {};
        this.uploadService = uploadService || defaultUploadService;
        this.setDefaultTexts(ts.getCurrentLanguage());
        Object.keys(this.fileErrors).forEach((key) => this._messages[key] = { errorMessage: '', files: [] });
        this.uploadingStartSubject.subscribe((_a) => {
            var { file } = _a, uploadInputs = __rest(_a, ["file"]);
            this._uploadingQueue.push(file.fileId);
            file.inUploading = true;
            this.uploading(file, uploadInputs);
        });
    }
    /**
     * Returns errors messages
     */
    get messages() {
        return this._messages;
    }
    /**
     * Checks if file fit the size limit
     */
    static isMaxSizeAcceptable(file, maxSize) {
        return file.size <= maxSize;
    }
    static isMinSizeAcceptable(file, minSize) {
        return file.size >= minSize;
    }
    /**
     * Checks if file type is acceptable
     */
    static isFileTypeAcceptable(file, allowedTypes, forbiddenTypes) {
        const type = file.name.split('.').reverse()[0].toLowerCase();
        if (allowedTypes === null || allowedTypes === void 0 ? void 0 : allowedTypes.length) {
            return allowedTypes.indexOf(type) !== -1;
        }
        else {
            return !(forbiddenTypes === null || forbiddenTypes === void 0 ? void 0 : forbiddenTypes.length) || forbiddenTypes.indexOf(type) === -1;
        }
    }
    setDefaultTexts(translation) {
        this.fileErrors.maxSize = translation['adapt.uploader.error.maxSize'];
        this.fileErrors.minSize = translation['adapt.uploader.error.minSize'];
        this.fileErrors.typeGeneral = translation['adapt.uploader.error.type.general'];
        this.fileErrors.typeList = translation['adapt.uploader.error.type.includeTypes'];
        this.fileErrors.count = translation['adapt.uploader.error.count'];
        this.fileErrors.duplicates = translation['adapt.uploader.error.duplicates'];
        this.fileErrors.folderSuppress = translation['adapt.uploader.error.folderSuppress'];
        this.fileErrors.fileSuppress = translation['adapt.uploader.error.fileSuppress'];
        this.fileErrors.genericErrorMessage = translation['adapt.uploader.error.genericErrorMessage'];
        this.fileErrors.removeErrorMessage = translation['adapt.uploader.error.removeErrorMessage'];
    }
    /**
     * Returns the copy of files saved in uploader
     */
    getFiles() {
        return this._storage.slice();
    }
    /**
     * Adds files to uploader storage
     */
    addFiles(files, allowDeletion, uploadMode, suppressParallel, allowDuplicates, maxFileSize, chunkSize, allowedTypes, forbiddenTypes, filesCount, customErrors, uploadUrl, minFileSize = 0) {
        // Suppress parallel uploading, it means only 1 file allowed to be in queue
        if (suppressParallel) {
            this._maxUploadingQueue = 1;
        }
        this.clearMessages();
        if (!allowDuplicates) {
            files = this.excludeDuplicates(files);
        }
        files = this.checkFilesType(files, allowedTypes, forbiddenTypes);
        files = this.checkFilesMaxSize(files, maxFileSize);
        files = this.checkFilesMinSize(files, minFileSize);
        this.checkFilesCount(files, filesCount);
        const filesToSave = files.map((data) => {
            return {
                data,
                fileId: uuid(),
                inUploading: false,
                uploaded: 0,
                canceled: false,
                error: false,
                errorText: '',
                allowDeletion: allowDeletion,
                totalFileSize: data.size,
                inDeleting: false,
            };
        });
        this.updateFilesStorage(filesToSave, true);
        this.proceedMessages();
        switch (uploadMode) {
            case UploaderMode.Auto: {
                this.checkForUploading({ chunkSize, uploadUrl, customErrors });
                break;
            }
            case UploaderMode.Manual: {
                break;
            }
        }
    }
    startUploading(uploadInputs) {
        const len = this.getFiles().length;
        const uploadingStream = this.uploadedSubject;
        const buffer = uploadingStream.pipe(bufferCount(len));
        this.checkForUploading(uploadInputs);
        buffer.subscribe((files) => {
            this.uploadingFinishedSubject.next(files);
            this.uploadingFinishedSubject.complete();
        });
    }
    abortUploading(uploadInputs, file) {
        if (file) {
            file.canceled = true;
            this.canceledSubject.next([file]);
            this.removeFromUploadingQueue(file, uploadInputs);
            return;
        }
        const canceledFiles = [];
        this._uploadingQueue.length = 0;
        this._storage.forEach((storageItem) => {
            if (storageItem.inUploading && !storageItem.canceled && !storageItem.error) {
                storageItem.canceled = true;
                canceledFiles.push(storageItem);
                storageItem.inUploading = false;
            }
        });
        if (canceledFiles.length) {
            this.canceledSubject.next(canceledFiles);
        }
    }
    /**
     * Removes file with appropriate id from the uploader storage
     */
    removeFile(id) {
        const index = this._storage.findIndex((file) => file.fileId === id);
        if (index >= 0) {
            this._storage.splice(index, 1);
        }
    }
    deleteFileFromServer(file, deleteUrl, uploadInputs) {
        return new Promise((resolve, reject) => {
            // TODO: Refactor this if possible
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            const request = deleteUrl
                ? this.defaultUploadService.deleteFile(file, deleteUrl)
                : this.uploadService.deleteFile(file);
            request.pipe().subscribe(() => {
                this.removeFromFileList(file, uploadInputs);
                file.deleted = true;
                file.inDeleting = false;
                resolve(file);
            }, () => {
                file.error = true;
                file.errorText = this.fileErrors.removeErrorMessage;
                file.inDeleting = false;
                reject();
            });
            file.inDeleting = true;
        });
    }
    getChunkStart(chunkNumber, chunkSize) {
        return chunkNumber * chunkSize;
    }
    getFileRequestId(chunkStart, chunkSize) {
        return chunkStart / chunkSize + 1;
    }
    updateFilesStorage(files, concat = false) {
        if (concat) {
            this._storage = this._storage.concat(files);
            return;
        }
        this._storage = Object.assign([], files);
    }
    // needed for the RTE attachment option
    decreaseFilesStorage(file) {
        const index = this._storage.findIndex((uploadedItem) => uploadedItem.fileId === file.fileId);
        if (index >= 0) {
            this._storage.splice(index, 1);
        }
    }
    resetFilesStorage() {
        this._storage.length = 0;
    }
    /**
     * Checks if files fit the max size limit
     */
    checkFilesMaxSize(files, maxFileSize) {
        files = files.filter(file => {
            if (!FileManager.isMaxSizeAcceptable(file, maxFileSize)) {
                this._messages.maxSize.files.push(file);
                return false;
            }
            return true;
        });
        this._messages.maxSize.errorMessage = this._messages.maxSize.files.length
            ? this._format(this.fileErrors.maxSize, formatFileSize(maxFileSize.toString()))
            : '';
        return files;
    }
    /**
     * Checks if files fit the min size limit
     */
    checkFilesMinSize(files, minFileSize) {
        files = files.filter(file => {
            if (!FileManager.isMinSizeAcceptable(file, minFileSize)) {
                this._messages.minSize.files.push(file);
                return false;
            }
            return true;
        });
        this._messages.minSize.errorMessage = this._messages.minSize.files.length
            ? this._format(this.fileErrors.minSize, formatFileSize(minFileSize.toString()))
            : '';
        return files;
    }
    /**
     * Excludes duplicates from uploading list
     */
    excludeDuplicates(files) {
        files = files.filter(file => {
            if (this.hasDuplicate(file)) {
                this._duplicate.push(file);
                return false;
            }
            return true;
        });
        if (this._duplicate.length > 0) {
            const message = this._format(this.fileErrors.duplicates, this._duplicate.length + '', this._storage.length + '');
            this._messages.duplicates.errorMessage = message;
            this._duplicate = [];
        }
        return files;
    }
    /**
     * Checks if files count is not exceeded. Removes excess files.
     */
    checkFilesCount(files, filesCount) {
        const diff = filesCount - this._storage.length;
        const removedFiles = files.splice(diff);
        let message;
        if (removedFiles.length > 0) {
            message = this._format(this.fileErrors.count, filesCount + '', removedFiles.length + '');
            this._messages.count = {
                errorMessage: message,
                files: [...removedFiles]
            };
        }
    }
    /**
     * Checks if file types is acceptable
     */
    checkFilesType(files, allowedTypes, forbiddenTypes) {
        const types = [];
        files = files.filter(file => {
            if (!FileManager.isFileTypeAcceptable(file, allowedTypes, forbiddenTypes)) {
                const type = file.name.split('.').reverse()[0];
                if (types.indexOf(type) === -1) {
                    types.push(type);
                }
                return false;
            }
            return true;
        });
        if (types.length) {
            if (allowedTypes === null || allowedTypes === void 0 ? void 0 : allowedTypes.length) {
                this._messages.typeList.errorMessage = this._format(this.fileErrors.typeList, types.join(), allowedTypes.join());
            }
            else {
                this._messages.typeGeneral.errorMessage = this._format(this.fileErrors.typeGeneral, types.join());
            }
        }
        return files;
    }
    /**
     * Checks if file already existed in uploading list
     */
    hasDuplicate(file) {
        return this._storage.some((storedFile) => {
            return storedFile.data.name === file.name;
        });
    }
    /**
     * Clears the warning messages array
     */
    clearMessages() {
        Object.keys(this._messages).forEach(t => this._messages[t] = {
            errorMessage: '',
            files: []
        });
    }
    /**
     * Creates the general message for added portion of files
     */
    proceedMessages() {
        Object.keys(this._messages).forEach(type => {
            const errorMessage = this._messages[type].errorMessage;
            if (errorMessage) {
                this.messagesSubject.next({
                    text: errorMessage,
                    files: this._messages[type].files,
                    variant: MessageStatus.Warning
                });
            }
        });
    }
    /**
     * Checks if files are ready for uploading. Added files to uploading queue.
     */
    checkForUploading(uploadInputs) {
        let filesCount = this._uploadingQueue.length - this._maxUploadingQueue;
        let file = this.getNextFile();
        while (filesCount < 0 && file) {
            if (file) {
                this.uploadingStartSubject.next(Object.assign({ file }, uploadInputs));
            }
            filesCount = this._uploadingQueue.length - this._maxUploadingQueue;
            file = this.getNextFile();
        }
    }
    /**
     * Returns next file which is ready for uploading
     */
    getNextFile() {
        const filesForUpload = this._storage.filter((file) => {
            return !file.inUploading && !file.error && !file.canceled && file.uploaded === 0;
        });
        return filesForUpload ? filesForUpload[0] : null;
    }
    /**
     * Starts file uploading
     */
    uploading(file, uploadInputs, chunkNumber = INITIAL_CHUNK_NUMBER) {
        let chunkSize = isNil(uploadInputs.chunkSize) ? null : uploadInputs.chunkSize;
        const { uploadUrl: url, customErrors } = uploadInputs;
        const chunkCount = Math.ceil(file.data.size / chunkSize);
        // Make assumption that if chunkSize passed as null/undefined there is no need to send file divided on chunks
        // but send file as one chunk instead
        const uploadAsOneChunk = isNil(chunkSize);
        chunkSize = uploadAsOneChunk ? file.data.size : chunkSize;
        if (chunkNumber < chunkCount || !file.data.size) { // empty file
            const chunk = {
                start: this.getChunkStart(chunkNumber, chunkSize),
                end: (chunkNumber + 1) * chunkSize,
                isEmpty: !file.data.size
            };
            this.readChunk(file, chunk).pipe(// read the contents of files
            mergeMap((binary) => {
                const requestBody = {
                    id: this.getFileRequestId(chunk.start, chunkSize),
                    chunksTotal: file.data.size ? Math.ceil(file.data.size / chunkSize) : 1,
                    data: uploadAsOneChunk ? file.data : new Uint8Array(binary.target.result),
                    name: file.data.name,
                    totalFileSize: file.totalFileSize,
                };
                if (requestBody.id === requestBody.chunksTotal) {
                    requestBody.checkSum = file.data.size;
                }
                // TODO fix types
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                requestBody.fullPath = file.data.webkitRelativePath || file.data.fullPath;
                // TODO: Refactor this if possible
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                const request = url ?
                    this.defaultUploadService.sendFile(requestBody, uploadAsOneChunk, url) :
                    this.uploadService.sendFile(requestBody, uploadAsOneChunk);
                return request // send the chunk
                    .pipe(takeWhile(() => !file.canceled), // send chunks until file uploading cancellation
                retry(this._retryTimes - 1)) // retry unsuccessful uploading
                    .pipe(tap({
                    next: (response) => {
                        file.response = response;
                        file.ok = uploadAsOneChunk ? response.ok : true;
                        url ? this.defaultUploadService.responseCallback(response, file) : this.uploadService.responseCallback(response, file);
                    },
                    error: (error) => {
                        file.ok = false;
                        url ? this.defaultUploadService.responseCallback(error, file) : this.uploadService.responseCallback(error, file);
                    }
                }));
            })).subscribe(() => {
                if (uploadAsOneChunk) {
                    if (file.response) {
                        if (file.response.type === HttpEventType.UploadProgress) {
                            file.uploaded = Math.round(file.response.loaded / file.response.total * 100);
                            this.uploadingProcessSubject.next(file);
                        }
                        else if (file.response.type === HttpEventType.Response) {
                            file.uploaded = FILE_IS_UPLOADED_PERCENTAGE;
                            this.removeFromUploadingQueue(file, uploadInputs);
                            this.uploadedSubject.next(file);
                        }
                    }
                }
                else {
                    file.uploaded = Math.ceil((chunkNumber + 1) * FILE_IS_UPLOADED_PERCENTAGE / chunkCount);
                    this.uploadingProcessSubject.next(file);
                    if (isFinite(file.uploaded)) {
                        this.uploading(file, uploadInputs, chunkNumber + 1);
                    }
                    else {
                        file.uploaded = FILE_IS_UPLOADED_PERCENTAGE;
                        this.removeFromUploadingQueue(file, uploadInputs);
                        this.uploadedSubject.next(file);
                    }
                }
            }, (error) => {
                file.error = true;
                if (error instanceof ProgressEvent) {
                    // TODO: Refactor this if possible
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    file.errorText = `${error.target.error.message}`;
                }
                if (error instanceof HttpErrorResponse) {
                    file.errorText = customErrors
                        ? `${error.message}`
                        : this.fileErrors.genericErrorMessage;
                }
                this.removeFromUploadingQueue(file, uploadInputs);
                this.errorUploadingSubject.next({ file, error });
            });
        }
        else { // all chunks have been sent
            this.removeFromUploadingQueue(file, uploadInputs);
            this.uploadedSubject.next(file);
        }
    }
    /**
     * Reads and sends file's chunk
     */
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    readChunk(file, chunk) {
        const reader = new FileReader();
        reader.readAsArrayBuffer(chunk.isEmpty ? file.data : file.data.slice(chunk.start, chunk.end));
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        return new Observable((observer) => {
            reader.onload = ((ev) => {
                observer.next(ev);
                observer.complete();
            });
            reader.onerror = (error) => {
                observer.error(error);
            };
        });
    }
    /**
     * Removes file from uploading queue
     */
    removeFromUploadingQueue(file, uploadInputs) {
        const index = this._uploadingQueue.findIndex((id) => id === file.fileId);
        if (index >= 0) {
            file.inUploading = false;
            this._uploadingQueue.splice(index, 1);
        }
        this.checkForUploading(uploadInputs);
    }
    removeFromFileList(file, uploadInputs) {
        const index = this._storage.findIndex((storageFile) => storageFile.fileId === file.fileId);
        if (index >= 0) {
            file.inUploading = false;
            this._storage.splice(index, 1);
        }
        this.checkForUploading(uploadInputs);
    }
    _format(...rest) {
        const args = rest.slice(1);
        return rest[0].replace(/{(\d+)}/g, (match, index) => !isUndefined(args[index]) ? args[index] : match);
    }
}
FileManager.ɵfac = function FileManager_Factory(t) { return new (t || FileManager)(i0.ɵɵinject('UploaderService', 8), i0.ɵɵinject(i1.SendFileService), i0.ɵɵinject(i2.AdaptTranslateService)); };
FileManager.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: FileManager, factory: FileManager.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(FileManager, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: ['UploaderService']
            }, {
                type: Optional
            }] }, { type: i1.SendFileService }, { type: i2.AdaptTranslateService }]; }, null); })();
//# sourceMappingURL=file-manager.js.map