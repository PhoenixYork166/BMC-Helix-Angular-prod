import { Directive, ElementRef, EventEmitter, Injector, Input, IterableDiffers, NgZone, Optional, Output, Renderer2, Self } from '@angular/core';
import { Platform } from '@angular/cdk/platform';
import { NgControl } from '@angular/forms';
import { ComponentPortal } from '@angular/cdk/portal';
import { Directionality } from '@angular/cdk/bidi';
import { BACKSPACE, DOWN_ARROW, ENTER, ESCAPE, LEFT_ARROW, RIGHT_ARROW, TAB, UP_ARROW } from '@angular/cdk/keycodes';
import { fromEvent, ReplaySubject } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import { isNil } from 'lodash-es';
import { getEventKeyCode } from '../common/key-codes';
import { regExpEscape } from '../common/utilities';
import { AdaptOverlayService, getOverlayConnectedPosition } from '../common/overlay/index';
import { getCaretPosition, getMention2ItemName, parseMention2ModelString, setCaretPosition } from './adapt-mention2-utils';
import { AdaptMention2ListComponent } from './adapt-mention2-list.component';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "@angular/cdk/platform";
import * as i3 from "../common/overlay/index";
import * as i4 from "@angular/cdk/bidi";
import * as i5 from "../common/radar/adapt-radar";
export class AdaptMention2Directive extends AdaptRadarAngularGenericDirective {
    constructor(_ngControl, _elementRef, _ngZone, _renderer, _platform, _differs, _overlayService, _injector, _dir, _adaptRadarService, _elem) {
        var _a;
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptMention2);
        this._ngControl = _ngControl;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._renderer = _renderer;
        this._platform = _platform;
        this._differs = _differs;
        this._overlayService = _overlayService;
        this._injector = _injector;
        this._dir = _dir;
        /**
         * Class list for mention tag (only for [contenteditable])
         * @docs-default text-active
         */
        this.mentionClassList = 'text-active';
        /**
         * Mention list popup max width
         * @docs-default 200px
         */
        this.mentionListMaxWidth = '200px';
        /**
         * Mention list popup max height
         * @docs-default 200px
         */
        this.mentionListMaxHeight = '200px';
        /**
         * Fires when mention model change
         */
        this.mentionModelChange = new EventEmitter();
        /**
         * Fires when search value is entered
         * @since v10.15.0
         */
        this.mentionSearchValueEntered = new EventEmitter();
        /**
         * Fires when item from the options list is selected
         * @since v10.15.0
         */
        this.mentionItemSelected = new EventEmitter();
        /**
         * Fires when mention trigger char is pressed
         * @since v10.15.0
         */
        this.mentionTriggerCharPressed = new EventEmitter();
        this._cachedViewMentionItems = new Map();
        this._showMentionLoader = false;
        this._entryElementFocus = false;
        this._viewInitComplete = false;
        this._destroyed$ = new ReplaySubject(1);
        this._mentionDiffer = [];
        this._mentionDiffer = new Array((_a = this.adaptMention2) === null || _a === void 0 ? void 0 : _a.length).fill(_differs.find([]).create(null));
    }
    /**
     * Mention directive model
     * @docs-default
     */
    set mentionModel(value) {
        this._adaptMentionModel = value || '';
        this._cacheMentionsFromString(this._adaptMentionModel);
        if (this._viewInitComplete && !this._entryElementFocus) {
            // Allow writeValue only after view init to be sure that ngControl and layout are ready
            this._writeValueToEntryElement();
        }
    }
    /**
     * When set to truthy, shows busy loader while data are loading
     * @since v10.15.0
     * @docs-default false
     */
    set showMentionLoader(state) {
        this._showMentionLoader = state;
        if (this._mentionListOverlayWithPortal) {
            this._mentionListOverlayWithPortal.componentRef.instance.isLoading = state;
        }
    }
    get showMentionLoader() {
        return this._showMentionLoader;
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._configureEntryElement();
        this._configureEntryElementSpy();
        this._configureEntryElementListeners();
        this._viewInitComplete = true;
        // Manually init entryElement if the mentionModel has been set before initComplete
        this._ngZone.onStable
            .pipe(takeUntil(this._destroyed$), take(1))
            .subscribe(() => {
            this._writeValueToEntryElement(true);
        });
    }
    ngDoCheck() {
        // needed for lazy loading
        if (this._mentionListOverlayWithPortal) {
            if (this._mentionDiffer.length && !isNil(this.adaptMention2)) {
                const isArrayChanged = this._mentionDiffer.some((differ, index) => {
                    var _a;
                    return differ.diff((_a = this.adaptMention2[index]) === null || _a === void 0 ? void 0 : _a.items);
                });
                if (isArrayChanged && this._entryElementFocus) {
                    this._openList();
                }
            }
        }
    }
    ngOnDestroy() {
        this._closeList();
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    /**
     * Configure entryElement
     */
    _configureEntryElement() {
        const hostElement = this._elementRef.nativeElement;
        if (hostElement instanceof HTMLInputElement || hostElement instanceof HTMLTextAreaElement) {
            // Get hostElement as entryElement if it is <input> or <textarea>
            this._entryElement = hostElement;
        }
        else {
            // Search inside of hostElement for <input> or <textarea>
            this._entryElement = hostElement.querySelector('input[type="text"], textarea');
            // Fallback to host element if no inputLike elements found.
            this._entryElement = this._entryElement || hostElement;
        }
        this._entryElementContentEditable =
            !(this._entryElement instanceof HTMLInputElement || this._entryElement instanceof HTMLTextAreaElement);
        if (this._entryElementContentEditable) {
            // Extra configuration for [contenteditable] element
            this._renderer.setStyle(this._entryElement, 'whiteSpace', 'pre-wrap'); // Show all the content including spaces
            if (this._platform.WEBKIT) {
                // Prohibit adding <div> on ENTER (Chrome)
                this._renderer.setStyle(this._entryElement, 'display', 'inline-block');
            }
        }
    }
    /**
     * Configure spy element for cursor position detection
     */
    _configureEntryElementSpy() {
        // Create SpyWrapperElement
        this._spyWrapperElement = this._renderer.createElement('div');
        const entryElementComputedStyle = getComputedStyle(this._entryElement);
        [
            'boxSizing',
            'width',
            'height',
            'overflowX',
            'overflowY',
            'borderTopWidth',
            'borderRightWidth',
            'borderBottomWidth',
            'borderLeftWidth',
            'paddingTop',
            'paddingRight',
            'paddingBottom',
            'paddingLeft',
            'fontStyle',
            'fontVariant',
            'fontWeight',
            'fontStretch',
            'fontSize',
            'lineHeight',
            'fontFamily',
            'textAlign',
            'textTransform',
            'textIndent',
            'textDecoration',
            'letterSpacing',
            'wordSpacing'
        ].forEach((styleProp) => {
            this._renderer.setStyle(this._spyWrapperElement, styleProp, entryElementComputedStyle[styleProp]);
        });
        if (this._entryElement instanceof HTMLInputElement) {
            this._renderer.setStyle(this._spyWrapperElement, 'whiteSpace', 'pre');
            this._renderer.setStyle(this._spyWrapperElement, 'overflowX', 'scroll');
        }
        else if (this._entryElement instanceof HTMLTextAreaElement) {
            this._renderer.setStyle(this._spyWrapperElement, 'whiteSpace', 'pre-wrap');
        }
        else {
            // [contenteditable]
            this._renderer.setStyle(this._spyWrapperElement, 'whiteSpace', 'pre-wrap');
        }
        this._spyElementBeforeCaret = this._renderer.createElement('span');
        this._renderer.appendChild(this._spyWrapperElement, this._spyElementBeforeCaret);
        this._spyCaret = this._renderer.createElement('span');
        this._renderer.appendChild(this._spyWrapperElement, this._spyCaret);
        this._spyElementAfterCaret = this._renderer.createElement('span');
        this._renderer.appendChild(this._spyWrapperElement, this._spyElementAfterCaret);
        // Create wrapper for Spy elements
        const spyElementsWrapper = this._renderer.createElement('div');
        this._renderer.setStyle(spyElementsWrapper, 'position', 'absolute');
        this._renderer.setStyle(spyElementsWrapper, 'zIndex', '-1');
        this._renderer.setStyle(spyElementsWrapper, 'opacity', '0');
        this._renderer.appendChild(spyElementsWrapper, this._spyWrapperElement);
        this._renderer.insertBefore(this._entryElement.parentElement, spyElementsWrapper, this._entryElement);
    }
    /**
     * Configure entryElement event listeners
     */
    _configureEntryElementListeners() {
        fromEvent(this._entryElement, 'input')
            .pipe(takeUntil(this._destroyed$))
            .subscribe((event) => {
            this._inputSourceValueChange(this._getEntryElementValue(), event);
            // Deleting the entire content of contenteditable keeps a <br>
            // FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=1513303
            // Delete it manually
            if (this._entryElementContentEditable &&
                this._entryElement.childNodes.length === 1 &&
                this._entryElement.childNodes[0].nodeType === 1 &&
                this._entryElement.childNodes[0].tagName.toLocaleLowerCase() === 'br') {
                this._entryElement.innerHTML = '';
                this._entryElement.focus();
            }
        });
        fromEvent(this._entryElement, 'focus')
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            this._entryElementFocus = true;
        });
        fromEvent(this._entryElement, 'blur')
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            this._entryElementFocus = false;
        });
        fromEvent(this._entryElement, 'keydown')
            .pipe(takeUntil(this._destroyed$))
            .subscribe((event) => {
            switch (getEventKeyCode(event)) {
                case UP_ARROW: {
                    if (this._mentionListOverlayWithPortal) {
                        event.preventDefault();
                        this._mentionListOverlayWithPortal.componentRef.instance.activatePrev();
                    }
                    break;
                }
                case DOWN_ARROW: {
                    if (this._mentionListOverlayWithPortal) {
                        event.preventDefault();
                        this._mentionListOverlayWithPortal.componentRef.instance.activateNext();
                    }
                    break;
                }
                case ENTER: {
                    if (this._mentionListOverlayWithPortal) {
                        event.preventDefault();
                        this._mentionListOverlayWithPortal.componentRef.instance.selectActive();
                    }
                    else {
                        // <br> for new lines instead of <div>
                        if (this._entryElementContentEditable) {
                            document.execCommand('defaultParagraphSeparator', false, 'br');
                        }
                    }
                    break;
                }
                case BACKSPACE: {
                    if (!this._entryElementContentEditable || !this._getEntryElementValue()) {
                        break;
                    }
                    const selection = window.getSelection();
                    if (selection.isCollapsed) {
                        const anchorNode = selection.anchorNode;
                        let targetMentionElement;
                        if (anchorNode instanceof HTMLElement && anchorNode.dataset.group) {
                            // Anchor is a targetMentionElement
                            targetMentionElement = anchorNode;
                        }
                        else if (anchorNode.parentElement instanceof HTMLElement && anchorNode.parentElement.dataset.group) {
                            // Anchor is a textNode inside the targetMentionElement
                            targetMentionElement = anchorNode.parentElement;
                        }
                        else if (anchorNode === this._entryElement) {
                            // Anchor is an entryElement
                            const newAnchorNode = this._entryElement.childNodes[selection.anchorOffset - 1];
                            if (newAnchorNode) {
                                if (newAnchorNode instanceof HTMLElement && newAnchorNode.dataset.group) {
                                    targetMentionElement = newAnchorNode;
                                }
                                else if (newAnchorNode.previousSibling instanceof HTMLElement && newAnchorNode.previousSibling.dataset.group) {
                                    targetMentionElement = newAnchorNode.previousSibling;
                                }
                            }
                        }
                        else if (selection.anchorOffset === 0) {
                            if (anchorNode.previousSibling instanceof HTMLElement && anchorNode.previousSibling.dataset.group) {
                                // Anchor is a textNode right after the targetMentionElement
                                targetMentionElement = anchorNode.previousSibling;
                            }
                        }
                        if (targetMentionElement) {
                            event.preventDefault();
                            const range = document.createRange();
                            range.selectNode(targetMentionElement);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                    }
                    break;
                }
                case TAB: {
                    this._closeList();
                    break;
                }
            }
        });
        fromEvent(this._entryElement, 'keyup')
            .pipe(takeUntil(this._destroyed$))
            .subscribe((event) => {
            if (this._mentionListOverlayWithPortal) {
                switch (getEventKeyCode(event)) {
                    case LEFT_ARROW:
                    case RIGHT_ARROW: {
                        this._checkCaretPosition();
                        break;
                    }
                }
            }
        });
    }
    /**
     * Write value to entryElement or ngControl
     */
    _writeValueToEntryElement(firstInit) {
        if (this._ngControl && this._ngControl.control) {
            const _uiString = this._getUIString();
            if (firstInit && !_uiString) {
                return;
            }
            this._ngControl.control.setValue(_uiString);
        }
        else {
            if (this._entryElementContentEditable) {
                const _uiLayout = this._getUILayout();
                if (firstInit && !_uiLayout.length) {
                    return;
                }
                this._entryElement.innerHTML = '';
                _uiLayout.forEach((element) => {
                    this._renderer.appendChild(this._entryElement, element);
                });
            }
            else {
                const _uiString = this._getUIString();
                if (firstInit && !_uiString) {
                    return;
                }
                this._entryElement.value = _uiString;
            }
        }
    }
    /**
     * Emit entryElement value change, update caret position
     */
    _inputSourceValueChange(value, event) {
        this.mentionModelChange.emit(this._applyMetadataToString(value));
        if (this._entryElementFocus) {
            this._checkCaretPosition(event);
        }
    }
    /**
     * Returns UI string without metadata
     */
    _getUIString() {
        const rawMentionModel = parseMention2ModelString(this._adaptMentionModel);
        let resultString = '';
        rawMentionModel.forEach((modelPart) => {
            resultString += typeof modelPart === 'string' ?
                modelPart : modelPart.group + modelPart.name;
        });
        return resultString;
    }
    /**
     * Returns layout representation of UI string
     */
    _getUILayout() {
        const layoutArray = [];
        parseMention2ModelString(this._adaptMentionModel)
            .forEach((modelPart) => {
            let mentionElement;
            if (typeof modelPart === 'string') {
                mentionElement = this._renderer.createText(modelPart);
            }
            else {
                mentionElement = this._renderer.createElement('span');
                mentionElement.textContent = modelPart.group + modelPart.name;
                // Chrome: creates <font> element if contenteditable='true'
                // FF: does not delete element if contenteditable='false'
                mentionElement.setAttribute('contenteditable', false);
                mentionElement.setAttribute('class', this.mentionClassList);
                mentionElement.dataset.group = modelPart.group;
                mentionElement.dataset.name = modelPart.name;
                mentionElement.dataset.meta = modelPart.meta;
                mentionElement.dataset.initial = modelPart.initial;
                mentionElement.addEventListener('click', () => {
                    const tempTextNode = this._renderer.createText('');
                    this._renderer.insertBefore(mentionElement.parentNode, tempTextNode, mentionElement.nextSibling);
                    window.getSelection().collapse(tempTextNode);
                });
            }
            layoutArray.push(mentionElement);
        });
        return layoutArray;
    }
    /**
     * Store all new mention model items
     */
    _cacheMentionsFromString(value) {
        parseMention2ModelString(value).filter(elem => typeof elem !== 'string')
            .forEach(mentionItem => {
            this._cachedViewMentionItems.set(mentionItem.group + mentionItem.name, mentionItem);
        });
    }
    /**
     * Expand string with metadata from cached mention items
     */
    _applyMetadataToString(value) {
        if (value) {
            this._cachedViewMentionItems.forEach((mentionItem, mentionViewKey) => {
                value = value.replace(new RegExp(regExpEscape(mentionViewKey), 'gm'), mentionItem.initial);
            });
        }
        return value;
    }
    /**
     * Returns entryElement string value
     */
    _getEntryElementValue() {
        const inputElement = this._entryElement;
        return this._entryElementContentEditable ? inputElement.textContent : inputElement.value;
    }
    /**
     * Check caret position
     * Open mention list popup if mentionGroup found
     */
    _checkCaretPosition(event) {
        var _a;
        if (!this.adaptMention2) {
            return;
        }
        const caretPosition = getCaretPosition(this._entryElement);
        if (caretPosition) {
            const stringBeforeCaret = this._getEntryElementValue().slice(0, caretPosition);
            const lastWordBeforeCaret = stringBeforeCaret.split(/\s/).pop();
            const previousActiveGroupTrigger = (_a = this._activeGroup) === null || _a === void 0 ? void 0 : _a.trigger;
            this._activeGroup = this.adaptMention2
                .find((mentionGroup) => mentionGroup.trigger === lastWordBeforeCaret[0]) || null;
            if (this._activeGroup) {
                const previousActivePosition = this._activePosition;
                const previousActiveQuery = this._activeQuery;
                this._activePosition = stringBeforeCaret.length - lastWordBeforeCaret.length;
                this._activeQuery = lastWordBeforeCaret.slice(1);
                if ((event && event.data === this._activeGroup.trigger) ||
                    (previousActivePosition !== this._activePosition) ||
                    (previousActiveGroupTrigger !== this._activeGroup.trigger) ||
                    (previousActiveQuery === '' && this._activeQuery === '')) {
                    this.mentionTriggerCharPressed.emit(this._activeGroup.trigger);
                }
                this.mentionSearchValueEntered.emit(this._activeQuery);
                this._spyElementBeforeCaret.textContent = this._getEntryElementValue().slice(0, this._activePosition);
                this._spyCaret.textContent = this._activeGroup.trigger + this._activeQuery;
                this._spyElementAfterCaret.textContent = this._getEntryElementValue().slice(caretPosition);
                this._renderer.setStyle(this._spyWrapperElement, 'width', this._entryElement.offsetWidth + 'px');
                this._renderer.setStyle(this._spyWrapperElement, 'height', this._entryElement.offsetHeight + 'px');
                this._renderer.setProperty(this._spyWrapperElement, 'scrollLeft', this._entryElement.scrollLeft);
                this._renderer.setProperty(this._spyWrapperElement, 'scrollTop', this._entryElement.scrollTop);
                this._openList();
            }
            else {
                this._closeList();
                this._activePosition = null;
                this._activeQuery = null;
            }
        }
        else {
            this._closeList();
            this._activeGroup = null;
            this._activePosition = null;
            this._activeQuery = null;
        }
    }
    /**
     * Append mention from mention list to UI and model
     */
    _appendMention(mention) {
        if (!isNil(this._activePosition)) {
            const space = '\u00A0';
            const newMentionLabel = mention.group + mention.name;
            const beforeCaretPart = this._getEntryElementValue().slice(0, this._activePosition);
            const afterCaretPart = this._getEntryElementValue()
                .slice(this._activePosition + this._activeGroup.trigger.length + this._activeQuery.length);
            const newEntryElementValue = beforeCaretPart + newMentionLabel + space + afterCaretPart;
            // Force set new mention to cache to apply the latest metadata to string
            this._cachedViewMentionItems.set(newMentionLabel, mention);
            // Update mentionModel to reflect changes to UI
            this.mentionModel = this._applyMetadataToString(newEntryElementValue);
            if (this._entryElementFocus) {
                this._writeValueToEntryElement();
            }
            // Emit mentionModel change
            this._inputSourceValueChange(newEntryElementValue);
            // Close list
            this._closeList();
            this._ngZone.onStable
                .pipe(takeUntil(this._destroyed$), take(1))
                .subscribe(() => {
                const newCaretPosition = (beforeCaretPart + newMentionLabel + space).length;
                setCaretPosition(this._entryElement, newCaretPosition);
                // Restore focus state after click on the list
                this._entryElement.focus();
            });
        }
    }
    /**
     * Open mention list
     */
    _openList() {
        if (!this._mentionListOverlayWithPortal) {
            this._mentionListOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptMention2ListComponent, null, this._injector), {
                origin: this._spyCaret,
                transformOriginSelector: '.adapt-dd-menu',
                scrollStrategy: 'close',
                positionStrategy: 'connected',
                connectedPositions: [
                    getOverlayConnectedPosition('bottom-left', this._dir.value),
                    getOverlayConnectedPosition('top-left', this._dir.value)
                ]
            });
            this._mentionListOverlayWithPortal.overlayRef.keydownEvents()
                .pipe(takeUntil(this._mentionListOverlayWithPortal.destroy$))
                .subscribe((event) => {
                if (getEventKeyCode(event) === ESCAPE) {
                    this._closeList();
                }
            });
            this._mentionListOverlayWithPortal.overlayRef.outsidePointerEvents()
                .pipe(takeUntil(this._mentionListOverlayWithPortal.destroy$))
                .subscribe(() => {
                this._closeList();
            });
        }
        this._mentionListOverlayWithPortal.componentRef.instance.list =
            this._activeGroup.items.filter((item) => {
                return (this.mentionFilter || this._defaultFilter)(item, this._activeQuery, this._activeGroup.searchKey);
            });
        this._mentionListOverlayWithPortal.componentRef.instance.searchKey = this._activeGroup.searchKey || AdaptMention2Directive.DefaultSearchKey;
        this._mentionListOverlayWithPortal.componentRef.instance.isLoading = this.showMentionLoader;
        this._mentionListOverlayWithPortal.componentRef.instance.itemTemplate = this._activeGroup.itemTemplate;
        this._mentionListOverlayWithPortal.componentRef.instance.maxHeight = this.mentionListMaxHeight;
        this._mentionListOverlayWithPortal.componentRef.instance.maxWidth = this.mentionListMaxWidth;
        if (this._mentionListSelectItem$) {
            this._mentionListSelectItem$.unsubscribe();
        }
        this._mentionListSelectItem$ =
            this._mentionListOverlayWithPortal.componentRef.instance.selectItem
                .pipe(takeUntil(this._mentionListOverlayWithPortal.destroy$))
                .subscribe((item) => {
                const itemName = getMention2ItemName(item, this._activeGroup.searchKey || AdaptMention2Directive.DefaultSearchKey);
                const newMention = {
                    group: this._activeGroup.trigger,
                    name: itemName,
                    meta: item.meta || '',
                    initial: `${this._activeGroup.trigger}[${itemName}](${item.meta || ''})`
                };
                this._appendMention(newMention);
                this.mentionItemSelected.emit(item);
            });
        setTimeout(() => {
            if (this._mentionListOverlayWithPortal) {
                // Update list position after the UI updated with a new data
                this._mentionListOverlayWithPortal.updatePositionForce();
            }
        });
    }
    /**
     * Close mention list
     */
    _closeList() {
        if (this._mentionListOverlayWithPortal) {
            this._mentionListOverlayWithPortal.destroy();
            this._mentionListOverlayWithPortal = null;
            if (this._mentionListSelectItem$) {
                this._mentionListSelectItem$.unsubscribe();
                this._mentionListSelectItem$ = null;
            }
        }
    }
    /**
     * Default mention item filter
     */
    _defaultFilter(item, query, searchKey) {
        return Boolean(getMention2ItemName(item, searchKey || AdaptMention2Directive.DefaultSearchKey)
            .match(new RegExp(regExpEscape(query), 'gmi')));
    }
}
AdaptMention2Directive.DefaultSearchKey = 'name';
AdaptMention2Directive.ɵfac = function AdaptMention2Directive_Factory(t) { return new (t || AdaptMention2Directive)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i3.AdaptOverlayService), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i4.Directionality), i0.ɵɵdirectiveInject(i5.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptMention2Directive.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptMention2Directive, selectors: [["", "adaptMention2", ""]], inputs: { adaptMention2: "adaptMention2", mentionModel: "mentionModel", showMentionLoader: "showMentionLoader", mentionClassList: "mentionClassList", mentionFilter: "mentionFilter", mentionListMaxWidth: "mentionListMaxWidth", mentionListMaxHeight: "mentionListMaxHeight" }, outputs: { mentionModelChange: "mentionModelChange", mentionSearchValueEntered: "mentionSearchValueEntered", mentionItemSelected: "mentionItemSelected", mentionTriggerCharPressed: "mentionTriggerCharPressed" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMention2Directive, [{
        type: Directive,
        args: [{
                selector: '[adaptMention2]'
            }]
    }], function () { return [{ type: i1.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i2.Platform }, { type: i0.IterableDiffers }, { type: i3.AdaptOverlayService }, { type: i0.Injector }, { type: i4.Directionality }, { type: i5.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { adaptMention2: [{
            type: Input
        }], mentionModel: [{
            type: Input
        }], showMentionLoader: [{
            type: Input
        }], mentionClassList: [{
            type: Input
        }], mentionFilter: [{
            type: Input
        }], mentionListMaxWidth: [{
            type: Input
        }], mentionListMaxHeight: [{
            type: Input
        }], mentionModelChange: [{
            type: Output
        }], mentionSearchValueEntered: [{
            type: Output
        }], mentionItemSelected: [{
            type: Output
        }], mentionTriggerCharPressed: [{
            type: Output
        }] }); })();
//# sourceMappingURL=adapt-mention2.directive.js.map