import { ApplicationRef, ComponentFactoryResolver, Injectable } from '@angular/core';
import { ComponentPortal } from '@angular/cdk/portal';
import { ESCAPE } from '@angular/cdk/keycodes';
import { takeUntil } from 'rxjs/operators';
import { fromEvent, noop } from 'rxjs';
import { merge, isNil } from 'lodash-es';
import { ScrollManageService } from '../common/scroll-manage.service';
import { LayerService } from '../common/layer-service';
import { AdaptOverlayService } from '../common/overlay/index';
import { getEventKeyCode } from '../common/key-codes';
import { AdaptModalComponent } from './modal.component';
import { AdaptDialogComponent } from './dialog.component';
import { AdaptModalConfig } from './modal.config';
import { ModalDeferred } from './modal.model';
import { DismissReasons } from '../common/common.enums';
import * as i0 from "@angular/core";
import * as i1 from "../common/scroll-manage.service";
import * as i2 from "./modal.config";
import * as i3 from "../common/layer-service";
import * as i4 from "../common/overlay/index";
let OPEN_MODAL_ID = 1;
/**
 * The service for using modal/dialogs
 *
 * open(config) – Opens modal window. Returns Promise that is resolved when a modal is closed and rejected when a modal is dismissed.
 *
 */
export class AdaptModalStackService {
    constructor(_componentFactoryResolver, _appRef, _scrollService, _mConfigService, _layerService, _overlayService) {
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._scrollService = _scrollService;
        this._mConfigService = _mConfigService;
        this._layerService = _layerService;
        this._overlayService = _overlayService;
        /**
         * The wrapper to include modals/dialogs
         */
        this._wrapper = document.body;
        /**
         * Array with opened modals
         */
        this._openedModals = new Map();
        // Get scroll manager
        this._scrollManager = this._scrollService.getScrollManager(this._wrapper);
        // Close all modals on route change
        this._popstateSubscription = fromEvent(window, 'popstate').subscribe(this.closeAllModals.bind(this));
    }
    get openedModals() {
        return this._openedModals;
    }
    get activeModal() {
        return this._activeModal;
    }
    ngOnDestroy() {
        this._popstateSubscription.unsubscribe();
        this._popstateSubscription = null;
    }
    /**
     * Open modal/dialog
     * @returns ModalDeferred - The Promise object with additional methods: resolve() and reject().
     * Resolved when a modal is closed and rejected when a modal is dismissed.
     */
    open(config, configInjector) {
        // close all dropdowns/popover while modal is opened
        if (config.closeAllOpenedItems !== false) {
            this._layerService.closeOpenedItem();
        }
        // Throw error if content missing
        if (!config || !config.content) {
            throw (new Error('Missing modal content'));
        }
        const componentToBuild = config.isDialog || this._mConfigService.isDialog ? AdaptDialogComponent : AdaptModalComponent;
        if (this._overlayService.enableCDKOverlayControl) {
            return this._openOverlay(componentToBuild, config, configInjector);
        }
        const modalDeferred = new ModalDeferred(() => {
            this._close(modalRef);
        }, () => {
            this._close(modalRef);
        });
        modalDeferred.then(noop, noop);
        const modalRef = this._componentFactoryResolver.resolveComponentFactory(componentToBuild).create(configInjector);
        this._layerService.addComponent(modalRef.instance, (event) => {
            modalRef.instance.escClickHandler(event);
        });
        const id = 'adapt-modal-' + OPEN_MODAL_ID++;
        modalRef.instance.id = id;
        modalRef.instance.config = config;
        modalRef.instance.configService = this._mConfigService;
        modalRef.instance.onClose.subscribe((result) => {
            modalDeferred.resolve(result);
        });
        modalRef.instance.onDismiss.subscribe((reason) => {
            modalDeferred.reject(reason);
        });
        modalRef.instance.onCloseAnimationEnd.subscribe(() => {
            this._scrollManager.show(modalRef);
        });
        this._openedModals.set(id, modalRef);
        this._activeModal = modalRef;
        this._scrollManager.hide(modalRef);
        this._appRef.attachView(modalRef.hostView);
        this._wrapper.appendChild(modalRef.location.nativeElement);
        return modalDeferred;
    }
    updateConfig(config, modalComponent) {
        this._updateConfig(config, modalComponent);
    }
    updateOverModalConfig(config, modalComponent, isOverModal) {
        this._updateConfig(config, modalComponent, isOverModal);
    }
    // TODO: Refactor this if possible
    closeAllModals() {
        this._openedModals.forEach((modalRef) => {
            if (modalRef.instance.config.beforeDismiss && !modalRef.instance.config.beforeDismiss(DismissReasons.CLOSE_ALL)) {
                return;
            }
            modalRef.instance.close(modalRef.instance.id);
            this._close(modalRef);
        });
    }
    /**
     * Close modal/dialog
     */
    _close(modalRef) {
        this._openedModals.delete(modalRef.instance.id);
        // In case there are more than one opened modal need to take last added to Map item and set is as active modal
        this._activeModal = this._openedModals.size ? Array.from(this._openedModals.values()).pop() : null;
        this._layerService.removeComponent(modalRef.instance);
        modalRef.destroy();
    }
    _updateConfig(config, modalComponent, isOverModal = false) {
        if (isNil(modalComponent === null || modalComponent === void 0 ? void 0 : modalComponent.instance)) {
            throw new Error('Please make sure that passed "modalComponent" argument is defined');
        }
        const modal = this._openedModals.get(modalComponent.instance.id);
        if (!modal) {
            return;
        }
        if (isOverModal) {
            const modalComponentInstance = modalComponent.instance;
            modalComponentInstance.overModalConfig = merge(modalComponentInstance.overModalConfig, config);
        }
        else {
            modalComponent.instance.updateConfig(config);
        }
    }
    _openOverlay(componentToBuild, config, injector) {
        const modalDeferred = new ModalDeferred(() => {
            if (modalOverlayWithPortal === null || modalOverlayWithPortal === void 0 ? void 0 : modalOverlayWithPortal.overlayRef) {
                this._closeOverlay(modalOverlayWithPortal);
            }
        }, () => {
            if (modalOverlayWithPortal === null || modalOverlayWithPortal === void 0 ? void 0 : modalOverlayWithPortal.overlayRef) {
                this._closeOverlay(modalOverlayWithPortal);
            }
        });
        modalDeferred.then(noop, noop);
        const modalOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(componentToBuild, null, injector), { scrollStrategy: 'block' });
        modalOverlayWithPortal.overlayRef.keydownEvents()
            .pipe(takeUntil(modalOverlayWithPortal.destroy$))
            .subscribe((event) => {
            if (getEventKeyCode(event) === ESCAPE) {
                modalOverlayWithPortal.componentRef.instance.escClickHandler(event);
            }
        });
        modalOverlayWithPortal.componentRef.instance.id = 'adapt-modal-' + OPEN_MODAL_ID++;
        modalOverlayWithPortal.componentRef.instance.config = config;
        modalOverlayWithPortal.componentRef.instance.configService = this._mConfigService;
        modalOverlayWithPortal.componentRef.instance.onClose.subscribe((result) => {
            modalDeferred.resolve(result);
        });
        modalOverlayWithPortal.componentRef.instance.onDismiss.subscribe((reason) => {
            modalDeferred.reject(reason);
            this._closeOverlay(modalOverlayWithPortal);
        });
        this._openedModals.set(modalOverlayWithPortal.componentRef.instance.id, modalOverlayWithPortal.componentRef);
        this._activeModal = modalOverlayWithPortal.componentRef;
        return modalDeferred;
    }
    _closeOverlay(overlayWithPortal, force) {
        this._openedModals.delete(overlayWithPortal.componentRef.instance.id);
        if (force) {
            overlayWithPortal.destroy();
        }
        else {
            if (overlayWithPortal === null || overlayWithPortal === void 0 ? void 0 : overlayWithPortal.componentRef) {
                overlayWithPortal.componentRef.instance.onCloseAnimationEnd
                    .pipe(takeUntil(overlayWithPortal.destroy$))
                    .subscribe(() => {
                    overlayWithPortal.destroy();
                });
                overlayWithPortal.componentRef.destroy();
            }
        }
    }
}
AdaptModalStackService.ɵfac = function AdaptModalStackService_Factory(t) { return new (t || AdaptModalStackService)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i1.ScrollManageService), i0.ɵɵinject(i2.AdaptModalConfig), i0.ɵɵinject(i3.LayerService), i0.ɵɵinject(i4.AdaptOverlayService)); };
AdaptModalStackService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptModalStackService, factory: AdaptModalStackService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptModalStackService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.ApplicationRef }, { type: i1.ScrollManageService }, { type: i2.AdaptModalConfig }, { type: i3.LayerService }, { type: i4.AdaptOverlayService }]; }, null); })();
//# sourceMappingURL=modal-stack.service.js.map