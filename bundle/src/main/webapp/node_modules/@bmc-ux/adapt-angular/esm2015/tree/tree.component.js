import { Component, ContentChildren, ElementRef, EventEmitter, Input, Output, QueryList, ViewChild, ViewChildren, ViewEncapsulation } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { animate, keyframes, style, transition, trigger } from '@angular/animations';
import { debounce, isEmpty } from 'lodash-es';
import { Tree } from 'primeng/tree';
import { PrimeNGConfig, SharedModule, TreeDragDropService } from 'primeng/api';
import { ANIMATION_DURATION, ANIMATION_TIMING_FUNCTION } from '../common/animation';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import { AdaptTranslateService } from '../common/i18n/index';
import { getFocusableElements } from '../common/focus';
import { TreeTrim, TreeWrap } from './tree.model';
import { AdaptTreeNodeTemplateDirective } from './tree-node-template.directive';
import * as i0 from "@angular/core";
import * as i1 from "primeng/api";
import * as i2 from "@angular/cdk/bidi";
import * as i3 from "../common/i18n/index";
import * as i4 from "../common/radar/adapt-radar";
const _c0 = ["treeSearch"];
const _c1 = ["treeContainer"];
const _c2 = ["treeNodeComponent"];
function AdaptTreeComponent_div_0_adapt_rx_search_4_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "adapt-rx-search", 10, 11);
    i0.ɵɵlistener("ngModelChange", function AdaptTreeComponent_div_0_adapt_rx_search_4_Template_adapt_rx_search_ngModelChange_0_listener($event) { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(2); return ctx_r8.filterDebounce($event); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("ngModel", ctx_r1.filterQuery)("clearButtonText", ctx_r1.texts.filterBtnClearText)("placeholder", ctx_r1.texts.filterPlaceholder);
} }
function AdaptTreeComponent_div_0_div_7_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("@nodeAnimation", undefined);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r10.treeFilterStatus);
} }
function AdaptTreeComponent_div_0_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 12);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptTreeComponent_div_0_div_7_div_2_Template, 2, 2, "div", 13);
    i0.ɵɵtext(3, "\n\n    ");
    i0.ɵɵelementStart(4, "adapt-custom-actions", 14);
    i0.ɵɵtext(5, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@nodeAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r2.filterQuery);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("actions", ctx_r2.customActions)("adaptRadarDisableEventSending", true);
} }
function AdaptTreeComponent_div_0_li_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "li", 16);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("sr-only", !(ctx_r4.getRootNode() && !ctx_r4.getRootNode().length));
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r4.treeFilterStatus);
} }
function AdaptTreeComponent_div_0_div_14_ng_template_2_Template(rf, ctx) { }
function AdaptTreeComponent_div_0_div_14_ng_template_4_ul_4_ng_container_2_ng_template_2_Template(rf, ctx) { }
const _c3 = function (a0, a1, a2, a3, a4, a5, a6) { return { $implicit: a0, index: a1, first: a2, last: a3, level: a4, parentNode: a5, nodeTestId: a6 }; };
function AdaptTreeComponent_div_0_div_14_ng_template_4_ul_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptTreeComponent_div_0_div_14_ng_template_4_ul_4_ng_container_2_ng_template_2_Template, 0, 0, "ng-template", 17);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const nestedNode_r28 = ctx.$implicit;
    const nestedNodeIndex_r29 = ctx.index;
    const firstNestedNode_r30 = ctx.first;
    const lastNestedNode_r31 = ctx.last;
    const ctx_r33 = i0.ɵɵnextContext(2);
    const level_r22 = ctx_r33.level;
    const node_r18 = ctx_r33.$implicit;
    const nodeTestId_r24 = ctx_r33.nodeTestId;
    const index_r19 = ctx_r33.index;
    i0.ɵɵnextContext();
    const _r16 = i0.ɵɵreference(5);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r16)("ngTemplateOutletContext", i0.ɵɵpureFunction7(2, _c3, nestedNode_r28, nestedNodeIndex_r29, firstNestedNode_r30, lastNestedNode_r31, level_r22 + 1, node_r18, nodeTestId_r24 + "_node" + index_r19));
} }
function AdaptTreeComponent_div_0_div_14_ng_template_4_ul_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "ul", 22);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptTreeComponent_div_0_div_14_ng_template_4_ul_4_ng_container_2_Template, 4, 10, "ng-container", 8);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r18 = i0.ɵɵnextContext().$implicit;
    const ctx_r26 = i0.ɵɵnextContext(3);
    i0.ɵɵproperty("@nodeAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", node_r18.children)("ngForTrackBy", ctx_r26.trackByNode);
} }
function AdaptTreeComponent_div_0_div_14_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵelement(1, "adapt-tree-node", 19, 20);
    i0.ɵɵtext(3, "\n\n        ");
    i0.ɵɵtemplate(4, AdaptTreeComponent_div_0_div_14_ng_template_4_ul_4_Template, 4, 3, "ul", 21);
    i0.ɵɵtext(5, "\n      ");
} if (rf & 2) {
    const node_r18 = ctx.$implicit;
    const index_r19 = ctx.index;
    const first_r20 = ctx.first;
    const last_r21 = ctx.last;
    const level_r22 = ctx.level;
    const parentNode_r23 = ctx.parentNode;
    const nodeTestId_r24 = ctx.nodeTestId;
    const ctx_r17 = i0.ɵɵnextContext(3);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("level", level_r22)("parentNode", parentNode_r23)("filter", ctx_r17.filter)("query", ctx_r17.filterQuery)("node", node_r18)("testID", nodeTestId_r24 + "_node" + index_r19)("firstChild", first_r20)("lastChild", last_r21)("index", index_r19);
    i0.ɵɵattribute("data-testid", nodeTestId_r24 + "_node" + index_r19);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", node_r18.children && node_r18.expanded);
} }
const _c4 = function (a0, a1, a2, a3, a5) { return { $implicit: a0, index: a1, first: a2, last: a3, level: 0, nodeTestId: a5 }; };
function AdaptTreeComponent_div_0_div_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div");
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptTreeComponent_div_0_div_14_ng_template_2_Template, 0, 0, "ng-template", 17);
    i0.ɵɵtext(3, "\n\n      ");
    i0.ɵɵtemplate(4, AdaptTreeComponent_div_0_div_14_ng_template_4_Template, 6, 11, "ng-template", null, 18, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const rootNode_r11 = ctx.$implicit;
    const index_r12 = ctx.index;
    const first_r13 = ctx.first;
    const last_r14 = ctx.last;
    const _r16 = i0.ɵɵreference(5);
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@nodeAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r16)("ngTemplateOutletContext", i0.ɵɵpureFunction5(3, _c4, rootNode_r11, index_r12, first_r13, last_r14, ctx_r5.testID));
} }
function AdaptTreeComponent_div_0_li_16_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 25);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelement(2, "div", 26);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} }
function AdaptTreeComponent_div_0_li_16_Template(rf, ctx) { if (rf & 1) {
    const _r37 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li");
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "div", 23);
    i0.ɵɵlistener("lazyLoad", function AdaptTreeComponent_div_0_li_16_Template_div_lazyLoad_2_listener() { i0.ɵɵrestoreView(_r37); const ctx_r36 = i0.ɵɵnextContext(2); return ctx_r36.onLazyLoad(); });
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵtemplate(4, AdaptTreeComponent_div_0_li_16_div_4_Template, 4, 0, "div", 24);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    i0.ɵɵnextContext();
    const _r3 = i0.ɵɵreference(10);
    const ctx_r6 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("lazyLoadRootContainer", _r3)("lazyLoadThresholds", 1);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.lazyLoading);
} }
const _c5 = function (a1, a2, a3) { return { "a-tree": true, "ui-tree-selectable": a1, "ui-treenode-dragover": a2, "a-tree__flex-scroll": a3 }; };
const _c6 = function (a0, a1) { return { "max-height": a0, "overflow-y": a1 }; };
function AdaptTreeComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r39 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 1);
    i0.ɵɵlistener("drop", function AdaptTreeComponent_div_0_Template_div_drop_0_listener($event) { i0.ɵɵrestoreView(_r39); const ctx_r38 = i0.ɵɵnextContext(); return ctx_r38.onDrop($event); })("dragover", function AdaptTreeComponent_div_0_Template_div_dragover_0_listener($event) { i0.ɵɵrestoreView(_r39); const ctx_r40 = i0.ɵɵnextContext(); return ctx_r40.onDragOver($event); })("dragenter", function AdaptTreeComponent_div_0_Template_div_dragenter_0_listener() { i0.ɵɵrestoreView(_r39); const ctx_r41 = i0.ɵɵnextContext(); return ctx_r41.onDragEnter(); })("dragleave", function AdaptTreeComponent_div_0_Template_div_dragleave_0_listener($event) { i0.ɵɵrestoreView(_r39); const ctx_r42 = i0.ɵɵnextContext(); return ctx_r42.onDragLeave($event); });
    i0.ɵɵtext(1, "\n\n  ");
    i0.ɵɵelementStart(2, "div", 2);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptTreeComponent_div_0_adapt_rx_search_4_Template, 2, 4, "adapt-rx-search", 3);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n\n  ");
    i0.ɵɵtemplate(7, AdaptTreeComponent_div_0_div_7_Template, 7, 4, "div", 4);
    i0.ɵɵtext(8, "\n\n  ");
    i0.ɵɵelementStart(9, "ul", 5, 6);
    i0.ɵɵtext(11, "\n    ");
    i0.ɵɵtemplate(12, AdaptTreeComponent_div_0_li_12_Template, 2, 3, "li", 7);
    i0.ɵɵtext(13, "\n\n    ");
    i0.ɵɵtemplate(14, AdaptTreeComponent_div_0_div_14_Template, 7, 9, "div", 8);
    i0.ɵɵtext(15, "\n\n    ");
    i0.ɵɵtemplate(16, AdaptTreeComponent_div_0_li_16_Template, 7, 3, "li", 9);
    i0.ɵɵtext(17, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMap(ctx_r0.styleClass);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction3(17, _c5, ctx_r0.selectionMode, ctx_r0.dragHover, ctx_r0.treeScrollHeight === "flex"))("ngStyle", ctx_r0.style);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r0.filter);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r0.customActionsVisible);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("a-tree__container_trim", ctx_r0.trim === ctx_r0.treeTrimEnum.Trim)("a-tree__container_wrap", ctx_r0.wrap === ctx_r0.treeWrapEnum.Wrap)("a-tree__container_wrap-all", ctx_r0.wrap === ctx_r0.treeWrapEnum.WrapAll);
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction2(21, _c6, ctx_r0.treeScrollHeight && ctx_r0.treeScrollHeight !== "flex" ? ctx_r0.treeScrollHeight : "auto", ctx_r0.treeScrollHeight ? "auto" : "visible"));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r0.filter);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r0.getRootNode())("ngForTrackBy", ctx_r0.trackByNode);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.lazy);
} }
let nextUniqueId = 0;
export class AdaptTreeComponent extends Tree {
    constructor(el, dragDropService, dir, config, ts, _adaptRadarService) {
        super(el, dragDropService, config);
        this.config = config;
        this.ts = ts;
        this._adaptRadarService = _adaptRadarService;
        this._uniqueId = `adapt-tree-${++nextUniqueId}`;
        this.treeWrapEnum = TreeWrap;
        this.treeTrimEnum = TreeTrim;
        /**
         * Turn on filtering functionality
         * @docs-default false
         */
        this.filter = false;
        /**
         * Configurable text for tree
         * @docs-default {filterPlaceholder: 'Filter', filterBtnClearText: 'Clear', filterNotFound: 'No matches found'}
         */
        this.texts = {};
        /**
         * String for test id data attribute. For test purposes
         * @docs-default adapt-tree-${++nextUniqueId}
         */
        this.testID = this._uniqueId;
        /**
         * Toggle lazy load mode. If set to true it enables loader anchor at the bottom of items list.
         * Under the hood IntersectionObserver is used. So please use polyfill if you are supporting old browsers(eg. IE).
         * <a href="https://github.com/w3c/IntersectionObserver/tree/main/polyfill" target="_blank">Link to polyfill</a>
         * @since v10.7.0
         * @docs-default false
         */
        this.lazy = false;
        /**
         * Flag that toggle lazy loader visibility
         * @since v10.7.0
         * @docs-default false
         */
        this.lazyLoading = false;
        /**
         * Label text trim variant. Possible values: Default: text not trimming; Trim: text trimming by container width with ellipsis
         * @docs-default TreeTrim.Default
         * @since v10.15.0
         */
        this.trim = TreeTrim.Default;
        /**
         * Label text wrap variant. Possible values: Default: no wrap text; Wrap: text wrap by words; WrapAll: force text wrap even text has no spaces
         * @docs-default TreeWrap.Default
         * @since v10.15.0
         */
        this.wrap = TreeWrap.Default;
        /**
         * Enables 'select all' button. For the correct work the "node.key" property for each node is required
         * @docs-default false
         * @since v12.13.0
         */
        this.selectAllButton = false;
        /**
         * Enables 'deselect all' button. For the correct work the "node.key" property for each node is required
         * @docs-default false
         * @since v12.13.0
         */
        this.deselectAllButton = false;
        this.adaptRadarDisableEventSending = false;
        /**
         * Callback to invoke when a node is dropped.
         * @docs-default
         * @since v12.14.0
         */
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onNodeDrop = new EventEmitter();
        /**
         * An event triggers when lazy load anchor become visible after scrolling list to the bottom
         * @since v10.7.0
         */
        this.lazyLoad = new EventEmitter();
        this.isRtl = false;
        this.filterQuery = '';
        this.filterDebounce = debounce(this.filterWrapper.bind(this), 200);
        this._flattenNodes = [];
        this._flattenFilteredNodes = [];
        this._defaultTexts = {};
        this._filteredTo = 0;
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._templates = {};
        this.setDefaultTexts(ts.getCurrentLanguage());
        this.isRtl = dir.value === 'rtl';
    }
    /**
     * Height of the scrollable viewport. Can be css value like 200px, 20rem of 'flex'.
     * 'Flex' value can be useful in cases when viewport should adjust itself according to the parent's height instead of a fixed viewport height.
     * In case of "lazy" true "treeScrollHeight" input has default value "flex"
     * @docs-default
     */
    set treeScrollHeight(value) {
        this._scrollHeight = value.toLowerCase();
    }
    get treeScrollHeight() {
        // For lazy loading case set default scrollHeight value as 'flex'
        return this.lazy ? this._scrollHeight || 'flex' : this._scrollHeight;
    }
    ngOnChanges(changes) {
        var _a;
        if (changes.selection) {
            this._checkIndeterminateStateRecursive(this.getRootNode());
        }
        if (changes.value) {
            this._flattenNodes = ((_a = changes.value.currentValue) === null || _a === void 0 ? void 0 : _a.length) ? this._getFlattenTree(changes.value.currentValue) : [];
            if (!changes.value.firstChange) {
                if (this.treeSearch) {
                    this.onClear();
                }
                if (this.draggableNodes) {
                    this.updateIcons();
                }
            }
        }
    }
    ngOnInit() {
        super.ngOnInit();
        this.texts = Object.assign(Object.assign({}, this._defaultTexts), this.texts);
        if (this.droppableNodes) {
            this.dragStartSubscription = this.dragDropService.dragStart$.subscribe(event => {
                this.dragNodeTree = event.tree;
                this.dragNode = event.node;
                this.dragNodeSubNodes = event.subNodes;
                this.dragNodeIndex = event.index;
                this.dragNodeScope = event.scope;
            });
            this.dragStopSubscription = this.dragDropService.dragStop$.subscribe(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            event => {
                this.dragNodeTree = null;
                this.dragNode = null;
                this.dragNodeSubNodes = null;
                this.dragNodeIndex = null;
                this.dragNodeScope = null;
                this.dragHover = false;
            });
        }
    }
    ngAfterContentInit() {
        this.adaptTemplates.toArray().forEach(item => {
            this._templates[item.name] = item.template;
        });
    }
    ngAfterViewInit() {
        this._elementIntersectObserver = this._adaptRadarService.subscribeOnElementIntersect(this.adaptRadarDisableEventSending, this.el, AdaptRadarAngularCustomEventName.AdaptTree);
    }
    updateIcons(droppedInto) {
        this.value.map((grandParent) => {
            var _a, _b;
            if (grandParent.isGroup && ((_a = grandParent.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                grandParent.collapsedIcon = 'd-icon-folder';
                grandParent.expandedIcon = 'd-icon-folder_open';
                grandParent.icon = null;
                grandParent.children.map((parent) => {
                    var _a, _b;
                    if (parent.isGroup && ((_a = parent.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                        parent.collapsedIcon = 'd-icon-folder';
                        parent.expandedIcon = 'd-icon-folder_open';
                        parent.icon = null;
                        parent.children.map((child) => {
                            child.icon = 'd-icon-file_o';
                            child.children = [];
                            child.droppable = false;
                        });
                    }
                    else if (parent.isGroup && (!parent.children || ((_b = parent.children) === null || _b === void 0 ? void 0 : _b.length) === 0)) {
                        parent.icon = 'd-icon-folder_o';
                    }
                    else {
                        parent.icon = 'd-icon-file_o';
                        parent.droppable = false;
                    }
                });
            }
            else if (grandParent.isGroup && (!grandParent.children || ((_b = grandParent.children) === null || _b === void 0 ? void 0 : _b.length) === 0)) {
                grandParent.icon = 'd-icon-folder_o';
            }
            else {
                grandParent.icon = 'd-icon-file_o';
                grandParent.droppable = false;
            }
        });
        if (droppedInto) {
            droppedInto.expanded = true;
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this._elementIntersectObserver) {
            this._elementIntersectObserver.disconnect();
            this._elementIntersectObserver = null;
        }
        if (this.dragStartSubscription) {
            this.dragStartSubscription.unsubscribe();
        }
        if (this.dragStopSubscription) {
            this.dragStopSubscription.unsubscribe();
        }
    }
    get treeFilterStatus() {
        var _a;
        return (this.filterQuery && ((_a = this.filteredNodes) === null || _a === void 0 ? void 0 : _a.length)) ?
            `${this._filteredToText} ${this._filteredTo}` : this.texts.filterNotFound;
    }
    get customActions() {
        return [
            {
                name: this.filterQuery ? this._checkAllFilterText : this._checkAllText,
                visible: this.isCheckAllVisible(),
                onClick: this.selectAllOptions.bind(this)
            },
            {
                name: this.filterQuery ? this._uncheckAllFilterText : this._uncheckAllText,
                visible: this.isUnCheckAllVisible(),
                onClick: this.deselectAllOptions.bind(this)
            }
        ];
    }
    get customActionsVisible() {
        return (this.selectAllButton || this.deselectAllButton) &&
            (this.isMultipleSelectionMode() || this.isCheckboxSelectionMode()) &&
            (this.isCheckAllVisible() || this.isUnCheckAllVisible());
    }
    isCheckAllVisible() {
        var _a;
        if (!this.selectAllButton) {
            return false;
        }
        if (isEmpty(this.value) || (this.filterQuery && !this.hasFilteredNodes())) {
            return false;
        }
        if (this.hasFilteredNodes()) {
            return this._flattenFilteredNodes
                .filter(node => { var _a; return !((_a = node.children) === null || _a === void 0 ? void 0 : _a.length); })
                .some(node => this.findIndexInSelection(node) < 0);
        }
        else {
            return ((_a = this.selection) === null || _a === void 0 ? void 0 : _a.length) !== this._flattenNodes.length;
        }
    }
    isUnCheckAllVisible() {
        var _a;
        if (!this.deselectAllButton) {
            return false;
        }
        if (isEmpty(this.value) || (this.filterQuery && !this.hasFilteredNodes())) {
            return false;
        }
        if (this.hasFilteredNodes()) {
            return this._flattenFilteredNodes
                .filter(node => { var _a; return !((_a = node.children) === null || _a === void 0 ? void 0 : _a.length); })
                .some(node => this.findIndexInSelection(node) >= 0);
        }
        else {
            return (_a = this.selection) === null || _a === void 0 ? void 0 : _a.length;
        }
    }
    selectAllOptions() {
        if (this.hasFilteredNodes()) {
            this._flattenFilteredNodes
                .filter(node => { var _a; return !((_a = node.children) === null || _a === void 0 ? void 0 : _a.length); })
                .forEach(node => {
                node = this.getNodeWithKey(node.key, this.value);
                if (!node) {
                    return;
                }
                const index = this.findIndexInSelection(node);
                if (index >= 0) {
                    return;
                }
                if (this.propagateSelectionDown) {
                    this.propagateDown(node, true);
                }
                else {
                    this.selection = [...this.selection || [], node];
                }
                if (this.propagateSelectionUp && node.parent) {
                    this.propagateUp(node.parent, true);
                }
            });
        }
        else {
            this._flattenNodes
                .forEach(node => {
                node = this.getNodeWithKey(node.key, this.value);
                if (!node) {
                    return;
                }
                const index = this.findIndexInSelection(node);
                if (index >= 0) {
                    return;
                }
                if (this.propagateSelectionDown) {
                    this.propagateDown(node, true);
                }
                else {
                    this.selection = [...this.selection || [], node];
                }
                if (this.propagateSelectionUp && node.parent) {
                    this.propagateUp(node.parent, true);
                }
            });
        }
        this.selectionChange.emit(this.selection);
    }
    deselectAllOptions() {
        var _a;
        if (this.hasFilteredNodes()) {
            this._flattenFilteredNodes
                .filter(node => { var _a; return !((_a = node.children) === null || _a === void 0 ? void 0 : _a.length); })
                .forEach(node => {
                node = this.getNodeWithKey(node.key, this.value);
                if (!node) {
                    return;
                }
                const index = this.findIndexInSelection(node);
                if (index < 0) {
                    return;
                }
                if (this.propagateSelectionDown) {
                    this.propagateDown(node, false);
                }
                else {
                    this.selection = this.selection.filter((val, i) => i != index);
                }
                if (this.propagateSelectionUp && node.parent) {
                    this.propagateUp(node.parent, false);
                }
            });
        }
        else {
            if (this.propagateSelectionDown) {
                this.value.forEach(node => this.propagateDown(node, false));
            }
            else {
                this.selection = null;
            }
        }
        this.selectionChange.emit(this.selection);
        (_a = getFocusableElements(this.treeContainer.nativeElement)[0]) === null || _a === void 0 ? void 0 : _a.focus();
    }
    filterWrapper(newFilterValue) {
        var _a;
        if (this.selectionMode) {
            if (!this.filterQuery && newFilterValue) {
                this.expandAll();
            }
            else if (this.filterQuery && !newFilterValue) {
                this.collapseAll();
            }
        }
        this.filterQuery = newFilterValue;
        this._filter(this.filterQuery);
        this._flattenFilteredNodes = ((_a = this.filteredNodes) === null || _a === void 0 ? void 0 : _a.length) ? this._getFlattenTree(this.filteredNodes) : [];
        this._filteredTo = this.selectionMode ?
            this._flattenFilteredNodes.filter(node => { var _a; return !((_a = node.children) === null || _a === void 0 ? void 0 : _a.length); }).length :
            this._flattenFilteredNodes.length;
    }
    setDefaultTexts(translation) {
        this._defaultTexts.filterPlaceholder = translation['adapt.common.filter'];
        this._defaultTexts.filterBtnClearText = translation['adapt.common.clear'];
        this._defaultTexts.filterNotFound = translation['adapt.tree.notFound'];
        this._filteredToText = translation['adapt.select.filteredTo'];
        this._checkAllText = translation['adapt.select.checkAll'];
        this._checkAllFilterText = translation['adapt.select.checkAllFilter'];
        this._uncheckAllText = translation['adapt.select.uncheckAll'];
        this._uncheckAllFilterText = translation['adapt.select.uncheckAllFilter'];
    }
    onNodeClick(event, node) {
        super.onNodeClick(event, node);
    }
    onNodeRightClick(event, node) {
        super.onNodeRightClick(event, node);
    }
    findIndexInSelection(node) {
        return super.findIndexInSelection(node);
    }
    propagateUp(node, select) {
        super.propagateUp(node, select);
    }
    propagateDown(node, select) {
        super.propagateDown(node, select);
    }
    isSelected(node) {
        return super.isSelected(node);
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getTemplateForNode(node) {
        if (!isEmpty(this._templates)) {
            return node.type && this._templates[node.type] ? this._templates[node.type] : this._templates.default;
        }
        return null;
    }
    // TODO: Refactor this if possible
    allowDrop(dragNode, dropNode, dragNodeScope) {
        return super.allowDrop(dragNode, dropNode, dragNodeScope);
    }
    onClear() {
        this.filterQuery = '';
        this._filter(this.filterQuery);
    }
    onLazyLoad() {
        // Emit lazy load event only when there is no filter value. Because filtering applied only on already loaded data.
        if (!this.filterQuery) {
            this.lazyLoad.emit();
        }
    }
    trackByNode(index, item) {
        return item.key;
    }
    expandAll() {
        this.value.forEach(node => {
            this._expandRecursive(node, true);
        });
    }
    collapseAll() {
        this.value.forEach(node => {
            this._expandRecursive(node, false);
        });
    }
    onDragOver(event) {
        super.onDragOver(event);
    }
    onDrop(event) {
        super.onDrop(event);
        this.updateIcons();
    }
    processTreeDrop(dragNode, dragNodeIndex) {
        super.processTreeDrop(dragNode, dragNodeIndex);
    }
    onDragEnter() {
        super.onDragEnter();
    }
    onDragLeave(event) {
        if (this.droppableNodes) {
            const rect = event.currentTarget.getBoundingClientRect();
            if (event.x > rect.left + rect.width || event.x < rect.left || event.y > rect.top + rect.height || event.y < rect.top) {
                this.dragHover = false;
            }
        }
    }
    isValidDragScope(dragScope) {
        return super.isValidDragScope(dragScope);
    }
    _expandRecursive(node, isExpand) {
        node.expanded = isExpand;
        if (node.children) {
            node.children.forEach(childNode => {
                this._expandRecursive(childNode, isExpand);
            });
        }
    }
    _checkIndeterminateStateRecursive(nodes, parent) {
        if (!nodes) {
            return;
        }
        nodes.forEach(node => {
            if (node.children) {
                this._checkIndeterminateStateRecursive(node.children, node);
                let selectedCount = 0;
                let partialSelected = false;
                for (let i = 0; i < node.children.length; i++) {
                    if (node.children[i].partialSelected) {
                        partialSelected = true;
                        break;
                    }
                    if (this.findIndexInSelection(node.children[i]) >= 0) {
                        selectedCount++;
                    }
                    if ((selectedCount > 0) && (selectedCount < (i + 1))) {
                        partialSelected = true;
                        break;
                    }
                }
                node.partialSelected = partialSelected;
                if (parent) {
                    parent.partialSelected = node.partialSelected;
                }
            }
        });
    }
    _getFlattenTree(treeData) {
        const flattenTree = [];
        treeData.forEach(node => {
            this._flattenRecursive(node, flattenTree);
        });
        return flattenTree;
    }
    _flattenRecursive(node, flattenTree) {
        flattenTree.push(node);
        if (node.children) {
            node.children.forEach(childNode => {
                this._flattenRecursive(childNode, flattenTree);
            });
        }
    }
}
AdaptTreeComponent.ɵfac = function AdaptTreeComponent_Factory(t) { return new (t || AdaptTreeComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.TreeDragDropService), i0.ɵɵdirectiveInject(i2.Directionality), i0.ɵɵdirectiveInject(i1.PrimeNGConfig), i0.ɵɵdirectiveInject(i3.AdaptTranslateService), i0.ɵɵdirectiveInject(i4.AdaptRadarAngularService)); };
AdaptTreeComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTreeComponent, selectors: [["adapt-tree"]], contentQueries: function AdaptTreeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, AdaptTreeNodeTemplateDirective, 4);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptTemplates = _t);
    } }, viewQuery: function AdaptTreeComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 5);
        i0.ɵɵviewQuery(_c2, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeSearch = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.treeNodeComponents = _t);
    } }, inputs: { value: "value", filter: "filter", texts: "texts", filterBtnClearText: "filterBtnClearText", filterPlaceholder: "filterPlaceholder", testID: "testID", lazy: "lazy", lazyLoading: "lazyLoading", trim: "trim", wrap: "wrap", selectAllButton: "selectAllButton", deselectAllButton: "deselectAllButton", treeScrollHeight: "treeScrollHeight", adaptRadarDisableEventSending: "adaptRadarDisableEventSending", draggableScope: "draggableScope", droppableScope: "droppableScope", draggableNodes: "draggableNodes", droppableNodes: "droppableNodes", validateDrop: "validateDrop" }, outputs: { onNodeDrop: "onNodeDrop", lazyLoad: "lazyLoad" }, features: [i0.ɵɵProvidersFeature([SharedModule, TreeDragDropService]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 2, vars: 1, consts: [[3, "ngClass", "ngStyle", "class", "drop", "dragover", "dragenter", "dragleave", 4, "ngIf"], [3, "ngClass", "ngStyle", "drop", "dragover", "dragenter", "dragleave"], [1, "a-tree__filter"], [3, "adaptRadarDisableEventSending", "ngModel", "clearButtonText", "placeholder", "ngModelChange", 4, "ngIf"], ["class", "a-tree__filter-controls", 4, "ngIf"], ["role", "tree", 1, "a-tree__container", 3, "ngStyle"], ["treeContainer", ""], ["role", "status", "class", "a-tree__no-matches", 3, "sr-only", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], [3, "adaptRadarDisableEventSending", "ngModel", "clearButtonText", "placeholder", "ngModelChange"], ["treeSearch", ""], [1, "a-tree__filter-controls"], ["class", "a-tree__filter-status", 4, "ngIf"], [3, "actions", "adaptRadarDisableEventSending"], [1, "a-tree__filter-status"], ["role", "status", 1, "a-tree__no-matches"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["treeNodeTemplate", ""], [3, "level", "parentNode", "filter", "query", "node", "testID", "firstChild", "lastChild", "index"], ["treeNodeComponent", ""], ["class", "a-tree__children", "role", "group", 4, "ngIf"], ["role", "group", 1, "a-tree__children"], ["adaptLazyLoadAnchor", "", 1, "pt-1", "pb-2", 3, "lazyLoadRootContainer", "lazyLoadThresholds", "lazyLoad"], ["class", "loader-container pt-0 pb-0 m-start-4", 4, "ngIf"], [1, "loader-container", "pt-0", "pb-0", "m-start-4"], [1, "loader-section"]], template: function AdaptTreeComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptTreeComponent_div_0_Template, 19, 24, "div", 0);
        i0.ɵɵtext(1, "\n\n\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", !ctx.horizontal);
    } }, encapsulation: 2, data: { animation: [
            trigger('nodeAnimation', [
                transition(':enter', [
                    style({ opacity: '0', transform: 'translate(-10px, 0)', width: '0', height: '0', overflow: 'hidden' }),
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, keyframes([
                        style({
                            opacity: '0',
                            transform: 'translate(-10px, 0)',
                            width: '0',
                            height: '0',
                            overflow: 'hidden',
                            offset: 0
                        }),
                        style({
                            opacity: '0',
                            transform: 'translate(-10px, 0)',
                            width: '*',
                            height: '*',
                            overflow: 'hidden',
                            offset: 0.1
                        }),
                        style({ opacity: '*', transform: 'translate(0, 0)', width: '*', height: '*', overflow: 'visible', offset: 1 })
                    ]))
                ]),
                transition(':leave', [
                    style({ opacity: '*', width: '*', height: '*', overflow: 'visible' }),
                    animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, keyframes([
                        style({ opacity: '*', width: '*', height: '*', overflow: 'visible', offset: 0 }),
                        style({ opacity: '0', width: '*', height: '*', overflow: 'visible', offset: 0.9 }),
                        style({ opacity: '0', width: '0', height: '0', overflow: 'hidden', offset: 1 })
                    ]))
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTreeComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-tree',
                templateUrl: './tree.component.html',
                providers: [SharedModule, TreeDragDropService],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('nodeAnimation', [
                        transition(':enter', [
                            style({ opacity: '0', transform: 'translate(-10px, 0)', width: '0', height: '0', overflow: 'hidden' }),
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, keyframes([
                                style({
                                    opacity: '0',
                                    transform: 'translate(-10px, 0)',
                                    width: '0',
                                    height: '0',
                                    overflow: 'hidden',
                                    offset: 0
                                }),
                                style({
                                    opacity: '0',
                                    transform: 'translate(-10px, 0)',
                                    width: '*',
                                    height: '*',
                                    overflow: 'hidden',
                                    offset: 0.1
                                }),
                                style({ opacity: '*', transform: 'translate(0, 0)', width: '*', height: '*', overflow: 'visible', offset: 1 })
                            ]))
                        ]),
                        transition(':leave', [
                            style({ opacity: '*', width: '*', height: '*', overflow: 'visible' }),
                            animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionInOut}`, keyframes([
                                style({ opacity: '*', width: '*', height: '*', overflow: 'visible', offset: 0 }),
                                style({ opacity: '0', width: '*', height: '*', overflow: 'visible', offset: 0.9 }),
                                style({ opacity: '0', width: '0', height: '0', overflow: 'hidden', offset: 1 })
                            ]))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i1.TreeDragDropService }, { type: i2.Directionality }, { type: i1.PrimeNGConfig }, { type: i3.AdaptTranslateService }, { type: i4.AdaptRadarAngularService }]; }, { value: [{
            type: Input
        }], filter: [{
            type: Input
        }], texts: [{
            type: Input
        }], filterBtnClearText: [{
            type: Input
        }], filterPlaceholder: [{
            type: Input
        }], testID: [{
            type: Input
        }], lazy: [{
            type: Input
        }], lazyLoading: [{
            type: Input
        }], trim: [{
            type: Input
        }], wrap: [{
            type: Input
        }], selectAllButton: [{
            type: Input
        }], deselectAllButton: [{
            type: Input
        }], treeScrollHeight: [{
            type: Input
        }], adaptRadarDisableEventSending: [{
            type: Input
        }], draggableScope: [{
            type: Input
        }], droppableScope: [{
            type: Input
        }], draggableNodes: [{
            type: Input
        }], droppableNodes: [{
            type: Input
        }], validateDrop: [{
            type: Input
        }], onNodeDrop: [{
            type: Output
        }], lazyLoad: [{
            type: Output
        }], treeSearch: [{
            type: ViewChild,
            args: ['treeSearch', { static: false }]
        }], treeContainer: [{
            type: ViewChild,
            args: ['treeContainer', { static: false }]
        }], treeNodeComponents: [{
            type: ViewChildren,
            args: ['treeNodeComponent']
        }], adaptTemplates: [{
            type: ContentChildren,
            args: [AdaptTreeNodeTemplateDirective]
        }] }); })();
//# sourceMappingURL=tree.component.js.map