import { Injectable } from '@angular/core';
import { escapeRegExp, isEmpty, uniq } from 'lodash-es';
import BigNumber from 'bignumber.js';
import { getTagText } from '../../metatag/index';
import { AdaptRxDatetimeParserFormatter, checkIsAfter, RxDatetimePickerMode } from '../../rx/rx-datetime/index';
import { isEmptyOrWhitespace } from '../../common/utilities';
import { AdvancedFilterOptionDataType, booleanDataTypeBlankValue } from './advanced-filter.models';
import { ADVANCED_FILTER_CONSTS, formatAdvancedFilterTagText, isFiniteNumber, parseNumericRange } from '../advanced-filtering-utils';
import * as i0 from "@angular/core";
import * as i1 from "../../rx/rx-datetime/index";
export class AdvancedFilterDataTypesConfigsService {
    constructor(_rxDatetimeParserFormatter) {
        this._rxDatetimeParserFormatter = _rxDatetimeParserFormatter;
    }
    static isEmptyOnEmptyValues(value) {
        return value == null || (Array.isArray(value) && (value.length === 0 || value.every(val => val == null)));
    }
    static getExpressionRawValues(option, searchTerm, filterNamePrefix) {
        const escapedStringForRegExp = `^${escapeRegExp(filterNamePrefix || option.label)}${ADVANCED_FILTER_CONSTS.TAG_OPTION_DELIMITER}?`;
        const searchTermResults = new RegExp(escapedStringForRegExp, 'i').exec(searchTerm);
        return searchTermResults ? searchTerm.substring(searchTermResults[0].length) : null;
    }
    static createAdvancedFilterTag(value, filterOption, filterOptionConfig, isIncompletedExpression, tagText) {
        return {
            data: {
                value,
                filterOption,
                isIncompletedExpression,
            },
            text: tagText || filterOptionConfig.getTagText(value, filterOption),
        };
    }
    getConfigs(texts) {
        const parserFormatter = this._rxDatetimeParserFormatter;
        const configs = {
            // also default implementations
            // TODO: Refactor this if possible
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            [AdvancedFilterOptionDataType.custom]: {
                getExpressionFieldTips: () => [],
                needRemoveTagValue: (value) => AdvancedFilterDataTypesConfigsService.isEmptyOnEmptyValues(value),
                formatValueForTag: (value) => String(value),
                // TODO: Refactor this if possible
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                getTagText(value, filterOption) {
                    return formatAdvancedFilterTagText(filterOption, this.formatValueForTag(value, filterOption));
                },
                updateFilterValue: (newValue) => newValue,
                parseTagFieldExpression: () => null,
                validateValue: () => [],
            },
            [AdvancedFilterOptionDataType.boolean]: {
                getExpressionFieldTips(option) {
                    const config = this;
                    return [
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag(false, option, config, false),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag(true, option, config, false),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag(booleanDataTypeBlankValue, option, config, false),
                    ];
                },
                formatValueForTag: (value) => value ? (value === booleanDataTypeBlankValue ? texts.blankLabel : texts.trueLabel) : texts.falseLabel,
                needRemoveTagValue: (value) => value == null,
                parseTagFieldExpression: (option, searchTerm) => {
                    let valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(option, searchTerm);
                    let resultValue;
                    valuesStr = valuesStr ? valuesStr.trim().toUpperCase() : null;
                    switch (valuesStr) {
                        case texts.trueLabel.toUpperCase():
                            resultValue = true;
                            break;
                        case texts.falseLabel.toUpperCase():
                            resultValue = false;
                            break;
                        case texts.blankLabel.toUpperCase():
                            resultValue = booleanDataTypeBlankValue;
                            break;
                        default:
                            return null;
                    }
                    return { value: resultValue };
                },
            },
            [AdvancedFilterOptionDataType.string]: {
                getExpressionFieldTips(option) {
                    return [AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([], option, this, true, formatAdvancedFilterTagText(option, ''))];
                },
                formatValueForTag: (value, filterOption) => {
                    const params = (filterOption.data || {});
                    if (typeof params.adjustModelForTagField === 'function') {
                        const newValue = params.adjustModelForTagField(value, filterOption);
                        if (newValue) {
                            value = newValue.map(tag => getTagText(tag));
                        }
                    }
                    return value.join(', ');
                },
                needRemoveTagValue: (value) => AdvancedFilterDataTypesConfigsService.isEmptyOnEmptyValues(value) || value.every(val => isEmptyOrWhitespace(val)),
                updateFilterValue: (newValue, oldValue) => uniq(oldValue.concat(newValue)),
                parseTagFieldExpression: (option, searchTerm) => {
                    const valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(option, searchTerm);
                    if (!valuesStr) {
                        return null;
                    }
                    const values = valuesStr.split(',').filter(str => !isEmptyOrWhitespace(str)).map(str => str.trim());
                    return values.length ? { value: values } : null;
                },
            },
            [AdvancedFilterOptionDataType.time]: {
                getExpressionFieldTips(option) {
                    return [
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, formatAdvancedFilterTagText(option, '')),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, `${option.label} ${texts.fromLabel} `),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, `${option.label} ${texts.toLabel} `)
                    ];
                },
                formatValueForTag: (value) => {
                    return value.filter(val => val).map(date => parserFormatter.format(date, RxDatetimePickerMode.Time, true)).join(' - ');
                },
                updateFilterValue: (newValue, oldValue) => {
                    return [newValue[0] || oldValue[0], newValue[1] || oldValue[1]];
                },
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    let valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm, `${filterOption.label} ${texts.fromLabel}`);
                    if (valuesStr != null) {
                        const dateFrom = parserFormatter.parse(valuesStr, RxDatetimePickerMode.Time, true);
                        return dateFrom.parseError ? null : { value: [dateFrom, null] };
                    }
                    valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm, `${filterOption.label} ${texts.toLabel}`);
                    if (valuesStr != null) {
                        const dateTo = parserFormatter.parse(valuesStr, RxDatetimePickerMode.Time, true);
                        return dateTo.parseError ? null : { value: [null, dateTo] };
                    }
                    valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm);
                    if (valuesStr != null) {
                        const valuesStrings = valuesStr.split('-');
                        const dateFrom = parserFormatter.parse(valuesStrings[0], RxDatetimePickerMode.Time, true);
                        const dateTo = valuesStrings[1] ? parserFormatter.parse(valuesStrings[1], RxDatetimePickerMode.Time, true) : { parseError: { query: valuesStrings[1] } };
                        return (dateFrom.parseError && !dateTo.parseError) ?
                            null : { value: [!dateFrom.parseError ? dateFrom : null, !dateTo.parseError ? dateTo : null] };
                    }
                    return null;
                },
                validateValue: (value) => {
                    const fromValue = value && value[0];
                    const toValue = value && value[1];
                    if ((fromValue && !fromValue.parseError) && (toValue && !toValue.parseError) && checkIsAfter(fromValue, toValue)) {
                        return [{ name: texts.validationErrors.invalidRangeName, text: texts.validationErrors.invalidRangeText }];
                    }
                    return [];
                },
            },
            [AdvancedFilterOptionDataType.date]: {
                getExpressionFieldTips(option) {
                    return [
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, formatAdvancedFilterTagText(option, '')),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, `${option.label} ${texts.fromLabel} `),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, `${option.label} ${texts.toLabel} `)
                    ];
                },
                formatValueForTag(value) {
                    return value.filter(val => val).map(date => parserFormatter.format(date, RxDatetimePickerMode.Date)).join(' - ');
                },
                updateFilterValue: (newValue, oldValue) => {
                    return [newValue[0] || oldValue[0], newValue[1] || oldValue[1]];
                },
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    let valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm, `${filterOption.label} ${texts.fromLabel}`);
                    if (valuesStr != null) {
                        const dateFrom = parserFormatter.parse(valuesStr, RxDatetimePickerMode.Date);
                        return dateFrom.parseError ? null : { value: [dateFrom, null] };
                    }
                    valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm, `${filterOption.label} ${texts.toLabel}`);
                    if (valuesStr != null) {
                        const dateTo = parserFormatter.parse(valuesStr, RxDatetimePickerMode.Date);
                        return dateTo.parseError ? null : { value: [null, dateTo] };
                    }
                    valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm);
                    if (valuesStr != null) {
                        const valuesStrings = valuesStr.split('-');
                        const dateFrom = parserFormatter.parse(valuesStrings[0], RxDatetimePickerMode.Date);
                        const dateTo = valuesStrings[1] ? parserFormatter.parse(valuesStrings[1], RxDatetimePickerMode.Date) : { parseError: { query: valuesStrings[1] } };
                        return (dateFrom.parseError && dateTo.parseError) ?
                            null : { value: [!dateFrom.parseError ? dateFrom : null, !dateTo.parseError ? dateTo : null] };
                    }
                    return null;
                },
                validateValue: (value) => {
                    const fromValue = value && value[0];
                    const toValue = value && value[1];
                    if ((fromValue && !fromValue.parseError) && (toValue && !toValue.parseError) && checkIsAfter(fromValue, toValue)) {
                        return [{ name: texts.validationErrors.invalidRangeName, text: texts.validationErrors.invalidRangeText }];
                    }
                    return [];
                },
            },
            [AdvancedFilterOptionDataType.datetime]: {
                getExpressionFieldTips(option) {
                    return [
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, formatAdvancedFilterTagText(option, '')),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, `${option.label} ${texts.fromLabel} `),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, `${option.label} ${texts.toLabel} `)
                    ];
                },
                formatValueForTag(value) {
                    return value.filter(val => val).map(date => parserFormatter.format(date, RxDatetimePickerMode.DateTime)).join(' - ');
                },
                updateFilterValue: (newValue, oldValue) => {
                    return [newValue[0] || oldValue[0], newValue[1] || oldValue[1]];
                },
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    let valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm, `${filterOption.label} ${texts.fromLabel}`);
                    if (valuesStr != null) {
                        const dateFrom = parserFormatter.parse(valuesStr, RxDatetimePickerMode.DateTime);
                        return dateFrom.parseError ? null : { value: [dateFrom, null] };
                    }
                    valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm, `${filterOption.label} ${texts.toLabel}`);
                    if (valuesStr != null) {
                        const dateTo = parserFormatter.parse(valuesStr, RxDatetimePickerMode.DateTime);
                        return dateTo.parseError ? null : { value: [null, dateTo] };
                    }
                    valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm);
                    if (valuesStr != null) {
                        const valuesStrings = valuesStr.split('-');
                        const dateFrom = parserFormatter.parse(valuesStrings[0], RxDatetimePickerMode.DateTime);
                        const dateTo = valuesStrings[1] ? parserFormatter.parse(valuesStrings[1], RxDatetimePickerMode.DateTime) : { parseError: { query: valuesStrings[1] } };
                        return (dateFrom.parseError && dateTo.parseError) ?
                            null : { value: [!dateFrom.parseError ? dateFrom : null, !dateTo.parseError ? dateTo : null] };
                    }
                    return null;
                },
                validateValue: (value) => {
                    const fromValue = value && value[0];
                    const toValue = value && value[1];
                    if ((fromValue && !fromValue.parseError) && (toValue && !toValue.parseError) && checkIsAfter(fromValue, toValue)) {
                        return [{ name: texts.validationErrors.invalidRangeName, text: texts.validationErrors.invalidRangeText }];
                    }
                    return [];
                },
            },
            [AdvancedFilterOptionDataType.selection]: {
                getExpressionFieldTips(filterOption) {
                    const data = filterOption.data;
                    const selectOptions = data && data.selectOptions || [];
                    return selectOptions.map(selectOption => {
                        return AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([selectOption.id], filterOption, this, false, formatAdvancedFilterTagText(filterOption, selectOption.name));
                    });
                },
                formatValueForTag: (value, option) => {
                    const data = option.data;
                    const selectOptions = data && data.selectOptions || [];
                    return value.map(id => selectOptions.find(selectOption => selectOption.id === id).name).join(', ');
                },
                updateFilterValue: (newValue, oldValue) => uniq(oldValue.concat(newValue)),
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    const valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm);
                    if (!valuesStr) {
                        return null;
                    }
                    const data = filterOption.data;
                    const selectOptions = data && data.selectOptions || [];
                    let value = [];
                    valuesStr.split(',').forEach(optionLabel => {
                        optionLabel = optionLabel.trim().toUpperCase();
                        const selectOption = selectOptions.find(option => option.name.toUpperCase() === optionLabel);
                        if (selectOption) {
                            value.push(selectOption.id);
                        }
                    });
                    value = uniq(value);
                    return value.length ? { value } : null;
                },
            },
            [AdvancedFilterOptionDataType.number]: {
                getExpressionFieldTips(option) {
                    return [
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, formatAdvancedFilterTagText(option, '')),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, `${option.label} ${texts.fromLabel} `),
                        AdvancedFilterDataTypesConfigsService.createAdvancedFilterTag([null, null], option, this, true, `${option.label} ${texts.toLabel} `)
                    ];
                },
                formatValueForTag: (value) => value.filter(val => val != null).map(val => String(val)).join(' - '),
                updateFilterValue: (newValue, oldValue) => {
                    return [newValue[0] == null ? oldValue[0] : newValue[0], newValue[1] == null ? oldValue[1] : newValue[1]];
                },
                parseTagFieldExpression: (filterOption, searchTerm) => {
                    let valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm, `${filterOption.label} ${texts.fromLabel}`);
                    if (valuesStr != null) {
                        const fromValue = parseFloat(valuesStr);
                        return isFiniteNumber(fromValue) ? { value: [fromValue, null] } : null;
                    }
                    valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm, `${filterOption.label} ${texts.toLabel}`);
                    if (valuesStr != null) {
                        const toValue = parseFloat(valuesStr);
                        return isFiniteNumber(toValue) ? { value: [null, toValue] } : null;
                    }
                    valuesStr = AdvancedFilterDataTypesConfigsService.getExpressionRawValues(filterOption, searchTerm);
                    if (valuesStr != null) {
                        const values = parseNumericRange(valuesStr.trim());
                        return isEmpty(values) ? null : { value: [values[0], isFiniteNumber(values[1]) ? values[1] : null] };
                    }
                    return null;
                },
                validateValue: (value, filterOption) => {
                    const fromValue = value && value[0];
                    const toValue = value && value[1];
                    const errors = [];
                    const isFiniteFromValue = isFiniteNumber(fromValue);
                    const isFiniteToValue = isFiniteNumber(toValue);
                    const numberTypeTexts = texts.validationErrors.numberTypeTexts;
                    const filterParams = (filterOption.data || {});
                    const minValue = filterParams.minValue;
                    const maxValue = filterParams.maxValue;
                    if (!isFiniteFromValue && fromValue != null) {
                        errors.push({ name: texts.validationErrors.invalidRangeName, text: numberTypeTexts.fromValueMustBeNumber });
                    }
                    if (!isFiniteToValue && toValue != null) {
                        errors.push({ name: texts.validationErrors.invalidRangeName, text: numberTypeTexts.toValueMustBeNumber });
                    }
                    if (isFiniteFromValue && isFiniteToValue && fromValue > toValue) {
                        errors.push({ name: texts.validationErrors.invalidRangeName, text: texts.validationErrors.invalidRangeText });
                    }
                    if ((minValue != null && (isFiniteFromValue && (new BigNumber(fromValue)).isLessThan(minValue) ||
                        isFiniteToValue && (new BigNumber(toValue)).isLessThan(minValue))) ||
                        (maxValue != null && (isFiniteFromValue && (new BigNumber(fromValue)).isGreaterThan(maxValue) ||
                            isFiniteToValue && (new BigNumber(toValue)).isGreaterThan(maxValue)))) {
                        if (minValue == null || maxValue == null) {
                            if (maxValue == null) {
                                errors.push({
                                    name: texts.validationErrors.invalidRangeName,
                                    text: numberTypeTexts.invalidMinValue.replace('{minValue}', String(minValue))
                                });
                            }
                            else {
                                errors.push({
                                    name: texts.validationErrors.invalidRangeName,
                                    text: numberTypeTexts.invalidMaxValue.replace('{maxValue}', String(maxValue))
                                });
                            }
                        }
                        else {
                            errors.push({
                                name: texts.validationErrors.invalidRangeName,
                                text: numberTypeTexts.invalidBetweenMinAndMax.replace('{minValue}', String(minValue))
                                    .replace('{maxValue}', String(maxValue))
                            });
                        }
                    }
                    return errors;
                },
            },
        };
        // set default implementations
        const baseAdvancedFilterOptionConfig = configs[AdvancedFilterOptionDataType.custom];
        for (const key in configs) {
            if (Object.prototype.hasOwnProperty.call(configs, key) && key !== AdvancedFilterOptionDataType.custom) {
                configs[key] = Object.assign(Object.assign({}, baseAdvancedFilterOptionConfig), configs[key]);
            }
        }
        return configs;
    }
}
AdvancedFilterDataTypesConfigsService.ɵfac = function AdvancedFilterDataTypesConfigsService_Factory(t) { return new (t || AdvancedFilterDataTypesConfigsService)(i0.ɵɵinject(i1.AdaptRxDatetimeParserFormatter)); };
AdvancedFilterDataTypesConfigsService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdvancedFilterDataTypesConfigsService, factory: AdvancedFilterDataTypesConfigsService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdvancedFilterDataTypesConfigsService, [{
        type: Injectable
    }], function () { return [{ type: i1.AdaptRxDatetimeParserFormatter }]; }, null); })();
//# sourceMappingURL=advanced-filter-configs.service.js.map