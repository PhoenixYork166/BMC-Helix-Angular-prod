import { ChangeDetectorRef, Component, ElementRef, Input, NgZone, Optional, Self, ViewChild } from '@angular/core';
import { NgControl } from '@angular/forms';
import { isEqual } from 'lodash-es';
import { take, takeUntil } from 'rxjs/operators';
import { AdaptTranslateService } from '../../common/i18n/index';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularService } from '../../common/radar/adapt-radar';
import { AdaptRxFeedbackComponent, AdaptRxFormControlDirective } from '../form-control/index';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "../../common/i18n/index";
import * as i3 from "../../common/radar/adapt-radar";
import * as i4 from "../form-control/rx-control-label/adapt-rx-control-label.component";
import * as i5 from "../form-control/rx-feedback/adapt-rx-feedback.component";
const _c0 = ["adaptRxFeedbackRef"];
const _c1 = ["*"];
export class AdaptRxRadiobuttonGroupComponent extends AdaptRxFormControlDirective {
    constructor(ngControl, _changeDetectorRef, ts, _ngZone, _adaptRadarService, _elem) {
        super(ngControl, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRxRadiobuttonGroup, _changeDetectorRef);
        this.ts = ts;
        this._ngZone = _ngZone;
        this.controlName = 'radiobutton-group';
        this.analyticsComponentName = AdaptRadarAngularCustomEventName;
        this._radioButtons = [];
    }
    /**
     * Check if the control has UI error state
     */
    get hasDangerState() {
        return this.adaptRxFeedbackRef.hasUIErrorState;
    }
    ngOnInit() {
        super.ngOnInit();
        this._checkName();
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._ngZone.onStable
            .pipe(takeUntil(this.destroy$), take(1))
            .subscribe(() => {
            if (this._radioButtons.length) {
                if (this.autofocus) {
                    (this._selectedRadioButton || this._radioButtons[0]).inputRef.nativeElement.focus();
                }
                if (this.tabIndex || this.tabIndex === 0) {
                    this._radioButtons.forEach(radiobutton => {
                        radiobutton.tabIndex = this.tabIndex;
                    });
                }
            }
        });
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    get value() {
        return this._value;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set value(newValue) {
        if (!isEqual(this._value, newValue)) {
            // Set this before proceeding to ensure no circular loop occurs with selection.
            this._value = newValue;
            this._updateSelectedRadioFromValue();
            this._checkSelectedRadioButton();
            this.stateChanges$.next();
        }
    }
    /**
     * Mark formControl as touched.
     * Wrapper to be able to invoke protected _onTouch
     */
    markAsTouched() {
        this._onTouched();
    }
    /**
     * Propagate formControl change.
     * Wrapper to be able to invoke protected _onChange
     */
    propagateChange() {
        this._onChange(this._value);
    }
    /**
     * Implementation of base abstract member
     */
    writeValue(value) {
        if (value !== undefined) {
            this._value = value;
        }
        this._updateSelectedRadioFromValue();
        this._checkSelectedRadioButton();
    }
    /**
     * Implementation from the base class
     */
    _focusNativeElement() {
        // This logic is located in the ngAfterViewInit
    }
    /**
     * Updates the `selected` radio button from the internal _value state.
     */
    _updateSelectedRadioFromValue() {
        // If the value already matches the selected radio, do nothing.
        const isAlreadySelected = this._selectedRadioButton && this._selectedRadioButton.value === this._value;
        if (this._radioButtons && !isAlreadySelected) {
            this._selectedRadioButton = null;
            this._radioButtons.forEach(radio => {
                radio.checked = this.value === radio.value;
                if (radio.checked) {
                    this._selectedRadioButton = radio;
                }
            });
        }
    }
    /**
     * Check if selected radioButton is checked
     */
    _checkSelectedRadioButton() {
        if (this._selectedRadioButton && !this._selectedRadioButton.checked) {
            this._selectedRadioButton.checked = true;
        }
    }
    /**
     * Check if [name] and [formControlName] attributes set.
     * Took from Angular -> radio_control_value_accessor
     */
    _checkName() {
        if (this.name && this.formControlName && this.name !== this.formControlName) {
            throw new Error(`
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <adapt-rx-radiobutton-group formControlName="food" name="food">
    `);
        }
        if (!this.name && this.formControlName) {
            this.name = this.formControlName;
        }
        if (!this.name && !this.formControlName) {
            this.name = `${this.id}_options`;
        }
    }
}
AdaptRxRadiobuttonGroupComponent.ɵfac = function AdaptRxRadiobuttonGroupComponent_Factory(t) { return new (t || AdaptRxRadiobuttonGroupComponent)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRxRadiobuttonGroupComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxRadiobuttonGroupComponent, selectors: [["adapt-rx-radiobutton-group"]], viewQuery: function AdaptRxRadiobuttonGroupComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptRxFeedbackRef = _t.first);
    } }, inputs: { formControlName: "formControlName" }, features: [i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 16, vars: 20, consts: [["role", "radiogroup"], [3, "for", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"], [1, "sr-only"], [3, "ariaErrorMessage", "errors", "warningMessage", "controlTouched", "messageAppeared"], ["adaptRxFeedbackRef", ""]], template: function AdaptRxRadiobuttonGroupComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelement(2, "adapt-rx-control-label", 1);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵelementStart(4, "fieldset");
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵelementStart(6, "legend", 2);
        i0.ɵɵtext(7);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n    ");
        i0.ɵɵprojection(9);
        i0.ɵɵtext(10, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(11, "\n\n  ");
        i0.ɵɵelementStart(12, "adapt-rx-feedback", 3, 4);
        i0.ɵɵlistener("messageAppeared", function AdaptRxRadiobuttonGroupComponent_Template_adapt_rx_feedback_messageAppeared_12_listener($event) { return ctx.handleMessageAppeared($event, ctx.analyticsComponentName.AdaptRxRadiobutton); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(14, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(15, "\n");
    } if (rf & 2) {
        const _r0 = i0.ɵɵreference(13);
        i0.ɵɵclassProp("has-danger", _r0.hasUIErrorState)("has-warning", ctx.warningMessage);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", null)("label", ctx.label)("subLabel", ctx.subLabel)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltip)("testID", ctx.testID);
        i0.ɵɵadvance(2);
        i0.ɵɵattribute("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy)("aria-invalid", ctx.hasDangerState)("aria-errormessage", ctx.ariaErrorMessage);
        i0.ɵɵadvance(3);
        i0.ɵɵtextInterpolate(ctx.label || ctx.ariaLabel);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ariaErrorMessage", ctx.ariaErrorMessage)("errors", ctx.ngControl.errors)("warningMessage", ctx.warningMessage)("controlTouched", ctx.ngControl.touched);
    } }, directives: [i4.AdaptRxControlLabelComponent, i5.AdaptRxFeedbackComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxRadiobuttonGroupComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-radiobutton-group',
                templateUrl: './adapt-rx-radiobutton-group.component.html'
            }]
    }], function () { return [{ type: i1.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i0.ChangeDetectorRef }, { type: i2.AdaptTranslateService }, { type: i0.NgZone }, { type: i3.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { formControlName: [{
            type: Input
        }], adaptRxFeedbackRef: [{
            type: ViewChild,
            args: ['adaptRxFeedbackRef', { static: true }]
        }] }); })();
//# sourceMappingURL=adapt-rx-radiobutton-group.component.js.map