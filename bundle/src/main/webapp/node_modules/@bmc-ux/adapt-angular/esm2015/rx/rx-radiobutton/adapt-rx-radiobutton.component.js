import { Component, ElementRef, EventEmitter, Input, NgZone, Optional, Output, ViewChild } from '@angular/core';
import { isEqual } from 'lodash-es';
import { ReplaySubject } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularCustomEventType, AdaptRadarAngularService, AdaptRadarAngularGenericDirective } from '../../common/radar/adapt-radar';
import { AdaptRxRadiobuttonGroupComponent } from './adapt-rx-radiobutton-group.component';
import * as i0 from "@angular/core";
import * as i1 from "./adapt-rx-radiobutton-group.component";
import * as i2 from "../../common/radar/adapt-radar";
import * as i3 from "@angular/common";
const _c0 = ["inputRef"];
function AdaptRxRadiobuttonComponent_span_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "span", 6);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.label);
} }
const _c1 = function (a0) { return { "radio__item_no-label": a0 }; };
let radioUniqueId = 1;
export class AdaptRxRadiobuttonComponent extends AdaptRadarAngularGenericDirective {
    constructor(radiobuttonGroup, _ngZone, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRxRadiobutton);
        this._ngZone = _ngZone;
        this._adaptRadarService = _adaptRadarService;
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onFocus = new EventEmitter();
        // eslint-disable-next-line @angular-eslint/no-output-on-prefix
        this.onBlur = new EventEmitter();
        /**
         * Checked state change emitter
         */
        this.checkedChange = new EventEmitter();
        this._controlName = 'radiobutton';
        this._checked = false;
        this._destroyed$ = new ReplaySubject(1);
        this._radioButtonGroup = radiobuttonGroup;
        if (this._radioButtonGroup) {
            this._radioButtonGroup._radioButtons.push(this);
        }
    }
    /**
     * Custom id for the input
     * @docs-default
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value || this._uniqId;
    }
    /**
     * Input [value] attribute
     * @docs-default
     */
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    get value() {
        return this._value;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set value(value) {
        if (this._value !== value) {
            this._value = value;
            if (this._radioButtonGroup) {
                if (!this.checked) {
                    // Update checked when the value changed to match the radio group's value
                    this.checked = isEqual(this._radioButtonGroup.value, value);
                    if (this.checked) {
                        this._radioButtonGroup._selectedRadioButton = this;
                    }
                }
            }
        }
    }
    /**
     * Input [checked] attribute
     * @docs-default
     */
    get checked() {
        return this._checked;
    }
    set checked(value) {
        const newCheckedState = Boolean(value);
        if (this._checked !== newCheckedState) {
            this._checked = newCheckedState;
        }
    }
    /**
     * When present, it specifies that the element should be disabled
     * @docs-default false
     */
    get disabled() {
        return this._disabled || (this._radioButtonGroup && this._radioButtonGroup.disabled);
    }
    set disabled(value) {
        this._disabled = Boolean(value);
    }
    ngOnInit() {
        // Create the uniq ID of control
        this._uniqId = `${this._controlName}-${radioUniqueId++}`;
        // Force setter to be called in case id was not specified.
        // TODO: refactor self-assignment
        /* eslint-disable */
        this.id = this.id;
        /* eslint-enable */
        if (this._radioButtonGroup) {
            // If the radio is inside a radio group, determine if it should be checked
            this.checked = this._radioButtonGroup.value === this._value;
            // Copy name from parent radio group
            this.name = this._radioButtonGroup.name;
        }
    }
    ngOnChanges(changes) {
        // Check if input[type=radio] is checked initially
        if (changes.checked && changes.checked.currentValue === true && changes.checked.firstChange) {
            this._ngZone.onStable
                .pipe(takeUntil(this._destroyed$), take(1))
                .subscribe(() => {
                if (this._radioButtonGroup && !isEqual(this._radioButtonGroup.value, this.value)) {
                    this._radioButtonGroup._selectedRadioButton = this;
                    this._radioButtonGroup.value = this.value;
                    this._radioButtonGroup.propagateChange();
                }
            });
        }
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    /**
     * AriaChecked attribute getter
     */
    get getAriaChecked() {
        return this.checked ? 'true' : 'false';
    }
    get readonly() {
        return this._radioButtonGroup ? this._radioButtonGroup.readonly : false;
    }
    /**
     * Input (change) event handler
     */
    inputChangeHandler(event) {
        event.stopPropagation();
        if (this.disabled || this.readonly) {
            event.preventDefault();
        }
        else {
            this.checked = true;
            if (this._radioButtonGroup) {
                this._radioButtonGroup.value = this.value;
                this._radioButtonGroup.propagateChange();
            }
        }
        this.checkedChange.emit(true);
        this._adaptRadarService.sendCustomEventForAllProviders(AdaptRadarAngularCustomEventName.AdaptRxRadiobutton, {
            GroupName: this.adaptRadarGroupName,
            EventType: AdaptRadarAngularCustomEventType.Click,
            Label: this.label,
            CurrentState: this.checked ? 'on' : 'off',
            Disabled: this.disabled,
            ReadOnly: this.readonly,
            RadioGroup: !!this._radioButtonGroup
        });
    }
    /**
     * Input (click) event handler
     */
    inputClickHandler(event) {
        if (this.disabled || this.readonly) {
            event.preventDefault();
        }
    }
    /**
     * Input (focus) event handler
     */
    inputFocusHandler(event) {
        if (this._radioButtonGroup) {
            this._radioButtonGroup.focusHandler(event);
        }
        this.onFocus.emit(event);
    }
    /**
     * Input (blur) event handler
     */
    inputBlurHandler(event) {
        if (this._radioButtonGroup) {
            this._radioButtonGroup.markAsTouched();
            this._radioButtonGroup.blurHandler(event);
        }
        this.onBlur.emit(event);
    }
}
AdaptRxRadiobuttonComponent.ɵfac = function AdaptRxRadiobuttonComponent_Factory(t) { return new (t || AdaptRxRadiobuttonComponent)(i0.ɵɵdirectiveInject(i1.AdaptRxRadiobuttonGroupComponent, 8), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRxRadiobuttonComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxRadiobuttonComponent, selectors: [["adapt-rx-radiobutton"]], viewQuery: function AdaptRxRadiobuttonComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputRef = _t.first);
    } }, inputs: { name: "name", label: "label", id: "id", value: "value", checked: "checked", disabled: "disabled", ariaLabel: "ariaLabel", ariaLabeledBy: "ariaLabeledBy", ariaDescribedBy: "ariaDescribedBy", testID: "testID", tabIndex: "tabIndex" }, outputs: { onFocus: "onFocus", onBlur: "onBlur", checkedChange: "checkedChange" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 17, vars: 20, consts: [[1, "radio"], [1, "radio__label"], ["type", "radio", "role", "radio", 3, "id", "disabled", "readOnly", "checked", "change", "click", "focus", "blur"], ["inputRef", ""], [1, "radio__item", 3, "ngClass"], ["class", "text-url-break-out", 4, "ngIf"], [1, "text-url-break-out"]], template: function AdaptRxRadiobuttonComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelementStart(2, "div", 1);
        i0.ɵɵtext(3, "\n    ");
        i0.ɵɵelementStart(4, "span");
        i0.ɵɵtext(5, "\n      ");
        i0.ɵɵelementStart(6, "input", 2, 3);
        i0.ɵɵlistener("change", function AdaptRxRadiobuttonComponent_Template_input_change_6_listener($event) { return ctx.inputChangeHandler($event); })("click", function AdaptRxRadiobuttonComponent_Template_input_click_6_listener($event) { return ctx.inputClickHandler($event); })("focus", function AdaptRxRadiobuttonComponent_Template_input_focus_6_listener($event) { return ctx.inputFocusHandler($event); })("blur", function AdaptRxRadiobuttonComponent_Template_input_blur_6_listener($event) { return ctx.inputBlurHandler($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n      ");
        i0.ɵɵelementStart(9, "label", 4);
        i0.ɵɵtext(10, "\n        ");
        i0.ɵɵtemplate(11, AdaptRxRadiobuttonComponent_span_11_Template, 2, 1, "span", 5);
        i0.ɵɵtext(12, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(14, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(15, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n");
    } if (rf & 2) {
        i0.ɵɵclassProp("readonly", ctx.readonly);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("id", ctx.id)("disabled", ctx.disabled)("readOnly", ctx.readonly)("checked", ctx.checked);
        i0.ɵɵattribute("name", ctx.name)("value", ctx.value)("aria-checked", ctx.getAriaChecked)("aria-readonly", ctx.readonly)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabeledBy)("aria-describedby", ctx.ariaDescribedBy)("tabindex", ctx.tabIndex)("data-testid", ctx.testID);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(18, _c1, !ctx.label));
        i0.ɵɵattribute("for", ctx.id);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.label);
    } }, directives: [i3.NgClass, i3.NgIf], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxRadiobuttonComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-radiobutton',
                templateUrl: './adapt-rx-radiobutton.component.html'
            }]
    }], function () { return [{ type: i1.AdaptRxRadiobuttonGroupComponent, decorators: [{
                type: Optional
            }] }, { type: i0.NgZone }, { type: i2.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { name: [{
            type: Input
        }], label: [{
            type: Input
        }], id: [{
            type: Input
        }], value: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaLabeledBy: [{
            type: Input
        }], ariaDescribedBy: [{
            type: Input
        }], testID: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], onFocus: [{
            type: Output
        }], onBlur: [{
            type: Output
        }], checkedChange: [{
            type: Output
        }], inputRef: [{
            type: ViewChild,
            args: ['inputRef', { static: true }]
        }] }); })();
//# sourceMappingURL=adapt-rx-radiobutton.component.js.map