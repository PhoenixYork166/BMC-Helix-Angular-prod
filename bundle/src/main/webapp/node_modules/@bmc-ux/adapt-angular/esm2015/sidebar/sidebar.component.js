import { ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Input, NgZone, Output, QueryList, Renderer2, ViewChild, ViewEncapsulation } from '@angular/core';
import { take, takeUntil } from 'rxjs/operators';
import { ReplaySubject } from 'rxjs';
import { AdaptSidebarItemComponent } from './sidebar-item/sidebar-item.component';
import { AdaptSidebarColumnComponent } from './sidebar-column/sidebar-column.component';
import { AdaptSidebarService } from './services/sidebar.service';
import { elWidthWithMargin, isUndefined } from '../common/utilities';
import { Directionality } from '@angular/cdk/bidi';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "./services/sidebar.service";
import * as i2 from "@angular/cdk/bidi";
import * as i3 from "../common/radar/adapt-radar";
import * as i4 from "@angular/common";
import * as i5 from "../tooltip/tooltip.directive";
const _c0 = ["main"];
const _c1 = ["nav"];
const _c2 = ["panel"];
const _c3 = ["nav2"];
const _c4 = ["panel2"];
function AdaptSidebarComponent_button_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "button", 11);
} if (rf & 2) {
    const tab_r8 = ctx.$implicit;
    const id_r9 = ctx.index;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("active", ctx_r1.selectedId === id_r9);
    i0.ɵɵproperty("ngClass", tab_r8.iconClass)("adaptTooltip", tab_r8.tooltipText)("adaptRadarDisableEventSending", true)("placement", ctx_r1.tooltipPosition);
    i0.ɵɵattribute("data-id", id_r9 + 1)("aria-label", tab_r8.ariaLabel ? tab_r8.ariaLabel : tab_r8.headerTitle);
} }
function AdaptSidebarComponent_div_12_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 12);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵprojection(2, 1);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} }
function AdaptSidebarComponent_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵprojection(1, 2);
    i0.ɵɵtext(2, "\n        ");
} }
function AdaptSidebarComponent_ng_container_24_button_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "button", 11);
} if (rf & 2) {
    const tab_r13 = ctx.$implicit;
    const id_r14 = ctx.index;
    const ctx_r11 = i0.ɵɵnextContext(2);
    i0.ɵɵclassProp("active", ctx_r11.selectedId2 === ctx_r11.tabs.length + id_r14);
    i0.ɵɵproperty("ngClass", tab_r13.iconClass)("adaptTooltip", tab_r13.tooltipText)("adaptRadarDisableEventSending", true)("placement", ctx_r11.tooltipPosition === "left" ? "right" : "left");
    i0.ɵɵattribute("data-id", ctx_r11.tabs.length + id_r14 + 1)("aria-label", tab_r13.ariaLabel ? tab_r13.ariaLabel : tab_r13.headerTitle);
} }
const _c5 = function (a0) { return { navClassName: a0 }; };
const _c6 = function (a0) { return { "opened": a0 }; };
function AdaptSidebarComponent_ng_container_24_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "div", 1, 13);
    i0.ɵɵlistener("click", function AdaptSidebarComponent_ng_container_24_Template_div_click_2_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(); return ctx_r15.clickNav($event); });
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵtemplate(5, AdaptSidebarComponent_ng_container_24_button_5_Template, 1, 8, "button", 3);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementStart(8, "div", 4, 14);
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵprojection(11, 3);
    i0.ɵɵtext(12, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵclassMapInterpolate1("adapt-sidebar-nav ", "adapt-sidebar-nav__" + ctx_r7.getOppositePosition(), "");
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(9, _c5, ctx_r7.navClassName));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", ctx_r7.tabs2);
    i0.ɵɵadvance(3);
    i0.ɵɵclassMapInterpolate1("adapt-sidebar-panels ", "adapt-sidebar-panels__" + ctx_r7.getOppositePosition(), "");
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(11, _c6, ctx_r7.isPanel2Opened));
} }
const _c7 = [[["", 8, "main"]], [["adapt-sidebar-item"]], [["adapt-sidebar-column", "position", "left"]], [["adapt-sidebar-column", "position", "right"]]];
const _c8 = function (a0, a1, a2, a3, a4) { return { className: a0, "light": a1, "dark": a2, "right": a3, "opened": a4 }; };
const _c9 = function (a0) { return { "adapt-sidebar-main--transition": a0 }; };
const _c10 = [".main", "adapt-sidebar-item", "adapt-sidebar-column[position='left']", "adapt-sidebar-column[position='right']"];
export class AdaptSidebarComponent extends AdaptRadarAngularGenericDirective {
    constructor(_service, _renderer, _dir, _changeDetectorRef, _ngZone, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptSidebar);
        this._service = _service;
        this._renderer = _renderer;
        this._dir = _dir;
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this.pWidth = 300;
        this.isRTL = false;
        this.tooltipPosition = 'left';
        this.tabs = [];
        this.tabs2 = [];
        this.isPanelOpened = false;
        this.isPanel2Opened = false;
        this.firstCheck = true;
        /**
         * Destroy subject
         */
        this.destroy$ = new ReplaySubject(1);
        /**
         * Sets the width for the slipping panel
         * @docs-default 300px
         */
        this.panelWidth = `${this.pWidth}px`;
        /**
         * Sets the width for the second slipping panel
         * @docs-default 300px
         */
        this.panel2Width = `${this.pWidth}px`;
        /**
         * Defines the side where the navigation element would be placed to. Available options - 'left', 'right'
         * @docs-default left
         */
        this.position = 'left';
        /**
         * Defines the color scheme would be applied. Available options - 'light', 'dark'
         * @docs-default light
         */
        this.theme = 'light';
        /**
         * The minimum width of main block with data in px
         * @docs-default 100
         */
        this.widthLimit = 100;
        /**
         * Allows main container dynamically adjust content to the width
         * @docs-default false
         */
        this.adjustMainContainerWidth = false;
        /**
         * An event fires when id for opened panel changed
         */
        this.openedIdChange = new EventEmitter();
        /**
         * An event fires when the panel is either opened or closed and return an object containing 2 properties, panel id as integer and isPanelOpened as boolean
         */
        this.isPanelOpenedCurrently = new EventEmitter();
        this._navWidth = 55;
        this._service.closePanel.subscribe((id) => {
            if (id >= this.tabs.length) {
                this.closePanel(this.panel2);
            }
            else {
                this.closePanel(this.panel);
            }
        });
    }
    set selectedId(id) {
        if (!isUndefined(id) && id !== this._selectedId) {
            this._selectedId = id;
            this.firstCheck = this.openedId === id;
        }
    }
    get selectedId() {
        return this._selectedId;
    }
    set selectedId2(id) {
        if (!isUndefined(id) && id !== this._selectedId2) {
            this._selectedId2 = id;
            this.firstCheck = this.openedId === id;
        }
    }
    get selectedId2() {
        return this._selectedId2;
    }
    ngOnInit() {
        this.isRTL = this._dir.value === 'rtl';
        if (this.isRTL) {
            this.tooltipPosition = this.position;
        }
        else {
            this.tooltipPosition = this.position === 'left' ? 'right' : 'left';
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        //For open panel2
        this._changeDetectorRef.detectChanges();
        this._ngZone.onStable
            .pipe(takeUntil(this.destroy$), take(1))
            .subscribe(() => {
            if (!isUndefined(this.openedId)) {
                this.openPanel(this.openedId);
            }
        });
    }
    ngAfterContentInit() {
        if (this.columnPanels && this.columnPanels.length) {
            this._service.initColumnsPanels(this.columnPanels);
            const tabs = this.columnPanels.map(column => this._configureTabs(column.panels));
            this.tabs = tabs[0];
            this.tabs2 = tabs[1];
        }
        else {
            this._service.initPanels(this.panels);
            this.tabs = this._configureTabs(this.panels);
        }
    }
    ngOnChanges(changes) {
        var _a;
        if (changes.position && changes.position.currentValue !== changes.position.previousValue && ((_a = this.main) === null || _a === void 0 ? void 0 : _a.nativeElement)) {
            this._updatePanelStyles(this.main.nativeElement.getBoundingClientRect().width, this.panel);
            this._setMainContainerStyles(this.isPanelOpened ? this.panelWidth : '0px', this.nav);
            if (this.panel2 && this.nav2) {
                this._updatePanelStyles(this.main.nativeElement.getBoundingClientRect().width, this.panel2);
                this._setMainContainerStyles(this.isPanel2Opened ? this.panel2Width : '0px', this.nav2);
            }
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
    clickNav({ target }) {
        const dataIdAttr = target.getAttribute('data-id');
        if (!dataIdAttr) {
            return;
        }
        const targetId = parseInt(dataIdAttr, 10) - 1;
        // if the target panel is already opened it should be closed
        // if the target panel is panel2
        if (targetId >= this.tabs.length) {
            if (this.isPanel2Opened && targetId === this.selectedId2) {
                this.closePanel(this.panel2);
                return;
            }
        }
        else {
            if (this.isPanelOpened && targetId === this.selectedId) {
                this.closePanel(this.panel);
                return;
            }
        }
        this.openPanel(targetId);
    }
    closePanel(panel) {
        if (panel) {
            const isPanel2 = panel === this.panel2;
            if (isPanel2) {
                this.isPanel2Opened = false;
                this.selectedId2 = null;
            }
            else {
                this.isPanelOpened = false;
                this.selectedId = null;
            }
            const interactPanelData = this._getInteractPanelData(panel);
            this._setMainContainerStyles('0px', interactPanelData.nav);
            this._setStyles(panel.nativeElement, {
                [interactPanelData.position]: '0'
            });
        }
        else if (this.panel2) { // Close panel and panel2 if the panel2 is exist
            this._closeAllPanels();
        }
        else { // Close default panel
            this.isPanelOpened = false;
            this.selectedId = null;
            this._setMainContainerStyles('0px', this.nav);
            this._setStyles(this.panel.nativeElement, {
                [this.getCurrentPosition()]: '0'
            });
        }
        this.isPanelOpenedCurrently.emit({
            id: this.selectedId,
            id2: this.selectedId2,
            isPanelOpened: this.isPanelOpened,
            isPanel2Opened: this.isPanel2Opened
        });
    }
    openPanel(id) {
        const mainWidth = this.main.nativeElement.getBoundingClientRect().width;
        if (id >= this.tabs.length && this.tabs2.length) {
            this.selectedTabHeaderTitle = this.tabs2[id - this.tabs.length].headerTitle;
            this._service.selectPanel2(id);
            this.selectedId2 = id;
            this._updatePanelStyles(mainWidth, this.panel2);
            this.isPanel2Opened = true;
        }
        else {
            this.selectedTabHeaderTitle = this.tabs[id].headerTitle;
            this._service.selectPanel(id);
            this.selectedId = id;
            this._updatePanelStyles(mainWidth, this.panel);
            this.isPanelOpened = true;
        }
        this.openedIdChange.emit(id);
        this.isPanelOpenedCurrently.emit({
            id: this.selectedId,
            id2: this.selectedId2,
            isPanelOpened: this.isPanelOpened,
            isPanel2Opened: this.isPanel2Opened
        });
    }
    getCurrentPosition() {
        if (this.isRTL) {
            return this.position === 'left' ? 'right' : 'left';
        }
        return this.position;
    }
    getOppositePosition() {
        return this.getCurrentPosition() === 'left' ? 'right' : 'left';
    }
    _configureTabs(panels) {
        panels.forEach(panel => {
            panel.theme = this.theme;
        });
        return panels.toArray();
    }
    _updatePanelStyles(mainWidth, panel) {
        const interactPanelData = this._getInteractPanelData(panel);
        const oppositePanelData = this._getOppositePanelData(panel);
        let fullOpenOppositePanel = false;
        // Interaction panel should be open using the entire space if the opposite panel is open and occupies >= mainWidth
        if (oppositePanelData.panel) {
            const currentOppositePanelWidth = oppositePanelData.panel.nativeElement.getBoundingClientRect().width;
            const takeMainWidthOppositePanel = currentOppositePanelWidth === mainWidth + 1;
            fullOpenOppositePanel = takeMainWidthOppositePanel && oppositePanelData.isOpened;
        }
        if (mainWidth > this.widthLimit + parseInt(interactPanelData.panelWidth, 10) && !fullOpenOppositePanel) {
            this._setMainContainerStyles(interactPanelData.panelWidth, interactPanelData.nav, oppositePanelData.panelWidth);
            this._setStyles(panel.nativeElement, {
                width: interactPanelData.panelWidth
            });
        }
        else {
            if (!interactPanelData.isOpened) {
                this._setStyles(panel.nativeElement, {
                    width: `${mainWidth + 1}px`
                });
            }
        }
        this._setStyles(panel.nativeElement, {
            [interactPanelData.position === 'left' ? 'right' : 'left']: 'auto',
            [interactPanelData.position]: `${this._navWidth}px`
        });
    }
    _setMainContainerStyles(panelWidth, nav, oppositePanelWidth) {
        const isNav2 = nav === this.nav2;
        const isOpenedOppositePanel = isNav2 ? this.isPanelOpened : this.isPanel2Opened;
        const position = isNav2 ? this.getOppositePosition() : this.getCurrentPosition();
        if (isOpenedOppositePanel && panelWidth === '0px') {
            this._setStyles(this.main.nativeElement, {
                [`margin-${position === 'left' ? 'right' : 'left'}`]: oppositePanelWidth,
                [`margin-${position}`]: panelWidth,
                width: this.adjustMainContainerWidth ?
                    `calc(100% - ${parseFloat(panelWidth) + elWidthWithMargin(nav.nativeElement)}px)` :
                    null,
            });
        }
        else {
            this._setStyles(this.main.nativeElement, {
                [`margin-${position === 'left' ? 'right' : 'left'}`]: isOpenedOppositePanel ? oppositePanelWidth : 'auto',
                [`margin-${position}`]: panelWidth,
                width: this.adjustMainContainerWidth ?
                    `calc(100% - ${parseFloat(panelWidth) + elWidthWithMargin(nav.nativeElement)}px)` :
                    null,
            });
        }
    }
    _closeAllPanels() {
        this._setMainContainerStyles('0px', this.nav, '0px');
        this.isPanelOpened = false;
        this.selectedId = null;
        this.isPanel2Opened = false;
        this.selectedId2 = null;
        this._setStyles(this.panel.nativeElement, {
            [this.getCurrentPosition()]: '0'
        });
        this._setStyles(this.panel2.nativeElement, {
            [this.getOppositePosition()]: '0'
        });
    }
    _setStyles(el, styles) {
        const keys = Object.keys(styles);
        keys.forEach(name => {
            this._renderer.setStyle(el, name, styles[name]);
        });
    }
    _getInteractPanelData(panel) {
        const isPanel = panel === this.panel;
        return {
            panel,
            isOpened: isPanel ? this.isPanelOpened : this.isPanel2Opened,
            position: isPanel ? this.getCurrentPosition() : this.getOppositePosition(),
            nav: isPanel ? this.nav : this.nav2,
            panelWidth: isPanel ? this.panelWidth : this.panel2Width
        };
    }
    _getOppositePanelData(panel) {
        const oppositePanel = panel === this.panel ? this.panel2 : this.panel;
        return this._getInteractPanelData(oppositePanel);
    }
}
AdaptSidebarComponent.ɵfac = function AdaptSidebarComponent_Factory(t) { return new (t || AdaptSidebarComponent)(i0.ɵɵdirectiveInject(i1.AdaptSidebarService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i2.Directionality), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptSidebarComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSidebarComponent, selectors: [["adapt-sidebar"]], contentQueries: function AdaptSidebarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, AdaptSidebarItemComponent, 4);
        i0.ɵɵcontentQuery(dirIndex, AdaptSidebarColumnComponent, 4);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panels = _t);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.columnPanels = _t);
    } }, viewQuery: function AdaptSidebarComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 7);
        i0.ɵɵviewQuery(_c3, 5);
        i0.ɵɵviewQuery(_c4, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.main = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nav = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panel = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nav2 = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panel2 = _t.first);
    } }, inputs: { className: "className", navClassName: "navClassName", panelWidth: "panelWidth", panel2Width: "panel2Width", position: "position", theme: "theme", widthLimit: "widthLimit", openedId: "openedId", adjustMainContainerWidth: "adjustMainContainerWidth" }, outputs: { openedIdChange: "openedIdChange", isPanelOpenedCurrently: "isPanelOpenedCurrently" }, exportAs: ["adaptSidebar"], features: [i0.ɵɵProvidersFeature([AdaptSidebarService]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c10, decls: 26, vars: 26, consts: [[1, "adapt-sidebar-wrapper", 3, "ngClass"], [3, "ngClass", "click"], ["nav", ""], ["class", "adapt-sidebar-nav-btn", "role", "button", "type", "button", 3, "active", "ngClass", "adaptTooltip", "adaptRadarDisableEventSending", "placement", 4, "ngFor", "ngForOf"], [3, "ngClass"], ["panel", ""], ["class", "adapt-sidebar-items", 4, "ngIf", "ngIfElse"], ["columnPanel", ""], [1, "adapt-sidebar-main", 3, "ngClass"], ["main", ""], [4, "ngIf"], ["role", "button", "type", "button", 1, "adapt-sidebar-nav-btn", 3, "ngClass", "adaptTooltip", "adaptRadarDisableEventSending", "placement"], [1, "adapt-sidebar-items"], ["nav2", ""], ["panel2", ""]], template: function AdaptSidebarComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c7);
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵelementStart(3, "div", 1, 2);
        i0.ɵɵlistener("click", function AdaptSidebarComponent_Template_div_click_3_listener($event) { return ctx.clickNav($event); });
        i0.ɵɵtext(5, "\n        ");
        i0.ɵɵtemplate(6, AdaptSidebarComponent_button_6_Template, 1, 8, "button", 3);
        i0.ɵɵtext(7, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n      ");
        i0.ɵɵelementStart(9, "div", 4, 5);
        i0.ɵɵtext(11, "\n        ");
        i0.ɵɵtemplate(12, AdaptSidebarComponent_div_12_Template, 4, 0, "div", 6);
        i0.ɵɵtext(13, "\n        ");
        i0.ɵɵtemplate(14, AdaptSidebarComponent_ng_template_14_Template, 3, 0, "ng-template", null, 7, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n      ");
        i0.ɵɵelementStart(18, "div", 8, 9);
        i0.ɵɵtext(20, "\n        ");
        i0.ɵɵprojection(21);
        i0.ɵɵtext(22, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(23, "\n      ");
        i0.ɵɵtemplate(24, AdaptSidebarComponent_ng_container_24_Template, 14, 13, "ng-container", 10);
        i0.ɵɵtext(25, "\n    ");
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r4 = i0.ɵɵreference(15);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction5(14, _c8, ctx.className, ctx.theme === "light", ctx.theme === "dark", ctx.position === "right", ctx.isPanelOpened || ctx.isPanel2Opened));
        i0.ɵɵadvance(2);
        i0.ɵɵclassMapInterpolate1("adapt-sidebar-nav ", "adapt-sidebar-nav__" + ctx.getCurrentPosition(), "");
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(20, _c5, ctx.navClassName));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngForOf", ctx.tabs);
        i0.ɵɵadvance(3);
        i0.ɵɵclassMapInterpolate1("adapt-sidebar-panels ", "adapt-sidebar-panels__" + ctx.getCurrentPosition(), "");
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(22, _c6, ctx.isPanelOpened));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", !(ctx.columnPanels == null ? null : ctx.columnPanels.length))("ngIfElse", _r4);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(24, _c9, !ctx.firstCheck));
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", ctx.tabs2.length);
    } }, directives: [i4.NgClass, i4.NgForOf, i4.NgIf, i5.AdaptTooltipDirective], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSidebarComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-sidebar',
                exportAs: 'adaptSidebar',
                encapsulation: ViewEncapsulation.None,
                providers: [AdaptSidebarService],
                template: `
    <div class="adapt-sidebar-wrapper"
         [ngClass]="{className: className, 'light': theme === 'light', 'dark': theme === 'dark', 'right': position === 'right','opened': isPanelOpened || isPanel2Opened}">
      <div #nav class="adapt-sidebar-nav {{'adapt-sidebar-nav__' + getCurrentPosition()}}"
           [ngClass]="{navClassName: navClassName}"
           (click)="clickNav($event)">
        <button *ngFor="let tab of tabs; let id = index;"
                [attr.data-id]="id + 1"
                class="adapt-sidebar-nav-btn"
                [class.active]="selectedId === id"
                [ngClass]="tab.iconClass"
                role="button"
                type="button"
                [attr.aria-label]="tab.ariaLabel ? tab.ariaLabel : tab.headerTitle"
                [adaptTooltip]="tab.tooltipText"
                [adaptRadarDisableEventSending]="true"
                [placement]="tooltipPosition"></button>
      </div>

      <div #panel class="adapt-sidebar-panels {{'adapt-sidebar-panels__' + getCurrentPosition()}}"
           [ngClass]="{'opened': isPanelOpened}">
        <div *ngIf="!columnPanels?.length;else columnPanel" class="adapt-sidebar-items">
          <ng-content select="adapt-sidebar-item"></ng-content>
        </div>
        <ng-template #columnPanel>
          <ng-content select="adapt-sidebar-column[position='left']"></ng-content>
        </ng-template>
      </div>
      <div #main class="adapt-sidebar-main" [ngClass]="{'adapt-sidebar-main--transition': !firstCheck}">
        <ng-content select=".main"></ng-content>
      </div>
      <ng-container *ngIf="tabs2.length">
        <div #nav2
             class="adapt-sidebar-nav {{'adapt-sidebar-nav__' + getOppositePosition()}}"
             [ngClass]="{navClassName: navClassName}"
             (click)="clickNav($event)">
          <button *ngFor="let tab of tabs2; let id = index;"
                  [attr.data-id]="tabs.length + id + 1"
                  class="adapt-sidebar-nav-btn"
                  [class.active]="selectedId2 === tabs.length + id"
                  [ngClass]="tab.iconClass"
                  role="button"
                  type="button"
                  [attr.aria-label]="tab.ariaLabel ? tab.ariaLabel : tab.headerTitle"
                  [adaptTooltip]="tab.tooltipText"
                  [adaptRadarDisableEventSending]="true"
                  [placement]="tooltipPosition === 'left' ? 'right': 'left'"></button>
        </div>
        <div class="adapt-sidebar-panels {{'adapt-sidebar-panels__' + getOppositePosition()}}"
             [ngClass]="{'opened': isPanel2Opened}"
             #panel2>
          <ng-content select="adapt-sidebar-column[position='right']"></ng-content>
        </div>
      </ng-container>
    </div>`
            }]
    }], function () { return [{ type: i1.AdaptSidebarService }, { type: i0.Renderer2 }, { type: i2.Directionality }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i3.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { className: [{
            type: Input
        }], navClassName: [{
            type: Input
        }], panelWidth: [{
            type: Input
        }], panel2Width: [{
            type: Input
        }], position: [{
            type: Input
        }], theme: [{
            type: Input
        }], widthLimit: [{
            type: Input
        }], openedId: [{
            type: Input
        }], adjustMainContainerWidth: [{
            type: Input
        }], openedIdChange: [{
            type: Output
        }], isPanelOpenedCurrently: [{
            type: Output
        }], panels: [{
            type: ContentChildren,
            args: [AdaptSidebarItemComponent]
        }], columnPanels: [{
            type: ContentChildren,
            args: [AdaptSidebarColumnComponent]
        }], main: [{
            type: ViewChild,
            args: ['main', { static: true }]
        }], nav: [{
            type: ViewChild,
            args: ['nav', { static: true }]
        }], panel: [{
            type: ViewChild,
            args: ['panel', { static: true }]
        }], nav2: [{
            type: ViewChild,
            args: ['nav2', { static: false }]
        }], panel2: [{
            type: ViewChild,
            args: ['panel2', { static: false }]
        }] }); })();
//# sourceMappingURL=sidebar.component.js.map