import { ChangeDetectorRef, Component, ElementRef, EventEmitter, HostBinding, Injector, Input, NgZone, Output, QueryList, Renderer2, TemplateRef, ViewChild, ViewChildren, ViewEncapsulation } from '@angular/core';
import { animate, animateChild, keyframes, query, style, transition, trigger, useAnimation } from '@angular/animations';
import { BACKSPACE, ENTER, TAB } from '@angular/cdk/keycodes';
import { merge, of, ReplaySubject } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import { isEqual, isNil, uniq } from 'lodash-es';
import { ANIMATION_NAME } from '../common/animation';
import { AdaptDeviceDetectionService } from '../common/device-detection.service';
import { AdaptTranslateService } from '../common/i18n/index';
import { createFormControlValidator, createFormControlValueAccessor, FormComponent } from '../common/form.component';
import { SafeCdr } from '../common/safe-cdr';
import { AdaptTruncatePipe } from '../common/truncated.pipe';
import { getEventKeyCode } from '../common/key-codes';
import { getValueOrFunc, hasShrunkText } from '../common/utilities';
import { AdaptRxTypeaheadComponent } from '../rx/rx-typeahead/index';
import { TagAddingSource } from './metatag.types';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import { ColorUtils } from '../common/color.utils';
import * as i0 from "@angular/core";
import * as i1 from "../common/truncated.pipe";
import * as i2 from "../common/device-detection.service";
import * as i3 from "../common/i18n/index";
import * as i4 from "../common/radar/adapt-radar";
import * as i5 from "@angular/common";
import * as i6 from "../rx/form-control/rx-control-label/adapt-rx-control-label.component";
import * as i7 from "../rx/rx-typeahead/adapt-rx-typeahead.component";
import * as i8 from "@angular/forms";
import * as i9 from "../tooltip/tooltip.directive";
const _c0 = ["adaptRxTypeaheadComponent"];
const _c1 = ["inputWrp"];
const _c2 = ["container"];
const _c3 = ["metatag"];
const _c4 = ["tagItem"];
const _c5 = ["tagItemWrp"];
function AdaptMetatagComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0);
} if (rf & 2) {
    const tag_r11 = ctx.tag;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵtextInterpolate(ctx_r1.getTruncatedTagModel(tag_r11).value);
} }
function AdaptMetatagComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 17);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r3.prefix);
} }
function AdaptMetatagComponent_div_20_a_6_Template(rf, ctx) { if (rf & 1) {
    const _r23 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "a", 28);
    i0.ɵɵlistener("click", function AdaptMetatagComponent_div_20_a_6_Template_a_click_0_listener($event) { i0.ɵɵrestoreView(_r23); const i_r13 = i0.ɵɵnextContext().index; const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.removeItem($event, i_r13, true); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r12 = i0.ɵɵnextContext().$implicit;
    const ctx_r16 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("close-inverse", !(ctx_r16.warningCheck(item_r12) && !ctx_r16.errorCheck(item_r12) && !ctx_r16.isAllWarnings));
    i0.ɵɵattribute("aria-label", ctx_r16.getRemoveTagBtnText(item_r12));
} }
function AdaptMetatagComponent_div_20_span_11_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 29);
} }
function AdaptMetatagComponent_div_20_span_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 30);
} }
function AdaptMetatagComponent_div_20_ng_template_15_Template(rf, ctx) { }
const _c6 = function (a0) { return { "is-mobile": a0 }; };
const _c7 = function (a0, a1) { return { tag: a0, index: a1 }; };
function AdaptMetatagComponent_div_20_Template(rf, ctx) { if (rf & 1) {
    const _r26 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 18, 19);
    i0.ɵɵlistener("dblclick", function AdaptMetatagComponent_div_20_Template_div_dblclick_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r26); const i_r13 = restoredCtx.index; const ctx_r25 = i0.ɵɵnextContext(); return ctx_r25.itemDblClick(i_r13); })("click", function AdaptMetatagComponent_div_20_Template_div_click_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r26); const i_r13 = restoredCtx.index; const ctx_r27 = i0.ɵɵnextContext(); return ctx_r27.itemClick($event, i_r13); })("@tagsListAnimation.done", function AdaptMetatagComponent_div_20_Template_div_animation_tagsListAnimation_done_0_listener($event) { i0.ɵɵrestoreView(_r26); const ctx_r28 = i0.ɵɵnextContext(); return ctx_r28.onTagAnimationDone($event); });
    i0.ɵɵtext(2, "\n          ");
    i0.ɵɵelementStart(3, "div", 20, 21);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵtemplate(6, AdaptMetatagComponent_div_20_a_6_Template, 1, 3, "a", 22);
    i0.ɵɵtext(7, "\n            ");
    i0.ɵɵelementStart(8, "span", 23, 24);
    i0.ɵɵtext(10, "\n              ");
    i0.ɵɵtemplate(11, AdaptMetatagComponent_div_20_span_11_Template, 1, 0, "span", 25);
    i0.ɵɵtext(12, "\n              ");
    i0.ɵɵtemplate(13, AdaptMetatagComponent_div_20_span_13_Template, 1, 0, "span", 26);
    i0.ɵɵtext(14, "\n              ");
    i0.ɵɵtemplate(15, AdaptMetatagComponent_div_20_ng_template_15_Template, 0, 0, "ng-template", 27);
    i0.ɵɵtext(16, "\n\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(17, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r12 = ctx.$implicit;
    const i_r13 = ctx.index;
    const _r17 = i0.ɵɵreference(9);
    const ctx_r5 = i0.ɵɵnextContext();
    const _r0 = i0.ɵɵreference(1);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("adaptTooltip", ctx_r5.getTagTooltipFunc(_r17, item_r12))("ngClass", i0.ɵɵpureFunction1(19, _c6, ctx_r5.isMobile))("@tagsListAnimation", ctx_r5.items.length);
    i0.ɵɵadvance(3);
    i0.ɵɵclassProp("is-active", ctx_r5.isCurrentTagActive(i_r13))("meta-tag-error", ctx_r5.errorCheck(item_r12) || ctx_r5.isAllWarnings)("meta-tag-warning", ctx_r5.warningCheck(item_r12) && !ctx_r5.errorCheck(item_r12) && !ctx_r5.isAllWarnings)("text-default", ctx_r5.warningCheck(item_r12) && !ctx_r5.errorCheck(item_r12) && !ctx_r5.isAllWarnings);
    i0.ɵɵproperty("@tagAnimation", undefined)("ngStyle", ctx_r5.getTagStyle(i_r13, item_r12));
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", !(ctx_r5.disabled || ctx_r5.readonly));
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", ctx_r5.errorCheck(item_r12) || ctx_r5.isAllWarnings);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r5.warningCheck(item_r12) && !ctx_r5.errorCheck(item_r12) && !ctx_r5.isAllWarnings);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r5.tagTemplate || _r0)("ngTemplateOutletContext", i0.ɵɵpureFunction2(21, _c7, item_r12, i_r13));
} }
function AdaptMetatagComponent_div_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 31);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r7.placeholder);
} }
function AdaptMetatagComponent_div_33_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 17);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r9.suffix);
} }
function AdaptMetatagComponent_div_36_p_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 35);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r29 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n      ", ctx_r29.warningStateText || ctx_r29.mainErrorText, "\n    ");
} }
function AdaptMetatagComponent_div_36_ng_template_4_p_1_b_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "b");
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r33 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", error_r33.name, " ");
} }
function AdaptMetatagComponent_div_36_ng_template_4_p_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "p", 35);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptMetatagComponent_div_36_ng_template_4_p_1_b_2_Template, 2, 1, "b", 37);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const error_r33 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", error_r33.name);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("", error_r33.text, "\n      ");
} }
function AdaptMetatagComponent_div_36_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptMetatagComponent_div_36_ng_template_4_p_1_Template, 4, 2, "p", 36);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const ctx_r31 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r31.errors)("ngForTrackBy", ctx_r31.trackByForErrors);
} }
const _c8 = function (a0) { return { "adapt-mt-error": a0 }; };
function AdaptMetatagComponent_div_36_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 32);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptMetatagComponent_div_36_p_2_Template, 2, 1, "p", 33);
    i0.ɵɵtext(3, "\n\n    ");
    i0.ɵɵtemplate(4, AdaptMetatagComponent_div_36_ng_template_4_Template, 3, 2, "ng-template", null, 34, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(6, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r30 = i0.ɵɵreference(5);
    const ctx_r10 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@validationFeedbackAnimation", undefined)("ngClass", i0.ɵɵpureFunction1(4, _c8, ctx_r10.errors.length));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r10.isWarnings && !ctx_r10.isAllWarnings)("ngIfElse", _r30);
} }
const _c9 = function (a0) { return { "use-all-space": a0 }; };
const COMMA_SYMBOL = ',';
let counter = 0;
export function getTagText(tag) {
    return typeof tag === 'string' ? tag : tag.text;
}
export class AdaptMetatagComponent extends FormComponent {
    constructor(_renderer, injector, truncatePipe, _ngZone, _devDetection, _changeDetectorRef, ts, _adaptRadarService, _elem) {
        super(injector, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptMetatag);
        this._renderer = _renderer;
        this.truncatePipe = truncatePipe;
        this._ngZone = _ngZone;
        this._devDetection = _devDetection;
        this._changeDetectorRef = _changeDetectorRef;
        // Need for using inherited properties in the template
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.context = this;
        this.items = [];
        this.isValid = true;
        this.inputValue = '';
        this.getTagText = getTagText;
        this.defaultTexts = {};
        /**
         * Label icon with a tooltip or popover
         */
        this.tooltipConfig = null;
        this.isMobile = false;
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.typeaheadFn = AdaptMetatagComponent.NullSearch;
        /**
         * Destroy subject
         */
        this.destroy$ = new ReplaySubject(1);
        /**
         * The maximum height of input component
         * @docs-default 100
         */
        this.maxHeight = 100;
        /**
         * Manages the ability to create tags by Enter key pressing
         * @docs-default false
         */
        this.suppressManual = false;
        /**
         * Allows to set up the width for the field
         * @docs-default 100%
         */
        this.width = '100%';
        /**
         * When a user inputs this symbol, the component creates new tag
         * @docs-default ,
         */
        this.delimiterSymbol = COMMA_SYMBOL;
        this.selectItemFormatter = this._defaultItemFormatter;
        /**
         * This input controls using full container width for editing tags
         * @docs-default
         * @since v11.11.0
         */
        this.fullWidthEdit = false;
        /* eslint-disable @angular-eslint/no-output-native */
        /**
         * The event firing on field focus
         */
        this.focus = new EventEmitter();
        /**
         * The event firing on field blur
         */
        this.blur = new EventEmitter();
        /* eslint-enable @angular-eslint/no-output-native */
        /**
         * The event firing on tag remove
         */
        this.removeTag = new EventEmitter();
        /**
         * The event firing on tag add
         * @since v12.14.0
         */
        this.addTag = new EventEmitter();
        /**
         * The event firing on tag edit
         */
        this.initTagEditing = new EventEmitter();
        this._isAdded = false;
        this._isEditingTag = false;
        this._activeTabIndex = null;
        this.name = `adapt-mt-${counter}`;
        this.id = `adapt-mt-${counter}`;
        counter++;
        const translation = ts.getCurrentLanguage();
        this.mainErrorText = translation['adapt.tag.mainError'];
        this.placeholder = translation['adapt.tag.placeholder'];
        this.warningStateText = translation['adapt.tag.warningState'];
        this._closeBtnText = translation['adapt.common.remove'];
        this.isMobile = _devDetection.isMobile();
    }
    /**
     * A function to transform the provided observable text into the array of results.
     * Note that the "this" argument is undefined so you need to explicitly bind it to a desired "this" target
     * @docs-default OperatorFunction<string, any[]>
     */
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    set search(searchFn) {
        this._search = searchFn;
        if (this._search) {
            const focus$ = this.focus.pipe(filter(() => this.openDropdownOnFocus), map(e => e.target.value));
            this.typeaheadFn = (text$) => {
                return this._search(merge(text$, focus$));
            };
        }
        else {
            this.typeaheadFn = AdaptMetatagComponent.NullSearch;
        }
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    get search() {
        return this._search;
    }
    get hostClasses() {
        return [
            'adapt-mt-host',
            this.getBaseHostClasses()
        ].join(' ');
    }
    get focused() {
        var _a;
        return ((_a = this.adaptRxTypeaheadComponent) === null || _a === void 0 ? void 0 : _a.inputRef.nativeElement.matches(':focus')) || false;
    }
    get inputSizeAttr() {
        return this.inputValue ? this.inputValue.length : 0;
    }
    get isEmpty() {
        return this.items.length === 0 && !this.inputValue;
    }
    get isWarnings() {
        return this.items.some(item => this.warningCheck(item));
    }
    get hasAllTagsErrors() {
        return this._isLabelError;
    }
    get hasNotAllTagsErrors() {
        return this.isWarnings && !this.hasAllTagsErrors;
    }
    get isAllWarnings() {
        return this.items.length > 0 && this.items.every(item => this.warningCheck(item));
    }
    get _isLabelError() {
        return this.items.some(item => this.errorCheck(item)) || this.isAllWarnings;
    }
    get _isCurrentlyActive() {
        return this.isMobile && this.tagItemList.some(item => item.nativeElement.classList.contains('is-active'));
    }
    get _currentCursorPosition() {
        return [].indexOf.call(this.metatag.nativeElement.children, this.inputWrp.nativeElement);
    }
    set value(v) {
        this._value = v;
    }
    get value() {
        return this._value;
    }
    static NullSearch() {
        return of(null);
    }
    ngOnInit() {
        super.ngOnInit();
        if (!this.errorCheck) {
            this.errorCheck = () => false;
        }
        if (!this.warningCheck) {
            this.warningCheck = () => false;
        }
        if (this.tooltipIconCls && !this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.tooltipIconCls,
                content: this.tooltipText,
                placement: 'top',
                popoverMode: false
            };
        }
        else if (this.popoverIcon) {
            this.tooltipConfig = {
                iconName: this.popoverIcon,
                content: this.popoverContent,
                placement: this.popoverPlacement,
                popoverMode: true,
                popoverTriggers: this.popoverTriggers
            };
        }
    }
    ngAfterContentInit() {
        this._renderer.setStyle(this.container.nativeElement, 'width', this.width);
        this.metatag.nativeElement.style.maxHeight = `${this.maxHeight}px`;
        this._ngZone.runOutsideAngular(() => {
            this._docListenerFn = this._renderer.listen('document', 'click', this._onDocumentClick.bind(this));
        });
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.destroy$.next();
        this.destroy$.complete();
        if (this._docListenerFn) {
            this._docListenerFn();
        }
    }
    writeValue(value) {
        if (value) {
            this.items = this.replaceModelOnWrite ? value.slice() : this.items.concat(value);
        }
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    getContainerClass() {
        const touched = this.control.touched;
        return [
            (touched && this.errors.length) ? 'has-danger' : '',
            (touched && this.hasNotAllTagsErrors) ? 'has-warning' : ''
        ].filter(Boolean);
    }
    getTruncatedTagModel(tag) {
        return this.truncatePipe.truncate(this.getTagText(tag), this.maxTagLength || this.truncateConfig, '...');
    }
    removeItem(event, index, focusOnInputField) {
        let defaultPrevented = false;
        this.removeTag.emit({
            domEvent: event,
            index,
            tag: this.items[index],
            preventDefault: () => defaultPrevented = true
        });
        if (!defaultPrevented) {
            if (index === 0) {
                this._resetInputElem();
            }
            this._activeTabIndex = null;
            this.items.splice(index, 1);
            this.emitModelChange();
            if (focusOnInputField) {
                this.focusOnInputField();
            }
        }
    }
    emitModelChange() {
        this.propagateChange(this._removeDuplicates());
    }
    onKeyDown(event, value) {
        if (this.disabled || this.readonly) {
            return;
        }
        const index = this._currentCursorPosition - 1;
        const eventKeyCode = getEventKeyCode(event);
        if ((eventKeyCode === BACKSPACE) && !value && this.items.length) {
            this.removeItem(event, index, this.isMobile);
            this._onTouchedCallback();
        }
        else if ((eventKeyCode === ENTER || eventKeyCode === TAB) && !this.suppressManual && !this._isAdded && value) {
            event.preventDefault(); // Prevent tabulation if value selected
            this._addTag(value, TagAddingSource.Input);
            if (!this.isMobile) {
                this._resetInputElem();
                this.focusOnInputField();
            }
            this._cleanField();
            this._onTouchedCallback();
        }
        else if (this.isMobile && this.isCurrentTagActive(index) && !value) {
            // some tag item is focused and we are trying to re-write its value by typing a new value
            event.preventDefault();
            this._activeTabIndex = null;
            this._onTagEdit(index, event.key);
        }
        this._isAdded = false;
    }
    onInput(event) {
        const inputValue = this.inputValue = this.adaptRxTypeaheadComponent.inputRef.nativeElement.value;
        let hasAddedTag = false;
        if (this.delimiterSymbol && !this.suppressManual) {
            const values = inputValue.split(this.delimiterSymbol)
                .map(v => v.trim()).filter(v => !!v);
            const delimiterSymbolIndex = inputValue.indexOf(this.delimiterSymbol);
            if (delimiterSymbolIndex >= 0) {
                const metatagIndex = this._currentCursorPosition;
                values.forEach((tag, index) => {
                    this._addTag(tag, TagAddingSource.Input, metatagIndex + index);
                });
                event.preventDefault();
                hasAddedTag = true;
            }
        }
        // if user cleared the input field by the backspace key and was tag editing
        if (!hasAddedTag && !inputValue && this._isEditingTag) {
            this.emitModelChange();
            this._isEditingTag = false;
        }
    }
    onTagAnimationDone(event) {
        // we will wait until animation for the just added tag(s) completes
        // to clean the input field
        if (event.phaseName === 'done' && !this._isEditingTag) {
            this._cleanField();
        }
    }
    isCurrentTagActive(index) {
        return this._activeTabIndex === index;
    }
    getTagTooltipFunc(tagTextContainer, tag) {
        return () => {
            const truncatedContent = this.getTruncatedTagModel(tag);
            return hasShrunkText(tagTextContainer) ?
                truncatedContent.value : (truncatedContent.truncated ? getTagText(tag) : '');
        };
    }
    getRemoveTagBtnText(tag) {
        return `${this._closeBtnText} ${this.getTagText(tag)}`;
    }
    onSelect(event) {
        event.preventDefault();
        this._isAdded = true;
        this._addTag(event.item, TagAddingSource.List);
        this._cleanField();
        if (!this.isMobile && this._currentCursorPosition !== this.items.length - 1) {
            this._resetInputElem();
        }
        this.focusOnInputField();
    }
    onFocus(event) {
        this.focus.emit(event);
    }
    onBlur(event) {
        this.blur.emit(event);
        if (this.suppressManual && !this.adaptRxTypeaheadComponent.popup.isOpen()) {
            this._cleanField();
        }
        if (!this.readonly) {
            this._onTouchedCallback();
        }
    }
    focusOnInputField(options) {
        this.adaptRxTypeaheadComponent.inputRef.nativeElement.focus(options);
    }
    onFieldContainerClick(event) {
        event.stopPropagation();
        if (event.target === this.adaptRxTypeaheadComponent.inputRef.nativeElement) {
            return;
        }
        const options = event.target.closest('.adapt-mt-item-wrapper') ? {
            preventScroll: true
        } : null;
        if (!this._isAdded && this.inputValue && !this.suppressManual) {
            this._addTag(this.inputValue, TagAddingSource.Input);
            this._cleanField();
            SafeCdr.detectChanges(this._changeDetectorRef);
        }
        this._activeTabIndex = null;
        if (this._currentCursorPosition !== this.items.length - 1) {
            this._resetInputElem();
        }
        this.focusOnInputField(options);
    }
    itemDblClick(index) {
        if (this.readonly || this.disabled || this.suppressManual) {
            return;
        }
        index = this._recalculateIndex(index);
        // force change detection to have correct tags position
        SafeCdr.detectChanges(this._changeDetectorRef);
        if (index === this.items.length - 1) {
            this._resetInputElem();
        }
        else {
            // not the last tag - input should be re-placed
            const currentTag = this.tagItemWrpList.toArray()[index].nativeElement;
            const inputWrp = this.metatag.nativeElement.removeChild(this.inputWrp.nativeElement);
            // insert input element before the clicked tag item
            // to take the place of further deleted target tag item
            this.metatag.nativeElement.insertBefore(inputWrp, currentTag);
        }
        this._onTagEdit(index);
    }
    /**
     * Function to handle tag item click on mobile devices
     */
    itemClick(event, index) {
        event.stopPropagation();
        if (!this.isMobile || this.readonly || this.disabled || this.suppressManual) {
            return;
        }
        index = this._recalculateIndex(index);
        // force change detection to have correct tags position
        SafeCdr.detectChanges(this._changeDetectorRef);
        if (this._activeTabIndex === index) {
            // click on active tag
            this._activeTabIndex = null;
            this._onTagEdit(index);
            return;
        }
        if (index !== this.items.length - 1) {
            // not the last tag - input should be re-placed
            const currentTag = this.tagItemWrpList.toArray()[index].nativeElement;
            const inputWrp = this.metatag.nativeElement.removeChild(this.inputWrp.nativeElement);
            // insert input element after the clicked tag item
            // to allow tag item deletion via Backspace key click
            this.metatag.nativeElement.insertBefore(inputWrp, currentTag.nextElementSibling);
        }
        else if (this._activeTabIndex !== this.items.length - 1) {
            this._resetInputElem();
        }
        this._activeTabIndex = index;
        this.focusOnInputField();
    }
    validate() {
        if (this._isLabelError) {
            return {
                tagError: this._customErrorTexts.tagError || {
                    name: '',
                    text: this.mainErrorText
                }
            };
        }
        else {
            return null;
        }
    }
    getInputStyle() {
        return {
            // on mobile we should hide the cursor
            width: this.inputValue
                ? null
                : this.isMobile && this.items.length ? this._isCurrentlyActive ? 0 : '1px' : '2px'
        };
    }
    trackByForErrors(index, error) {
        return error.name || error.text || index;
    }
    trackByForTags(index, item) {
        return item || index;
    }
    getTagStyle(index, item) {
        const tagFormatterParam = {
            index: index,
            tag: item
        };
        const tagStyleConfig = this._getTagStyleConfig(tagFormatterParam);
        const bgColor = tagStyleConfig === null || tagStyleConfig === void 0 ? void 0 : tagStyleConfig.backgroundColor;
        const color = tagStyleConfig === null || tagStyleConfig === void 0 ? void 0 : tagStyleConfig.color;
        if (bgColor && !color) {
            return Object.assign(Object.assign({}, tagStyleConfig), { color: this._getTextColor(bgColor) });
        }
        return tagStyleConfig;
    }
    _recalculateIndex(index) {
        if (!this._isEditingTag) {
            return index;
        }
        this._activeTabIndex = null;
        this._addTag(this.inputValue, TagAddingSource.Input);
        this._cleanField();
        // change index value since we delete a tag once entering edit mode
        return index < this._currentCursorPosition ? index : index + 1;
    }
    _onTagEdit(index, presetTagValue) {
        let defaultPrevented = false;
        const tag = this.items[index];
        this.initTagEditing.emit({
            index,
            tag,
            preventDefault: () => defaultPrevented = true
        });
        if (!defaultPrevented) {
            this.items.splice(index, 1);
            this._isEditingTag = true;
            this._isAdded = false;
            this.inputValue = presetTagValue ? presetTagValue : getTagText(tag);
            // needed to trigger event and show options list
            if (presetTagValue) {
                this.adaptRxTypeaheadComponent.inputRef.nativeElement.value = this.inputValue;
                this.adaptRxTypeaheadComponent.inputRef.nativeElement.dispatchEvent(new Event('input'));
            }
            this.focusOnInputField();
            this.adaptRxTypeaheadComponent.inputRef.nativeElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        }
    }
    _onTouchedCallback() {
        return;
    }
    _removeDuplicates() {
        return uniq(this.items);
    }
    _addTag(value, addingSource, index = this._currentCursorPosition) {
        var _a;
        if (value) {
            if (!this.items.some(item => isEqual(item, value))) {
                let defaultPrevented = false;
                this.addTag.emit({
                    tag: value,
                    preventDefault: () => defaultPrevented = true,
                    addingSource: addingSource
                });
                if (!defaultPrevented) {
                    this.items.splice(index, 0, value);
                    this.emitModelChange();
                }
            }
            this.focusOnInputField();
            (_a = this.adaptRxTypeaheadComponent) === null || _a === void 0 ? void 0 : _a.inputRef.nativeElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        }
    }
    _cleanField() {
        this.inputValue = '';
        this._isEditingTag = false;
    }
    _onDocumentClick(event) {
        const inputEl = this.adaptRxTypeaheadComponent.inputRef;
        if (!isNil(event.target.closest('button.dropdown-item'))) {
            // tag has been added from the suggestion list
            return;
        }
        if (inputEl && inputEl.nativeElement.contains(event.target)) {
            return;
        }
        if (this._isCurrentlyActive || !this.inputValue) {
            this._activeTabIndex = null;
            this._resetInputElem();
        }
        if (!this._isAdded && this.inputValue) {
            if (!this.suppressManual) {
                this._addTag(this.inputValue, TagAddingSource.Input);
                this._cleanField();
                SafeCdr.detectChanges(this._changeDetectorRef);
            }
            this._resetInputElem();
        }
    }
    _resetInputElem() {
        const inputWrp = this.metatag.nativeElement.removeChild(this.inputWrp.nativeElement);
        this.metatag.nativeElement.appendChild(inputWrp);
    }
    _defaultItemFormatter(value) {
        return value ? (typeof value === 'string' ? value : value.text) : '';
    }
    _getTagStyleConfig(tagFormatterParam) {
        return getValueOrFunc(this.tagStyleFormatter, tagFormatterParam) || {};
    }
    _getTextColor(color) {
        const contrastLightResults = ColorUtils.checkContrast('#FFFFFF', color);
        const contrastDarkResults = ColorUtils.checkContrast('#333333', color);
        if (contrastLightResults.ratio > contrastDarkResults.ratio) {
            return '#FFFFFF';
        }
        else if (contrastLightResults.ratio < contrastDarkResults.ratio) {
            return '#333333';
        }
    }
}
AdaptMetatagComponent.ɵfac = function AdaptMetatagComponent_Factory(t) { return new (t || AdaptMetatagComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptTruncatePipe), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.AdaptTranslateService), i0.ɵɵdirectiveInject(i4.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptMetatagComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptMetatagComponent, selectors: [["adapt-metatag"], ["adapt-tag-field"]], viewQuery: function AdaptMetatagComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 5);
        i0.ɵɵviewQuery(_c2, 7);
        i0.ɵɵviewQuery(_c3, 7);
        i0.ɵɵviewQuery(_c4, 5);
        i0.ɵɵviewQuery(_c5, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptRxTypeaheadComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputWrp = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.metatag = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tagItemList = _t);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tagItemWrpList = _t);
    } }, hostVars: 4, hostBindings: function AdaptMetatagComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
        i0.ɵɵclassProp("adapt-mt-focused", ctx.focused);
    } }, inputs: { prefix: "prefix", suffix: "suffix", maxTagLength: "maxTagLength", truncateConfig: "truncateConfig", id: "id", testID: "testID", name: "name", ariaLabel: "ariaLabel", search: "search", maxHeight: "maxHeight", suppressManual: "suppressManual", label: "label", placeholder: "placeholder", mainErrorText: "mainErrorText", warningStateText: "warningStateText", width: "width", errorCheck: "errorCheck", warningCheck: "warningCheck", selectItemTemplate: "selectItemTemplate", tagTemplate: "tagTemplate", replaceModelOnWrite: "replaceModelOnWrite", delimiterSymbol: "delimiterSymbol", popupClass: "popupClass", disabledInput: "disabledInput", openDropdownOnFocus: "openDropdownOnFocus", selectItemFormatter: "selectItemFormatter", fullWidthEdit: "fullWidthEdit", tagStyleFormatter: "tagStyleFormatter" }, outputs: { focus: "focus", blur: "blur", removeTag: "removeTag", addTag: "addTag", initTagEditing: "initTagEditing" }, features: [i0.ɵɵProvidersFeature([
            createFormControlValueAccessor(AdaptMetatagComponent),
            createFormControlValidator(AdaptMetatagComponent)
        ]), i0.ɵɵInheritDefinitionFeature], decls: 39, vars: 40, consts: [["defaultTagTemplate", ""], [1, "adapt-mt-container", "form-group", 3, "ngClass"], ["container", ""], [1, "adapt-mt-label-wrapper"], [3, "for", "label", "requiredLabel", "showRequiredLabel", "tooltip"], [1, "adapt-mt-field-wrapper"], ["class", "adapt-mt-adding", 4, "ngIf"], [1, "adapt-mt-wrapper", 3, "click"], [1, "adapt-mt"], ["metatag", ""], ["placement", "auto", "class", "adapt-mt-item-wrapper", 3, "adaptRadarDisableEventSending", "adaptTooltip", "ngClass", "dblclick", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "adapt-mt-input-container", 3, "ngClass"], ["inputWrp", ""], ["class", "adapt-mt-placeholder", 4, "ngIf"], [1, "adapt-mt-input", 3, "adaptRadarDisableEventSending", "ngStyle", "id", "testID", "disabled", "readonly", "typeahead", "focusFirst", "appendToBody", "ariaLabel", "resultFormatter", "resultTemplate", "popupClass", "popupWidth", "ngModel", "showClearButton", "input", "keydown", "onFocus", "onBlur", "onSelectItem"], ["adaptRxTypeaheadComponent", ""], [3, "ngClass", 4, "ngIf"], [1, "adapt-mt-adding"], ["placement", "auto", 1, "adapt-mt-item-wrapper", 3, "adaptRadarDisableEventSending", "adaptTooltip", "ngClass", "dblclick", "click"], ["tagItemWrp", ""], [1, "adapt-mt-item", 3, "ngStyle"], ["tagItem", ""], ["class", "adapt-mt-item-close close", "href", "javascript:void(0)", 3, "close-inverse", "click", 4, "ngIf"], [1, "adapt-mt-text"], ["tagTextContainer", ""], ["class", "d-icon-exclamation_triangle mr-1", 4, "ngIf"], ["class", "d-icon-exclamation_circle mr-1", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["href", "javascript:void(0)", 1, "adapt-mt-item-close", "close", 3, "click"], [1, "d-icon-exclamation_triangle", "mr-1"], [1, "d-icon-exclamation_circle", "mr-1"], [1, "adapt-mt-placeholder"], [3, "ngClass"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngIf", "ngIfElse"], ["errorsTemplate", ""], [1, "form-control-feedback", "m-0", "pt-1", "pb-2"], ["class", "form-control-feedback m-0 pt-1 pb-2", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"]], template: function AdaptMetatagComponent_Template(rf, ctx) { if (rf & 1) {
        const _r36 = i0.ɵɵgetCurrentView();
        i0.ɵɵtemplate(0, AdaptMetatagComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(2, "\n\n");
        i0.ɵɵelementStart(3, "div", 1, 2);
        i0.ɵɵtext(5, "\n  ");
        i0.ɵɵelementStart(6, "div", 3);
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵelement(8, "adapt-rx-control-label", 4);
        i0.ɵɵtext(9, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(10, "\n\n  ");
        i0.ɵɵelementStart(11, "div", 5);
        i0.ɵɵtext(12, "\n    ");
        i0.ɵɵtemplate(13, AdaptMetatagComponent_div_13_Template, 2, 1, "div", 6);
        i0.ɵɵtext(14, "\n    ");
        i0.ɵɵelementStart(15, "div", 7);
        i0.ɵɵlistener("click", function AdaptMetatagComponent_Template_div_click_15_listener($event) { return ctx.onFieldContainerClick($event); });
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵelementStart(17, "div", 8, 9);
        i0.ɵɵtext(19, "\n        ");
        i0.ɵɵtemplate(20, AdaptMetatagComponent_div_20_Template, 19, 24, "div", 10);
        i0.ɵɵtext(21, "\n        ");
        i0.ɵɵelementStart(22, "div", 11, 12);
        i0.ɵɵtext(24, "\n          ");
        i0.ɵɵtemplate(25, AdaptMetatagComponent_div_25_Template, 2, 1, "div", 13);
        i0.ɵɵtext(26, "\n\n          ");
        i0.ɵɵelementStart(27, "adapt-rx-typeahead", 14, 15);
        i0.ɵɵlistener("input", function AdaptMetatagComponent_Template_adapt_rx_typeahead_input_27_listener($event) { return ctx.onInput($event); })("keydown", function AdaptMetatagComponent_Template_adapt_rx_typeahead_keydown_27_listener($event) { i0.ɵɵrestoreView(_r36); const _r8 = i0.ɵɵreference(28); return ctx.onKeyDown($event, _r8.inputRef.nativeElement.value); })("onFocus", function AdaptMetatagComponent_Template_adapt_rx_typeahead_onFocus_27_listener($event) { return ctx.onFocus($event); })("onBlur", function AdaptMetatagComponent_Template_adapt_rx_typeahead_onBlur_27_listener($event) { return ctx.onBlur($event); })("onSelectItem", function AdaptMetatagComponent_Template_adapt_rx_typeahead_onSelectItem_27_listener($event) { return ctx.onSelect($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(29, "\n        ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(30, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(31, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(32, "\n    ");
        i0.ɵɵtemplate(33, AdaptMetatagComponent_div_33_Template, 2, 1, "div", 6);
        i0.ɵɵtext(34, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(35, "\n\n  ");
        i0.ɵɵtemplate(36, AdaptMetatagComponent_div_36_Template, 7, 6, "div", 16);
        i0.ɵɵtext(37, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(38, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(3);
        i0.ɵɵclassProp("adapt-mt_disabled", ctx.disabled)("adapt-mt_readonly", ctx.readonly);
        i0.ɵɵproperty("ngClass", ctx.getContainerClass());
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltipConfig);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", ctx.prefix);
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("adapt-mt-wrapper_disabled", ctx.disabled);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngForOf", ctx.items)("ngForTrackBy", ctx.trackByForTags);
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("adapt-mt-input-container__empty", !ctx.items.length);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(38, _c9, ctx.fullWidthEdit));
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.isEmpty);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("ngStyle", ctx.getInputStyle())("id", ctx.id + "_search")("testID", ctx.testID + "_search")("disabled", ctx.disabled || ctx.disabledInput)("readonly", ctx.readonly)("typeahead", ctx.typeaheadFn)("focusFirst", false)("appendToBody", true)("ariaLabel", ctx.ariaLabel)("resultFormatter", ctx.selectItemFormatter)("resultTemplate", ctx.selectItemTemplate)("popupClass", ctx.popupClass)("popupWidth", "auto")("ngModel", ctx.inputValue)("showClearButton", false);
        i0.ɵɵattribute("size", ctx.inputSizeAttr);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", ctx.suffix);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.isWarnings && !ctx.isAllWarnings || ctx.control.touched && ctx.errors.length);
    } }, directives: [i5.NgClass, i6.AdaptRxControlLabelComponent, i5.NgIf, i5.NgForOf, i7.AdaptRxTypeaheadComponent, i5.NgStyle, i8.NgControlStatus, i8.NgModel, i9.AdaptTooltipDirective, i5.NgTemplateOutlet], encapsulation: 2, data: { animation: [
            trigger('validationFeedbackAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.fadeIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.fadeOut)
                ])
            ]),
            trigger('errorToggleAnimation', [
                transition(':enter', [
                    style({
                        opacity: 0
                    }),
                    animate(250)
                ]),
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(150)
                ])
            ]),
            trigger('tagsListAnimation', [
                transition(':increment', [
                    query('@tagAnimation', [
                        animateChild()
                    ], { optional: true })
                ])
            ]),
            trigger('tagAnimation', [
                transition(':enter', animate(100, keyframes([
                    style({
                        opacity: 0,
                        padding: 0,
                        offset: 0
                    }),
                    style({
                        opacity: 0.3,
                        padding: '1px 6px 1px',
                        offset: .3
                    }),
                    style({
                        opacity: 0.35,
                        padding: '1px 8px 2px',
                        offset: .35
                    }),
                    style({
                        opacity: 0.9,
                        padding: '2px 19px 3px',
                        offset: .9
                    }),
                    style({
                        opacity: 1,
                        offset: 1
                    })
                ])))
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMetatagComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-metatag, adapt-tag-field',
                templateUrl: './metatag.component.html',
                encapsulation: ViewEncapsulation.None,
                providers: [
                    createFormControlValueAccessor(AdaptMetatagComponent),
                    createFormControlValidator(AdaptMetatagComponent)
                ],
                animations: [
                    trigger('validationFeedbackAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.fadeIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.fadeOut)
                        ])
                    ]),
                    trigger('errorToggleAnimation', [
                        transition(':enter', [
                            style({
                                opacity: 0
                            }),
                            animate(250)
                        ]),
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(150)
                        ])
                    ]),
                    trigger('tagsListAnimation', [
                        transition(':increment', [
                            query('@tagAnimation', [
                                animateChild()
                            ], { optional: true })
                        ])
                    ]),
                    trigger('tagAnimation', [
                        transition(':enter', animate(100, keyframes([
                            style({
                                opacity: 0,
                                padding: 0,
                                offset: 0
                            }),
                            style({
                                opacity: 0.3,
                                padding: '1px 6px 1px',
                                offset: .3
                            }),
                            style({
                                opacity: 0.35,
                                padding: '1px 8px 2px',
                                offset: .35
                            }),
                            style({
                                opacity: 0.9,
                                padding: '2px 19px 3px',
                                offset: .9
                            }),
                            style({
                                opacity: 1,
                                offset: 1
                            })
                        ])))
                    ])
                ]
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.Injector }, { type: i1.AdaptTruncatePipe }, { type: i0.NgZone }, { type: i2.AdaptDeviceDetectionService }, { type: i0.ChangeDetectorRef }, { type: i3.AdaptTranslateService }, { type: i4.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { prefix: [{
            type: Input
        }], suffix: [{
            type: Input
        }], maxTagLength: [{
            type: Input
        }], truncateConfig: [{
            type: Input
        }], id: [{
            type: Input
        }], testID: [{
            type: Input
        }], name: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], search: [{
            type: Input
        }], maxHeight: [{
            type: Input
        }], suppressManual: [{
            type: Input
        }], label: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], mainErrorText: [{
            type: Input
        }], warningStateText: [{
            type: Input
        }], width: [{
            type: Input
        }], errorCheck: [{
            type: Input
        }], warningCheck: [{
            type: Input
        }], selectItemTemplate: [{
            type: Input
        }], tagTemplate: [{
            type: Input
        }], replaceModelOnWrite: [{
            type: Input
        }], delimiterSymbol: [{
            type: Input
        }], popupClass: [{
            type: Input
        }], disabledInput: [{
            type: Input
        }], openDropdownOnFocus: [{
            type: Input
        }], selectItemFormatter: [{
            type: Input
        }], fullWidthEdit: [{
            type: Input
        }], tagStyleFormatter: [{
            type: Input
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], removeTag: [{
            type: Output
        }], addTag: [{
            type: Output
        }], initTagEditing: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], focused: [{
            type: HostBinding,
            args: ['class.adapt-mt-focused']
        }], adaptRxTypeaheadComponent: [{
            type: ViewChild,
            args: ['adaptRxTypeaheadComponent', { static: true }]
        }], inputWrp: [{
            type: ViewChild,
            args: ['inputWrp']
        }], container: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }], metatag: [{
            type: ViewChild,
            args: ['metatag', { static: true }]
        }], tagItemList: [{
            type: ViewChildren,
            args: ['tagItem']
        }], tagItemWrpList: [{
            type: ViewChildren,
            args: ['tagItemWrp']
        }] }); })();
//# sourceMappingURL=metatag.component.js.map