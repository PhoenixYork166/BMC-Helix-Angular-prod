import { ElementRef, Injectable } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { TooltipPlacement } from '../common/positioning';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/bidi";
export class TooltipService {
    constructor(elementRef, dir) {
        this.elementRef = elementRef;
        this.dir = dir;
        this._offset = 15;
        this._arrowSize = 6;
    }
    getActualPosition(x, y) {
        x += this._offset;
        y -= this._offset / 2;
        if (this.dir.value === 'rtl') {
            x -= this._offset + this.elementRef.nativeElement.offsetWidth;
        }
        else {
            x += this._offset;
        }
        return { x, y };
    }
    getFixedPosition(target, placement) {
        let point;
        let translatePoint;
        const objectHeightWidth = this.getWidthHeight(this.elementRef);
        switch (placement) {
            case TooltipPlacement.Top: {
                point = this.getTopPosition(target);
                translatePoint = {
                    x: Math.round(-objectHeightWidth.x / 2),
                    y: Math.round(-objectHeightWidth.y)
                };
                break;
            }
            case TooltipPlacement.Right: {
                point = this.getRightPosition(target);
                translatePoint = {
                    x: 0,
                    y: Math.round(-objectHeightWidth.y / 2)
                };
                break;
            }
            case TooltipPlacement.Bottom: {
                point = this.getBottomPosition(target);
                translatePoint = {
                    x: Math.round(-objectHeightWidth.x / 2),
                    y: 0
                };
                break;
            }
            case TooltipPlacement.Left: {
                point = this.getLeftPosition(target);
                translatePoint = {
                    x: Math.round(-objectHeightWidth.x),
                    y: Math.round(-objectHeightWidth.y / 2)
                };
                break;
            }
        }
        return { point, translatePoint };
    }
    getAutoPosition(target) {
        // TODO check if can be refactored
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        return new Promise((resolve) => {
            const timer = setTimeout(() => {
                const t = self.getTopPosition(target);
                const b = self.getBottomPosition(target);
                const l = self.getLeftPosition(target);
                const r = self.getRightPosition(target);
                const { innerWidth, innerHeight } = window;
                const { width, height } = self.elementRef.nativeElement.getBoundingClientRect();
                if (t.y - height - self._arrowSize >= 0 &&
                    t.x - width - self._arrowSize >= 0 &&
                    t.x + width + self._arrowSize <= innerWidth) {
                    resolve({
                        point: t,
                        placement: 'top'
                    });
                }
                else if (b.y + height + self._arrowSize <= innerHeight &&
                    b.x - width - self._arrowSize >= 0 &&
                    b.x + width + self._arrowSize <= innerWidth) {
                    resolve({
                        point: b,
                        placement: 'bottom'
                    });
                }
                else if (l.x - width - self._arrowSize >= 0) {
                    resolve({
                        point: l,
                        placement: 'left'
                    });
                }
                else if (r.x + width + self._arrowSize <= innerWidth) {
                    resolve({
                        point: r,
                        placement: 'right'
                    });
                }
                else {
                    resolve({
                        point: t,
                        placement: 'top'
                    });
                }
                clearTimeout(timer);
            }, 0);
        });
    }
    getTopPosition(target) {
        const { top, left, width } = target.getBoundingClientRect();
        return { x: left + width / 2, y: top - this._arrowSize };
    }
    getRightPosition(target) {
        const { top, left, width, height } = target.getBoundingClientRect();
        return { x: left + width + this._arrowSize, y: top + height / 2 };
    }
    getBottomPosition(target) {
        const { top, left, width, height } = target.getBoundingClientRect();
        return { x: left + width / 2, y: top + height + this._arrowSize };
    }
    getLeftPosition(target) {
        const { top, left, height } = target.getBoundingClientRect();
        return { x: left - this._arrowSize, y: top + height / 2 };
    }
    getWidthHeight(el) {
        const { width, height } = el.nativeElement.getBoundingClientRect();
        return { x: width, y: height };
    }
}
TooltipService.ɵfac = function TooltipService_Factory(t) { return new (t || TooltipService)(i0.ɵɵinject(i0.ElementRef), i0.ɵɵinject(i1.Directionality)); };
TooltipService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TooltipService, factory: TooltipService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(TooltipService, [{
        type: Injectable
    }], function () { return [{ type: i0.ElementRef }, { type: i1.Directionality }]; }, null); })();
//# sourceMappingURL=tooltip.service.js.map