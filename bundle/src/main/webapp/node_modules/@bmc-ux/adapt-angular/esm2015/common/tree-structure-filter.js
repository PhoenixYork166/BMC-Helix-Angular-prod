import { Injectable } from '@angular/core';
import { isString } from './utilities';
import * as i0 from "@angular/core";
export class AdaptTreeStructureFilteringService {
    // TODO: Cover with unit tests!
    filter(items, filterQuery, filterByProp) {
        return this.onFilter(items, filterQuery, filterByProp);
    }
    // Filtering logic took from PrimeNG and simplified
    onFilter(items, filterQuery, filterByProp) {
        if (filterQuery === '') {
            return null;
        }
        else {
            const filteredNodes = [];
            for (let _i = 0, _a = items; _i < _a.length; _i++) {
                const node = _a[_i];
                const copyNode = Object.assign({}, node);
                if (((this.findFilteredNodes(copyNode, filterQuery, filterByProp)
                    || this.isFilterMatched(copyNode, filterQuery, filterByProp)))) {
                    filteredNodes.push(copyNode);
                }
            }
            return filteredNodes;
        }
    }
    findFilteredNodes(node, filterQuery, filterByProp) {
        if (node) {
            let matched = false;
            if (node.items) {
                const childNodes = node.items;
                node.items = [];
                for (let _i = 0, childNodes1 = childNodes; _i < childNodes1.length; _i++) {
                    const childNode = childNodes1[_i];
                    const copyChildNode = Object.assign({}, childNode);
                    if (this.isFilterMatched(copyChildNode, filterQuery, filterByProp)) {
                        matched = true;
                        node.items.push(copyChildNode);
                    }
                }
            }
            if (matched) {
                return true;
            }
        }
    }
    isFilterMatched(node, filterQuery, filterByProp) {
        let matched = false;
        if (isString(filterQuery)) {
            const filterQueryLowerCase = filterQuery.toLowerCase();
            const fieldValue = this.removeAccents(String(node[filterByProp])).toLowerCase();
            if (fieldValue.indexOf(filterQueryLowerCase) > -1) {
                matched = true;
            }
        }
        else {
            if (node[filterByProp] === filterQuery) {
                matched = true;
            }
        }
        if (!matched || Boolean(node.items && node.items.length)) {
            matched = this.findFilteredNodes(node, filterQuery, filterByProp) || matched;
        }
        return matched;
    }
    removeAccents(str) {
        if (str) {
            str = str
                .replace(/[\xC0-\xC5]/g, 'A')
                .replace(/[\xC6]/g, 'AE')
                .replace(/[\xC7]/g, 'C')
                .replace(/[\xC8-\xCB]/g, 'E')
                .replace(/[\xCC-\xCF]/g, 'I')
                .replace(/[\xD0]/g, 'D')
                .replace(/[\xD1]/g, 'N')
                .replace(/[\xD2-\xD6\xD8]/g, 'O')
                .replace(/[\xD9-\xDC]/g, 'U')
                .replace(/[\xDD]/g, 'Y')
                .replace(/[\xDE]/g, 'P')
                .replace(/[\xE0-\xE5]/g, 'a')
                .replace(/[\xE6]/g, 'ae')
                .replace(/[\xE7]/g, 'c')
                .replace(/[\xE8-\xEB]/g, 'e')
                .replace(/[\xEC-\xEF]/g, 'i')
                .replace(/[\xF1]/g, 'n')
                .replace(/[\xF2-\xF6\xF8]/g, 'o')
                .replace(/[\xF9-\xFC]/g, 'u')
                .replace(/[\xFE]/g, 'p')
                .replace(/[\xFD\xFF]/g, 'y');
        }
        return str;
    }
}
AdaptTreeStructureFilteringService.ɵfac = function AdaptTreeStructureFilteringService_Factory(t) { return new (t || AdaptTreeStructureFilteringService)(); };
AdaptTreeStructureFilteringService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptTreeStructureFilteringService, factory: AdaptTreeStructureFilteringService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTreeStructureFilteringService, [{
        type: Injectable
    }], null, null); })();
//# sourceMappingURL=tree-structure-filter.js.map