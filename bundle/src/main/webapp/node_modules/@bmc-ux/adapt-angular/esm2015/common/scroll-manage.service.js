import { Injectable } from '@angular/core';
import { AdaptDeviceDetectionService } from './device-detection.service';
import * as i0 from "@angular/core";
import * as i1 from "./device-detection.service";
let CONTAINER_ID = 1;
/**
 * The service for manage scrollbar visibility for the current container
 *
 * getScrollManager(element: HTMLElement) - returns an object for manipulation scroll visibility for element
 * Scroll manage object:
 * {
 *  hide: () => void;   <–– hide scrollbar
 *  show: () => void    <–– show scrollbar
 * }
 *
 */
export class ScrollManageService {
    constructor(_deviceDetectionService) {
        this._deviceDetectionService = _deviceDetectionService;
        /**
         * Containers for whom provide scroll manager
         */
        this._containers = [];
        this._calculateScrollbarWidth();
        this._createStyleContainer();
    }
    /**
     * Public API
     * returns hide: (() => void); show: (() => void)
     */
    getScrollManager(element) {
        let scrollEl = this._getContainer(element);
        if (!scrollEl) {
            scrollEl = new ContainerScrollManager(element, this._scrollbarWidth, this._updateStyleList.bind(this), this._deviceDetectionService);
            this._containers.push(scrollEl);
            this._updateStyleList();
        }
        return scrollEl.api;
    }
    /**
     * Method for search the container among registered
     * returns ContainerScrollManager
     */
    _getContainer(el) {
        return this._containers.find((elem) => {
            return elem.el === el;
        });
    }
    /**
     * Method for calculating scrollbar width in the current environment
     */
    _calculateScrollbarWidth() {
        // Set up and add to DOM temporary outer div
        const outer = document.createElement('div');
        outer.style.visibility = 'hidden';
        outer.style.width = '100px';
        document.body.appendChild(outer);
        // Get width without scroll
        const widthNoScroll = outer.offsetWidth;
        // Force scrollbars
        outer.style.overflow = 'scroll';
        // Set up and add to DOM temporary inner div
        const inner = document.createElement('div');
        inner.style.width = '100%';
        outer.appendChild(inner);
        // Get width with scroll
        const widthWithScroll = inner.offsetWidth;
        // Remove temporary divs
        outer.parentNode.removeChild(outer);
        // Get scrollbar width
        this._scrollbarWidth = widthNoScroll - widthWithScroll;
    }
    /**
     * Method for creation style container
     */
    _createStyleContainer() {
        this._styleListContainer = document.createElement('style');
        this._styleListContainer.type = 'text/css';
        document.getElementsByTagName('head')[0].appendChild(this._styleListContainer);
    }
    /**
     * Method for updating all styles in the style container
     */
    _updateStyleList() {
        const containersStyleList = this._containers.map((elem) => {
            return elem.style;
        });
        this._styleListContainer.innerText = containersStyleList.join('\n') + '\n.overflow-hidden{overflow: hidden!important;}';
    }
}
ScrollManageService.ɵfac = function ScrollManageService_Factory(t) { return new (t || ScrollManageService)(i0.ɵɵinject(i1.AdaptDeviceDetectionService)); };
ScrollManageService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ScrollManageService, factory: ScrollManageService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ScrollManageService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1.AdaptDeviceDetectionService }]; }, null); })();
/**
 * The class represents scrollbar manager for container
 */
export class ContainerScrollManager {
    constructor(element, scrollbarWidth, styleUpdateCallback, deviceDetectionService) {
        this.api = {
            hide: this.hideScroll.bind(this),
            show: this.showScroll.bind(this)
        };
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.hiddenScrollSubscribers = new Set();
        this.el = element;
        this.cssClass = `sc-${CONTAINER_ID++}-hide-scroll`;
        this.scrollbarWidth = scrollbarWidth;
        this.styleUpdateCallback = styleUpdateCallback;
        this.deviceDetection = deviceDetectionService;
    }
    /**
     * Method for checking container paddingRight property and calculating additional styles according to that
     */
    _checkContainer() {
        const elementPadding = parseInt(getComputedStyle(this.el).paddingRight, 10) + this.scrollbarWidth;
        this.style = `.${this.cssClass}{padding-right: ${elementPadding}px!important;}`;
        this.styleUpdateCallback();
    }
    // TODO: Refactor this if possible
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * Hide scroll for current container
     */
    hideScroll(hiddenScrollSubscriber) {
        /* eslint-enable @typescript-eslint/no-explicit-any */
        if (hiddenScrollSubscriber && !this.hiddenScrollSubscribers.has(hiddenScrollSubscriber)) {
            this.hiddenScrollSubscribers.add(hiddenScrollSubscriber);
        }
        // fix for ios devices
        if (this.deviceDetection.iosPlatform()) {
            this.top = document.body.getBoundingClientRect().top;
            this.el.style.position = 'fixed';
            this.el.style.width = '100%';
            this.el.style.top = this.top + 'px';
            return;
        }
        const w1 = getComputedStyle(this.el).width;
        this.el.classList.add('overflow-hidden');
        const w2 = getComputedStyle(this.el).width;
        // Check if the scroll was visible before overflow restriction
        if (w1 !== w2) {
            this._checkContainer();
            this.el.classList.add(this.cssClass);
        }
    }
    // TODO: Refactor this if possible
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * Show scroll for current container
     */
    showScroll(hiddenScrollSubscriber) {
        /* eslint-enable @typescript-eslint/no-explicit-any */
        if (hiddenScrollSubscriber) {
            this.hiddenScrollSubscribers.delete(hiddenScrollSubscriber);
            if (this.hiddenScrollSubscribers.size > 0) {
                return;
            }
        }
        // fix for ios devices
        if (this.deviceDetection.iosPlatform()) {
            const n = this.top * (-1);
            this.el.style.removeProperty('position');
            this.el.style.removeProperty('width');
            this.el.style.removeProperty('top');
            // position = 'static';
            window.scroll(0, n);
            return;
        }
        this.el.classList.remove('overflow-hidden');
        this.el.classList.remove(this.cssClass);
    }
}
//# sourceMappingURL=scroll-manage.service.js.map