import { ApplicationRef, ComponentFactoryResolver, Injectable, Injector, NgZone } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { ComponentPortal } from '@angular/cdk/portal';
import { ESCAPE } from '@angular/cdk/keycodes';
import { noop, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { isNil } from 'lodash-es';
import { ScrollManageService } from '../common/scroll-manage.service';
import { DismissReasons } from '../common/common.enums';
import { adaptWarn } from '../common/logger';
import { LayerService } from '../common/layer-service';
import { AdaptOverlayService } from '../common/overlay/index';
import { AdaptDockedPanelConfig } from './docked-panel.config';
import { DockedDeferred, DockedPanelDirection, DockedPanelInstance } from './docked-panel.model';
import { AdaptDockedPanelContainerComponent } from './docked-panel.container';
import { getEventKeyCode } from '../common/key-codes';
import * as i0 from "@angular/core";
import * as i1 from "./docked-panel.config";
import * as i2 from "../common/scroll-manage.service";
import * as i3 from "@angular/cdk/bidi";
import * as i4 from "../common/layer-service";
import * as i5 from "../common/overlay/index";
export class AdaptDockedPanelStackService {
    constructor(_componentFactoryResolver, _injector, _appRef, _dpConfig, _scrollService, _ngZone, _dir, _layerService, _overlayService) {
        this._componentFactoryResolver = _componentFactoryResolver;
        this._injector = _injector;
        this._appRef = _appRef;
        this._dpConfig = _dpConfig;
        this._scrollService = _scrollService;
        this._ngZone = _ngZone;
        this._dir = _dir;
        this._layerService = _layerService;
        this._overlayService = _overlayService;
        // Public fields
        this.direction = DockedPanelDirection.LEFT; // TODO: need to check default value here
        this.hideBackdrop = false;
        // Private fields
        this._openedPanels = [];
        this._wrapper = document.body;
        this._alertsSubject = new Subject();
        this._scrollManager = this._scrollService.getScrollManager(this._wrapper);
    }
    get openedPanels() {
        return this._openedPanels;
    }
    get parentDP() {
        return this._parentDP;
    }
    get activeDP() {
        return this._activeDP;
    }
    get alertsState() {
        return this._alertsSubject.asObservable();
    }
    open(dpConfig, configInjector) {
        if (typeof dpConfig === 'string') {
            throw new Error('String type is not supported. DockedPanel type expected.');
        }
        const panel = new DockedPanelInstance(dpConfig);
        panel.promise = new DockedDeferred(() => {
            this.close(panel.id);
        }, () => {
            this.close(panel.id);
        });
        panel.promise.then(noop, noop);
        // Return in case panel already opened
        if (this._openedPanels.indexOf(panel) !== -1) {
            return;
        }
        // close all dropdowns/popover while dockedPanel is opened
        if (panel.config.closeAllOpenedItems !== false) {
            this._layerService.closeOpenedItem();
        }
        // Build DockedPanel Container
        this._buildContainer(configInjector);
        // Get 'direction' and 'hideBackdrop' settings from the first panel
        // and set then as a global for all next in the current DockedPanel Container
        if (!this._openedPanels.length) {
            this.direction = panel.config.direction || this._dpConfig.direction;
            if (this._dir.value === 'rtl') {
                if (this.direction === DockedPanelDirection.LEFT) {
                    this.direction = DockedPanelDirection.RIGHT;
                }
                else {
                    this.direction = DockedPanelDirection.LEFT;
                }
            }
            this.hideBackdrop = panel.config.hideBackdrop || this._dpConfig.hideBackdrop;
            this._parentDP = panel;
        }
        // Make parent panel inactive
        if (this._openedPanels.length) {
            this._openedPanels[0].inactive = true;
        }
        this._activeDP = panel;
        // Add new panel to the opened list
        this._openedPanels.unshift(panel);
        return panel.promise;
    }
    updateConfig(config, dockedPanelInstance) {
        if (isNil(dockedPanelInstance)) {
            throw new Error('Please make sure that passed "dockedPanelInstance" argument is defined');
        }
        const panel = this._findPanel(dockedPanelInstance.id);
        // Return in case panel not found
        if (!panel) {
            return;
        }
        dockedPanelInstance.updateConfig(config);
    }
    close(id) {
        const panel = this._findPanel(id);
        if (!this._findPanel(id)) {
            adaptWarn('ADAPT-ANGULAR Warning! Panel with provided ID is not found');
            return;
        }
        // Delete panel from the opened list
        const deleteIndex = this._openedPanels.indexOf(panel);
        if (panel.overModalOpen) {
            panel.overModalOpen = false;
        }
        else if (deleteIndex !== -1) {
            this._openedPanels.splice(deleteIndex, 1);
        }
        // Activate parent panel
        if (this._openedPanels.length) {
            this._openedPanels[0].inactive = false;
            this._activeDP = this._openedPanels[0];
        }
        else {
            this._activeDP = null;
        }
    }
    closeAllDockedPanels() {
        this._openedPanels.forEach((item) => {
            setTimeout(() => {
                const beforeDismiss = item.config && item.config.beforeDismiss;
                if (beforeDismiss && !beforeDismiss(DismissReasons.CLOSE_ALL)) {
                    return;
                }
                this.close(item.id);
            });
        });
    }
    openAlert(alert) {
        this._alertsSubject.next(alert);
    }
    // Private methods
    /**
     * Search DockedPanel by ID
     */
    _findPanel(id) {
        return this.openedPanels.find((elem) => {
            return elem.id === id;
        });
    }
    /**
     * Build DockedPanel Container
     */
    _buildContainer(configInjector) {
        if (this._overlayService.enableCDKOverlayControl) {
            this._buildOverlayContainer(configInjector);
            return;
        }
        if (this._container) {
            return;
        }
        this._container = this._componentFactoryResolver.resolveComponentFactory(AdaptDockedPanelContainerComponent).create(configInjector);
        this._appRef.attachView(this._container.hostView);
        this._wrapper.appendChild(this._container.location.nativeElement);
        this._scrollManager.hide(this);
        // Throw DockedPanel Service instance to the DockedPanel Container
        this._container.instance.dps = this;
        this._container.instance.onPanelClosed.subscribe(() => {
            if (!this._openedPanels.length) {
                this._destroyContainer();
            }
        });
    }
    /**
     * Destroy DockedPanel Container
     */
    _destroyContainer() {
        if (!this._container) {
            return;
        }
        this._container.destroy();
        this._scrollManager.show(this);
        this._container = null;
        this._parentDP = null;
        this._activeDP = null;
    }
    _buildOverlayContainer(configInjector) {
        if (this._dockedPanelContainerOverlayWithPortal) {
            return;
        }
        this._dockedPanelContainerOverlayWithPortal =
            this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptDockedPanelContainerComponent, null, configInjector), { scrollStrategy: 'block' });
        this._dockedPanelContainerOverlayWithPortal.componentRef.instance.dps = this;
        this._dockedPanelContainerOverlayWithPortal.overlayRef.keydownEvents()
            .pipe(takeUntil(this._dockedPanelContainerOverlayWithPortal.destroy$))
            .subscribe(event => {
            if (getEventKeyCode(event) === ESCAPE && this.activeDP) {
                const beforeDismiss = this.activeDP.config && this.activeDP.config.beforeDismiss;
                if (this.activeDP.config.blockKeyboard || this._dpConfig.blockKeyboard) {
                    return;
                }
                if (beforeDismiss && !beforeDismiss(DismissReasons.ESC)) {
                    return;
                }
                this.activeDP.promise.reject(DismissReasons.ESC);
            }
        });
        this._dockedPanelContainerOverlayWithPortal.componentRef.instance.onPanelClosed
            .pipe(takeUntil(this._dockedPanelContainerOverlayWithPortal.destroy$))
            .subscribe(() => {
            if (!this._openedPanels.length) {
                this._destroyOverlayContainer();
            }
        });
    }
    _destroyOverlayContainer() {
        if (!this._dockedPanelContainerOverlayWithPortal) {
            return;
        }
        this._dockedPanelContainerOverlayWithPortal.destroy();
        this._dockedPanelContainerOverlayWithPortal = null;
        this._parentDP = null;
        this._activeDP = null;
    }
}
AdaptDockedPanelStackService.ɵfac = function AdaptDockedPanelStackService_Factory(t) { return new (t || AdaptDockedPanelStackService)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i1.AdaptDockedPanelConfig), i0.ɵɵinject(i2.ScrollManageService), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i3.Directionality), i0.ɵɵinject(i4.LayerService), i0.ɵɵinject(i5.AdaptOverlayService)); };
AdaptDockedPanelStackService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptDockedPanelStackService, factory: AdaptDockedPanelStackService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDockedPanelStackService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.Injector }, { type: i0.ApplicationRef }, { type: i1.AdaptDockedPanelConfig }, { type: i2.ScrollManageService }, { type: i0.NgZone }, { type: i3.Directionality }, { type: i4.LayerService }, { type: i5.AdaptOverlayService }]; }, null); })();
//# sourceMappingURL=docked-panel-stack.service.js.map