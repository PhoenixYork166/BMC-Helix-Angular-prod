import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgZone, Optional, Output, Renderer2, Self, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';
import { NgControl } from '@angular/forms';
import { BACKSPACE, DELETE, DOWN_ARROW, ENTER, TAB, UP_ARROW } from '@angular/cdk/keycodes';
import { BehaviorSubject, fromEvent, Subject, timer } from 'rxjs';
import { map, switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { isNumber, toString } from 'lodash-es';
import { getEventKeyCode } from '../../common/key-codes';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularService } from '../../common/radar/adapt-radar';
import { AdaptDropdownDirective } from '../../dropdown/index';
import { AdaptRxFeedbackComponent, AdaptRxFormControlDirective } from '../form-control/index';
import { AdaptRxTypeaheadConfigService } from './adapt-rx-typeahead-config.service';
import { AdaptTranslateService } from '../../common/i18n/index';
import { AdaptDeviceDetectionService } from '../../common/device-detection.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "./adapt-rx-typeahead-config.service";
import * as i3 from "../../common/i18n/index";
import * as i4 from "../../common/device-detection.service";
import * as i5 from "../../common/radar/adapt-radar";
import * as i6 from "../form-control/rx-control-label/adapt-rx-control-label.component";
import * as i7 from "../../dropdown/dropdown.component";
import * as i8 from "@angular/common";
import * as i9 from "../form-control/rx-feedback/adapt-rx-feedback.component";
import * as i10 from "../../highlight/highlight";
import * as i11 from "@angular/cdk/scrolling";
const _c0 = ["inputRef"];
const _c1 = ["typeaheadContainer"];
const _c2 = ["adaptDropdownDirective"];
const _c3 = ["adaptRxFeedbackRef"];
function AdaptRxTypeaheadComponent_button_13_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 11);
    i0.ɵɵlistener("click", function AdaptRxTypeaheadComponent_button_13_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(); return ctx_r6.clearSearchValue(); });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementStart(2, "span", 12);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("btn-sm", ctx_r3.size === "sm")("btn-lg", ctx_r3.size === "lg");
    i0.ɵɵproperty("disabled", ctx_r3.disabled || ctx_r3.readonly);
    i0.ɵɵattribute("data-testid", ctx_r3.testID + "_clear");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r3.clearButtonText);
} }
function AdaptRxTypeaheadComponent_ng_template_16_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵelement(1, "adapt-highlight", 23);
    i0.ɵɵtext(2, "\n        ");
} if (rf & 2) {
    const result_r15 = ctx.result;
    const term_r16 = ctx.term;
    const ctx_r9 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("result", ctx_r9.resultFormatter(result_r15))("term", term_r16);
} }
function AdaptRxTypeaheadComponent_ng_template_16_ng_container_14_button_4_ng_template_2_Template(rf, ctx) { }
const _c4 = function (a0, a1, a2) { return { result: a0, term: a1, formatter: a2 }; };
function AdaptRxTypeaheadComponent_ng_template_16_ng_container_14_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r23 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 26);
    i0.ɵɵlistener("click", function AdaptRxTypeaheadComponent_ng_template_16_ng_container_14_button_4_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r23); const result_r19 = restoredCtx.$implicit; const ctx_r22 = i0.ɵɵnextContext(3); return ctx_r22.selectResult(result_r19); });
    i0.ɵɵtext(1, "\n                ");
    i0.ɵɵtemplate(2, AdaptRxTypeaheadComponent_ng_template_16_ng_container_14_button_4_ng_template_2_Template, 0, 0, "ng-template", 27);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const result_r19 = ctx.$implicit;
    const index_r20 = ctx.index;
    i0.ɵɵnextContext(2);
    const _r8 = i0.ɵɵreference(4);
    const ctx_r18 = i0.ɵɵnextContext();
    i0.ɵɵproperty("id", ctx_r18.popupId + "-" + ctx_r18.resultFormatter(result_r19))("ngClass", index_r20 === ctx_r18.activeResultIndex ? ctx_r18.RESULT_ACTIVE_CLASS : "");
    i0.ɵɵattribute("data-testid", ctx_r18.testID + "_item-" + index_r20);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r18.resultTemplate || _r8)("ngTemplateOutletContext", i0.ɵɵpureFunction3(5, _c4, result_r19, ctx_r18.term, ctx_r18.resultFormatter));
} }
function AdaptRxTypeaheadComponent_ng_template_16_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "cdk-virtual-scroll-viewport", 24);
    i0.ɵɵtext(3, "\n              ");
    i0.ɵɵtemplate(4, AdaptRxTypeaheadComponent_ng_template_16_ng_container_14_button_4_Template, 4, 9, "button", 25);
    i0.ɵɵtext(5, "\n            ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("height", ctx_r11.isMobileOrTablet ? ctx_r11.popupMaxHeight + "px" : ctx_r11.virtualScrollDropdownHeight);
    i0.ɵɵproperty("itemSize", ctx_r11.virtualScrollItemSize)("minBufferPx", ctx_r11.minBufferPx)("maxBufferPx", ctx_r11.maxBufferPx);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("cdkVirtualForOf", ctx_r11.results)("cdkVirtualForTrackBy", ctx_r11.trackByForResults);
} }
function AdaptRxTypeaheadComponent_ng_template_16_ng_container_16_button_2_ng_template_2_Template(rf, ctx) { }
function AdaptRxTypeaheadComponent_ng_template_16_ng_container_16_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r29 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 26);
    i0.ɵɵlistener("click", function AdaptRxTypeaheadComponent_ng_template_16_ng_container_16_button_2_Template_button_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r29); const result_r25 = restoredCtx.$implicit; const ctx_r28 = i0.ɵɵnextContext(3); return ctx_r28.selectResult(result_r25); });
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵtemplate(2, AdaptRxTypeaheadComponent_ng_template_16_ng_container_16_button_2_ng_template_2_Template, 0, 0, "ng-template", 27);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const result_r25 = ctx.$implicit;
    const index_r26 = ctx.index;
    i0.ɵɵnextContext(2);
    const _r8 = i0.ɵɵreference(4);
    const ctx_r24 = i0.ɵɵnextContext();
    i0.ɵɵproperty("id", ctx_r24.popupId + "-" + ctx_r24.resultFormatter(result_r25))("ngClass", index_r26 === ctx_r24.activeResultIndex ? ctx_r24.RESULT_ACTIVE_CLASS : "");
    i0.ɵɵattribute("data-testid", ctx_r24.testID + "_item-" + index_r26);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r24.resultTemplate || _r8)("ngTemplateOutletContext", i0.ɵɵpureFunction3(5, _c4, result_r25, ctx_r24.term, ctx_r24.resultFormatter));
} }
function AdaptRxTypeaheadComponent_ng_template_16_ng_container_16_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptRxTypeaheadComponent_ng_template_16_ng_container_16_button_2_Template, 4, 9, "button", 28);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r12.results)("ngForTrackBy", ctx_r12.trackByForResults);
} }
function AdaptRxTypeaheadComponent_ng_template_16_div_21_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 29);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r13.resultStatusMessage);
} }
function AdaptRxTypeaheadComponent_ng_template_16_div_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 30);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r14.emptyResultMessage);
} }
function AdaptRxTypeaheadComponent_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 13);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵtemplate(3, AdaptRxTypeaheadComponent_ng_template_16_ng_template_3_Template, 3, 2, "ng-template", null, 14, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(5, "\n\n        ");
    i0.ɵɵelementStart(6, "div", 15);
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelement(8, "adapt-rx-feedback", 16, 17);
    i0.ɵɵtext(10, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n\n        ");
    i0.ɵɵelementStart(12, "div", 18);
    i0.ɵɵtext(13, "\n          ");
    i0.ɵɵtemplate(14, AdaptRxTypeaheadComponent_ng_template_16_ng_container_14_Template, 7, 7, "ng-container", 19);
    i0.ɵɵtext(15, "\n\n          ");
    i0.ɵɵtemplate(16, AdaptRxTypeaheadComponent_ng_template_16_ng_container_16_Template, 4, 2, "ng-container", 19);
    i0.ɵɵtext(17, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(18, "\n\n        ");
    i0.ɵɵelementStart(19, "div", 20);
    i0.ɵɵtext(20, "\n          ");
    i0.ɵɵtemplate(21, AdaptRxTypeaheadComponent_ng_template_16_div_21_Template, 2, 1, "div", 21);
    i0.ɵɵtext(22, "\n\n          ");
    i0.ɵɵtemplate(23, AdaptRxTypeaheadComponent_ng_template_16_div_23_Template, 2, 1, "div", 22);
    i0.ɵɵtext(24, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(25, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(26, "\n    ");
} if (rf & 2) {
    const _r10 = i0.ɵɵreference(9);
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("id", ctx_r4.popupId)("ngStyle", ctx_r4.getDropdownStyles())("ngClass", ctx_r4.popupClass);
    i0.ɵɵadvance(7);
    i0.ɵɵproperty("errors", ctx_r4.ngControl.errors)("warningMessage", ctx_r4.warningMessage)("controlTouched", ctx_r4.ngControl.touched)("alertFeedbackStyle", true)("alertFeedbackTruncation", !ctx_r4.isMobileOrTablet);
    i0.ɵɵadvance(4);
    i0.ɵɵclassProp("mt-2", _r10.hasUIErrorState || ctx_r4.warningMessage);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.virtualScroll);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r4.virtualScroll);
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngIf", ctx_r4.resultStatusMessage && (ctx_r4.results == null ? null : ctx_r4.results.length));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.showEmptyResultMessage && !(ctx_r4.results == null ? null : ctx_r4.results.length));
} }
export class AdaptRxTypeaheadComponent extends AdaptRxFormControlDirective {
    constructor(ngControl, _renderer, _ngZone, adaptRxTypeaheadConfigService, _changeDetectorRef, ts, _deviceDetector, _adaptRadarService, _elem) {
        super(ngControl, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRxTypeahead, _changeDetectorRef);
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        this.ts = ts;
        this._deviceDetector = _deviceDetector;
        this.controlName = 'typeahead';
        this.activeResultIndex = 0; // index of active result in the popup
        this.isMobileOrTablet = false;
        this.RESULT_ACTIVE_CLASS = 'text-active';
        /**
         * The value for the "autocomplete" attribute for the "<input>" element
         * @docs-default off
         */
        this.autocomplete = 'off';
        /**
         * Allows using a custom entered text as a model value.
         * In case if there is no matched options with entered value
         * @docs-default false
         */
        this.editable = false;
        /**
         * Hold focus on the first result item while typing
         * @docs-default true
         */
        this.focusFirst = true;
        /**
         *  After menu close, restore focus the element which was in focus before menu open
         *  @docs-default false
         */
        this.restoreFocusAfterClose = false;
        /**
         * The function that converts an item from the result list to a "string" to display in the "<input>" field
         * @docs-default item
         */
        this.inputFormatter = toString;
        /**
         * The function that converts an item from the result list to a "string" to display in the popup
         * @docs-default item
         */
        this.resultFormatter = toString;
        /**
         * Show the hint in the "<input>" when an item in the result list matches
         * @docs-default false
         */
        this.showHint = false;
        /**
         * The preferred placement of the typeahead
         * @docs-default bottom-left
         */
        this.placement = ['bottom-left', 'bottom-right', 'top-left', 'top-right', 'auto'];
        /**
         * Control size
         * @docs-default default
         */
        this.size = 'default';
        /**
         * Max height in pixels for the popup before scroll visible. On mobile max height calculates automatically
         * @docs-default 200
         */
        this.popupMaxHeight = 200;
        /**
         * Use disable styles for readonly state
         * @docs-default false
         */
        this.disabledStyleForReadonlyState = false;
        /**
         * Use to toggle virtual scroll feature to render results. Can be suitable for big amount of results
         * @docs-default false
         */
        this.virtualScroll = false;
        /**
         * Set <b>[itemSize]</b> input for virtual scroll feature. More info can be found here - <a href="https://material.angular.io/cdk/scrolling/api" target="_blank">https://material.angular.io/cdk/scrolling/api</a>
         * @docs-default 32
         */
        this.virtualScrollItemSize = 32;
        /**
         * Minimum amount of content buffer (in pixels) that the viewport must render.
         * @docs-default 400
         */
        this.minBufferPx = 400;
        /**
         * Configures how much buffer space to render back up to when it detects that more buffer is required.
         * @docs-default 1200
         */
        this.maxBufferPx = 1200;
        /**
         * Use to set results dropdown height. On mobile height calculates automatically
         * @docs-default 13.75rem
         */
        this.virtualScrollDropdownHeight = '13.75rem';
        /**
         * Offset from the top edge of the viewport during auto-scroll when focusing on input on mobile devices.
         * To disable autoscroll need to pass 'null'.
         * @docs-default 0
         * @since v11.2.0
         */
        this.mobileFocusAutoscrollTopOffset = 0;
        /**
         * Allow showing the empty result message if no items to display
         * @docs-default false
         * @since v11.8.0
         */
        this.showEmptyResultMessage = false;
        /**
         * Control clear button visibility
         * @docs-default true
         *
         * @since v12.15.0
         */
        this.showClearButton = true;
        /* eslint-disable @angular-eslint/no-output-on-prefix */
        /**
         * An event emitted right before an item is selected from the result list.
         */
        this.onSelectItem = new EventEmitter();
        this._closed$ = new Subject();
        this._inputInFocus = false;
        /**
         * Indicates if input was changed after selection from listbox.
         */
        this._inputValueChanged = false;
        this.size = adaptRxTypeaheadConfigService.size;
        this.editable = adaptRxTypeaheadConfigService.editable;
        this.focusFirst = adaptRxTypeaheadConfigService.focusFirst;
        this.showHint = adaptRxTypeaheadConfigService.showHint;
        this.placement = adaptRxTypeaheadConfigService.placement;
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    ngOnInit() {
        super.ngOnInit();
        this.isMobileOrTablet = this._deviceDetector.isMobile() || this._deviceDetector.deviceTablet();
        this._valueChanges = fromEvent(this.inputRef.nativeElement, 'input')
            .pipe(map($event => $event.target.value));
        this._resubscribeTypeahead = new BehaviorSubject(null);
        const inputValues$ = this._valueChanges.pipe(tap(value => {
            this._inputValueBackup = value;
            this._inputValueChanged = true;
            this._onChange(this.editable ? value : undefined);
        }));
        const results$ = inputValues$.pipe(this.typeahead);
        const userInput$ = this._resubscribeTypeahead.pipe(switchMap(() => results$));
        this._subscription = this._subscribeToUserInput(userInput$);
    }
    ngOnChanges(changes) {
        // on changes to the input formatter, update the displayed input value by
        // applying the new formatter to the current value of the bound form control
        if (changes.inputFormatter && this.ngControl && this.ngControl.value) {
            this._writeInputValue(this._getFormattedItemForInput(this.ngControl.value));
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._closePopup();
        this._unsubscribeFromUserInput();
        this._unsubscribeFromVisualViewportResize();
    }
    setDefaultTexts(translation) {
        this.emptyResultMessage = translation['adapt.select.notFound'];
        this.clearButtonText = this.clearButtonText || translation['adapt.common.clear'];
    }
    get popupId() {
        return this.id + '_popup';
    }
    /**
     * Check if the control has UI error state
     */
    get hasDangerState() {
        return this.adaptRxFeedbackRef.hasUIErrorState;
    }
    /**
     * Check if component should have success appearance if no errors
     */
    get hasSuccessState() {
        // return this.showValidState && this.ngControl.touched && !this.ngControl.errors;
        return false;
    }
    /**
     * Get active result value
     */
    get activeResult() {
        return this.results ? this.results[this.activeResultIndex] : undefined;
    }
    /**
     * Own instance implementation of writeValue from ControlValueAccessor
     */
    writeValue(value) {
        const formattedValue = this._getFormattedItemForInput(value);
        this._writeInputValue(formattedValue);
        this._inputValueBackup = formattedValue;
    }
    /**
     * Dismisses typeahead popup window
     */
    dismissPopup() {
        this._resubscribeTypeahead.next(null);
        this.activeDescendant = undefined;
        if (!this._inputInFocus) {
            this._onTouched();
        }
    }
    /**
     * Handle native input (blur) event
     */
    blurHandler(event) {
        super.blurHandler(event);
        this._inputInFocus = false;
        this._resubscribeTypeahead.next(null);
        this._unsubscribeFromVisualViewportResize();
        if (!this.popup.isOpen()) {
            this._setValueFromProposal();
            this._onTouched();
        }
    }
    focusHandler(event) {
        super.focusHandler(event);
        this._inputInFocus = true;
        this._inputWidth = this.typeaheadContainer.nativeElement.offsetWidth;
        if (this.isMobileOrTablet) {
            if (!this._removeVisualViewportResizeListener) {
                const visualViewport = window.visualViewport;
                const dropdownVerticalMargin = this.virtualScroll ? 20 : 10;
                this._removeVisualViewportResizeListener = this._renderer.listen(visualViewport, 'resize', () => {
                    this.popupMaxHeight = visualViewport.height - this.typeaheadContainer.nativeElement.offsetHeight - dropdownVerticalMargin;
                });
            }
            if (isNumber(this.mobileFocusAutoscrollTopOffset)) {
                this._ngZone.runOutsideAngular(() => {
                    // This timer is added to properly scroll to the top of typeahead component on mobile devices
                    timer(200)
                        .pipe(takeUntil(this.destroy$))
                        .subscribe(() => {
                        this.typeaheadContainer.nativeElement.scrollIntoView({ behavior: 'auto' });
                        window.scrollBy(0, -this.mobileFocusAutoscrollTopOffset);
                    });
                });
            }
        }
    }
    getDropdownStyles() {
        const minWidth = 200;
        return {
            width: this.popupWidth ? `${this.popupWidth}` : `${this._inputWidth >= minWidth ? this._inputWidth : minWidth}px`,
            maxHeight: this.virtualScroll ? 'auto' : `${this.popupMaxHeight}px`
        };
    }
    /**
     * Handle native input (keydown) event
     */
    inputKeydownHandler(event) {
        this._lastKeyCode = getEventKeyCode(event);
        if (!this.popup.isOpen()) {
            return;
        }
        switch (this._lastKeyCode) {
            case DOWN_ARROW: {
                event.preventDefault();
                this._activateNextResult();
                this._showHint(false);
                this._scrollToActiveResultItem();
                break;
            }
            case UP_ARROW: {
                event.preventDefault();
                this._activatePrevResult();
                this._showHint(false);
                this._scrollToActiveResultItem();
                break;
            }
            case ENTER: {
                const result = this.activeResult;
                if (result !== null && result !== undefined) {
                    event.preventDefault();
                    event.stopPropagation();
                    this._selectResult(result);
                }
                this._closePopup();
                break;
            }
            case TAB: {
                this._closePopup();
                break;
            }
        }
    }
    /**
     * Select result
     */
    selectResult(item) {
        this._selectResult(item);
        this._closePopup();
    }
    trackByForResults(index, item) {
        return item;
    }
    clearSearchValue() {
        this.writeValue('');
        this._onChange('');
        this._inputValueChanged = false;
        this._closePopup();
        this.term = '';
        this._focusNativeElement();
    }
    /**
     * Implementation from the base class
     */
    _focusNativeElement() {
        this.inputRef.nativeElement.focus();
    }
    /**
     * Check if active result present
     */
    _hasActiveResult() {
        return this.activeResultIndex > -1 && this.activeResultIndex < this.results.length;
    }
    /**
     * Activate the next result from results list
     */
    _activateNextResult() {
        if (this.activeResultIndex < this.results.length - 1) {
            this.activeResultIndex++;
        }
        this._activeResultChanged();
    }
    /**
     * Activate the prev result from results list
     */
    _activatePrevResult() {
        if (this.activeResultIndex > 0) {
            this.activeResultIndex--;
        }
        this._activeResultChanged();
    }
    /**
     * Reset active result
     */
    _resetActiveResult() {
        const setDefault = () => this.activeResultIndex = this.popup.isOpen() && this.focusFirst ? 0 : -1;
        if (this._inputValueBackup) {
            const firstMatchedIndex = this.results.findIndex(item => { var _a; return (_a = this._getFormattedItemForInput(item)) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith(this._inputValueBackup.toLowerCase()); });
            if (firstMatchedIndex > -1) {
                this.activeResultIndex = firstMatchedIndex;
            }
            else {
                setDefault();
            }
        }
        else {
            setDefault();
        }
        this._activeResultChanged();
    }
    /**
     * Active result changed
     */
    _activeResultChanged() {
        this.activeDescendant = (this.activeResultIndex >= 0 && this.activeResult) ?
            this.popupId + '-' + this.resultFormatter(this.activeResult) : undefined;
    }
    /**
     * Scroll to active result item
     */
    _scrollToActiveResultItem() {
        this._ngZone.onStable.pipe(takeUntil(this.destroy$), take(1)).subscribe(() => {
            const activeItem = document.querySelector(`#${this.popupId} .${this.RESULT_ACTIVE_CLASS}`);
            if (activeItem) {
                activeItem.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        });
    }
    /**
     * Open result's popup
     */
    _openPopup() {
        if (this.readonly || this.disabled) {
            return;
        }
        if (!this.popup.isOpen()) {
            this._inputValueBackup = this.inputRef.nativeElement.value;
            this.popup.open();
            this._activeResultChanged();
        }
        else {
            this._ngZone.onStable
                .pipe(takeUntil(this.destroy$), take(1))
                .subscribe(() => {
                var _a, _b;
                (_b = (_a = this.popup) === null || _a === void 0 ? void 0 : _a.menuWindowRef) === null || _b === void 0 ? void 0 : _b.instance.recalculatePosition();
            });
        }
    }
    /**
     * Close result's popup
     */
    _closePopup() {
        this._closed$.next();
        this.popup.close();
        this.activeDescendant = undefined;
    }
    /**
     * Select result and propagate change
     */
    _selectResult(result) {
        let defaultPrevented = false;
        this.onSelectItem.emit({
            item: result,
            preventDefault: () => {
                defaultPrevented = true;
            }
        });
        this._resubscribeTypeahead.next(null);
        if (!defaultPrevented) {
            this.writeValue(result);
            this._onChange(result);
            this._inputValueChanged = false;
        }
    }
    /**
     * Show hint in the input
     * @param onlyFromStart - indicate that hint should display only if input value is a start of proposal values.
     * For example, if onlyFromStart = true, then on "app" input "apple" hint would be shown, "pineapple" would not.
     */
    _showHint(onlyFromStart = true) {
        if (this.showHint && this._hasActiveResult() && this._inputValueBackup
            && ![BACKSPACE, DELETE].includes(this._lastKeyCode)) {
            const userInputLowerCase = this._inputValueBackup.toLowerCase();
            const formattedVal = this._getFormattedItemForInput(this.activeResult);
            if (userInputLowerCase === (formattedVal === null || formattedVal === void 0 ? void 0 : formattedVal.substr(0, this._inputValueBackup.length).toLowerCase())) {
                this._writeInputValue(this._inputValueBackup + formattedVal.substr(this._inputValueBackup.length));
                this.inputRef.nativeElement.setSelectionRange.apply(this.inputRef.nativeElement, [this._inputValueBackup.length, formattedVal.length]);
            }
            else if (!onlyFromStart) {
                this._writeInputValue(formattedVal);
            }
        }
    }
    /**
     * Returns formatted item if [inputFormatter] defined or toString(item)
     */
    _getFormattedItemForInput(item) {
        return item != null && this.inputFormatter ? this.inputFormatter(item) : toString(item);
    }
    /**
     * Write value to native input
     */
    _writeInputValue(value) {
        this._renderer.setProperty(this.inputRef.nativeElement, 'value', toString(value));
    }
    /**
     * Subscribe to native control (input) event
     */
    _subscribeToUserInput(userInput$) {
        return userInput$.subscribe((results) => {
            if (!(results === null || results === void 0 ? void 0 : results.length) && !this.showEmptyResultMessage) {
                this._closePopup();
            }
            else {
                if (this.isMobileOrTablet) {
                    // Timeout added to wait until focus animation on mobile devices stabilized and dropdown can be shown with correct max-height
                    setTimeout(() => {
                        this._openPopup();
                    }, 300);
                }
                else {
                    this._openPopup();
                }
                this.results = results;
                this.term = this.inputRef.nativeElement.value;
                this._resetActiveResult();
                this._showHint();
            }
        });
    }
    /**
     * Unsubscribe from native control (input) event
     */
    _unsubscribeFromUserInput() {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
        this._subscription = null;
    }
    _unsubscribeFromVisualViewportResize() {
        if (this._removeVisualViewportResizeListener) {
            this._removeVisualViewportResizeListener();
            this._removeVisualViewportResizeListener = null;
        }
    }
    _setValueFromProposal() {
        if (!this.editable && this._inputValueBackup && this._inputValueChanged) {
            if (this.showHint && this.activeResult && (this.activeResult.toLowerCase() === this.inputRef.nativeElement.value)) {
                this._selectResult(this.activeResult);
            }
            else if (!this.showHint && this.results) {
                const relativeResult = this.results
                    .find(item => { var _a; return ((_a = this._getFormattedItemForInput(item)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === this._inputValueBackup.toLowerCase(); });
                relativeResult !== undefined && this._selectResult(relativeResult);
            }
        }
    }
}
AdaptRxTypeaheadComponent.ɵfac = function AdaptRxTypeaheadComponent_Factory(t) { return new (t || AdaptRxTypeaheadComponent)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptRxTypeaheadConfigService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.AdaptTranslateService), i0.ɵɵdirectiveInject(i4.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i5.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRxTypeaheadComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxTypeaheadComponent, selectors: [["adapt-rx-typeahead"]], viewQuery: function AdaptRxTypeaheadComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 7);
        i0.ɵɵviewQuery(_c3, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.typeaheadContainer = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popup = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptRxFeedbackRef = _t.first);
    } }, inputs: { autocomplete: "autocomplete", placeholder: "placeholder", editable: "editable", focusFirst: "focusFirst", restoreFocusAfterClose: "restoreFocusAfterClose", inputFormatter: "inputFormatter", typeahead: "typeahead", resultFormatter: "resultFormatter", resultTemplate: "resultTemplate", showHint: "showHint", placement: "placement", appendToBody: "appendToBody", size: "size", popupMaxHeight: "popupMaxHeight", disabledStyleForReadonlyState: "disabledStyleForReadonlyState", virtualScroll: "virtualScroll", virtualScrollItemSize: "virtualScrollItemSize", minBufferPx: "minBufferPx", maxBufferPx: "maxBufferPx", virtualScrollDropdownHeight: "virtualScrollDropdownHeight", popupClass: "popupClass", popupWidth: "popupWidth", mobileFocusAutoscrollTopOffset: "mobileFocusAutoscrollTopOffset", showEmptyResultMessage: "showEmptyResultMessage", resultStatusMessage: "resultStatusMessage", showClearButton: "showClearButton", clearButtonText: "clearButtonText" }, outputs: { onSelectItem: "onSelectItem" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 23, vars: 54, consts: [["typeaheadContainer", ""], [3, "for", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"], ["adaptDropdown", "", 3, "adaptRadarDisableEventSending", "setMobileState", "autoFocusFirst", "placement", "appendToBody", "autoClose", "restoreFocusAfterClose", "onClose"], ["adaptDropdownDirective", "adaptDropdown"], ["adaptDropdownAnchor", "", 1, "rx-typeahead__input-wrapper"], ["type", "text", "autocapitalize", "off", "autocorrect", "off", "role", "combobox", "aria-multiline", "false", 1, "form-control", "rx-form-control", 3, "id", "required", "disabled", "readOnly", "autofocus", "autocomplete", "focus", "blur", "keydown"], ["inputRef", ""], ["class", "btn btn-link d-icon-cross_adapt rx-typeahead__clear-btn", "type", "button", 3, "btn-sm", "btn-lg", "disabled", "click", 4, "ngIf"], ["adaptDropdownMenuTemplate", ""], [3, "ariaErrorMessage", "errors", "warningMessage", "controlTouched"], ["adaptRxFeedbackRef", ""], ["type", "button", 1, "btn", "btn-link", "d-icon-cross_adapt", "rx-typeahead__clear-btn", 3, "disabled", "click"], [1, "sr-only"], ["adaptDropdownMenu", "", "role", "listbox", "aria-live", "polite", 1, "dropdown-menu", 3, "id", "ngStyle", "ngClass"], ["defaultResultTemplate", ""], [1, "px-3"], [3, "errors", "warningMessage", "controlTouched", "alertFeedbackStyle", "alertFeedbackTruncation"], ["popupFeedback", ""], [1, "rx-typeahead-popup-content"], [4, "ngIf"], ["role", "status", "tabindex", "-1"], ["class", "dropdown-header text-tertiary font-weight-default pt-3", 4, "ngIf"], ["class", "dropdown-header text-tertiary font-weight-default", 4, "ngIf"], [3, "result", "term"], [3, "itemSize", "minBufferPx", "maxBufferPx"], ["type", "button", "class", "dropdown-item rx-typeahead__dropdown-item", "role", "option", "tabindex", "-1", 3, "id", "ngClass", "click", 4, "cdkVirtualFor", "cdkVirtualForOf", "cdkVirtualForTrackBy"], ["type", "button", "role", "option", "tabindex", "-1", 1, "dropdown-item", "rx-typeahead__dropdown-item", 3, "id", "ngClass", "click"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["type", "button", "class", "dropdown-item rx-typeahead__dropdown-item", "role", "option", "tabindex", "-1", 3, "id", "ngClass", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "dropdown-header", "text-tertiary", "font-weight-default", "pt-3"], [1, "dropdown-header", "text-tertiary", "font-weight-default"]], template: function AdaptRxTypeaheadComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", null, 0);
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵelement(3, "adapt-rx-control-label", 1);
        i0.ɵɵtext(4, "\n\n  ");
        i0.ɵɵelementStart(5, "div", 2, 3);
        i0.ɵɵlistener("onClose", function AdaptRxTypeaheadComponent_Template_div_onClose_5_listener() { return ctx.dismissPopup(); });
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵelementStart(8, "div", 4);
        i0.ɵɵtext(9, "\n      ");
        i0.ɵɵelementStart(10, "input", 5, 6);
        i0.ɵɵlistener("focus", function AdaptRxTypeaheadComponent_Template_input_focus_10_listener($event) { return ctx.focusHandler($event); })("blur", function AdaptRxTypeaheadComponent_Template_input_blur_10_listener($event) { return ctx.blurHandler($event); })("keydown", function AdaptRxTypeaheadComponent_Template_input_keydown_10_listener($event) { return ctx.inputKeydownHandler($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(12, "\n      ");
        i0.ɵɵtemplate(13, AdaptRxTypeaheadComponent_button_13_Template, 5, 7, "button", 7);
        i0.ɵɵtext(14, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(15, "\n\n    ");
        i0.ɵɵtemplate(16, AdaptRxTypeaheadComponent_ng_template_16_Template, 27, 14, "ng-template", 8);
        i0.ɵɵtext(17, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n\n  ");
        i0.ɵɵelement(19, "adapt-rx-feedback", 9, 10);
        i0.ɵɵtext(21, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n");
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(6);
        const _r2 = i0.ɵɵreference(11);
        i0.ɵɵclassProp("has-danger", ctx.hasDangerState)("has-warning", ctx.warningMessage)("has-success", ctx.hasSuccessState);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("subLabel", ctx.subLabel)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltip)("testID", ctx.testID);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("adaptRadarDisableEventSending", true)("setMobileState", false)("autoFocusFirst", false)("placement", ctx.placement)("appendToBody", ctx.appendToBody)("autoClose", "outside")("restoreFocusAfterClose", ctx.restoreFocusAfterClose);
        i0.ɵɵadvance(5);
        i0.ɵɵclassProp("form-control-disabled-look", ctx.readonly && ctx.disabledStyleForReadonlyState)("form-control-sm", ctx.size === "sm")("form-control-lg", ctx.size === "lg")("typeahead-input_mobile", ctx.isMobileOrTablet);
        i0.ɵɵproperty("id", ctx.id)("required", ctx.required)("disabled", ctx.disabled)("readOnly", ctx.readonly)("autofocus", ctx.autofocus)("autocomplete", ctx.autocomplete);
        i0.ɵɵattribute("placeholder", ctx.placeholder)("tabindex", ctx.tabIndex)("data-testid", ctx.testID + "_input")("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy)("aria-required", ctx.required)("aria-invalid", ctx.hasDangerState)("aria-errormessage", ctx.ariaErrorMessage)("aria-autocomplete", ctx.showHint ? "both" : "list")("aria-activedescendant", ctx.activeDescendant)("aria-controls", _r1.isOpen() ? ctx.popupId : null)("aria-expanded", _r1.isOpen())("aria-readonly", ctx.readonly)("aria-disabled", ctx.disabled);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.showClearButton && _r2.value && !(ctx.disabled || ctx.readonly));
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ariaErrorMessage", ctx.ariaErrorMessage)("errors", ctx.ngControl.errors)("warningMessage", ctx.warningMessage)("controlTouched", ctx.ngControl.touched);
    } }, directives: [i6.AdaptRxControlLabelComponent, i7.AdaptDropdownDirective, i7.AdaptDropdownAnchorDirective, i8.NgIf, i7.AdaptDropdownMenuTemplateDirective, i9.AdaptRxFeedbackComponent, i7.AdaptDropdownMenuDirective, i8.NgStyle, i8.NgClass, i10.AdaptHighlightDirective, i11.CdkVirtualScrollViewport, i11.CdkFixedSizeVirtualScroll, i11.CdkVirtualForOf, i8.NgTemplateOutlet, i8.NgForOf], styles: ["\n    /* Hack to avoid mobile zoom-in on input focus */\n    .typeahead-input_mobile, .typeahead-input_mobile:focus {\n      font-size: 1rem !important;\n    }\n  "], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxTypeaheadComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-typeahead',
                templateUrl: './adapt-rx-typeahead.component.html',
                encapsulation: ViewEncapsulation.None,
                styles: [`
    /* Hack to avoid mobile zoom-in on input focus */
    .typeahead-input_mobile, .typeahead-input_mobile:focus {
      font-size: 1rem !important;
    }
  `]
            }]
    }], function () { return [{ type: i1.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i2.AdaptRxTypeaheadConfigService }, { type: i0.ChangeDetectorRef }, { type: i3.AdaptTranslateService }, { type: i4.AdaptDeviceDetectionService }, { type: i5.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { autocomplete: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], editable: [{
            type: Input
        }], focusFirst: [{
            type: Input
        }], restoreFocusAfterClose: [{
            type: Input
        }], inputFormatter: [{
            type: Input
        }], typeahead: [{
            type: Input
        }], resultFormatter: [{
            type: Input
        }], resultTemplate: [{
            type: Input
        }], showHint: [{
            type: Input
        }], placement: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], size: [{
            type: Input
        }], popupMaxHeight: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], virtualScroll: [{
            type: Input
        }], virtualScrollItemSize: [{
            type: Input
        }], minBufferPx: [{
            type: Input
        }], maxBufferPx: [{
            type: Input
        }], virtualScrollDropdownHeight: [{
            type: Input
        }], popupClass: [{
            type: Input
        }], popupWidth: [{
            type: Input
        }], mobileFocusAutoscrollTopOffset: [{
            type: Input
        }], showEmptyResultMessage: [{
            type: Input
        }], resultStatusMessage: [{
            type: Input
        }], showClearButton: [{
            type: Input
        }], clearButtonText: [{
            type: Input
        }], onSelectItem: [{
            type: Output
        }], inputRef: [{
            type: ViewChild,
            args: ['inputRef', { static: true }]
        }], typeaheadContainer: [{
            type: ViewChild,
            args: ['typeaheadContainer', { static: true }]
        }], popup: [{
            type: ViewChild,
            args: ['adaptDropdownDirective', { static: true }]
        }], adaptRxFeedbackRef: [{
            type: ViewChild,
            args: ['adaptRxFeedbackRef', { static: true }]
        }] }); })();
//# sourceMappingURL=adapt-rx-typeahead.component.js.map