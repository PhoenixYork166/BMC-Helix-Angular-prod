import { Directive, Input, ElementRef, Renderer2 } from '@angular/core';
import { AdaptSplitComponent } from './split.component';
import { toBoolean } from '../common/utilities';
import * as i0 from "@angular/core";
import * as i1 from "./split.component";
export class AdaptSplitAreaDirective {
    constructor(elementRef, renderer, split) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.split = split;
        this.eventsLockFct = [];
        this._order = null;
        this._size = null;
        this._minSizePixel = 0;
        this._visible = true;
    }
    /**
     * Order of the area. Useful if you show/hide areas using NgIf/NgFor and wants to keep the same order.
     * If specified for all, areas displayed from order min to max
     * @docs-default
     */
    set order(v) {
        this._order = !isNaN(v) ? v : null;
        this.split.updateArea(this, this._order, this._size, this._minSizePixel);
    }
    /**
     * Percentage size of the area. If null or if all areas sizes not equal to 100, all areas will have the same size
     * @docs-default
     */
    set size(v) {
        this._size = !isNaN(v) ? v : null;
        this.split.updateArea(this, this._order, this._size, this._minSizePixel);
    }
    set minSizePixel(v) {
        this._minSizePixel = (!isNaN(v) && v > 0) ? v : 0;
        this.split.updateArea(this, this._order, this._size, this._minSizePixel);
    }
    get visible() {
        return this._visible;
    }
    /**
     * Toggles area visibility without removing it from the DOM. Useful for specific case like routing
     * @docs-default true
     */
    set visible(v) {
        this._visible = toBoolean(v);
        if (this.visible) {
            this.split.showArea(this);
        }
        else {
            this.split.hideArea(this);
        }
    }
    ngOnInit() {
        this.renderer.addClass(this.elementRef.nativeElement, 'split-area');
        this.split.addArea(this, this._order, this._size, this._minSizePixel);
    }
    // TODO check if e argument can be removed
    /*eslint-disable @typescript-eslint/no-unused-vars */
    lockEvents() {
        this.eventsLockFct.push(this.renderer.listen(this.elementRef.nativeElement, 'selectstart', e => false));
        this.eventsLockFct.push(this.renderer.listen(this.elementRef.nativeElement, 'dragstart', e => false));
    }
    /*eslint-enable @typescript-eslint/no-unused-vars */
    unlockEvents() {
        while (this.eventsLockFct.length > 0) {
            const fct = this.eventsLockFct.pop();
            if (fct) {
                fct();
            }
        }
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    setStyle(key, value) {
        this.renderer.setStyle(this.elementRef.nativeElement, key, value);
    }
    ngOnDestroy() {
        this.split.removeArea(this);
    }
}
AdaptSplitAreaDirective.ɵfac = function AdaptSplitAreaDirective_Factory(t) { return new (t || AdaptSplitAreaDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptSplitComponent)); };
AdaptSplitAreaDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptSplitAreaDirective, selectors: [["div", "adaptSplitArea", ""], ["div", "adapt-split-area", ""]], hostVars: 2, hostBindings: function AdaptSplitAreaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("hided", !ctx.visible);
    } }, inputs: { order: "order", size: "size", minSizePixel: "minSizePixel", visible: "visible" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSplitAreaDirective, [{
        type: Directive,
        args: [{
                selector: 'div[adaptSplitArea], div[adapt-split-area]',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.hided]': '!visible'
                }
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.AdaptSplitComponent }]; }, { order: [{
            type: Input
        }], size: [{
            type: Input
        }], minSizePixel: [{
            type: Input
        }], visible: [{
            type: Input
        }] }); })();
//# sourceMappingURL=split-area.directive.js.map