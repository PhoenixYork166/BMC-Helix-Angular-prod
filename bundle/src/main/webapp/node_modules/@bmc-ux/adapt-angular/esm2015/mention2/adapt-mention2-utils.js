import { isString } from 'lodash-es';
export function getMention2ItemName(item, searchKey) {
    return isString(item) ? item : item[searchKey];
}
export function parseMention2ModelString(str) {
    /*eslint-disable-next-line no-useless-escape*/
    const regExp = new RegExp(/\S\[[^\]\[]+]\([^)]*\)/gm);
    const viewArray = [];
    if (str) {
        const stringParts = str.split(regExp);
        const tagParts = str.match(regExp);
        stringParts.forEach((elem, index) => {
            if (elem) {
                viewArray.push(elem);
            }
            const tag = tagParts && tagParts[index];
            if (tag) {
                viewArray.push({
                    initial: tag,
                    group: tag.slice(0, 1),
                    /*eslint-disable-next-line no-useless-escape*/
                    name: tag.match(/\[([^\]\[]+)]/)[1],
                    meta: tag.match(/\(([^)]*)\)/)[1]
                });
            }
        });
    }
    return viewArray;
}
export function getCaretPosition(element) {
    let caretOffset = 0;
    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
        caretOffset = element.selectionEnd;
    }
    else {
        const window = element.ownerDocument.defaultView;
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preCaretRange.toString().length;
        }
    }
    return caretOffset;
}
export function setCaretPosition(element, position) {
    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
        element.setSelectionRange(position, position);
    }
    else {
        let tempPos = 0;
        let childNodeCount = 0;
        while (tempPos < position) {
            const currentChildNode = element.childNodes[childNodeCount++];
            tempPos += currentChildNode.textContent.length;
            if (tempPos >= position) {
                const tempTextNode = document.createTextNode('');
                currentChildNode.parentNode.insertBefore(tempTextNode, currentChildNode.nextSibling);
                window.getSelection().collapse(tempTextNode);
            }
        }
    }
}
//# sourceMappingURL=adapt-mention2-utils.js.map