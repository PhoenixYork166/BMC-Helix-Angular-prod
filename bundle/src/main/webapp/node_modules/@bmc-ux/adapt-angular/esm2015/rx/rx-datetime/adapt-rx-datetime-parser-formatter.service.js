import { Inject, Injectable, LOCALE_ID } from '@angular/core';
import { formatDate, FormatWidth, getLocaleDateFormat, getLocaleDateTimeFormat, getLocaleTimeFormat } from '@angular/common';
import { isNil } from 'lodash-es';
import { getDateFromParts, parseDateFromString } from './common/parse.utils';
import { getDateParts } from './common/partition.utils';
import { isValidDate } from './common/validate.utils';
import { RxDatetimePickerMode } from './adapt-rx-datetime.types';
import * as i0 from "@angular/core";
export function ADAPT_RX_DATETIME_PARSER_FORMATTER_FACTORY(locale) {
    return new AdaptRxDatetimeDefaultParserFormatter(locale);
}
/**
 * An abstract service for parsing and formatting dates
 * Converts between the internal `RxDatetimeStruct` model presentation and a `string` that is displayed in the input element.
 *
 * When user types something in the input this service attempts to parse it into a `RxDatetimeStruct` object.
 * And vice versa, when users selects date/time in the picker, it must be displayed as a `string` in the input.
 *
 * Default implementation uses the Date.parse, but you can provide another implementation via DI
 * to use an alternative string format or a custom parsing logic.
 *
 */
export class AdaptRxDatetimeParserFormatter {
}
AdaptRxDatetimeParserFormatter.ɵfac = function AdaptRxDatetimeParserFormatter_Factory(t) { return new (t || AdaptRxDatetimeParserFormatter)(); };
AdaptRxDatetimeParserFormatter.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptRxDatetimeParserFormatter, factory: function AdaptRxDatetimeParserFormatter_Factory(t) { let r = null; if (t) {
        r = new t();
    }
    else {
        r = ADAPT_RX_DATETIME_PARSER_FORMATTER_FACTORY(i0.ɵɵinject(LOCALE_ID));
    } return r; }, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxDatetimeParserFormatter, [{
        type: Injectable,
        args: [{ providedIn: 'root', useFactory: ADAPT_RX_DATETIME_PARSER_FORMATTER_FACTORY, deps: [LOCALE_ID] }]
    }], null, null); })();
export class AdaptRxDatetimeDefaultParserFormatter extends AdaptRxDatetimeParserFormatter {
    constructor(_locale) {
        super();
        this._locale = _locale;
        this._timePeriodRegex = /a{1,5}/;
        this._hour12Regex = /h{1,2}/;
        this._hour24Regex = /H{1,2}/;
        this._storedYearFormats = [
            'y'
        ];
        this._storedMonthFormats = [
            'M',
            'MM',
            'MMM',
            'MMMM',
            'MMMMM'
        ];
        this._storedYearMonthFormats = [
            'y, MMM',
            'y MMM',
            'y, MMMM',
            'y MMMM',
            'y, MMMMM',
            'y MMMMM',
            'MMM, y',
            'MMM y',
            'MMMM, y',
            'MMMM y',
            'MMMMM, y',
            'MMMMM y'
        ];
    }
    parse(value, mode, hasSeconds, use12hoursTime, locale, inputFormat) {
        if (!value) {
            return null;
        }
        locale = locale || this._locale;
        // User can skip the use12hoursTime parameter so need to check it and set automatically if needed
        if (isNil(use12hoursTime)) {
            use12hoursTime = this._use12hoursFormat(locale);
        }
        let formats;
        // Note: depending on locale, the ordering of formats is very important due to the handling of abbreviated year 'yy'.
        // For example, German locale uses 'dd.MM.yy' for shortDate and 'dd.MM.y' for mediumDate. Both of these match date strings
        // with 2-character years, but in short format the year is interpreted as in the current century (abbreviated year), while
        // in medium format the year is interpreted as absolute. For example, '03.10.21' parses as October 3, 2021 in shortDate format
        // and as October 3, 0021 in mediumDate format. Since the matching algorithm just looks for the first match, we must ensure
        // that ordering of formats considers short first, lest all intended short date strings get parsed as dates in the first century!
        const namedDateTimeFormats = ['short', 'medium', 'long'];
        const namedDateFormats = ['shortDate', 'mediumDate', 'longDate'];
        const namedTimeFormats = ['shortTime', 'mediumTime', 'longTime'];
        const customDateTimeFormats = this._getCustomDateTimeFormats(locale, hasSeconds, use12hoursTime);
        // err on the side of a parser that is more forgiving in the formats that it accepts
        switch (mode) {
            case RxDatetimePickerMode.Date:
                // prefer date-only formats, but also accept all custom dateTime formats
                formats = [
                    ...namedDateFormats,
                    ...namedDateTimeFormats,
                    ...customDateTimeFormats,
                ];
                break;
            case RxDatetimePickerMode.Time:
                // prefer time-only formats, but also accept all custom dateTime formats
                formats = [
                    ...namedTimeFormats,
                    ...namedDateTimeFormats,
                    ...customDateTimeFormats,
                ];
                break;
            case RxDatetimePickerMode.DateTime:
                // prefer date-time formats, but also accept all custom dateTime formats
                formats = [
                    ...namedDateTimeFormats,
                    ...customDateTimeFormats,
                    ...namedDateFormats
                ];
                break;
            case RxDatetimePickerMode.Year:
                // prefer year-month format, but also accept all custom dateTime formats
                formats = [
                    ...this._storedYearFormats,
                    ...namedDateFormats,
                    ...customDateTimeFormats
                ];
                break;
            case RxDatetimePickerMode.Month:
                // prefer year-month format, but also accept all custom dateTime formats
                formats = [
                    ...this._storedMonthFormats,
                    ...namedDateFormats,
                    ...customDateTimeFormats
                ];
                break;
            case RxDatetimePickerMode.YearMonth:
                // prefer year-month format, but also accept all custom dateTime formats
                formats = [
                    ...this._storedYearMonthFormats,
                    ...namedDateFormats,
                    ...customDateTimeFormats
                ];
                break;
            default:
                formats = [];
        }
        if (inputFormat) {
            formats.unshift(inputFormat);
        }
        const parsedDate = parseDateFromString(value, formats, locale);
        if (isValidDate(parsedDate)) {
            const parts = getDateParts(parsedDate);
            return parts;
        }
        else {
            return {
                year: null,
                month: null,
                date: null,
                hours: null,
                minutes: null,
                seconds: null,
                parseError: {
                    query: value,
                    mode: mode,
                    locale: locale,
                    hasSeconds: hasSeconds,
                    use12HoursTime: use12hoursTime
                }
            };
        }
    }
    format(dateParts, mode, hasSeconds, use12hoursTime, locale, inputFormat) {
        if (!dateParts || dateParts.parseError) {
            return null;
        }
        const date = getDateFromParts(dateParts);
        if (!isValidDate(date)) {
            return null;
        }
        locale = locale || this._locale;
        if (inputFormat) {
            return formatDate(date, inputFormat, locale);
        }
        // User can skip the use12hoursTime parameter so need to check it and set automatically if needed
        if (isNil(use12hoursTime)) {
            use12hoursTime = this._use12hoursFormat(locale);
        }
        let format;
        let timeUsed = false;
        switch (mode) {
            case RxDatetimePickerMode.Date:
                format = 'mediumDate';
                break;
            case RxDatetimePickerMode.Time:
                format = this._getCustomTimeFormat(locale, hasSeconds, use12hoursTime);
                timeUsed = true;
                break;
            case RxDatetimePickerMode.DateTime:
                format = this._getCustomDateTimeFormat(locale, hasSeconds, use12hoursTime, FormatWidth.Medium);
                timeUsed = true;
                break;
            case RxDatetimePickerMode.Year:
                format = 'y';
                break;
            case RxDatetimePickerMode.Month:
                format = 'MMMM';
                break;
            case RxDatetimePickerMode.YearMonth:
                format = 'MMM, y';
                break;
            default:
                format = 'medium';
        }
        if (timeUsed && !isNil(use12hoursTime)) {
            if (use12hoursTime) {
                format = format
                    .replace('HH', 'hh')
                    .replace('H', 'h')
                    .replace(' a', '') + ' a';
            }
            else {
                format = format
                    .replace('hh', 'HH')
                    .replace('h', 'H')
                    .replace('a', '');
            }
        }
        return formatDate(date, format, locale);
    }
    _getCustomTimeFormat(locale, hasSeconds, use12hoursTime) {
        let timeFormat = getLocaleTimeFormat(locale, hasSeconds ? FormatWidth.Medium : FormatWidth.Short);
        if (use12hoursTime) {
            if (!this._timePeriodRegex.test(timeFormat)) {
                timeFormat += ' a';
            }
            timeFormat = timeFormat.replace(this._hour24Regex, 'h');
        }
        else {
            timeFormat = timeFormat
                .replace(this._timePeriodRegex, '')
                .replace(this._hour12Regex, 'H')
                .trim();
        }
        return timeFormat;
    }
    _getCustomDateTimeFormat(locale, hasSeconds, use12hoursTime, dateWidth) {
        // Seconds are usually not relevant in the datepicker, but "mediumTime" format typically includes seconds, and
        // "longTime" typically includes both seconds and timezone offset, which are unlikely to be
        // part of user-entered date time strings. For parsing purposes, it makes sense to allow custom formats that
        // combine the "shortTime" format with any of the named date formats. In particular, the "preferred" format
        // combines "shortTime" with "mediumDate"
        return getLocaleDateTimeFormat(locale, FormatWidth.Medium)
            .replace('{1}', getLocaleDateFormat(locale, dateWidth))
            .replace('{0}', this._getCustomTimeFormat(locale, hasSeconds, use12hoursTime));
    }
    _getCustomDateTimeFormats(locale, hasSeconds, use12hoursTime) {
        if (locale.toString() !== this._storedLocale) {
            this._storedLocale = locale.toString();
            // Some locales include additional characters between the date and time portions of the named
            // datetime formats (eg. "medium" format has a comma in German, and an "à" in French);
            // since we want to be as forgiving as possible about how the date and time formats are
            // combined when parsing user input, we should allow some simple combinations that may not
            // correspond to the named formats
            const dateShort = getLocaleDateFormat(locale, FormatWidth.Short);
            const dateMedium = getLocaleDateFormat(locale, FormatWidth.Medium);
            const dateLong = getLocaleDateFormat(locale, FormatWidth.Long);
            const timeShort12 = this._getCustomTimeFormat(locale, false, true);
            const timeShort12s = this._getCustomTimeFormat(locale, true, true);
            const timeShort24 = this._getCustomTimeFormat(locale, false, false);
            const timeShort24s = this._getCustomTimeFormat(locale, true, false);
            this._storedDateTimeFormats = [
                this._getCustomDateTimeFormat(locale, hasSeconds, use12hoursTime, FormatWidth.Short),
                this._getCustomDateTimeFormat(locale, hasSeconds, !use12hoursTime, FormatWidth.Short),
                this._getCustomDateTimeFormat(locale, !hasSeconds, use12hoursTime, FormatWidth.Short),
                this._getCustomDateTimeFormat(locale, !hasSeconds, !use12hoursTime, FormatWidth.Short),
                this._getCustomDateTimeFormat(locale, hasSeconds, use12hoursTime, FormatWidth.Medium),
                this._getCustomDateTimeFormat(locale, hasSeconds, !use12hoursTime, FormatWidth.Medium),
                this._getCustomDateTimeFormat(locale, !hasSeconds, use12hoursTime, FormatWidth.Medium),
                this._getCustomDateTimeFormat(locale, !hasSeconds, !use12hoursTime, FormatWidth.Medium),
                this._getCustomDateTimeFormat(locale, hasSeconds, use12hoursTime, FormatWidth.Long),
                this._getCustomDateTimeFormat(locale, hasSeconds, !use12hoursTime, FormatWidth.Long),
                this._getCustomDateTimeFormat(locale, !hasSeconds, use12hoursTime, FormatWidth.Long),
                this._getCustomDateTimeFormat(locale, !hasSeconds, !use12hoursTime, FormatWidth.Long),
                `${dateShort} ${timeShort12}`,
                `${dateShort} ${timeShort12s}`,
                `${dateShort} ${timeShort24}`,
                `${dateShort} ${timeShort24s}`,
                `${dateMedium} ${timeShort12}`,
                `${dateMedium} ${timeShort12s}`,
                `${dateMedium} ${timeShort24}`,
                `${dateMedium} ${timeShort24s}`,
                `${dateLong} ${timeShort12}`,
                `${dateLong} ${timeShort12s}`,
                `${dateLong} ${timeShort24}`,
                `${dateLong} ${timeShort24s}`,
                `${timeShort12}`,
                `${timeShort12s}`,
                `${timeShort24}`,
                `${timeShort24s}`,
                'M/d/y',
                'h',
                'H' // allow time like '6' (24-hours format)
            ];
        }
        return this._storedDateTimeFormats;
    }
    _use12hoursFormat(locale) {
        return /a/.test(getLocaleTimeFormat(locale, FormatWidth.Short));
    }
}
AdaptRxDatetimeDefaultParserFormatter.ɵfac = function AdaptRxDatetimeDefaultParserFormatter_Factory(t) { return new (t || AdaptRxDatetimeDefaultParserFormatter)(i0.ɵɵinject(LOCALE_ID)); };
AdaptRxDatetimeDefaultParserFormatter.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptRxDatetimeDefaultParserFormatter, factory: AdaptRxDatetimeDefaultParserFormatter.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxDatetimeDefaultParserFormatter, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
//# sourceMappingURL=adapt-rx-datetime-parser-formatter.service.js.map