import { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, HostListener, Injector, Input, NgZone, Output, Renderer2 } from '@angular/core';
import { EventManager } from '@angular/platform-browser';
import { ComponentPortal } from '@angular/cdk/portal';
import { Directionality } from '@angular/cdk/bidi';
import { ReplaySubject } from 'rxjs';
import { isFunction, throttle } from 'lodash-es';
import { isNumber, isUndefined, toBoolean } from '../common/utilities';
import { AdaptDeviceDetectionService } from '../common/device-detection.service';
import { AdaptOverlayService, getOverlayConnectedPositions } from '../common/overlay/index';
import { SafeCdr } from '../common/safe-cdr';
import { AdaptTooltipComponent } from './tooltip.component';
import * as i0 from "@angular/core";
import * as i1 from "../common/device-detection.service";
import * as i2 from "@angular/platform-browser";
import * as i3 from "../common/overlay/index";
import * as i4 from "@angular/cdk/bidi";
let _componentRef;
let _domEl;
let id = 0;
const tooltips = {};
const TOOLTIP_OFFSET = 6;
export class AdaptTooltipDirective {
    constructor(elementRef, injector, componentFactoryResolver, appRef, ngZone, _renderer, _detectService, _eventManager, _overlayService, _dir) {
        this.elementRef = elementRef;
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.ngZone = ngZone;
        this._renderer = _renderer;
        this._detectService = _detectService;
        this._eventManager = _eventManager;
        this._overlayService = _overlayService;
        this._dir = _dir;
        /* eslint-disable @angular-eslint/no-input-rename */
        /**
         * Popup delay in milliseconds until it opens
         * @docs-default 200
         */
        this.delay = 200;
        this.useWidthFitting = true;
        this.adaptRadarDisableEventSending = false;
        /**
         * Emits an event when the tooltip is shown
         */
        this.shown = new EventEmitter();
        /**
         * Emits an event when the tooltip is hidden
         */
        this.hidden = new EventEmitter();
        this._updateTooltipPositionThrottled = throttle(this.updateTooltipPosition.bind(this), 50);
        this._manual = false;
        this._isMobile = false;
        this._mousePoint = { x: 0, y: 0 };
        this._destroyed$ = new ReplaySubject(1);
        this._id = id++;
        tooltips[id] = this;
        this._overlayConnectedPositions = getOverlayConnectedPositions(this._dir.value, TOOLTIP_OFFSET);
        this._tooltipOverlayPlacements = [
            this._overlayConnectedPositions.top,
            this._overlayConnectedPositions.left,
            this._overlayConnectedPositions.right,
            this._overlayConnectedPositions.bottom,
            this._overlayConnectedPositions['left-top'],
            this._overlayConnectedPositions['left-bottom'],
            this._overlayConnectedPositions['right-top'],
            this._overlayConnectedPositions['right-bottom'],
            this._overlayConnectedPositions['top-left'],
            this._overlayConnectedPositions['top-right'],
            this._overlayConnectedPositions['bottom-left'],
            this._overlayConnectedPositions['bottom-right']
        ];
    }
    /**
     * Content to be displayed as tooltip. If falsy, the tooltip won't open.
     * If you pass the value via the Func1<TooltipValue, ElementRef<HTMLElement>>
     * the calculation will be precessed directly before the tooltip showing or updating
     */
    set adaptTooltip(content) {
        this._tooltipContent = content;
        if (!content && _componentRef) {
            _componentRef.instance.visible = false;
        }
    }
    get manual() {
        return this._manual;
    }
    set manual(v) {
        this._manual = toBoolean(v);
    }
    mouseEnter(e) {
        if (this.manual) {
            return;
        }
        if (this._overlayService.enableCDKOverlayControl) {
            this._openOverlay();
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this._removeHostMouseMoveListener
                = this._eventManager.addEventListener(this.elementRef.nativeElement, 'mousemove', this._updateTooltipPositionThrottled);
        });
        const { clientX, clientY } = e;
        this.updateCoordinates(clientX, clientY);
        this.updateTooltipData();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mouseLeave(e) {
        if (this.manual) {
            return;
        }
        this.close();
        if (this._removeHostMouseMoveListener) {
            this._removeHostMouseMoveListener();
            this._removeHostMouseMoveListener = null;
        }
    }
    focus(e) {
        if (this.manual) {
            return;
        }
        if (this._overlayService.enableCDKOverlayControl && !this.manual) {
            this._openOverlay(true);
            return;
        }
        const { x, y } = e.target.getClientRects()[0];
        this.updateCoordinates(x, y);
        this.updateTooltipData();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    blur(e) {
        if (this.manual) {
            return;
        }
        if (this._overlayService.enableCDKOverlayControl) {
            this._closeOverlay();
            return;
        }
        if (this._removeHostMouseMoveListener) {
            this._removeHostMouseMoveListener();
            this._removeHostMouseMoveListener = null;
        }
        this.close();
    }
    ngOnInit() {
        this._isMobile = this._detectService.isMobile();
        this.placement = isUndefined(this.placement) && this.manual ? 'top' : this.placement;
    }
    ngOnDestroy() {
        if (this.isOpen()) {
            this.toggle();
        }
        delete tooltips[this._id];
        const tooltipsCount = Object.keys(tooltips).length;
        if (!tooltipsCount && _componentRef) {
            _componentRef.destroy();
        }
        if (!tooltipsCount && _domEl) {
            _domEl.remove();
        }
        clearTimeout(this._delayTimer);
        // Release memory via unlink Injector
        this.injector = null;
        if (this._removeHostMouseMoveListener) {
            this._removeHostMouseMoveListener();
            this._removeHostMouseMoveListener = null;
        }
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    open() {
        if (this._overlayService.enableCDKOverlayControl) {
            this._openOverlay();
            return;
        }
        if (_componentRef) {
            this.updateTooltipData();
        }
    }
    close() {
        if (this._overlayService.enableCDKOverlayControl) {
            this._closeOverlay();
            return;
        }
        if (_componentRef) {
            _componentRef.instance.visible = false;
            this.hidden.emit();
            this._removeAriaAttributes();
            clearTimeout(this._delayTimer);
        }
    }
    isOpen() {
        if (this._overlayService.enableCDKOverlayControl) {
            return !!this._tooltipOverlayWithPortal;
        }
        if (_componentRef) {
            return _componentRef.instance.visible;
        }
        return false;
    }
    toggle() {
        if (this.isOpen()) {
            this.close();
        }
        else {
            this.open();
        }
    }
    _openOverlay(useAutoPlacement) {
        if (this._tooltipOverlayWithPortal) {
            return;
        }
        clearTimeout(this._delayTimer);
        this.ngZone.runOutsideAngular(() => {
            this._removeHostMouseMoveListener = this._eventManager.addEventListener(this.elementRef.nativeElement, 'mousemove', ({ clientX, clientY }) => {
                this._mousePoint.x = clientX;
                this._mousePoint.y = clientY;
                if (this._tooltipOverlayWithPortal) {
                    this._tooltipOverlayWithPortal.overlayRef.updatePosition();
                }
            });
        });
        this._delayTimer = window.setTimeout(() => {
            const connectedPositions = [];
            if (this.placement || useAutoPlacement) {
                if (this.placement && this.placement !== 'auto') {
                    connectedPositions.push(this._overlayConnectedPositions[this.placement]);
                }
                connectedPositions.push(...this._tooltipOverlayPlacements);
                this._tooltipOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptTooltipComponent, null, this.injector), {
                    origin: this.elementRef.nativeElement,
                    positionStrategy: 'connected',
                    scrollStrategy: 'close',
                    connectedPositions: connectedPositions
                });
            }
            else {
                this._tooltipOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptTooltipComponent, null, this.injector), {
                    origin: this._mousePoint,
                    positionStrategy: 'float',
                    scrollStrategy: 'close'
                });
                this._tooltipOverlayWithPortal.overlayRef.updatePosition();
            }
            const tooltipContent = isFunction(this._tooltipContent) ? this._tooltipContent(this.elementRef) : this._tooltipContent;
            if (tooltipContent) {
                this._tooltipOverlayWithPortal.componentRef.instance.content = tooltipContent;
                this._tooltipOverlayWithPortal.componentRef.instance.visible = true;
            }
            this._tooltipOverlayWithPortal.componentRef.instance.setMinWidth(this.minWidth ? this.minWidth + 'px' : null);
            this.calculateWidth();
            this._tooltipOverlayWithPortal.componentRef.instance.width = this._processedWidth;
            this._tooltipOverlayWithPortal.componentRef.instance.adaptRadarDisableEventSending = this.adaptRadarDisableEventSending;
            this.shown.emit();
            this._setOverlayAriaAttributes();
            if (AdaptTooltipDirective.activeTooltip && AdaptTooltipDirective.activeTooltip !== this) {
                AdaptTooltipDirective.activeTooltip.close();
            }
            AdaptTooltipDirective.activeTooltip = this;
        }, this.delay);
    }
    _closeOverlay() {
        clearTimeout(this._delayTimer);
        if (this._tooltipOverlayWithPortal) {
            this._tooltipOverlayWithPortal.destroy();
            this._tooltipOverlayWithPortal = null;
            if (this._removeHostMouseMoveListener) {
                this._removeHostMouseMoveListener();
            }
            this.hidden.emit();
            this._removeAriaAttributes();
        }
    }
    updateTooltipPosition(e) {
        const { clientX, clientY } = e;
        this.updateCoordinates(clientX, clientY);
        if (isUndefined(this.placement)) {
            _componentRef.instance.updatePosition(this._x, this._y);
        }
    }
    isExist() {
        return !!_componentRef && !!_domEl;
    }
    updateTooltipData() {
        if (!this.isExist()) {
            this.createComponent();
        }
        if (this._isMobile) {
            return;
        }
        clearTimeout(this._delayTimer);
        this._delayTimer = window.setTimeout(() => {
            const tooltipContent = isFunction(this._tooltipContent) ? this._tooltipContent(this.elementRef) : this._tooltipContent;
            if (tooltipContent) {
                _componentRef.instance.content = tooltipContent;
                _componentRef.instance.id = `${this._id}`;
                _componentRef.instance.visible = true;
            }
            _componentRef.instance.placement = this.placement;
            _componentRef.instance.useWidthFitting = this.useWidthFitting;
            _componentRef.instance.adaptRadarDisableEventSending = this.adaptRadarDisableEventSending;
            this.calculateWidth();
            _componentRef.instance.width = this._processedWidth;
            if (isUndefined(this.placement)) {
                _componentRef.instance.updatePosition(this._x, this._y);
            }
            else {
                _componentRef.instance.setPosition(this.elementRef.nativeElement);
            }
            _componentRef.instance.setMinWidth(this.minWidth ? this.minWidth + 'px' : null);
            this.shown.emit();
            this._setAriaAttributes();
        }, this.delay);
    }
    calculateWidth() {
        let tempWidth = 'initial';
        // if width is not defined we need to reset it with fit-content
        if (this.width) {
            // we accept pixels in width attribute
            if (isNumber(this.width)) { // if user pass width angular way like [width]="40"
                tempWidth = this.width + 'px';
            }
            else if (parseInt(this.width, 10)) { // if user pass width without brackets like width="40"
                tempWidth = this.width + 'px';
            }
            else { // if user pass something else like width="'auto'"
                tempWidth = this.width;
            }
        }
        this._processedWidth = tempWidth;
    }
    createComponent() {
        const componentRef = this.componentFactoryResolver
            .resolveComponentFactory(AdaptTooltipComponent)
            .create(this.injector);
        // once AdaptTooltipModule is only one module in the project
        // user may observe a component artifact visible on the page.
        // For this reason, we have to manually call change detection
        // and not wait next change detection cycle that covers dynamic component
        // so ngOnInit will be called and styles to hide the component view will be applied
        SafeCdr.detectChanges(componentRef.changeDetectorRef);
        this.appRef.attachView(componentRef.hostView);
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const domElem = componentRef.hostView
            .rootNodes[0];
        document.body.appendChild(domElem);
        _componentRef = componentRef;
        _domEl = domElem;
    }
    updateCoordinates(x, y) {
        this._x = x;
        this._y = y;
    }
    _setOverlayAriaAttributes() {
        this._tooltipOverlayWithPortal.componentRef.instance.id = `${this._id}`;
        this._setAriaAttributes();
    }
    _removeAriaAttributes() {
        if (this._ariaDescribedBy) {
            this._renderer.setAttribute(this.elementRef.nativeElement, 'aria-describedby', this._ariaDescribedBy);
        }
        else {
            this._renderer.removeAttribute(this.elementRef.nativeElement, 'aria-describedby');
        }
    }
    _setAriaAttributes() {
        this._ariaDescribedBy = this.elementRef.nativeElement.getAttribute('aria-describedby');
        this._renderer.setAttribute(this.elementRef.nativeElement, 'aria-describedby', this._ariaDescribedBy && this._ariaDescribedBy !== `${this._id}` ? [this._ariaDescribedBy, `${this._id}`].join(' ') : `${this._id}`);
    }
}
AdaptTooltipDirective.activeTooltip = null;
AdaptTooltipDirective.ɵfac = function AdaptTooltipDirective_Factory(t) { return new (t || AdaptTooltipDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i2.EventManager), i0.ɵɵdirectiveInject(i3.AdaptOverlayService), i0.ɵɵdirectiveInject(i4.Directionality)); };
AdaptTooltipDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTooltipDirective, selectors: [["", "adaptTooltip", ""]], hostBindings: function AdaptTooltipDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("mouseenter", function AdaptTooltipDirective_mouseenter_HostBindingHandler($event) { return ctx.mouseEnter($event); })("mouseleave", function AdaptTooltipDirective_mouseleave_HostBindingHandler($event) { return ctx.mouseLeave($event); })("focus", function AdaptTooltipDirective_focus_HostBindingHandler($event) { return ctx.focus($event); })("blur", function AdaptTooltipDirective_blur_HostBindingHandler($event) { return ctx.blur($event); });
    } }, inputs: { delay: ["popupDelay", "delay"], placement: "placement", width: "width", minWidth: "minWidth", useWidthFitting: "useWidthFitting", adaptRadarDisableEventSending: "adaptRadarDisableEventSending", adaptTooltip: "adaptTooltip", manual: "manual" }, outputs: { shown: "shown", hidden: "hidden" }, exportAs: ["tooltip"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTooltipDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptTooltip]',
                exportAs: 'tooltip'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Injector }, { type: i0.ComponentFactoryResolver }, { type: i0.ApplicationRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.AdaptDeviceDetectionService }, { type: i2.EventManager }, { type: i3.AdaptOverlayService }, { type: i4.Directionality }]; }, { delay: [{
            type: Input,
            args: ['popupDelay']
        }], placement: [{
            type: Input
        }], width: [{
            type: Input
        }], minWidth: [{
            type: Input
        }], useWidthFitting: [{
            type: Input
        }], adaptRadarDisableEventSending: [{
            type: Input
        }], shown: [{
            type: Output
        }], hidden: [{
            type: Output
        }], adaptTooltip: [{
            type: Input
        }], manual: [{
            type: Input
        }], mouseEnter: [{
            type: HostListener,
            args: ['mouseenter', ['$event']]
        }], mouseLeave: [{
            type: HostListener,
            args: ['mouseleave', ['$event']]
        }], focus: [{
            type: HostListener,
            args: ['focus', ['$event']]
        }], blur: [{
            type: HostListener,
            args: ['blur', ['$event']]
        }] }); })();
//# sourceMappingURL=tooltip.directive.js.map