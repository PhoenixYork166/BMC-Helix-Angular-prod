import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, Output, Renderer2, ViewChild } from '@angular/core';
import { trigger } from '@angular/animations';
import { ReplaySubject } from 'rxjs';
import { distinctUntilChanged, map, takeUntil } from 'rxjs/operators';
import { isNil, isUndefined } from 'lodash-es';
import { GetAngle, GetDistance, GetDragNDrop } from '../../../common/drag-n-drop';
import { ZOOM_ANIMATION } from '../common/common.utils';
import { SafeCdr } from '../../../common/safe-cdr';
import { AdaptRxDatetimeConfigService } from '../adapt-rx-datetime-config.service';
import { RxClockFace, RxClockMode } from '../adapt-rx-datetime.types';
import { getClockTicks } from './adapt-rx-clock-ticks';
import * as i0 from "@angular/core";
import * as i1 from "../adapt-rx-datetime-config.service";
import * as i2 from "@angular/common";
const _c0 = ["dndContainerRef"];
function AdaptRxClockComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelement(2, "span", 4);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementStart(4, "span", 3);
    i0.ɵɵtext(5);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(4);
    i0.ɵɵclassProp("active", ctx_r0.config.activeMode === ctx_r0.rxClockMode.Seconds);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r0.config.texts.clock.ssBtn);
} }
function AdaptRxClockComponent_button_17_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 11);
    i0.ɵɵlistener("click", function AdaptRxClockComponent_button_17_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.changeMeridiem(); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 3);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelement(5, "span", 4);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementStart(7, "span", 3);
    i0.ɵɵtext(8);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("disabled", ctx_r1.config.disabled);
    i0.ɵɵattribute("data-testid", ctx_r1.testID + "_ampm");
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("active", !ctx_r1.isPM);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.config.texts.clock.amBtn);
    i0.ɵɵadvance(4);
    i0.ɵɵclassProp("active", ctx_r1.isPM);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r1.config.texts.clock.pmBtn);
} }
function AdaptRxClockComponent_div_23_ng_template_2_Template(rf, ctx) { }
const _c1 = function (a0, a1) { return { $implicit: a0, active: a1 }; };
function AdaptRxClockComponent_div_23_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 12);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptRxClockComponent_div_23_ng_template_2_Template, 0, 0, "ng-template", 13);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    const _r6 = i0.ɵɵreference(32);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r6)("ngTemplateOutletContext", i0.ɵɵpureFunction2(2, _c1, ctx_r3.clockFaceTicks.hours, ctx_r3.uiValue.hours));
} }
function AdaptRxClockComponent_div_25_ng_template_2_Template(rf, ctx) { }
function AdaptRxClockComponent_div_25_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 12);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptRxClockComponent_div_25_ng_template_2_Template, 0, 0, "ng-template", 13);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    const _r6 = i0.ɵɵreference(32);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r6)("ngTemplateOutletContext", i0.ɵɵpureFunction2(2, _c1, ctx_r4.clockFaceTicks.minutes, ctx_r4.uiValue.minutes));
} }
function AdaptRxClockComponent_div_27_ng_template_2_Template(rf, ctx) { }
function AdaptRxClockComponent_div_27_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 12);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵtemplate(2, AdaptRxClockComponent_div_27_ng_template_2_Template, 0, 0, "ng-template", 13);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext();
    const _r6 = i0.ɵɵreference(32);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r6)("ngTemplateOutletContext", i0.ɵɵpureFunction2(2, _c1, ctx_r5.clockFaceTicks.seconds, ctx_r5.uiValue.seconds));
} }
function AdaptRxClockComponent_ng_template_31_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 17);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "div", 18);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelement(5, "div", 19);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelement(7, "div", 20);
    i0.ɵɵtext(8, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const label_r18 = ctx.$implicit;
    const index_r19 = ctx.index;
    const ticksSet_r16 = i0.ɵɵnextContext().$implicit;
    const active_r14 = i0.ɵɵnextContext().active;
    const ctx_r17 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("transform", "rotate(" + index_r19 / ticksSet_r16.length * 360 + "deg)");
    i0.ɵɵclassProp("a3t-clock--tick_active", label_r18.value === active_r14);
    i0.ɵɵattribute("data-testid", ctx_r17.testID + "_tick_" + index_r19 / ticksSet_r16.length * 360);
    i0.ɵɵadvance(2);
    i0.ɵɵstyleProp("transform", "rotate(" + -index_r19 / ticksSet_r16.length * 360 + "deg)");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n        ", label_r18.uiValue, "\n      ");
} }
function AdaptRxClockComponent_ng_template_31_div_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 15);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptRxClockComponent_ng_template_31_div_1_div_2_Template, 9, 8, "div", 16);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ticksSet_r16 = ctx.$implicit;
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ticksSet_r16);
} }
function AdaptRxClockComponent_ng_template_31_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵtemplate(1, AdaptRxClockComponent_ng_template_31_div_1_Template, 4, 1, "div", 14);
    i0.ɵɵtext(2, "\n");
} if (rf & 2) {
    const ticks_r13 = ctx.$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ticks_r13);
} }
export class AdaptRxClockComponent {
    constructor(_datetimeConfigService, _renderer, _changeDetectorRef) {
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.config = {
            activeMode: RxClockMode.Hours,
            activeTime: undefined,
            initialTime: undefined,
            use12HoursTime: false,
            hasSeconds: false,
            disabled: false,
            texts: undefined
        };
        this.isPM = false;
        this.rxClockMode = RxClockMode;
        this.clockFaceTicks = {
            hours: AdaptRxClockComponent.Hours24Ticks,
            minutes: AdaptRxClockComponent.MinutesTicks,
            seconds: AdaptRxClockComponent.SecondsTicks
        };
        this.uiValue = {
            hours: null,
            minutes: null,
            seconds: null
        };
        /* eslint-disable @angular-eslint/no-output-on-prefix */
        /**
         * An event firing on clock mode change
         */
        this.onModeChange = new EventEmitter();
        /**
         * An event firing on time change
         * It happens on each drag end
         */
        this.onTimeChange = new EventEmitter();
        /**
         * An event firing on hoursLabel change
         * It happens on while dragging
         */
        this.onHoursChange = new EventEmitter();
        /**
         * An event firing on minutesLabel change
         * It happens on while dragging
         */
        this.onMinutesChange = new EventEmitter();
        /**
         * An event firing on secondsLabel change
         * It happens on while dragging
         */
        this.onSecondsChange = new EventEmitter();
        this._innerFaceTouchAreaSize = .65; // part of the face radius
        this._faceSize = 220;
        this._destroyed$ = new ReplaySubject(1);
        this.config.texts = _datetimeConfigService.texts;
    }
    ngOnInit() {
        this._initDragNDrop();
    }
    ngOnChanges(changes) {
        if (changes.hasSeconds && !isNil(changes.hasSeconds.currentValue)) {
            this.config.hasSeconds = changes.hasSeconds.currentValue;
        }
        if (changes.activeMode && !isUndefined(changes.activeMode.currentValue)) {
            this.gotoNextFace(changes.activeMode.currentValue);
        }
        if (changes.activeTime && !isUndefined(changes.activeTime.currentValue)) {
            this.config.activeTime = changes.activeTime.currentValue;
            this._updateUIValue();
            this._checkMeridiem();
        }
        if (changes.use12HoursTime && !isNil(changes.use12HoursTime.currentValue)) {
            this.config.use12HoursTime = changes.use12HoursTime.currentValue;
            this._checkMeridiem();
        }
        if (changes.initialTime && !isUndefined(changes.initialTime.currentValue)) {
            this.config.initialTime = changes.initialTime.currentValue;
            this._updateUIValue();
            this._checkMeridiem();
        }
        if (changes.disabled && !isNil(changes.disabled.currentValue)) {
            this.config.disabled = changes.disabled.currentValue;
        }
        if (changes.texts && !isNil(changes.texts.currentValue)) {
            Object.assign(this.config.texts, changes.texts.currentValue);
        }
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    /**
     * Change time use12HoursTime
     */
    changeMeridiem() {
        this.isPM = !this.isPM;
        if (this.config.activeTime) {
            if (this.config.use12HoursTime) {
                if (this.isPM) {
                    this.config.activeTime.hours = this.uiValue.hours === 12 ? 12 : this.uiValue.hours + 12;
                }
                else {
                    this.config.activeTime.hours = this.uiValue.hours === 12 ? 0 : this.uiValue.hours;
                }
            }
            this.onTimeChange.emit(this.config.activeTime);
            this.onHoursChange.emit(this.config.activeTime.hours);
        }
    }
    /**
     * Change clock mode
     */
    gotoNextFace(nextFace) {
        if (nextFace === this.config.activeMode) {
            return;
        }
        if (nextFace === null) {
            nextFace = (this.config.activeMode + 1) % (this.config.hasSeconds ? 3 : 2);
        }
        switch (nextFace) {
            case RxClockMode.Hours: {
                this.config.activeMode = RxClockMode.Hours;
                break;
            }
            case RxClockMode.Minutes: {
                this.config.activeMode = RxClockMode.Minutes;
                break;
            }
            case RxClockMode.Seconds: {
                if (this.config.hasSeconds) {
                    this.config.activeMode = RxClockMode.Seconds;
                }
                else {
                    this.config.activeMode = RxClockMode.Hours;
                }
                break;
            }
        }
        this.onModeChange.emit(this.config.activeMode);
    }
    /**
     * Check activeTime according to use12HoursTime
     */
    _checkMeridiem() {
        if (this.config.use12HoursTime) {
            this.clockFaceTicks.hours = AdaptRxClockComponent.Hours12Ticks;
            if (this.config.activeTime && !isNil(this.config.activeTime.hours)) {
                this.isPM = this.config.activeTime.hours >= 12;
                this.uiValue.hours = (this.config.activeTime.hours % 12) || 12;
            }
        }
        else {
            this.clockFaceTicks.hours = AdaptRxClockComponent.Hours24Ticks;
        }
    }
    /**
     * Drag and drop initialization
     */
    _initDragNDrop() {
        this._renderer.setStyle(this.dndContainerRef.nativeElement, 'width', `${this._faceSize}px`);
        this._renderer.setStyle(this.dndContainerRef.nativeElement, 'height', `${this._faceSize}px`);
        let centerX;
        let centerY;
        const dragStart = () => {
            const elRect = this.dndContainerRef.nativeElement.getBoundingClientRect();
            centerX = elRect.left + elRect.width / 2;
            centerY = elRect.top + elRect.height / 2;
        };
        const dragEnd = () => {
            this.onTimeChange.emit(this.config.activeTime);
        };
        GetDragNDrop(this.dndContainerRef.nativeElement, null, null, dragStart, dragEnd)
            .pipe(map(moveCoords => {
            if (this.config.disabled) {
                return;
            }
            const angle = Math.round(GetAngle(centerX, centerY, moveCoords.x, moveCoords.y) * 100) / 100;
            const distance = Math.round(GetDistance(centerX, centerY, moveCoords.x, moveCoords.y) * 100) / 100;
            return { angle: angle, distanceFromCenter: distance };
        }), distinctUntilChanged(), takeUntil(this._destroyed$))
            .subscribe(this._touchPointChange.bind(this));
    }
    /**
     * Drag and drop handler
     */
    _touchPointChange(touchPoint) {
        if (touchPoint) {
            const newValue = Object.assign({}, this.config.activeTime);
            switch (this.config.activeMode) {
                case RxClockMode.Hours: {
                    this.uiValue.hours = this._getClockFaceTick(touchPoint, this.clockFaceTicks.hours).value;
                    newValue.hours = this.uiValue.hours;
                    if (this.config.use12HoursTime) {
                        if (this.isPM) {
                            newValue.hours = newValue.hours === 12 ? 12 : newValue.hours + 12;
                        }
                        else {
                            newValue.hours = newValue.hours === 12 ? 0 : newValue.hours;
                        }
                    }
                    this.onHoursChange.emit(newValue.hours);
                    break;
                }
                case RxClockMode.Minutes: {
                    this.uiValue.minutes = this._getClockFaceTick(touchPoint, this.clockFaceTicks.minutes).value;
                    newValue.minutes = this.uiValue.minutes;
                    this.onMinutesChange.emit(newValue.minutes);
                    break;
                }
                case RxClockMode.Seconds: {
                    this.uiValue.seconds = this._getClockFaceTick(touchPoint, this.clockFaceTicks.seconds).value;
                    newValue.seconds = this.uiValue.seconds;
                    this.onSecondsChange.emit(newValue.seconds);
                    break;
                }
            }
            this.config.activeTime = Object.assign({}, newValue);
            SafeCdr.detectChanges(this._changeDetectorRef);
        }
    }
    /**
     * Returns clock face activeTime according to touch point location
     */
    _getClockFaceTick(touchPoint, activeFaceTicks) {
        const actualTicksSet = (activeFaceTicks.length === 1) || (touchPoint.distanceFromCenter > this._faceSize / 2 * this._innerFaceTouchAreaSize) ?
            activeFaceTicks[0] : activeFaceTicks[1];
        return actualTicksSet[Math.round(touchPoint.angle * actualTicksSet.length / 360) % actualTicksSet.length];
    }
    _updateUIValue() {
        var _a, _b, _c;
        if (this.config.initialTime) {
            this.config.activeTime = {
                hours: isNil((_a = this.config.activeTime) === null || _a === void 0 ? void 0 : _a.hours) ? this.config.initialTime.hours : this.config.activeTime.hours,
                minutes: isNil((_b = this.config.activeTime) === null || _b === void 0 ? void 0 : _b.minutes) ? this.config.initialTime.minutes : this.config.activeTime.minutes,
                seconds: isNil((_c = this.config.activeTime) === null || _c === void 0 ? void 0 : _c.seconds) ? this.config.initialTime.seconds : this.config.activeTime.seconds,
            };
        }
        this.uiValue = Object.assign({}, this.config.activeTime);
    }
}
AdaptRxClockComponent.Hours24Ticks = getClockTicks(RxClockFace.Hours24);
AdaptRxClockComponent.Hours12Ticks = getClockTicks(RxClockFace.Hours12);
AdaptRxClockComponent.MinutesTicks = getClockTicks(RxClockFace.Minutes);
AdaptRxClockComponent.SecondsTicks = getClockTicks(RxClockFace.Seconds);
AdaptRxClockComponent.ɵfac = function AdaptRxClockComponent_Factory(t) { return new (t || AdaptRxClockComponent)(i0.ɵɵdirectiveInject(i1.AdaptRxDatetimeConfigService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptRxClockComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxClockComponent, selectors: [["adapt-rx-clock"]], viewQuery: function AdaptRxClockComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dndContainerRef = _t.first);
    } }, inputs: { activeMode: "activeMode", activeTime: "activeTime", initialTime: "initialTime", use12HoursTime: "use12HoursTime", hasSeconds: "hasSeconds", disabled: "disabled", texts: "texts", testID: "testID" }, outputs: { onModeChange: "onModeChange", onTimeChange: "onTimeChange", onHoursChange: "onHoursChange", onMinutesChange: "onMinutesChange", onSecondsChange: "onSecondsChange" }, features: [i0.ɵɵNgOnChangesFeature], decls: 34, vars: 16, consts: [[1, "a3t-clock"], [1, "a3t-clock--controls"], ["type", "button", "tabindex", "-1", 1, "a3t-clock--control-btn", "m-end-2", 3, "disabled", "click"], [1, "a3t-clock--control-item"], [1, "a3t-clock--control-separator"], [4, "ngIf"], ["type", "button", "tabindex", "-1", "class", "a3t-clock--control-btn", 3, "disabled", "click", 4, "ngIf"], [1, "a3t-clock--faces"], ["dndContainerRef", ""], ["style", "position:absolute; width: 100%; height: 100%", 4, "ngIf"], ["clockFaceTemplate", ""], ["type", "button", "tabindex", "-1", 1, "a3t-clock--control-btn", 3, "disabled", "click"], [2, "position", "absolute", "width", "100%", "height", "100%"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "a3t-clock--face", 4, "ngFor", "ngForOf"], [1, "a3t-clock--face"], ["class", "a3t-clock--tick", 3, "a3t-clock--tick_active", "transform", 4, "ngFor", "ngForOf"], [1, "a3t-clock--tick"], [1, "a3t-clock--tick-label"], [1, "a3t-clock--tick-arrow"], [1, "a3t-clock--tick-center"]], template: function AdaptRxClockComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelementStart(2, "div", 1);
        i0.ɵɵtext(3, "\n    ");
        i0.ɵɵelementStart(4, "button", 2);
        i0.ɵɵlistener("click", function AdaptRxClockComponent_Template_button_click_4_listener() { return ctx.gotoNextFace(null); });
        i0.ɵɵtext(5, "\n      ");
        i0.ɵɵelementStart(6, "span", 3);
        i0.ɵɵtext(7);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n      ");
        i0.ɵɵelement(9, "span", 4);
        i0.ɵɵtext(10, "\n      ");
        i0.ɵɵelementStart(11, "span", 3);
        i0.ɵɵtext(12);
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n      ");
        i0.ɵɵtemplate(14, AdaptRxClockComponent_ng_container_14_Template, 7, 3, "ng-container", 5);
        i0.ɵɵtext(15, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(16, "\n    ");
        i0.ɵɵtemplate(17, AdaptRxClockComponent_button_17_Template, 10, 8, "button", 6);
        i0.ɵɵtext(18, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(19, "\n  ");
        i0.ɵɵelementStart(20, "div", 7, 8);
        i0.ɵɵtext(22, "\n    ");
        i0.ɵɵtemplate(23, AdaptRxClockComponent_div_23_Template, 4, 5, "div", 9);
        i0.ɵɵtext(24, "\n    ");
        i0.ɵɵtemplate(25, AdaptRxClockComponent_div_25_Template, 4, 5, "div", 9);
        i0.ɵɵtext(26, "\n    ");
        i0.ɵɵtemplate(27, AdaptRxClockComponent_div_27_Template, 4, 5, "div", 9);
        i0.ɵɵtext(28, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(29, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(30, "\n\n");
        i0.ɵɵtemplate(31, AdaptRxClockComponent_ng_template_31_Template, 3, 1, "ng-template", null, 10, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(33, "\n");
    } if (rf & 2) {
        i0.ɵɵclassProp("a3t-clock_disabled", ctx.config.disabled);
        i0.ɵɵadvance(4);
        i0.ɵɵproperty("disabled", ctx.config.disabled);
        i0.ɵɵattribute("data-testid", ctx.testID + "_hhmmss");
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("active", ctx.config.activeMode === ctx.rxClockMode.Hours);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.config.texts.clock.hhBtn);
        i0.ɵɵadvance(4);
        i0.ɵɵclassProp("active", ctx.config.activeMode === ctx.rxClockMode.Minutes);
        i0.ɵɵadvance(1);
        i0.ɵɵtextInterpolate(ctx.config.texts.clock.mmBtn);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.config.hasSeconds);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.config.use12HoursTime);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("@zoomAnimation", ctx.config.activeMode);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngIf", ctx.config.activeMode === ctx.rxClockMode.Hours);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.config.activeMode === ctx.rxClockMode.Minutes);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.config.activeMode === ctx.rxClockMode.Seconds);
    } }, directives: [i2.NgIf, i2.NgTemplateOutlet, i2.NgForOf], encapsulation: 2, data: { animation: [
            trigger('zoomAnimation', ZOOM_ANIMATION)
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxClockComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-clock',
                templateUrl: './adapt-rx-clock.component.html',
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('zoomAnimation', ZOOM_ANIMATION)
                ]
            }]
    }], function () { return [{ type: i1.AdaptRxDatetimeConfigService }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, { activeMode: [{
            type: Input
        }], activeTime: [{
            type: Input
        }], initialTime: [{
            type: Input
        }], use12HoursTime: [{
            type: Input
        }], hasSeconds: [{
            type: Input
        }], disabled: [{
            type: Input
        }], texts: [{
            type: Input
        }], testID: [{
            type: Input
        }], onModeChange: [{
            type: Output
        }], onTimeChange: [{
            type: Output
        }], onHoursChange: [{
            type: Output
        }], onMinutesChange: [{
            type: Output
        }], onSecondsChange: [{
            type: Output
        }], dndContainerRef: [{
            type: ViewChild,
            args: ['dndContainerRef', { static: true }]
        }] }); })();
//# sourceMappingURL=adapt-rx-clock.component.js.map