import { Directive, ElementRef, Input, NgZone, Renderer2 } from '@angular/core';
import { TabsControlsTypeDirection } from './tabs-controls.enum';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "../common/radar/adapt-radar";
export class AdaptTabsControlsDirective extends AdaptRadarAngularGenericDirective {
    constructor(_renderer, _el, _ngZone, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptTabsControls);
        this._renderer = _renderer;
        this._el = _el;
        this._ngZone = _ngZone;
        /**
         * set type direction for floating line
         */
        this.direction = TabsControlsTypeDirection.Horizontal;
        this._element = this._el.nativeElement;
    }
    /**
     * Align a floating line to an element
     */
    alignToElement(element) {
        this.show();
        return (typeof requestAnimationFrame !== 'undefined') ? this._ngZone.runOutsideAngular(() => requestAnimationFrame(() => this._setStyles(element))) : this._setStyles(element);
    }
    /**
     * Show floating line in a component
     */
    show() {
        this._renderer.setStyle(this._element, 'visibility', 'visible');
    }
    /**
     * Hide floating line in a component
     */
    hide() {
        this._renderer.setStyle(this._element, 'visibility', 'hidden');
    }
    /**
     * Sets styles based on direction
     */
    _setStyles(element) {
        const left = element ? (element.offsetLeft || 0) + 'px' : 0;
        const width = element ? (element.offsetWidth || 0) + 'px' : 0;
        const top = element ? (element.offsetTop || 0) + 'px' : 0;
        const height = element ? (element.offsetHeight || 0) + 'px' : 0;
        switch (this.direction) {
            case TabsControlsTypeDirection.Vertical:
                this._applyStyles(this._element, { top: `${top}`, height: `${height}` });
                break;
            case TabsControlsTypeDirection.Horizontal:
                this._applyStyles(this._element, { left: `${left}`, width: `${width}` });
                break;
        }
    }
    /**
     * Applies css styles for avoiding a bug in IE 11 with renderer method
     */
    _applyStyles(el, styles) {
        for (const prop in styles) {
            if (Object.prototype.hasOwnProperty.call(styles, prop)) {
                this._renderer.setStyle(el, prop, styles[prop]);
            }
        }
    }
}
AdaptTabsControlsDirective.ɵfac = function AdaptTabsControlsDirective_Factory(t) { return new (t || AdaptTabsControlsDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptTabsControlsDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptTabsControlsDirective, selectors: [["", "adaptTabsControls", ""], ["li", "adapt-tabs-controls", ""]], hostVars: 2, hostBindings: function AdaptTabsControlsDirective_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("adapt-tabs-controls", true);
    } }, inputs: { direction: "direction" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTabsControlsDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptTabsControls], li[adapt-tabs-controls]',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: { '[class.adapt-tabs-controls]': 'true' }
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { direction: [{
            type: Input
        }] }); })();
//# sourceMappingURL=tabs-controls.directive.js.map