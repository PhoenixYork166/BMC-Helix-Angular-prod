import { Component, ElementRef, HostBinding, Inject, Input, NgZone, QueryList, Renderer2, ViewChildren } from '@angular/core';
import { DOCUMENT, Location } from '@angular/common';
import { ActivatedRoute } from '@angular/router';
import { fromEvent, ReplaySubject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import { DomHandler } from 'primeng/dom';
import { AdaptAnimateScrollService } from '../common/scroll/scroll.service';
import { AdaptDeviceDetectionService } from '../common/device-detection.service';
import { AdaptAnchorLinkComponent } from './anchor-link/anchor-link.component';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "../common/scroll/scroll.service";
import * as i2 from "@angular/router";
import * as i3 from "@angular/common";
import * as i4 from "../common/device-detection.service";
import * as i5 from "../common/radar/adapt-radar";
import * as i6 from "./anchor-link/anchor-link.component";
function AdaptAnchorNavigatorComponent_ng_container_0_h6_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "h6", 4);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r4.listHeader);
} }
function AdaptAnchorNavigatorComponent_ng_container_0_ng_template_4_Template(rf, ctx) { }
function AdaptAnchorNavigatorComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptAnchorNavigatorComponent_ng_container_0_h6_2_Template, 2, 1, "h6", 2);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵtemplate(4, AdaptAnchorNavigatorComponent_ng_container_0_ng_template_4_Template, 0, 0, "ng-template", 3);
    i0.ɵɵtext(5, "\n");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    const _r2 = i0.ɵɵreference(5);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.listHeader);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r2);
} }
function AdaptAnchorNavigatorComponent_ng_container_2_ng_template_2_Template(rf, ctx) { }
function AdaptAnchorNavigatorComponent_ng_container_2_div_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 7);
} }
function AdaptAnchorNavigatorComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r9 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptAnchorNavigatorComponent_ng_container_2_ng_template_2_Template, 0, 0, "ng-template", 3);
    i0.ɵɵtext(3, "\n  ");
    i0.ɵɵelementStart(4, "div", 5);
    i0.ɵɵlistener("click", function AdaptAnchorNavigatorComponent_ng_container_2_Template_div_click_4_listener($event) { i0.ɵɵrestoreView(_r9); const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.toggleNavigatorVisibility($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n\n  ");
    i0.ɵɵtemplate(6, AdaptAnchorNavigatorComponent_ng_container_2_div_6_Template, 1, 0, "div", 6);
    i0.ɵɵtext(7, "\n");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    const _r2 = i0.ɵɵreference(5);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r2);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", ctx_r1.isNavigatorVisible);
} }
function AdaptAnchorNavigatorComponent_ng_template_4_li_3_ul_4_li_2_Template(rf, ctx) { if (rf & 1) {
    const _r16 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li", 15);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "adapt-anchor-link", 11);
    i0.ɵɵlistener("onLinkClick", function AdaptAnchorNavigatorComponent_ng_template_4_li_3_ul_4_li_2_Template_adapt_anchor_link_onLinkClick_2_listener($event) { i0.ɵɵrestoreView(_r16); const ctx_r15 = i0.ɵɵnextContext(4); return ctx_r15.scrollTo($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const t_r14 = ctx.$implicit;
    const ctx_r13 = i0.ɵɵnextContext(4);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("item", t_r14)("isMobile", ctx_r13.isMobile)("isNavigatorVisible", ctx_r13.isNavigatorVisible);
} }
function AdaptAnchorNavigatorComponent_ng_template_4_li_3_ul_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "ul", 13);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptAnchorNavigatorComponent_ng_template_4_li_3_ul_4_li_2_Template, 4, 3, "li", 14);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r11 = i0.ɵɵnextContext().$implicit;
    const ctx_r12 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", item_r11.children)("ngForTrackBy", ctx_r12.trackByFn);
} }
const _c0 = function (a0) { return { "has-child": a0 }; };
function AdaptAnchorNavigatorComponent_ng_template_4_li_3_Template(rf, ctx) { if (rf & 1) {
    const _r19 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "li", 10);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "adapt-anchor-link", 11);
    i0.ɵɵlistener("onLinkClick", function AdaptAnchorNavigatorComponent_ng_template_4_li_3_Template_adapt_anchor_link_onLinkClick_2_listener($event) { i0.ɵɵrestoreView(_r19); const ctx_r18 = i0.ɵɵnextContext(2); return ctx_r18.scrollTo($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n\n      ");
    i0.ɵɵtemplate(4, AdaptAnchorNavigatorComponent_ng_template_4_li_3_ul_4_Template, 4, 2, "ul", 12);
    i0.ɵɵtext(5, "\n\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r11 = ctx.$implicit;
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(5, _c0, item_r11.children == null ? null : item_r11.children.length));
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("item", item_r11)("isMobile", ctx_r10.isMobile)("isNavigatorVisible", ctx_r10.isNavigatorVisible);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", item_r11.children == null ? null : item_r11.children.length);
} }
function AdaptAnchorNavigatorComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "ul", 8);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵtemplate(3, AdaptAnchorNavigatorComponent_ng_template_4_li_3_Template, 6, 7, "li", 9);
    i0.ɵɵtext(4, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(5, "\n");
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngForOf", ctx_r3.list)("ngForTrackBy", ctx_r3.trackByFn);
} }
export class AdaptAnchorNavigatorComponent extends AdaptRadarAngularGenericDirective {
    constructor(_element, _ngZone, _renderer, _animateScrollService, 
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    document, // https://github.com/angular/angular/issues/20351
    _activatedRouter, _location, _device, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptAnchorNavigator);
        this._element = _element;
        this._ngZone = _ngZone;
        this._renderer = _renderer;
        this._animateScrollService = _animateScrollService;
        this.document = document;
        this._activatedRouter = _activatedRouter;
        this._location = _location;
        this._device = _device;
        this.isMobile = false;
        this.isNavigatorVisible = false;
        /**
         * DOM node class used to mark blocks for navigation
         * @docs-default _scroll-spy
         */
        this.anchorBlockClass = '_scroll-spy';
        /**
         * The distance in pixels above scroll target where the animation should stop.
         * Setting a positive number results in the scroll target being more in the middle of the screen, negative numbers will produce scrolling "too far"
         * @docs-default 0
         */
        this.scrollOffset = 0;
        /**
         * The duration how long a scrollTo animation should last by default
         * @docs-default 400
         */
        this.scrollDuration = 400;
        this.defaultClass = true;
        this._fragment = '';
        this._dotSize = 7; // should be consistent to the CSS dimensions - $an-link-title-dot-indicator-size variable
        this._destroyed$ = new ReplaySubject(1);
        this._scrollContainer = this.document.body;
        this._isViewInitialized = false;
        // in case page has been loaded with already preset url fragment
        this._fragment = _activatedRouter.snapshot.fragment;
    }
    /**
     * Container for anchors to detect the scroll events on
     * @since v10.6.0
     * @docs-default document.body
     */
    set scrollContainer(elem) {
        if (elem) {
            this._scrollContainer = elem;
        }
        // if a component's view is not fully initialized
        // no need to perform any action on applying line animation
        if (!this._isViewInitialized) {
            return;
        }
        this._setInitialContainerScroll();
    }
    ngOnInit() {
        this.isMobile = this._device.deviceMobile();
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._ngZone.runOutsideAngular(() => {
            fromEvent(this.document, 'click')
                .pipe(filter(() => this.isMobile), takeUntil(this._destroyed$))
                .subscribe(() => {
                this._ngZone.run(() => this.isNavigatorVisible = false);
            });
        });
        // querying on the document.body
        this._anchorContentItems = this.document.body.querySelectorAll(`.${this.anchorBlockClass}`);
        this._isViewInitialized = true;
        this._setInitialContainerScroll();
    }
    toggleNavigatorVisibility(event) {
        event.stopPropagation();
        this.isNavigatorVisible = !this.isNavigatorVisible;
    }
    scrollTo(item) {
        const elementID = item.href.substring(item.href.lastIndexOf('#') + 1);
        this._animateScrollService.scrollToElement(elementID, this.scrollDuration, this.scrollOffset, this._scrollContainer);
        this._location.replaceState(item.href);
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    trackByFn(index) {
        return index;
    }
    _setInitialContainerScroll() {
        const listenerTarget = this._animateScrollService.getListenerTarget(this._scrollContainer);
        this._ngZone.runOutsideAngular(() => {
            // listen to the scroll events for the provided scrollContainer
            // to apply line animation
            fromEvent(listenerTarget, 'scroll')
                .pipe(takeUntil(this._destroyed$))
                .subscribe(() => {
                this._anchorPreset();
            });
        });
        this._anchorPreset();
        if (!this._fragment) {
            return;
        }
        // in case url fragment is available - scroll to respective block in the container
        this._animateScrollService.scrollToElement(this._fragment, this.scrollDuration, this.scrollOffset, this._scrollContainer);
        this._applyLineAnimation();
    }
    _isContentWithinViewport() {
        const firstContentItem = this._anchorContentItems[0];
        const lastContentItem = this._anchorContentItems[this._anchorContentItems.length - 1];
        return DomHandler.getWindowScrollTop() + DomHandler.getViewport().height > DomHandler.getOffset(firstContentItem).top
            && DomHandler.getWindowScrollTop() < DomHandler.getOffset(lastContentItem).top + lastContentItem.offsetHeight;
    }
    _fixedOnScroll() {
        if (!this.isMobile) {
            return;
        }
        this._isContentWithinViewport()
            ? this._renderer.addClass(this._element.nativeElement, 'fixed')
            : this._renderer.removeClass(this._element.nativeElement, 'fixed');
    }
    _detachLineAnimation() {
        this._anchorLinkComponents.forEach(item => {
            this._renderer.setStyle(item.animationLine.nativeElement, 'height', '0');
        });
    }
    _applyLineAnimation() {
        let windowScroll = DomHandler.getWindowScrollTop();
        if (!this._animateScrollService.isDocumentBody(this._scrollContainer)) {
            windowScroll = DomHandler.getOffset(this._scrollContainer).top;
        }
        this._anchorContentItems.forEach((item) => this._calculateScrolledContentDistance(item, windowScroll));
    }
    _anchorPreset() {
        this._fixedOnScroll();
        // reset previously applied line animation
        this._detachLineAnimation();
        // apply line animation based on scroll position
        this._applyLineAnimation();
    }
    _calculateScrolledContentDistance(item, scroll) {
        const top = Math.floor(DomHandler.getOffset(item).top);
        const elemLink = this._anchorLinkComponents.find(({ item: anchor }) => new RegExp(item.id, 'gi').test(anchor.href));
        if (!elemLink) {
            return;
        }
        const line = elemLink.animationLine.nativeElement;
        const windowScroll = this._animateScrollService.isDocumentBody(this._scrollContainer)
            ? DomHandler.getWindowScrollTop()
            : this._scrollContainer.scrollTop;
        const windowHeight = this._animateScrollService.isDocumentBody(this._scrollContainer)
            ? window.innerHeight
            : this._scrollContainer.offsetHeight;
        const scrolledToBottom = (windowScroll + windowHeight) >= this._scrollContainer.scrollHeight;
        let { top: rectTop } = item.getBoundingClientRect();
        /**
         * When scroll touch the bottom of the page - highlight all items momentarily.
         */
        if (scrolledToBottom) {
            this._renderer.addClass(elemLink.anchor.nativeElement, 'current');
            this._renderer.addClass(elemLink.anchor.nativeElement, 'past');
            this._renderer.setStyle(line, 'height', `calc(100% - ${this._dotSize}px)`);
            return;
        }
        if (scroll >= top) {
            if (!this._animateScrollService.isDocumentBody(this._scrollContainer)) {
                rectTop = rectTop - this._scrollContainer.getBoundingClientRect().top;
            }
            // inside the section block
            if (scroll <= top + item.offsetHeight) {
                this._renderer.removeClass(elemLink.anchor.nativeElement, 'past');
                this._renderer.addClass(elemLink.anchor.nativeElement, 'current');
                this._renderer.addClass(elemLink.anchor.nativeElement, 'reading');
                this._renderer.setAttribute(elemLink.anchor.nativeElement, 'aria-checked', 'true');
                const scrolledHeight = elemLink.anchor.nativeElement.classList.contains('reading') ? Math.abs(rectTop * 100 / item.offsetHeight) : 0;
                this._renderer.setStyle(line, 'height', `calc(${scrolledHeight}% - ${this._dotSize}px)`);
            }
            else {
                this._renderer.removeClass(elemLink.anchor.nativeElement, 'current');
                this._renderer.addClass(elemLink.anchor.nativeElement, 'past');
                this._renderer.removeAttribute(elemLink.anchor.nativeElement, 'aria-checked');
                this._renderer.setStyle(line, 'height', `calc(100% - ${this._dotSize}px)`);
            }
        }
        else {
            this._renderer.removeClass(elemLink.anchor.nativeElement, 'current');
            this._renderer.removeClass(elemLink.anchor.nativeElement, 'reading');
            this._renderer.removeClass(elemLink.anchor.nativeElement, 'past');
            this._renderer.removeAttribute(elemLink.anchor.nativeElement, 'aria-checked');
        }
    }
}
AdaptAnchorNavigatorComponent.ɵfac = function AdaptAnchorNavigatorComponent_Factory(t) { return new (t || AdaptAnchorNavigatorComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptAnimateScrollService), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i2.ActivatedRoute), i0.ɵɵdirectiveInject(i3.Location), i0.ɵɵdirectiveInject(i4.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i5.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptAnchorNavigatorComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptAnchorNavigatorComponent, selectors: [["adapt-anchor-navigator"]], viewQuery: function AdaptAnchorNavigatorComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(AdaptAnchorLinkComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._anchorLinkComponents = _t);
    } }, hostVars: 2, hostBindings: function AdaptAnchorNavigatorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("anchor-navigator-container", ctx.defaultClass);
    } }, inputs: { list: "list", listHeader: "listHeader", anchorBlockClass: "anchorBlockClass", scrollOffset: "scrollOffset", scrollDuration: "scrollDuration", scrollContainer: "scrollContainer" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 7, vars: 2, consts: [[4, "ngIf"], ["anchorNavigator", ""], ["class", "anchor-navigator__title", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "anchor-navigator__title"], [1, "anchor-navigator__click-to-show", 3, "click"], ["class", "anchor-navigator__backdrop", 4, "ngIf"], [1, "anchor-navigator__backdrop"], ["role", "menu", 1, "anchor-navigator__list"], ["role", "none", "class", "anchor-navigator__item", 3, "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "none", 1, "anchor-navigator__item", 3, "ngClass"], [3, "item", "isMobile", "isNavigatorVisible", "onLinkClick"], ["role", "none", "class", "anchor-navigator__sub-list", 4, "ngIf"], ["role", "none", 1, "anchor-navigator__sub-list"], ["role", "none", "class", "anchor-navigator__item", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "none", 1, "anchor-navigator__item"]], template: function AdaptAnchorNavigatorComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, AdaptAnchorNavigatorComponent_ng_container_0_Template, 6, 2, "ng-container", 0);
        i0.ɵɵtext(1, "\n\n");
        i0.ɵɵtemplate(2, AdaptAnchorNavigatorComponent_ng_container_2_Template, 8, 2, "ng-container", 0);
        i0.ɵɵtext(3, "\n\n");
        i0.ɵɵtemplate(4, AdaptAnchorNavigatorComponent_ng_template_4_Template, 6, 2, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(6, "\n");
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", !ctx.isMobile);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.isMobile);
    } }, directives: [i3.NgIf, i3.NgTemplateOutlet, i3.NgForOf, i3.NgClass, i6.AdaptAnchorLinkComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptAnchorNavigatorComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-anchor-navigator',
                templateUrl: './anchor-navigator.component.html'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.AdaptAnimateScrollService }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: i2.ActivatedRoute }, { type: i3.Location }, { type: i4.AdaptDeviceDetectionService }, { type: i5.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { list: [{
            type: Input
        }], listHeader: [{
            type: Input
        }], anchorBlockClass: [{
            type: Input
        }], scrollOffset: [{
            type: Input
        }], scrollDuration: [{
            type: Input
        }], scrollContainer: [{
            type: Input
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.anchor-navigator-container']
        }], _anchorLinkComponents: [{
            type: ViewChildren,
            args: [AdaptAnchorLinkComponent]
        }] }); })();
//# sourceMappingURL=anchor-navigator.component.js.map