import { ApplicationRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Injector, Input, NgZone, Output, PLATFORM_ID, Renderer2, TemplateRef, ViewContainerRef, ViewEncapsulation } from '@angular/core';
import { DOCUMENT, isPlatformServer } from '@angular/common';
import { transition, trigger, useAnimation } from '@angular/animations';
import { ESCAPE } from '@angular/cdk/keycodes';
import { ComponentPortal } from '@angular/cdk/portal';
import { Directionality } from '@angular/cdk/bidi';
import { fromEvent, ReplaySubject } from 'rxjs';
import { filter, take, takeUntil } from 'rxjs/operators';
import { ANIMATION_NAME } from '../common/animation';
import { AdaptDeviceDetectionService } from '../common/device-detection.service';
import { AdaptTranslateService } from '../common/i18n/index';
import { LayerService } from '../common/layer-service';
import { positionElements } from '../common/positioning';
import { PopupService } from '../common/popup';
import { SafeCdr } from '../common/safe-cdr';
import { getEventKeyCode } from '../common/key-codes';
import { isEventFrom } from '../common/utilities';
import { listenToTriggers } from '../common/triggers';
import { AdaptOverlayService, getOverlayConnectedPositions } from '../common/overlay/index';
// https://github.com/angular/angular-cli/issues/2034#issuecomment-317270354
import { AdaptPopoverConfig } from './popover.config';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "../common/device-detection.service";
import * as i2 from "../common/overlay/index";
import * as i3 from "../common/i18n/index";
import * as i4 from "@angular/common";
import * as i5 from "./popover.config";
import * as i6 from "../common/layer-service";
import * as i7 from "@angular/cdk/bidi";
import * as i8 from "../common/radar/adapt-radar";
function AdaptPopoverWindow2Component_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 7);
} }
function AdaptPopoverWindow2Component_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r6 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 8);
    i0.ɵɵlistener("click", function AdaptPopoverWindow2Component_button_5_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r6); const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.closeCB(); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵattribute("aria-label", ctx_r1.closeText);
} }
function AdaptPopoverWindow2Component_div_7_ng_template_2_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r12 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 8);
    i0.ɵɵlistener("click", function AdaptPopoverWindow2Component_div_7_ng_template_2_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r12); const ctx_r11 = i0.ɵɵnextContext(3); return ctx_r11.closeCB(); });
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = i0.ɵɵnextContext(3);
    i0.ɵɵattribute("aria-label", ctx_r10.closeText);
} }
function AdaptPopoverWindow2Component_div_7_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵelementStart(1, "div", 12);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵtemplate(4, AdaptPopoverWindow2Component_div_7_ng_template_2_button_4_Template, 2, 1, "button", 2);
    i0.ɵɵtext(5, "\n        ");
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r8.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r8.closeCB);
} }
function AdaptPopoverWindow2Component_div_7_ng_template_5_Template(rf, ctx) { }
function AdaptPopoverWindow2Component_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptPopoverWindow2Component_div_7_ng_template_2_Template, 6, 2, "ng-template", null, 10, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵtemplate(5, AdaptPopoverWindow2Component_div_7_ng_template_5_Template, 0, 0, "ng-template", 11);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r7 = i0.ɵɵreference(3);
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r2.isTemplate(ctx_r2.title) ? ctx_r2.title : _r7)("ngTemplateOutletContext", ctx_r2.context);
} }
function AdaptPopoverWindow2Component_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 11);
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r3.content)("ngTemplateOutletContext", ctx_r3.context);
} }
function AdaptPopoverWindow2Component_ng_container_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r4.content);
} }
const _c0 = function (a0) { return { "a-popover-wrap": a0 }; };
const _c1 = ["*"];
function AdaptPopoverWindowComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 5);
} }
function AdaptPopoverWindowComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 6);
    i0.ɵɵlistener("click", function AdaptPopoverWindowComponent_button_5_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return ctx_r3.closeCB(); });
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵattribute("aria-label", ctx_r1.closeText);
} }
function AdaptPopoverWindowComponent_div_7_ng_template_2_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 6);
    i0.ɵɵlistener("click", function AdaptPopoverWindowComponent_div_7_ng_template_2_button_4_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r10); const ctx_r9 = i0.ɵɵnextContext(3); return ctx_r9.closeCB(); });
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = i0.ɵɵnextContext(3);
    i0.ɵɵattribute("aria-label", ctx_r8.closeText);
} }
function AdaptPopoverWindowComponent_div_7_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵelementStart(1, "div", 10);
    i0.ɵɵtext(2);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵtemplate(4, AdaptPopoverWindowComponent_div_7_ng_template_2_button_4_Template, 2, 1, "button", 2);
    i0.ɵɵtext(5, "\n        ");
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(ctx_r6.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r6.closeCB);
} }
function AdaptPopoverWindowComponent_div_7_ng_template_5_Template(rf, ctx) { }
function AdaptPopoverWindowComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 7);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptPopoverWindowComponent_div_7_ng_template_2_Template, 6, 2, "ng-template", null, 8, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(4, "\n        ");
    i0.ɵɵtemplate(5, AdaptPopoverWindowComponent_div_7_ng_template_5_Template, 0, 0, "ng-template", 9);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const _r5 = i0.ɵɵreference(3);
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(5);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r2.isTitleTemplate() ? ctx_r2.title : _r5)("ngTemplateOutletContext", ctx_r2.context);
} }
const _c2 = "\n    /* If replace styles to CSS repo, the initial positioning works wrong */\n    adapt-popover-window {\n      position: absolute;\n      display: block;\n      max-width: 250px;\n    }\n  ";
let nextId = 0;
export class AdaptPopoverWindow2Component {
    constructor(_element, _renderer, _deviceDetectionService, _changeDetectorRef, overlayService, ts) {
        this._element = _element;
        this._renderer = _renderer;
        this._deviceDetectionService = _deviceDetectionService;
        this._changeDetectorRef = _changeDetectorRef;
        this.overlayService = overlayService;
        this.ts = ts;
        /** Set the primary placement for popover, if there will be not enought space it will automatically move popover for the best place to show */
        this.placement = 'top';
        this.closeAnimationDone = new EventEmitter();
        this.popoverAnimationDone = this._onPopoverAnimationDone;
        this.closeText = ts.getCurrentLanguage()['adapt.common.close'];
    }
    get hostClasses() {
        return [
            'popover',
            'position-relative',
            this.popoverClass,
            this.isMobile ? 'popover-mobile' : ''
        ].join(' ');
    }
    get isMobile() {
        return this._deviceDetectionService.deviceMobile();
    }
    get popoverAnimation() {
        return !this.closing;
    }
    ngOnInit() {
        if (this.isMobile) {
            this.placement = 'mobile';
        }
        this._renderer.setAttribute(this._element.nativeElement, 'tabindex', '-1');
    }
    focusOnOpen() {
        return requestAnimationFrame(() => {
            this._element.nativeElement.focus();
        });
    }
    isEventFrom(event) {
        return isEventFrom(event, this._element.nativeElement);
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    isTemplate(val) {
        return val instanceof TemplateRef;
    }
    markForCheck() {
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    _onPopoverAnimationDone(event) {
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        if (event.toState === false) {
            this.closeAnimationDone.emit();
            this.closeAnimationDone.complete();
        }
    }
}
AdaptPopoverWindow2Component.ɵfac = function AdaptPopoverWindow2Component_Factory(t) { return new (t || AdaptPopoverWindow2Component)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.AdaptOverlayService), i0.ɵɵdirectiveInject(i3.AdaptTranslateService)); };
AdaptPopoverWindow2Component.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptPopoverWindow2Component, selectors: [["adapt-popover-window2"]], hostAttrs: ["role", "tooltip"], hostVars: 8, hostBindings: function AdaptPopoverWindow2Component_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵsyntheticHostListener("@popoverAnimation.done", function AdaptPopoverWindow2Component_animation_popoverAnimation_done_HostBindingHandler($event) { return ctx.popoverAnimationDone($event); });
    } if (rf & 2) {
        i0.ɵɵhostProperty("id", ctx.id);
        i0.ɵɵsyntheticHostProperty("@popoverAnimation", ctx.popoverAnimation);
        i0.ɵɵclassMap(ctx.hostClasses);
        i0.ɵɵstyleProp("max-width", ctx.maxWidth)("min-width", ctx.minWidth);
    } }, inputs: { content: "content", placement: "placement", title: "title", id: "id", closeCB: "closeCB", popoverClass: "popoverClass", context: "context", maxWidth: "maxWidth", minWidth: "minWidth" }, outputs: { closeAnimationDone: "closeAnimationDone" }, ngContentSelectors: _c1, decls: 19, vars: 8, consts: [[3, "ngClass"], ["class", "arrow", 4, "ngIf"], ["class", "close", "type", "button", "role", "button", 3, "click", 4, "ngIf"], ["class", "popover-header", 4, "ngIf"], [1, "popover-body"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], [1, "arrow"], ["type", "button", "role", "button", 1, "close", 3, "click"], [1, "popover-header"], ["simpleTitle", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "popover-title"]], template: function AdaptPopoverWindow2Component_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵtemplate(3, AdaptPopoverWindow2Component_div_3_Template, 1, 0, "div", 1);
        i0.ɵɵtext(4, "\n      ");
        i0.ɵɵtemplate(5, AdaptPopoverWindow2Component_button_5_Template, 2, 1, "button", 2);
        i0.ɵɵtext(6, "\n      ");
        i0.ɵɵtemplate(7, AdaptPopoverWindow2Component_div_7_Template, 7, 2, "div", 3);
        i0.ɵɵtext(8, "\n      ");
        i0.ɵɵelementStart(9, "div", 4);
        i0.ɵɵtext(10, "\n        ");
        i0.ɵɵprojection(11);
        i0.ɵɵtext(12, "\n\n        ");
        i0.ɵɵtemplate(13, AdaptPopoverWindow2Component_ng_container_13_Template, 1, 2, "ng-container", 5);
        i0.ɵɵtext(14, "\n\n        ");
        i0.ɵɵtemplate(15, AdaptPopoverWindow2Component_ng_container_15_Template, 2, 1, "ng-container", 6);
        i0.ɵɵtext(16, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(18, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(6, _c0, ctx.isMobile));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.isMobile);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.closeCB && (ctx.title === null || ctx.title === undefined));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.title !== null && ctx.title !== undefined);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", ctx.overlayService.enableCDKOverlayControl && ctx.isTemplate(ctx.content));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.overlayService.enableCDKOverlayControl && !ctx.isTemplate(ctx.content));
    } }, directives: [i4.NgClass, i4.NgIf, i4.NgTemplateOutlet], styles: [_c2], encapsulation: 2, data: { animation: [
            trigger('popoverAnimation', [
                transition('* => 1', [
                    useAnimation(ANIMATION_NAME.popIn)
                ]),
                transition('1 => 0', [
                    useAnimation(ANIMATION_NAME.popOut)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptPopoverWindow2Component, [{
        type: Component,
        args: [{
                selector: 'adapt-popover-window2',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    'role': 'tooltip',
                    '[id]': 'id'
                },
                styles: [`
    /* If replace styles to CSS repo, the initial positioning works wrong */
    adapt-popover-window {
      position: absolute;
      display: block;
      max-width: 250px;
    }
  `],
                template: `
    <div [ngClass]="{'a-popover-wrap': isMobile}">
      <div class="arrow" *ngIf="!isMobile"></div>
      <button class="close"
              [attr.aria-label]="closeText"
              *ngIf="closeCB && (title === null || title === undefined)"
              type="button"
              role="button"
              (click)="closeCB()">
      </button>
      <div class="popover-header" *ngIf="title !== null && title !== undefined">
        <ng-template #simpleTitle>
          <div class="popover-title">{{title}}</div>
          <button class="close"
                  [attr.aria-label]="closeText"
                  *ngIf="closeCB"
                  type="button"
                  role="button"
                  (click)="closeCB()">
          </button>
        </ng-template>
        <ng-template [ngTemplateOutlet]="isTemplate(title) ? title : simpleTitle"
                     [ngTemplateOutletContext]="context"></ng-template>
      </div>
      <div class="popover-body">
        <ng-content></ng-content>

        <ng-container *ngIf="overlayService.enableCDKOverlayControl && isTemplate(content)"
                      [ngTemplateOutlet]="content"
                      [ngTemplateOutletContext]="context"></ng-container>

        <ng-container *ngIf="overlayService.enableCDKOverlayControl && !isTemplate(content)">{{content}}</ng-container>
      </div>
    </div>
  `,
                animations: [
                    trigger('popoverAnimation', [
                        transition('* => 1', [
                            useAnimation(ANIMATION_NAME.popIn)
                        ]),
                        transition('1 => 0', [
                            useAnimation(ANIMATION_NAME.popOut)
                        ])
                    ])
                ],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.AdaptDeviceDetectionService }, { type: i0.ChangeDetectorRef }, { type: i2.AdaptOverlayService }, { type: i3.AdaptTranslateService }]; }, { content: [{
            type: Input
        }], placement: [{
            type: Input
        }], title: [{
            type: Input
        }], id: [{
            type: Input
        }], closeCB: [{
            type: Input
        }], popoverClass: [{
            type: Input
        }], context: [{
            type: Input
        }], closeAnimationDone: [{
            type: Output
        }], maxWidth: [{
            type: HostBinding,
            args: ['style.max-width']
        }, {
            type: Input
        }], minWidth: [{
            type: HostBinding,
            args: ['style.min-width']
        }, {
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], popoverAnimation: [{
            type: HostBinding,
            args: ['@popoverAnimation']
        }], popoverAnimationDone: [{
            type: HostListener,
            args: ['@popoverAnimation.done', ['$event']]
        }] }); })();
export class AdaptPopoverWindowComponent {
    constructor(_element, _renderer, _deviceDetectionService, _changeDetectorRef, ts) {
        this._element = _element;
        this._renderer = _renderer;
        this._deviceDetectionService = _deviceDetectionService;
        this._changeDetectorRef = _changeDetectorRef;
        this.ts = ts;
        this.closeAnimationDone = new EventEmitter();
        this.popoverAnimationDone = this._onPopoverAnimationDone.bind(this);
        this._animationState = 'void';
        this._placement = 'top';
        this.closeText = ts.getCurrentLanguage()['adapt.common.close'];
    }
    set placement(value) {
        this._placement = value;
        this.animationState = value;
    }
    get placement() {
        return this._placement;
    }
    get hostClasses() {
        return [
            'popover',
            'bs-popover-' + this.placement.split('-')[0],
            'bs-popover-' + this.placement,
            this.popoverClass,
            this.isMobile ? 'popover-mobile' : ''
        ].join(' ');
    }
    get popoverAnimation() {
        return this.animationState;
    }
    get isMobile() {
        return this._deviceDetectionService.deviceMobile();
    }
    set animationState(value) {
        this._animationState = value ? value.split('-')[0] : 'void';
        // if the parent component uses ChangeDetectionStrategy.OnPush need to run an additional change detection
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    get animationState() {
        return this._animationState;
    }
    ngOnInit() {
        if (this.isMobile) {
            this.placement = 'mobile';
        }
        this._renderer.setAttribute(this._element.nativeElement, 'tabindex', '-1');
    }
    isTitleTemplate() {
        return this.title instanceof TemplateRef;
    }
    applyPlacement(_placement) {
        // remove the current placement classes
        this._renderer.removeClass(this._element.nativeElement, 'bs-popover-' + this.placement.toString().split('-')[0]);
        this._renderer.removeClass(this._element.nativeElement, 'bs-popover-' + this.placement.toString());
        // set the new placement classes
        this.placement = _placement;
        // apply the new placement
        this._renderer.addClass(this._element.nativeElement, 'bs-popover-' + this.placement.toString().split('-')[0]);
        this._renderer.addClass(this._element.nativeElement, 'bs-popover-' + this.placement.toString());
    }
    focusOnOpen() {
        return requestAnimationFrame(() => {
            this._element.nativeElement.focus();
        });
    }
    isEventFrom(event) {
        return isEventFrom(event, this._element.nativeElement);
    }
    _onPopoverAnimationDone(event) {
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        if ((event.fromState !== event.toState) && (event.toState === 'void')) {
            this.closeAnimationDone.emit();
            this.closeAnimationDone.complete();
        }
    }
}
AdaptPopoverWindowComponent.ɵfac = function AdaptPopoverWindowComponent_Factory(t) { return new (t || AdaptPopoverWindowComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.AdaptTranslateService)); };
AdaptPopoverWindowComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptPopoverWindowComponent, selectors: [["adapt-popover-window"]], hostAttrs: ["role", "tooltip"], hostVars: 8, hostBindings: function AdaptPopoverWindowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵsyntheticHostListener("@popoverAnimation.done", function AdaptPopoverWindowComponent_animation_popoverAnimation_done_HostBindingHandler($event) { return ctx.popoverAnimationDone($event); });
    } if (rf & 2) {
        i0.ɵɵhostProperty("id", ctx.id);
        i0.ɵɵsyntheticHostProperty("@popoverAnimation", ctx.popoverAnimation);
        i0.ɵɵclassMap(ctx.hostClasses);
        i0.ɵɵstyleProp("max-width", ctx.maxWidth)("min-width", ctx.minWidth);
    } }, inputs: { placement: "placement", title: "title", id: "id", closeCB: "closeCB", popoverClass: "popoverClass", context: "context", maxWidth: "maxWidth", minWidth: "minWidth" }, outputs: { closeAnimationDone: "closeAnimationDone" }, ngContentSelectors: _c1, decls: 15, vars: 6, consts: [[3, "ngClass"], ["class", "arrow", 4, "ngIf"], ["class", "close", "type", "button", "role", "button", 3, "click", 4, "ngIf"], ["class", "popover-header", 4, "ngIf"], [1, "popover-body"], [1, "arrow"], ["type", "button", "role", "button", 1, "close", 3, "click"], [1, "popover-header"], ["simpleTitle", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "popover-title"]], template: function AdaptPopoverWindowComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵtemplate(3, AdaptPopoverWindowComponent_div_3_Template, 1, 0, "div", 1);
        i0.ɵɵtext(4, "\n      ");
        i0.ɵɵtemplate(5, AdaptPopoverWindowComponent_button_5_Template, 2, 1, "button", 2);
        i0.ɵɵtext(6, "\n      ");
        i0.ɵɵtemplate(7, AdaptPopoverWindowComponent_div_7_Template, 7, 2, "div", 3);
        i0.ɵɵtext(8, "\n      ");
        i0.ɵɵelementStart(9, "div", 4);
        i0.ɵɵtext(10, "\n        ");
        i0.ɵɵprojection(11);
        i0.ɵɵtext(12, "\n      ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(13, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(14, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction1(4, _c0, ctx.isMobile));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", !ctx.isMobile);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.closeCB && (ctx.title === null || ctx.title === undefined));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.title !== null && ctx.title !== undefined);
    } }, directives: [i4.NgClass, i4.NgIf, i4.NgTemplateOutlet], styles: [_c2], encapsulation: 2, data: { animation: [
            trigger('popoverAnimation', [
                // Top
                transition('void => top', [
                    useAnimation(ANIMATION_NAME.moveIn, { params: { translateY: 30, unit: 'px' } })
                ]),
                transition('top => void', [
                    useAnimation(ANIMATION_NAME.moveOut, { params: { translateY: 30, unit: 'px' } })
                ]),
                // Left
                transition('void => left', [
                    useAnimation(ANIMATION_NAME.moveIn, { params: { translateX: 30, unit: 'px' } })
                ]),
                transition('left => void', [
                    useAnimation(ANIMATION_NAME.moveOut, { params: { translateX: 30, unit: 'px' } })
                ]),
                // Right
                transition('void => right', [
                    useAnimation(ANIMATION_NAME.moveIn, { params: { translateX: -30, unit: 'px' } })
                ]),
                transition('right => void', [
                    useAnimation(ANIMATION_NAME.moveOut, { params: { translateX: -30, unit: 'px' } })
                ]),
                // Bottom
                transition('void => bottom', [
                    useAnimation(ANIMATION_NAME.moveIn, { params: { translateY: -30, unit: 'px' } })
                ]),
                transition('bottom => void', [
                    useAnimation(ANIMATION_NAME.moveOut, { params: { translateY: -30, unit: 'px' } })
                ]),
                // On mobile just fade
                transition('void => mobile', [
                    useAnimation(ANIMATION_NAME.popIn)
                ]),
                transition('mobile => void', [
                    useAnimation(ANIMATION_NAME.popOut)
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptPopoverWindowComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-popover-window',
                changeDetection: ChangeDetectionStrategy.OnPush,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    'role': 'tooltip',
                    '[id]': 'id'
                },
                styles: [`
    /* If replace styles to CSS repo, the initial positioning works wrong */
    adapt-popover-window {
      position: absolute;
      display: block;
      max-width: 250px;
    }
  `],
                template: `
    <div [ngClass]="{'a-popover-wrap': isMobile}">
      <div class="arrow" *ngIf="!isMobile"></div>
      <button class="close"
              [attr.aria-label]="closeText"
              *ngIf="closeCB && (title === null || title === undefined)"
              type="button"
              role="button"
              (click)="closeCB()">
      </button>
      <div class="popover-header" *ngIf="title !== null && title !== undefined">
        <ng-template #simpleTitle>
          <div class="popover-title">{{title}}</div>
          <button class="close"
                  [attr.aria-label]="closeText"
                  *ngIf="closeCB"
                  type="button"
                  role="button"
                  (click)="closeCB()">
          </button>
        </ng-template>
        <ng-template [ngTemplateOutlet]="isTitleTemplate() ? title : simpleTitle"
                     [ngTemplateOutletContext]="context"></ng-template>
      </div>
      <div class="popover-body">
        <ng-content></ng-content>
      </div>
    </div>
  `,
                animations: [
                    trigger('popoverAnimation', [
                        // Top
                        transition('void => top', [
                            useAnimation(ANIMATION_NAME.moveIn, { params: { translateY: 30, unit: 'px' } })
                        ]),
                        transition('top => void', [
                            useAnimation(ANIMATION_NAME.moveOut, { params: { translateY: 30, unit: 'px' } })
                        ]),
                        // Left
                        transition('void => left', [
                            useAnimation(ANIMATION_NAME.moveIn, { params: { translateX: 30, unit: 'px' } })
                        ]),
                        transition('left => void', [
                            useAnimation(ANIMATION_NAME.moveOut, { params: { translateX: 30, unit: 'px' } })
                        ]),
                        // Right
                        transition('void => right', [
                            useAnimation(ANIMATION_NAME.moveIn, { params: { translateX: -30, unit: 'px' } })
                        ]),
                        transition('right => void', [
                            useAnimation(ANIMATION_NAME.moveOut, { params: { translateX: -30, unit: 'px' } })
                        ]),
                        // Bottom
                        transition('void => bottom', [
                            useAnimation(ANIMATION_NAME.moveIn, { params: { translateY: -30, unit: 'px' } })
                        ]),
                        transition('bottom => void', [
                            useAnimation(ANIMATION_NAME.moveOut, { params: { translateY: -30, unit: 'px' } })
                        ]),
                        // On mobile just fade
                        transition('void => mobile', [
                            useAnimation(ANIMATION_NAME.popIn)
                        ]),
                        transition('mobile => void', [
                            useAnimation(ANIMATION_NAME.popOut)
                        ])
                    ])
                ],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.AdaptDeviceDetectionService }, { type: i0.ChangeDetectorRef }, { type: i3.AdaptTranslateService }]; }, { placement: [{
            type: Input
        }], title: [{
            type: Input
        }], id: [{
            type: Input
        }], closeCB: [{
            type: Input
        }], popoverClass: [{
            type: Input
        }], context: [{
            type: Input
        }], closeAnimationDone: [{
            type: Output
        }], maxWidth: [{
            type: HostBinding,
            args: ['style.max-width']
        }, {
            type: Input
        }], minWidth: [{
            type: HostBinding,
            args: ['style.min-width']
        }, {
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], popoverAnimation: [{
            type: HostBinding,
            args: ['@popoverAnimation']
        }], popoverAnimationDone: [{
            type: HostListener,
            args: ['@popoverAnimation.done', ['$event']]
        }] }); })();
/**
 * A lightweight, extensible directive for fancy popover creation.
 */
export class AdaptPopoverDirective extends AdaptRadarAngularGenericDirective {
    constructor(_elementRef, _renderer, injector, detection, componentFactoryResolver, viewContainerRef, config, _ngZone, _layerService, _overlayService, _applicationRef, _directionality, 
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _document, // https://github.com/angular/angular/issues/20351
    _adaptRadarService, _elem, _platformId) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptPopover);
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.injector = injector;
        this.detection = detection;
        this.componentFactoryResolver = componentFactoryResolver;
        this.viewContainerRef = viewContainerRef;
        this.config = config;
        this._ngZone = _ngZone;
        this._layerService = _layerService;
        this._overlayService = _overlayService;
        this._applicationRef = _applicationRef;
        this._directionality = _directionality;
        this._document = _document;
        this._platformId = _platformId;
        /**
         * When specified, the popover will be attached to the body
         * @since v9.2.0
         * @docs-default true
         */
        this.appendToBody = true;
        /**
         * Close button in the popover header
         * @docs-default false
         */
        this.closeBtn = false;
        /**
         * Delay before popover is open
         * @docs-default 0
         */
        this.popupDelay = 0;
        /**
         * Auto close popover when popover origin is out of viewport
         * @since v12.17.0
         * @docs-default false
         */
        this.closeOnOutOfView = false;
        /**
         * Emits an event when the popover is shown
         */
        this.shown = new EventEmitter();
        /**
         * Emits an event when the popover is hidden
         */
        this.hidden = new EventEmitter();
        this._popoverWindowId = `adapt-popover-${nextId++}`;
        this._maxWidth = 250;
        this._minWidth = 0;
        this._destroyed$ = new ReplaySubject(1);
        this.placement = config.placement;
        this.triggers = config.triggers;
        this.appendToBody = config.appendToBody || (config.container === 'body');
        this.autoClose = config.autoClose;
        this._popupService = new PopupService(AdaptPopoverWindowComponent, injector, viewContainerRef, _renderer, componentFactoryResolver, _applicationRef);
        this._overlayConnectedPositions = getOverlayConnectedPositions(this._directionality.value, 2);
        this._overlayConnectedPositions.top.panelClass = 'bs-popover-top';
        this._overlayConnectedPositions.left.panelClass = 'bs-popover-left';
        this._overlayConnectedPositions.right.panelClass = 'bs-popover-right';
        this._overlayConnectedPositions.bottom.panelClass = 'bs-popover-bottom';
        this._overlayConnectedPositions['left-top'].panelClass = ['bs-popover-left', 'bs-popover-left-top'];
        this._overlayConnectedPositions['left-bottom'].panelClass = ['bs-popover-left', 'bs-popover-left-bottom'];
        this._overlayConnectedPositions['right-top'].panelClass = ['bs-popover-right', 'bs-popover-right-top'];
        this._overlayConnectedPositions['right-bottom'].panelClass = ['bs-popover-right', 'bs-popover-right-bottom'];
        this._overlayConnectedPositions['top-left'].panelClass = ['bs-popover-top', 'bs-popover-top-left'];
        this._overlayConnectedPositions['top-right'].panelClass = ['bs-popover-top', 'bs-popover-top-right'];
        this._overlayConnectedPositions['bottom-left'].panelClass = ['bs-popover-bottom', 'bs-popover-bottom-left'];
        this._overlayConnectedPositions['bottom-right'].panelClass = ['bs-popover-bottom', 'bs-popover-bottom-right'];
        this._popoverOverlayPositions = [
            this._overlayConnectedPositions.top,
            this._overlayConnectedPositions.left,
            this._overlayConnectedPositions.right,
            this._overlayConnectedPositions.bottom,
            this._overlayConnectedPositions['left-top'],
            this._overlayConnectedPositions['left-bottom'],
            this._overlayConnectedPositions['right-top'],
            this._overlayConnectedPositions['right-bottom'],
            this._overlayConnectedPositions['top-left'],
            this._overlayConnectedPositions['top-right'],
            this._overlayConnectedPositions['bottom-left'],
            this._overlayConnectedPositions['bottom-right']
        ];
    }
    get maxWidth() {
        return `${this._maxWidth}px`;
    }
    set maxWidth(w) {
        this._maxWidth = parseInt(w, 10);
    }
    /**
     * @since v12.21.0
     */
    set minWidth(width) {
        this._minWidth = parseInt(width, 10);
    }
    get minWidth() {
        return `${this._minWidth}px`;
    }
    get isMobile() {
        return this.detection.deviceMobile();
    }
    open(forcedElement, forcedPlacement) {
        if (this._elementRef.nativeElement === document.activeElement) {
            this._lastFocusEl = this._elementRef.nativeElement;
        }
        if (this._overlayService.enableCDKOverlayControl) {
            this._openOverlay(forcedElement, forcedPlacement);
            return;
        }
        if (this.container === 'body') {
            this.appendToBody = true;
        }
        if (!this._windowRef && !this._isDisabled() && !this._openTimeout) {
            this._openTimeout = window.setTimeout(() => {
                // for https://github.bmc.com/bmc-ux/adapt-angular/issues/1179
                const newContext = {
                    context: { close: this.close.bind(this) }
                };
                this._windowRef = this._popupService.open(this.adaptPopover, newContext);
                this._windowRef.instance.title = this.popoverTitle;
                this._windowRef.instance.context = newContext;
                this._windowRef.instance.popoverClass = this.popoverClass;
                this._windowRef.instance.id = this._popoverWindowId;
                this._windowRef.instance.maxWidth = this.maxWidth;
                this._windowRef.instance.closeCB = this.closeBtn ? this.close.bind(this) : null;
                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', this._popoverWindowId);
                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-expanded', 'true');
                this._focusTimeout = this._windowRef.instance.focusOnOpen();
                if (this.appendToBody) {
                    this._document.body.appendChild(this._windowRef.location.nativeElement);
                }
                if (this.placement === 'auto') {
                    this._ngZone.onStable
                        .pipe(takeUntil(this._destroyed$), take(1))
                        .subscribe(() => {
                        this._ngZone.run(() => {
                            this.setProperPopoverPosition();
                        });
                    });
                }
                else {
                    this.setProperPopoverPosition();
                }
            }, this.popupDelay);
            this._layerService.addComponent(this, () => {
                if (this.autoClose) {
                    this.close();
                }
            });
        }
    }
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of the popover.
     */
    close(force) {
        if (this._overlayService.enableCDKOverlayControl) {
            this._closeOverlay(force);
            return;
        }
        if (!this._windowRef) {
            return;
        }
        if (this._openTimeout) {
            clearTimeout(this._openTimeout);
            this._openTimeout = null;
        }
        if (this._focusTimeout) {
            cancelAnimationFrame(this._focusTimeout);
            this._focusTimeout = null;
        }
        const closeFn = () => {
            if (this._windowRef) {
                this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-expanded', 'false');
                this._popupService.close();
                this._windowRef = null;
                this.hidden.emit();
                this._setTargetStyle();
            }
        };
        if (force === true) {
            closeFn();
        }
        else {
            if (this._windowRef) {
                this._windowRef.instance.animationState = null;
                this._windowRef.instance.closeAnimationDone.subscribe(() => {
                    closeFn();
                });
            }
        }
        this._layerService.removeComponent(this);
        // setProperPopoverPosition method create a lot of observables which are not unsubscribed while closing
        if (this._popoverSubscription) {
            this._popoverSubscription.unsubscribe();
        }
        if (this._lastFocusEl) {
            this._lastFocusEl.focus();
        }
    }
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of the popover.
     */
    toggle() {
        (this._overlayService.enableCDKOverlayControl ? this._popoverOverlayWithPortal : this._windowRef) ?
            this.close() : this.open();
    }
    /**
     * Returns whether or not the popover is currently being shown
     */
    isOpen() {
        return this._windowRef != null;
    }
    ngOnInit() {
        if (this.isMobile) {
            this.closeBtn = true;
            this.placement = 'mobile';
        }
        this._unregisterListenersFn = listenToTriggers(this._renderer, this._elementRef.nativeElement, this.triggers, this.open.bind(this), this.close.bind(this), this.toggle.bind(this));
        this._renderer.setAttribute(this._elementRef.nativeElement, 'role', 'button');
        this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-expanded', 'false');
    }
    ngOnChanges(changes) {
        // close popover if title and content become empty, or disablePopover set to true
        if ((changes.ngbPopover || changes.popoverTitle || changes.disablePopover) && this._isDisabled()) {
            this.close();
        }
    }
    ngOnDestroy() {
        this.close(true);
        // This check is needed as it might happen that ngOnDestroy is called before ngOnInit
        // under certain conditions, see: https://github.com/ng-bootstrap/ng-bootstrap/issues/2199
        if (this._unregisterListenersFn) {
            this._unregisterListenersFn();
        }
        this._layerService.removeComponent(this);
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    _openOverlay(forcedElement, forcedPlacement) {
        if ((!this._popoverOverlayWithPortal || this._popoverOverlayWithPortal.componentRef.instance.closing) && !this._isDisabled() && !this._openTimeout) {
            this._openTimeout = window.setTimeout(() => {
                var _a;
                if ((_a = this._popoverOverlayWithPortal) === null || _a === void 0 ? void 0 : _a.componentRef.instance.closing) {
                    this._popoverOverlayWithPortal.componentRef.instance.closeAnimationDone.complete();
                    this._popoverOverlayWithPortal.destroy();
                    this._popoverOverlayWithPortal = null;
                }
                // for https://github.bmc.com/bmc-ux/adapt-angular/issues/1179
                const newContext = {
                    context: { close: this.close.bind(this) }
                };
                const connectedPositions = [];
                if (this.placement !== 'mobile') {
                    if (forcedPlacement) {
                        connectedPositions.push(this._overlayConnectedPositions[forcedPlacement]);
                    }
                    else {
                        const isAutoPlacement = Array.isArray(this.placement)
                            ? this.placement.some(p => p === 'auto')
                            : this.placement === 'auto';
                        if (!isAutoPlacement) {
                            const placementList = Array.isArray(this.placement) ? this.placement : [this.placement];
                            placementList.forEach(placementName => {
                                const connectedPos = placementName;
                                connectedPositions.push(this._overlayConnectedPositions[connectedPos]);
                            });
                        }
                        connectedPositions.push(...this._popoverOverlayPositions);
                    }
                }
                this._popoverOverlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptPopoverWindow2Component, this.viewContainerRef, this.injector), {
                    origin: forcedElement || this._elementRef.nativeElement,
                    transformOriginSelector: '.popover',
                    positionStrategy: this.isMobile ? 'center' : 'connected',
                    scrollStrategy: this.isMobile ? 'block' : 'reposition',
                    connectedPositions: connectedPositions,
                    repositionScrollStrategyConfig: { autoClose: this.closeOnOutOfView }
                });
                // Process detach action invoked from Position/Scroll strategies
                this._popoverOverlayWithPortal.overlayRef.detachments()
                    .pipe(takeUntil(this._popoverOverlayWithPortal.destroy$))
                    .subscribe(() => {
                    this._closeOverlay(true, true);
                });
                this._popoverOverlayWithPortal.overlayRef.keydownEvents()
                    .pipe(takeUntil(this._popoverOverlayWithPortal.destroy$))
                    .subscribe((event) => {
                    if ((getEventKeyCode(event) === ESCAPE) && this.autoClose) {
                        this.close();
                    }
                });
                this._popoverOverlayWithPortal.overlayRef.outsidePointerEvents()
                    .pipe(takeUntil(this._popoverOverlayWithPortal.destroy$), filter(event => event.target !== this._elementRef.nativeElement))
                    .subscribe((event) => {
                    if (this._shouldCloseFromClick(event)) {
                        this.close();
                    }
                });
                this._popoverOverlayWithPortal.componentRef.instance.content = this.adaptPopover;
                this._popoverOverlayWithPortal.componentRef.instance.title = this.popoverTitle;
                this._popoverOverlayWithPortal.componentRef.instance.context = newContext;
                this._popoverOverlayWithPortal.componentRef.instance.popoverClass = this.popoverClass;
                this._popoverOverlayWithPortal.componentRef.instance.id = this._popoverWindowId;
                this._popoverOverlayWithPortal.componentRef.instance.maxWidth = this.maxWidth;
                this._popoverOverlayWithPortal.componentRef.instance.minWidth = this.minWidth;
                this._popoverOverlayWithPortal.componentRef.instance.closeCB = this.closeBtn ? this.close.bind(this) : null;
                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', this._popoverWindowId);
                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-expanded', 'true');
                this._focusTimeout = this._popoverOverlayWithPortal.componentRef.instance.focusOnOpen();
                this.shown.emit();
                // if the parent component uses ChangeDetectionStrategy.OnPush need to run an additional change detection
                this._popoverOverlayWithPortal.componentRef.instance.markForCheck();
            }, this.popupDelay);
        }
    }
    _closeOverlay(force, preventScroll = false) {
        if (this._openTimeout) {
            clearTimeout(this._openTimeout);
            this._openTimeout = null;
        }
        if (this._focusTimeout) {
            cancelAnimationFrame(this._focusTimeout);
            this._focusTimeout = null;
        }
        if (this._popoverOverlayWithPortal) {
            this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
            this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-expanded', 'false');
            if (force === true) {
                this._popoverOverlayWithPortal.destroy();
                this._popoverOverlayWithPortal = null;
            }
            else {
                this._popoverOverlayWithPortal.componentRef.instance.closing = true;
                this._popoverOverlayWithPortal.componentRef.instance.closeAnimationDone
                    .pipe(takeUntil(this._popoverOverlayWithPortal.destroy$))
                    .subscribe(() => {
                    this._popoverOverlayWithPortal.destroy();
                    this._popoverOverlayWithPortal = null;
                });
                // if the parent component uses ChangeDetectionStrategy.OnPush need to run an additional change detection
                this._popoverOverlayWithPortal.componentRef.instance.markForCheck();
            }
            this.hidden.emit();
            this._setTargetStyle();
            if (this._lastFocusEl) {
                this._lastFocusEl.focus({ preventScroll: preventScroll });
            }
        }
    }
    _isDisabled() {
        if (this.disablePopover) {
            return true;
        }
        return !this.adaptPopover && !this.popoverTitle;
    }
    setProperPopoverPosition() {
        this._windowRef.instance.placement = positionElements(this._elementRef.nativeElement, this._windowRef.location.nativeElement, this.placement, this.appendToBody, this.fallbackPlacement);
        // apply styling to set basic css-classes on target element, before going for positioning
        SafeCdr.detectChanges(this._windowRef.changeDetectorRef);
        SafeCdr.markForCheck(this._windowRef.changeDetectorRef);
        // position popover along the element
        if (!this.isMobile) {
            this._popoverSubscription = this._ngZone.onStable
                .pipe(takeUntil(this._destroyed$), take(1))
                .subscribe(() => {
                /** Hot fix related to the task -> https://github.bmc.com/bmc-ux/adapt-angular/issues/1117 */
                this._setTargetStyle('relative', 1061);
                this._windowRef.instance.applyPlacement(positionElements(this._elementRef.nativeElement, this._windowRef.location.nativeElement, this._windowRef.instance.placement, this.appendToBody));
            });
        }
        if (this.autoClose) {
            this._ngZone.runOutsideAngular(() => {
                // prevents automatic closing right after an opening by putting a guard for the time of one event handling
                // pass
                // use case: click event would reach an element opening the popover first, then reach the autoClose handler
                // which would close it
                let justOpened = true;
                requestAnimationFrame(() => justOpened = false);
                fromEvent(this._document, 'click')
                    .pipe(takeUntil(this.hidden), filter(() => !justOpened), filter(e => this._shouldCloseFromClick(e)), filter(e => {
                    // Additional check for case when popover opened inside another popover
                    // Temporary. Will be removed after fully transfer to CdkOverlay
                    if (!this._isEventFromPopover(e)) {
                        let node = e.target.parentNode;
                        while (node != null) {
                            if (node.nodeName === 'ADAPT-POPOVER-WINDOW') {
                                return false;
                            }
                            node = node.parentNode;
                        }
                    }
                    return true;
                }))
                    .subscribe(() => this._ngZone.run(() => this.close()));
            });
        }
        this.shown.emit();
    }
    _shouldCloseFromClick(event) {
        if (event.button !== 2) {
            if (this.autoClose === true) {
                return true;
            }
            else if (this.autoClose === 'inside' && this._isEventFromPopover(event)) {
                return true;
            }
            else if (this.autoClose === 'outside' && !this._isEventFromPopover(event)) {
                return true;
            }
        }
        return false;
    }
    _isEventFromPopover(event) {
        const popup = this._overlayService.enableCDKOverlayControl ? this._popoverOverlayWithPortal.componentRef.instance : this._windowRef.instance;
        return popup ? popup.isEventFrom(event) : false;
    }
    _setTargetStyle(value = '', zIndex = '') {
        if (isPlatformServer(this._platformId)) {
            return false;
        }
        else {
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            if (isSafari && this.triggers.indexOf('mouse') > -1) {
                this._elementRef.nativeElement.style.position = value;
                this._elementRef.nativeElement.style.zIndex = zIndex;
            }
        }
    }
}
AdaptPopoverDirective.ɵfac = function AdaptPopoverDirective_Factory(t) { return new (t || AdaptPopoverDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i5.AdaptPopoverConfig), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i6.LayerService), i0.ɵɵdirectiveInject(i2.AdaptOverlayService), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i7.Directionality), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i8.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PLATFORM_ID)); };
AdaptPopoverDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptPopoverDirective, selectors: [["", "adaptPopover", ""]], inputs: { adaptPopover: "adaptPopover", popoverTitle: "popoverTitle", placement: "placement", fallbackPlacement: "fallbackPlacement", triggers: "triggers", container: "container", appendToBody: "appendToBody", closeBtn: "closeBtn", popupDelay: "popupDelay", disablePopover: "disablePopover", popoverClass: "popoverClass", autoClose: "autoClose", closeOnOutOfView: "closeOnOutOfView", maxWidth: "maxWidth", minWidth: "minWidth" }, outputs: { shown: "shown", hidden: "hidden" }, exportAs: ["adaptPopover"], features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptPopoverDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptPopover]',
                exportAs: 'adaptPopover'
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.Injector }, { type: i1.AdaptDeviceDetectionService }, { type: i0.ComponentFactoryResolver }, { type: i0.ViewContainerRef }, { type: i5.AdaptPopoverConfig }, { type: i0.NgZone }, { type: i6.LayerService }, { type: i2.AdaptOverlayService }, { type: i0.ApplicationRef }, { type: i7.Directionality }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: i8.AdaptRadarAngularService }, { type: i0.ElementRef }, { type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { adaptPopover: [{
            type: Input
        }], popoverTitle: [{
            type: Input
        }], placement: [{
            type: Input
        }], fallbackPlacement: [{
            type: Input
        }], triggers: [{
            type: Input
        }], container: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], closeBtn: [{
            type: Input
        }], popupDelay: [{
            type: Input
        }], disablePopover: [{
            type: Input
        }], popoverClass: [{
            type: Input
        }], autoClose: [{
            type: Input
        }], closeOnOutOfView: [{
            type: Input
        }], shown: [{
            type: Output
        }], hidden: [{
            type: Output
        }], maxWidth: [{
            type: Input
        }], minWidth: [{
            type: Input
        }] }); })();
//# sourceMappingURL=popover.directive.js.map