import { Directive, Input, ViewContainerRef, ComponentFactoryResolver, Injector, ChangeDetectorRef } from '@angular/core';
import { Subscription } from 'rxjs';
import { PromiseTrackerService } from './promise-tracker.service';
import { AdaptBusyService } from './busy.service';
import { AdaptBusyComponent } from './busy.component';
import { AdaptBusyBackdropComponent } from './busy-backdrop.component';
import { isString, isEqual } from 'lodash-es';
import * as i0 from "@angular/core";
import * as i1 from "./busy.service";
import * as i2 from "./promise-tracker.service";
/**
 * ### Syntax
 *
 * - `<div [ngBusy]="busy">...</div>`
 * - `<div [ngBusy]="[busyA, busyB, busyC]">...</div>`
 * - `<div [ngBusy]="{busy: busy, message: 'Loading...', backdrop: false, delay: 200, minDuration: 600}">...</div>`
 */
export class AdaptBusyDirective {
    constructor(service, tracker, cfResolver, vcRef, injector, changeDetectorRef) {
        this.service = service;
        this.tracker = tracker;
        this.cfResolver = cfResolver;
        this.vcRef = vcRef;
        this.injector = injector;
        this.changeDetectorRef = changeDetectorRef;
        this.adaptRadarDisableEventSending = false;
        /**
         * Set determinate mode for loaders
         * @since v11.6.0
         * @docs-default false
         */
        this.determinate = false;
    }
    /**
     * Alias for ngBusy.busy
     * @since v10.2.0
     * @docs-default
     */
    set busyPromise(value) {
        if (this.options) {
            this.options.busy = value;
        }
        else {
            this.options = { busy: null };
        }
    }
    get busyPromise() {
        return this.options ? this.options.busy : null;
    }
    ngOnChanges(changes) {
        if (changes.options || changes.busyPromise) {
            this.updateConfig();
        }
        if (changes.determinate && this.busyRef) {
            this.busyRef.instance.determinate = this.determinate;
        }
    }
    ngOnDestroy() {
        this.destroyComponents();
    }
    updateConfig() {
        const options = this.optionsNorm = this.normalizeOptions(this.options);
        if (this.busyRef) {
            this._bindComponentProperties(options);
        }
        if (this.backdropRef) {
            this.backdropRef.instance.type = options.loaderType;
            this.backdropRef.instance.overlayClass = options.overlayClass;
        }
        if (!this.busyRef) {
            this.destroyComponents();
            if (options.backdrop) {
                this.createBackdrop();
            }
            this.createBusy();
            // need to manually run change detection cycle for the case
            // when directive is initialized with already passed busy property.
            // ngOnInit hook will be triggered only on the next change detection cycle
            // (createComponent method only attaches newly created View to the current view and renders it)
            // for the AdaptBusyComponent and AdaptBusyBackdropComponent,
            // so the subscription for the activeState$ triggered by PromiseTrackerService will be missed and components will not be rendered
            this.changeDetectorRef.detectChanges();
        }
        if (!isEqual(options.busy, this.tracker.promiseList)) {
            this.tracker.reset({
                promiseList: options.busy,
                delay: isString(options.delay) ? parseInt(options.delay, 10) : options.delay,
                minDuration: isString(options.minDuration) ? parseInt(options.minDuration, 10) : options.minDuration
            });
        }
    }
    normalizeOptions(options) {
        if (!options) {
            options = { busy: null };
        }
        else if (Array.isArray(options)
            || options instanceof Promise
            || options instanceof Subscription) {
            options = { busy: options };
        }
        options = Object.assign({}, this.service.config, options);
        if (!Array.isArray(options.busy)) {
            options.busy = [options.busy];
        }
        return options;
    }
    destroyComponents() {
        if (this.busyRef) {
            this.busyRef.destroy();
        }
        if (this.backdropRef) {
            this.backdropRef.destroy();
        }
    }
    createBackdrop() {
        const backdropFactory = this.cfResolver.resolveComponentFactory(AdaptBusyBackdropComponent);
        const { loaderType, overlayClass } = this.optionsNorm;
        this.backdropRef = this.vcRef.createComponent(backdropFactory, null, this.injector);
        this.backdropRef.instance.type = loaderType;
        this.backdropRef.instance.overlayClass = overlayClass;
    }
    createBusy() {
        const busyFactory = this.cfResolver.resolveComponentFactory(AdaptBusyComponent);
        this.busyRef = this.vcRef.createComponent(busyFactory, null, this.injector);
        this._bindComponentProperties(this.optionsNorm);
    }
    _bindComponentProperties(options) {
        const { message, wrapperClass, loaderType, sticky, offsetTop, inOutType, percentageValue, loaderClass, loaderImg, content } = options;
        const instance = this.busyRef.instance;
        instance.message = message;
        instance.wrapperClass = wrapperClass;
        instance.type = loaderType;
        instance.sticky = sticky;
        instance.offsetTop = offsetTop;
        instance.inOutType = inOutType;
        instance.value = percentageValue;
        instance.determinate = this.determinate;
        instance.loaderClass = loaderClass;
        instance.loaderImg = loaderImg;
        instance.content = content;
        instance.adaptRadarDisableEventSending = this.adaptRadarDisableEventSending;
    }
}
AdaptBusyDirective.ɵfac = function AdaptBusyDirective_Factory(t) { return new (t || AdaptBusyDirective)(i0.ɵɵdirectiveInject(i1.AdaptBusyService), i0.ɵɵdirectiveInject(i2.PromiseTrackerService), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef)); };
AdaptBusyDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptBusyDirective, selectors: [["", "adapt-busy", ""], ["", "ngBusy", ""]], inputs: { options: ["ngBusy", "options"], adaptRadarDisableEventSending: "adaptRadarDisableEventSending", busyPromise: "busyPromise", determinate: "determinate" }, features: [i0.ɵɵProvidersFeature([PromiseTrackerService]), i0.ɵɵNgOnChangesFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptBusyDirective, [{
        type: Directive,
        args: [{
                selector: '[adapt-busy], [ngBusy]',
                providers: [PromiseTrackerService]
            }]
    }], function () { return [{ type: i1.AdaptBusyService }, { type: i2.PromiseTrackerService }, { type: i0.ComponentFactoryResolver }, { type: i0.ViewContainerRef }, { type: i0.Injector }, { type: i0.ChangeDetectorRef }]; }, { options: [{
            type: Input,
            args: ['ngBusy']
        }], adaptRadarDisableEventSending: [{
            type: Input
        }], busyPromise: [{
            type: Input
        }], determinate: [{
            type: Input
        }] }); })();
//# sourceMappingURL=busy.directive.js.map