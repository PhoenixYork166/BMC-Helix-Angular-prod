import { ApplicationRef, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChild, Directive, ElementRef, EventEmitter, forwardRef, HostBinding, HostListener, Inject, Injector, Input, NgZone, Optional, Output, Renderer2, SkipSelf, TemplateRef, ViewChild, ViewContainerRef } from '@angular/core';
import { animate, query, style, transition, trigger, useAnimation } from '@angular/animations';
import { EventManager } from '@angular/platform-browser';
import { Directionality } from '@angular/cdk/bidi';
import { ComponentPortal } from '@angular/cdk/portal';
import { ESCAPE, TAB } from '@angular/cdk/keycodes';
import { asapScheduler, BehaviorSubject, fromEvent, ReplaySubject, Subject, timer } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import { isEqual, isFunction, isNil } from 'lodash-es';
import { ANIMATION_DURATION, ANIMATION_NAME, ANIMATION_TIMING_FUNCTION } from '../common/animation';
import { AdaptDeviceDetectionService } from '../common/device-detection.service';
import { AdaptOverlayService, getOverlayConnectedPositions } from '../common/overlay/index';
import { AdaptTranslateService } from '../common/i18n/index';
import { LayerService } from '../common/layer-service';
import { PopupService } from '../common/popup';
import { ResizeService } from '../common/resize/resize.service';
import { SafeCdr } from '../common/safe-cdr';
import { ScrollManageService } from '../common/scroll-manage.service';
import { adaptWarn } from '../common/logger';
import { convertPlacement, positionElements } from '../common/positioning';
import { getEventKeyCode } from '../common/key-codes';
import { getFocusableElements } from '../common/focus';
import { isEventFrom } from '../common/utilities';
import { getInteractionSource } from '../common/interaction-source';
import { AdaptDropdownCloseReason, AdaptDropdownConfig } from './dropdown.model';
import { AdaptDropdownWindow2Component } from './dropdown-window2.component';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../close/close.component";
import * as i3 from "../focus-holder/focus-holder.directive";
import * as i4 from "./dropdown.model";
import * as i5 from "../common/device-detection.service";
import * as i6 from "@angular/cdk/bidi";
import * as i7 from "../common/scroll-manage.service";
import * as i8 from "../common/layer-service";
import * as i9 from "@angular/platform-browser";
import * as i10 from "../common/resize/resize.service";
import * as i11 from "../common/overlay/index";
import * as i12 from "../common/i18n/index";
import * as i13 from "../common/radar/adapt-radar";
const _c0 = ["container"];
function AdaptDropdownWindowComponent_ng_container_1_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵlistener("click", function AdaptDropdownWindowComponent_ng_container_1_div_6_Template_div_click_0_listener($event) { return $event.stopPropagation(); });
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "button", 10);
    i0.ɵɵlistener("click", function AdaptDropdownWindowComponent_ng_container_1_div_6_Template_button_click_2_listener() { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(2); return ctx_r7.mobileView.cancelCB && ctx_r7.mobileView.cancelCB(); });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "h2", 11);
    i0.ɵɵtext(6);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n          ");
    i0.ɵɵelementStart(8, "button", 12);
    i0.ɵɵlistener("click", function AdaptDropdownWindowComponent_ng_container_1_div_6_Template_button_click_8_listener() { i0.ɵɵrestoreView(_r8); const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.mobileView.doneCB && ctx_r9.mobileView.doneCB(); });
    i0.ɵɵtext(9);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r3.mobileView.cancelBtnTitle, "\n          ");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r3.mobileView.title, "\n          ");
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("invisible", !ctx_r3.mobileView.doneCB);
    i0.ɵɵproperty("disabled", !ctx_r3.mobileView.doneCB);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n            ", ctx_r3.mobileView.doneBtnTitle, "\n          ");
} }
function AdaptDropdownWindowComponent_ng_container_1_div_11_Template(rf, ctx) { if (rf & 1) {
    const _r11 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 13);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵelementStart(2, "h5");
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n            ");
    i0.ɵɵelementStart(5, "adapt-close", 14);
    i0.ɵɵlistener("close", function AdaptDropdownWindowComponent_ng_container_1_div_11_Template_adapt_close_close_5_listener() { i0.ɵɵrestoreView(_r11); const ctx_r10 = i0.ɵɵnextContext(2); return ctx_r10.mobileView.cancelCB && ctx_r10.mobileView.cancelCB(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(2);
    i0.ɵɵclassMap("modal-title text-default");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r5.mobileView.title);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true);
} }
function AdaptDropdownWindowComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelement(2, "div", 2);
    i0.ɵɵtext(3, "\n\n      ");
    i0.ɵɵelementStart(4, "div", 3);
    i0.ɵɵtext(5, "\n        ");
    i0.ɵɵtemplate(6, AdaptDropdownWindowComponent_ng_container_1_div_6_Template, 11, 6, "div", 4);
    i0.ɵɵtext(7, "\n\n        ");
    i0.ɵɵelementStart(8, "div", 5, 6);
    i0.ɵɵtext(10, "\n          ");
    i0.ɵɵtemplate(11, AdaptDropdownWindowComponent_ng_container_1_div_11_Template, 7, 4, "div", 7);
    i0.ɵɵtext(12, "\n          ");
    i0.ɵɵelementContainer(13, 8);
    i0.ɵɵtext(14, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(15, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(16, "\n    ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(4);
    i0.ɵɵclassProp("position-relative", ctx_r0.isMobile)("is-tablet", ctx_r0.isTablet)("is-picker", ctx_r0.mobileView.isPicker)("full-height", ctx_r0.mobileView.fullHeight);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r0.mobileView.isPicker);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("dropdown-menu-mobile-placement", ctx_r0.isMobilePlacement);
    i0.ɵɵproperty("ngClass", ctx_r0.customClass);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r0.isTablet);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r0.templateRef);
} }
function AdaptDropdownWindowComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 15);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "div", 5, 6);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementContainer(6, 8);
    i0.ɵɵtext(7, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n    ");
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("is-picker", ctx_r2.mobileView.isPicker);
    i0.ɵɵproperty("adaptFocusHolder", ctx_r2.holdFocusInMenu)("holdFocusOnInit", ctx_r2.holdFocusOnOpen)("focusFirstOnInit", ctx_r2.autoFocusFirst)("eventType", ctx_r2.eventInvokedFrom)("focusFirstDelay", 250)("restoreLastFocusedElement", ctx_r2.restoreFocusAfterClose)("focusNextElement", ctx_r2.focusNextElementAfterClose);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngClass", ctx_r2.customClass);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r2.templateRef);
} }
function AdaptDropdownMenuTemplateComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵprojection(1);
    i0.ɵɵtext(2, "\n    ");
} }
const _c1 = ["*"];
const _c2 = ["contentPlacement"];
function AdaptDropdownDirective_ng_template_5_Template(rf, ctx) { }
const _c3 = [[["", "adaptDropdownAnchor", ""]], [["", "adaptDropdownToggle", ""]]];
const _c4 = ["[adaptDropdownAnchor]", "[adaptDropdownToggle]"];
export class AdaptDropdownWindowComponent {
    constructor(_elementRef, _renderer, _cdr, _ngZone) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._cdr = _cdr;
        this._ngZone = _ngZone;
        this.anchorPositionChange = new EventEmitter();
        this.popupAnimationDone = new EventEmitter();
        this._isOpen = true; // Use in animation
        this.holdFocusInMenu = false;
        this.holdFocusOnOpen = false;
        this.autoFocusFirst = true;
        this.restoreFocusAfterClose = false;
        this.focusNextElementAfterClose = false;
        this.anchorPositionTrackingTimerId = null;
        this.enableAnchorPositionTracking = true;
        this.isMobilePlacement = false;
        this.dataPlacement = 'bottom-left';
        this.defaultClass = true;
        this._closeAnimationDone = new EventEmitter();
        this._currentPlacement = 'bottom-left';
        this._destroyed$ = new ReplaySubject(1);
    }
    get mobileClass() {
        return this.isMobile;
    }
    get positionAttr() {
        return this.dataPlacement;
    }
    get backdropAnimation() {
        return this._isOpen;
    }
    get popupAnimation() {
        return this.animationMode;
    }
    afterAnimationDone(e) {
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        if (e.toState === false) {
            this._closeAnimationDone.emit();
        }
        this.popupAnimationDone.emit(Object.assign(Object.assign({}, e), { eventInvokedFrom: this.eventInvokedFrom }));
    }
    ngAfterViewInit() {
        if (this.content) {
            this.container.nativeElement.appendChild(this.content._elementRef.nativeElement);
        }
        if (this.isMobile || this.appendTo === 'body') {
            document.body.appendChild(this._elementRef.nativeElement);
            this._elementRef.nativeElement.classList.add('dd-menu--in-body');
        }
        else if (this.appendTo) {
            this.appendTo.appendChild(this._elementRef.nativeElement);
        }
        this._ngZone.onStable
            .pipe(takeUntil(this._destroyed$), take(1))
            .subscribe(() => {
            this._applyPosition();
            this.enableTrackingAnchorPosition();
        });
    }
    recalculatePosition() {
        this._applyPosition(true);
    }
    enableTrackingAnchorPosition() {
        if (this.appendTo === 'body' &&
            !this.isMobile &&
            this.anchorPositionTrackingTimerId == null &&
            this.enableAnchorPositionTracking) {
            // get the pure object without additional properties and methods
            const getSizeAndPositionFromRect = (rect) => {
                return { height: rect.height, width: rect.width, x: rect.left, y: rect.y };
            };
            this._ngZone.runOutsideAngular(() => {
                let previousAnchorRect = getSizeAndPositionFromRect(this.anchor.getBoundingClientRect());
                this.anchorPositionTrackingTimerId = setInterval(() => {
                    const currentAnchorRect = getSizeAndPositionFromRect(this.anchor.getBoundingClientRect());
                    this._applyPosition();
                    if (!isEqual(previousAnchorRect, currentAnchorRect)) {
                        previousAnchorRect = currentAnchorRect;
                        if (this.anchorPositionChange.observers.length) {
                            this._ngZone.run(() => {
                                this.anchorPositionChange.emit({
                                    previousAnchorRect,
                                    currentAnchorRect
                                });
                            });
                        }
                    }
                    // TODO: Refactor this if possible
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                }, this.anchorPositionTrackingIntervalMs);
            });
        }
    }
    ngOnDestroy() {
        if (this.anchorPositionTrackingTimerId) {
            clearInterval(this.anchorPositionTrackingTimerId);
            this.anchorPositionTrackingTimerId = null;
        }
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    /**
     * Check if click event from this window
     */
    isEventFrom(event) {
        return isEventFrom(event, this._elementRef.nativeElement);
    }
    /**
     * Close window
     */
    close() {
        this._isOpen = false;
        this.animationMode = false;
        // when used inside a component with OnPush strategy, must explicitly mark for check to ensure animationMode change is detected
        SafeCdr.markForCheck(this._cdr);
        return this._closeAnimationDone;
    }
    focusFirstItemInPopup() {
        var _a;
        (_a = getFocusableElements(this._elementRef.nativeElement)[0]) === null || _a === void 0 ? void 0 : _a.focus();
    }
    _applyPosition(useCurrentPlacement = false) {
        if (this.isMobile) {
            this._currentPlacement = 'center';
            return;
        }
        this._currentPlacement =
            positionElements(this.anchor, this.container.nativeElement, this.placement, this.isMobile || this.appendTo === 'body', null, useCurrentPlacement && this._currentPlacement !== 'center' ? this._currentPlacement : null);
        this.dataPlacement = this._currentPlacement;
        this.isMobilePlacement = this._currentPlacement === 'mobile';
        this._applyTransformOrigin();
    }
    _applyTransformOrigin() {
        let _transform = 'center top';
        switch (this._currentPlacement) {
            case 'bottom': {
                _transform = 'center top';
                break;
            }
            case 'bottom-left': {
                _transform = `${this.animationPlacement === 'center' ? 'center' : 'left'} top`;
                break;
            }
            case 'bottom-right': {
                _transform = `${this.animationPlacement === 'center' ? 'center' : 'right'} top`;
                break;
            }
            case 'top': {
                _transform = 'center bottom';
                break;
            }
            case 'top-left': {
                _transform = `${this.animationPlacement === 'center' ? 'center' : 'left'} bottom`;
                break;
            }
            case 'top-right': {
                _transform = `${this.animationPlacement === 'center' ? 'center' : 'right'} bottom`;
                break;
            }
            case 'left': {
                _transform = 'right center';
                break;
            }
            case 'left-top': {
                _transform = `right ${this.animationPlacement === 'center' ? 'center' : 'top'}`;
                break;
            }
            case 'left-bottom': {
                _transform = `right ${this.animationPlacement === 'center' ? 'center' : 'bottom'}`;
                break;
            }
            case 'right': {
                _transform = 'left center';
                break;
            }
            case 'right-top': {
                _transform = `left ${this.animationPlacement === 'center' ? 'center' : 'top'}`;
                break;
            }
            case 'right-bottom': {
                _transform = `left ${this.animationPlacement === 'center' ? 'center' : 'bottom'}`;
                break;
            }
            case 'center': {
                _transform = 'center center';
                break;
            }
        }
        this._renderer.setStyle(this.container.nativeElement, 'transform-origin', _transform);
    }
}
AdaptDropdownWindowComponent.ɵfac = function AdaptDropdownWindowComponent_Factory(t) { return new (t || AdaptDropdownWindowComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone)); };
AdaptDropdownWindowComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDropdownWindowComponent, selectors: [["adapt-dropdown-window"]], viewQuery: function AdaptDropdownWindowComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);
    } }, hostVars: 7, hostBindings: function AdaptDropdownWindowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵsyntheticHostListener("@popupAnimation.done", function AdaptDropdownWindowComponent_animation_popupAnimation_done_HostBindingHandler($event) { return ctx.afterAnimationDone($event); });
    } if (rf & 2) {
        i0.ɵɵattribute("data-position", ctx.positionAttr);
        i0.ɵɵsyntheticHostProperty("@backdropAnimation", ctx.backdropAnimation)("@popupAnimation", ctx.popupAnimation);
        i0.ɵɵclassProp("a-dropdown-window", ctx.defaultClass)("a-dropdown-window_mobile", ctx.mobileClass);
    } }, decls: 6, vars: 2, consts: [[4, "ngIf", "ngIfElse"], ["desktopView", ""], [1, "a-dropdown-window--backdrop"], [1, "a-dropdown-window--wrapper"], ["class", "a-dropdown-window--header", 3, "click", 4, "ngIf"], [1, "a-dropdown-window--menu", 3, "ngClass"], ["container", ""], ["class", "modal-header", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "a-dropdown-window--header", 3, "click"], ["type", "button", 1, "btn", "btn-link", "btn-sm", 3, "click"], [1, "m-0", "text-center"], [1, "btn", "btn-link", "btn-sm", 3, "disabled", "click"], [1, "modal-header"], [3, "adaptRadarDisableEventSending", "close"], [1, "a-dropdown-window--wrapper", 3, "adaptFocusHolder", "holdFocusOnInit", "focusFirstOnInit", "eventType", "focusFirstDelay", "restoreLastFocusedElement", "focusNextElement"]], template: function AdaptDropdownWindowComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵtemplate(1, AdaptDropdownWindowComponent_ng_container_1_Template, 17, 14, "ng-container", 0);
        i0.ɵɵtext(2, "\n\n    ");
        i0.ɵɵtemplate(3, AdaptDropdownWindowComponent_ng_template_3_Template, 10, 11, "ng-template", null, 1, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(5, "\n  ");
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(4);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.isMobile || ctx.isTablet)("ngIfElse", _r1);
    } }, directives: [i1.NgIf, i1.NgClass, i1.NgTemplateOutlet, i2.AdaptCloseComponent, i3.AdaptFocusHolderDirective], encapsulation: 2, data: { animation: [
            trigger('popupAnimation', [
                transition('void => desktop', [
                    query('.a-dropdown-window--menu', [
                        useAnimation(ANIMATION_NAME.popIn)
                    ])
                ]),
                transition('desktop => 0', [
                    query('.a-dropdown-window--menu', [
                        useAnimation(ANIMATION_NAME.popOut)
                    ])
                ]),
                transition('void => mobile', [
                    query('.a-dropdown-window--wrapper', [
                        style({ transform: 'translate(0px, 100%)', opacity: '0' }),
                        animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ transform: 'translate(0px, 0px)', opacity: '1' }))
                    ])
                ]),
                transition('mobile => 0', [
                    query('.a-dropdown-window--wrapper', [
                        style({ transform: 'translate(0px, 0px)', opacity: '1' }),
                        animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionOut}`, style({ transform: 'translate(0px, 100%)', opacity: '0' }))
                    ])
                ]),
                transition('void => picker', [
                    query('.a-dropdown-window--wrapper', [
                        useAnimation(ANIMATION_NAME.popIn)
                    ])
                ]),
                transition('picker => 0', [
                    query('.a-dropdown-window--wrapper', [
                        useAnimation(ANIMATION_NAME.popOut)
                    ])
                ])
            ]),
            trigger('backdropAnimation', [
                transition('void => 1', [
                    query('.a-dropdown-window--backdrop', [
                        useAnimation(ANIMATION_NAME.opacity)
                    ], { optional: true })
                ]),
                transition('1 => 0', [
                    query('.a-dropdown-window--backdrop', [
                        useAnimation(ANIMATION_NAME.opacity, {
                            params: {
                                from: '*',
                                to: '0'
                            }
                        })
                    ], { optional: true })
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropdownWindowComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-dropdown-window',
                template: `
    <ng-container *ngIf="isMobile || isTablet; else desktopView">
      <div class="a-dropdown-window--backdrop"></div>

      <div class="a-dropdown-window--wrapper"
           [class.position-relative]="isMobile"
           [class.is-tablet]="isTablet"
           [class.is-picker]="mobileView.isPicker"
           [class.full-height]="mobileView.fullHeight">
        <div class="a-dropdown-window--header" *ngIf="!mobileView.isPicker" (click)="$event.stopPropagation()">
          <button type="button" class="btn btn-link btn-sm" (click)="mobileView.cancelCB && mobileView.cancelCB()">
            {{mobileView.cancelBtnTitle}}
          </button>
          <h2 class="m-0 text-center">
            {{mobileView.title}}
          </h2>
          <button class="btn btn-link btn-sm"
                  (click)="mobileView.doneCB && mobileView.doneCB()"
                  [disabled]="!mobileView.doneCB"
                  [class.invisible]="!mobileView.doneCB">
            {{mobileView.doneBtnTitle}}
          </button>
        </div>

        <div #container class="a-dropdown-window--menu"
             [ngClass]="customClass"
             [class.dropdown-menu-mobile-placement]="isMobilePlacement">
          <div class="modal-header" *ngIf="isTablet">
            <h5 [class]="'modal-title text-default'">{{mobileView.title}}</h5>
            <adapt-close [adaptRadarDisableEventSending]="true"
                         (close)="mobileView.cancelCB && mobileView.cancelCB()"></adapt-close>
          </div>
          <ng-container [ngTemplateOutlet]="templateRef"></ng-container>
        </div>
      </div>
    </ng-container>

    <ng-template #desktopView>
      <div class="a-dropdown-window--wrapper"
           [adaptFocusHolder]="holdFocusInMenu"
           [holdFocusOnInit]="holdFocusOnOpen"
           [focusFirstOnInit]="autoFocusFirst"
           [eventType]="eventInvokedFrom"
           [class.is-picker]="mobileView.isPicker"
           [focusFirstDelay]="250"
           [restoreLastFocusedElement]="restoreFocusAfterClose"
           [focusNextElement]="focusNextElementAfterClose">
        <div #container class="a-dropdown-window--menu" [ngClass]="customClass">
          <ng-container [ngTemplateOutlet]="templateRef"></ng-container>
        </div>
      </div>
    </ng-template>
  `,
                animations: [
                    trigger('popupAnimation', [
                        transition('void => desktop', [
                            query('.a-dropdown-window--menu', [
                                useAnimation(ANIMATION_NAME.popIn)
                            ])
                        ]),
                        transition('desktop => 0', [
                            query('.a-dropdown-window--menu', [
                                useAnimation(ANIMATION_NAME.popOut)
                            ])
                        ]),
                        transition('void => mobile', [
                            query('.a-dropdown-window--wrapper', [
                                style({ transform: 'translate(0px, 100%)', opacity: '0' }),
                                animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionIn}`, style({ transform: 'translate(0px, 0px)', opacity: '1' }))
                            ])
                        ]),
                        transition('mobile => 0', [
                            query('.a-dropdown-window--wrapper', [
                                style({ transform: 'translate(0px, 0px)', opacity: '1' }),
                                animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.transitionOut}`, style({ transform: 'translate(0px, 100%)', opacity: '0' }))
                            ])
                        ]),
                        transition('void => picker', [
                            query('.a-dropdown-window--wrapper', [
                                useAnimation(ANIMATION_NAME.popIn)
                            ])
                        ]),
                        transition('picker => 0', [
                            query('.a-dropdown-window--wrapper', [
                                useAnimation(ANIMATION_NAME.popOut)
                            ])
                        ])
                    ]),
                    trigger('backdropAnimation', [
                        transition('void => 1', [
                            query('.a-dropdown-window--backdrop', [
                                useAnimation(ANIMATION_NAME.opacity)
                            ], { optional: true })
                        ]),
                        transition('1 => 0', [
                            query('.a-dropdown-window--backdrop', [
                                useAnimation(ANIMATION_NAME.opacity, {
                                    params: {
                                        from: '*',
                                        to: '0'
                                    }
                                })
                            ], { optional: true })
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }]; }, { container: [{
            type: ViewChild,
            args: ['container', { static: false }]
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.a-dropdown-window']
        }], mobileClass: [{
            type: HostBinding,
            args: ['class.a-dropdown-window_mobile']
        }], positionAttr: [{
            type: HostBinding,
            args: ['attr.data-position']
        }], backdropAnimation: [{
            type: HostBinding,
            args: ['@backdropAnimation']
        }], popupAnimation: [{
            type: HostBinding,
            args: ['@popupAnimation']
        }], afterAnimationDone: [{
            type: HostListener,
            args: ['@popupAnimation.done', ['$event']]
        }] }); })();
/**
 * Dropdown menu container
 */
export class AdaptDropdownMenuDirective {
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    constructor(dropdown, 
    // Made public to resolve problem with dropdown inside dropdown in case of <ng-content>
    // https://github.com/angular/angular/issues/14935
    _elementRef) {
        this.dropdown = dropdown;
        this._elementRef = _elementRef;
        this.isOpen = false;
        this.transitionStyle = 'none';
        this._currentPlacement = 'bottom-left';
    }
    get transformOrigin() {
        let _transform = 'center top';
        switch (this._currentPlacement) {
            case 'bottom': {
                _transform = 'center top';
                break;
            }
            case 'bottom-left': {
                _transform = this.dropdown.animationPlacement === 'auto' ? 'left top' : 'center top';
                break;
            }
            case 'bottom-right': {
                _transform = this.dropdown.animationPlacement === 'auto' ? 'right top' : 'center top';
                break;
            }
            case 'top': {
                _transform = 'center bottom';
                break;
            }
            case 'top-left': {
                _transform = this.dropdown.animationPlacement === 'auto' ? 'left bottom' : 'center bottom';
                break;
            }
            case 'top-right': {
                _transform = this.dropdown.animationPlacement === 'auto' ? 'right bottom' : 'center bottom';
                break;
            }
            case 'left': {
                _transform = 'right center';
                break;
            }
            case 'left-top': {
                _transform = this.dropdown.animationPlacement === 'auto' ? 'right top' : 'right center';
                break;
            }
            case 'left-bottom': {
                _transform = this.dropdown.animationPlacement === 'auto' ? 'right bottom' : 'right-center';
                break;
            }
            case 'right': {
                _transform = 'left center';
                break;
            }
            case 'right-top': {
                _transform = this.dropdown.animationPlacement === 'auto' ? 'left top' : 'left-center';
                break;
            }
            case 'right-bottom': {
                _transform = this.dropdown.animationPlacement === 'auto' ? 'left bottom' : 'left-center';
                break;
            }
        }
        return _transform;
    }
    get transformOriginStyle() {
        return this.transformOrigin;
    }
    isEventFrom(event) {
        return isEventFrom(event, this._elementRef.nativeElement);
    }
    position(triggerEl, placement) {
        this._currentPlacement = positionElements(triggerEl, this._elementRef.nativeElement, placement);
    }
}
AdaptDropdownMenuDirective.ɵfac = function AdaptDropdownMenuDirective_Factory(t) { return new (t || AdaptDropdownMenuDirective)(i0.ɵɵdirectiveInject(forwardRef(() => AdaptDropdownDirective)), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptDropdownMenuDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptDropdownMenuDirective, selectors: [["", "adaptDropdownMenu", ""]], hostVars: 4, hostBindings: function AdaptDropdownMenuDirective_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵstyleProp("transition", ctx.transitionStyle)("transform-origin", ctx.transformOriginStyle);
    } } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropdownMenuDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptDropdownMenu]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(() => AdaptDropdownDirective)]
            }] }, { type: i0.ElementRef }]; }, { transitionStyle: [{
            type: HostBinding,
            args: ['style.transition']
        }], transformOriginStyle: [{
            type: HostBinding,
            args: ['style.transformOrigin']
        }] }); })();
export class AdaptDropdownMenuTemplateDirective {
    constructor(menuTemplateRef) {
        this.menuTemplateRef = menuTemplateRef;
    }
}
AdaptDropdownMenuTemplateDirective.ɵfac = function AdaptDropdownMenuTemplateDirective_Factory(t) { return new (t || AdaptDropdownMenuTemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef)); };
AdaptDropdownMenuTemplateDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptDropdownMenuTemplateDirective, selectors: [["ng-template", "adaptDropdownMenuTemplate", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropdownMenuTemplateDirective, [{
        type: Directive,
        args: [{
                selector: 'ng-template[adaptDropdownMenuTemplate]'
            }]
    }], function () { return [{ type: i0.TemplateRef }]; }, null); })();
export class AdaptDropdownMenuTemplateComponent {
}
AdaptDropdownMenuTemplateComponent.ɵfac = function AdaptDropdownMenuTemplateComponent_Factory(t) { return new (t || AdaptDropdownMenuTemplateComponent)(); };
AdaptDropdownMenuTemplateComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDropdownMenuTemplateComponent, selectors: [["adapt-dropdown-menu-template"]], viewQuery: function AdaptDropdownMenuTemplateComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(TemplateRef, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, ngContentSelectors: _c1, decls: 3, vars: 0, template: function AdaptDropdownMenuTemplateComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵtemplate(1, AdaptDropdownMenuTemplateComponent_ng_template_1_Template, 3, 0, "ng-template");
        i0.ɵɵtext(2, "\n  ");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropdownMenuTemplateComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-dropdown-menu-template',
                template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `
            }]
    }], null, { templateRef: [{
            type: ViewChild,
            args: [TemplateRef]
        }] }); })();
/**
 * Marks an element to which dropdown menu will be anchored. This is a simple version
 * of the AdaptDropdownToggle directive. It plays the same role as adaptDropdownToggle but
 * doesn't listen to click events to toggle dropdown menu thus enabling support for
 * events other than click.
 *
 * @since 1.1.0
 */
export class AdaptDropdownAnchorDirective {
    // TODO(nicholas): change type to AdaptDropdownDirective
    // from migration to angular 8
    // https://github.com/angular/angular/issues/30106
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    constructor(dropdown, _elementRef, _renderer) {
        this.dropdown = dropdown;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.ariaHasPopupAttr = true;
        this.ariaExpandedAttr = false;
        this._destroyed$ = new ReplaySubject(1);
        this._shouldFocusPopup = false;
        this.anchorEl = _elementRef.nativeElement;
    }
    ngOnInit() {
        fromEvent(this._elementRef.nativeElement, 'keydown')
            .pipe(takeUntil(this._destroyed$))
            .subscribe((event) => {
            this._shouldFocusPopup = getEventKeyCode(event) === TAB && !event.shiftKey;
        });
        fromEvent(this._elementRef.nativeElement, 'focusout')
            .pipe(takeUntil(this._destroyed$))
            .subscribe(() => {
            if (this._shouldFocusPopup) {
                if (this.dropdown.isOpen() && isFunction(this.dropdown.focusFirstItemInPopup)) {
                    this.dropdown.focusFirstItemInPopup();
                }
            }
        });
        this.dropdown.popupAnimationDone
            .pipe(takeUntil(this._destroyed$))
            .subscribe((event) => {
            if (event) {
                this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-expanded', `${!!event.toState}`);
            }
        });
    }
    ngOnDestroy() {
        this._destroyed$.next();
        this._destroyed$.complete();
    }
    isEventFrom(event) {
        return isEventFrom(event, this._elementRef.nativeElement);
    }
}
AdaptDropdownAnchorDirective.ɵfac = function AdaptDropdownAnchorDirective_Factory(t) { return new (t || AdaptDropdownAnchorDirective)(i0.ɵɵdirectiveInject(forwardRef(() => AdaptDropdownDirective)), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2)); };
AdaptDropdownAnchorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptDropdownAnchorDirective, selectors: [["", "adaptDropdownAnchor", ""]], hostVars: 2, hostBindings: function AdaptDropdownAnchorDirective_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵattribute("aria-haspopup", ctx.ariaHasPopupAttr)("aria-expanded", ctx.ariaExpandedAttr);
    } } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropdownAnchorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptDropdownAnchor]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(() => AdaptDropdownDirective)]
            }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, { ariaHasPopupAttr: [{
            type: HostBinding,
            args: ['attr.aria-haspopup']
        }], ariaExpandedAttr: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }] }); })();
/**
 * Allows the dropdown to be toggled via click. This directive is optional: you can use AdaptDropdownAnchor as an alternative.
 */
export class AdaptDropdownToggleDirective extends AdaptDropdownAnchorDirective {
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    constructor(dropdown, elementRef, renderer) {
        super(dropdown, elementRef, renderer);
        /**
         * Uses to control caret visibility
         * @docs-default true
         * @since v10.14.0
         */
        this.showCaret = true;
        /**
         * Set caret color type. Can be useful for instance if the button looks like a link so the caret should reflect link styles
         * @docs-default default
         * @since v10.17.0
         */
        this.dropdownTogglerType = 'default';
        this.ariaExpandedAttr = false;
        this.ariaHasPopupAttr = true;
    }
    get toggleClass() {
        return this.showCaret;
    }
    get toggleUpClass() {
        return this.isDropUp();
    }
    get toggleLinkClass() {
        return this.showCaret && this.dropdownTogglerType === 'link';
    }
    click(e) {
        this.toggleOpen(e);
    }
    isDropUp() {
        let dropUp;
        if (Array.isArray(this.dropdown.placement)) {
            const matches = this.dropdown.placement.filter(el => (el.split('-')[0] === 'top'));
            dropUp = matches.length === this.dropdown.placement.length;
        }
        else {
            dropUp = this.dropdown.placement.split('-')[0] === 'top';
        }
        return dropUp;
    }
    toggleOpen(e) {
        this.dropdown.toggle(e);
    }
}
AdaptDropdownToggleDirective.ɵfac = function AdaptDropdownToggleDirective_Factory(t) { return new (t || AdaptDropdownToggleDirective)(i0.ɵɵdirectiveInject(forwardRef(() => AdaptDropdownDirective)), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2)); };
AdaptDropdownToggleDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptDropdownToggleDirective, selectors: [["", "adaptDropdownToggle", ""]], hostVars: 8, hostBindings: function AdaptDropdownToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("click", function AdaptDropdownToggleDirective_click_HostBindingHandler($event) { return ctx.click($event); });
    } if (rf & 2) {
        i0.ɵɵattribute("aria-expanded", ctx.ariaExpandedAttr)("aria-haspopup", ctx.ariaHasPopupAttr);
        i0.ɵɵclassProp("dropdown-toggle", ctx.toggleClass)("dropdown-toggle-up", ctx.toggleUpClass)("dropdown-toggle-link", ctx.toggleLinkClass);
    } }, inputs: { showCaret: "showCaret", dropdownTogglerType: "dropdownTogglerType" }, features: [i0.ɵɵProvidersFeature([{
                provide: AdaptDropdownAnchorDirective,
                useExisting: forwardRef(() => AdaptDropdownToggleDirective)
            }]), i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropdownToggleDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptDropdownToggle]',
                providers: [{
                        provide: AdaptDropdownAnchorDirective,
                        useExisting: forwardRef(() => AdaptDropdownToggleDirective)
                    }]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [forwardRef(() => AdaptDropdownDirective)]
            }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, { showCaret: [{
            type: Input
        }], dropdownTogglerType: [{
            type: Input
        }], ariaExpandedAttr: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], toggleClass: [{
            type: HostBinding,
            args: ['class.dropdown-toggle']
        }], toggleUpClass: [{
            type: HostBinding,
            args: ['class.dropdown-toggle-up']
        }], toggleLinkClass: [{
            type: HostBinding,
            args: ['class.dropdown-toggle-link']
        }], ariaHasPopupAttr: [{
            type: HostBinding,
            args: ['attr.aria-haspopup']
        }], click: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
/**
 * Transforms a node into a dropdown.
 */
// eslint-disable-next-line @angular-eslint/component-class-suffix
export class AdaptDropdownDirective extends AdaptRadarAngularGenericDirective {
    constructor(config, _componentFactoryResolver, _deviceDetector, _dir, _el, _injector, _renderer, _scrollService, _layerService, _eventManager, _resizeService, _overlayService, _applicationRef, ts, _parentDropdownDirective, _adaptRadarService) {
        super(_adaptRadarService, _el, AdaptRadarAngularCustomEventName.AdaptDropdown);
        this._componentFactoryResolver = _componentFactoryResolver;
        this._deviceDetector = _deviceDetector;
        this._dir = _dir;
        this._el = _el;
        this._injector = _injector;
        this._renderer = _renderer;
        this._scrollService = _scrollService;
        this._layerService = _layerService;
        this._eventManager = _eventManager;
        this._resizeService = _resizeService;
        this._overlayService = _overlayService;
        this._applicationRef = _applicationRef;
        this.ts = ts;
        this._parentDropdownDirective = _parentDropdownDirective;
        this.defaultTexts = {};
        /**
         * Animation transform-origin property
         * @docs-default auto
         */
        this.animationPlacement = 'auto';
        /**
         *  Hold `Tab` key focus in the dropdownMenu area
         *  @docs-default false
         */
        this.holdFocusInMenu = false;
        /**
         *  Auto holding focus on dropdownMenu open
         *  @docs-default false
         */
        this.holdFocusOnOpen = false;
        /**
         * Focus first menu item on open
         * @docs-default true
         */
        this.autoFocusFirst = true;
        /**
         *  After menu close, restore focus the element which was in focus before menu open
         *  @docs-default false
         */
        this.restoreFocusAfterClose = false;
        /**
         *  After menu close, focus the next element which was in focus before menu open
         *  @docs-default true
         */
        this.focusNextElementAfterClose = true;
        /**
         *  Interval of anchor position tracking when the menu is attached to the body.
         *  Change the value if you have some performance problems or you have a delay in the menu
         *  positioning
         *  @docs-default 30
         */
        this.anchorPositionTrackingIntervalMs = 30;
        /**
         *  Enable an anchor position tracking when the menu is attached to the body
         *  @docs-default true
         */
        this.enableAnchorPositionTracking = true;
        /**
         * Add resize listener on passed HTML element and recalculate dropdown position when element resize. Can be helpful when dropdown has dynamic height
         * @docs-default
         */
        this.recalculatePositionOnElementResize = null;
        /* eslint-disable @angular-eslint/no-output-on-prefix */
        /**
         *  An event fired when the dropdown is open
         *  @since v10.9.0
         */
        this.onOpen = new EventEmitter();
        /**
         *  An event fired when the dropdown is closed via internal reason:
         *  escape button click, click inside, click outside or component destroy
         *  @since v10.9.0
         */
        this.onClose = new EventEmitter();
        /* eslint-enable @angular-eslint/no-output-on-prefix */
        this.anchorPositionChange = new EventEmitter();
        this.popupAnimationDone = new EventEmitter();
        this.defaultClass = true;
        this._mobileView = {
            title: null,
            fullHeight: null,
            cancelCB: (() => this.close()),
            doneCB: null,
            doneBtnTitle: '',
            cancelBtnTitle: '',
            isPicker: null
        };
        /**
         * Subject for trapping [open] setter till OnInit complete
         */
        this._init$ = new BehaviorSubject(false);
        this._isMobile = false;
        this._isTablet = false;
        this._animationMode = 'desktop';
        this._open = false;
        this._closing = false;
        this._removeMenuWindowRef$ = new Subject();
        this._openTimeout = null;
        this.placement = config.placement;
        this.autoClose = config.autoClose;
        this.setDefaultTexts(ts.getCurrentLanguage());
        this._overlayConnectedPositions = getOverlayConnectedPositions(this._dir.value, 2);
    }
    /**
     * When specified, the drop-down list will be attached to the body
     * @docs-default false
     */
    set appendToBody(state) {
        if (state && !this._appendTo) {
            this.appendTo = 'body';
        }
    }
    /**
     * When specified, the drop-down list will be attached to the selected element
     * @docs-default
     */
    set appendTo(element) {
        this._appendTo = element;
    }
    /**
     * Setup for mobile view
     * @docs-default
     */
    set mobileView(obj) {
        const defaultCancelCB = () => this.close();
        if (obj) {
            this._mobileView.title = obj.title || null;
            this._mobileView.fullHeight = obj.fullHeight || null;
            this._mobileView.cancelCB = obj.cancelCB
                ? () => obj.cancelCB(this)
                : defaultCancelCB;
            this._mobileView.doneCB = obj.doneCB ? () => obj.doneCB(this) : null;
            this._mobileView.doneBtnTitle = obj.doneBtnTitle || this.defaultTexts.doneBtnTitle;
            this._mobileView.cancelBtnTitle = obj.cancelBtnTitle || this.defaultTexts.cancelBtnTitle;
            this._mobileView.isPicker = obj.isPicker || null;
        }
        else {
            this._mobileView = {
                cancelCB: defaultCancelCB,
                doneBtnTitle: this.defaultTexts.doneBtnTitle,
                cancelBtnTitle: this.defaultTexts.cancelBtnTitle
            };
        }
    }
    ngOnInit() {
        this.dropdownId = ++AdaptDropdownDirective.LAST_ID;
        // Get scroll manager
        this._scrollManager = this._scrollService.getScrollManager(document.body);
        if (isNil(this.setMobileState)) {
            this._isTablet = this._deviceDetector.deviceTablet();
            this._isMobile = this._deviceDetector.isMobile();
            if (this._isTablet) {
                this._mobileView.isPicker = true;
            }
        }
        else {
            this._isMobile = this.setMobileState;
        }
        this._animationMode = this._isMobile ? (this._mobileView.isPicker ? 'picker' : 'mobile') : 'desktop';
        if ((this._dir.value === 'rtl') && (this.placement)) {
            this.placement = convertPlacement(this.placement);
        }
        this._popupWindowService = new PopupService(AdaptDropdownWindowComponent, this._injector, this.contentPlacement, this._renderer, this._componentFactoryResolver, this._applicationRef);
        // Tell subscribers that init complete
        this._init$.next(true);
    }
    ngOnChanges(changes) {
        var _a, _b;
        // In case we want to change custom class after dropdown opened
        if (changes.customClass && ((_a = this.menuWindowRef) === null || _a === void 0 ? void 0 : _a.instance)) {
            this.menuWindowRef.instance.customClass = this.customClass;
        }
        if ((_b = this.menuWindowRef) === null || _b === void 0 ? void 0 : _b.instance) {
            if (changes.restoreFocusAfterClose) {
                this.menuWindowRef.instance.restoreFocusAfterClose = this.restoreFocusAfterClose;
            }
            if (changes.focusNextElementAfterClose) {
                this.menuWindowRef.instance.focusNextElementAfterClose = this.focusNextElementAfterClose;
            }
        }
    }
    ngOnDestroy() {
        if (this._overlayService.enableCDKOverlayControl) {
            this._closeOverlay(AdaptDropdownCloseReason.Destroy, true);
            return;
        }
        if (this.menuWindowRef) {
            this._removeMenuWindowRef();
            this._closeIfActive();
            if (this._isMobile) {
                this._scrollManager.show(this);
            }
            this.onClose.emit(AdaptDropdownCloseReason.Destroy);
            this._layerService.removeComponent(this);
            if (this._removeTapEventListener) {
                this._removeTapEventListener();
            }
        }
        if (this.recalculatePositionOnElementResize) {
            this._resizeService.removeResizeEventListener(this.recalculatePositionOnElementResize);
        }
        if (this._openTimeout) {
            clearTimeout(this._openTimeout);
            this._openTimeout = null;
        }
    }
    setDefaultTexts(translation) {
        this.defaultTexts.doneBtnTitle = translation['adapt.common.done'];
        this.defaultTexts.cancelBtnTitle = translation['adapt.common.cancel'];
        this._mobileView.doneBtnTitle = this.defaultTexts.doneBtnTitle;
        this._mobileView.cancelBtnTitle = this.defaultTexts.cancelBtnTitle;
    }
    /**
     * Checks if the dropdown menu is open or not.
     */
    isOpen() {
        return this._open;
    }
    /**
     * Opens the dropdown menu of a given navbar or tabbed navigation.
     */
    open(event) {
        var _a, _b;
        this.eventInvokedFrom = getInteractionSource(event);
        if (this.eventInvokedFrom === 'program') {
            adaptWarn('In case call of the open method without passed event, the event type is "program" by default.');
        }
        if (this._overlayService.enableCDKOverlayControl) {
            this._openOverlay(this.eventInvokedFrom);
            return;
        }
        if (this.menuWindowRef) {
            if (!this._closing) {
                return;
            }
            this.menuWindowRef.instance.close().complete();
            this._closeSubscription.unsubscribe();
            this._removeMenuWindowRef();
            this._closing = false;
            this._openTimeout = window.setTimeout(() => {
                this._createMenuWindowRef(this.eventInvokedFrom);
                clearTimeout(this._openTimeout);
                this._openTimeout = null;
            }, 0);
        }
        else {
            if (!(this._parentDropdownDirective
                /**
                 * Check that active dropdown menu contains child dropdown (eg. advanced filter contains select inside tabs)
                 * The root cause of the problem is that we can't access to the _parentDropdownDirective because select insert as content projection.
                 * And nodes are only "projected" (moved to a different location) but everything else works relative to their source (= before projection) location
                 * https://github.com/angular/angular/issues/14935
                 * https://github.com/angular/angular/issues/17723
                 */
                || ((_b = (_a = AdaptDropdownDirective.ActivePicker) === null || _a === void 0 ? void 0 : _a._menu) === null || _b === void 0 ? void 0 : _b._elementRef.nativeElement.contains(this._el.nativeElement))) && !this.autoClose) {
                // Allow child dropdown opening
                // TODO: check and refactor active dropdown detection functional
                this._closeActive();
            }
            this._createMenuWindowRef(this.eventInvokedFrom);
        }
    }
    /**
     * Closes the dropdown menu of a given navbar or tabbed navigation.
     */
    close(reason = null) {
        if (this._overlayService.enableCDKOverlayControl) {
            this._closeOverlay(reason);
            return;
        }
        if (this.menuWindowRef && this._open) {
            this._closing = true;
            this._closeSubscription = this.menuWindowRef.instance.close().subscribe(() => {
                this._removeMenuWindowRef();
                this._closing = false;
                // Wait until close animation completes before resetting scroll on document body; doing it sooner causes the menu window to
                // immediately "jump" in ios, displacing the position of contained elements and preventing click events from firing (issue 2214).
                if (this._isMobile) {
                    this._scrollManager.show(this);
                }
                this._closeIfActive();
            });
            this._layerService.removeComponent(this);
            this._open = false;
            this.onClose.emit(reason);
            if (this.recalculatePositionOnElementResize) {
                this._resizeService.removeResizeEventListener(this.recalculatePositionOnElementResize);
            }
        }
        if (this._removeTapEventListener) {
            this._removeTapEventListener();
        }
    }
    /**
     * Toggles the dropdown menu of a given navbar or tabbed navigation.
     */
    toggle(e) {
        this.isOpen() ? this.close() : this.open(e);
    }
    focusFirstItemInPopup() {
        var _a, _b;
        if (this._overlayService.enableCDKOverlayControl) {
            (_a = this._overlayWithPortal) === null || _a === void 0 ? void 0 : _a.componentRef.instance.focusFirstItemInPopup();
        }
        else {
            (_b = this.menuWindowRef) === null || _b === void 0 ? void 0 : _b.instance.focusFirstItemInPopup();
        }
    }
    isEventFromMenu(e) {
        const popupRef = this._overlayService.enableCDKOverlayControl ? this._overlayWithPortal.componentRef : this.menuWindowRef;
        return popupRef ? popupRef.instance.isEventFrom(e) : false;
    }
    _createMenuWindowRef(eventFrom) {
        this.menuWindowRef = this._popupWindowService.open();
        this.menuWindowRef.instance.templateRef = this._menuTemplate ? this._menuTemplate.menuTemplateRef : null;
        this.menuWindowRef.instance.content = this._menu;
        if (this._appendTo) {
            this.menuWindowRef.instance.appendTo = this._appendTo;
        }
        if (this.positionTo) {
            this.menuWindowRef.instance.anchor = this.positionTo;
        }
        else {
            this.menuWindowRef.instance.anchor = this._anchor ? this._anchor.anchorEl : this._el.nativeElement;
        }
        this.menuWindowRef.instance.placement = this.placement;
        this.menuWindowRef.instance.isMobile = this._isMobile;
        this.menuWindowRef.instance.isTablet = this._isTablet;
        this.menuWindowRef.instance.customClass = this.customClass;
        this.menuWindowRef.instance.mobileView = this._mobileView;
        this.menuWindowRef.instance.animationMode = this._animationMode;
        this.menuWindowRef.instance.animationPlacement = this.animationPlacement;
        this.menuWindowRef.instance.holdFocusInMenu = this.holdFocusInMenu;
        this.menuWindowRef.instance.holdFocusOnOpen = this.holdFocusOnOpen;
        this.menuWindowRef.instance.autoFocusFirst = this.autoFocusFirst;
        this.menuWindowRef.instance.eventInvokedFrom = eventFrom;
        this.menuWindowRef.instance.restoreFocusAfterClose = this.restoreFocusAfterClose;
        this.menuWindowRef.instance.focusNextElementAfterClose = this.focusNextElementAfterClose;
        this.menuWindowRef.instance.anchorPositionTrackingIntervalMs = this.anchorPositionTrackingIntervalMs;
        this.menuWindowRef.instance.enableAnchorPositionTracking = this.enableAnchorPositionTracking;
        this.menuWindowRef.instance.anchorPositionChange = this.anchorPositionChange;
        this.menuWindowRef.instance.popupAnimationDone = this.popupAnimationDone;
        this._markAsActive();
        this._open = true;
        if (this._isMobile) {
            this._scrollManager.hide(this);
        }
        this.onOpen.emit();
        this._eventType = this._isMobile ? 'tap' : 'click';
        this._removeTapEventListener = this._eventManager.addGlobalEventListener('document', this._eventType, this._closeFromClick.bind(this));
        this._layerService.addComponent(this, () => {
            if (this.autoClose || this.closeOnEscape) {
                this.close(AdaptDropdownCloseReason.Esc);
            }
        });
        if (this.recalculatePositionOnElementResize) {
            this._resizeService.addResizeEventListener(this.recalculatePositionOnElementResize, () => {
                if (this.menuWindowRef) {
                    this.menuWindowRef.instance.recalculatePosition();
                }
            });
        }
        timer(0, asapScheduler)
            .pipe(takeUntil(this._removeMenuWindowRef$))
            .subscribe(() => {
            var _a;
            (_a = this.menuWindowRef) === null || _a === void 0 ? void 0 : _a.hostView.detectChanges();
        });
    }
    _removeMenuWindowRef() {
        if (this.menuWindowRef) {
            this._removeMenuWindowRef$.next();
            this._popupWindowService.close();
            this.menuWindowRef = null;
        }
    }
    _openOverlay(eventInvokedFrom) {
        var _a;
        if (!this._open) {
            if (this._closing) {
                this._closeOverlay(AdaptDropdownCloseReason.Destroy, true);
            }
            let connectedPositions = [];
            if (!(this._isMobile || this._isTablet)) {
                const placementArray = this.placement ? (Array.isArray(this.placement) ? this.placement : [this.placement]) : [];
                placementArray.forEach((placementItem) => {
                    if (!(placementItem === 'auto' || placementItem === 'mobile')) {
                        let connectedPositionName;
                        if (this._dir.value === 'rtl') {
                            connectedPositionName =
                                placementItem.replace('left', 'right').replace('right', 'left');
                        }
                        else {
                            connectedPositionName = placementItem;
                        }
                        connectedPositions.push(this._overlayConnectedPositions[connectedPositionName]);
                    }
                    if (placementItem === 'auto') {
                        connectedPositions.push(this._overlayConnectedPositions['bottom-start'], this._overlayConnectedPositions['bottom-end'], this._overlayConnectedPositions['top-start'], this._overlayConnectedPositions['top-end'], this._overlayConnectedPositions['start'], this._overlayConnectedPositions['start-top'], this._overlayConnectedPositions['start-bottom'], this._overlayConnectedPositions['end'], this._overlayConnectedPositions['end-top'], this._overlayConnectedPositions['end-bottom']);
                    }
                });
                if (!connectedPositions.length) {
                    connectedPositions = [
                        this._overlayConnectedPositions['bottom-start'],
                        this._overlayConnectedPositions['bottom-end'],
                        this._overlayConnectedPositions['top-start'],
                        this._overlayConnectedPositions['top-end']
                    ];
                }
            }
            this._overlayWithPortal = this._overlayService.openOverlayWithPortal(new ComponentPortal(AdaptDropdownWindow2Component, null, this._injector), {
                origin: this.positionTo || ((_a = this._anchor) === null || _a === void 0 ? void 0 : _a.anchorEl) || this._el.nativeElement,
                transformOriginSelector: '.adapt-dd-menu',
                scrollStrategy: (this._isMobile || this._isTablet) ? 'block' : 'reposition',
                positionStrategy: (this._isMobile || this._isTablet) ? (this._mobileView.isPicker ? 'center' : null) : 'connected',
                connectedPositions: connectedPositions
            }, {
                hasBackdrop: this._isMobile || this._isTablet
            });
            // Process detach action invoked from Position/Scroll strategies
            this._overlayWithPortal.overlayRef.detachments()
                .pipe(takeUntil(this._overlayWithPortal.destroy$))
                .subscribe(() => {
                this._closeOverlay(null, true);
            });
            // Process keydown
            this._overlayWithPortal.overlayRef.keydownEvents()
                .pipe(takeUntil(this._overlayWithPortal.destroy$))
                .subscribe(event => {
                if (getEventKeyCode(event) === ESCAPE && (this.autoClose || this.closeOnEscape)) {
                    this._closeOverlay(AdaptDropdownCloseReason.Esc);
                }
            });
            // Process inside click
            fromEvent(this._overlayWithPortal.overlayRef.overlayElement, 'click')
                .pipe(takeUntil(this._overlayWithPortal.destroy$))
                .subscribe(() => {
                if (this.autoClose === true || this.autoClose === 'inside') {
                    this.close(AdaptDropdownCloseReason.ClickInside);
                }
            });
            // Process outside click
            this._overlayWithPortal.overlayRef.outsidePointerEvents()
                .pipe(takeUntil(this._overlayWithPortal.destroy$))
                .subscribe((event) => {
                if (!this._isEventFromToggle(event) && (this.autoClose === true || this.autoClose === 'outside')) {
                    this._closeOverlay(AdaptDropdownCloseReason.ClickOutside);
                }
            });
            this._overlayWithPortal.componentRef.instance.animationMode = this._animationMode;
            this._overlayWithPortal.componentRef.instance.autoFocusFirst = this.autoFocusFirst;
            this._overlayWithPortal.componentRef.instance.content = this._menu;
            this._overlayWithPortal.componentRef.instance.customClass = this.customClass;
            this._overlayWithPortal.componentRef.instance.eventInvokedFrom = eventInvokedFrom;
            this._overlayWithPortal.componentRef.instance.focusNextElementAfterClose = this.focusNextElementAfterClose;
            this._overlayWithPortal.componentRef.instance.holdFocusInMenu = this.holdFocusInMenu;
            this._overlayWithPortal.componentRef.instance.holdFocusOnOpen = this.holdFocusOnOpen;
            this._overlayWithPortal.componentRef.instance.isMobile = this._isMobile;
            this._overlayWithPortal.componentRef.instance.isTablet = this._isTablet;
            this._overlayWithPortal.componentRef.instance.mobileView = this._mobileView;
            this._overlayWithPortal.componentRef.instance.restoreFocusAfterClose = this.restoreFocusAfterClose;
            this._overlayWithPortal.componentRef.instance.templateRef =
                this._menuTemplateComponent ? this._menuTemplateComponent.templateRef : (this._menuTemplate ? this._menuTemplate.menuTemplateRef : null);
            this._overlayWithPortal.componentRef.instance.popupAnimationDone
                .pipe(takeUntil(this._overlayWithPortal.destroy$))
                .subscribe(animationEvent => {
                this.popupAnimationDone.emit(Object.assign(Object.assign({}, animationEvent), { eventInvokedFrom: eventInvokedFrom }));
            });
            this._open = true;
            this._markAsActive();
            this.onOpen.emit();
            // Overlay is being created asynchronously so need to run change detection on open manually
            this._overlayWithPortal.componentRef.changeDetectorRef.detectChanges();
        }
    }
    _closeOverlay(reason, force) {
        if (this._overlayWithPortal) {
            if (force) {
                this.popupAnimationDone.next(null);
                this._overlayWithPortal.destroy();
                this._overlayWithPortal = null;
                this._closing = false;
                this._closeIfActive();
            }
            else {
                this._closing = true;
                this._overlayWithPortal.overlayRef.detachBackdrop();
                this._overlayWithPortal.componentRef.instance.close()
                    .pipe(takeUntil(this._overlayWithPortal.destroy$))
                    .subscribe(() => {
                    this._overlayWithPortal.destroy();
                    this._overlayWithPortal = null;
                    this._closing = false;
                    this._closeIfActive();
                });
            }
            // Avoid emitting close event double time when close animation already run
            if (this._open) {
                this._open = false;
                this.onClose.emit(reason);
            }
        }
        if (this._removeTapEventListener) {
            this._removeTapEventListener();
        }
    }
    _closeFromClick(e) {
        if (this.autoClose && e.button !== 2 && !this._isEventFromToggle(e)) {
            if (this.autoClose === true) {
                this.close(this.isEventFromMenu(e) ? AdaptDropdownCloseReason.ClickInside : AdaptDropdownCloseReason.ClickOutside);
            }
            else if (this.autoClose === 'inside' && this.isEventFromMenu(e)) {
                this.close(AdaptDropdownCloseReason.ClickInside);
            }
            else if (this.autoClose === 'outside' && !this.isEventFromMenu(e)) {
                this.close(AdaptDropdownCloseReason.ClickOutside);
            }
        }
    }
    _isEventFromToggle(e) {
        return this._anchor.isEventFrom(e);
    }
    _markAsActive() {
        AdaptDropdownDirective.ActivePicker = this;
    }
    _closeIfActive() {
        if (AdaptDropdownDirective.ActivePicker && (AdaptDropdownDirective.ActivePicker === this)) {
            AdaptDropdownDirective.ActivePicker.close(null);
            AdaptDropdownDirective.ActivePicker = null;
        }
    }
    _closeActive() {
        if (AdaptDropdownDirective.ActivePicker && this.autoClose) {
            AdaptDropdownDirective.ActivePicker.close(null);
            AdaptDropdownDirective.ActivePicker = null;
        }
    }
}
AdaptDropdownDirective.LAST_ID = 0;
AdaptDropdownDirective.ActivePicker = null; // https://github.com/angular/angular/issues/18867
AdaptDropdownDirective.ɵfac = function AdaptDropdownDirective_Factory(t) { return new (t || AdaptDropdownDirective)(i0.ɵɵdirectiveInject(i4.AdaptDropdownConfig), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i5.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i6.Directionality), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i7.ScrollManageService), i0.ɵɵdirectiveInject(i8.LayerService), i0.ɵɵdirectiveInject(i9.EventManager), i0.ɵɵdirectiveInject(i10.ResizeService), i0.ɵɵdirectiveInject(i11.AdaptOverlayService), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i12.AdaptTranslateService), i0.ɵɵdirectiveInject(AdaptDropdownDirective, 12), i0.ɵɵdirectiveInject(i13.AdaptRadarAngularService)); };
AdaptDropdownDirective.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptDropdownDirective, selectors: [["adapt-dropdown"], ["", "adaptDropdown", ""]], contentQueries: function AdaptDropdownDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        i0.ɵɵcontentQuery(dirIndex, AdaptDropdownMenuDirective, 5);
        i0.ɵɵcontentQuery(dirIndex, AdaptDropdownMenuTemplateDirective, 7);
        i0.ɵɵcontentQuery(dirIndex, AdaptDropdownMenuTemplateComponent, 7);
        i0.ɵɵcontentQuery(dirIndex, AdaptDropdownAnchorDirective, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._menu = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._menuTemplate = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._menuTemplateComponent = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._anchor = _t.first);
    } }, viewQuery: function AdaptDropdownDirective_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c2, 7, ViewContainerRef);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentPlacement = _t.first);
    } }, hostVars: 2, hostBindings: function AdaptDropdownDirective_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("dropdown", ctx.defaultClass);
    } }, inputs: { autoClose: "autoClose", customClass: "customClass", closeOnEscape: "closeOnEscape", placement: "placement", animationPlacement: "animationPlacement", holdFocusInMenu: "holdFocusInMenu", holdFocusOnOpen: "holdFocusOnOpen", autoFocusFirst: "autoFocusFirst", restoreFocusAfterClose: "restoreFocusAfterClose", focusNextElementAfterClose: "focusNextElementAfterClose", appendToBody: "appendToBody", appendTo: "appendTo", positionTo: "positionTo", anchorPositionTrackingIntervalMs: "anchorPositionTrackingIntervalMs", enableAnchorPositionTracking: "enableAnchorPositionTracking", recalculatePositionOnElementResize: "recalculatePositionOnElementResize", setMobileState: "setMobileState", mobileView: "mobileView" }, outputs: { onOpen: "onOpen", onClose: "onClose", anchorPositionChange: "anchorPositionChange", popupAnimationDone: "popupAnimationDone" }, exportAs: ["adaptDropdown"], features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c4, decls: 8, vars: 0, consts: [["contentPlacement", ""]], template: function AdaptDropdownDirective_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c3);
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵprojection(1);
        i0.ɵɵtext(2, "\n    ");
        i0.ɵɵprojection(3, 1);
        i0.ɵɵtext(4, "\n\n    ");
        i0.ɵɵtemplate(5, AdaptDropdownDirective_ng_template_5_Template, 0, 0, "ng-template", null, 0, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n  ");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptDropdownDirective, [{
        type: Component,
        args: [{
                selector: 'adapt-dropdown, [adaptDropdown]',
                exportAs: 'adaptDropdown',
                template: `
    <ng-content select="[adaptDropdownAnchor]"></ng-content>
    <ng-content select="[adaptDropdownToggle]"></ng-content>

    <ng-template #contentPlacement></ng-template>
  `
            }]
    }], function () { return [{ type: i4.AdaptDropdownConfig }, { type: i0.ComponentFactoryResolver }, { type: i5.AdaptDeviceDetectionService }, { type: i6.Directionality }, { type: i0.ElementRef }, { type: i0.Injector }, { type: i0.Renderer2 }, { type: i7.ScrollManageService }, { type: i8.LayerService }, { type: i9.EventManager }, { type: i10.ResizeService }, { type: i11.AdaptOverlayService }, { type: i0.ApplicationRef }, { type: i12.AdaptTranslateService }, { type: AdaptDropdownDirective, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }, { type: i13.AdaptRadarAngularService }]; }, { autoClose: [{
            type: Input
        }], customClass: [{
            type: Input
        }], closeOnEscape: [{
            type: Input
        }], placement: [{
            type: Input
        }], animationPlacement: [{
            type: Input
        }], holdFocusInMenu: [{
            type: Input
        }], holdFocusOnOpen: [{
            type: Input
        }], autoFocusFirst: [{
            type: Input
        }], restoreFocusAfterClose: [{
            type: Input
        }], focusNextElementAfterClose: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], appendTo: [{
            type: Input
        }], positionTo: [{
            type: Input
        }], anchorPositionTrackingIntervalMs: [{
            type: Input
        }], enableAnchorPositionTracking: [{
            type: Input
        }], recalculatePositionOnElementResize: [{
            type: Input
        }], setMobileState: [{
            type: Input
        }], onOpen: [{
            type: Output
        }], onClose: [{
            type: Output
        }], anchorPositionChange: [{
            type: Output
        }], popupAnimationDone: [{
            type: Output
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.dropdown']
        }], contentPlacement: [{
            type: ViewChild,
            args: ['contentPlacement', { read: ViewContainerRef, static: true }]
        }], _menu: [{
            type: ContentChild,
            args: [AdaptDropdownMenuDirective]
        }], _menuTemplate: [{
            type: ContentChild,
            args: [AdaptDropdownMenuTemplateDirective, { static: true }]
        }], _menuTemplateComponent: [{
            type: ContentChild,
            args: [AdaptDropdownMenuTemplateComponent, { static: true }]
        }], _anchor: [{
            type: ContentChild,
            args: [AdaptDropdownAnchorDirective, { static: true }]
        }], mobileView: [{
            type: Input
        }] }); })();
//# sourceMappingURL=dropdown.component.js.map