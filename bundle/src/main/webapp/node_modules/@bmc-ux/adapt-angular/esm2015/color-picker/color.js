import { Component, ElementRef, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { fromEvent, merge } from 'rxjs';
import { distinctUntilChanged, flatMap, map, startWith, take, takeUntil, tap } from 'rxjs/operators';
import { rgb } from 'd3-color';
import { ColorPalette, ColorUtils, getRGBColorFromString } from '../common/color.utils';
import { ColorType } from '../common/common.enums';
import * as i0 from "@angular/core";
const _c0 = ["colorMapCanvas"];
const _c1 = ["colorStripCanvas"];
const _c2 = ["colorStripArea"];
const DEFAULT_PICKER_COLOR = getRGBColorFromString('#ffffff');
export class ColorComponent {
    constructor() {
        this.mapDragging = false;
        this.stripDragging = false;
        this.colorMapState = {
            x: 0,
            y: 0,
            color: 'rgb(0, 0, 0)'
        };
        this.colorStripState = {
            y: 0,
            color: 'rgb(255, 0, 0)'
        };
        this.colorType = ColorType.HEX;
        this.width = 173;
        this.height = 159;
        this.colorStripWidth = 6;
        this.colorChange = new EventEmitter();
        this._mapColor = ColorPalette.RED;
        this._stripColor = ColorPalette.RED;
    }
    set color(color) {
        // Prevent color setting when touch in process
        if (this.mapDragging || this.stripDragging) {
            return;
        }
        this._setColor(color || DEFAULT_PICKER_COLOR);
    }
    ngAfterViewInit() {
        this._initColorMap();
        this._initColorStrip();
    }
    _initColorMap() {
        this._colorMapContext = this.colorMapCanvas.nativeElement.getContext('2d');
        this._fillColorMap();
        const start$ = merge(fromEvent(this.colorMapCanvas.nativeElement, 'mousedown', { passive: false }), fromEvent(this.colorMapCanvas.nativeElement, 'touchstart', { passive: false }));
        const move$ = merge(fromEvent(window, 'mousemove', { passive: false }), fromEvent(window, 'touchmove', { passive: false }));
        const end$ = merge(fromEvent(window, 'mouseup', { passive: false }), fromEvent(window, 'touchend', { passive: false }));
        let colorMapRect;
        const drag$ = start$.pipe(tap(() => {
            colorMapRect = this.colorMapCanvas.nativeElement.getBoundingClientRect();
            this.mapDragging = true;
        }), flatMap((start) => move$.pipe(startWith(start), 
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        map((move) => {
            if (move.cancelable) {
                move.preventDefault();
            }
            const eventObj = move.changedTouches ? move.changedTouches[0] : move;
            let x = eventObj.clientX - colorMapRect.left;
            x = x < 0 ? 0 : x > colorMapRect.width ? colorMapRect.width : x;
            let y = eventObj.clientY - colorMapRect.top;
            y = y < 0 ? 0 : y > colorMapRect.height ? colorMapRect.height : y;
            return { x: Math.round(x), y: Math.round(y) };
        }), takeUntil(end$.pipe(take(1), tap(() => {
            this.mapDragging = false;
        }))))), distinctUntilChanged((a, b) => (a.x === b.x) && (a.y === b.y)));
        drag$.subscribe(this._selectColor.bind(this));
    }
    _initColorStrip() {
        this._colorStripContext = this.colorStripCanvas.nativeElement.getContext('2d');
        const palette = this._colorStripContext.createLinearGradient(0, 0, 0, this.height);
        palette.addColorStop(0 / 6, ColorUtils.getColorStr(ColorPalette.RED, ColorType.RGB));
        palette.addColorStop(1 / 6, ColorUtils.getColorStr(ColorPalette.MAGENTA, ColorType.RGB));
        palette.addColorStop(2 / 6, ColorUtils.getColorStr(ColorPalette.BLUE, ColorType.RGB));
        palette.addColorStop(3 / 6, ColorUtils.getColorStr(ColorPalette.CYAN, ColorType.RGB));
        palette.addColorStop(4 / 6, ColorUtils.getColorStr(ColorPalette.GREEN, ColorType.RGB));
        palette.addColorStop(5 / 6, ColorUtils.getColorStr(ColorPalette.YELLOW, ColorType.RGB));
        palette.addColorStop(6 / 6, ColorUtils.getColorStr(ColorPalette.RED, ColorType.RGB));
        this._colorStripContext.fillStyle = palette;
        this._colorStripContext.fillRect(0, 0, this.colorStripWidth, this.height);
        this._colorStripContext.fillStyle = 'rgb(255, 0, 0)';
        // Set up the edge values
        for (let x = 0; x < this.colorStripWidth; x++) {
            this._colorStripContext.fillRect(x, 0, 1, 1);
        }
        for (let y = 0; y < this.colorStripWidth; y++) {
            this._colorStripContext.fillRect(y, this.height - 1, 1, 1);
        }
        const start$ = merge(fromEvent(this.colorStripArea.nativeElement, 'mousedown', { passive: false }), fromEvent(this.colorStripArea.nativeElement, 'touchstart', { passive: false }));
        const move$ = merge(fromEvent(window, 'mousemove', { passive: false }), fromEvent(window, 'touchmove', { passive: false }));
        const end$ = merge(fromEvent(window, 'mouseup', { passive: false }), fromEvent(window, 'touchend', { passive: false }));
        let colorStripRect;
        const drag$ = start$.pipe(tap(() => {
            colorStripRect = this.colorStripCanvas.nativeElement.getBoundingClientRect();
            this.stripDragging = true;
        }), flatMap((start) => move$.pipe(startWith(start), 
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        map((move) => {
            if (move.cancelable) {
                move.preventDefault();
            }
            const eventObj = move.changedTouches ? move.changedTouches[0] : move;
            let x = eventObj.clientX - colorStripRect.left;
            x = x < 0 ? 0 : x > colorStripRect.width ? colorStripRect.width : x;
            let y = eventObj.clientY - colorStripRect.top;
            y = y < 0 ? 0 : y > colorStripRect.height ? colorStripRect.height : y;
            return { x: Math.round(x), y: Math.round(y) };
        }), takeUntil(end$.pipe(take(1), tap(() => {
            this.stripDragging = false;
        }))))), distinctUntilChanged((a, b) => (a.x === b.x) && (a.y === b.y)));
        drag$.subscribe(this._selectStripColor.bind(this));
    }
    _fillColorMap() {
        if (!this._colorMapContext) {
            return;
        }
        this._colorMapContext.rect(0, 0, this.width, this.height);
        this._colorMapContext.fillStyle = ColorUtils.getColorStr(this._stripColor, ColorType.HEX);
        this._colorMapContext.fillRect(0, 0, this.width, this.height);
        const grdWhite = this._colorMapContext.createLinearGradient(0, 0, this.width, 0);
        const grdBlack = this._colorMapContext.createLinearGradient(0, 0, 0, this.height);
        grdWhite.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grdWhite.addColorStop(1, 'rgba(255, 255, 255, 0)');
        this._colorMapContext.fillStyle = grdWhite;
        this._colorMapContext.fillRect(0, 0, this.width, this.height);
        grdBlack.addColorStop(0, 'rgba(0, 0, 0, 0)');
        grdBlack.addColorStop(1, 'rgba(0, 0, 0, 1)');
        this._colorMapContext.fillStyle = grdBlack;
        this._colorMapContext.fillRect(0, 0, this.width, this.height);
        this._colorMapContext.fillStyle = 'rgb(0, 0, 0)';
        this._colorMapContext.fillRect(0, this.height - 1, this.width, 1);
        this._colorMapContext.fillStyle = 'rgb(255, 255, 255)';
        this._colorMapContext.fillRect(0, 0, 1, 1);
        this._colorMapContext.fillStyle = ColorUtils.getColorStr(this._stripColor, ColorType.HEX);
        this._colorMapContext.fillRect(this.width - 1, 0, 1, 1);
    }
    _selectColor(point) {
        this.colorMapState.x = point.x;
        this.colorMapState.y = point.y;
        this._mapColor = ColorUtils
            .hsvToRGB({
            h: 1 - 1 / this.height * this.colorStripState.y,
            s: point.x / this.width,
            v: 1 - point.y / this.height
        });
        this.colorChange.emit(rgb(this._mapColor.r, this._mapColor.g, this._mapColor.b));
    }
    _selectStripColor(e) {
        this._stripColor = ColorUtils
            .hsvToRGB({
            h: 1 - 1 / this.height * e.y,
            s: 1,
            v: 1
        });
        this.colorStripState.y = e.y;
        this.colorStripState.color = ColorUtils.getColorStr(this._stripColor, ColorType.HEX);
        this._fillColorMap();
        this._selectColor({ x: this.colorMapState.x, y: this.colorMapState.y });
    }
    _setColor(color) {
        const { h, s, v } = ColorUtils.rgbToHSV(color);
        this.colorStripState.y = (1 - h) * this.height;
        this.colorMapState.x = this.width * s;
        this.colorMapState.y = this.height * (1 - v);
        this._mapColor = color;
        this._stripColor = ColorUtils.hsvToRGB({ h: h, s: 1, v: 1 });
        this._fillColorMap();
    }
}
ColorComponent.ɵfac = function ColorComponent_Factory(t) { return new (t || ColorComponent)(); };
ColorComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: ColorComponent, selectors: [["adapt-color"]], viewQuery: function ColorComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.colorMapCanvas = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.colorStripCanvas = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.colorStripArea = _t.first);
    } }, hostVars: 2, hostBindings: function ColorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassProp("adapt-cp-area", true);
    } }, inputs: { colorType: "colorType", width: "width", height: "height", colorStripWidth: "colorStripWidth", color: "color" }, outputs: { colorChange: "colorChange" }, decls: 18, vars: 16, consts: [[1, "adapt-cp-pick-area"], [1, "adapt-cp-pick-canvas"], ["colorMapCanvas", ""], [1, "adapt-cp-spot"], [1, "adapt-cp-bar-area"], ["colorStripArea", ""], [1, "adapt-cp-bar-canvas"], ["colorStripCanvas", ""], [1, "adapt-cp-bar-spot"]], template: function ColorComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵelement(3, "canvas", 1, 2);
        i0.ɵɵtext(5, "\n      ");
        i0.ɵɵelement(6, "div", 3);
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n    ");
        i0.ɵɵelementStart(9, "div", 4, 5);
        i0.ɵɵtext(11, "\n      ");
        i0.ɵɵelement(12, "canvas", 6, 7);
        i0.ɵɵtext(14, "\n      ");
        i0.ɵɵelement(15, "div", 8);
        i0.ɵɵtext(16, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n  ");
    } if (rf & 2) {
        i0.ɵɵadvance(3);
        i0.ɵɵattribute("width", ctx.width)("height", ctx.height);
        i0.ɵɵadvance(3);
        i0.ɵɵstyleProp("left", ctx.colorMapState.x, "px")("top", ctx.colorMapState.y, "px");
        i0.ɵɵclassProp("dragging", ctx.mapDragging);
        i0.ɵɵadvance(6);
        i0.ɵɵattribute("width", ctx.colorStripWidth)("height", ctx.height);
        i0.ɵɵadvance(3);
        i0.ɵɵstyleProp("top", ctx.colorStripState.y, "px")("background-color", ctx.colorStripState.color);
        i0.ɵɵclassProp("dragging", ctx.stripDragging);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ColorComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-color',
                template: `
    <div class="adapt-cp-pick-area">
      <canvas #colorMapCanvas class="adapt-cp-pick-canvas"
              [attr.width]="width"
              [attr.height]="height"></canvas>
      <div class="adapt-cp-spot"
           [class.dragging]="mapDragging"
           [style.left.px]="colorMapState.x"
           [style.top.px]="colorMapState.y"></div>
    </div>
    <div class="adapt-cp-bar-area" #colorStripArea>
      <canvas #colorStripCanvas class="adapt-cp-bar-canvas"
              [attr.width]="colorStripWidth"
              [attr.height]="height"></canvas>
      <div class="adapt-cp-bar-spot"
           [class.dragging]="stripDragging"
           [style.top.px]="colorStripState.y"
           [style.backgroundColor]="colorStripState.color"></div>
    </div>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[class.adapt-cp-area]': 'true'
                }
            }]
    }], null, { colorType: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], colorStripWidth: [{
            type: Input
        }], color: [{
            type: Input
        }], colorChange: [{
            type: Output
        }], colorMapCanvas: [{
            type: ViewChild,
            args: ['colorMapCanvas', { static: true }]
        }], colorStripCanvas: [{
            type: ViewChild,
            args: ['colorStripCanvas', { static: true }]
        }], colorStripArea: [{
            type: ViewChild,
            args: ['colorStripArea', { static: true }]
        }] }); })();
//# sourceMappingURL=color.js.map