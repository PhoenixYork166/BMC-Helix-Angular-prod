import { Component, ElementRef, EventEmitter, Input, NgZone, Output, QueryList, Renderer2, ViewChild, ViewChildren, ViewEncapsulation } from '@angular/core';
import { ResizeService } from '../common/resize/resize.service';
import { AdaptDeviceDetectionService } from '../common/device-detection.service';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { isDefined, isUndefined } from '../common/utilities';
import { BehaviorSubject, fromEvent, merge, Subject } from 'rxjs';
import { filter, flatMap, map, switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "../common/device-detection.service";
import * as i2 from "../common/resize/resize.service";
import * as i3 from "../common/radar/adapt-radar";
import * as i4 from "@angular/common";
import * as i5 from "../tooltip/tooltip.directive";
const _c0 = ["container"];
const _c1 = ["swipePanel"];
const _c2 = ["body"];
const _c3 = ["tailFirst"];
const _c4 = ["tailLast"];
const _c5 = ["selectedSpot"];
const _c6 = ["spot"];
const _c7 = ["stepItem"];
const _c8 = function (a0) { return { "background-image": a0 }; };
function AdaptStepsComponent_button_6_div_3_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 16);
} if (rf & 2) {
    const step_r5 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(1, _c8, "url(" + step_r5.src + ")"));
} }
function AdaptStepsComponent_button_6_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 14);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵtemplate(2, AdaptStepsComponent_button_6_div_3_div_2_Template, 1, 3, "div", 15);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r5 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵproperty("ngClass", step_r5.icon);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", step_r5.src);
} }
function AdaptStepsComponent_button_6_div_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 17);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r5 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(step_r5.label);
} }
function AdaptStepsComponent_button_6_div_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 18);
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r5 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(step_r5.shortLabel);
} }
const _c9 = function (a0, a1, a2, a3, a4, a5, a6, a7) { return { "adapt-step-collapsed": a0, "adapt-step-last": a1, "adapt-step-active": a2, "adapt-step-disabled": a3, "adapt-step-selected": a4, "adapt-step-prev": a5, "adapt-step-current": a6, "adapt-step-next": a7 }; };
function AdaptStepsComponent_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r18 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 8, 9);
    i0.ɵɵlistener("@hoverAnimation.start", function AdaptStepsComponent_button_6_Template_button_animation_hoverAnimation_start_0_listener() { i0.ɵɵrestoreView(_r18); const ctx_r17 = i0.ɵɵnextContext(); return ctx_r17.updateSelectionSpot(); })("@hoverAnimation.done", function AdaptStepsComponent_button_6_Template_button_animation_hoverAnimation_done_0_listener() { i0.ɵɵrestoreView(_r18); const ctx_r19 = i0.ɵɵnextContext(); return ctx_r19.updateSelectionSpot(); })("mouseenter", function AdaptStepsComponent_button_6_Template_button_mouseenter_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r18); const id_r6 = restoredCtx.index; const ctx_r20 = i0.ɵɵnextContext(); return ctx_r20.stepMouseAction(id_r6); })("mouseleave", function AdaptStepsComponent_button_6_Template_button_mouseleave_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r18); const id_r6 = restoredCtx.index; const ctx_r21 = i0.ɵɵnextContext(); return ctx_r21.stepMouseAction(id_r6); })("click", function AdaptStepsComponent_button_6_Template_button_click_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r18); const id_r6 = restoredCtx.index; const step_r5 = restoredCtx.$implicit; const ctx_r22 = i0.ɵɵnextContext(); return ctx_r22.clickStep(id_r6, step_r5, $event); });
    i0.ɵɵtext(2, "\n      ");
    i0.ɵɵtemplate(3, AdaptStepsComponent_button_6_div_3_Template, 4, 2, "div", 10);
    i0.ɵɵtext(4, "\n      ");
    i0.ɵɵelementStart(5, "div", 11);
    i0.ɵɵtext(6, "\n        ");
    i0.ɵɵtemplate(7, AdaptStepsComponent_button_6_div_7_Template, 2, 1, "div", 12);
    i0.ɵɵtext(8, "\n        ");
    i0.ɵɵtemplate(9, AdaptStepsComponent_button_6_div_9_Template, 2, 1, "div", 13);
    i0.ɵɵtext(10, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r5 = ctx.$implicit;
    const id_r6 = ctx.index;
    const last_r7 = ctx.last;
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵstyleProp("z-index", ctx_r2.steps.length - id_r6);
    i0.ɵɵpropertyInterpolate("adaptTooltip", ctx_r2.isCollapsedStep(id_r6) && !step_r5.disabled ? step_r5.shortLabel : "");
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("width", 200)("@hoverAnimation", step_r5.hover)("ngClass", i0.ɵɵpureFunction8(14, _c9, ctx_r2.isCollapsedStep(id_r6), last_r7, ctx_r2.isActive(id_r6), step_r5.disabled, ctx_r2.applySelectedCls(id_r6), ctx_r2.isMobile && ctx_r2.stepsSwipeState.step === id_r6 + 1, ctx_r2.isMobile && ctx_r2.stepsSwipeState.step === id_r6, ctx_r2.isMobile && ctx_r2.stepsSwipeState.step === id_r6 - 1));
    i0.ɵɵattribute("aria-checked", ctx_r2.isActive(id_r6))("aria-label", step_r5.label || step_r5.shortLabel)("aria-disabled", step_r5.disabled)("tabindex", step_r5.disabled ? -1 : null);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", step_r5.icon || step_r5.src);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", step_r5.label);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", step_r5.shortLabel);
} }
function AdaptStepsComponent_div_13_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "div", 21);
} if (rf & 2) {
    const id_r25 = ctx.index;
    const ctx_r23 = i0.ɵɵnextContext(2);
    i0.ɵɵstyleProp("transition", ctx_r23.stepsSwipeState.dragging ? "none" : "flex-grow .2s")("flex-grow", ctx_r23.getMobileSwipeIndicatorWidth(id_r25));
    i0.ɵɵclassProp("active", ctx_r23.isActive(id_r25));
} }
function AdaptStepsComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 19);
    i0.ɵɵtext(1, "\n  ");
    i0.ɵɵtemplate(2, AdaptStepsComponent_div_13_div_2_Template, 1, 6, "div", 20);
    i0.ɵɵtext(3, "\n");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r4.steps);
} }
export class AdaptStepsComponent extends AdaptRadarAngularGenericDirective {
    constructor(renderer, element, devDetection, resizeService, _ngZone, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptSteps);
        this.renderer = renderer;
        this.element = element;
        this.devDetection = devDetection;
        this.resizeService = resizeService;
        this._ngZone = _ngZone;
        this.expandedSteps = [];
        this.isMobile = false;
        this.stepsSwipeState = {
            dragging: false,
            draggingShift: 0,
            step: 0,
            translate: 0
        };
        /**
         * Sets the index of the selected step. Also you could set it -1 just not to select any step initially
         * @docs-default -1
         */
        this.activeIndex = -1;
        /**
         * Whether the items are clickable or not
         * @docs-default true
         */
        this.readonly = true;
        /**
         * An event fires on active step changed.
         * Returns step index
         */
        this.activeIndexChange = new EventEmitter();
        this.stepsToShow = 4;
        this.widthLimit = {
            MOBILE: 400,
            TABLET: 768
        };
        this._expandedStartId = 0;
        this._selectionSpotHidden = false;
        this.el = this.element.nativeElement;
        this.isMobile = devDetection.deviceMobile();
    }
    ngOnDestroy() {
        this.resizeService.removeResizeEventListener(this.container.nativeElement);
    }
    ngOnInit() {
        this.steps = this.steps || this.model;
        this._initActiveIndex = this.activeIndex;
        this.steps = this.steps.map((step) => {
            step.hover = false;
            return step;
        });
        this.getStepCount();
        this.updateExpandedSteps(true);
        if (this.isMobile) {
            this._initMobileView();
        }
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.resizeService.addResizeEventListener(this.container.nativeElement, this.resizeListener.bind(this));
    }
    isActive(id) {
        return id === this.activeIndex;
    }
    isDisabled(id) {
        return this.expandedSteps[id].disabled || this.readonly;
    }
    isCollapsedStep(id) {
        if (this.isMobile) {
            return;
        }
        return this.expandedSteps.indexOf(this.steps[id]) === -1;
    }
    clickStep(id, step, event) {
        const isNextExpanded = !this.isCollapsedStep(id);
        if (isUndefined(step)) {
            step = this.steps[id];
        }
        if (this.readonly || step.disabled) {
            if (!event) {
                return;
            }
            event.preventDefault();
            return;
        }
        this.activeIndex = id;
        this.activeIndexChange.emit(this.activeIndex);
        if (this.activeIndex > this.expandedEndId) {
            this.expandedStartId = this.activeIndex - this.stepsToShow + 1;
            this.expandedEndId = this.activeIndex;
        }
        else if (this.activeIndex < this.expandedStartId) {
            this.expandedStartId = this.activeIndex;
            this.expandedEndId = this.activeIndex + this.stepsToShow - 1;
        }
        this.updateExpandedSteps();
        // This is a dirty hack for beautiful animation
        if (!isNextExpanded) {
            this.hideSelectionSpot();
        }
        else {
            this.showSelectionSpot();
        }
        this._ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                this.updateSelectionSpot();
            }, 300);
        });
    }
    stepMouseAction(id) {
        const step = this.steps[id];
        if (!step.disabled) {
            step.hover = !step.hover;
        }
    }
    updateSelectionSpot() {
        if (this.isMobile) {
            return;
        }
        if (this.activeIndex < 0) {
            return;
        }
        const steps = this.stepItems.toArray();
        const activeStep = steps[this.activeIndex];
        const { offsetWidth, offsetLeft } = activeStep.nativeElement;
        this.selectedSpotEl.nativeElement.style.left = `${offsetLeft}px`;
        this.selectedSpotEl.nativeElement.style.width = `${offsetWidth}px`;
    }
    applySelectedCls(id) {
        return this._selectionSpotHidden && this.activeIndex === id;
    }
    selectStepById(id) {
        this.clickStep(id);
        if (this.isMobile) {
            this.stepsSwipe.update(id);
        }
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    getMobileSwipeIndicatorWidth(id) {
        if (this.stepsSwipeState.dragging) {
            // run on drag
            if (this.stepsSwipeState.draggingShift <= 0) {
                // swipe to next step
                if (id === this.stepsSwipeState.step + 1) {
                    // increase next step width
                    return `${-this.stepsSwipeState.draggingShift || 1}`;
                }
                else if (id === this.stepsSwipeState.step) {
                    // decrease current step width
                    return `${(this.swipeWrapperWidth + this.stepsSwipeState.draggingShift) || 1}`;
                }
                else {
                    // default width for rest steps
                    return 1;
                }
            }
            else {
                // swipe to previous step
                if (id === this.stepsSwipeState.step - 1) {
                    // increase previous step width
                    return `${this.stepsSwipeState.draggingShift || 1}`;
                }
                else if (id === this.stepsSwipeState.step) {
                    // decrease current step width
                    return `${(this.swipeWrapperWidth - this.stepsSwipeState.draggingShift) || 1}`;
                }
                else {
                    // default width for rest steps
                    return 1;
                }
            }
        }
        else {
            // run out of drag
            if (id === this.stepsSwipeState.step) {
                // maximum width for current step
                return this.swipeWrapperWidth;
            }
            else {
                // default width for rest steps
                return 1;
            }
        }
    }
    hideSelectionSpot() {
        if (this.isMobile) {
            return;
        }
        this.renderer.setStyle(this.selectedSpotEl.nativeElement, 'display', 'none');
        this._selectionSpotHidden = true;
    }
    showSelectionSpot() {
        if (this.isMobile) {
            return;
        }
        this.renderer.setStyle(this.selectedSpotEl.nativeElement, 'display', 'block');
        this._selectionSpotHidden = false;
    }
    resizeListener() {
        if (this.isMobile) {
            this.swipeWrapperWidth = parseInt(getComputedStyle(this.container.nativeElement).width, 10);
            this.stepsSwipe.update();
        }
        this.getStepCount();
        this.updateExpandedSteps(true);
        // This is a dirty hack for beautiful animation
        this._ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                this.updateSelectionSpot();
            }, 250);
        });
    }
    updateExpandedSteps(needUpdate = false) {
        const steps = this.steps.slice();
        this.expandedSteps = [];
        if (steps.length <= this.stepsToShow) {
            this.expandedSteps = steps.slice();
        }
        else {
            const delta = (this.activeIndex + this.stepsToShow) - steps.length;
            if (isUndefined(this.expandedStartId) || needUpdate) {
                this.expandedStartId = delta > 0 ? this.activeIndex - delta : (this.activeIndex < 0 ? 0 : this.activeIndex);
            }
            if (isUndefined(this.expandedEndId) || needUpdate) {
                this.expandedEndId = this.expandedStartId + this.stepsToShow - 1;
            }
            steps.forEach((step, id) => {
                if (id >= this.expandedStartId && id <= this.expandedEndId) {
                    this.expandedSteps.push(step);
                }
            });
        }
    }
    getStepCount() {
        const containerEl = this.container.nativeElement;
        let { width } = containerEl.getBoundingClientRect();
        // Gets the integer value of the width
        width = Math.floor(width);
        if (width <= this.widthLimit.MOBILE) {
            // Sets the steps count for mobile devices
            this.stepsToShow = 2;
        }
        else if (width > this.widthLimit.MOBILE && width < this.widthLimit.TABLET) {
            // Sets the steps count for tablets
            this.stepsToShow = 3;
        }
        else {
            // Sets the steps count for PCs
            this.stepsToShow = 4;
        }
    }
    _initMobileView() {
        this.swipeWrapperWidth = parseInt(getComputedStyle(this.container.nativeElement).width, 10);
        this.stepsSwipe = new SwipeSteps(this.container.nativeElement, this.steps.length);
        this.stepsSwipe.stateChange.subscribe(nextState => {
            this.stepsSwipeState = nextState;
            this.swipePanel.nativeElement.style.transition = nextState.dragging ? 'none' : 'transform .2s';
            this.swipePanel.nativeElement.style.transform = `translateX(${nextState.translate}px)`;
        });
    }
}
AdaptStepsComponent.ɵfac = function AdaptStepsComponent_Factory(t) { return new (t || AdaptStepsComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.AdaptDeviceDetectionService), i0.ɵɵdirectiveInject(i2.ResizeService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptStepsComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptStepsComponent, selectors: [["adapt-steps"]], viewQuery: function AdaptStepsComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
        i0.ɵɵviewQuery(_c2, 5);
        i0.ɵɵviewQuery(_c3, 5);
        i0.ɵɵviewQuery(_c4, 5);
        i0.ɵɵviewQuery(_c5, 7);
        i0.ɵɵviewQuery(_c6, 5);
        i0.ɵɵviewQuery(_c7, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.swipePanel = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.bodyEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tailFirstEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tailLastEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.selectedSpotEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.spotEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.stepItems = _t);
    } }, hostVars: 2, hostBindings: function AdaptStepsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵstyleProp("display", "block");
    } }, inputs: { steps: "steps", activeIndex: "activeIndex", model: "model", readonly: "readonly", style: "style", styleClass: "styleClass" }, outputs: { activeIndexChange: "activeIndexChange" }, features: [i0.ɵɵInheritDefinitionFeature], decls: 15, vars: 4, consts: [[1, "adapt-steps"], ["container", ""], ["role", "menu", 1, "adapt-steps-panel"], ["swipePanel", ""], ["role", "menuitemradio", "class", "adapt-step", "placement", "top", "type", "button", 3, "adaptTooltip", "adaptRadarDisableEventSending", "width", "zIndex", "ngClass", "mouseenter", "mouseleave", "click", 4, "ngFor", "ngForOf"], [1, "adapt-selection-spot"], ["selectedSpot", ""], ["class", "adapt-steps-mobile__indicators-block", 4, "ngIf"], ["role", "menuitemradio", "placement", "top", "type", "button", 1, "adapt-step", 3, "adaptTooltip", "adaptRadarDisableEventSending", "width", "ngClass", "mouseenter", "mouseleave", "click"], ["stepItem", ""], ["class", "adapt-step-image", 3, "ngClass", 4, "ngIf"], [1, "adapt-step-label"], ["class", "adapt-step-label-text adapt-step-label-text-long", 4, "ngIf"], ["class", "adapt-step-label-text adapt-step-label-text-short", 4, "ngIf"], [1, "adapt-step-image", 3, "ngClass"], ["class", "adapt-step-image-tag", 3, "ngStyle", 4, "ngIf"], [1, "adapt-step-image-tag", 3, "ngStyle"], [1, "adapt-step-label-text", "adapt-step-label-text-long"], [1, "adapt-step-label-text", "adapt-step-label-text-short"], [1, "adapt-steps-mobile__indicators-block"], ["class", "adapt-steps-mobile__indicator", 3, "active", "transition", "flexGrow", 4, "ngFor", "ngForOf"], [1, "adapt-steps-mobile__indicator"]], template: function AdaptStepsComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0, 1);
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵelementStart(3, "div", 2, 3);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵtemplate(6, AdaptStepsComponent_button_6_Template, 12, 23, "button", 4);
        i0.ɵɵtext(7, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n  ");
        i0.ɵɵelement(9, "div", 5, 6);
        i0.ɵɵtext(11, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(12, "\n\n");
        i0.ɵɵtemplate(13, AdaptStepsComponent_div_13_Template, 4, 1, "div", 7);
        i0.ɵɵtext(14, "\n\n");
    } if (rf & 2) {
        i0.ɵɵclassProp("adapt-steps-mobile", ctx.isMobile);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngForOf", ctx.steps);
        i0.ɵɵadvance(7);
        i0.ɵɵproperty("ngIf", ctx.isMobile);
    } }, directives: [i4.NgForOf, i4.NgIf, i5.AdaptTooltipDirective, i4.NgClass, i4.NgStyle], encapsulation: 2, data: { animation: [
            trigger('hoverAnimation', [
                state('0', style({
                    'width': '15px'
                })),
                state('1', style({
                    'width': '20px'
                })),
                transition('0 => 1', animate('250ms ease-in')),
                transition('1 => 0', animate('250ms ease-in'))
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptStepsComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-steps',
                templateUrl: './steps.component.html',
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[style.display]': '"block"'
                },
                animations: [
                    trigger('hoverAnimation', [
                        state('0', style({
                            'width': '15px'
                        })),
                        state('1', style({
                            'width': '20px'
                        })),
                        transition('0 => 1', animate('250ms ease-in')),
                        transition('1 => 0', animate('250ms ease-in'))
                    ])
                ],
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i1.AdaptDeviceDetectionService }, { type: i2.ResizeService }, { type: i0.NgZone }, { type: i3.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { steps: [{
            type: Input
        }], activeIndex: [{
            type: Input
        }], model: [{
            type: Input
        }], readonly: [{
            type: Input
        }], style: [{
            type: Input
        }], styleClass: [{
            type: Input
        }], activeIndexChange: [{
            type: Output
        }], container: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }], swipePanel: [{
            type: ViewChild,
            args: ['swipePanel', { static: true }]
        }], bodyEl: [{
            type: ViewChild,
            args: ['body']
        }], tailFirstEl: [{
            type: ViewChild,
            args: ['tailFirst']
        }], tailLastEl: [{
            type: ViewChild,
            args: ['tailLast']
        }], selectedSpotEl: [{
            type: ViewChild,
            args: ['selectedSpot', { static: true }]
        }], spotEl: [{
            type: ViewChild,
            args: ['spot']
        }], stepItems: [{
            type: ViewChildren,
            args: ['stepItem']
        }] }); })();
export class SwipeSteps {
    constructor(swipeContainer, stepCount, activeStep, tolerance) {
        this._stepCount = 1;
        this._tolerance = 100;
        this.stateChange = new Subject();
        this._stepWidth = 100;
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this._translate$ = new BehaviorSubject(0);
        this._swipeState = {
            dragging: false,
            draggingShift: 0,
            step: 0,
            translate: 0
        };
        this._swipeContainer = swipeContainer;
        this._stepCount = stepCount;
        this._activeStep = activeStep || 0;
        if (tolerance) {
            this._tolerance = tolerance;
        }
        this._init();
    }
    update(activeStep) {
        this._stepWidth = parseInt(getComputedStyle(this._swipeContainer).width, 10);
        if (isDefined(activeStep)) {
            this._activeStep = activeStep;
        }
        this.gotoStep(this._activeStep);
    }
    gotoStep(stepNumber) {
        if (stepNumber < 0) {
            this._activeStep = 0;
        }
        else if (stepNumber > this._stepCount - 1) {
            this._activeStep = this._stepCount - 1;
        }
        else {
            this._activeStep = stepNumber;
        }
        this._swipeState.step = this._activeStep;
        this._translate$.next(-this._stepWidth * this._activeStep);
    }
    prevStep() {
        this.gotoStep(this._activeStep - 1);
    }
    nextStep() {
        this.gotoStep(this._activeStep + 1);
    }
    _init() {
        this._stepWidth = parseInt(getComputedStyle(this._swipeContainer).width, 10);
        this._translate$.subscribe((v => {
            this._swipeState.translate = v;
            this.stateChange.next(this._swipeState);
        }).bind(this));
        const touchStart$ = fromEvent(this._swipeContainer, 'touchstart', { passive: false });
        const touchMove$ = fromEvent(window, 'touchmove', { passive: false });
        const touchEnd$ = merge(fromEvent(window, 'touchend', { passive: false }));
        let dragShift = 0;
        const drag$ = touchStart$
            .pipe(tap(() => {
            this._swipeState.dragging = true;
        }), flatMap((start) => touchMove$
            .pipe(map((move) => {
            if (move.cancelable) {
                move.preventDefault();
            }
            return move.changedTouches[0].pageX - start.changedTouches[0].pageX;
        }), filter(v => Math.abs(v) < this._stepWidth), takeUntil(touchEnd$))));
        const dragEnd$ = drag$.pipe(switchMap(() => touchEnd$.pipe(take(1), tap(() => {
            this._swipeState.dragging = false;
            this._swipeState.draggingShift = 0;
        }))));
        drag$.subscribe((shift => {
            dragShift = shift;
            this._swipeState.draggingShift = dragShift;
            this._translate$.next(shift - this._stepWidth * this._activeStep);
        }).bind(this));
        dragEnd$.subscribe((() => {
            if (dragShift > 100) {
                this.prevStep();
            }
            else if (dragShift < -100) {
                this.nextStep();
            }
            else {
                this.gotoStep(this._activeStep);
            }
        }).bind(this));
    }
}
//# sourceMappingURL=steps.component.js.map