/* eslint-disable @typescript-eslint/no-explicit-any */
import { Directive, ElementRef, EventEmitter, forwardRef, HostBinding, Injector, Input, Output } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';
import { formatString, hasRequiredValidator, toBoolean } from './utilities';
import { AdaptTranslateService } from './i18n/index';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from './radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "./i18n/index";
import * as i2 from "./radar/adapt-radar";
export function createFormControlValueAccessor(type) {
    return {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => type),
        multi: true
    };
}
export function createFormControlValidator(type) {
    return {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => type),
        multi: true
    };
}
// eslint-disable-next-line @angular-eslint/directive-class-suffix
export class FormComponent extends AdaptRadarAngularGenericDirective {
    constructor(injector, ts, _adaptRadarService, _elem, _entityName) {
        super(_adaptRadarService, _elem, _entityName);
        this.injector = injector;
        this.ts = ts;
        this.mainCls = '';
        this.popoverPlacement = 'top';
        this.popoverTriggers = 'click';
        this.defaultFormErrors = {};
        this._customErrorTexts = {};
        this.buildInValidators = {
            min: (value) => {
                const error = {
                    name: this.defaultFormErrors.minValueName,
                    text: formatString(this.defaultFormErrors.minValue, value.min)
                };
                return error;
            },
            max: (value) => {
                const error = {
                    name: this.defaultFormErrors.maxValueName,
                    text: formatString(this.defaultFormErrors.maxValue, value.max)
                };
                return error;
            },
            required: () => {
                const error = {
                    name: this.defaultFormErrors.requiredName,
                    text: this.defaultFormErrors.required
                };
                return error;
            },
            requiredTrue: () => {
                const error = {
                    name: this.defaultFormErrors.requiredTrueName,
                    text: this.defaultFormErrors.requiredTrue
                };
                return error;
            },
            email: () => {
                const error = {
                    name: this.defaultFormErrors.emailName,
                    text: this.defaultFormErrors.email
                };
                return error;
            },
            minlength: (value) => {
                const error = {
                    name: this.defaultFormErrors.minLengthName,
                    text: formatString(this.defaultFormErrors.minLength, value.requiredLength, value.actualLength)
                };
                return error;
            },
            maxlength: (value) => {
                const error = {
                    name: this.defaultFormErrors.maxLengthName,
                    text: formatString(this.defaultFormErrors.maxLength, value.requiredLength, value.actualLength)
                };
                return error;
            },
            pattern: (value) => {
                const error = {
                    name: this.defaultFormErrors.patternName,
                    text: formatString(this.defaultFormErrors.pattern, value.requiredPattern)
                };
                return error;
            }
        };
        this._readonly = false;
        this._disabled = false;
        this._errors = [];
        // TODO check if useless arg can be removed
        /* eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */
        this.propagateChange = (_) => {
        };
        this.setDefaultErrors(ts.getCurrentLanguage());
    }
    get hostClasses() {
        return this.getBaseHostClasses();
    }
    set errorTexts(errors) {
        this._customErrorTexts = errors;
    }
    get readonly() {
        return this._readonly;
    }
    set readonly(v) {
        this._readonly = toBoolean(v);
    }
    get required() {
        return this._required || hasRequiredValidator(this.control);
    }
    set required(v) {
        this._required = toBoolean(v);
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(v) {
        this._disabled = toBoolean(v);
    }
    get requiredLabel() {
        return this._requiredLabel;
    }
    set requiredLabel(v) {
        this._requiredLabel = v;
    }
    get errors() {
        const validators = Object.keys(this.control && this.control.errors ? this.control.errors : {});
        let hasRequiredError = false;
        this._errors = [];
        validators.forEach((v) => {
            const isBuildIn = Object.prototype.hasOwnProperty.call(this.buildInValidators, v);
            const error = this.control.errors[v];
            const customError = this._customErrorTexts[v];
            if (customError && error.text) {
                error.text = customError.text;
            }
            if (!(v === 'required' && this.control.untouched)) {
                if (customError) {
                    this._errors.push(customError);
                }
                else if (isBuildIn) {
                    this._errors.push(this.buildInValidators[v](error));
                }
                else {
                    this._errors.push(error);
                }
            }
        });
        hasRequiredError = !!this._errors.filter((e) => e.name === 'Required').length;
        if (hasRequiredError && this.control.untouched) {
            let deleteIndex = -1;
            this._errors.forEach((elem, index) => {
                deleteIndex = elem.name === 'Required' ? index : -1;
            });
            if (deleteIndex !== -1) {
                this._errors.splice(deleteIndex, 1);
            }
        }
        return this._errors;
    }
    ngOnInit() {
        this.initControl();
    }
    setDefaultErrors(translation) {
        this.defaultFormErrors.minValue = translation['adapt.formControl.error.minValue'];
        this.defaultFormErrors.minValueName = translation['adapt.formControl.error.minValueName'];
        this.defaultFormErrors.maxValue = translation['adapt.formControl.error.maxValue'];
        this.defaultFormErrors.maxValueName = translation['adapt.formControl.error.maxValueName'];
        this.defaultFormErrors.required = translation['adapt.formControl.error.required'];
        this.defaultFormErrors.requiredName = translation['adapt.formControl.error.requiredName'];
        this.defaultFormErrors.requiredTrue = translation['adapt.formControl.error.requiredTrue'];
        this.defaultFormErrors.requiredTrueName = translation['adapt.formControl.error.requiredTrueName'];
        this.defaultFormErrors.email = translation['adapt.formControl.error.email'];
        this.defaultFormErrors.emailName = translation['adapt.formControl.error.emailName'];
        this.defaultFormErrors.minLength = translation['adapt.formControl.error.minLength'];
        this.defaultFormErrors.minLengthName = translation['adapt.formControl.error.minLengthName'];
        this.defaultFormErrors.maxLength = translation['adapt.formControl.error.maxLength'];
        this.defaultFormErrors.maxLengthName = translation['adapt.formControl.error.maxLengthName'];
        this.defaultFormErrors.pattern = translation['adapt.formControl.error.pattern'];
        this.defaultFormErrors.patternName = translation['adapt.formControl.error.patternName'];
        this.requiredLabel = translation['adapt.common.required'];
    }
    initControl() {
        this.control = this.injector.get(NgControl);
    }
    // TODO: in a new FormComponent need to implement this method
    // abstract setDisabledState?(isDisabled: boolean): void;
    overrideBuildInValidatorMessage(name, cb) {
        if (this.buildInValidators[name]) {
            this.buildInValidators[name] = cb;
        }
    }
    getBaseHostClasses() {
        const classes = [
            this.mainCls,
            this.suppressIcons ? 'prevent-success-icon' : '',
        ];
        // Workaround: set manually form validation classes due to removing with dynamic mainCls
        // TODO: maybe extend the NgControlStatus class for applying these classes
        const control = this.control;
        if (control) {
            classes.push(control.valid ? 'ng-valid' : 'ng-invalid', control.pending ? 'ng-pending' : '', control.touched ? 'ng-touched' : 'ng-untouched', control.dirty ? 'ng-dirty' : 'ng-pristine');
        }
        return classes.join(' ');
    }
}
FormComponent.ɵfac = function FormComponent_Factory(t) { return new (t || FormComponent)(i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.AdaptRadarAngularCustomEventName)); };
FormComponent.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: FormComponent, hostVars: 2, hostBindings: function FormComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostClasses);
    } }, inputs: { mainCls: "mainCls", suppressIcons: "suppressIcons", prefix: "prefix", suffix: "suffix", label: "label", hideLabel: "hideLabel", placeholder: "placeholder", name: "name", id: "id", tooltipIconCls: "tooltipIconCls", tooltipText: "tooltipText", popoverIcon: "popoverIcon", popoverPlacement: "popoverPlacement", popoverTriggers: "popoverTriggers", popoverContent: "popoverContent", width: "width", errorTexts: "errorTexts", readonly: "readonly", required: "required", disabled: "disabled", requiredLabel: "requiredLabel" }, outputs: { focus: "focus", blur: "blur" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(FormComponent, [{
        type: Directive
    }], function () { return [{ type: i0.Injector }, { type: i1.AdaptTranslateService }, { type: i2.AdaptRadarAngularService }, { type: i0.ElementRef }, { type: i2.AdaptRadarAngularCustomEventName }]; }, { mainCls: [{
            type: Input
        }], suppressIcons: [{
            type: Input
        }], prefix: [{
            type: Input
        }], suffix: [{
            type: Input
        }], label: [{
            type: Input
        }], hideLabel: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], name: [{
            type: Input
        }], id: [{
            type: Input
        }], tooltipIconCls: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], popoverIcon: [{
            type: Input
        }], popoverPlacement: [{
            type: Input
        }], popoverTriggers: [{
            type: Input
        }], popoverContent: [{
            type: Input
        }], width: [{
            type: Input
        }], focus: [{
            type: Output
        }], blur: [{
            type: Output
        }], hostClasses: [{
            type: HostBinding,
            args: ['class']
        }], errorTexts: [{
            type: Input
        }], readonly: [{
            type: Input
        }], required: [{
            type: Input
        }], disabled: [{
            type: Input
        }], requiredLabel: [{
            type: Input
        }] }); })();
//# sourceMappingURL=form.component.js.map