import { isEmpty as isEmptylodash, isNil } from 'lodash-es';
// TODO: Refactor this if possible.
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function toBoolean(value) {
    return value != null && `${value}` !== 'false';
}
// TODO: Refactor this if possible.
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function toNumber(value) {
    if (typeof value === 'undefined') {
        return null;
    }
    else if (typeof value === 'string') {
        return parseInt(value, 10);
    }
    return value;
}
// TODO: Refactor this if possible.
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function toArray(value) {
    return Array.prototype.slice.call(value);
}
// TODO: Refactor this if possible. Potentially can be change to lodash-es
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function isUndefined(v) {
    return v === void 0;
}
// TODO: Refactor this if possible. Potentially can be change to lodash-es
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function isArray(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
}
// TODO: Refactor this if possible. Potentially can be change to lodash-es
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function isFunction(fn) {
    return Object.prototype.toString.call(fn) === '[object Function]';
}
// TODO: Refactor this if possible. Potentially can be change to lodash-es
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function isString(s) {
    return typeof s === 'string';
}
// TODO: Refactor this if possible. Potentially can be change to lodash-es
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function isNumber(n) {
    return typeof n === 'number';
}
export function isSafeNumber(value) {
    /** check if passed argument is decimal,
     * not strict equality to correct quotient assignment
     * when dot is the first character in the string (e.g '.99')
     */
    const isDecimal = (value === null || value === void 0 ? void 0 : value.indexOf('.')) >= 0;
    const quotient = isDecimal ? value.split(/[.]/)[0] : value;
    if (Number.isSafeInteger(Number(quotient))) {
        if (!isDecimal) {
            return true;
        }
        return !(Number(quotient) === Number.MAX_SAFE_INTEGER || Number(quotient) === Number.MIN_SAFE_INTEGER);
    }
    return false;
}
// TODO: Refactor this if possible.
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function toString(value) {
    return (value !== undefined && value !== null) ? `${value}` : '';
}
// TODO: Refactor this if possible.
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function isDefined(value) {
    return value !== undefined && value !== null;
}
// TODO: Refactor this if possible.
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function regExpEscape(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
export function isImgTypeValid(type) {
    return type === 'image/jpeg'
        || type === 'image/jpg'
        || type === 'image/png'
        || type === 'image/gif'
        || type === 'image/tiff'
        || type === 'image/svg'
        || type === 'image/svg+xml';
}
// TODO: Refactor this if possible.
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function formatString(str, ...params) {
    return str.replace(/{(\d+)}/g, (match, index) => !isUndefined(params[index]) ? params[index] : match);
}
// TODO: Refactor this if possible. Potentially can be change to lodash-es
// TODO: Also seems like this function work incorrectly and has different to lodash-es "isEmpty", so be careful when provide refactoring
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export function isEmpty(value) {
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    return !value || !value.length;
}
export function isEmptyOrWhitespace(value) {
    // match the regex: '', ' ', '\n', '  \n\n ', '\t\n', '\r\n' ...
    return !value || !!value.match(/^\s*$/);
}
export function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}
export function hasShrunkText(element) {
    return element.offsetWidth < element.scrollWidth;
}
export function querySelectorChildrenAndSelf(el, selector) {
    const queryEl = el.querySelector(selector);
    return queryEl ? queryEl : (el.matches(selector) ? el : null);
}
export function elWidthWithMargin(el) {
    const style = getComputedStyle(el);
    return el.offsetWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
}
// TODO: Refactor this if possible. Potentially can be change to lodash-es
/* eslint-disable @typescript-eslint/no-explicit-any */
export function debounce(func, waitInMs) {
    let timeout;
    return function (...args) {
        // TODO check if this can be refactored
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const context = this;
        const later = function () {
            timeout = null;
            func.apply(context, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, waitInMs);
        if (!timeout) {
            func.apply(context, args);
        }
    };
}
/* eslint-enable @typescript-eslint/no-explicit-any */
export function hasKeyboardKeyCode(event, eventKey, eventKeyCodeForFallback, ieEventKey) {
    if (event.key === undefined) {
        return event.keyCode === eventKeyCodeForFallback;
    }
    else {
        return event.key === eventKey || (ieEventKey !== undefined && event.key === ieEventKey);
    }
}
export function getValueOrFunc(valOrFunc, ...params) {
    return typeof valOrFunc === 'function' ? valOrFunc.apply(this, params) : valOrFunc;
}
/* eslint-enable */
export function trueOrNull(val) {
    return val == null ? true : val;
}
export function getElementStyles(element) {
    const computed = window.getComputedStyle(element);
    const properties = [
        'direction',
        'boxSizing',
        'height',
        'overflowX',
        'overflowY',
        'borderTopWidth',
        'borderRightWidth',
        'borderBottomWidth',
        'borderLeftWidth',
        'borderStyle',
        'paddingTop',
        'paddingRight',
        'paddingBottom',
        'paddingLeft',
        // https://developer.mozilla.org/en-US/docs/Web/CSS/font
        'fontStyle',
        'fontVariant',
        'fontWeight',
        'fontStretch',
        'fontSize',
        'fontSizeAdjust',
        'lineHeight',
        'fontFamily',
        'textAlign',
        'textTransform',
        'textIndent',
        'textDecoration',
        'letterSpacing',
        'wordSpacing',
        'tabSize'
    ];
    const styles = {};
    // Transfer the element's properties to the div
    properties.forEach((prop) => {
        styles[prop] = computed[prop];
    });
    return styles;
}
/**
 * Tells whether the event has been triggered from element's subtree or not.
 *
 * @param event - the event to check
 * @param element - element to check
 *
 * @return whether the event has been triggered from element's subtree or not.
 */
export function isEventFrom(event, element) {
    // there might be a case when we have event from element that has been just removed
    // in this case we don't know if it was inside or outside popup
    // for this we are checking event target path for popover element with the same ID as our popover instance
    let eventFromElement = false;
    let path = [];
    if (event.composedPath) {
        path = event.composedPath();
    }
    else { // composedPath is not supported by IE and Edge 12-18, for fallback use:
        let target = event.target;
        while (target.parentNode !== null) {
            path.push(target);
            target = target.parentNode;
        }
    }
    for (const pathElement of path) {
        if (pathElement === element) {
            eventFromElement = true;
            break;
        }
    }
    return eventFromElement;
}
/**
 * Utility function to find maximum depth in the array of objects structure
 *
 * @param data {KeyValueObject[] | KeyValueObject} - Structure to iterate through
 * @param property {string} (optional) - Specify by what property need to iterate
 *
 * @returns {number} - Max depth number
 */
export function maxDepth(data, property) {
    if (isNil(data) || isEmptylodash(data)) {
        return 0;
    }
    if (Array.isArray(data)) {
        return 1 + Math.max(...data.map(d => maxDepth(d, property)));
    }
    if (typeof (data) === 'object' && isDefined(data)) {
        // If 'property' argument wasn't passed find max depth for all properties
        if (!property) {
            return Math.max(...Object.values(data).map(d => maxDepth(d, property)));
        }
        if (Object.keys(data).includes(property)) {
            const filteredChild = Object.entries(data).find(d => d[0] === property);
            return Math.max(...Object.values(filteredChild).map(d => maxDepth(d, property)));
        }
        return 0;
    }
    return 0;
}
/**
 * Check if the control has standard required validator
 * @param control: FormControl | NgControl
 */
export function hasRequiredValidator(control) {
    let _hasRequiredValidator = false;
    let _controlValidator;
    if (control) {
        if (control.control && isFunction(control.control.validator)) {
            // FormControl
            _controlValidator = control.control.validator;
        }
        else if (isFunction(control.validator)) {
            // [(ngModel)]
            _controlValidator = control.validator;
        }
    }
    if (_controlValidator) {
        // Test validator on empty FormControl
        const emptyControlErrors = _controlValidator({});
        _hasRequiredValidator = emptyControlErrors &&
            (Object.prototype.hasOwnProperty.call(emptyControlErrors, 'required')
                || Object.prototype.hasOwnProperty.call(emptyControlErrors, 'requiredtrue'));
    }
    return _hasRequiredValidator;
}
//# sourceMappingURL=utilities.js.map