import { isNil } from 'lodash-es';
import { color, hsl } from 'd3-color';
import { ColorType } from './common.enums';
/**
 * @deprecated since 11.14.0
 * Use ColorType from '../common/common.enums';
 */
export const ColorTypes = {
    HEX: 'HEX',
    RGB: 'RGB'
};
export var SourceTypes;
(function (SourceTypes) {
    SourceTypes[SourceTypes["Theme"] = 0] = "Theme";
    SourceTypes[SourceTypes["Recent"] = 1] = "Recent";
    SourceTypes[SourceTypes["Input"] = 2] = "Input";
    SourceTypes[SourceTypes["Picker"] = 3] = "Picker";
    SourceTypes[SourceTypes["Empty"] = 4] = "Empty"; // @since 11.12.0
})(SourceTypes || (SourceTypes = {}));
export const ColorPatterns = {
    HEX: /^#?([a-fA-F\d]{2})([a-fA-F\d]{2})([a-fA-F\d]{2})$/,
    RGB: /^(rgb\()?(1?[0-9]{1,2}|2[0-4][0-9]|25[0-5]),(1?[0-9]{1,2}|2[0-4][0-9]|25[0-5]),(1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])(\))?$/
};
export const ColorPalette = {
    WHITE: { r: 255, g: 255, b: 255 },
    BLACK: { r: 0, g: 0, b: 0 },
    RED: { r: 255, g: 0, b: 0 },
    YELLOW: { r: 255, g: 255, b: 0 },
    GREEN: { r: 0, g: 255, b: 0 },
    CYAN: { r: 0, g: 255, b: 255 },
    BLUE: { r: 0, g: 0, b: 255 },
    MAGENTA: { r: 255, g: 0, b: 255 }
};
export const lightnessEdge = 50;
export const isDarkMode = getComputedStyle(document.documentElement).getPropertyValue('--dark-mode').trim() === 'true';
export class ColorUtils {
    static parseColor(color, pattern, type) {
        const regExp = new RegExp(pattern);
        const match = regExp.exec(color);
        let radix;
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        let result;
        if (match) {
            if (type === ColorType.HEX) {
                result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
                result = result ? result.slice(1) : result;
                radix = 16;
            }
            else if (type === ColorType.RGB) {
                result = color.match(/\d+/gi);
                radix = 10;
            }
            return {
                r: parseInt(result[0], radix),
                g: parseInt(result[1], radix),
                b: parseInt(result[2], radix)
            };
        }
        return null;
    }
    static getColorChannelsStr(c, type) {
        let color;
        if (isNil(c)) {
            return null;
        }
        switch (type) {
            case ColorType.HEX: {
                color = `${this.decToHex(c.r)}${this.decToHex(c.g)}${this.decToHex(c.b)}`;
                break;
            }
            case ColorType.RGB: {
                color = `${c.r},${c.g},${c.b}`;
                break;
            }
        }
        return color;
    }
    static getColorStr(c, type) {
        let color;
        if (isNil(c)) {
            return null;
        }
        switch (type) {
            case ColorType.HEX: {
                color = `#${this.decToHex(c.r)}${this.decToHex(c.g)}${this.decToHex(c.b)}`;
                break;
            }
            case ColorType.RGB: {
                color = `RGB(${c.r},${c.g},${c.b})`;
                break;
            }
        }
        return color.toLowerCase();
    }
    static rgbToHSV(color) {
        const r = color.r / 255;
        const g = color.g / 255;
        const b = color.b / 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const d = max - min;
        let h;
        const s = max === 0 ? 0 : (d / max);
        const v = max;
        if (max === min) {
            h = 0; // achromatic
        }
        else {
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return { h, s, v };
    }
    static hsvToRGB(color) {
        let r;
        let g;
        let b;
        const i = Math.floor(color.h * 6);
        const f = color.h * 6 - i;
        const p = color.v * (1 - color.s);
        const q = color.v * (1 - f * color.s);
        const t = color.v * (1 - (1 - f) * color.s);
        switch (i % 6) {
            case 0:
                r = color.v;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = color.v;
                b = p;
                break;
            case 2:
                r = p;
                g = color.v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = color.v;
                break;
            case 4:
                r = t;
                g = p;
                b = color.v;
                break;
            case 5:
                r = color.v;
                g = p;
                b = q;
                break;
        }
        return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
        };
    }
    static decToHex(n) {
        return ('0' + n.toString(16)).slice(-2);
    }
    // to make a color darker, we should multiply each component (r, g, b values) by desire coefficient -
    // the smaller the factor, the darker the shade (it's like adding black to the value).
    static getDarken(color, percent = 0.14) {
        const colorRGB = ColorUtils.parseColor(color, ColorPatterns.HEX, ColorType.HEX);
        Object.keys(colorRGB).forEach((colorComponentName) => {
            colorRGB[colorComponentName] = Math.floor((1 - percent) * colorRGB[colorComponentName]);
        });
        return ColorUtils.getColorStr(colorRGB, ColorType.HEX);
    }
    static getBorderColor(color, percent = 0.33) {
        if (!color || !ColorPatterns.HEX.test(color)) {
            return null;
        }
        const hslColor = hsl(color);
        if (isDarkMode) {
            if (hslColor.l * 100 < 67) {
                return hslColor.copy({ l: hslColor.l + 0.25 }).toString();
            }
            return hslColor.copy({ l: hslColor.l + 0.1 }).toString();
        }
        return hslColor.darker(percent).toString();
    }
    // Materials used: https://css-tricks.com/using-javascript-to-adjust-saturation-and-brightness-of-rgb-colors/
    static getBackgroundLightness(backgroundColor) {
        let color;
        let lightness = 0;
        if (ColorPatterns.HEX.test(backgroundColor)) {
            color = ColorUtils.parseColor(backgroundColor, ColorPatterns.HEX, ColorType.HEX);
        }
        if (ColorPatterns.RGB.test(backgroundColor)) {
            color = ColorUtils.parseColor(backgroundColor, ColorPatterns.RGB, ColorType.RGB);
        }
        if (color) {
            const rgbIntArray = [color.r, color.g, color.b];
            const highest = Math.max(...rgbIntArray);
            const lowest = Math.min(...rgbIntArray);
            lightness = (highest + lowest) / 2 / 255;
        }
        if (!isNil(lightness)) {
            return lightness * 100;
        }
        return lightness;
    }
    static checkContrast(foreground, background) {
        const contractRatio = {
            ratio: '0',
            AA: 'fail',
            AALarge: 'fail',
            AAA: 'fail',
            AAALarge: 'fail'
        };
        let bg = background;
        if (background.includes('rgb')) {
            bg = this.rgbToHex(background.slice(4, -1));
        }
        const luminanceForeground = this.getLuminance(foreground);
        const luminanceBackground = this.getLuminance(bg);
        //the contrast between the 2 colors is calculated by using the contrast ratio formula and to find the origin of these numbers, please follow https://www.w3.org/WAI/GL/wiki/Contrast_ratio
        const ratio = (Math.max(luminanceForeground, luminanceBackground) + 0.05) / (Math.min(luminanceForeground, luminanceBackground) + 0.05);
        contractRatio.ratio = (Math.round(ratio * 100) / 100).toString();
        // contrast ratio is measured based on the below 3 number 4.5, 3 and 7 and it is derived from https://usecontrast.com/guide
        if (ratio >= 4.5) {
            contractRatio.AA = 'pass';
            contractRatio.AAALarge = 'pass';
        }
        else {
            contractRatio.AA = 'fail';
            contractRatio.AAALarge = 'fail';
        }
        if (ratio >= 3) {
            contractRatio.AALarge = 'pass';
        }
        else {
            contractRatio.AALarge = 'fail';
        }
        if (ratio >= 7) {
            contractRatio.AAA = 'pass';
        }
        else {
            contractRatio.AAA = 'fail';
        }
        return contractRatio;
    }
    static getHexNum(colorSubstring) {
        let colorHexaNum;
        try {
            colorHexaNum = parseInt(colorSubstring, 16);
        }
        catch (err) {
            colorHexaNum = 0;
        }
        return colorHexaNum;
    }
    // sRGB is the standard naming convention from https://wunnle.com/dynamic-text-color-based-on-background and https://webaim.org/resources/contrastchecker/?fcolor=DB8A92&bcolor=ffffff
    //Please follow the link to learn more about the sRGB naming https://en.wikipedia.org/wiki/SRGB
    // the numbers here are the part of the formula to calculate luminance. Please find the attached reference here https://en.wikipedia.org/wiki/Relative_luminance and https://en.wikipedia.org/wiki/SRGB
    static getsRGB(color) {
        return this.getHexNum(color) / 255 <= 0.03928 // formula is taken from https://en.wikipedia.org/wiki/SRGB
            ? this.getHexNum(color) / 255 / 12.92 // formula is taken from https://en.wikipedia.org/wiki/SRGB
            : Math.pow((this.getHexNum(color) / 255 + 0.055) / 1.055, 2.4); // formula is taken from https://en.wikipedia.org/wiki/SRGB
    }
    // the numbers here are the part of the formula to calculate luminance. Please find the attached reference here https://en.wikipedia.org/wiki/Relative_luminance
    static getLuminance(color) {
        if (color) {
            return (0.2126 * this.getsRGB(color.substr(1, 2)) + 0.7152 * this.getsRGB(color.substr(3, 2)) + 0.0722 * this.getsRGB(color.substr(-2)));
        }
    }
    static componentToHex(c) {
        const hex = c.toString(16);
        return hex.length == 1 ? '0' + hex : hex;
    }
    static rgbToHex(rgb) {
        const r = Number(rgb.split(',')[0]);
        const g = Number(rgb.split(',')[1]);
        const b = Number(rgb.split(',')[2]);
        return '#' + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);
    }
}
export function getColorType(value) {
    value = value === null || value === void 0 ? void 0 : value.toLowerCase();
    if (value) {
        if (/^#([a-fA-F0-9]){3}$|#([a-fA-F0-9]){6}$/.test(value)) {
            return ColorType.HEX;
        }
        if (/^(rgb\()(1?[0-9]{1,2}|2[0-4][0-9]|25[0-5]),\s?(1?[0-9]{1,2}|2[0-4][0-9]|25[0-5]),\s?(1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])(\))$/.test(value)) {
            return ColorType.RGB;
        }
    }
    return null;
}
export function getRGBColorFromString(value) {
    let rgbColor = null;
    switch (getColorType(value)) {
        case ColorType.RGB: {
            rgbColor = Object.assign(color(value).rgb(), { parsedString: value, colorType: ColorType.RGB });
            break;
        }
        case ColorType.HEX: {
            rgbColor = Object.assign(color(value).rgb(), { parsedString: value, colorType: ColorType.HEX });
            break;
        }
    }
    return rgbColor;
}
export function getStringFromRGBColor(color, type) {
    switch (type) {
        case ColorType.HEX: {
            return color.formatHex();
        }
        case ColorType.RGB: {
            return color.formatRgb().replace(/\s/gm, ''); // .formatRgb() returns string with whitespaces
        }
    }
}
//# sourceMappingURL=color.utils.js.map