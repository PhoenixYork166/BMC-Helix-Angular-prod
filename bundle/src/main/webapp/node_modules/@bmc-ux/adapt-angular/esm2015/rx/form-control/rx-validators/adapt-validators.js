import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS, Validators } from '@angular/forms';
import { BigNumber } from 'bignumber.js';
import { isFunction, isNil } from 'lodash-es';
import { checkIsAfter } from '../../rx-datetime/common/common.utils';
import * as i0 from "@angular/core";
export class AdaptValidators {
    static min(min, errorMessageFn) {
        const res = (control) => {
            if (isNil(control.value) || control.value === '' || isNil(min)) {
                return null;
            }
            let error = null;
            if (!BigNumber.isBigNumber(control.value)) {
                error = Validators.min(min)(control);
            }
            else if (!control.value.isNaN() && control.value.lt(min)) {
                error = {
                    min: {
                        min: min,
                        actual: control.value
                    }
                };
            }
            if (error && isFunction(errorMessageFn)) {
                error.min.message = errorMessageFn({ min: min, actual: control.value });
            }
            return error;
        };
        return res;
    }
    static max(max, errorMessageFn) {
        const res = (control) => {
            if (isNil(control.value) || control.value === '' || isNil(max)) {
                return null;
            }
            let error = null;
            if (!BigNumber.isBigNumber(control.value)) {
                error = Validators.max(max)(control);
            }
            else if (!control.value.isNaN() && control.value.gt(max)) {
                error = {
                    max: {
                        max: max,
                        actual: control.value
                    }
                };
            }
            if (error && isFunction(errorMessageFn)) {
                error.max.message = errorMessageFn({ max: max, actual: control.value });
            }
            return error;
        };
        return res;
    }
    static required(errorMessageFn) {
        const res = (control) => {
            const error = Validators.required(control);
            if (error && isFunction(errorMessageFn)) {
                error.required = { message: errorMessageFn() };
            }
            return error;
        };
        return res;
    }
    static requiredTrue(errorMessageFn) {
        const res = (control) => {
            const error = Validators.requiredTrue(control) ? { requiredtrue: true } : null;
            if (error && isFunction(errorMessageFn)) {
                error.requiredtrue = { message: errorMessageFn() };
            }
            return error;
        };
        return res;
    }
    static email(errorMessageFn) {
        const res = (control) => {
            const error = Validators.email(control);
            if (error && isFunction(errorMessageFn)) {
                error.email = { message: errorMessageFn() };
            }
            return error;
        };
        return res;
    }
    static minLength(minLength, errorMessageFn) {
        const res = (control) => {
            const error = Validators.minLength(minLength)(control);
            if (error && isFunction(errorMessageFn)) {
                error.minlength.message = errorMessageFn(error.minlength);
            }
            return error;
        };
        return res;
    }
    static maxLength(maxLength, errorMessageFn) {
        const res = (control) => {
            const error = Validators.maxLength(maxLength)(control);
            if (error && isFunction(errorMessageFn)) {
                error.maxlength.message = errorMessageFn(error.maxlength);
            }
            return error;
        };
        return res;
    }
    static pattern(pattern, errorMessageFn) {
        const res = (control) => {
            const error = Validators.pattern(pattern)(control);
            if (error && isFunction(errorMessageFn)) {
                error.pattern.message = errorMessageFn(error.pattern);
            }
            return error;
        };
        return res;
    }
    static range(min, max, errorMessageFn) {
        const res = (control) => {
            // don't validate on empty values
            if (isNil(control.value) || control.value === '' || isNil(min) || isNil(max)) {
                return null;
            }
            let error = null;
            if (AdaptValidators.min(min)(control) || AdaptValidators.max(max)(control)) {
                error = {
                    range: {
                        min,
                        max,
                        actual: control.value
                    }
                };
            }
            if (error && isFunction(errorMessageFn)) {
                error.range.message = errorMessageFn(error.range);
            }
            return error;
        };
        return res;
    }
    static rxDatetimeFormat(errorMessageFn) {
        const res = (control) => {
            var _a;
            let error = null;
            if ((_a = control.value) === null || _a === void 0 ? void 0 : _a.parseError) {
                error = {
                    rxDatetimeFormat: control.value.parseError
                };
            }
            if (error && isFunction(errorMessageFn)) {
                error.rxDatetimeFormat.message = errorMessageFn(error.rxDatetimeFormat);
            }
            return error;
        };
        return res;
    }
    static rxDatetimeRangeFormat(errorMessageFn) {
        const res = (control) => {
            let error = null;
            if (control.value) {
                const start = AdaptValidators.rxDatetimeFormat()({ value: control.value[0] });
                const end = AdaptValidators.rxDatetimeFormat()({ value: control.value[1] });
                if (start || end) {
                    error = {
                        rxDatetimeRangeFormat: {
                            start: (start === null || start === void 0 ? void 0 : start.rxDatetimeFormat) || null,
                            end: (end === null || end === void 0 ? void 0 : end.rxDatetimeFormat) || null
                        }
                    };
                }
            }
            if (error && isFunction(errorMessageFn)) {
                error.rxDatetimeRangeFormat.message = errorMessageFn(error.rxDatetimeRangeFormat);
            }
            return error;
        };
        return res;
    }
    static rxDatetimeRangeOrder(errorMessageFn) {
        const res = (control) => {
            let error = null;
            if (control.value &&
                control.value[0] && !control.value[0].parseError &&
                control.value[1] && !control.value[1].parseError) {
                if (checkIsAfter(control.value[0], control.value[1])) {
                    error = {
                        rxDatetimeRangeOrder: {
                            start: control.value[0],
                            end: control.value[1]
                        }
                    };
                }
            }
            if (error && isFunction(errorMessageFn)) {
                error.rxDatetimeRangeOrder.message = errorMessageFn();
            }
            return error;
        };
        return res;
    }
    static integerNumber(errorMessageFn) {
        const res = (control) => {
            if (isNil(control.value) || control.value === '') {
                return null;
            }
            // Allow any positive or negative integer (e.g. 0, 1, -1, +5, -5).
            const regExp = /^(-?|\+?)?(\d+)$/g;
            let error = null;
            if (isNaN(control.value) || !regExp.test(control.value)) {
                error = { integerNumber: true };
                if (isFunction(errorMessageFn)) {
                    error.integerNumber = { message: errorMessageFn() };
                }
            }
            return error;
        };
        return res;
    }
    static scientificNumber(errorMessageFn) {
        const res = (control) => {
            if (isNil(control.value) || control.value === '') {
                return null;
            }
            // Allow any positive or negative number in scientific notation (e.g. 1e2, -1E2 .08e-2, -1.1e-5, +5.5-E3, -5.0e+1).
            const regExp = /^[-+]?\d*\.?\d+([eE][-+]?\d+)?(?!:[-.]?)$/;
            let error = null;
            if (isNaN(control.value) || !regExp.test(control.value)) {
                error = { scientificNumber: true };
                if (isFunction(errorMessageFn)) {
                    error.scientificNumber = { message: errorMessageFn() };
                }
            }
            return error;
        };
        return res;
    }
    static floatNumber(errorMessageFn) {
        const res = (control) => {
            if (isNil(control.value) || control.value === '') {
                return null;
            }
            // Allow any positive or negative number with floating point (e.g. 0.5, .08, -1.1, +5.5, -5.0, 5).
            const regExp = /^[-+]?(\d*)?[.]?\d+$/;
            let error = null;
            if (isNaN(control.value) || !regExp.test(control.value)) {
                error = { floatNumber: true };
                if (isFunction(errorMessageFn)) {
                    error.floatNumber = { message: errorMessageFn() };
                }
            }
            return error;
        };
        return res;
    }
}
export class AdaptMinValidatorDirective {
    validate(control) {
        return AdaptValidators.min(this.adaptMin, this.adaptMinMessageFn)(control);
    }
}
AdaptMinValidatorDirective.ɵfac = function AdaptMinValidatorDirective_Factory(t) { return new (t || AdaptMinValidatorDirective)(); };
AdaptMinValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptMinValidatorDirective, selectors: [["", "adaptMin", "", "ngModel", ""], ["", "adaptMin", "", "formControl", ""]], inputs: { adaptMin: "adaptMin", adaptMinMessageFn: "adaptMinMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptMinValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMinValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptMin][ngModel],[adaptMin][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptMinValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptMin: [{
            type: Input
        }], adaptMinMessageFn: [{
            type: Input
        }] }); })();
export class AdaptMaxValidatorDirective {
    validate(control) {
        return AdaptValidators.max(this.adaptMax, this.adaptMaxMessageFn)(control);
    }
}
AdaptMaxValidatorDirective.ɵfac = function AdaptMaxValidatorDirective_Factory(t) { return new (t || AdaptMaxValidatorDirective)(); };
AdaptMaxValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptMaxValidatorDirective, selectors: [["", "adaptMax", "", "ngModel", ""], ["", "adaptMax", "", "formControl", ""]], inputs: { adaptMax: "adaptMax", adaptMaxMessageFn: "adaptMaxMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptMaxValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMaxValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptMax][ngModel],[adaptMax][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptMaxValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptMax: [{
            type: Input
        }], adaptMaxMessageFn: [{
            type: Input
        }] }); })();
export class AdaptRequiredValidatorDirective {
    validate(control) {
        return AdaptValidators.required(this.adaptRequiredMessageFn)(control);
    }
}
AdaptRequiredValidatorDirective.ɵfac = function AdaptRequiredValidatorDirective_Factory(t) { return new (t || AdaptRequiredValidatorDirective)(); };
AdaptRequiredValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptRequiredValidatorDirective, selectors: [["", "adaptRequired", "", "ngModel", ""], ["", "adaptRequired", "", "formControl", ""]], inputs: { adaptRequiredMessageFn: "adaptRequiredMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRequiredValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRequiredValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptRequired][ngModel],[adaptRequired][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRequiredValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptRequiredMessageFn: [{
            type: Input
        }] }); })();
export class AdaptRequiredTrueValidatorDirective {
    validate(control) {
        return AdaptValidators.requiredTrue(this.adaptRequiredTrueMessageFn)(control);
    }
}
AdaptRequiredTrueValidatorDirective.ɵfac = function AdaptRequiredTrueValidatorDirective_Factory(t) { return new (t || AdaptRequiredTrueValidatorDirective)(); };
AdaptRequiredTrueValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptRequiredTrueValidatorDirective, selectors: [["", "adaptRequiredTrue", "", "ngModel", ""], ["", "adaptRequiredTrue", "", "formControl", ""]], inputs: { adaptRequiredTrueMessageFn: "adaptRequiredTrueMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRequiredTrueValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRequiredTrueValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptRequiredTrue][ngModel],[adaptRequiredTrue][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRequiredTrueValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptRequiredTrueMessageFn: [{
            type: Input
        }] }); })();
export class AdaptEmailValidatorDirective {
    validate(control) {
        return AdaptValidators.email(this.adaptEmailMessageFn)(control);
    }
}
AdaptEmailValidatorDirective.ɵfac = function AdaptEmailValidatorDirective_Factory(t) { return new (t || AdaptEmailValidatorDirective)(); };
AdaptEmailValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptEmailValidatorDirective, selectors: [["", "adaptEmail", "", "ngModel", ""], ["", "adaptEmail", "", "formControl", ""]], inputs: { adaptEmailMessageFn: "adaptEmailMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptEmailValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptEmailValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptEmail][ngModel],[adaptEmail][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptEmailValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptEmailMessageFn: [{
            type: Input
        }] }); })();
export class AdaptMinLengthValidatorDirective {
    validate(control) {
        return AdaptValidators.minLength(this.adaptMinLength, this.adaptMinLengthMessageFn)(control);
    }
}
AdaptMinLengthValidatorDirective.ɵfac = function AdaptMinLengthValidatorDirective_Factory(t) { return new (t || AdaptMinLengthValidatorDirective)(); };
AdaptMinLengthValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptMinLengthValidatorDirective, selectors: [["", "adaptMinLength", "", "ngModel", ""], ["", "adaptMinLength", "", "formControl", ""]], inputs: { adaptMinLength: "adaptMinLength", adaptMinLengthMessageFn: "adaptMinLengthMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptMinLengthValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMinLengthValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptMinLength][ngModel],[adaptMinLength][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptMinLengthValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptMinLength: [{
            type: Input
        }], adaptMinLengthMessageFn: [{
            type: Input
        }] }); })();
export class AdaptMaxLengthValidatorDirective {
    validate(control) {
        return AdaptValidators.maxLength(this.adaptMaxLength, this.adaptMaxLengthMessageFn)(control);
    }
}
AdaptMaxLengthValidatorDirective.ɵfac = function AdaptMaxLengthValidatorDirective_Factory(t) { return new (t || AdaptMaxLengthValidatorDirective)(); };
AdaptMaxLengthValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptMaxLengthValidatorDirective, selectors: [["", "adaptMaxLength", "", "ngModel", ""], ["", "adaptMaxLength", "", "formControl", ""]], inputs: { adaptMaxLength: "adaptMaxLength", adaptMaxLengthMessageFn: "adaptMaxLengthMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptMaxLengthValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptMaxLengthValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptMaxLength][ngModel],[adaptMaxLength][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptMaxLengthValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptMaxLength: [{
            type: Input
        }], adaptMaxLengthMessageFn: [{
            type: Input
        }] }); })();
export class AdaptPatternValidatorDirective {
    validate(control) {
        return AdaptValidators.pattern(this.adaptPattern, this.adaptPatternMessageFn)(control);
    }
}
AdaptPatternValidatorDirective.ɵfac = function AdaptPatternValidatorDirective_Factory(t) { return new (t || AdaptPatternValidatorDirective)(); };
AdaptPatternValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptPatternValidatorDirective, selectors: [["", "adaptPattern", "", "ngModel", ""], ["", "adaptPattern", "", "formControl", ""]], inputs: { adaptPattern: "adaptPattern", adaptPatternMessageFn: "adaptPatternMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptPatternValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptPatternValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptPattern][ngModel],[adaptPattern][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptPatternValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptPattern: [{
            type: Input
        }], adaptPatternMessageFn: [{
            type: Input
        }] }); })();
export class AdaptRangeValidatorDirective {
    validate(control) {
        return AdaptValidators.range(this.adaptRange[0], this.adaptRange[1], this.adaptRangeMessageFn)(control);
    }
}
AdaptRangeValidatorDirective.ɵfac = function AdaptRangeValidatorDirective_Factory(t) { return new (t || AdaptRangeValidatorDirective)(); };
AdaptRangeValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptRangeValidatorDirective, selectors: [["", "adaptRange", "", "ngModel", ""], ["", "adaptRange", "", "formControl", ""]], inputs: { adaptRange: "adaptRange", adaptRangeMessageFn: "adaptRangeMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRangeValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRangeValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptRange][ngModel],[adaptRange][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRangeValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptRange: [{
            type: Input
        }], adaptRangeMessageFn: [{
            type: Input
        }] }); })();
export class AdaptRxDatetimeFormatValidatorDirective {
    validate(control) {
        return AdaptValidators.rxDatetimeFormat(this.adaptRxDatetimeFormatMessageFn)(control);
    }
}
AdaptRxDatetimeFormatValidatorDirective.ɵfac = function AdaptRxDatetimeFormatValidatorDirective_Factory(t) { return new (t || AdaptRxDatetimeFormatValidatorDirective)(); };
AdaptRxDatetimeFormatValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptRxDatetimeFormatValidatorDirective, selectors: [["", "adaptRxDatetimeFormat", "", "ngModel", ""], ["", "adaptRxDatetimeFormat", "", "formControl", ""]], inputs: { adaptRxDatetimeFormatMessageFn: "adaptRxDatetimeFormatMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRxDatetimeFormatValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxDatetimeFormatValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptRxDatetimeFormat][ngModel],[adaptRxDatetimeFormat][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRxDatetimeFormatValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptRxDatetimeFormatMessageFn: [{
            type: Input
        }] }); })();
export class AdaptRxDatetimeRangeFormatValidatorDirective {
    validate(control) {
        return AdaptValidators.rxDatetimeRangeFormat(this.adaptRxDatetimeRangeFormatMessageFn)(control);
    }
}
AdaptRxDatetimeRangeFormatValidatorDirective.ɵfac = function AdaptRxDatetimeRangeFormatValidatorDirective_Factory(t) { return new (t || AdaptRxDatetimeRangeFormatValidatorDirective)(); };
AdaptRxDatetimeRangeFormatValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptRxDatetimeRangeFormatValidatorDirective, selectors: [["", "adaptRxDatetimeRangeFormat", "", "ngModel", ""], ["", "adaptRxDatetimeRangeFormat", "", "formControl", ""]], inputs: { adaptRxDatetimeRangeFormatMessageFn: "adaptRxDatetimeRangeFormatMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRxDatetimeRangeFormatValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxDatetimeRangeFormatValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptRxDatetimeRangeFormat][ngModel],[adaptRxDatetimeRangeFormat][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRxDatetimeRangeFormatValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptRxDatetimeRangeFormatMessageFn: [{
            type: Input
        }] }); })();
export class AdaptRxDatetimeRangeOrderValidatorDirective {
    validate(control) {
        return AdaptValidators.rxDatetimeRangeOrder(this.adaptRxDatetimeRangeOrderMessageFn)(control);
    }
}
AdaptRxDatetimeRangeOrderValidatorDirective.ɵfac = function AdaptRxDatetimeRangeOrderValidatorDirective_Factory(t) { return new (t || AdaptRxDatetimeRangeOrderValidatorDirective)(); };
AdaptRxDatetimeRangeOrderValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptRxDatetimeRangeOrderValidatorDirective, selectors: [["", "adaptRxDatetimeRangeOrder", "", "ngModel", ""], ["", "adaptRxDatetimeRangeOrder", "", "formControl", ""]], inputs: { adaptRxDatetimeRangeOrderMessageFn: "adaptRxDatetimeRangeOrderMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRxDatetimeRangeOrderValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxDatetimeRangeOrderValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptRxDatetimeRangeOrder][ngModel],[adaptRxDatetimeRangeOrder][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptRxDatetimeRangeOrderValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptRxDatetimeRangeOrderMessageFn: [{
            type: Input
        }] }); })();
export class AdaptIntegerNumberValidatorDirective {
    validate(control) {
        return AdaptValidators.integerNumber(this.adaptIntegerNumberMessageFn)(control);
    }
}
AdaptIntegerNumberValidatorDirective.ɵfac = function AdaptIntegerNumberValidatorDirective_Factory(t) { return new (t || AdaptIntegerNumberValidatorDirective)(); };
AdaptIntegerNumberValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptIntegerNumberValidatorDirective, selectors: [["", "adaptIntegerNumber", "", "ngModel", ""], ["", "adaptIntegerNumber", "", "formControl", ""]], inputs: { adaptIntegerNumberMessageFn: "adaptIntegerNumberMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptIntegerNumberValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptIntegerNumberValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptIntegerNumber][ngModel], [adaptIntegerNumber][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptIntegerNumberValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptIntegerNumberMessageFn: [{
            type: Input
        }] }); })();
export class AdaptScientificNumberValidatorDirective {
    validate(control) {
        return AdaptValidators.scientificNumber(this.adaptScientificNumberMessageFn)(control);
    }
}
AdaptScientificNumberValidatorDirective.ɵfac = function AdaptScientificNumberValidatorDirective_Factory(t) { return new (t || AdaptScientificNumberValidatorDirective)(); };
AdaptScientificNumberValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptScientificNumberValidatorDirective, selectors: [["", "adaptScientificNumber", "", "ngModel", ""], ["", "adaptScientificNumber", "", "formControl", ""]], inputs: { adaptScientificNumberMessageFn: "adaptScientificNumberMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptScientificNumberValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptScientificNumberValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptScientificNumber][ngModel], [adaptScientificNumber][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptScientificNumberValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptScientificNumberMessageFn: [{
            type: Input
        }] }); })();
export class AdaptFloatNumberValidatorDirective {
    validate(control) {
        return AdaptValidators.floatNumber(this.adaptFloatNumberMessageFn)(control);
    }
}
AdaptFloatNumberValidatorDirective.ɵfac = function AdaptFloatNumberValidatorDirective_Factory(t) { return new (t || AdaptFloatNumberValidatorDirective)(); };
AdaptFloatNumberValidatorDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptFloatNumberValidatorDirective, selectors: [["", "adaptFloatNumber", "", "ngModel", ""], ["", "adaptFloatNumber", "", "formControl", ""]], inputs: { adaptFloatNumberMessageFn: "adaptFloatNumberMessageFn" }, features: [i0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptFloatNumberValidatorDirective), multi: true }
        ])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptFloatNumberValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[adaptFloatNumber][ngModel], [adaptFloatNumber][formControl]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => AdaptFloatNumberValidatorDirective), multi: true }
                ]
            }]
    }], null, { adaptFloatNumberMessageFn: [{
            type: Input
        }] }); })();
//# sourceMappingURL=adapt-validators.js.map