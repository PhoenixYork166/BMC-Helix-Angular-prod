import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgZone, Optional, Output, QueryList, Self, TemplateRef, ViewChild, ViewChildren, ViewEncapsulation } from '@angular/core';
import { NgControl } from '@angular/forms';
import { animateChild, query, transition, trigger, useAnimation } from '@angular/animations';
import { ENTER, ESCAPE } from '@angular/cdk/keycodes';
import { moveItemInArray } from '@angular/cdk/drag-drop';
import { fromEvent, of, ReplaySubject } from 'rxjs';
import { switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { cloneDeep, filter, findIndex, includes, isArray, isEmpty, isFunction, toLower, toString } from 'lodash-es';
import { v4 as uuid } from 'uuid';
import { ANIMATION_NAME } from '../../common/animation';
import { AdaptTranslateService } from '../../common/i18n/index';
import { getEventKeyCode } from '../../common/key-codes';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularCustomEventType, AdaptRadarAngularService } from '../../common/radar/adapt-radar';
import { maxDepth } from '../../common/utilities';
import { AdaptRxFeedbackComponent, AdaptRxFormControlDirective } from '../form-control/index';
import { AdaptRxListItemComponent } from '../rx-list-item/index';
import { SafeCdr } from '../../common/safe-cdr';
import { adaptWarn } from '../../common/logger';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "../../common/i18n/index";
import * as i3 from "../../common/radar/adapt-radar";
const _c0 = ["itemsList"];
const _c1 = ["filterInput"];
const _c2 = ["adaptRxFeedbackRef"];
function AdaptRxListBuilderComponent_div_9_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r8 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "button", 14);
    i0.ɵɵlistener("click", function AdaptRxListBuilderComponent_div_9_button_7_Template_button_click_0_listener() { i0.ɵɵrestoreView(_r8); const ctx_r7 = i0.ɵɵnextContext(2); return ctx_r7.onListItemAdd(); });
    i0.ɵɵtext(1);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("data-testid", ctx_r6.testID + "_add-item");
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate1("\n        ", ctx_r6.texts.add, "\n      ");
} }
function AdaptRxListBuilderComponent_div_9_Template(rf, ctx) { if (rf & 1) {
    const _r10 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelement(2, "span", 10);
    i0.ɵɵtext(3, "\n      ");
    i0.ɵɵelementStart(4, "input", 11, 12);
    i0.ɵɵlistener("focus", function AdaptRxListBuilderComponent_div_9_Template_input_focus_4_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r9 = i0.ɵɵnextContext(); return ctx_r9.focusHandler($event); })("blur", function AdaptRxListBuilderComponent_div_9_Template_input_blur_4_listener($event) { i0.ɵɵrestoreView(_r10); const ctx_r11 = i0.ɵɵnextContext(); return ctx_r11.blurHandler($event); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n\n      ");
    i0.ɵɵtemplate(7, AdaptRxListBuilderComponent_div_9_button_7_Template, 2, 2, "button", 13);
    i0.ɵɵtext(8, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassProp("focused", ctx_r0.focused);
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("id", ctx_r0.id)("disabled", ctx_r0.disabled)("autofocus", ctx_r0.autofocus);
    i0.ɵɵattribute("name", ctx_r0.name)("placeholder", ctx_r0.texts.searchPlaceholder)("tabindex", ctx_r0.tabIndex)("data-testid", ctx_r0.testID + "_search")("aria-label", ctx_r0.ariaLabel)("aria-labelledby", ctx_r0.ariaLabelledby)("aria-describedby", ctx_r0.ariaDescribedBy)("aria-invalid", ctx_r0.hasDangerState)("aria-errormessage", ctx_r0.ariaErrorMessage);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", !(ctx_r0.disabled || ctx_r0.readonly) && ctx_r0.canAdd && !ctx_r0.addValidationError && !ctx_r0.addingItemDuplicateOrEmpty);
} }
function AdaptRxListBuilderComponent_div_15_adapt_custom_actions_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "adapt-custom-actions", 20);
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("actions", ctx_r13.selectionActions);
} }
function AdaptRxListBuilderComponent_div_15_div_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 21);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵelementStart(2, "span");
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵelement(4, "span", 22);
    i0.ɵɵtext(5, "\n          ");
    i0.ɵɵelementStart(6, "span");
    i0.ɵɵtext(7);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(8, "\n        ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r14 = i0.ɵɵnextContext(2);
    i0.ɵɵattribute("data-testid", ctx_r14.testID + "_list-header");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r14.texts.headerText);
    i0.ɵɵadvance(4);
    i0.ɵɵtextInterpolate2("(", ctx_r14.filteredListItems.length, " ", ctx_r14.texts.numberOptionsText, ")");
} }
function AdaptRxListBuilderComponent_div_15_ng_container_7_ng_template_2_Template(rf, ctx) { }
const _c3 = function (a0) { return { $implicit: a0 }; };
function AdaptRxListBuilderComponent_div_15_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n          ");
    i0.ɵɵtemplate(2, AdaptRxListBuilderComponent_div_15_ng_container_7_ng_template_2_Template, 0, 0, "ng-template", 23);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r18 = ctx.$implicit;
    i0.ɵɵnextContext();
    const _r16 = i0.ɵɵreference(10);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r16)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c3, item_r18));
} }
function AdaptRxListBuilderComponent_div_15_ng_template_9_div_8_ng_container_2_ng_template_2_Template(rf, ctx) { }
function AdaptRxListBuilderComponent_div_15_ng_template_9_div_8_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1, "\n              ");
    i0.ɵɵtemplate(2, AdaptRxListBuilderComponent_div_15_ng_template_9_div_8_ng_container_2_ng_template_2_Template, 0, 0, "ng-template", 23);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const childItem_r25 = ctx.$implicit;
    i0.ɵɵnextContext(3);
    const _r16 = i0.ɵɵreference(10);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngTemplateOutlet", _r16)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c3, childItem_r25));
} }
function AdaptRxListBuilderComponent_div_15_ng_template_9_div_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 29);
    i0.ɵɵtext(1, "\n            ");
    i0.ɵɵtemplate(2, AdaptRxListBuilderComponent_div_15_ng_template_9_div_8_ng_container_2_Template, 4, 4, "ng-container", 18);
    i0.ɵɵtext(3, "\n          ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const listItem_r20 = i0.ɵɵnextContext().$implicit;
    const ctx_r23 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("@listItemChildrenAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", listItem_r20.children)("ngForTrackBy", ctx_r23.trackByItem);
} }
function AdaptRxListBuilderComponent_div_15_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    const _r29 = i0.ɵɵgetCurrentView();
    i0.ɵɵtext(0, "\n          ");
    i0.ɵɵelementStart(1, "div", 24, 25);
    i0.ɵɵtext(3, "\n            ");
    i0.ɵɵelementStart(4, "adapt-rx-list-item", 26, 27);
    i0.ɵɵlistener("onItemEdit", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_onItemEdit_4_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r28 = i0.ɵɵnextContext(2); return ctx_r28.onListItemEdit($event); })("onItemDelete", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_onItemDelete_4_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r30 = i0.ɵɵnextContext(2); return ctx_r30.onListItemDelete($event); })("onItemUpdate", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_onItemUpdate_4_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r31 = i0.ɵɵnextContext(2); return ctx_r31.onListItemUpdate($event); })("onListItemValueChange", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_onListItemValueChange_4_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r32 = i0.ɵɵnextContext(2); return ctx_r32.onListItemChange($event); })("onExitEditMode", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_onExitEditMode_4_listener() { i0.ɵɵrestoreView(_r29); const ctx_r33 = i0.ɵɵnextContext(2); return ctx_r33.onExitListItemEdit(); })("onKeyUp", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_onKeyUp_4_listener() { const restoredCtx = i0.ɵɵrestoreView(_r29); const listItem_r20 = restoredCtx.$implicit; const ctx_r34 = i0.ɵɵnextContext(2); return ctx_r34.onKeyUp(listItem_r20.id); })("onKeyDown", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_onKeyDown_4_listener() { const restoredCtx = i0.ɵɵrestoreView(_r29); const listItem_r20 = restoredCtx.$implicit; const ctx_r35 = i0.ɵɵnextContext(2); return ctx_r35.onKeyDown(listItem_r20.id); })("selectionStateChange", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_selectionStateChange_4_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r36 = i0.ɵɵnextContext(2); return ctx_r36.onSelectionStateChange($event); })("dragStart", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_dragStart_4_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r37 = i0.ɵɵnextContext(2); return ctx_r37.dragStartSubject.next($event); })("dragEnter", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_dragEnter_4_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r38 = i0.ɵɵnextContext(2); return ctx_r38.dragEnterSubject.next($event); })("dragOver", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_dragOver_4_listener($event) { i0.ɵɵrestoreView(_r29); const _r21 = i0.ɵɵreference(2); const ctx_r39 = i0.ɵɵnextContext(2); return ctx_r39.dragOverSubject.next({ event: $event.event, item: $event.item, draggableOverElement: _r21 }); })("dragLeave", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_dragLeave_4_listener($event) { i0.ɵɵrestoreView(_r29); const _r21 = i0.ɵɵreference(2); const ctx_r40 = i0.ɵɵnextContext(2); return ctx_r40.dragLeaveSubject.next({ event: $event.event, draggableLeaveElement: _r21 }); })("drop", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_drop_4_listener($event) { i0.ɵɵrestoreView(_r29); const ctx_r41 = i0.ɵɵnextContext(2); return ctx_r41.dropSubject.next($event); })("dragEnd", function AdaptRxListBuilderComponent_div_15_ng_template_9_Template_adapt_rx_list_item_dragEnd_4_listener() { i0.ɵɵrestoreView(_r29); const ctx_r42 = i0.ɵɵnextContext(2); return ctx_r42.dragEndSubject.next(); });
    i0.ɵɵelementEnd();
    i0.ɵɵtext(6, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(7, "\n\n          ");
    i0.ɵɵtemplate(8, AdaptRxListBuilderComponent_div_15_ng_template_9_div_8_Template, 4, 3, "div", 28);
    i0.ɵɵtext(9, "\n        ");
} if (rf & 2) {
    const listItem_r20 = ctx.$implicit;
    const _r22 = i0.ɵɵreference(5);
    const ctx_r17 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("adapt-list-builder__drag-drop-item", !ctx_r17.dragDisabled);
    i0.ɵɵproperty("@listItemAnimation", undefined);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("item", listItem_r20)("id", ctx_r17.id + "_item_" + listItem_r20.id)("testID", ctx_r17.testID + "_item-" + listItem_r20.id)("disabled", listItem_r20.disabled || ctx_r17.disabled)("readonly", ctx_r17.readonly)("searchQuery", ctx_r17.inputEl ? ctx_r17.inputEl.nativeElement.value : "")("allowSaving", !(ctx_r17.editValidationError || ctx_r17.editingItemDuplicateOrEmpty || ctx_r17.editingSizeExceeded))("editError", ctx_r17.editValidationError)("maxLength", ctx_r17.listItemMaxLength)("texts", ctx_r17.texts)("hideControls", ctx_r17.isDragging)("hideEdit", ctx_r17.hideEdit)("hideDelete", ctx_r17.hideDelete)("itemFormatter", ctx_r17.listItemFormatter)("itemSetterProp", ctx_r17.listItemSetterProp)("itemContentTemplate", ctx_r17.listItemContentTemplate)("dragDisabled", ctx_r17.dragDisabled)("selectionMode", ctx_r17.getSelectionMode());
    i0.ɵɵadvance(4);
    i0.ɵɵproperty("ngIf", listItem_r20.children && listItem_r20.children.length && _r22.isExpanded);
} }
function AdaptRxListBuilderComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", null, 15);
    i0.ɵɵtext(2, "\n\n        ");
    i0.ɵɵtemplate(3, AdaptRxListBuilderComponent_div_15_adapt_custom_actions_3_Template, 2, 1, "adapt-custom-actions", 16);
    i0.ɵɵtext(4, "\n\n        ");
    i0.ɵɵtemplate(5, AdaptRxListBuilderComponent_div_15_div_5_Template, 9, 4, "div", 17);
    i0.ɵɵtext(6, "\n\n        ");
    i0.ɵɵtemplate(7, AdaptRxListBuilderComponent_div_15_ng_container_7_Template, 4, 4, "ng-container", 18);
    i0.ɵɵtext(8, "\n\n        ");
    i0.ɵɵtemplate(9, AdaptRxListBuilderComponent_div_15_ng_template_9_Template, 10, 22, "ng-template", null, 19, i0.ɵɵtemplateRefExtractor);
    i0.ɵɵtext(11, "\n\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@listAnimation", ctx_r1.filteredListItems);
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("ngIf", ctx_r1.selectionMode === "multiple" && !ctx_r1.disabled && !ctx_r1.readonly);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r1.hideListAreaLabel);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngForOf", ctx_r1.filteredListItems)("ngForTrackBy", ctx_r1.trackByItem);
} }
function AdaptRxListBuilderComponent_ng_template_19_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵelementStart(1, "div", 30);
    i0.ɵɵtext(2, "\n        ");
    i0.ɵɵelementStart(3, "adapt-empty-state", 31);
    i0.ɵɵtext(4, "\n          ");
    i0.ɵɵelementStart(5, "div", 32);
    i0.ɵɵtext(6, "\n            ");
    i0.ɵɵprojection(7);
    i0.ɵɵtext(8, "\n          ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(9, "\n        ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(10, "\n      ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n    ");
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("type", "objects")("label", ctx_r3.texts.notFound);
} }
const _c4 = [[["", 8, "empty-text"]]];
const _c5 = function (a0) { return { "height": a0 }; };
const _c6 = [".empty-text"];
var ListItemDropArea;
(function (ListItemDropArea) {
    ListItemDropArea[ListItemDropArea["Above"] = 0] = "Above";
    ListItemDropArea[ListItemDropArea["Below"] = 1] = "Below";
    ListItemDropArea[ListItemDropArea["Center"] = 2] = "Center";
})(ListItemDropArea || (ListItemDropArea = {}));
const DROP_AREA_EDGE = {
    top: .25,
    center: .5,
    bottom: .75
};
export class AdaptRxListBuilderComponent extends AdaptRxFormControlDirective {
    constructor(ngControl, _changeDetectorRef, ts, _ngZone, _adaptRadarService, _elem) {
        super(ngControl, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRxListBuilder, _changeDetectorRef);
        this.ts = ts;
        this._ngZone = _ngZone;
        this.controlName = 'list-builder';
        this.analyticsComponentName = AdaptRadarAngularCustomEventName;
        this.isDragging = false;
        this.focused = false;
        this.canAdd = false; // The flag notifying that search native input has a value
        this.filteredListItems = [];
        this.addingItemDuplicateOrEmpty = false;
        this.editingItemDuplicateOrEmpty = false;
        this.editingSizeExceeded = false;
        this.dragStartSubject = new ReplaySubject(1);
        this.dragEnterSubject = new ReplaySubject(1);
        this.dragOverSubject = new ReplaySubject(1);
        this.dragLeaveSubject = new ReplaySubject(1);
        this.dropSubject = new ReplaySubject(1);
        this.dragEndSubject = new ReplaySubject(1);
        /**
         * When present, hides the input for list filtering/item searching.
         * @docs-default false
         */
        this.hideSearchField = false;
        /**
         * When present, hides list item edit button.
         * @docs-default false
         */
        this.hideEdit = false;
        /**
         * When present, hides list item delete button.
         * @docs-default false
         */
        this.hideDelete = false;
        /**
         * When present, hides list title.
         * @docs-default false
         */
        this.hideListAreaLabel = false;
        /**
         * Allow creating nested structures when dragging one element over other element.
         * @docs-default false
         * @since 10.9.0
         */
        this.treeStructure = false;
        /**
         * Formatter that transforms item into a string to become editable
         * once custom content has been provided or to be displayed as an item.
         * @docs-default option => option[this.listItemSetterProp]
         * @since 11.5.0
         */
        this.listItemFormatter = this._defaultItemFormatter.bind(this);
        /**
         * Property name to be updated
         * @docs-default name
         * @since 11.5.0
         */
        this.listItemSetterProp = 'name';
        /**
         * Fires when list item has added
         */
        this.listItemAdd = new EventEmitter();
        /**
         * Fires when list item enters edit mode
         */
        this.listItemEdit = new EventEmitter();
        /**
         * Fires when list item has been updated. Returns <code>[oldValue, newValue]</code>
         */
        this.listItemUpdate = new EventEmitter();
        /**
         * Fires when list item has removed
         */
        this.listItemRemove = new EventEmitter();
        this._dragItemExpandOverWaitTimeMs = 300; // Delay before list children open when drag over them
        this._defaultTexts = {};
        this._dragMoveCursor = {
            clientX: 0,
            clientY: 0
        };
        this._dragOverClasses = [];
        this._draggableClasses = {
            drag: 'adapt-list-builder__drag-item',
            drop: 'adapt-list-builder__drop-item',
            dropAreaAbove: 'adapt-list-builder__drop-area_above',
            dropAreaBelow: 'adapt-list-builder__drop-area_below',
            dropAreaCenter: 'adapt-list-builder__drop-area_center'
        };
        this.setDefaultTexts(ts.getCurrentLanguage());
    }
    /**
     * When present, it specifies that the element should be disabled.
     * @docs-default false
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (this.inputEl) {
            this._cleanInput();
            this._updateListOptions();
        }
        this._disabled = Boolean(value);
    }
    /**
     * Check if the control has UI error state
     */
    get hasDangerState() {
        return !this.readonly && this.adaptRxFeedbackRef.hasUIErrorState;
    }
    get selectionActions() {
        return [
            {
                name: this.texts.selectAll,
                visible: this._canBeSelected(),
                onClick: this._selectAll.bind(this)
            },
            {
                name: this.texts.clear,
                visible: this._canBeCleared(),
                onClick: this._clearAll.bind(this)
            }
        ];
    }
    ngOnInit() {
        super.ngOnInit();
        this.texts = Object.assign(Object.assign({}, this._defaultTexts), this.texts);
        this._ngZone.onStable
            .pipe(take(1), takeUntil(this.destroy$))
            .subscribe(() => {
            this._autoSelectItem();
            if (this._isNestedStructure() && !!this.selectionMode) {
                adaptWarn('ADAPT-ANGULAR Warning! List builder component! Selection feature is working only with flat list builder model structure');
            }
        });
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        if (this.inputEl) {
            fromEvent(this.inputEl.nativeElement, 'input')
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => {
                this._updateListOptions();
            });
            fromEvent(this.inputEl.nativeElement, 'keyup')
                .pipe(takeUntil(this.destroy$), tap(() => this.canAdd = !this.readonly && Boolean(this.inputEl.nativeElement.value)))
                .subscribe((event) => {
                const keyCode = getEventKeyCode(event);
                if (keyCode === ESCAPE || keyCode === ENTER) {
                    event.preventDefault();
                    switch (keyCode) {
                        case ESCAPE: {
                            this._cleanInput();
                            this._updateListOptions();
                            break;
                        }
                        case ENTER: {
                            if (!this.readonly && !this.addingItemDuplicateOrEmpty && !this.addValidationError) {
                                this.onListItemAdd();
                            }
                            break;
                        }
                    }
                }
            });
        }
        this.dragStartSubject
            .pipe(switchMap(e => of(e)), takeUntil(this.destroy$))
            .subscribe(({ event, item }) => {
            this.onDragStart(event, item);
        });
        this.dragEnterSubject
            .pipe(switchMap(e => of(e)), takeUntil(this.destroy$))
            .subscribe(({ event, item }) => {
            this.onDragEnter(event, item);
        });
        this.dragOverSubject
            .pipe(switchMap(e => of(e)), takeUntil(this.destroy$))
            .subscribe(({ event, item, draggableOverElement }) => {
            this.onDragOver(event, item, draggableOverElement);
        });
        this.dragLeaveSubject
            .pipe(switchMap(e => of(e)), takeUntil(this.destroy$))
            .subscribe(({ event, draggableLeaveElement }) => {
            this.onDragLeave(event, draggableLeaveElement);
        });
        this.dropSubject
            .pipe(switchMap(e => of(e)), takeUntil(this.destroy$))
            .subscribe((event) => {
            this.onDrop(event);
        });
        this.dragEndSubject
            .pipe(switchMap(e => of(e)), takeUntil(this.destroy$))
            .subscribe(() => {
            this.onDragEnd();
        });
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        clearTimeout(this._overItemTimeout);
    }
    get errors() {
        let _errors = this.ngControl.errors;
        if (!this.readonly && this.addValidationError && !this.addingItemDuplicateOrEmpty) {
            const _itemAddError = {
                itemAddError: {
                    message: this.addValidationError,
                    priority: 0
                }
            };
            _errors = Object.assign(Object.assign({}, this.ngControl.errors), _itemAddError);
        }
        return _errors;
    }
    setDefaultTexts(translation) {
        this._defaultTexts.requiredText = translation['adapt.common.required'];
        this._defaultTexts.searchPlaceholder = translation['adapt.listBuilder.searchPlaceholder'];
        this._defaultTexts.headerText = translation['adapt.listBuilder.headerText'];
        this._defaultTexts.numberOptionsText = translation['adapt.listBuilder.numberOptionsText'];
        this._defaultTexts.add = translation['adapt.listBuilder.add'];
        this._defaultTexts.notFound = translation['adapt.listBuilder.notFound'];
        this._defaultTexts.selectAll = translation['adapt.listBuilder.selectAll'];
        this._defaultTexts.clear = translation['adapt.listBuilder.clear'];
        this._defaultTexts.edit = translation['adapt.common.edit'];
        this._defaultTexts.save = translation['adapt.common.save'];
        this._defaultTexts.cancel = translation['adapt.common.cancel'];
        this._defaultTexts.delete = translation['adapt.common.delete'];
    }
    writeValue(value) {
        this._modelValue = isArray(value) ? value : [];
        if (isFunction(this.customSort)) {
            this._modelValue = this._sortSelectOptions(this._modelValue);
        }
        this._updateListOptions();
    }
    focusHandler(event) {
        this.focused = true;
        super.focusHandler(event);
    }
    blurHandler(event) {
        this.focused = false;
        this._onTouched();
        super.blurHandler(event);
    }
    get dragDisabled() {
        return (this.canAdd || this.nonInteractive || isFunction(this.customSort));
    }
    onDragStart(event, item) {
        this._ngZone.run(() => {
            this.isDragging = true;
            item.isExpanded = false;
        });
        // Required by Firefox (https://stackoverflow.com/questions/19055264/why-doesnt-html5-drag-and-drop-work-in-firefox)
        event.dataTransfer.setData(this.listItemFormatter(item.item), toString(item.item.id));
        this._preview = this._createPreviewElement(item.listItemContainer.nativeElement);
        document.body.appendChild(this._preview);
        // we need to replace default drag image by custom element
        event.dataTransfer.setDragImage(this._preview, 0, 0);
        this._dragItem = item.item;
        this._dragElement = item.listItemContainer.nativeElement;
        this._placeholder = this._createPlaceholderElement(item.listItemContainer.nativeElement);
        document.body.appendChild(this._placeholder);
    }
    onDragEnter(event, item) {
        const dropArea = this._getDropArea(event, item);
        if (this._placeholder) {
            switch (dropArea) {
                case ListItemDropArea.Above: {
                    this._placeholder.classList.remove('d-none');
                    item.listItemContainer.nativeElement.prepend(this._placeholder);
                    break;
                }
                case ListItemDropArea.Center: {
                    this._placeholder.classList.add('d-none');
                    item.listItemContainer.nativeElement.append(this._placeholder);
                    break;
                }
                case ListItemDropArea.Below: {
                    this._placeholder.classList.remove('d-none');
                    item.listItemContainer.nativeElement.append(this._placeholder);
                    break;
                }
            }
            this._dragElement.classList.add(this._draggableClasses.drag);
        }
    }
    onDragOver(event, item, draggableOverElement) {
        if (!this.isDragging) {
            return;
        }
        event.preventDefault();
        if (item !== this._dragOverItem) {
            clearTimeout(this._overItemTimeout);
            this._dragOverItem = item.item;
            // Handle item.children expand
            if (this._dragItem !== item.item && !item.isExpanded) {
                this._overItemTimeout = window.setTimeout(() => {
                    item.isExpanded = true;
                }, this._dragItemExpandOverWaitTimeMs);
            }
            this._dragOverElement = draggableOverElement;
        }
        if (event.clientX === this._dragMoveCursor.clientX && event.clientY === this._dragMoveCursor.clientY) {
            return;
        }
        this._dragMoveCursor.clientX = event.clientX;
        this._dragMoveCursor.clientY = event.clientY;
        this._dropArea = this._getDropArea(event, item);
        this._dragOverClasses = this._getDragOverClasses(item.item);
        this._dragOverElement.classList.add(...this._dragOverClasses);
    }
    onDragLeave(event, draggableLeaveElement) {
        if (draggableLeaveElement) {
            draggableLeaveElement.classList.remove(this._draggableClasses.drop, this._draggableClasses.dropAreaAbove, this._draggableClasses.dropAreaBelow, this._draggableClasses.dropAreaCenter);
            this._dragOverClasses = [];
        }
    }
    onDrop(event) {
        var _a, _b;
        if (!this.isDragging) {
            return;
        }
        event.preventDefault();
        if (((_a = this._dragOverItem) === null || _a === void 0 ? void 0 : _a.id) !== ((_b = this._dragItem) === null || _b === void 0 ? void 0 : _b.id)) {
            this._ngZone.run(() => {
                this._modelValue = this._replaceItemInList(this._modelValue, this._dragItem.id, this._dragOverItem.id, this._dropArea);
            });
            this._updateControlModel();
            this._onTouched();
        }
        this._dragElement.classList.remove(this._draggableClasses.drag);
        this._dragOverElement.classList.remove(this._draggableClasses.drop, this._draggableClasses.dropAreaAbove, this._draggableClasses.dropAreaBelow, this._draggableClasses.dropAreaCenter);
        this._destroyElements();
        this._dragItem = null;
        this._dragOverItem = null;
        this._dragElement = null;
        this._dragOverElement = null;
        this._dragOverClasses = [];
        this.isDragging = false;
    }
    onDragEnd() {
        clearTimeout(this._overItemTimeout);
        if (this._dragElement) {
            this._dragElement.classList.remove(this._draggableClasses.drag);
        }
        this._dragItem = null;
        this._dragOverItem = null;
        this._dragElement = null;
        this._dragOverElement = null;
        this.isDragging = false;
        this._destroyElements();
    }
    checkForAddError(searchQuery) {
        this.addingItemDuplicateOrEmpty = !searchQuery || Boolean(this._modelValue.find(item => this.listItemFormatter(item) === searchQuery));
        this.addValidationError = !this.addingItemDuplicateOrEmpty ?
            (this.itemValidation ? this.itemValidation(searchQuery, this._modelValue, false) : null) : null;
    }
    checkForEditError(oldValue, newValue) {
        this.editingItemDuplicateOrEmpty = !newValue || (oldValue === newValue);
        this.editingSizeExceeded = this.listItemMaxLength && newValue && newValue.length > this.listItemMaxLength;
        this.editValidationError = !this.editingItemDuplicateOrEmpty ?
            (this.itemValidation ? this.itemValidation(newValue, this._modelValue, true) : null) : null;
    }
    onListItemAdd() {
        var _a;
        const itemToAdd = {
            id: isFunction(this.generateListItemId) ? this.generateListItemId() : uuid(),
            [this.listItemSetterProp]: this.inputEl.nativeElement.value
        };
        this._modelValue.unshift(itemToAdd);
        this.listItemAdd.emit(itemToAdd);
        this._cleanInput();
        this._updateControlModel();
        this._adaptRadarService.sendCustomEventForAllProviders(AdaptRadarAngularCustomEventName.AdaptRxListBuilder, {
            GroupName: this.adaptRadarGroupName,
            EventType: AdaptRadarAngularCustomEventType.Click,
            Label: this.label,
            Required: this.required,
            ReadOnly: this.readonly,
            Disabled: this.disabled,
            Action: 'add',
            ListCount: (_a = this._modelValue) === null || _a === void 0 ? void 0 : _a.length,
            MaxDepth: maxDepth(this._modelValue, 'children')
        });
    }
    onListItemEdit(listItem) {
        this.checkForEditError(this.listItemFormatter(listItem), this.listItemFormatter(listItem));
        this.listItemEdit.emit(listItem);
    }
    onListItemDelete(listItem) {
        var _a, _b, _c;
        // const modelBeforeDeletion = cloneDeep(this._modelValue);
        const listItemParent = this._getParentItem(this._modelValue, listItem.id);
        const listItemContainer = listItemParent ? listItemParent.children : this._modelValue;
        const listItemIndex = findIndex(listItemContainer, elem => elem.id === listItem.id);
        listItemContainer.splice(listItemIndex, 1);
        if (listItem.selected && this.getSelectionMode() === 'single') {
            this._selectItemIfDeleted(listItemContainer, listItemIndex);
        }
        this.listItemRemove.emit(listItem);
        const totalChildren = (_b = (_a = listItem.children) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        const totalGrandChildren = listItem.children
            ? listItem.children.reduce((sum, child) => { var _a, _b; return sum + ((_b = (_a = child.children) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); }, 0)
            : 0;
        this._updateControlModel();
        this._onTouched();
        this._adaptRadarService.sendCustomEventForAllProviders(AdaptRadarAngularCustomEventName.AdaptRxListBuilder, {
            GroupName: this.adaptRadarGroupName,
            EventType: AdaptRadarAngularCustomEventType.Click,
            Label: this.label,
            Required: this.required,
            ReadOnly: this.readonly,
            Disabled: this.disabled,
            Action: 'delete',
            ListCount: (_c = this._modelValue) === null || _c === void 0 ? void 0 : _c.length,
            MaxDepth: maxDepth(this._modelValue, 'children'),
            TotalChildren: totalChildren,
            TotalGrandchildren: totalGrandChildren
        });
    }
    onListItemUpdate(itemValue) {
        const listItemParent = this._getParentItem(this._modelValue, itemValue[0].id);
        const listItemContainer = listItemParent ? listItemParent.children : this._modelValue;
        const listItemIndex = findIndex(listItemContainer, elem => elem.id === itemValue[0].id);
        listItemContainer[listItemIndex] = itemValue[1];
        this.listItemUpdate.emit(itemValue);
        this._updateControlModel();
    }
    onListItemChange(value) {
        this.checkForEditError(value[0], value[1]);
    }
    onExitListItemEdit() {
        this.editValidationError = null;
    }
    onKeyUp(shiftItemId) {
        if (this.dragDisabled) {
            return;
        }
        if (this.treeStructure) {
            const shiftItemParent = this._getParentItem(this._modelValue, shiftItemId);
            const shiftItemParentContainer = shiftItemParent ? shiftItemParent.children : this._modelValue;
            const shiftItemIndex = findIndex(shiftItemParentContainer, elem => elem.id === shiftItemId);
            const shiftItem = shiftItemParentContainer[shiftItemIndex];
            const shiftItemParentContainerPrevSibling = shiftItemParentContainer[shiftItemIndex - 1];
            if (shiftItemParentContainerPrevSibling) {
                // there is prev item in listItem parent container
                if (shiftItemParentContainerPrevSibling.children) {
                    // place listItem to prevSibling.children at the last position
                    shiftItemParentContainer.splice(shiftItemIndex, 1);
                    shiftItemParentContainerPrevSibling.children.push(shiftItem);
                }
                else {
                    // create nextSibling.children and place listItem
                    shiftItemParentContainer.splice(shiftItemIndex, 1);
                    shiftItemParentContainerPrevSibling.children = [shiftItem];
                }
            }
            else {
                // the start of the container
                if (shiftItemParentContainer !== this._modelValue) {
                    this._modelValue = this._replaceItemInList(this._modelValue, shiftItem.id, shiftItemParent.id, ListItemDropArea.Above);
                }
            }
            this._focusShiftedItem(shiftItem);
        }
        else {
            let index = findIndex(this._modelValue, elem => elem.id === shiftItemId);
            moveItemInArray(this._modelValue, index, (index === 0) ? this.filteredListItems.length : --index);
        }
        this._updateControlModel();
        this._onTouched();
    }
    onKeyDown(shiftItemId) {
        if (this.dragDisabled) {
            return;
        }
        if (this.treeStructure) {
            const shiftItemParent = this._getParentItem(this._modelValue, shiftItemId);
            const shiftItemParentContainer = shiftItemParent ? shiftItemParent.children : this._modelValue;
            const shiftItemIndex = findIndex(shiftItemParentContainer, elem => elem.id === shiftItemId);
            const shiftItem = shiftItemParentContainer[shiftItemIndex];
            const shiftItemParentContainerNextSibling = shiftItemParentContainer[shiftItemIndex + 1];
            if (shiftItemParentContainerNextSibling) {
                // there are some items in the listItem parent container
                if (shiftItemParentContainerNextSibling.children) {
                    // place listItem to nextSibling.children at the first position
                    shiftItemParentContainer.splice(shiftItemIndex, 1);
                    shiftItemParentContainerNextSibling.children.unshift(shiftItem);
                }
                else {
                    // create nextSibling.children and place listItem
                    shiftItemParentContainer.splice(shiftItemIndex, 1);
                    shiftItemParentContainerNextSibling.children = [shiftItem];
                }
            }
            else {
                // the end of the container
                if (shiftItemParentContainer !== this._modelValue) {
                    this._modelValue = this._replaceItemInList(this._modelValue, shiftItem.id, shiftItemParent.id, ListItemDropArea.Below);
                }
            }
            this._focusShiftedItem(shiftItem);
        }
        else {
            const index = findIndex(this._modelValue, elem => elem.id === shiftItemId);
            moveItemInArray(this._modelValue, index, (index + 1) % this.filteredListItems.length);
        }
        this._updateControlModel();
        this._onTouched();
    }
    onSelectionStateChange(changedItem) {
        if (this.selectionMode === 'single') {
            this._modelValue.forEach(item => {
                // For the "single" selection all items need to be changed
                item.selected = item.id === changedItem.id;
            });
        }
        if (this.selectionMode === 'multiple') {
            this._modelValue.forEach(item => {
                // For the "multiple" selection only changed item need to be changed
                if (item.id === changedItem.id) {
                    item.selected = changedItem.selected;
                }
            });
        }
        this._updateControlModel();
    }
    getSelectionMode() {
        // Turn off selection feature if user use tree structured list
        return this._isNestedStructure() ? null : this.selectionMode;
    }
    trackByItem(index, item) {
        return item.id;
    }
    /**
     * Implementation from the base class
     */
    _focusNativeElement() {
        this.inputEl.nativeElement.focus();
    }
    _defaultItemFormatter(item) {
        return item[this.listItemSetterProp];
    }
    _updateListOptions() {
        const searchQuery = this.inputEl ? this.inputEl.nativeElement.value : '';
        this.filteredListItems = this._filterTree(searchQuery, cloneDeep(this._modelValue));
        this.checkForAddError(searchQuery);
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
    _updateControlModel() {
        if (isFunction(this.customSort)) {
            this._modelValue = this._sortSelectOptions(this._modelValue);
        }
        this._updateListOptions();
        this._onChange(this._modelValue);
    }
    _cleanInput() {
        this.inputEl.nativeElement.value = '';
        this.canAdd = false;
    }
    _filterTree(filterQuery, list) {
        return filter(list, (item) => {
            if (includes(toLower(this.listItemFormatter(item)), toLower(filterQuery))) {
                return true;
            }
            else if (item.children) {
                item.children = this._filterTree(filterQuery, item.children);
                return !isEmpty(item.children);
            }
        });
    }
    _sortSelectOptions(model) {
        return model.sort(this.customSort);
    }
    _getParentItem(list, id, parentItem = null) {
        return list.reduce((foundParentElement, listItem) => {
            if (foundParentElement) {
                return foundParentElement;
            }
            if (listItem.id === id) {
                return parentItem;
            }
            if (listItem.children) {
                return this._getParentItem(listItem.children, id, listItem);
            }
        }, null);
    }
    _replaceItemInList(listItems, dragItemId, overItemId, dropArea) {
        listItems = cloneDeep(listItems);
        const dragItemParent = this._getParentItem(listItems, dragItemId);
        const dragItemParentContainer = dragItemParent ? dragItemParent.children : listItems;
        const dragItemIndex = findIndex(dragItemParentContainer, elem => elem.id === dragItemId);
        const dragItem = dragItemParentContainer[dragItemIndex];
        dragItemParentContainer.splice(dragItemIndex, 1);
        if (dragItemParent && !dragItemParentContainer.length) {
            delete dragItemParent.children;
        }
        const overItemParent = this._getParentItem(listItems, overItemId);
        const overItemParentContainer = overItemParent ? overItemParent.children : listItems;
        const overItemIndex = findIndex(overItemParentContainer, elem => elem.id === overItemId);
        const overItem = overItemParentContainer[overItemIndex];
        switch (dropArea) {
            case ListItemDropArea.Above: {
                overItemParentContainer.splice(overItemIndex, 0, dragItem);
                break;
            }
            case ListItemDropArea.Below: {
                overItemParentContainer.splice(overItemIndex + 1, 0, dragItem);
                break;
            }
            case ListItemDropArea.Center: {
                if (overItem.children) {
                    overItem.children.push(dragItem);
                }
                else {
                    overItem.children = [dragItem];
                }
                break;
            }
        }
        return listItems;
    }
    _getDropArea(event, adaptRxListItemComponent) {
        // Handle drag area
        const listItemElementBoundingClientRect = adaptRxListItemComponent.listItemContainer.nativeElement.getBoundingClientRect();
        const percentageY = (event.clientY - listItemElementBoundingClientRect.top) / listItemElementBoundingClientRect.height;
        if (this.treeStructure) {
            if (percentageY < DROP_AREA_EDGE.top) {
                return ListItemDropArea.Above;
            }
            else if (percentageY > DROP_AREA_EDGE.bottom) {
                return ListItemDropArea.Below;
            }
            else {
                return ListItemDropArea.Center;
            }
        }
        else {
            if (percentageY < DROP_AREA_EDGE.center) {
                return ListItemDropArea.Above;
            }
            else {
                return ListItemDropArea.Below;
            }
        }
    }
    _getDragOverClasses(listItem) {
        const classes = [];
        if (this._dragOverItem === listItem) {
            classes.push(this._draggableClasses.drop);
        }
        if (listItem !== this._dragItem && this._dragOverItem === listItem) {
            switch (this._dropArea) {
                case ListItemDropArea.Above:
                    classes.push(this._draggableClasses.dropAreaAbove);
                    break;
                case ListItemDropArea.Below:
                    classes.push(this._draggableClasses.dropAreaBelow);
                    break;
                case ListItemDropArea.Center:
                    classes.push(this._draggableClasses.dropAreaCenter);
                    break;
            }
        }
        return classes;
    }
    _focusShiftedItem(shiftItem) {
        this._ngZone.onStable
            .pipe(takeUntil(this.destroy$), take(1))
            .subscribe(() => {
            const activeListItemComponent = this.rxListItemComponents.find(item => item.item.id === shiftItem.id);
            if (shiftItem.children) {
                activeListItemComponent.isExpanded = false;
            }
            activeListItemComponent.listItemDnDSymbol.nativeElement.focus();
        });
    }
    _createPreviewElement(element) {
        const preview = element.cloneNode(true);
        // match styles
        const { width, height } = element.getBoundingClientRect();
        preview.style.width = `${width}px`;
        preview.style.height = `${height}px`;
        preview.style.pointerEvents = 'none';
        preview.style.margin = '0';
        preview.style.position = 'absolute';
        preview.style.top = '0';
        preview.style.left = `-${width}px`;
        return preview;
    }
    _createPlaceholderElement(element) {
        const placeholder = document.createElement('div');
        const { width } = element.getBoundingClientRect();
        placeholder.style.width = `${width}px`;
        placeholder.classList.add('placeholder');
        return placeholder;
    }
    _destroyElements() {
        if (this._placeholder) {
            this._placeholder.parentElement.removeChild(this._placeholder);
            this._placeholder = null;
        }
        if (this._preview) {
            this._preview.parentElement.removeChild(this._preview);
            this._preview = null;
        }
    }
    _autoSelectItem() {
        var _a;
        // For cases when no item is marked as selected and selection mode is "single" automatically select available item in the list
        if (this.getSelectionMode() === 'single'
            && ((_a = this._modelValue) === null || _a === void 0 ? void 0 : _a.length)
            && !this._modelValue.some(v => v.selected)
            && !this.disabled
            && !this.readonly) {
            const firstAvailableItemForSelection = this._modelValue.findIndex(v => !v.disabled);
            if (firstAvailableItemForSelection !== -1) {
                this._modelValue[firstAvailableItemForSelection].selected = true;
                this._updateControlModel();
            }
        }
    }
    _selectAll() {
        this._modelValue.forEach(item => {
            if (!item.disabled) {
                item.selected = true;
            }
        });
        this._updateControlModel();
    }
    _clearAll() {
        this._modelValue.forEach(item => {
            if (!item.disabled) {
                item.selected = false;
            }
        });
        this._updateControlModel();
    }
    _canBeSelected() {
        return this._modelValue.some(v => !v.disabled && !v.selected);
    }
    _canBeCleared() {
        return this._modelValue.some(v => !v.disabled && v.selected);
    }
    _selectItemIfDeleted(listItemContainer, listItemIndex) {
        // First iteration trying to select next item in the list
        const availableItemForSelection = listItemContainer
            .find((item, i) => i >= listItemIndex && !item.disabled);
        if (availableItemForSelection) {
            availableItemForSelection.selected = true;
        }
        else {
            // In case it is not possible to select next item selecting previous one
            const listItemContainerCopy = [...listItemContainer];
            const availableItemForSelection = listItemContainerCopy.reverse().find(item => !item.disabled);
            if (availableItemForSelection) {
                availableItemForSelection.selected = true;
            }
        }
    }
    _isNestedStructure() {
        return this.treeStructure || this._modelValue.some(v => { var _a; return (_a = v.children) === null || _a === void 0 ? void 0 : _a.length; });
    }
}
AdaptRxListBuilderComponent.ɵfac = function AdaptRxListBuilderComponent_Factory(t) { return new (t || AdaptRxListBuilderComponent)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRxListBuilderComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxListBuilderComponent, selectors: [["adapt-rx-list-builder"]], viewQuery: function AdaptRxListBuilderComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 5);
        i0.ɵɵviewQuery(_c1, 5);
        i0.ɵɵviewQuery(_c2, 7);
        i0.ɵɵviewQuery(AdaptRxListItemComponent, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemsList = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputEl = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptRxFeedbackRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.rxListItemComponents = _t);
    } }, inputs: { hideSearchField: "hideSearchField", hideEdit: "hideEdit", hideDelete: "hideDelete", hideListAreaLabel: "hideListAreaLabel", customSort: "customSort", texts: "texts", menuHeight: "menuHeight", listItemMaxLength: "listItemMaxLength", generateListItemId: "generateListItemId", itemValidation: "itemValidation", disabled: "disabled", treeStructure: "treeStructure", listItemFormatter: "listItemFormatter", listItemSetterProp: "listItemSetterProp", listItemContentTemplate: "listItemContentTemplate", selectionMode: "selectionMode" }, outputs: { listItemAdd: "listItemAdd", listItemEdit: "listItemEdit", listItemUpdate: "listItemUpdate", listItemRemove: "listItemRemove" }, features: [i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c6, decls: 29, vars: 29, consts: [[1, "adapt-list-builder"], [3, "for", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"], [1, "adapt-list-builder__wrp"], ["class", "adapt-list-builder__search", 3, "focused", 4, "ngIf"], [1, "adapt-list-container", "adapt-list", 3, "ngStyle"], [4, "ngIf", "ngIfElse"], ["empty", ""], [3, "ariaErrorMessage", "errors", "warningMessage", "controlTouched", "messageAppeared"], ["adaptRxFeedbackRef", ""], [1, "adapt-list-builder__search"], [1, "d-icon-search"], ["type", "text", 1, "form-control", "adapt-list-builder__search-input", "m-start-1", 3, "id", "disabled", "autofocus", "focus", "blur"], ["filterInput", ""], ["type", "button", "role", "button", "class", "adapt-list-builder__add-item btn btn-link", 3, "click", 4, "ngIf"], ["type", "button", "role", "button", 1, "adapt-list-builder__add-item", "btn", "btn-link", 3, "click"], ["itemsList", ""], ["class", "adapt-list-builder__list-selection-actions", 3, "actions", 4, "ngIf"], ["class", "adapt-list-builder__list-header", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["listItemTemplate", ""], [1, "adapt-list-builder__list-selection-actions", 3, "actions"], [1, "adapt-list-builder__list-header"], [1, "letter-space"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "adapt-list-builder__list-wrp"], ["draggableItemElement", ""], [3, "item", "id", "testID", "disabled", "readonly", "searchQuery", "allowSaving", "editError", "maxLength", "texts", "hideControls", "hideEdit", "hideDelete", "itemFormatter", "itemSetterProp", "itemContentTemplate", "dragDisabled", "selectionMode", "onItemEdit", "onItemDelete", "onItemUpdate", "onListItemValueChange", "onExitEditMode", "onKeyUp", "onKeyDown", "selectionStateChange", "dragStart", "dragEnter", "dragOver", "dragLeave", "drop", "dragEnd"], ["listItemComponent", ""], ["class", "adapt-list-builder__list-item-children", 4, "ngIf"], [1, "adapt-list-builder__list-item-children"], [1, "list-container"], [3, "adaptRadarDisableEventSending", "type", "label"], [1, "empty-info"]], template: function AdaptRxListBuilderComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c4);
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n\n  ");
        i0.ɵɵtext(2, "\n  ");
        i0.ɵɵelement(3, "adapt-rx-control-label", 1);
        i0.ɵɵtext(4, "\n  ");
        i0.ɵɵtext(5, "\n\n  ");
        i0.ɵɵelementStart(6, "div", 2);
        i0.ɵɵtext(7, "\n\n    ");
        i0.ɵɵtext(8, "\n    ");
        i0.ɵɵtemplate(9, AdaptRxListBuilderComponent_div_9_Template, 9, 15, "div", 3);
        i0.ɵɵtext(10, "\n    ");
        i0.ɵɵtext(11, "\n\n    ");
        i0.ɵɵtext(12, "\n    ");
        i0.ɵɵelementStart(13, "div", 4);
        i0.ɵɵtext(14, "\n      ");
        i0.ɵɵtemplate(15, AdaptRxListBuilderComponent_div_15_Template, 12, 5, "div", 5);
        i0.ɵɵtext(16, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(17, "\n    ");
        i0.ɵɵtext(18, "\n\n    ");
        i0.ɵɵtemplate(19, AdaptRxListBuilderComponent_ng_template_19_Template, 12, 3, "ng-template", null, 6, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(21, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n\n  ");
        i0.ɵɵtext(23, "\n  ");
        i0.ɵɵelementStart(24, "adapt-rx-feedback", 7, 8);
        i0.ɵɵlistener("messageAppeared", function AdaptRxListBuilderComponent_Template_adapt_rx_feedback_messageAppeared_24_listener($event) { return ctx.handleMessageAppeared($event, ctx.analyticsComponentName.AdaptRxListBuilder); });
        i0.ɵɵtext(26, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(27, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(28, "\n");
    } if (rf & 2) {
        const _r2 = i0.ɵɵreference(20);
        i0.ɵɵclassProp("has-danger", ctx.hasDangerState)("has-warning", ctx.warningMessage)("disabled", ctx.disabled)("adapt-list-builder_sorted", !!ctx.customSort)("readonly", ctx.readonly);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("subLabel", ctx.subLabel)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltip)("testID", ctx.testID);
        i0.ɵɵadvance(6);
        i0.ɵɵproperty("ngIf", !ctx.hideSearchField);
        i0.ɵɵadvance(4);
        i0.ɵɵclassProp("borderless", !ctx.hideSearchField);
        i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(27, _c5, ctx.menuHeight));
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.filteredListItems.length)("ngIfElse", _r2);
        i0.ɵɵadvance(9);
        i0.ɵɵproperty("ariaErrorMessage", ctx.ariaErrorMessage)("errors", ctx.errors)("warningMessage", ctx.warningMessage)("controlTouched", ctx.ngControl.touched);
    } }, encapsulation: 2, data: { animation: [
            trigger('listAnimation', [
                transition('* => 0', []),
                transition(':decrement', [
                    query('@listItemAnimation', [
                        animateChild()
                    ], { optional: true })
                ]),
                transition(':enter, :increment', [
                    query('@listItemAnimation', [
                        animateChild()
                    ], { optional: true })
                ])
            ]),
            trigger('listItemAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.itemIn)
                ]),
                transition(':leave', [
                    useAnimation(ANIMATION_NAME.itemOut)
                ])
            ]),
            trigger('listItemChildrenAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '0',
                            to: '*'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(ANIMATION_NAME.height, {
                        params: {
                            from: '*',
                            to: '0'
                        }
                    })
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxListBuilderComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-list-builder',
                encapsulation: ViewEncapsulation.None,
                templateUrl: './adapt-rx-list-builder.component.html',
                animations: [
                    trigger('listAnimation', [
                        transition('* => 0', []),
                        transition(':decrement', [
                            query('@listItemAnimation', [
                                animateChild()
                            ], { optional: true })
                        ]),
                        transition(':enter, :increment', [
                            query('@listItemAnimation', [
                                animateChild()
                            ], { optional: true })
                        ])
                    ]),
                    trigger('listItemAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.itemIn)
                        ]),
                        transition(':leave', [
                            useAnimation(ANIMATION_NAME.itemOut)
                        ])
                    ]),
                    trigger('listItemChildrenAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '0',
                                    to: '*'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(ANIMATION_NAME.height, {
                                params: {
                                    from: '*',
                                    to: '0'
                                }
                            })
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i1.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i0.ChangeDetectorRef }, { type: i2.AdaptTranslateService }, { type: i0.NgZone }, { type: i3.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { hideSearchField: [{
            type: Input
        }], hideEdit: [{
            type: Input
        }], hideDelete: [{
            type: Input
        }], hideListAreaLabel: [{
            type: Input
        }], customSort: [{
            type: Input
        }], texts: [{
            type: Input
        }], menuHeight: [{
            type: Input
        }], listItemMaxLength: [{
            type: Input
        }], generateListItemId: [{
            type: Input
        }], itemValidation: [{
            type: Input
        }], disabled: [{
            type: Input
        }], treeStructure: [{
            type: Input
        }], listItemFormatter: [{
            type: Input
        }], listItemSetterProp: [{
            type: Input
        }], listItemContentTemplate: [{
            type: Input
        }], selectionMode: [{
            type: Input
        }], listItemAdd: [{
            type: Output
        }], listItemEdit: [{
            type: Output
        }], listItemUpdate: [{
            type: Output
        }], listItemRemove: [{
            type: Output
        }], itemsList: [{
            type: ViewChild,
            args: ['itemsList', { static: false }]
        }], inputEl: [{
            type: ViewChild,
            args: ['filterInput', { static: false }]
        }], rxListItemComponents: [{
            type: ViewChildren,
            args: [AdaptRxListItemComponent]
        }], adaptRxFeedbackRef: [{
            type: ViewChild,
            args: ['adaptRxFeedbackRef', { static: true }]
        }] }); })();
//# sourceMappingURL=adapt-rx-list-builder.component.js.map