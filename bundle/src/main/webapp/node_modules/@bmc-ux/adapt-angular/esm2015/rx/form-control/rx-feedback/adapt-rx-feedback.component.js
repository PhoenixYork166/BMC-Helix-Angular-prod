import { ChangeDetectorRef, Component, EventEmitter, Input, Output } from '@angular/core';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { asyncScheduler, ReplaySubject, Subject } from 'rxjs';
import { takeUntil, throttleTime } from 'rxjs/operators';
import { isEqual } from 'lodash-es';
import { SafeCdr } from '../../../common/safe-cdr';
import { AdaptRxFeedbackService } from './adapt-rx-feedback.service';
import * as i0 from "@angular/core";
import * as i1 from "./adapt-rx-feedback.service";
import * as i2 from "@angular/common";
function AdaptRxFeedbackComponent_div_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const error_r5 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(error_r5.body.message);
} }
const _c0 = function (a0) { return { $implicit: a0, type: "danger" }; };
function AdaptRxFeedbackComponent_div_2_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 8);
} if (rf & 2) {
    const error_r5 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵnextContext();
    const _r3 = i0.ɵɵreference(10);
    i0.ɵɵproperty("ngTemplateOutlet", _r3)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c0, error_r5.body.message));
} }
function AdaptRxFeedbackComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptRxFeedbackComponent_div_2_ng_container_2_Template, 2, 1, "ng-container", 6);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptRxFeedbackComponent_div_2_ng_container_4_Template, 1, 4, "ng-container", 7);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@feedbackAnimation", undefined);
    i0.ɵɵattribute("id", ctx_r0.ariaErrorMessage);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r0.alertFeedbackStyle);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r0.alertFeedbackStyle);
} }
function AdaptRxFeedbackComponent_div_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r10 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r10.successMessage);
} }
const _c1 = function (a0) { return { $implicit: a0, type: "success" }; };
function AdaptRxFeedbackComponent_div_4_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 8);
} if (rf & 2) {
    const ctx_r11 = i0.ɵɵnextContext(2);
    const _r3 = i0.ɵɵreference(10);
    i0.ɵɵproperty("ngTemplateOutlet", _r3)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c1, ctx_r11.successMessage));
} }
function AdaptRxFeedbackComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptRxFeedbackComponent_div_4_ng_container_2_Template, 2, 1, "ng-container", 6);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptRxFeedbackComponent_div_4_ng_container_4_Template, 1, 4, "ng-container", 7);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@feedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r1.alertFeedbackStyle);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r1.alertFeedbackStyle);
} }
function AdaptRxFeedbackComponent_div_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtext(1);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r12 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r12.warningMessage);
} }
const _c2 = function (a0) { return { $implicit: a0, type: "warning" }; };
function AdaptRxFeedbackComponent_div_6_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0, 8);
} if (rf & 2) {
    const ctx_r13 = i0.ɵɵnextContext(2);
    const _r3 = i0.ɵɵreference(10);
    i0.ɵɵproperty("ngTemplateOutlet", _r3)("ngTemplateOutletContext", i0.ɵɵpureFunction1(2, _c2, ctx_r13.warningMessage));
} }
function AdaptRxFeedbackComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 10);
    i0.ɵɵtext(1, "\n    ");
    i0.ɵɵtemplate(2, AdaptRxFeedbackComponent_div_6_ng_container_2_Template, 2, 1, "ng-container", 6);
    i0.ɵɵtext(3, "\n    ");
    i0.ɵɵtemplate(4, AdaptRxFeedbackComponent_div_6_ng_container_4_Template, 1, 4, "ng-container", 7);
    i0.ɵɵtext(5, "\n  ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵproperty("@feedbackAnimation", undefined);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", !ctx_r2.alertFeedbackStyle);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r2.alertFeedbackStyle);
} }
function AdaptRxFeedbackComponent_ng_template_9_div_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 16);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "div", 15);
    i0.ɵɵtext(3, "\u00A0");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} }
function AdaptRxFeedbackComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n  ");
    i0.ɵɵelementStart(1, "div", 11);
    i0.ɵɵtext(2, "\n    ");
    i0.ɵɵtemplate(3, AdaptRxFeedbackComponent_ng_template_9_div_3_Template, 5, 0, "div", 12);
    i0.ɵɵtext(4, "\n\n    ");
    i0.ɵɵelementStart(5, "div", 13);
    i0.ɵɵtext(6, "\n      ");
    i0.ɵɵelement(7, "div", 14);
    i0.ɵɵtext(8, "\n      ");
    i0.ɵɵelementStart(9, "div", 15);
    i0.ɵɵtext(10);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(11, "\n    ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(12, "\n  ");
    i0.ɵɵelementEnd();
    i0.ɵɵtext(13, "\n");
} if (rf & 2) {
    const message_r14 = ctx.$implicit;
    const type_r15 = ctx.type;
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("alert_truncated-wrapper", ctx_r4.alertFeedbackTruncation);
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("ngIf", ctx_r4.alertFeedbackTruncation);
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("alert_truncated", ctx_r4.alertFeedbackTruncation)("alert-success", type_r15 === "success")("alert-danger", type_r15 === "danger")("alert-warning", type_r15 === "warning");
    i0.ɵɵadvance(2);
    i0.ɵɵclassProp("d-icon-check_circle", type_r15 === "success")("d-icon-exclamation_triangle", type_r15 === "danger")("d-icon-exclamation_circle", type_r15 === "warning");
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(message_r14);
} }
export class AdaptRxFeedbackComponent {
    constructor(_changeDetectorRef, _feedbackService) {
        this._changeDetectorRef = _changeDetectorRef;
        this._feedbackService = _feedbackService;
        this.validationErrors = [];
        /**
         * The event firing when the component shows error state
         */
        this.messageAppeared = new EventEmitter();
        this._rawErrors = null;
        this._isTouched = false;
        this._checkForErrors$ = new Subject();
        this._destroyed$ = new ReplaySubject(1);
        // Subscribe on errors checking. Using subject to avoid redundant checking method calls
        this._checkForErrors$
            .pipe(takeUntil(this._destroyed$), throttleTime(100, asyncScheduler, { trailing: true }))
            .subscribe(() => {
            this._checkForErrors();
        });
    }
    /**
     * Errors object
     */
    set errors(value) {
        if (!isEqual(value, this._rawErrors)) {
            this._rawErrors = value;
            this._checkForErrors$.next();
        }
    }
    /**
     * Indicator if control touched
     * Some of errors by default must be visible only if the control touched
     */
    set controlTouched(value) {
        const isTouchedNext = Boolean(value);
        if (this._isTouched !== isTouchedNext) {
            this._isTouched = isTouchedNext;
            this._checkForErrors$.next();
        }
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    /**
     * Check if the error state is being
     */
    get hasUIErrorState() {
        return Boolean(this.validationErrors.length);
    }
    /**
     * Check if it must be success message be shown
     */
    get hasSuccessStateMessage() {
        return Boolean(this.successMessage) && !this.validationErrors.length && this._isTouched;
    }
    /**
     * Check if there are errors
     */
    _checkForErrors() {
        const actualNgControlErrors = this._rawErrors;
        if (actualNgControlErrors) {
            Object.keys(actualNgControlErrors).forEach((actualNgControlErrorName) => {
                // Get actual error from stored validation errors
                const storedValidationError = this.validationErrors.find(elem => elem.name === actualNgControlErrorName);
                // Get actual error body
                let actualErrorBody = actualNgControlErrors[actualNgControlErrorName];
                // Get error body by error key or default
                const defaultError = this._feedbackService.defaultValidationErrors[actualNgControlErrorName] ||
                    this._feedbackService.defaultValidationErrors['default'];
                // Extend actual error body with default properties
                actualErrorBody = Object.assign({ message: defaultError.getMessage(actualNgControlErrors[actualNgControlErrorName]), showOnTouched: Boolean(defaultError.showOnTouched), priority: defaultError.priority }, actualErrorBody);
                if (storedValidationError) {
                    // If actual error was stored previously, just update stored validation error body
                    storedValidationError.body = actualErrorBody;
                }
                else {
                    if (!actualErrorBody.showOnTouched || (actualErrorBody.showOnTouched && this._isTouched)) {
                        this.validationErrors.push({ name: actualNgControlErrorName, body: actualErrorBody });
                    }
                }
            });
            // Find and remove errors in stored errors array which dont exist in FormControl
            const errorsToRemove = this.validationErrors.filter(errorToRemove => {
                return !Object.prototype.hasOwnProperty.call(actualNgControlErrors, errorToRemove.name) || (errorToRemove.body.showOnTouched && !this._isTouched);
            });
            errorsToRemove.forEach(errorToRemove => {
                const index = this.validationErrors.indexOf(errorToRemove);
                this.validationErrors.splice(index, 1);
            });
        }
        else {
            this.validationErrors.length = 0;
        }
        // Sort validation errors by priority
        this.validationErrors.sort((prevError, nextError) => prevError.body.priority - nextError.body.priority);
        if (this.validationErrors.length > 0) {
            this.messageAppeared.emit({ errors: this.validationErrors });
        }
        // If the parent component uses OnPush strategy need to additionally notify about changes
        SafeCdr.markForCheck(this._changeDetectorRef);
    }
}
AdaptRxFeedbackComponent.ɵfac = function AdaptRxFeedbackComponent_Factory(t) { return new (t || AdaptRxFeedbackComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.AdaptRxFeedbackService)); };
AdaptRxFeedbackComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxFeedbackComponent, selectors: [["adapt-rx-feedback"]], inputs: { ariaErrorMessage: "ariaErrorMessage", errors: "errors", controlTouched: "controlTouched", successMessage: "successMessage", warningMessage: "warningMessage", alertFeedbackStyle: "alertFeedbackStyle", alertFeedbackTruncation: "alertFeedbackTruncation" }, outputs: { messageAppeared: "messageAppeared" }, decls: 12, vars: 3, consts: [[1, "form-control-feedback"], ["class", "rx-feedback-alert text-danger", "role", "alert", 4, "ngFor", "ngForOf"], ["class", "rx-feedback-alert text-success", "role", "alert", 4, "ngIf"], ["class", "rx-feedback-alert text-warning", "role", "alert", 4, "ngIf"], ["solidFeedbackTemplate", ""], ["role", "alert", 1, "rx-feedback-alert", "text-danger"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "alert", 1, "rx-feedback-alert", "text-success"], ["role", "alert", 1, "rx-feedback-alert", "text-warning"], [1, "py-1"], ["class", "alert m-0 invisible", 4, "ngIf"], [1, "alert", "m-0"], [1, "alert-icon"], [1, "alert-content"], [1, "alert", "m-0", "invisible"]], template: function AdaptRxFeedbackComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵtemplate(2, AdaptRxFeedbackComponent_div_2_Template, 6, 4, "div", 1);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵtemplate(4, AdaptRxFeedbackComponent_div_4_Template, 6, 3, "div", 2);
        i0.ɵɵtext(5, "\n\n  ");
        i0.ɵɵtemplate(6, AdaptRxFeedbackComponent_div_6_Template, 6, 3, "div", 3);
        i0.ɵɵtext(7, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(8, "\n\n");
        i0.ɵɵtemplate(9, AdaptRxFeedbackComponent_ng_template_9_Template, 14, 18, "ng-template", null, 4, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(11, "\n");
    } if (rf & 2) {
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngForOf", ctx.validationErrors);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.hasSuccessStateMessage);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.warningMessage);
    } }, directives: [i2.NgForOf, i2.NgIf, i2.NgTemplateOutlet], encapsulation: 2, data: { animation: [
            trigger('feedbackAnimation', [
                state('void', style({ overflow: 'hidden' })),
                state('*', style({ overflow: 'visible' })),
                transition(':enter', [
                    style({ height: 0, opacity: 0, overflow: 'hidden' }),
                    animate('0.2s ease-in', style({ height: '*', opacity: 1, overflow: 'hidden' }))
                ]),
                transition(':leave', [
                    style({ height: '*', opacity: 1, overflow: 'hidden' }),
                    animate('0.2s ease-out', style({ height: 0, opacity: 0, overflow: 'hidden' }))
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxFeedbackComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-feedback',
                templateUrl: './adapt-rx-feedback.component.html',
                animations: [
                    trigger('feedbackAnimation', [
                        state('void', style({ overflow: 'hidden' })),
                        state('*', style({ overflow: 'visible' })),
                        transition(':enter', [
                            style({ height: 0, opacity: 0, overflow: 'hidden' }),
                            animate('0.2s ease-in', style({ height: '*', opacity: 1, overflow: 'hidden' }))
                        ]),
                        transition(':leave', [
                            style({ height: '*', opacity: 1, overflow: 'hidden' }),
                            animate('0.2s ease-out', style({ height: 0, opacity: 0, overflow: 'hidden' }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.AdaptRxFeedbackService }]; }, { ariaErrorMessage: [{
            type: Input
        }], errors: [{
            type: Input
        }], controlTouched: [{
            type: Input
        }], successMessage: [{
            type: Input
        }], warningMessage: [{
            type: Input
        }], alertFeedbackStyle: [{
            type: Input
        }], alertFeedbackTruncation: [{
            type: Input
        }], messageAppeared: [{
            type: Output
        }] }); })();
//# sourceMappingURL=adapt-rx-feedback.component.js.map