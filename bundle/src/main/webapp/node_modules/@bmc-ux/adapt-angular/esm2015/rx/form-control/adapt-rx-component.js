import { Directive, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import { ReplaySubject, Subject } from 'rxjs';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { AdaptTranslateService } from '../../common/i18n/index';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "../../common/i18n/index";
import * as i2 from "../../common/radar/adapt-radar";
let nextUniqueId = 1;
export class AdaptRxComponentDirective extends AdaptRadarAngularGenericDirective {
    /* eslint-enable @angular-eslint/no-output-on-prefix */
    constructor(ts, _adaptRadarService, _elem, _entityName) {
        super(_adaptRadarService, _elem, _entityName);
        this.ts = ts;
        this._required = false;
        this._disabled = false;
        this._readonly = false;
        this._autofocus = false;
        /**
         * Stream that emits whenever the state of the control changes. Needs to run change detection.
         */
        this.stateChanges$ = new Subject();
        /**
         * Destroy subject
         */
        this.destroy$ = new ReplaySubject(1);
        /**
         * Control [aria-label] attribute text
         */
        this.ariaLabel = null;
        /**
         * Control [aria-labeledby] attribute text
         */
        this.ariaLabelledby = null;
        /**
         * Control [aria-describedby] attribute text
         */
        this.ariaDescribedBy = null;
        /* eslint-disable @angular-eslint/no-output-on-prefix */
        /**
         * Focus emitter
         */
        this.onFocus = new EventEmitter();
        /**
         * Blur emitter
         */
        this.onBlur = new EventEmitter();
    }
    /**
     * Control [id]. Returns autogenerated if the value wasn't set
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value || this._uniqId;
    }
    /**
     * Control [disabled] attribute. No needed if the control uses as reactive one
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    /**
     * Control [readonly] attribute
     */
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        this._readonly = coerceBooleanProperty(value);
    }
    get nonInteractive() {
        return this.disabled || this.readonly;
    }
    /**
     * Control [autofocus] attribute
     */
    get autofocus() {
        return this._autofocus;
    }
    set autofocus(value) {
        this._autofocus = coerceBooleanProperty(value);
    }
    /**
     * Control [aria-errormessage] attribute value
     * Important thing here is that 'aria-errormessage' attribute is work in tandem with 'aria-invalid'
     * Additional info can be found here - https://www.w3.org/TR/wai-aria/#aria-errormessage
     *
     * @since 11.3.0
     */
    get ariaErrorMessage() {
        return this._ariaErrorMessage;
    }
    set ariaErrorMessage(value) {
        this._ariaErrorMessage = value !== null && value !== void 0 ? value : this._errorMessageId;
    }
    ngOnInit() {
        // Create the uniq ID of control
        this._uniqId = `rx-${this.controlName}-${nextUniqueId}`;
        this._errorMessageId = `rx-${this.controlName}-error-message-id-${nextUniqueId}`;
        nextUniqueId++;
        // Force setter to be called in case id was not specified.
        // TODO: refactor self-assignment
        /* eslint-disable */
        this.id = this.id;
        this.ariaErrorMessage = this.ariaErrorMessage;
        /* eslint-enable */
        this.requiredLabel = this.requiredLabel || this.ts.getCurrentLanguage()['adapt.common.required'];
        if (!this.testID) {
            this.testID = this.id;
        }
    }
    ngOnChanges(changes) {
        if (changes.autofocus && coerceBooleanProperty(changes.autofocus.currentValue) === true) {
            setTimeout(() => {
                this._focusNativeElement();
            }, 0);
        }
        this.stateChanges$.next();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.stateChanges$.complete();
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Callback on input focusHandler
     */
    focusHandler(event) {
        this.onFocus.emit(event);
    }
    /**
     * Callback on input blurHandler
     */
    blurHandler(event) {
        this.onBlur.emit(event);
    }
}
AdaptRxComponentDirective.ɵfac = function AdaptRxComponentDirective_Factory(t) { return new (t || AdaptRxComponentDirective)(i0.ɵɵdirectiveInject(i1.AdaptTranslateService), i0.ɵɵdirectiveInject(i2.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.AdaptRadarAngularCustomEventName)); };
AdaptRxComponentDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: AdaptRxComponentDirective, inputs: { name: "name", label: "label", subLabel: "subLabel", requiredLabel: "requiredLabel", ariaLabel: "ariaLabel", ariaLabelledby: "ariaLabelledby", ariaDescribedBy: "ariaDescribedBy", tabIndex: "tabIndex", testID: "testID", id: "id", disabled: "disabled", readonly: "readonly", autofocus: "autofocus", ariaErrorMessage: "ariaErrorMessage" }, outputs: { onFocus: "onFocus", onBlur: "onBlur" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxComponentDirective, [{
        type: Directive
    }], function () { return [{ type: i1.AdaptTranslateService }, { type: i2.AdaptRadarAngularService }, { type: i0.ElementRef }, { type: i2.AdaptRadarAngularCustomEventName }]; }, { name: [{
            type: Input
        }], label: [{
            type: Input
        }], subLabel: [{
            type: Input
        }], requiredLabel: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }], ariaLabelledby: [{
            type: Input
        }], ariaDescribedBy: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }], testID: [{
            type: Input
        }], id: [{
            type: Input
        }], disabled: [{
            type: Input
        }], readonly: [{
            type: Input
        }], autofocus: [{
            type: Input
        }], ariaErrorMessage: [{
            type: Input
        }], onFocus: [{
            type: Output
        }], onBlur: [{
            type: Output
        }] }); })();
//# sourceMappingURL=adapt-rx-component.js.map