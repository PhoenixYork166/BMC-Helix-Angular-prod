import { ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Input, Output, TemplateRef } from '@angular/core';
import { merge } from 'lodash-es';
import { DismissReasons } from '../common/common.enums';
import { AdaptTranslateService } from '../common/i18n/index';
import { AdaptModalConfig } from './modal.config';
import { ActiveModalRef } from './modal.model';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "./modal.model";
import * as i2 from "../common/i18n/index";
import * as i3 from "../common/radar/adapt-radar";
/**
 * The abstract class for represent basics modal functional
 */
export class ModalDirective extends AdaptRadarAngularGenericDirective {
    constructor(_elRef, _componentFactoryResolver, _activeModalRef, _rootActiveModalRef, ts, _adaptRadarService) {
        super(_adaptRadarService, _elRef, AdaptRadarAngularCustomEventName.AdaptModal);
        this._elRef = _elRef;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._activeModalRef = _activeModalRef;
        this._rootActiveModalRef = _rootActiveModalRef;
        this.ts = ts;
        this.modalClassInstance = true; // Needed for LayerService
        this.alerts = [];
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any, @angular-eslint/no-output-on-prefix */
        this.onClose = new EventEmitter();
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any, @angular-eslint/no-output-on-prefix */
        this.onDismiss = new EventEmitter();
        /* eslint-disable-next-line @angular-eslint/no-output-on-prefix */
        this.onCloseAnimationEnd = new EventEmitter();
        this.alertClosed = new EventEmitter();
        this.reason = DismissReasons;
        // ESC click handler
        this.escClickHandler = ($event) => {
            let closeModal;
            if ($event && !$event.defaultPrevented) {
                closeModal = !this.config.isDialog;
                switch (this.config.blockKeyboard) {
                    case true: {
                        closeModal = false;
                        break;
                    }
                    case false: {
                        closeModal = true;
                        break;
                    }
                }
            }
            if (closeModal) {
                this.dismiss(this.reason.ESC);
            }
            return closeModal;
        };
        this.context = {
            close: (result) => {
                this.close(result);
            },
            dismiss: (reason) => {
                this.dismiss(reason);
            },
            openOverModal: () => {
                return;
            },
            closeOverModal: () => {
                return;
            },
            getData: () => {
                return this.config ? this.config.data : undefined;
            },
            openAlert: (alert) => {
                this.openAlert(alert);
            },
            alertClosed: this.alertClosed
        };
        Object.assign(this._activeModalRef, this.context);
        if (_rootActiveModalRef) {
            Object.assign(this._rootActiveModalRef, this.context);
        }
        this.closeText = ts.getCurrentLanguage()['adapt.common.close'];
    }
    ngOnInit() {
        this._activeModalRef.openOverModal = this.context.openOverModal;
        this._activeModalRef.closeOverModal = this.context.closeOverModal;
        const contentContainer = this.getContentPlacementRef();
        // Set 'beforeDismiss' property if it was received
        if (this.config && this.config.beforeDismiss) {
            this._beforeDismiss = this.config.beforeDismiss;
        }
        // Build modal inner content according to config.content type
        if (this.config.content instanceof TemplateRef) {
            contentContainer.createEmbeddedView(this.config.content, this.context);
        }
        else if (typeof this.config.content === 'string') {
            const modalBodyContainer = contentContainer.element.nativeElement.parentNode;
            const newNode = document.createElement('div');
            newNode.classList.add('modal-body');
            newNode.innerText = this.config.content;
            modalBodyContainer.appendChild(newNode);
        }
        else {
            const factory = this._componentFactoryResolver.resolveComponentFactory(this.config.content);
            const contentRef = contentContainer.createComponent(factory);
            contentRef.location.nativeElement.style.display = 'flex';
            contentRef.location.nativeElement.style.flex = '1 1 auto';
            contentRef.location.nativeElement.style.flexDirection = 'column';
            this.contentInstanceRef = contentRef.instance;
        }
    }
    updateConfig(config) {
        this.config = merge(this.config, config);
    }
    openAlert(alert) {
        this.alerts.unshift(alert);
    }
    get title() {
        return this.config.title && this.config.title.trim() ? this.config.title : null;
    }
    get showHeader() {
        if (this.config.showEmptyHeader === false) {
            return false;
        }
        return Boolean(this.title) || this.config.showEmptyHeader || this.configService.showEmptyHeader;
    }
    // TODO: Refactor this if possible
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * Close modal with the result
     */
    close(result) {
        /* eslint-enable @typescript-eslint/no-explicit-any */
        this.onClose.emit(result);
    }
    // TODO: Refactor this if possible
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * Dismiss modal with the reason
     */
    dismiss(reason) {
        /* eslint-enable @typescript-eslint/no-explicit-any */
        if (this._beforeDismiss && !this._beforeDismiss(reason)) {
            return;
        }
        this.onDismiss.emit(reason);
    }
    /**
     * Emit onCloseAnimationEnd event on modal animation end
     */
    modalCloseAnimationEnd(event) {
        /* eslint-enable @typescript-eslint/no-explicit-any */
        if (event.toState === 'void') {
            this.onCloseAnimationEnd.emit();
            const contentViewContainerRef = this.getContentPlacementRef();
            if (contentViewContainerRef) {
                contentViewContainerRef.detach();
                contentViewContainerRef.clear();
            }
        }
    }
}
ModalDirective.ɵfac = function ModalDirective_Factory(t) { return new (t || ModalDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i1.ActiveModalRef), i0.ɵɵdirectiveInject(i1.ActiveModalRef), i0.ɵɵdirectiveInject(i2.AdaptTranslateService), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService)); };
ModalDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ModalDirective, inputs: { id: "id", config: "config", configService: "configService" }, outputs: { onClose: "onClose", onDismiss: "onDismiss", onCloseAnimationEnd: "onCloseAnimationEnd", alertClosed: "alertClosed" }, features: [i0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(ModalDirective, [{
        type: Directive
    }], function () { return [{ type: i0.ElementRef }, { type: i0.ComponentFactoryResolver }, { type: i1.ActiveModalRef }, { type: i1.ActiveModalRef }, { type: i2.AdaptTranslateService }, { type: i3.AdaptRadarAngularService }]; }, { id: [{
            type: Input
        }], config: [{
            type: Input
        }], configService: [{
            type: Input
        }], onClose: [{
            type: Output
        }], onDismiss: [{
            type: Output
        }], onCloseAnimationEnd: [{
            type: Output
        }], alertClosed: [{
            type: Output
        }] }); })();
//# sourceMappingURL=modal.js.map