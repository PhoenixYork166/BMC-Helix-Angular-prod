{"version":3,"file":"positioning.js","sourceRoot":"","sources":["../../../../../libs/adapt-angular/src/common/positioning.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,WAAW;IACtB,QAAQ,CAAC,OAAoB,EAAE,QAAiB,IAAI;QAClD,IAAI,UAAsB,CAAC;QAC3B,IAAI,YAAY,GAAe,EAAC,KAAK,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAC,CAAC;QAE3F,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,UAAU,CAAC,KAAK,OAAO,EAAE;YAClD,UAAU,GAAG,OAAO,CAAC,qBAAqB,EAAE,CAAC;SAC9C;aAAM;YACL,MAAM,cAAc,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YAElD,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;YAEzC,IAAI,cAAc,KAAK,QAAQ,CAAC,eAAe,EAAE;gBAC/C,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC;aACnD;YAED,YAAY,CAAC,GAAG,IAAI,cAAc,CAAC,SAAS,CAAC;YAC7C,YAAY,CAAC,IAAI,IAAI,cAAc,CAAC,UAAU,CAAC;SAChD;QAED,UAAU,CAAC,GAAG,IAAI,YAAY,CAAC,GAAG,CAAC;QACnC,UAAU,CAAC,MAAM,IAAI,YAAY,CAAC,GAAG,CAAC;QACtC,UAAU,CAAC,IAAI,IAAI,YAAY,CAAC,IAAI,CAAC;QACrC,UAAU,CAAC,KAAK,IAAI,YAAY,CAAC,IAAI,CAAC;QAEtC,IAAI,KAAK,EAAE;YACT,UAAU,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YAC5C,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YAClD,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAC9C,UAAU,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;SACjD;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,MAAM,CAAC,OAAoB,EAAE,QAAiB,IAAI;QAChD,MAAM,KAAK,GAAG,OAAO,CAAC,qBAAqB,EAAE,CAAC;QAC9C,MAAM,cAAc,GAAG;YACrB,GAAG,EAAE,MAAM,CAAC,WAAW,GAAG,QAAQ,CAAC,eAAe,CAAC,SAAS;YAC5D,IAAI,EAAE,MAAM,CAAC,WAAW,GAAG,QAAQ,CAAC,eAAe,CAAC,UAAU;SAC/D,CAAC;QAEF,MAAM,QAAQ,GAAG;YACf,MAAM,EAAE,KAAK,CAAC,MAAM,IAAI,OAAO,CAAC,YAAY;YAC5C,KAAK,EAAE,KAAK,CAAC,KAAK,IAAI,OAAO,CAAC,WAAW;YACzC,GAAG,EAAE,KAAK,CAAC,GAAG,GAAG,cAAc,CAAC,GAAG;YACnC,MAAM,EAAE,KAAK,CAAC,MAAM,GAAG,cAAc,CAAC,GAAG;YACzC,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI;YACtC,KAAK,EAAE,KAAK,CAAC,KAAK,GAAG,cAAc,CAAC,IAAI;SACzC,CAAC;QAEF,IAAI,KAAK,EAAE;YACT,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC9C,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YAC5C,QAAQ,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACxC,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC9C,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YAC1C,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;SAC7C;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,gBAAgB,CAAC,WAAwB,EAAE,aAA0B,EAAE,SAAiB,EAAE,YAAsB;QAC9G,MAAM,cAAc,GAAG,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;QAC1G,MAAM,cAAc,GAAG,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC;QACxD,MAAM,WAAW,GAAG,aAAa,CAAC,qBAAqB,EAAE,CAAC;QAC1D,MAAM,gBAAgB,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;QAC1D,MAAM,kBAAkB,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC;QAE/D,MAAM,gBAAgB,GAAe;YACnC,QAAQ,EAAE,WAAW,CAAC,MAAM,IAAI,aAAa,CAAC,YAAY;YAC1D,OAAO,EAAE,WAAW,CAAC,KAAK,IAAI,aAAa,CAAC,WAAW;YACvD,KAAK,EAAE,CAAC;YACR,QAAQ,EAAE,WAAW,CAAC,MAAM,IAAI,aAAa,CAAC,YAAY;YAC1D,MAAM,EAAE,CAAC;YACT,OAAO,EAAE,WAAW,CAAC,KAAK,IAAI,aAAa,CAAC,WAAW;SACxD,CAAC;QAEF,QAAQ,gBAAgB,EAAE;YACxB,KAAK,KAAK;gBACR,gBAAgB,CAAC,GAAG;oBAClB,cAAc,CAAC,GAAG,GAAG,CAAC,aAAa,CAAC,YAAY,GAAG,UAAU,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC,CAAC;gBAC9F,MAAM;YACR,KAAK,QAAQ;gBACX,gBAAgB,CAAC,GAAG,GAAG,cAAc,CAAC,GAAG,GAAG,cAAc,CAAC,MAAM,CAAC;gBAClE,MAAM;YACR,KAAK,MAAM;gBACT,gBAAgB,CAAC,IAAI;oBACnB,cAAc,CAAC,IAAI,GAAG,CAAC,aAAa,CAAC,WAAW,GAAG,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,CAAC;gBAC7F,MAAM;YACR,KAAK,OAAO;gBACV,gBAAgB,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,KAAK,CAAC;gBACnE,MAAM;YACR,KAAK,QAAQ;gBACX,MAAM;SACT;QAED,QAAQ,kBAAkB,EAAE;YAC1B,KAAK,KAAK;gBACR,gBAAgB,CAAC,GAAG,GAAG,cAAc,CAAC,GAAG,CAAC;gBAC1C,MAAM;YACR,KAAK,QAAQ;gBACX,gBAAgB,CAAC,GAAG,GAAG,cAAc,CAAC,GAAG,GAAG,cAAc,CAAC,MAAM,GAAG,aAAa,CAAC,YAAY,CAAC;gBAC/F,MAAM;YACR,KAAK,MAAM;gBACT,gBAAgB,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC;gBAC5C,MAAM;YACR,KAAK,OAAO;gBACV,gBAAgB,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,KAAK,GAAG,aAAa,CAAC,WAAW,CAAC;gBAC/F,MAAM;YACR,KAAK,QAAQ;gBACX,IAAI,gBAAgB,KAAK,KAAK,IAAI,gBAAgB,KAAK,QAAQ,EAAE;oBAC/D,gBAAgB,CAAC,IAAI,GAAG,cAAc,CAAC,IAAI,GAAG,cAAc,CAAC,KAAK,GAAG,CAAC,GAAG,aAAa,CAAC,WAAW,GAAG,CAAC,CAAC;iBACxG;qBAAM,IAAI,gBAAgB,KAAK,QAAQ,EAAE;oBACxC,MAAM;iBACP;qBAAM;oBACL,gBAAgB,CAAC,GAAG,GAAG,cAAc,CAAC,GAAG,GAAG,cAAc,CAAC,MAAM,GAAG,CAAC,GAAG,aAAa,CAAC,YAAY,GAAG,CAAC,CAAC;iBACxG;gBACD,MAAM;SACT;QAED,gBAAgB,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;QACxD,gBAAgB,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QAC9D,gBAAgB,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC1D,gBAAgB,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAE5D,OAAO,gBAAgB,CAAC;IAC1B,CAAC;IAED,mGAAmG;IACnG,sBAAsB,CAAC,WAAwB,EAAE,aAA0B;QACzE,MAAM,mBAAmB,GAAa,EAAE,CAAC;QACzC,MAAM,kBAAkB,GAAG,WAAW,CAAC,qBAAqB,EAAE,CAAC;QAC/D,MAAM,YAAY,GAAG,gBAAgB,CAAC,aAAa,CAAC,CAAC;QACrD,MAAM,IAAI,GAAG,QAAQ,CAAC,eAAe,CAAC;QACtC,MAAM,YAAY,GAAG,MAAM,CAAC,WAAW,IAAI,IAAI,CAAC,YAAY,CAAC;QAC7D,MAAM,WAAW,GAAG,MAAM,CAAC,UAAU,IAAI,IAAI,CAAC,WAAW,CAAC;QAC1D,MAAM,2BAA2B,GAAG,kBAAkB,CAAC,IAAI,GAAG,kBAAkB,CAAC,KAAK,GAAG,CAAC,CAAC;QAC3F,MAAM,2BAA2B,GAAG,kBAAkB,CAAC,GAAG,GAAG,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC;QAE3F,0DAA0D;QAC1D,gCAAgC;QAChC,sEAAsE;QACtE,MAAM,oBAAoB,GAAG;YAC3B,KAAK,EAAE,QAAQ,CAAC,YAAY,CAAC,KAAK,EAAE,EAAE,CAAC;YACvC,MAAM,EAAE,QAAQ,CAAC,YAAY,CAAC,MAAM,EAAE,EAAE,CAAC;YACzC,IAAI,EAAE,QAAQ,CAAC,YAAY,CAAC,IAAI,EAAE,EAAE,CAAC;YACrC,KAAK,EAAE,QAAQ,CAAC,YAAY,CAAC,KAAK,EAAE,EAAE,CAAC;YACvC,GAAG,EAAE,QAAQ,CAAC,YAAY,CAAC,GAAG,EAAE,EAAE,CAAC;YACnC,MAAM,EAAE,QAAQ,CAAC,YAAY,CAAC,MAAM,EAAE,EAAE,CAAC;SAC1C,CAAC;QAEF,8GAA8G;QAC9G,kBAAkB;QAClB,IAAI,oBAAoB,CAAC,KAAK,GAAG,kBAAkB,CAAC,IAAI,EAAE;YACxD,sBAAsB;YACtB,IAAI,2BAA2B,GAAG,oBAAoB,CAAC,MAAM,GAAG,CAAC;gBAC/D,YAAY,GAAG,2BAA2B,GAAG,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC9E,mBAAmB,CAAC,MAAM,CAAC,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;aACnE;YACD,qCAAqC;YACrC,IAAI,CAAC,iCAAiC,CAAC,kBAAkB,EAAE,oBAAoB,EAAE,MAAM,EAAE,mBAAmB,CAAC,CAAC;SAC/G;QAED,2CAA2C;QAC3C,IAAI,oBAAoB,CAAC,MAAM,GAAG,kBAAkB,CAAC,GAAG,EAAE;YACxD,IAAI,2BAA2B,GAAG,oBAAoB,CAAC,KAAK,GAAG,CAAC;gBAC9D,WAAW,GAAG,2BAA2B,GAAG,oBAAoB,CAAC,KAAK,GAAG,CAAC,EAAE;gBAC5E,mBAAmB,CAAC,MAAM,CAAC,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;aAClE;YACD,IAAI,CAAC,iCAAiC,CAAC,kBAAkB,EAAE,oBAAoB,EAAE,KAAK,EAAE,mBAAmB,CAAC,CAAC;SAC9G;QAED,8GAA8G;QAC9G,kBAAkB;QAClB,IAAI,WAAW,GAAG,kBAAkB,CAAC,KAAK,GAAG,oBAAoB,CAAC,KAAK,EAAE;YACvE,uBAAuB;YACvB,IAAI,2BAA2B,GAAG,oBAAoB,CAAC,MAAM,GAAG,CAAC;gBAC/D,YAAY,GAAG,2BAA2B,GAAG,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC9E,mBAAmB,CAAC,MAAM,CAAC,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC;aACpE;YACD,uCAAuC;YACvC,IAAI,CAAC,iCAAiC,CAAC,kBAAkB,EAAE,oBAAoB,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAC;SAChH;QAED,gGAAgG;QAChG,IAAI,YAAY,GAAG,kBAAkB,CAAC,MAAM,GAAG,oBAAoB,CAAC,MAAM,EAAE;YAC1E,IAAI,2BAA2B,GAAG,oBAAoB,CAAC,KAAK,GAAG,CAAC;gBAC9D,WAAW,GAAG,2BAA2B,GAAG,oBAAoB,CAAC,KAAK,GAAG,CAAC,EAAE;gBAC5E,mBAAmB,CAAC,MAAM,CAAC,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;aACrE;YACD,IAAI,CAAC,iCAAiC,CAAC,kBAAkB,EAAE,oBAAoB,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;SACjH;QAED,OAAO,mBAAmB,CAAC;IAC7B,CAAC;IAEO,YAAY,CAAC,OAAoB;QACvC,OAAO,MAAM,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;IAC1C,CAAC;IAEO,QAAQ,CAAC,OAAoB,EAAE,IAAY;QACjD,OAAO,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC;IAC1C,CAAC;IAEO,kBAAkB,CAAC,OAAoB;QAC7C,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,UAAU,CAAC,IAAI,QAAQ,CAAC,KAAK,QAAQ,CAAC;IACvE,CAAC;IAEO,YAAY,CAAC,OAAoB;QACvC,IAAI,cAAc,GAAgB,OAAO,CAAC,YAAY,IAAI,QAAQ,CAAC,eAAe,CAAC;QAEnF,OAAO,cAAc,IAAI,cAAc,KAAK,QAAQ,CAAC,eAAe,IAAI,IAAI,CAAC,kBAAkB,CAAC,cAAc,CAAC,EAAE;YAC/G,cAAc,GAAgB,cAAc,CAAC,YAAY,CAAC;SAC3D;QAED,OAAO,cAAc,IAAI,QAAQ,CAAC,eAAe,CAAC;IACpD,CAAC;IAED;;;;OAIG;IACK,iCAAiC,CACvC,kBAA8B,EAAE,oBAAgC,EAAE,gBAAwB,EAC1F,qBAA+B;QAC/B,MAAM,IAAI,GAAG,QAAQ,CAAC,eAAe,CAAC;QAEtC,wBAAwB;QACxB,IAAI,oBAAoB,CAAC,MAAM,IAAI,kBAAkB,CAAC,MAAM,EAAE;YAC5D,qBAAqB,CAAC,MAAM,CAAC,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,gBAAgB,GAAG,SAAS,CAAC,CAAC;SAC7F;QAED,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,kBAAkB,CAAC,GAAG,IAAI,oBAAoB,CAAC,MAAM,EAAE;YACrG,qBAAqB,CAAC,MAAM,CAAC,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,gBAAgB,GAAG,MAAM,CAAC,CAAC;SAC1F;IACH,CAAC;IAED;;;;OAIG;IACK,iCAAiC,CACvC,kBAA8B,EAAE,oBAAgC,EAAE,gBAAwB,EAC1F,qBAA+B;QAC/B,MAAM,IAAI,GAAG,QAAQ,CAAC,eAAe,CAAC;QAEtC,wBAAwB;QACxB,IAAI,CAAC,MAAM,CAAC,UAAU,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,kBAAkB,CAAC,IAAI,IAAI,oBAAoB,CAAC,KAAK,EAAE;YACnG,qBAAqB,CAAC,MAAM,CAAC,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,gBAAgB,GAAG,OAAO,CAAC,CAAC;SAC3F;QAED,IAAI,oBAAoB,CAAC,KAAK,IAAI,kBAAkB,CAAC,KAAK,EAAE;YAC1D,qBAAqB,CAAC,MAAM,CAAC,qBAAqB,CAAC,MAAM,EAAE,CAAC,EAAE,gBAAgB,GAAG,QAAQ,CAAC,CAAC;SAC5F;IACH,CAAC;CACF;AAED,MAAM,eAAe,GAAG,IAAI,WAAW,EAAE,CAAC;AAE1C;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,gBAAgB,CAAC,WAAwB,EACxB,aAA0B,EAC1B,SAA8C,EAC9C,YAAsB,EACtB,iBAA6B,EAC7B,gBAA4B;IAC3D,MAAM,aAAa,GAAgB,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,SAAsB,CAAC,CAAC;IAExG,+CAA+C;IAC/C,IAAI,SAAS,GAAG,aAAa,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,MAAM,CAAC,CAAC;IAC/D,MAAM,OAAO,GAAG,SAAS,IAAI,CAAC,CAAC;IAE/B,IAAI,OAAO,EAAE;QACX;YACE,aAAa;YACb,cAAc;YACd,QAAQ;YACR,UAAU;YACV,WAAW;YACX,KAAK;YACL,OAAO;YACP,cAAc;YACd,MAAM;YACN,aAAa;YACb,UAAU;YACV,WAAW;YACX,QAAQ;SACT,CAAC,OAAO,CAAC,CAAC,mBAAmB,EAAE,EAAE;YAChC,IAAI,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;gBACnF,aAAa,CAAC,MAAM,CAAC,SAAS,EAAE,EAAE,CAAC,EAAE,mBAAgC,CAAC,CAAC;aACxE;QACH,CAAC,CAAC,CAAC;KACJ;IAED,gCAAgC;IAChC,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IAAI,OAAO,GAAG,CAAC,CAAC;IAChB,IAAI,gBAA2B,CAAC;IAChC,2BAA2B;IAC3B,MAAM,mBAAmB,GAAG,eAAe,CAAC,sBAAsB,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;IAE/F,yCAAyC;IACzC,KAAK,MAAM,EAAC,IAAI,EAAE,KAAK,EAAC,IAAI,aAAa,CAAC,aAAa,CAAC,EAAE;QACxD,MAAM,QAAQ,GAAG,mBAAmB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,IAAI,CAAC,IAAI,IAAI,CAAC;QACvE,MAAM,UAAU,GAAG,aAAa,CAAC,MAAM,KAAK,KAAK,GAAG,CAAC,CAAC;QAEtD,+GAA+G;QAC/G,wBAAwB;QACxB,IAAI,QAAQ,IAAI,UAAU,EAAE;YAC1B,IAAI,CAAC,QAAQ,IAAI,UAAU,IAAI,OAAO,IAAI,iBAAiB,IAAI,iBAAiB,KAAK,MAAM,EAAE;gBAC3F,gBAAgB,GAAG,iBAAiB,CAAC;aACtC;iBAAM;gBACL,gBAAgB,GAAG,gBAAgB,IAAI,IAAI,CAAC;aAC7C;YAGD,MAAM,GAAG,GAAG,eAAe,CAAC,gBAAgB,CAAC,WAAW,EAAE,aAAa,EAAE,gBAAgB,EAAE,YAAY,CAAC,CAAC;YAEzG,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC;YACjB,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC;YACnB,MAAM;SACP;KACF;IACD,aAAa,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,MAAM,IAAI,CAAC;IACxC,aAAa,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,OAAO,IAAI,CAAC;IAE1C,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AAED,6CAA6C;AAC7C,SAAS,aAAa,CAAI,CAAM;IAC9B,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,CAAC;AACjD,CAAC;AASD,MAAM,OAAgB,gBAAgB;;AACpB,oBAAG,GAAW,KAAK,CAAC;AACpB,sBAAK,GAAW,OAAO,CAAC;AACxB,uBAAM,GAAW,QAAQ,CAAC;AAC1B,qBAAI,GAAW,MAAM,CAAC;AACtB,qBAAI,GAAW,MAAM,CAAC;AAGxC,MAAM,CAAC,MAAM,yBAAyB,GAAG,CAAC,WAAwB,EAAE,aAA0B,EAAY,EAAE;IAC1G,OAAO,eAAe,CAAC,sBAAsB,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;AAC5E,CAAC,CAAC;AAEF,kCAAkC;AAClC,iEAAiE;AACjE,MAAM,UAAU,gBAAgB,CAAC,SAAc;IAC7C,kCAAkC;IAClC,iEAAiE;IACjE,MAAM,GAAG,GAAG,UAAU,EAAO;QAC3B,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAErF,OAAO,EAAE,CAAC;IACZ,CAAC,CAAC;IAEF,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;QAC5B,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;KAC3C;SAAM;QACL,OAAO,GAAG,CAAC,SAAS,CAAC,CAAC;KACvB;AACH,CAAC","sourcesContent":["export class Positioning {\n  position(element: HTMLElement, round: boolean = true): ClientRect {\n    let elPosition: ClientRect;\n    let parentOffset: ClientRect = {width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0};\n\n    if (this.getStyle(element, 'position') === 'fixed') {\n      elPosition = element.getBoundingClientRect();\n    } else {\n      const offsetParentEl = this.offsetParent(element);\n\n      elPosition = this.offset(element, false);\n\n      if (offsetParentEl !== document.documentElement) {\n        parentOffset = this.offset(offsetParentEl, false);\n      }\n\n      parentOffset.top += offsetParentEl.clientTop;\n      parentOffset.left += offsetParentEl.clientLeft;\n    }\n\n    elPosition.top -= parentOffset.top;\n    elPosition.bottom -= parentOffset.top;\n    elPosition.left -= parentOffset.left;\n    elPosition.right -= parentOffset.left;\n\n    if (round) {\n      elPosition.top = Math.round(elPosition.top);\n      elPosition.bottom = Math.round(elPosition.bottom);\n      elPosition.left = Math.round(elPosition.left);\n      elPosition.right = Math.round(elPosition.right);\n    }\n\n    return elPosition;\n  }\n\n  offset(element: HTMLElement, round: boolean = true): ClientRect {\n    const elBcr = element.getBoundingClientRect();\n    const viewportOffset = {\n      top: window.pageYOffset - document.documentElement.clientTop,\n      left: window.pageXOffset - document.documentElement.clientLeft\n    };\n\n    const elOffset = {\n      height: elBcr.height || element.offsetHeight,\n      width: elBcr.width || element.offsetWidth,\n      top: elBcr.top + viewportOffset.top,\n      bottom: elBcr.bottom + viewportOffset.top,\n      left: elBcr.left + viewportOffset.left,\n      right: elBcr.right + viewportOffset.left\n    };\n\n    if (round) {\n      elOffset.height = Math.round(elOffset.height);\n      elOffset.width = Math.round(elOffset.width);\n      elOffset.top = Math.round(elOffset.top);\n      elOffset.bottom = Math.round(elOffset.bottom);\n      elOffset.left = Math.round(elOffset.left);\n      elOffset.right = Math.round(elOffset.right);\n    }\n\n    return elOffset;\n  }\n\n  positionElements(hostElement: HTMLElement, targetElement: HTMLElement, placement: string, appendToBody?: boolean): ClientRect {\n    const hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n    const targetElStyles = this.getAllStyles(targetElement);\n    const targetElBCR = targetElement.getBoundingClientRect();\n    const placementPrimary = placement.split('-')[0] || 'top';\n    const placementSecondary = placement.split('-')[1] || 'center';\n\n    const targetElPosition: ClientRect = {\n      'height': targetElBCR.height || targetElement.offsetHeight,\n      'width': targetElBCR.width || targetElement.offsetWidth,\n      'top': 0,\n      'bottom': targetElBCR.height || targetElement.offsetHeight,\n      'left': 0,\n      'right': targetElBCR.width || targetElement.offsetWidth\n    };\n\n    switch (placementPrimary) {\n      case 'top':\n        targetElPosition.top =\n          hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));\n        break;\n      case 'bottom':\n        targetElPosition.top = hostElPosition.top + hostElPosition.height;\n        break;\n      case 'left':\n        targetElPosition.left =\n          hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));\n        break;\n      case 'right':\n        targetElPosition.left = hostElPosition.left + hostElPosition.width;\n        break;\n      case 'mobile':\n        break;\n    }\n\n    switch (placementSecondary) {\n      case 'top':\n        targetElPosition.top = hostElPosition.top;\n        break;\n      case 'bottom':\n        targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;\n        break;\n      case 'left':\n        targetElPosition.left = hostElPosition.left;\n        break;\n      case 'right':\n        targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;\n        break;\n      case 'center':\n        if (placementPrimary === 'top' || placementPrimary === 'bottom') {\n          targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;\n        } else if (placementPrimary === 'mobile') {\n          break;\n        } else {\n          targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;\n        }\n        break;\n    }\n\n    targetElPosition.top = Math.round(targetElPosition.top);\n    targetElPosition.bottom = Math.round(targetElPosition.bottom);\n    targetElPosition.left = Math.round(targetElPosition.left);\n    targetElPosition.right = Math.round(targetElPosition.right);\n\n    return targetElPosition;\n  }\n\n  // get the available placements of the target element in the viewport depending on the host element\n  getAvailablePlacements(hostElement: HTMLElement, targetElement: HTMLElement): string[] {\n    const availablePlacements: string[] = [];\n    const hostElemClientRect = hostElement.getBoundingClientRect();\n    const targetElemCS = getComputedStyle(targetElement);\n    const html = document.documentElement;\n    const windowHeight = window.innerHeight || html.clientHeight;\n    const windowWidth = window.innerWidth || html.clientWidth;\n    const hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;\n    const hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2;\n\n    // Replace BoundingClientRect values to ComputedStyle ones\n    // Need to fix angular animation\n    // const targetElemClientRect = targetElement.getBoundingClientRect();\n    const targetElemClientRect = {\n      width: parseInt(targetElemCS.width, 10),\n      height: parseInt(targetElemCS.height, 10),\n      left: parseInt(targetElemCS.left, 10),\n      right: parseInt(targetElemCS.right, 10),\n      top: parseInt(targetElemCS.top, 10),\n      bottom: parseInt(targetElemCS.bottom, 10),\n    };\n\n    // left: check if target width can be placed between host left and viewport start and also height of target is\n    // inside viewport\n    if (targetElemClientRect.width < hostElemClientRect.left) {\n      // check for left only\n      if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n        windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'left');\n      }\n      // check for left-top and left-bottom\n      this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);\n    }\n\n    // top: target height is less than host top\n    if (targetElemClientRect.height < hostElemClientRect.top) {\n      if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n        windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'top');\n      }\n      this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);\n    }\n\n    // right: check if target width can be placed between host right and viewport end and also height of target is\n    // inside viewport\n    if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {\n      // check for right only\n      if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n        windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'right');\n      }\n      // check for right-top and right-bottom\n      this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);\n    }\n\n    // bottom: check if there is enough space between host bottom and viewport end for target height\n    if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {\n      if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n        windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'bottom');\n      }\n      this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);\n    }\n\n    return availablePlacements;\n  }\n\n  private getAllStyles(element: HTMLElement): CSSStyleDeclaration {\n    return window.getComputedStyle(element);\n  }\n\n  private getStyle(element: HTMLElement, prop: string): string {\n    return this.getAllStyles(element)[prop];\n  }\n\n  private isStaticPositioned(element: HTMLElement): boolean {\n    return (this.getStyle(element, 'position') || 'static') === 'static';\n  }\n\n  private offsetParent(element: HTMLElement): HTMLElement {\n    let offsetParentEl = <HTMLElement>element.offsetParent || document.documentElement;\n\n    while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n      offsetParentEl = <HTMLElement>offsetParentEl.offsetParent;\n    }\n\n    return offsetParentEl || document.documentElement;\n  }\n\n  /**\n   * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom\n   * primaryplacement: left|right\n   * availablePlacementArr: array in which available placements to be set\n   */\n  private setSecondaryPlacementForLeftRight(\n    hostElemClientRect: ClientRect, targetElemClientRect: ClientRect, primaryPlacement: string,\n    availablePlacementArr: string[]): void {\n    const html = document.documentElement;\n\n    // check for left-bottom\n    if (targetElemClientRect.height <= hostElemClientRect.bottom) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');\n    }\n\n    if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');\n    }\n  }\n\n  /**\n   * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right\n   * primaryplacement: top|bottom\n   * availablePlacementArr: array in which available placements to be set\n   */\n  private setSecondaryPlacementForTopBottom(\n    hostElemClientRect: ClientRect, targetElemClientRect: ClientRect, primaryPlacement: string,\n    availablePlacementArr: string[]): void {\n    const html = document.documentElement;\n\n    // check for left-bottom\n    if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');\n    }\n\n    if (targetElemClientRect.width <= hostElemClientRect.right) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');\n    }\n  }\n}\n\nconst positionService = new Positioning();\n\n/**\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\n * Returns the applied placement.\n * In case of auto placement, placements are selected in order\n *   'top', 'bottom', 'left', 'right',\n *   'top-left', 'top-right',\n *   'bottom-left', 'bottom-right',\n *   'left-top', 'left-bottom',\n *   'right-top', 'right-bottom'.\n * `fallbackPlacement` param: if there are no available places and the `placement` param contains `auto`\n * position, then will be used this placement\n * `currentPlacement` param: when the dd has already applied placement and there are no available\n * places, then will be used this placement\n */\nexport function positionElements(hostElement: HTMLElement,\n                                 targetElement: HTMLElement,\n                                 placement: string | Placement | PlacementArray,\n                                 appendToBody?: boolean,\n                                 fallbackPlacement?: Placement,\n                                 currentPlacement?: Placement): Placement {\n  const placementVals: Placement[] = Array.isArray(placement) ? [...placement] : [placement as Placement];\n\n  // replace auto placement with other placements\n  let autoIndex = placementVals.findIndex(val => val === 'auto');\n  const hasAuto = autoIndex >= 0;\n\n  if (hasAuto) {\n    [\n      'bottom-left',\n      'bottom-right',\n      'bottom',\n      'top-left',\n      'top-right',\n      'top',\n      'right',\n      'right-bottom',\n      'left',\n      'left-bottom',\n      'left-top',\n      'right-top',\n      'mobile'\n    ].forEach((predefinedPlacement) => {\n      if (placementVals.find(val => val.search('^' + predefinedPlacement) !== -1) == null) {\n        placementVals.splice(autoIndex++, 1, predefinedPlacement as Placement);\n      }\n    });\n  }\n\n  // coordinates where to position\n  let topVal = 0;\n  let leftVal = 0;\n  let appliedPlacement: Placement;\n  // get available placements\n  const availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement);\n\n  // iterate over all the passed placements\n  for (const {item, index} of toItemIndexes(placementVals)) {\n    const hasPlace = availablePlacements.find(val => val === item) != null;\n    const isLastItem = placementVals.length === index + 1;\n\n    // check if passed placement is present in the available placement or otherwise apply the last placement in the\n    // passed placement list\n    if (hasPlace || isLastItem) {\n      if (!hasPlace && isLastItem && hasAuto && fallbackPlacement && fallbackPlacement !== 'auto') {\n        appliedPlacement = fallbackPlacement;\n      } else {\n        appliedPlacement = currentPlacement || item;\n      }\n\n\n      const pos = positionService.positionElements(hostElement, targetElement, appliedPlacement, appendToBody);\n\n      topVal = pos.top;\n      leftVal = pos.left;\n      break;\n    }\n  }\n  targetElement.style.top = `${topVal}px`;\n  targetElement.style.left = `${leftVal}px`;\n\n  return appliedPlacement;\n}\n\n// function to get index and item of an array\nfunction toItemIndexes<T>(a: T[]): { item: T; index: number }[] {\n  return a.map((item, index) => ({item, index}));\n}\n\nexport type Placement = 'auto' | 'top' | 'bottom' | 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' |\n  'bottom-right' | 'left-top' | 'left-bottom' | 'right-top' | 'right-bottom' | 'mobile';\n\nexport type PlacementArray = Placement | Placement[];\n\nexport type ToastPlacement = 'top-right' | 'top-left' | 'top-center';\n\nexport abstract class TooltipPlacement {\n  static readonly Top: string = 'top';\n  static readonly Right: string = 'right';\n  static readonly Bottom: string = 'bottom';\n  static readonly Left: string = 'left';\n  static readonly Auto: string = 'auto';\n}\n\nexport const availableTargetPlacements = (hostElement: HTMLElement, targetElement: HTMLElement): string[] => {\n  return positionService.getAvailablePlacements(hostElement, targetElement);\n};\n\n// TODO: Refactor this if possible\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport function convertPlacement(placement: any): any {\n  // TODO: Refactor this if possible\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  const rep = function (el: any): any {\n    el = el.includes('left') ? el.replace('left', 'right') : el.replace('right', 'left');\n\n    return el;\n  };\n\n  if (Array.isArray(placement)) {\n    return placement.map(place => rep(place));\n  } else {\n    return rep(placement);\n  }\n}\n"]}