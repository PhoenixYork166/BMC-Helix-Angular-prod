{"version":3,"file":"flexible-connected-position-strategy.js","sourceRoot":"","sources":["../../../../../../../libs/adapt-angular/src/common/overlay/position/flexible-connected-position-strategy.ts"],"names":[],"mappings":"AAEA,OAAO,EACL,iCAAiC,GAGlC,MAAM,sBAAsB,CAAC;AAG9B,MAAM,OAAO,sCAAuC,SAAQ,iCAAiC;IAC3F,6DAA6D;IAC7D,MAAM,CAAC,mCAAmC,CAAC,GAAe,EAAE,KAAY,EAAE,QAAoB;QAC5F,qBAAqB;QACrB,0DAA0D;QAC1D,0DAA0D;QAC1D,EAAE;QACF,8GAA8G;QAC9G,6EAA6E;QAC7E,yGAAyG;QACzG,2GAA2G;QAC3G,mEAAmE;QACnE,EAAE;QACF,6EAA6E;QAC7E,wGAAwG;QAExG,OAAO,KAAK,CAAC;IACf,CAAC;IAED,YAAY,WAAoD,EACpD,cAA6B,EAC7B,SAAmB,EACnB,SAAmB,EACnB,iBAAmC;QAC7C,KAAK,CAAC,WAAW,EAAE,cAAc,EAAE,SAAS,EAAE,SAAS,EAAE,iBAAiB,CAAC,CAAC;QAE5E,MAAM,KAAK,GAAG,IAEb,CAAC;QAEF,KAAK,CAAC,6BAA6B,GAAG,sCAAsC,CAAC,mCAAmC,CAAC;IACnH,CAAC;CACF","sourcesContent":["import {ViewportRuler} from '@angular/cdk/scrolling';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  FlexibleConnectedPositionStrategy,\n  FlexibleConnectedPositionStrategyOrigin,\n  OverlayContainer,\n} from '@angular/cdk/overlay';\nimport {Point} from '@angular/cdk/drag-drop';\n\nexport class AdaptFlexibleConnectedPositionStrategy extends FlexibleConnectedPositionStrategy {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static PatchedCanFitWithFlexibleDimensions(fit: OverlayFit, point: Point, viewport: ClientRect): boolean {\n    // Related to issues:\n    // https://github.bmc.com/bmc-ux/adapt-angular/issues/7176\n    // https://github.bmc.com/bmc-ux/adapt-angular/issues/7446\n    //\n    // _canFitWithFlexibleDimensions is being invoked to check if there's enough space for the minimum dimensions.\n    // If so, the checking position is been adding to the flexiblePositions list.\n    // After that, if flexiblePositions have some items, there is a check for the best position and apply it.\n    // But for the case when the origin is out of the viewport, the check for the best position returns 'null',\n    // and the attempt to update the overlay position throws the error.\n    //\n    // If avoid the _canFitWithFlexibleDimensions check and force return 'false',\n    // the flexiblePositions stays empty, so the logic goes to fallbackPositions and applies the latest one.\n\n    return false;\n  }\n\n  constructor(connectedTo: FlexibleConnectedPositionStrategyOrigin,\n              _viewportRuler: ViewportRuler,\n              _document: Document,\n              _platform: Platform,\n              _overlayContainer: OverlayContainer) {\n    super(connectedTo, _viewportRuler, _document, _platform, _overlayContainer);\n\n    const _this = this as unknown as {\n      _canFitWithFlexibleDimensions(fit: OverlayFit, point: Point, viewport: ClientRect): boolean;\n    };\n\n    _this._canFitWithFlexibleDimensions = AdaptFlexibleConnectedPositionStrategy.PatchedCanFitWithFlexibleDimensions;\n  }\n}\n\n/** Record of measurements for how an overlay (at a given position) fits into the viewport. */\ninterface OverlayFit {\n  /** Whether the overlay fits completely in the viewport. */\n  isCompletelyWithinViewport: boolean;\n\n  /** Whether the overlay fits in the viewport on the y-axis. */\n  fitsInViewportVertically: boolean;\n\n  /** Whether the overlay fits in the viewport on the x-axis. */\n  fitsInViewportHorizontally: boolean;\n\n  /** The total visible area (in px^2) of the overlay inside the viewport. */\n  visibleArea: number;\n}\n"]}