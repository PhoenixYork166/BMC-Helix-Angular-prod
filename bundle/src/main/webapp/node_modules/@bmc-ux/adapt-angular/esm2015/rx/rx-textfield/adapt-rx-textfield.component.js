import { ChangeDetectorRef, Component, ElementRef, Input, Optional, Self, ViewChild, ViewEncapsulation } from '@angular/core';
import { NgControl } from '@angular/forms';
import { isString } from 'lodash-es';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularCustomEventType, AdaptRadarAngularService } from '../../common/radar/adapt-radar';
import { AdaptRxFeedbackComponent, AdaptRxFormControlDirective } from '../form-control/index';
import { AdaptRxTextfieldConfigService } from './adapt-rx-textfield-config.service';
import { AdaptTranslateService } from '../../common/i18n/index';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "./adapt-rx-textfield-config.service";
import * as i3 from "../../common/radar/adapt-radar";
import * as i4 from "../../common/i18n/index";
import * as i5 from "../form-control/rx-control-label/adapt-rx-control-label.component";
import * as i6 from "@angular/common";
import * as i7 from "../form-control/rx-feedback/adapt-rx-feedback.component";
import * as i8 from "../../badge/badge.component";
const _c0 = ["inputRef"];
const _c1 = ["adaptRxFeedbackRef"];
function AdaptRxTextfieldComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 9);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 10);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r0.prepend);
} }
function AdaptRxTextfieldComponent_div_15_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 11);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "adapt-badge", 12);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵadvance(2);
    i0.ɵɵproperty("adaptRadarDisableEventSending", true)("variant", ctx_r2.fieldTagType);
    i0.ɵɵadvance(1);
    i0.ɵɵtextInterpolate(ctx_r2.fieldTagText);
} }
function AdaptRxTextfieldComponent_div_17_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 13);
    i0.ɵɵtext(1, "\n      ");
    i0.ɵɵelementStart(2, "span", 10);
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵtext(4, "\n    ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = i0.ɵɵnextContext();
    i0.ɵɵadvance(3);
    i0.ɵɵtextInterpolate(ctx_r3.append);
} }
const _c2 = [[["", "input-start-content", ""]], [["", "input-end-content", ""]]];
const _c3 = ["[input-start-content]", "[input-end-content]"];
export class AdaptRxTextfieldComponent extends AdaptRxFormControlDirective {
    constructor(ngControl, adaptRxTextfieldService, _changeDetectorRef, _adaptRadarService, ts, _elem) {
        super(ngControl, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRxTextfield, _changeDetectorRef);
        this.ts = ts;
        this.controlName = 'textfield';
        this.analyticsComponentName = AdaptRadarAngularCustomEventName;
        /**
         * Control size
         * @docs-default default
         */
        this.size = 'default';
        /**
         * Custom tag type : 'primary', 'info', 'success', 'warning', 'danger', 'active', 'secondary'
         * @docs-default primary
         * @since v10.1.0
         */
        this.fieldTagType = 'primary';
        /**
         * Show success appearance when no errors
         * @docs-default false
         */
        this.showValidState = false;
        /**
         * Show success icon when no errors
         * @docs-default false
         */
        this.showValidStateIcon = false;
        /**
         * Show error icon when errors
         * @docs-default false
         */
        this.showInvalidStateIcon = false;
        /**
         * Use disable styles for readonly state
         * @docs-default false
         */
        this.disabledStyleForReadonlyState = false;
        // Set default params from the config service
        this.size = adaptRxTextfieldService.size;
        this.showValidState = adaptRxTextfieldService.showValidState;
        this.showValidStateIcon = adaptRxTextfieldService.showValidStateIcon;
        this.showInvalidStateIcon = adaptRxTextfieldService.showInvalidStateIcon;
        this.disabledStyleForReadonlyState = adaptRxTextfieldService.disabledStyleForReadonlyState;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        if (value !== this._value) {
            this._value = value;
            this._onChange(this._value);
            this.stateChanges$.next();
        }
    }
    /**
     * Returns input type value according to [isPassword] value
     */
    get getInputTypeValue() {
        return this.isPassword ? 'password' : 'text';
    }
    /**
     * Returns autocomplete attribute value for native element
     */
    get getAutocompleteValue() {
        return isString(this.autocomplete) ? this.autocomplete : (this.autocomplete ? 'on' : 'off');
    }
    /**
     * Check if the control has UI error state
     */
    get hasDangerState() {
        return this.adaptRxFeedbackRef.hasUIErrorState;
    }
    /**
     * Check if component should have success appearance if no errors
     */
    get hasSuccessState() {
        return this.showValidState && this.ngControl.touched && !this.ngControl.errors;
    }
    /**
     * Check if the invalid state icon should be displayed when has danger state
     */
    get hasDangerStateIcon() {
        return this.hasDangerState && this.showInvalidStateIcon;
    }
    /**
     * Check if the valid state icon should be displayed when has success state
     */
    get hasSuccessStateIcon() {
        return this.hasSuccessState && this.showValidStateIcon;
    }
    /**
     * Input element (input) event handler
     */
    inputValueChange() {
        this._checkNativeValue();
    }
    /**
     * Implementation of base abstract member
     */
    writeValue(value) {
        if (value !== undefined) {
            this._value = value;
            this._previousNativeValue = undefined;
        }
    }
    /**
     * Extend parent method
     */
    blurHandler(event) {
        var _a;
        super.blurHandler(event);
        this._onTouched();
        this._adaptRadarService.sendCustomEventForAllProviders(AdaptRadarAngularCustomEventName.AdaptRxTextfield, {
            GroupName: this.adaptRadarGroupName,
            EventType: AdaptRadarAngularCustomEventType.Blur,
            Label: this.label,
            Subtext: !!this.subLabel,
            TextEntered: !!this.value,
            CharCount: (_a = this.value) === null || _a === void 0 ? void 0 : _a.length,
            Badge: !!this.fieldTagText,
            BadgeText: this.fieldTagText || null,
            Hinted: !!this.tooltip,
            Required: this.required,
            Disabled: this.disabled,
            ReadOnly: this.readonly,
            FieldSize: this.size,
            // DynamicEntry: false
        });
    }
    /**
     * Extend parent method
     */
    focusHandler(event) {
        var _a;
        super.focusHandler(event);
        this._adaptRadarService.sendCustomEventForAllProviders(AdaptRadarAngularCustomEventName.AdaptRxTextfield, {
            GroupName: this.adaptRadarGroupName,
            EventType: AdaptRadarAngularCustomEventType.Focus,
            Label: this.label,
            Subtext: !!this.subLabel,
            TextEntered: !!this.value,
            CharCount: (_a = this.value) === null || _a === void 0 ? void 0 : _a.length,
            Badge: !!this.fieldTagText,
            BadgeText: this.fieldTagText || null,
            Hinted: !!this.tooltip,
            Required: this.required,
            Disabled: this.disabled,
            ReadOnly: this.readonly,
            FieldSize: this.size,
            // DynamicEntry: false
        });
    }
    /**
     * Implementation from the base class
     * Focus the native element if [autofocus] == true
     */
    _focusNativeElement() {
        this.inputRef.nativeElement.focus();
    }
    /**
     * Check if the native element value was changed and propagate change
     */
    _checkNativeValue() {
        const newValue = this.inputRef.nativeElement.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.value = newValue;
        }
    }
}
AdaptRxTextfieldComponent.ɵfac = function AdaptRxTextfieldComponent_Factory(t) { return new (t || AdaptRxTextfieldComponent)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i2.AdaptRxTextfieldConfigService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i4.AdaptTranslateService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRxTextfieldComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxTextfieldComponent, selectors: [["adapt-rx-textfield"]], viewQuery: function AdaptRxTextfieldComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 7);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.inputRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptRxFeedbackRef = _t.first);
    } }, inputs: { prepend: "prepend", append: "append", isPassword: "isPassword", autocomplete: "autocomplete", placeholder: "placeholder", size: "size", fieldTagText: "fieldTagText", fieldTagType: "fieldTagType", showValidState: "showValidState", showValidStateIcon: "showValidStateIcon", showInvalidStateIcon: "showInvalidStateIcon", validStateMessage: "validStateMessage", disabledStyleForReadonlyState: "disabledStyleForReadonlyState" }, features: [i0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c3, decls: 24, vars: 61, consts: [[3, "for", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"], [1, "input-group"], ["class", "input-group-prepend", 4, "ngIf"], [1, "form-control", "rx-form-control", 3, "id", "value", "required", "disabled", "readOnly", "autofocus", "autocomplete", "input", "focus", "blur"], ["inputRef", ""], ["class", "input-group-custom-tag", 4, "ngIf"], ["class", "input-group-append", 4, "ngIf"], [3, "ariaErrorMessage", "errors", "successMessage", "warningMessage", "controlTouched", "messageAppeared"], ["adaptRxFeedbackRef", ""], [1, "input-group-prepend"], [1, "input-group-text"], [1, "input-group-custom-tag"], [3, "adaptRadarDisableEventSending", "variant"], [1, "input-group-append"]], template: function AdaptRxTextfieldComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef(_c2);
        i0.ɵɵelementStart(0, "div");
        i0.ɵɵtext(1, "\n  ");
        i0.ɵɵelement(2, "adapt-rx-control-label", 0);
        i0.ɵɵtext(3, "\n\n  ");
        i0.ɵɵelementStart(4, "div", 1);
        i0.ɵɵtext(5, "\n    ");
        i0.ɵɵtemplate(6, AdaptRxTextfieldComponent_div_6_Template, 5, 1, "div", 2);
        i0.ɵɵtext(7, "\n    ");
        i0.ɵɵprojection(8);
        i0.ɵɵtext(9, "\n    ");
        i0.ɵɵelementStart(10, "input", 3, 4);
        i0.ɵɵlistener("input", function AdaptRxTextfieldComponent_Template_input_input_10_listener() { return ctx.inputValueChange(); })("focus", function AdaptRxTextfieldComponent_Template_input_focus_10_listener($event) { return ctx.focusHandler($event); })("blur", function AdaptRxTextfieldComponent_Template_input_blur_10_listener($event) { return ctx.blurHandler($event); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(12, "\n    ");
        i0.ɵɵprojection(13, 1);
        i0.ɵɵtext(14, "\n    ");
        i0.ɵɵtemplate(15, AdaptRxTextfieldComponent_div_15_Template, 5, 3, "div", 5);
        i0.ɵɵtext(16, "\n    ");
        i0.ɵɵtemplate(17, AdaptRxTextfieldComponent_div_17_Template, 5, 1, "div", 6);
        i0.ɵɵtext(18, "\n  ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(19, "\n\n  ");
        i0.ɵɵelementStart(20, "adapt-rx-feedback", 7, 8);
        i0.ɵɵlistener("messageAppeared", function AdaptRxTextfieldComponent_Template_adapt_rx_feedback_messageAppeared_20_listener($event) { return ctx.handleMessageAppeared($event, ctx.analyticsComponentName.AdaptRxTextfield); });
        i0.ɵɵelementEnd();
        i0.ɵɵtext(22, "\n");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(23, "\n");
    } if (rf & 2) {
        i0.ɵɵclassProp("has-danger", ctx.hasDangerState)("has-warning", ctx.warningMessage)("has-success", ctx.hasSuccessState)("has-tag", !!ctx.fieldTagText);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("subLabel", ctx.subLabel)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltip)("testID", ctx.testID);
        i0.ɵɵadvance(2);
        i0.ɵɵclassProp("input-group-sm", ctx.size === "sm")("input-group-lg", ctx.size === "lg")("has-disabled-icon", ctx.readonly && ctx.disabledStyleForReadonlyState)("has-danger-icon", ctx.hasDangerStateIcon)("has-success-icon", ctx.hasSuccessStateIcon)("disabled-look", ctx.disabled);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.prepend);
        i0.ɵɵadvance(4);
        i0.ɵɵclassProp("form-control-disabled-look", ctx.readonly && ctx.disabledStyleForReadonlyState)("form-control-danger", ctx.hasDangerStateIcon)("form-control-success", ctx.hasSuccessStateIcon);
        i0.ɵɵproperty("id", ctx.id)("value", ctx.value)("required", ctx.required)("disabled", ctx.disabled)("readOnly", ctx.readonly)("autofocus", ctx.autofocus)("autocomplete", ctx.getAutocompleteValue);
        i0.ɵɵattribute("type", ctx.getInputTypeValue)("name", ctx.name)("placeholder", ctx.placeholder)("tabindex", ctx.tabIndex)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy)("aria-required", ctx.required)("aria-readonly", ctx.readonly)("aria-disabled", ctx.disabled)("aria-invalid", ctx.hasDangerState)("aria-errormessage", ctx.ariaErrorMessage)("data-testid", ctx.testID);
        i0.ɵɵadvance(5);
        i0.ɵɵproperty("ngIf", !!ctx.fieldTagText);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.append);
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ariaErrorMessage", ctx.ariaErrorMessage)("errors", ctx.ngControl.errors)("successMessage", ctx.validStateMessage)("warningMessage", ctx.warningMessage)("controlTouched", ctx.ngControl.touched);
    } }, directives: [i5.AdaptRxControlLabelComponent, i6.NgIf, i7.AdaptRxFeedbackComponent, i8.AdaptBadgeComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxTextfieldComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-textfield',
                templateUrl: './adapt-rx-textfield.component.html',
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: i1.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i2.AdaptRxTextfieldConfigService }, { type: i0.ChangeDetectorRef }, { type: i3.AdaptRadarAngularService }, { type: i4.AdaptTranslateService }, { type: i0.ElementRef }]; }, { prepend: [{
            type: Input
        }], append: [{
            type: Input
        }], isPassword: [{
            type: Input
        }], autocomplete: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], size: [{
            type: Input
        }], fieldTagText: [{
            type: Input
        }], fieldTagType: [{
            type: Input
        }], showValidState: [{
            type: Input
        }], showValidStateIcon: [{
            type: Input
        }], showInvalidStateIcon: [{
            type: Input
        }], validStateMessage: [{
            type: Input
        }], disabledStyleForReadonlyState: [{
            type: Input
        }], inputRef: [{
            type: ViewChild,
            args: ['inputRef', { static: true }]
        }], adaptRxFeedbackRef: [{
            type: ViewChild,
            args: ['adaptRxFeedbackRef', { static: true }]
        }] }); })();
//# sourceMappingURL=adapt-rx-textfield.component.js.map