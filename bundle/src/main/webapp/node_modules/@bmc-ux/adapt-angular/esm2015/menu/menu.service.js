import { Injectable, Renderer2, ChangeDetectorRef } from '@angular/core';
import { isDefined } from '../common/utilities';
import { BehaviorSubject } from 'rxjs';
import * as i0 from "@angular/core";
export class MenuInnerService {
    constructor(_renderer, _changeDetectorRef) {
        this._renderer = _renderer;
        this._changeDetectorRef = _changeDetectorRef;
        this.mobileDefaultTexts = {};
        this.menuElementRef = new BehaviorSubject(null);
    }
    get cascadeChain() {
        return this._openedMenu;
    }
    init(config) {
        this.item = config.cascadeItem;
        this.id = config.id;
        this.isMobile = config.isMobile;
        this.mobileDefaultTexts = config.mobileViewTexts;
        this.appendToBody = config.appendToBody;
        this._attachCascade(config.id);
        // add parent element
        if (this.item.items) {
            this.item.items.forEach((item) => {
                this._addParent(item, this.item);
            });
        }
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    addCascadeItem(parentNode, componentRef, anchor) {
        if (!this._openedMenu.id) {
            return;
        }
        this._openedMenu.subMenuItems.push({
            parentNode,
            componentRef,
            anchor
        });
        this.currentActiveCascadeItem = componentRef.instance._elemRef.nativeElement;
        if (!isDefined(this._documentListenerFunc)) {
            this._documentListenerFunc = this._renderer.listen('document', 'click', this.closeFromClick.bind(this));
        }
    }
    detachCascade() {
        this._openedMenu.subMenuItems.forEach((item) => {
            this._destroy(item);
        });
        this._openedMenu.subMenuItems = [];
        if (this._documentListenerFunc) {
            this._documentListenerFunc();
            this._documentListenerFunc = null;
        }
    }
    destroyCascadeItems(level) {
        var _a;
        this._openedMenu.subMenuItems.forEach((item, index) => {
            if (index > level) {
                this._destroy(item);
            }
        });
        this._openedMenu.subMenuItems.length = level + 1;
        this.currentActiveCascadeItem = (_a = this._openedMenu.subMenuItems[level]) === null || _a === void 0 ? void 0 : _a.componentRef.instance._elemRef.nativeElement;
    }
    closeFromClick(e) {
        if (!this.getCascadeLength()) {
            return;
        }
        const clickMenu = this.cascadeChain.subMenuItems.some((item) => {
            return item.componentRef ? item.componentRef.instance.isEventFrom(e) : false;
        });
        const clickTarget = this.cascadeChain.subMenuItems.some((item) => {
            return item.anchor ? item.anchor.isEventFrom(e) : false;
        });
        if (!clickMenu && !clickTarget) {
            this.detachCascade();
            // need to run manually change detection to cover use-case
            // when parent component implements OnPush strategy
            this._changeDetectorRef.detectChanges();
        }
    }
    getCascadeLength() {
        return this.cascadeChain ? this.cascadeChain.subMenuItems.length : 0;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _attachCascade(id) {
        if (this._openedMenu && this._openedMenu.subMenuItems) {
            this.detachCascade();
        }
        this._openedMenu = {
            id,
            subMenuItems: []
        };
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _destroy(item) {
        item.componentRef.destroy();
        item.parentNode.expanded = false;
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    _addParent(menuItem, parent) {
        menuItem.parent = parent;
        if (menuItem.items) {
            menuItem.items.forEach((item) => {
                this._addParent(item, menuItem);
            });
        }
    }
}
MenuInnerService.ɵfac = function MenuInnerService_Factory(t) { return new (t || MenuInnerService)(i0.ɵɵinject(i0.Renderer2), i0.ɵɵinject(i0.ChangeDetectorRef)); };
MenuInnerService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: MenuInnerService, factory: MenuInnerService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MenuInnerService, [{
        type: Injectable
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, null); })();
//# sourceMappingURL=menu.service.js.map