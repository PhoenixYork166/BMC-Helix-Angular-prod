import { Component, ElementRef, HostListener, Input } from '@angular/core';
import { TAB } from '@angular/cdk/keycodes';
import { asapScheduler, ReplaySubject, timer } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { getEventKeyCode } from '../common/key-codes';
import { getFocusableElements } from '../common/focus';
import { AdaptInteractionSourceService } from '../common/interaction-source';
import * as i0 from "@angular/core";
import * as i1 from "../common/interaction-source";
const _c0 = ["*"];
// eslint-disable-next-line @angular-eslint/component-class-suffix
export class AdaptFocusHolderDirective {
    constructor(_elRef, _interactionSourceService) {
        this._elRef = _elRef;
        this._interactionSourceService = _interactionSourceService;
        /**
         *  Hold `Tab` key focus in the directive's host element area
         */
        this.adaptFocusHolder = false;
        /**
         *  Auto holding focus on init
         */
        this.holdFocusOnInit = true;
        /**
         *  The event type for the focusing holder init
         */
        this.eventType = 'keyboard';
        /**
         * Focus first focusable element in the directive area on init
         */
        this.focusFirstOnInit = false;
        /**
         *  The delay before first element in the host element will be focussed
         */
        this.focusFirstDelay = 0;
        /**
         *  Restore last focused element after directive's host element destroy
         */
        this.restoreLastFocusedElement = true;
        /**
         *  Focus the element next to last focussed element after directive's host element destroy
         */
        this.focusNextElement = false;
        /**
         * Prevent scrolling to the focus element. Part of FocusOptions.
         * @docs-default false
         * @since v12.34.0
         */
        this.preventScroll = false;
        this._destroyed$ = new ReplaySubject(1);
    }
    _onKeydown(event) {
        if (!this.adaptFocusHolder || getEventKeyCode(event) !== TAB) {
            return;
        }
        const focusableElements = getFocusableElements(this._elRef.nativeElement);
        if (focusableElements.length) {
            const firstEl = focusableElements[0];
            const lastEl = focusableElements[focusableElements.length - 1];
            const target = event.target;
            if (event.shiftKey) {
                if (target === firstEl) {
                    event.preventDefault();
                    lastEl.focus({ preventScroll: this.preventScroll });
                }
                if (target === this._elRef.nativeElement) {
                    event.preventDefault();
                    lastEl.focus({ preventScroll: this.preventScroll });
                }
            }
            else {
                if (target === lastEl) {
                    event.preventDefault();
                    firstEl.focus({ preventScroll: this.preventScroll });
                }
                if (target === this._elRef.nativeElement) {
                    event.preventDefault();
                    firstEl.focus({ preventScroll: this.preventScroll });
                }
            }
        }
        else {
            event.preventDefault();
        }
    }
    ngOnInit() {
        this._lastFocusEl = document.activeElement;
        this._focusedElementsList = getFocusableElements(document);
        if (this._lastFocusEl) {
            this._lastElementIndex = this._focusedElementsList.indexOf(this._lastFocusEl);
        }
    }
    ngAfterViewInit() {
        if (this.adaptFocusHolder && this.holdFocusOnInit) {
            // Stealing focus synchronously in an ngAfterViewInit will trigger ExpressionChangedAfterItHasBeenChecked error
            // if the loss of focus on the currently active element has repercussions on template-bound properties
            // (eg. if the focus is currently on an input element bound to a form control that is not yet touched)
            timer(0, asapScheduler)
                .pipe(takeUntil(this._destroyed$))
                .subscribe(() => {
                this._elRef.nativeElement.focus({ preventScroll: true });
            });
        }
        if (this.focusFirstOnInit && this.eventType === 'keyboard') {
            timer(this.focusFirstDelay)
                .pipe(takeUntil(this._destroyed$))
                .subscribe(() => {
                var _a;
                (_a = getFocusableElements(this._elRef.nativeElement)[0]) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: this.preventScroll });
            });
        }
    }
    ngOnDestroy() {
        this._destroyed$.next();
        this._destroyed$.complete();
        // Check if focus hadn't been changed before the directive destroy
        if (this._elRef.nativeElement.contains(document.activeElement)) {
            if (this.restoreLastFocusedElement && !this.focusNextElement && this._lastFocusEl) {
                this._lastFocusEl.focus({ preventScroll: this.preventScroll });
            }
            else if (this.focusNextElement) {
                const isLastEventFromKeyboard = this._interactionSourceService.getLastInteractionSourceOrigin() === 'keyboard';
                const lastEventFromKeyboard = this._interactionSourceService.getLastInteractionSourceEvent();
                const tabKeyEvent = isLastEventFromKeyboard && lastEventFromKeyboard && getEventKeyCode(lastEventFromKeyboard) === TAB ?
                    lastEventFromKeyboard : null;
                // Last event type is needed for IE11 while using keyboard navigation (#2164)
                // Also it is needed to be sure that the last event type is KeyboardEvent
                if (this.focusNextElement && isLastEventFromKeyboard) {
                    let elementToFocus = this._lastFocusEl;
                    if (tabKeyEvent) {
                        if (tabKeyEvent.shiftKey) {
                            elementToFocus = this._focusedElementsList[this._lastElementIndex - 1] || this._lastFocusEl;
                        }
                        else {
                            elementToFocus = this._focusedElementsList[this._lastElementIndex + 1];
                        }
                    }
                    if (elementToFocus) {
                        elementToFocus.focus({ preventScroll: this.preventScroll });
                    }
                }
            }
        }
        this._lastFocusEl = null;
        this._focusedElementsList = null;
    }
}
AdaptFocusHolderDirective.ɵfac = function AdaptFocusHolderDirective_Factory(t) { return new (t || AdaptFocusHolderDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.AdaptInteractionSourceService)); };
AdaptFocusHolderDirective.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptFocusHolderDirective, selectors: [["adapt-focus-holder"], ["", "adaptFocusHolder", ""]], hostVars: 1, hostBindings: function AdaptFocusHolderDirective_HostBindings(rf, ctx) { if (rf & 1) {
        i0.ɵɵlistener("keydown", function AdaptFocusHolderDirective_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); });
    } if (rf & 2) {
        i0.ɵɵattribute("tabindex", -1);
    } }, inputs: { adaptFocusHolder: "adaptFocusHolder", holdFocusOnInit: "holdFocusOnInit", eventType: "eventType", focusFirstOnInit: "focusFirstOnInit", focusFirstDelay: "focusFirstDelay", restoreLastFocusedElement: "restoreLastFocusedElement", focusNextElement: "focusNextElement", preventScroll: "preventScroll" }, ngContentSelectors: _c0, decls: 3, vars: 0, template: function AdaptFocusHolderDirective_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵprojection(1);
        i0.ɵɵtext(2, "\n  ");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptFocusHolderDirective, [{
        type: Component,
        args: [{
                selector: 'adapt-focus-holder, [adaptFocusHolder]',
                template: `
    <ng-content></ng-content>
  `,
                // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                host: {
                    '[attr.tabindex]': '-1'
                }
            }]
    }], function () { return [{ type: i0.ElementRef }, { type: i1.AdaptInteractionSourceService }]; }, { adaptFocusHolder: [{
            type: Input
        }], holdFocusOnInit: [{
            type: Input
        }], eventType: [{
            type: Input
        }], focusFirstOnInit: [{
            type: Input
        }], focusFirstDelay: [{
            type: Input
        }], restoreLastFocusedElement: [{
            type: Input
        }], focusNextElement: [{
            type: Input
        }], preventScroll: [{
            type: Input
        }], _onKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
//# sourceMappingURL=focus-holder.directive.js.map