import { FormatWidth, FormStyle, getLocaleDateFormat, getLocaleDateTimeFormat, getLocaleDayNames, getLocaleDayPeriods, getLocaleDirection, getLocaleEraNames, getLocaleId, getLocaleMonthNames, getLocaleNumberSymbol, getLocaleTimeFormat, NumberSymbol, TranslationWidth } from '@angular/common';
import { capitalize, isNaN, isNil, isNumber, toString, trim } from 'lodash-es';
import { adaptWarn } from '../../../common/logger';
import { isValidTimeZone } from './time-zone.utils';
import { getTimeZoneOffset } from './offset.utils';
import { isInvalidDateStruct, isValidDate } from './validate.utils';
const makeOptional = (pattern) => `(?:${pattern})?`;
const ISO_YEAR_PATTERN = '(?<year>\\d{4})';
const ISO_MONTH_PATTERN = '-(?<month>\\d{2})';
const ISO_DAY_PATTERN = '-(?<date>\\d{2})';
const ISO_HOUR_PATTERN = 'T(?<hours>\\d{2})';
const ISO_MINUTE_PATTERN = ':(?<minutes>\\d{2})';
const ISO_SECOND_PATTERN = ':(?<seconds>\\d{2})';
const ISO_MS_PATTERN = '\\.(?<milliseconds>\\d{3})\\d*';
const ISO_TZ_PATTERN = '(?<offsetsign>[+-])(?<offsethours>\\d{2}):?(?<offsetminutes>\\d{2})';
// ISO dates should include at least the year and month
const ISO_DATE_PATTERN = ISO_YEAR_PATTERN + ISO_MONTH_PATTERN + makeOptional(ISO_DAY_PATTERN);
// When included, the time part of ISO dates should include at least the hours and minutes
const ISO_TIME_PATTERN = ISO_HOUR_PATTERN + ISO_MINUTE_PATTERN + makeOptional(ISO_SECOND_PATTERN + makeOptional(ISO_MS_PATTERN));
// Regular expressions for matching date strings in ISO format, with or without timezone
const ISO_UTC_REG_EXP = new RegExp(`^${ISO_DATE_PATTERN}${makeOptional(ISO_TIME_PATTERN)}Z?$`);
const ISO_OFFSET_REG_EXP = new RegExp(`^${ISO_DATE_PATTERN}${ISO_TIME_PATTERN}${ISO_TZ_PATTERN}$`);
// Regular expression for splitting date formats used by Angular, taken from Angular source
const DATE_FORMAT_LITERAL = '(?:[^GyYMLwWdEabBhHmsSzZO\']+)';
const DATE_FORMAT_QUOTED_LITERAL = '(?:\'(?:[^\']|\'\')*\')';
const DATE_FORMAT_TOKEN = '(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4})';
const DATE_FORMATS_SPLIT = new RegExp(`(${DATE_FORMAT_LITERAL}|${DATE_FORMAT_QUOTED_LITERAL}|${DATE_FORMAT_TOKEN})([\\s\\S]*)`);
const FORMAT_MATCHERS = new Map();
const NO_LOCALE_DATA_CACHE = new Set();
function fillStructDefaults(parts) {
    return ['year', 'month', 'hours', 'minutes', 'seconds', 'milliseconds'].reduce((memo, property) => {
        memo[property] = memo[property] || 0;
        return memo;
    }, Object.assign(Object.assign({}, parts), { date: isNil(parts.date) ? 1 : parts.date }));
}
function getCurrentCentury() {
    return new Date().getFullYear().toString().slice(0, 2);
}
function hasYearMatch(matchGroups) {
    return !isNil(matchGroups.year) || !isNil(matchGroups.abbreviatedyear);
}
function hasMonthMatch(matchGroups) {
    return !isNil(matchGroups.month) ||
        !isNil(matchGroups.abbreviatedmonth) || !isNil(matchGroups.narrowmonth) || !isNil(matchGroups.widemonth) ||
        !isNil(matchGroups.abbreviatedsmonth) || !isNil(matchGroups.narrowsmonth) || !isNil(matchGroups.widesmonth);
}
function applyEra(matchGroups, year, locale) {
    let isBCE = false;
    year = toString(year);
    if (matchGroups.abbreviatedera) {
        isBCE = matchGroups.abbreviatedera === getLocaleEraNames(locale, TranslationWidth.Abbreviated)[0];
    }
    else if (matchGroups.wideera) {
        isBCE = matchGroups.wideera === getLocaleEraNames(locale, TranslationWidth.Wide)[0];
    }
    else if (matchGroups.narrowera) {
        isBCE = matchGroups.narrowera === getLocaleEraNames(locale, TranslationWidth.Narrow)[0];
    }
    // https://github.bmc.com/bmc-ux/adapt-angular/issues/6680
    // https://docs.microsoft.com/en-us/office/troubleshoot/excel/two-digit-year-numbers#the-2029-rule
    if (!isBCE && (year.length <= 2)) {
        let tempYear = parseInt(year, 10);
        if (tempYear >= 0 && tempYear <= 29) {
            tempYear += 2000;
        }
        else if (tempYear >= 30 && tempYear <= 99) {
            tempYear += 1900;
        }
        year = tempYear.toString();
    }
    return isBCE ? `-${year.padStart(6, '0')}` : year.padStart(4, '0');
}
function formatYearMonthDate(date) {
    const year = date.getFullYear();
    const formattedYear = year >= 0 ? year.toString().padStart(4, '0') : `-${Math.abs(year).toString().padStart(6, '0')}`;
    return `${formattedYear}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
}
function extractDay(matchGroups, locale) {
    if (matchGroups.abbreviatedday) {
        return getLocaleDayNames(locale, FormStyle.Format, TranslationWidth.Abbreviated).indexOf(matchGroups.abbreviatedday) + 1;
    }
    else if (matchGroups.wideday) {
        return getLocaleDayNames(locale, FormStyle.Format, TranslationWidth.Wide).indexOf(matchGroups.wideday) + 1;
    }
    else if (matchGroups.narrowday) {
        return getLocaleDayNames(locale, FormStyle.Format, TranslationWidth.Narrow).indexOf(matchGroups.narrowday) + 1;
    }
    else if (matchGroups.shortday) {
        return getLocaleDayNames(locale, FormStyle.Format, TranslationWidth.Short).indexOf(matchGroups.shortday) + 1;
    }
    return 0;
}
function extractDateFromWeekNumberingYear(matchGroups, locale) {
    // try to extract the date from week-numbering year, week and day of week,
    // but only if the "normal" year is not part of the match group
    if (hasYearMatch(matchGroups) || !matchGroups.wnyear && !matchGroups.abbreviatedwnyear) {
        return null;
    }
    const wnyear = applyEra(matchGroups, matchGroups.wnyear || `${getCurrentCentury()}${matchGroups.abbreviatedwnyear}`, locale);
    // January 4th is always in the first week of the year in ISO week-numbering system
    const date = new Date(`${wnyear}-01-04T00:00`);
    // subtract appropriate number of days to put the date on the first day of the first week
    date.setTime(date.getTime() - date.getDay() * 24 * 60 * 60 * 1000);
    // add weeks to put the date at the start of the matched week
    const week = matchGroups.week && parseInt(matchGroups.week);
    week && week <= 53 && date.setTime(date.getTime() + (week - 1) * 7 * 24 * 60 * 60 * 1000);
    // add days to put the date on the matched day of the week
    const day = extractDay(matchGroups, locale) || 1;
    date.setTime(date.getTime() + (day - 1) * 24 * 60 * 60 * 1000);
    return formatYearMonthDate(date);
}
function extractDateFromWeekNumberInMonth(matchGroups, locale) {
    // try to extract the date from matched year, month, week in month and day of week,
    // but only if the numeric date of month is not part of the match group
    const week = parseInt(matchGroups.weekinmonth);
    if (!isNil(matchGroups.date) || !week || week < 1 || week > 5 || !hasMonthMatch(matchGroups) || !hasYearMatch(matchGroups)) {
        return null;
    }
    const month = extractMonth(matchGroups, locale);
    const day = extractDay(matchGroups, locale);
    const date = new Date(`${extractYear(matchGroups, locale)}-${month}-01T00:00:00`);
    // when the day is not specified and the week number is 1 the match is the first day of the month;
    // otherwise we need to do some calculations to adjust the date to the desired day
    if (day || week > 1) {
        // subtract appropriate number of days to put the date on the Sunday of the first week
        date.setTime(date.getTime() - date.getDay() * 24 * 60 * 60 * 1000);
        // add weeks to put the date at the start of the matched week
        date.setTime(date.getTime() + (week - 1) * 7 * 24 * 60 * 60 * 1000);
        // add appropriate number of days to put the date on the desired day of the week
        date.setTime(date.getTime() + (day - 1) * 24 * 60 * 60 * 1000);
    }
    return formatYearMonthDate(date);
}
function extractDateFromYearMonthDate(matchGroups, locale) {
    return `${extractYear(matchGroups, locale)}-${extractMonth(matchGroups, locale)}-${extractDate(matchGroups)}`;
}
function extractYear(matchGroups, locale) {
    let year;
    if (matchGroups.year) {
        year = matchGroups.year;
    }
    else if (matchGroups.abbreviatedyear) {
        // 'yy' format is special in that it returns the same string for different centuries (ie. 1901 => '01'; 2001 => '01');
        // It is therefore not possible to uniquely distinguish the intended century from the parsed string, so the best
        // we can do is to "guess" that the current century is intended.
        year = `${getCurrentCentury()}${matchGroups.abbreviatedyear}`;
    }
    return isNil(year) ? '1970' : applyEra(matchGroups, year, locale);
}
function extractMonth(matchGroups, locale) {
    let month;
    if (!isNil(matchGroups.month)) {
        month = matchGroups.month;
    }
    else if (!isNil(matchGroups.abbreviatedmonth)) {
        month = (getLocaleMonthNames(locale, FormStyle.Format, TranslationWidth.Abbreviated).indexOf(matchGroups.abbreviatedmonth) + 1).toString();
    }
    else if (!isNil(matchGroups.narrowmonth)) {
        month = (getLocaleMonthNames(locale, FormStyle.Format, TranslationWidth.Narrow).indexOf(matchGroups.narrowmonth) + 1).toString();
    }
    else if (!isNil(matchGroups.widemonth)) {
        month = (getLocaleMonthNames(locale, FormStyle.Format, TranslationWidth.Wide).indexOf(matchGroups.widemonth) + 1).toString();
    }
    else if (!isNil(matchGroups.abbreviatedsmonth)) {
        month = (getLocaleMonthNames(locale, FormStyle.Standalone, TranslationWidth.Abbreviated).indexOf(matchGroups.abbreviatedsmonth) + 1).toString();
    }
    else if (!isNil(matchGroups.narrowsmonth)) {
        month = (getLocaleMonthNames(locale, FormStyle.Standalone, TranslationWidth.Narrow).indexOf(matchGroups.narrowsmonth) + 1).toString();
    }
    else if (!isNil(matchGroups.widesmonth)) {
        month = (getLocaleMonthNames(locale, FormStyle.Standalone, TranslationWidth.Wide).indexOf(matchGroups.widesmonth) + 1).toString();
    }
    else {
        month = '01';
    }
    return month.padStart(2, '0');
}
function extractDate(matchGroups) {
    return (matchGroups.date || '01').padStart(2, '0');
}
function extractHours(matchGroups, locale) {
    if (matchGroups.hour) {
        return matchGroups.hour.padStart(2, '0');
    }
    if (!matchGroups.hour12) {
        return '00';
    }
    let hour = parseInt(matchGroups.hour12);
    if (hour > 12) {
        // invalid value; set hour to a value that will result in invalid date
        return '25';
    }
    let isPM = false;
    if (matchGroups.abbreviateddayperiod) {
        isPM = matchGroups.abbreviateddayperiod === getLocaleDayPeriods(locale, FormStyle.Format, TranslationWidth.Abbreviated)[1];
    }
    else if (matchGroups.widedayperiod) {
        isPM = matchGroups.widedayperiod === getLocaleDayPeriods(locale, FormStyle.Format, TranslationWidth.Wide)[1];
    }
    else if (matchGroups.narrowdayperiod) {
        isPM = matchGroups.narrowdayperiod === getLocaleDayPeriods(locale, FormStyle.Format, TranslationWidth.Narrow)[1];
    }
    hour = hour % 12;
    if (isPM) {
        hour += 12;
    }
    return hour.toString().padStart(2, '0');
}
function extractMinutes(matchGroups) {
    return (matchGroups.minute || '0').padStart(2, '0');
}
function extractSeconds(matchGroups) {
    return (matchGroups.second || '0').padStart(2, '0');
}
function extractMilliseconds(matchGroups) {
    return matchGroups.millisecond || '000';
}
function extractZone(matchGroups, locale) {
    const sign = matchGroups.offsetsign;
    if (!sign) {
        return '';
    }
    const hours = toString(matchGroups.offsethours).padStart(2, '0');
    const minutes = toString(matchGroups.offsetminutes).padStart(2, '0');
    return `${sign === getLocaleNumberSymbol(locale, NumberSymbol.MinusSign) ? '-' : '+'}${hours}${minutes}`;
}
function attemptMatch(value, matcher, locale) {
    const match = value.match(matcher);
    if (!match) {
        return null;
    }
    const date = extractDateFromWeekNumberingYear(match.groups, locale) ||
        extractDateFromWeekNumberInMonth(match.groups, locale) ||
        extractDateFromYearMonthDate(match.groups, locale);
    const time = `${extractHours(match.groups, locale)}:${extractMinutes(match.groups)}:${extractSeconds(match.groups)}.${extractMilliseconds(match.groups)}`;
    const zone = extractZone(match.groups, locale);
    return new Date(`${date}T${time}${zone}`);
}
function getDirectionSafeString(value, locale) {
    // rtl language strings must be converted into unicode when used as part of regular expression patterns
    return getLocaleDirection(locale) === 'rtl' ? value.split('').map(a => `\\u${a.charCodeAt(0).toString(16).padStart(4, '0')}`).join('') : value;
}
function joinLocalizedNames(names, locale) {
    return names.map(name => getDirectionSafeString(name, locale).replace(/\./g, '\\.')).join('|');
}
function getNumericPattern(length, partName) {
    return length === 2 ? `(?<${partName}>\\d{2})` : `(?<${partName}>\\d{1,2})`;
}
function getLocalizedNamesPattern(length, partName, locale, localizedNamesGetter) {
    switch (length) {
        case 6:
            return `(?<short${partName}>${joinLocalizedNames(localizedNamesGetter(TranslationWidth.Short), locale)})`;
        case 5:
            return `(?<narrow${partName}>${joinLocalizedNames(localizedNamesGetter(TranslationWidth.Narrow), locale)})`;
        case 4:
            return `(?<wide${partName}>${joinLocalizedNames(localizedNamesGetter(TranslationWidth.Wide), locale)})`;
        default:
            return `(?<abbreviated${partName}>${joinLocalizedNames(localizedNamesGetter(TranslationWidth.Abbreviated), locale)})`;
    }
}
function getYearPattern(length, partName) {
    switch (length) {
        case 4:
            return `(?<${partName}>\\d{4})`;
        case 3:
            return `(?<${partName}>\\d{3,4})`;
        case 2:
            return `(?<abbreviated${partName}>\\d{2})`;
        default:
            return `(?<${partName}>\\d{1,4})`;
    }
}
function getMonthPattern(length, style, locale) {
    return length < 3 ? getNumericPattern(length, 'month') :
        getLocalizedNamesPattern(length, style === FormStyle.Standalone ? 'smonth' : 'month', locale, (width) => getLocaleMonthNames(locale, style, width));
}
function getGMTOffsetPattern(length, locale) {
    return length === 4 ?
        `GMT(?<offsetsign>${getDirectionSafeString(getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), locale)}|\\+)(?<offsethours>\\d{2}):(?<offsetminutes>\\d{2})` :
        `GMT(?<offsetsign>${getDirectionSafeString(getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), locale)}|\\+)(?<offsethours>\\d{1,2})`;
}
function getISOOffsetPattern(length, locale) {
    switch (length) {
        case 5:
            return `(?<offsetsign>${getDirectionSafeString(getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), locale)}|\\+)(?<offsethours>\\d{2}):(?<offsetminutes>\\d{2})`;
        case 4:
            return getGMTOffsetPattern(length, locale);
        default:
            return `(?<offsetsign>${getDirectionSafeString(getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), locale)}|\\+)(?<offsethours>\\d{2})(?<offsetminutes>\\d{2})`;
    }
}
function getPatternFromPart(namedPart, locale) {
    // TODO: do we need to support the "extra data" parts 'b', 'B'?
    switch (namedPart.slice(0, 1)) {
        case 'G':
            // Era name (AD/BC)
            return getLocalizedNamesPattern(namedPart.length, 'era', locale, (width) => getLocaleEraNames(locale, width));
        case 'y':
            // 1-4 digit representations of year
            return getYearPattern(namedPart.length, 'year');
        case 'Y':
            // 1-4 digit representations of week-numbering year
            return getYearPattern(namedPart.length, 'wnyear');
        case 'M':
            // Month of the year in 1-2 digit numeric format or appropriate string format
            return getMonthPattern(namedPart.length, FormStyle.Format, locale);
        case 'L':
            // Month of the year in 1-2 digit numeric format or appropriate string format
            return getMonthPattern(namedPart.length, FormStyle.Standalone, locale);
        case 'w':
            // 1-2 digit representation of week of the year
            return '(?<week>\\d{1,2})';
        case 'W':
            // 1-2 digit representation of week of the month
            return '(?<weekinmonth>\\d{1,2})';
        case 'd':
            // 1-2 digit representation of the day of the month
            return getNumericPattern(namedPart.length, 'date');
        case 'E':
            // Day of the week in appropriate string format
            return getLocalizedNamesPattern(namedPart.length, 'day', locale, (width) => getLocaleDayNames(locale, FormStyle.Format, width));
        case 'a':
            // Generic period of the day (am-pm) in appropriate string format
            return getLocalizedNamesPattern(namedPart.length, 'dayperiod', locale, (width) => getLocaleDayPeriods(locale, FormStyle.Format, width));
        case 'h':
            // 1-2 digit representation of the hour of the day in 12-hour clock
            return getNumericPattern(namedPart.length, 'hour12');
        case 'H':
            // 1-2 digit representation of the hour of the day in 24-hour clock
            return getNumericPattern(namedPart.length, 'hour');
        case 'm':
            // 1-2 digit representation of the minute of the hour
            return getNumericPattern(namedPart.length, 'minute');
        case 's':
            // 1-2 digit representation of the second of the minute
            return getNumericPattern(namedPart.length, 'second');
        case 'S':
            // Fractional second
            return `(?<millisecond>\\d{${namedPart.length}})`;
        case 'O':
        case 'z':
            // Timezone GMT short (GMT+4) or long (GMT+0430) format
            return getGMTOffsetPattern(namedPart.length, locale);
        case 'Z':
            // Timezone GMT long format if length === 4; Timezone ISO8601 short (-0430) or extended (-04:30) format otherwise
            return getISOOffsetPattern(namedPart.length, locale);
        default:
            // Extra formatting characters
            return namedPart === '\'\'' ? '\'' : namedPart.replace(/(^'|'$)/g, '').replace(/''/g, '\'').replace(/(\.|\/|\[|\])/g, '\\$1');
    }
}
function buildMatcherFromFormat(format, locale) {
    let parts = [];
    let match;
    while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
            parts = parts.concat(match.slice(1));
            const part = parts.pop();
            if (!part) {
                break;
            }
            format = part;
        }
        else {
            parts.push(format);
            break;
        }
    }
    return new RegExp(`^${parts.map(part => getPatternFromPart(part, locale)).join('')}$`);
}
function getFormatMatcher(locale, format) {
    if (!FORMAT_MATCHERS.has(locale)) {
        try {
            getLocaleId(locale);
        }
        catch (e) {
            if (!NO_LOCALE_DATA_CACHE.has(locale)) {
                adaptWarn('DatetimeParserFormatter:', e.message, 'Falling back to "en".');
                NO_LOCALE_DATA_CACHE.add(locale);
            }
            locale = 'en';
        }
        !FORMAT_MATCHERS.has(locale) && FORMAT_MATCHERS.set(locale, new Map());
    }
    const matchers = FORMAT_MATCHERS.get(locale);
    if (matchers.has(format)) {
        return { matcher: matchers.get(format), locale };
    }
    let formatValue;
    let width;
    switch (format) {
        case 'shortDate':
        case 'mediumDate':
        case 'longDate':
        case 'fullDate':
            width = FormatWidth[capitalize(format.replace('Date', ''))];
            formatValue = getLocaleDateFormat(locale, width);
            break;
        case 'shortTime':
        case 'mediumTime':
        case 'longTime':
        case 'fullTime':
            width = FormatWidth[capitalize(format.replace('Time', ''))];
            formatValue = getLocaleTimeFormat(locale, width);
            break;
        case 'short':
        case 'medium':
        case 'long':
        case 'full':
            width = FormatWidth[capitalize(format)];
            formatValue = getLocaleDateTimeFormat(locale, width).replace('{0}', getLocaleTimeFormat(locale, width)).replace('{1}', getLocaleDateFormat(locale, width));
            break;
        default:
            formatValue = format;
    }
    const matcher = buildMatcherFromFormat(formatValue, locale);
    matchers.set(format, matcher);
    return { matcher, locale };
}
function parseISODate(value) {
    return value.match(ISO_UTC_REG_EXP) || value.match(ISO_OFFSET_REG_EXP) ? new Date(value) : null;
}
function parseFormattedDate(value, formats, locale) {
    let parsedDate = null;
    for (const format of formats) {
        const formatMatcher = getFormatMatcher(locale, format);
        parsedDate = attemptMatch(value, formatMatcher.matcher, formatMatcher.locale);
        if (parsedDate) {
            break;
        }
    }
    return parsedDate;
}
/**
 * parseDateFromString() function
 *
 * Parses a string representation of a date into a Date object by matching
 * specified date formats in a specified locale
 */
export function parseDateFromString(value, formats, locale) {
    value = trim(value);
    if (!value) {
        return null;
    }
    // match custom formatted values first becase the custom format can be pretty similar to ISO like "yyyy-dd-MM" and "yyyy-MM-dd"
    const parsedDate = parseFormattedDate(value, formats, locale) || parseISODate(value);
    return isValidDate(parsedDate) ? parsedDate : new Date(NaN);
}
/**
 * dateFromUnixTime() function
 *
 * Converts an input unix timestamp into a Date object
 */
export function dateFromUnixTime(value) {
    return isNumber(value) && !isNaN(value) ? new Date(value * 1000) : null;
}
/**
 * getDateFromParts() function
 *
 * Converts an extended datetime struct object into a Date object, respecting the time zone specified in the struct.
 *
 * Note: if a timezone observes Daylight Savings, datetime structs whose parts fall during the "lost" hour
 * during spring ahead to daylight savings technically have no matching Date object; in that case the
 * the resulting Date will be adjusted forward 1 hour (for example, there is no 2am on March 14, 2021 in Vancouver,
 * so a struct specifying these parts will translate into a Date object at 3am on that day.
 * Conversely, datetime structs whose parts fall during the "repeated" hour during fall back from daylight
 * savings are technically ambiguous because they match 2 separate Date objects; in that case, the resulting
 * Date is the earlier of the 2 matches (for example, there are two separate moments in time corresponding
 * to 1am on November 7, 2021 in Vancouver, so a struct specifying these parts translates to 1am before the time
 * falls back to standard time). In particular, there is no struct that converts to the second of the repeated hours
 * during the fall back to standard time.
 * This behaviour matches that of the Date constructor when applied to the same date parts in the client timezone.
 */
export function getDateFromParts(parts) {
    if (!parts) {
        return null;
    }
    else if (isInvalidDateStruct(parts)) {
        // invalid date struct corresponds to Invalid date object
        return new Date(NaN);
    }
    // eslint-disable-next-line prefer-const
    let { year, month, date, hours, minutes, seconds, milliseconds, timeZone, offset } = fillStructDefaults(parts);
    if (!timeZone || !isValidTimeZone(timeZone)) {
        // no fancy Intl footwork is necessary when the client time zone is used
        const res = isNil(offset) ? new Date(year, month, date, hours, minutes, seconds, milliseconds) :
            new Date(Date.UTC(year, month, date, hours, minutes, seconds, milliseconds) + Math.round(offset) * 60 * 1000);
        // Force set year to be sure 2-digit year won't be formatted to 19xx
        res.setFullYear(year);
        return res;
    }
    // start by constructing a UTC date for the given parts
    const dateObj = new Date(Date.UTC(year, month, date, hours, minutes, seconds, milliseconds));
    // Force set year to be sure 2-digit year won't be formatted to 19xx
    dateObj.setUTCFullYear(year);
    // now determine the offset of that date in the desired time zone
    offset = getTimeZoneOffset(dateObj, timeZone);
    // adjust the date by the calculated offset so that it represents the parts in the desired time zone instead of UTC
    offset && dateObj.setTime(dateObj.getTime() + offset * 60 * 1000);
    // we may need further adjustment if the date is near a daylight savings change
    const adjustedOffset = getTimeZoneOffset(dateObj, timeZone);
    const offsetBefore = getTimeZoneOffset(new Date(dateObj.getTime() - 60 * 60 * 1000), timeZone);
    if (adjustedOffset > offset) {
        // Adjusting the date has moved it out of Daylight Savings period, so the adjusted date will have a struct whose
        // hour is 1 less than the original parts, and we need to re-adjust forward an hour.
        // Note that in the case that the shift was forward out of DS, there is a 1 hour range of structs that is ambiguous
        // in determining a Date object, as the time zone repeats an hour during the change
        // (e.g. in Vancouver tz, the times between 1AM and 2AM on 2021-11-07 are repeated twice). In this case
        // we follow the behaviour of the Date constructor to decide that such an ambiguous struct represents the
        // first of the two matching Dates, ie. the one in the new offset.
        dateObj.setTime(dateObj.getTime() + 60 * 60 * 1000);
    }
    else if (offsetBefore < offset) {
        // Adjusting the date has moved it so that the time one hour prior is in Daylight Savings period. The adjusted date
        // will have a struct whose hour is 1 greater than the original parts, so we need to re-adjust backward an hour.
        // As in the previous case, if the shift was backward into DS, there is a 1 hour range of ambiguous structs, and we
        // decide that such an ambiguous struct represents the first of the two matching Dates.
        dateObj.setTime(dateObj.getTime() - 60 * 60 * 1000);
    }
    return dateObj;
}
//# sourceMappingURL=parse.utils.js.map