import { Injectable, NgZone } from '@angular/core';
/**
 * Angular Material CDK
 */
import { FocusMonitor, ListKeyManager } from '@angular/cdk/a11y';
import { fromEvent, ReplaySubject } from 'rxjs';
import { distinctUntilChanged, take, delay, takeUntil } from 'rxjs/operators';
import { getEventKeyCode } from './key-codes';
import { TAB } from '@angular/cdk/keycodes';
import { AdaptListKeyManagerItemDirective } from './list-key-manager';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/a11y";
export class AdaptFocusMonitorService {
    constructor(focusMonitor, _ngZone) {
        this.focusMonitor = focusMonitor;
        this._ngZone = _ngZone;
        this._destroyed$ = new ReplaySubject(1);
        // this.onSomeElementFocus = this.onSomeElementFocus.bind(this);
    }
    init(elements) {
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const keyManager = this.keyManager = new ListKeyManager(elements);
        keyManager.withHorizontalOrientation('ltr'); // Arrow navigation options
        keyManager.withWrap(); // Arrow navigation options
        keyManager.skipPredicate(this.skipPredicate.bind(this));
        if (this._setActiveItemSubscription) {
            this._setActiveItemSubscription.unsubscribe();
        }
        // While AdaptFocusHolderDirective [focusFirstOnInit]="true" need to set active element into keyManager
        this._setActiveItemSubscription = this._ngZone.onStable.asObservable()
            .pipe(takeUntil(this._destroyed$), take(1), delay(0)).subscribe(() => this._setActiveItem());
        // TODO: update activeItemIndex if changed from mouse click
        // TODO: track keyDown if select is attached to body
        // window.addEventListener('focus', this.onSomeElementFocus, true); // performance check should
    }
    onKeyDown(event) {
        this.keyManager.onKeydown(event);
        if (getEventKeyCode(event) === TAB) {
            this.onTabKeyDown();
        }
        else {
            this.onNotTabKeyDown();
        }
    }
    registerKeyDown(element) {
        return fromEvent(element, 'keydown')
            .pipe(distinctUntilChanged(), takeUntil(this._destroyed$))
            .subscribe((event) => this.onKeyDown(event));
    }
    // private onSomeElementFocus(event: Event) {
    //   const target = event.target;
    //   const listItems = (this.keyManager as any)._getItemsArray() as SelectOptionEl[];
    // const indexOfActiveEl = listItems.findIndex(item => this.getNativeEl(item) === target /* check by parents chain */);
    // if (indexOfActiveEl >= 0) {
    // set active el in keyManager
    // }
    // }
    focusOnFirstElement() {
        this.keyManager.setFirstItemActive();
        this.trySetFocusOnActiveEl('program');
    }
    focusOnElement(index) {
        // need to do according to logic in a11y (disabled e.t...)
        // instead of this
        // this.keyManager.setActiveItem(index);
        // need this
        this.keyManager.updateActiveItem(index - 1);
        this.keyManager.setNextItemActive();
        this.trySetFocusOnActiveEl('program');
    }
    ngOnDestroy() {
        if (this._setActiveItemSubscription) {
            this._setActiveItemSubscription.unsubscribe();
        }
        this._destroyed$.next(true);
        this._destroyed$.complete();
        // window.removeEventListener('focus', this.onSomeElementFocus, true);
    }
    skipPredicate(item) {
        var _a;
        // workaround: due to ElementRef should do this
        return ((_a = this.getNativeEl(item)) === null || _a === void 0 ? void 0 : _a.disabled) || (item === null || item === void 0 ? void 0 : item.disabled);
    }
    getNativeEl(item) {
        return item.nativeElement;
    }
    onTabKeyDown() {
        this._ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                // Update active item index by active item
                this._setActiveItem();
            });
        });
    }
    getRealActiveElIndex() {
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const listItems = this.keyManager._getItemsArray();
        const focusedEl = document.activeElement;
        const indexOfActiveEl = listItems.findIndex(item => this.getNativeEl(item) === focusedEl);
        return indexOfActiveEl;
    }
    onNotTabKeyDown() {
        if (this.keyManager.activeItem) {
            this.trySetFocusOnActiveEl('keyboard');
        }
    }
    trySetFocusOnActiveEl(origin) {
        const activeItem = this.keyManager.activeItem;
        let nativeEl;
        if (activeItem) {
            if (activeItem instanceof AdaptListKeyManagerItemDirective) {
                nativeEl = activeItem.getNativeElement();
            }
            else {
                nativeEl = this.getNativeEl(activeItem);
            }
            this.focusMonitor.focusVia(nativeEl, origin);
        }
    }
    _setActiveItem() {
        const focusedElIndex = this.getRealActiveElIndex();
        if (focusedElIndex > -1) {
            this.keyManager.setActiveItem(focusedElIndex);
        }
    }
}
AdaptFocusMonitorService.ɵfac = function AdaptFocusMonitorService_Factory(t) { return new (t || AdaptFocusMonitorService)(i0.ɵɵinject(i1.FocusMonitor), i0.ɵɵinject(i0.NgZone)); };
AdaptFocusMonitorService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: AdaptFocusMonitorService, factory: AdaptFocusMonitorService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptFocusMonitorService, [{
        type: Injectable
    }], function () { return [{ type: i1.FocusMonitor }, { type: i0.NgZone }]; }, null); })();
//# sourceMappingURL=focus-monitor.service.js.map