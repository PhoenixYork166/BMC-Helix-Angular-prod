import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, HostBinding, Input, NgZone, Output, Renderer2 } from '@angular/core';
import { SafeCdr } from '../common/safe-cdr';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "../common/radar/adapt-radar";
import * as i2 from "@angular/common";
import * as i3 from "./split-gutter.directive";
function AdaptSplitComponent_ng_template_3_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementStart(0, "div", 2);
    i0.ɵɵlistener("mousedown", function AdaptSplitComponent_ng_template_3_div_1_Template_div_mousedown_0_listener($event) { i0.ɵɵrestoreView(_r7); const index_r2 = i0.ɵɵnextContext().index; const ctx_r5 = i0.ɵɵnextContext(); return ctx_r5.startDragging($event, index_r2 * 2 + 1); })("touchstart", function AdaptSplitComponent_ng_template_3_div_1_Template_div_touchstart_0_listener($event) { i0.ɵɵrestoreView(_r7); const index_r2 = i0.ɵɵnextContext().index; const ctx_r8 = i0.ɵɵnextContext(); return ctx_r8.startDragging($event, index_r2 * 2 + 1); });
    i0.ɵɵtext(1, "\n        ");
    i0.ɵɵelement(2, "div", 3);
    i0.ɵɵtext(3, "\n        ");
    i0.ɵɵelement(4, "span", 4);
    i0.ɵɵtext(5, "\n      ");
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const index_r2 = i0.ɵɵnextContext().index;
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵproperty("order", index_r2 * 2 + 1)("direction", ctx_r4.direction)("size", ctx_r4.gutterSize)("disabled", ctx_r4.disabled);
} }
function AdaptSplitComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n      ");
    i0.ɵɵtemplate(1, AdaptSplitComponent_ng_template_3_div_1_Template, 6, 4, "div", 1);
    i0.ɵɵtext(2, "\n    ");
} if (rf & 2) {
    const area_r1 = ctx.$implicit;
    const last_r3 = ctx.last;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", last_r3 === false && area_r1.component.visible === true && !ctx_r0.isLastVisibleArea(area_r1));
} }
const _c0 = ["*"];
class DIRECTION {
}
DIRECTION.HORIZONTAL = 'horizontal';
DIRECTION.VERTICAL = 'vertical';
export class AdaptSplitComponent extends AdaptRadarAngularGenericDirective {
    constructor(cdRef, elementRef, renderer, ngZone, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptSplit);
        this.cdRef = cdRef;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Sets splitter direction. Accepts values: 'vertical' or 'horizontal'
         * @docs-default horizontal
         */
        this.direction = 'horizontal';
        /**
         * Sets width. If no value specified - takes all space available
         * @docs-default 100%
         */
        this.width = 0;
        /**
         * Sets height. If no value specified - takes all space available
         * @docs-default 100%
         */
        this.height = 0;
        /**
         * Sets gutter (dragging element) width size
         * @docs-default 1
         */
        this.gutterSize = 10;
        this.disabled = false;
        /**
         * Adds transitions to the split area on changing its size or visibility
         * @docs-default false
         */
        this.visibleTransition = false;
        this.minWidthPercent = 5;
        /**
         * Emits event on splitter drag start
         */
        this.dragStart = new EventEmitter(false);
        /**
         * Emits event on splitter drag progress
         */
        this.dragProgress = new EventEmitter(false);
        /**
         * Emits event on splitter drag end
         */
        this.dragEnd = new EventEmitter(false);
        this.areas = [];
        this.isDragging = false;
        this.containerSize = 0;
        this.areaASize = 0;
        this.areaBSize = 0;
        this.eventsDragFct = [];
    }
    get styleFlexDirection() {
        switch (this.direction) {
            case DIRECTION.HORIZONTAL: {
                return DIRECTION.HORIZONTAL;
            }
            case DIRECTION.VERTICAL: {
                return DIRECTION.VERTICAL;
            }
            default: {
                return DIRECTION.VERTICAL;
            }
        }
    }
    get dragging() {
        // add animation of areas when visibleTransition is truthy
        return this.visibleTransition;
    }
    get visibleAreas() {
        return this.areas.filter(a => a.component.visible);
    }
    get nbGutters() {
        return this.visibleAreas.length - 1;
    }
    ngOnInit() {
        this._setHeightStyle();
        this._setWidthStyle();
    }
    ngOnChanges(changes) {
        if (changes.gutterSize || changes.disabled) {
            this.refresh();
        }
        if (changes['height']) {
            this._setHeightStyle();
        }
        if (changes['width']) {
            this._setWidthStyle();
        }
    }
    addArea(component, orderUser, sizeUser, minPixel) {
        this.areas.push({
            component,
            orderUser,
            order: -1,
            sizeUser,
            size: -1,
            minPixel
        });
        this.refresh();
    }
    updateArea(component, orderUser, sizeUser, minPixel) {
        const item = this.areas.find(a => a.component === component);
        if (item) {
            item.orderUser = orderUser;
            item.sizeUser = sizeUser;
            item.minPixel = minPixel;
            this.refresh();
        }
    }
    removeArea(area) {
        const item = this.areas.find(a => a.component === area);
        if (item) {
            const index = this.areas.indexOf(item);
            this.areas.splice(index, 1);
            this.areas.forEach((a, i) => a.order = i * 2);
            this.refresh();
        }
    }
    hideArea(area) {
        const item = this.areas.find(a => a.component === area);
        if (item) {
            item.component.setStyle('flex-basis', 0);
            this.refresh();
        }
    }
    showArea(area) {
        const item = this.areas.find(a => a.component === area);
        if (item) {
            this.refresh();
        }
    }
    isLastVisibleArea(area) {
        const visibleAreas = this.visibleAreas;
        return visibleAreas.length > 0 ? area === visibleAreas[visibleAreas.length - 1] : false;
    }
    startDragging(startEvent, gutterOrder) {
        startEvent.preventDefault();
        if (this.disabled) {
            return;
        }
        const areaA = this.areas.find(a => a.order === gutterOrder - 1);
        const areaB = this.areas.find(a => a.order === gutterOrder + 1);
        if (!areaA || !areaB) {
            return;
        }
        const prop = (this.direction === 'horizontal') ? 'offsetWidth' : 'offsetHeight';
        this.containerSize = this.elementRef.nativeElement[prop];
        this.areaASize = this.containerSize * areaA.size / 100;
        this.areaBSize = this.containerSize * areaB.size / 100;
        let start;
        if (startEvent instanceof MouseEvent) {
            start = {
                x: startEvent.screenX,
                y: startEvent.screenY
            };
        }
        else if (startEvent instanceof TouchEvent) {
            start = {
                x: startEvent.touches[0].screenX,
                y: startEvent.touches[0].screenY
            };
        }
        else {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.eventsDragFct.push(this.renderer.listen('document', 'mousemove', e => this.dragEvent(e, start, areaA, areaB)));
            this.eventsDragFct.push(this.renderer.listen('document', 'touchmove', e => this.dragEvent(e, start, areaA, areaB)));
        });
        // TODO check if e argument can be removed
        /*eslint-disable @typescript-eslint/no-unused-vars */
        this.eventsDragFct.push(this.renderer.listen('document', 'mouseup', e => this.stopDragging()));
        this.eventsDragFct.push(this.renderer.listen('document', 'touchend', e => this.stopDragging()));
        this.eventsDragFct.push(this.renderer.listen('document', 'touchcancel', e => this.stopDragging()));
        /*eslint-enable @typescript-eslint/no-unused-vars */
        areaA.component.lockEvents();
        areaB.component.lockEvents();
        this.isDragging = true;
        this.notify('start');
    }
    notify(type) {
        const data = this.visibleAreas.map(a => a.size);
        switch (type) {
            case 'start':
                return this.dragStart.emit(data);
            case 'progress':
                return this.dragProgress.emit(data);
            case 'end':
                return this.dragEnd.emit(data);
        }
    }
    ngOnDestroy() {
        this.stopDragging();
    }
    refresh() {
        this.stopDragging();
        const visibleAreas = this.visibleAreas;
        // ORDERS: Set css 'order' property depending on user input or added order
        const nbCorrectOrder = this.areas.filter(a => a.orderUser !== null && !isNaN(a.orderUser)).length;
        if (nbCorrectOrder === this.areas.length) {
            this.areas.sort((a, b) => +a.orderUser - +b.orderUser);
        }
        this.areas.forEach((a, i) => {
            a.order = i * 2;
            a.component.setStyle('order', a.order);
        });
        // SIZES: Set css 'flex-basis' property depending on user input or equal sizes
        const totalSize = visibleAreas.map(a => a.sizeUser).reduce((acc, s) => acc + s, 0);
        const nbCorrectSize = visibleAreas.filter(a => a.sizeUser !== null && !isNaN(a.sizeUser) && a.sizeUser >= this.minWidthPercent).length;
        if (totalSize < 99.99 || totalSize > 100.01 || nbCorrectSize !== visibleAreas.length) {
            const size = Number((100 / visibleAreas.length).toFixed(3));
            visibleAreas.forEach(a => a.size = size);
        }
        else {
            visibleAreas.forEach(a => a.size = Number(a.sizeUser));
        }
        this.refreshStyleSizes();
        SafeCdr.markForCheck(this.cdRef);
    }
    refreshStyleSizes() {
        const visibleAreas = this.visibleAreas;
        const f = this.gutterSize * this.nbGutters / visibleAreas.length;
        visibleAreas.forEach(a => a.component.setStyle('flex-basis', `calc( ${a.size}% - ${f}px )`));
    }
    dragEvent(event, start, areaA, areaB) {
        if (!this.isDragging) {
            return;
        }
        let end;
        if (event instanceof MouseEvent) {
            end = {
                x: event.screenX,
                y: event.screenY
            };
        }
        else if (event instanceof TouchEvent) {
            end = {
                x: event.touches[0].screenX,
                y: event.touches[0].screenY
            };
        }
        else {
            return;
        }
        this.drag(start, end, areaA, areaB);
    }
    drag(start, end, areaA, areaB) {
        const offsetPixel = (this.direction === 'horizontal') ? (start.x - end.x) : (start.y - end.y);
        const newSizePixelA = this.areaASize - offsetPixel;
        const newSizePixelB = this.areaBSize + offsetPixel;
        if (newSizePixelA < areaA.minPixel || newSizePixelB < areaB.minPixel) {
            return;
        }
        let newSizePercentA = newSizePixelA / this.containerSize * 100;
        let newSizePercentB = newSizePixelB / this.containerSize * 100;
        if (newSizePercentA <= this.minWidthPercent) {
            newSizePercentA = this.minWidthPercent;
            newSizePercentB = areaA.size + areaB.size - this.minWidthPercent;
        }
        else if (newSizePercentB <= this.minWidthPercent) {
            newSizePercentB = this.minWidthPercent;
            newSizePercentA = areaA.size + areaB.size - this.minWidthPercent;
        }
        else {
            newSizePercentA = Number(newSizePercentA.toFixed(3));
            newSizePercentB = Number((areaA.size + areaB.size - newSizePercentA).toFixed(3));
        }
        areaA.size = newSizePercentA;
        areaB.size = newSizePercentB;
        this.refreshStyleSizes();
        this.notify('progress');
    }
    stopDragging() {
        if (!this.isDragging) {
            return;
        }
        this.areas.forEach(a => a.component.unlockEvents());
        while (this.eventsDragFct.length > 0) {
            const fct = this.eventsDragFct.pop();
            if (fct) {
                fct();
            }
        }
        this.containerSize = 0;
        this.areaASize = 0;
        this.areaBSize = 0;
        this.isDragging = false;
        this.notify('end');
    }
    _setHeightStyle() {
        var _a;
        const element = (_a = this.elementRef) === null || _a === void 0 ? void 0 : _a.nativeElement;
        const height = (this.height && !isNaN(this.height) && this.height > 0) ? this.height + 'px' : '100%';
        this.renderer.setStyle(element, 'height', height);
    }
    _setWidthStyle() {
        var _a;
        const element = (_a = this.elementRef) === null || _a === void 0 ? void 0 : _a.nativeElement;
        const width = (this.width && !isNaN(this.width) && this.width > 0) ? this.width + 'px' : '100%';
        this.renderer.setStyle(element, 'width', width);
    }
}
AdaptSplitComponent.ɵfac = function AdaptSplitComponent_Factory(t) { return new (t || AdaptSplitComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptSplitComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptSplitComponent, selectors: [["adapt-split"]], hostVars: 4, hostBindings: function AdaptSplitComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.styleFlexDirection);
        i0.ɵɵclassProp("is-transition", ctx.dragging);
    } }, inputs: { direction: "direction", width: "width", height: "height", gutterSize: "gutterSize", disabled: "disabled", visibleTransition: "visibleTransition", minWidthPercent: "minWidthPercent" }, outputs: { dragStart: "dragStart", dragProgress: "dragProgress", dragEnd: "dragEnd" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 4, vars: 1, consts: [["ngFor", "", 3, "ngForOf"], ["adapt-split-gutter", "", 3, "order", "direction", "size", "disabled", "mousedown", "touchstart", 4, "ngIf"], ["adapt-split-gutter", "", 3, "order", "direction", "size", "disabled", "mousedown", "touchstart"], [1, "flex-area"], [1, "gripper"]], template: function AdaptSplitComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵprojectionDef();
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵprojection(1);
        i0.ɵɵtext(2, "\n    ");
        i0.ɵɵtemplate(3, AdaptSplitComponent_ng_template_3_Template, 3, 1, "ng-template", 0);
    } if (rf & 2) {
        i0.ɵɵadvance(3);
        i0.ɵɵproperty("ngForOf", ctx.areas);
    } }, directives: [i2.NgForOf, i2.NgIf, i3.AdaptSplitGutterDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptSplitComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-split',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <ng-content></ng-content>
    <ng-template ngFor let-area [ngForOf]="areas" let-index="index" let-last="last">
      <div adapt-split-gutter *ngIf="last === false && area.component.visible === true && !isLastVisibleArea(area)"
           [order]="index*2+1"
           [direction]="direction"
           [size]="gutterSize"
           [disabled]="disabled"
           (mousedown)="startDragging($event, index*2+1)"
           (touchstart)="startDragging($event, index*2+1)">
        <div class="flex-area"></div>
        <span class="gripper"></span>
      </div>
    </ng-template>`
            }]
    }], function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i1.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { direction: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], gutterSize: [{
            type: Input
        }], disabled: [{
            type: Input
        }], visibleTransition: [{
            type: Input
        }], minWidthPercent: [{
            type: Input
        }], dragStart: [{
            type: Output
        }], dragProgress: [{
            type: Output
        }], dragEnd: [{
            type: Output
        }], styleFlexDirection: [{
            type: HostBinding,
            args: ['class']
        }], dragging: [{
            type: HostBinding,
            args: ['class.is-transition']
        }] }); })();
//# sourceMappingURL=split.component.js.map