import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgZone, Optional, Output, QueryList, Renderer2, Self, ViewChild, ViewChildren, ViewEncapsulation } from '@angular/core';
import { transition, trigger, useAnimation } from '@angular/animations';
import { NgControl } from '@angular/forms';
import { take, takeUntil } from 'rxjs/operators';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularCustomEventType, AdaptRadarAngularService } from '../../common/radar/adapt-radar';
import { AdaptRxFeedbackComponent, AdaptRxFormControlDirective } from '../form-control/index';
import { ANIMATION_DURATION, ANIMATION_NAME } from '../../common/animation';
import { AdaptTranslateService } from '../../common/i18n/index';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "../../common/i18n/index";
import * as i3 from "../../common/radar/adapt-radar";
import * as i4 from "../form-control/rx-control-label/adapt-rx-control-label.component";
import * as i5 from "@angular/common";
import * as i6 from "../form-control/rx-feedback/adapt-rx-feedback.component";
const _c0 = ["adaptRxFeedbackRef"];
const _c1 = ["buttonRef"];
function AdaptRxTimeSlotComponent_div_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r7 = i0.ɵɵgetCurrentView();
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelementStart(1, "button", 7, 8);
    i0.ɵɵlistener("focus", function AdaptRxTimeSlotComponent_div_2_ng_container_1_Template_button_focus_1_listener($event) { i0.ɵɵrestoreView(_r7); const ctx_r6 = i0.ɵɵnextContext(2); return ctx_r6.focusHandler($event); })("blur", function AdaptRxTimeSlotComponent_div_2_ng_container_1_Template_button_blur_1_listener($event) { i0.ɵɵrestoreView(_r7); const ctx_r8 = i0.ɵɵnextContext(2); return ctx_r8.blurHandler($event); })("click", function AdaptRxTimeSlotComponent_div_2_ng_container_1_Template_button_click_1_listener() { const restoredCtx = i0.ɵɵrestoreView(_r7); const slot_r3 = restoredCtx.$implicit; const ctx_r9 = i0.ɵɵnextContext(2); return ctx_r9.selectSlot(slot_r3); });
    i0.ɵɵtext(3);
    i0.ɵɵelementEnd();
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const slot_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r2 = i0.ɵɵnextContext(2);
    i0.ɵɵadvance(1);
    i0.ɵɵclassProp("active", slot_r3 === ctx_r2.selectedSlot)("disabled", ctx_r2.disabled || ctx_r2.readonly);
    i0.ɵɵproperty("@slotsAnimation", undefined)("id", ctx_r2.id + "_slot-" + index_r4)("name", ctx_r2.id + "_group")("disabled", ctx_r2.disabled);
    i0.ɵɵattribute("aria-checked", slot_r3 === ctx_r2.selectedSlot)("tabindex", ctx_r2.tabIndex ? ctx_r2.tabIndex + index_r4 : undefined)("data-testid", ctx_r2.testID + "_item-" + index_r4)("aria-readonly", ctx_r2.readonly)("aria-disabled", ctx_r2.disabled)("aria-invalid", ctx_r2.hasDangerState)("aria-errormessage", ctx_r2.ariaErrorMessage);
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate(slot_r3);
} }
function AdaptRxTimeSlotComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "div", 5);
    i0.ɵɵtemplate(1, AdaptRxTimeSlotComponent_div_2_ng_container_1_Template, 4, 16, "ng-container", 6);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngForOf", ctx_r0.slots);
} }
export class AdaptRxTimeSlotComponent extends AdaptRxFormControlDirective {
    constructor(ngControl, _renderer, _changeDetectorRef, _ngZone, ts, _adaptRadarService, _elem) {
        super(ngControl, ts, _adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptRxTimeSlot, _changeDetectorRef);
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        this.ts = ts;
        this.controlName = 'timeslot';
        this.analyticsComponentName = AdaptRadarAngularCustomEventName;
        /* eslint-disable @angular-eslint/no-output-on-prefix */
        /**
         * Select slot emitter
         */
        this.onSelectedSlotChanged = new EventEmitter();
        const translation = ts.getCurrentLanguage();
        this.label = translation['adapt.timeSlot.available'];
    }
    /**
     * Check if the control has UI error state
     */
    get hasDangerState() {
        return this.adaptRxFeedbackRef.hasUIErrorState;
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this._setSlotMaxWidth();
    }
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes.slots) {
            this._ngZone.onStable
                .pipe(takeUntil(this.destroy$), take(1))
                .subscribe(() => {
                this._setSlotMaxWidth();
            });
        }
    }
    selectSlot(slot) {
        var _a;
        this._adaptRadarService.sendCustomEventForAllProviders(AdaptRadarAngularCustomEventName.AdaptRxTimeSlot, {
            GroupName: this.adaptRadarGroupName,
            EventType: AdaptRadarAngularCustomEventType.ValueChanged,
            Label: this.label,
            Required: this.required,
            ReadOnly: this.readonly,
            Disabled: this.disabled,
            Slots: (_a = this.slots) === null || _a === void 0 ? void 0 : _a.length
        });
        if (this.nonInteractive) {
            return;
        }
        this.selectedSlot = this.selectedSlot === slot ? null : slot;
        this._onChange(this.selectedSlot);
        this.onSelectedSlotChanged.emit(this.selectedSlot);
    }
    // TODO: Refactor this if possible
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    writeValue(slot) {
        this.selectedSlot = slot;
    }
    blurHandler(event) {
        super.blurHandler(event);
        this._onTouched();
    }
    /**
     * Implementation of superClass member
     */
    _focusNativeElement() {
        if (this.buttonRef && this.buttonRef.length) {
            this.buttonRef.first.nativeElement.focus();
        }
    }
    /**
     * Calculates max-widths of each slot
     */
    _setSlotMaxWidth() {
        const btnList = this.buttonRef.toArray();
        if (btnList) {
            const arr = btnList.map(item => item.nativeElement.clientWidth);
            const max = Math.round(Math.max(...arr));
            btnList.map(_ => this._renderer.setStyle(_.nativeElement, 'width', `${max}px`));
        }
    }
}
AdaptRxTimeSlotComponent.ɵfac = function AdaptRxTimeSlotComponent_Factory(t) { return new (t || AdaptRxTimeSlotComponent)(i0.ɵɵdirectiveInject(i1.NgControl, 10), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.AdaptTranslateService), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptRxTimeSlotComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptRxTimeSlotComponent, selectors: [["adapt-rx-timeslot"]], viewQuery: function AdaptRxTimeSlotComponent_Query(rf, ctx) { if (rf & 1) {
        i0.ɵɵviewQuery(_c0, 7);
        i0.ɵɵviewQuery(_c1, 5);
    } if (rf & 2) {
        let _t;
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.adaptRxFeedbackRef = _t.first);
        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.buttonRef = _t);
    } }, inputs: { slots: "slots" }, outputs: { onSelectedSlotChanged: "onSelectedSlotChanged" }, features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature], decls: 5, vars: 20, consts: [[1, "a-slot"], [3, "for", "label", "subLabel", "requiredLabel", "showRequiredLabel", "tooltip", "testID"], ["class", "a-slot__list", "role", "group", 4, "ngIf"], [3, "ariaErrorMessage", "errors", "warningMessage", "controlTouched", "messageAppeared"], ["adaptRxFeedbackRef", ""], ["role", "group", 1, "a-slot__list"], [4, "ngFor", "ngForOf"], ["type", "button", "role", "checkbox", 1, "btn", "btn-secondary", "btn-sm", 3, "id", "name", "disabled", "focus", "blur", "click"], ["buttonRef", ""]], template: function AdaptRxTimeSlotComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "div", 0);
        i0.ɵɵelement(1, "adapt-rx-control-label", 1);
        i0.ɵɵtemplate(2, AdaptRxTimeSlotComponent_div_2_Template, 2, 1, "div", 2);
        i0.ɵɵelementStart(3, "adapt-rx-feedback", 3, 4);
        i0.ɵɵlistener("messageAppeared", function AdaptRxTimeSlotComponent_Template_adapt_rx_feedback_messageAppeared_3_listener($event) { return ctx.handleMessageAppeared($event, ctx.analyticsComponentName.AdaptRxTimeSlot); });
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(4);
        i0.ɵɵclassProp("has-danger", _r1.hasUIErrorState)("has-warning", ctx.warningMessage);
        i0.ɵɵattribute("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedBy)("aria-required", ctx.required);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("for", ctx.id)("label", ctx.label)("subLabel", ctx.subLabel)("requiredLabel", ctx.requiredLabel)("showRequiredLabel", ctx.required)("tooltip", ctx.tooltip)("testID", ctx.testID);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ngIf", ctx.slots && ctx.slots.length);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("ariaErrorMessage", ctx.ariaErrorMessage)("errors", ctx.ngControl.errors)("warningMessage", ctx.warningMessage)("controlTouched", ctx.ngControl.touched);
    } }, directives: [i4.AdaptRxControlLabelComponent, i5.NgIf, i6.AdaptRxFeedbackComponent, i5.NgForOf], encapsulation: 2, data: { animation: [
            trigger('slotsAnimation', [
                transition('void => *', [
                    useAnimation(ANIMATION_NAME.opacity, {
                        params: {
                            duration: ANIMATION_DURATION.medium
                        }
                    })
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptRxTimeSlotComponent, [{
        type: Component,
        args: [{
                selector: 'adapt-rx-timeslot',
                templateUrl: './adapt-rx-timeslot.component.html',
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: false,
                animations: [
                    trigger('slotsAnimation', [
                        transition('void => *', [
                            useAnimation(ANIMATION_NAME.opacity, {
                                params: {
                                    duration: ANIMATION_DURATION.medium
                                }
                            })
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i1.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i2.AdaptTranslateService }, { type: i3.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { slots: [{
            type: Input
        }], onSelectedSlotChanged: [{
            type: Output
        }], adaptRxFeedbackRef: [{
            type: ViewChild,
            args: ['adaptRxFeedbackRef', { static: true }]
        }], buttonRef: [{
            type: ViewChildren,
            args: ['buttonRef']
        }] }); })();
//# sourceMappingURL=adapt-rx-timeslot.component.js.map