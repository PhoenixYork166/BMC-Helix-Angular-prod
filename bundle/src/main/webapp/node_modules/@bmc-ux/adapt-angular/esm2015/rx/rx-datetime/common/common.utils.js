import { animate, query, style, transition } from '@angular/animations';
import { clone, forIn, isEmpty, isNil, set } from 'lodash-es';
import { getDateFromParts } from './parse.utils';
import { getDateParts } from './partition.utils';
import { isValidDate } from './validate.utils';
import { DateTimeKey } from '../../../common/common.enums';
import { RxDatetimePickerMode } from '../adapt-rx-datetime.types';
export const SLIDE_ANIMATION = [
    transition(':increment', [
        query(':enter', [
            style({ opacity: 0, transform: 'translateX(30px)' }),
            animate('.2s ease-out', style({ opacity: 1, transform: 'translateX(0px)' }))
        ], {
            optional: true,
        })
    ]),
    transition(':decrement', [
        query(':enter', [
            style({ opacity: 0, transform: 'translateX(-30px)' }),
            animate('.2s ease-out', style({ opacity: 1, transform: 'translateX(0px)' }))
        ], {
            optional: true,
        })
    ])
];
export const SLIDE_HORIZONTAL_ANIMATION = [
    transition(':increment', [
        style({ opacity: 0, transform: 'translateX(30px)' }),
        animate('.2s ease-out', style({ opacity: '*', transform: 'translateX(0px)' }))
    ]),
    transition(':decrement', [
        style({ opacity: 0, transform: 'translateX(-30px)' }),
        animate('.2s ease-out', style({ opacity: '*', transform: 'translateX(0px)' }))
    ])
];
export const ZOOM_ANIMATION = [
    transition(':increment', [
        query(':enter', [
            style({ opacity: 0, transform: 'scale(0.9)' }),
            animate('.2s ease-out', style({ opacity: 1, transform: 'scale(1)' }))
        ], {
            optional: true,
        })
    ]),
    transition(':decrement', [
        query(':enter', [
            style({ opacity: 0, transform: 'scale(1.1)' }),
            animate('.2s ease-out', style({ opacity: 1, transform: 'scale(1)' }))
        ], {
            optional: true,
        })
    ])
];
export const CALENDAR_ROWS = 6;
export const DAYS_A_WEEK = 7;
export const MONTHS_A_YEAR = 12;
export function checkIfPropsDefined(object, props) {
    if (isEmpty(object) || isEmpty(props)) {
        return false;
    }
    return props.every(prop => {
        return !isNil(object[prop]);
    });
}
export function getDateStamp(v) {
    if (!checkIfPropsDefined(v, getDatetimeModelPropsByMode(RxDatetimePickerMode.Date, false))) {
        return null;
    }
    const jsDate = new Date(v.year, v.month, v.date, 0, 0, 0, 0);
    return jsDate.getTime();
}
export function getDateTimeStamp(v) {
    if (!checkIfPropsDefined(v, getDatetimeModelPropsByMode(RxDatetimePickerMode.DateTime, true))) {
        return null;
    }
    const jsDate = new Date(v.year, v.month, v.date, v.hours, v.minutes, v.seconds, 0);
    return jsDate.getTime();
}
export function getDatetimeModelPropsByMode(mode, hasSeconds) {
    let propsToPick;
    switch (mode) {
        case RxDatetimePickerMode.DateTime: {
            propsToPick = [DateTimeKey.Year, DateTimeKey.Month, DateTimeKey.Date, DateTimeKey.Hours, DateTimeKey.Minutes];
            if (hasSeconds) {
                propsToPick.push(DateTimeKey.Seconds);
            }
            break;
        }
        case RxDatetimePickerMode.Date: {
            propsToPick = [DateTimeKey.Year, DateTimeKey.Month, DateTimeKey.Date];
            break;
        }
        case RxDatetimePickerMode.Time: {
            propsToPick = [DateTimeKey.Hours, DateTimeKey.Minutes];
            if (hasSeconds) {
                propsToPick.push(DateTimeKey.Seconds);
            }
            break;
        }
        case RxDatetimePickerMode.YearMonth: {
            propsToPick = [DateTimeKey.Year, DateTimeKey.Month];
            break;
        }
        case RxDatetimePickerMode.Year: {
            propsToPick = [DateTimeKey.Year];
            break;
        }
        case RxDatetimePickerMode.Month: {
            propsToPick = [DateTimeKey.Month];
            break;
        }
    }
    return propsToPick;
}
export function checkIsAfter(val1, val2, allowEqual) {
    const today = getDateParts(new Date());
    const startStruct = Object.assign(Object.assign({}, today), val1);
    const endStruct = Object.assign(Object.assign({}, today), val2);
    // Normalize 2 struct objects in case of missing some props like:
    // val1: {year: null, month: 1, date: 2}; val2: {year: 2022, month: null, date: null}
    [
        DateTimeKey.Year,
        DateTimeKey.Month,
        DateTimeKey.Date,
        DateTimeKey.Hours,
        DateTimeKey.Minutes,
        DateTimeKey.Seconds,
        DateTimeKey.Milliseconds
    ].forEach((dateTimeProp) => {
        if (isNil(val1[dateTimeProp]) || isNil(val2[dateTimeProp])) {
            const newValue = val1[dateTimeProp] || val2[dateTimeProp] || today[dateTimeProp];
            startStruct[dateTimeProp] = newValue;
            endStruct[dateTimeProp] = newValue;
        }
    });
    const date1 = getDateFromParts(startStruct);
    const date2 = getDateFromParts(endStruct);
    return isValidDate(date1) && isValidDate(date2) && (allowEqual ? date1 >= date2 : date1 > date2);
}
export function getStructWithDefaults(destStruct, defaultStruct) {
    destStruct = clone(destStruct);
    if (destStruct && defaultStruct) {
        forIn(defaultStruct, (defaultPartValue, defaultPartName) => {
            if (isNil(destStruct[defaultPartName])) {
                set(destStruct, defaultPartName, defaultPartValue);
            }
        });
    }
    return destStruct;
}
//# sourceMappingURL=common.utils.js.map