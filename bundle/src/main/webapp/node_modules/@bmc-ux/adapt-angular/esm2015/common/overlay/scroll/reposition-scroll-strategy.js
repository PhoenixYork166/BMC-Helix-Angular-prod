import { fromEvent } from 'rxjs';
import { auditTime } from 'rxjs/operators';
export class AdaptRepositionScrollStrategy {
    constructor(_viewportRuler, _ngZone, _config) {
        this._viewportRuler = _viewportRuler;
        this._ngZone = _ngZone;
        this._config = _config;
        this._scrollSubscription = null;
    }
    /**
     * Attaches this scroll strategy to an overlay
     */
    attach(overlayRef) {
        this._overlayRef = overlayRef;
    }
    /**
     * Enables repositioning of the attached overlay on scroll
     */
    enable() {
        var _a;
        if (!this._scrollSubscription) {
            const throttle = this._config ? this._config.scrollThrottle : 0;
            this._ngZone.runOutsideAngular(() => {
                this._scrollSubscription =
                    fromEvent(window, 'scroll', { capture: true })
                        .pipe(auditTime(throttle))
                        .subscribe((event) => {
                        // Update position only in case outer scroll happens
                        if (!this._overlayRef.overlayElement.contains(event.target)) {
                            this._overlayRef.updatePosition();
                        }
                    });
            });
            if ((_a = this._config) === null || _a === void 0 ? void 0 : _a.autoClose) {
                this._overlayRefOriginIntersectObserver = new IntersectionObserver(([entry], observer) => {
                    if (!entry.isIntersecting) {
                        this._ngZone.run(() => {
                            this._overlayRef.detach();
                            observer.disconnect();
                        });
                    }
                }, { root: null, threshold: 0 });
                this._overlayRefOriginIntersectObserver.observe(this._overlayRef.getConfig().positionStrategy._origin);
            }
        }
    }
    /**
     * Disables repositioning of the attached overlay on scroll
     */
    disable() {
        if (this._scrollSubscription) {
            this._scrollSubscription.unsubscribe();
            this._scrollSubscription = null;
        }
        if (this._overlayRefOriginIntersectObserver) {
            this._overlayRefOriginIntersectObserver.disconnect();
            this._overlayRefOriginIntersectObserver = null;
        }
    }
    /**
     * Detaches the scroll listener
     */
    detach() {
        this.disable();
        this._overlayRef = null;
    }
}
//# sourceMappingURL=reposition-scroll-strategy.js.map