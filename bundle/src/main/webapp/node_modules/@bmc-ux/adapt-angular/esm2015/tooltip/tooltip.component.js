import { Component, ElementRef, HostBinding, Input, NgZone, Renderer2, TemplateRef, ViewEncapsulation } from '@angular/core';
import { animate, state, style, transition, trigger, useAnimation } from '@angular/animations';
import { distinctUntilChanged, take, takeUntil } from 'rxjs/operators';
import { fromPromise } from 'rxjs/internal-compatibility';
import { ReplaySubject } from 'rxjs';
import { ANIMATION_DURATION, ANIMATION_NAME, ANIMATION_TIMING_FUNCTION } from '../common/animation';
import { TooltipPlacement } from '../common/positioning';
import { AdaptOverlayService } from '../common/overlay/index';
import { TooltipService } from './tooltip.service';
import { AdaptRadarAngularCustomEventName, AdaptRadarAngularGenericDirective, AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
import * as i1 from "./tooltip.service";
import * as i2 from "../common/overlay/index";
import * as i3 from "../common/radar/adapt-radar";
import * as i4 from "@angular/common";
function AdaptTooltipComponent_3_ng_template_0_Template(rf, ctx) { }
function AdaptTooltipComponent_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, AdaptTooltipComponent_3_ng_template_0_Template, 0, 0, "ng-template");
} }
function AdaptTooltipComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r2 = i0.ɵɵnextContext();
    i0.ɵɵtextInterpolate(ctx_r2.content);
} }
function AdaptTooltipComponent_ng_template_8_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function AdaptTooltipComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtext(0, "\n        ");
    i0.ɵɵtemplate(1, AdaptTooltipComponent_ng_template_8_ng_container_1_Template, 1, 0, "ng-container", 4);
    i0.ɵɵtext(2, "\n      ");
} if (rf & 2) {
    const ctx_r4 = i0.ɵɵnextContext();
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r4.content)("ngTemplateOutletContext", ctx_r4.context);
} }
export class AdaptTooltipComponent extends AdaptRadarAngularGenericDirective {
    constructor(tooltipService, renderer, ngZone, element, _overlayService, _adaptRadarService, _elem) {
        super(_adaptRadarService, _elem, AdaptRadarAngularCustomEventName.AdaptTooltip);
        this.tooltipService = tooltipService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.element = element;
        this._overlayService = _overlayService;
        // TODO: Refactor this if possible
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.context = {};
        this.useWidthFitting = true;
        this.adjustedWidthMargin = 20;
        this._translatePoint = null;
        this._visible = false;
        this._destroyed$ = new ReplaySubject(1);
    }
    get w() {
        if (this._width) {
            return `${this._width}`;
        }
        if (this._maxWidthForFitting) {
            return `${this._maxWidthForFitting}px`;
        }
        return 'none';
    }
    get translate() {
        if (this._translatePoint) {
            return `translate(${this._translatePoint.x}px, ${this._translatePoint.y}px)`;
        }
        return;
    }
    get hostCls() {
        const cls = ['adapt-tooltip'];
        if (this._overlayService.enableCDKOverlayControl) {
            cls.push('position-static');
        }
        if (this.customCls) {
            cls.push(this.customCls);
        }
        return cls.join(' ');
    }
    get currentPlacement() {
        return this._currentPlacement;
    }
    get placement() {
        return this._placement;
    }
    set placement(c) {
        this._placement = c;
        this._currentPlacement = c;
    }
    set width(w) {
        this._width = w;
    }
    get visible() {
        return this._visible;
    }
    set visible(v) {
        this._visible = v;
    }
    ngOnInit() {
        this._currentPlacement = this.placement;
    }
    setPosition(target) {
        if (this.placement === TooltipPlacement.Auto) {
            this._setAutoPosition(target);
        }
        else {
            this._setFixedPosition(target);
            this.adjustMaxWidthForViewportFitting(target);
        }
    }
    setMinWidth(minWidth) {
        this.renderer.setStyle(this.element.nativeElement, 'minWidth', minWidth);
    }
    updatePosition(x, y) {
        this.setPositionStyles(this.tooltipService.getActualPosition(x, y));
        this._translatePoint = null;
    }
    isTemplate() {
        return this.content instanceof TemplateRef;
    }
    ngOnDestroy() {
        this._destroyed$.next(true);
        this._destroyed$.complete();
    }
    setPositionStyles(point) {
        this.renderer.setStyle(this.element.nativeElement, 'left', `${point.x}px`);
        this.renderer.setStyle(this.element.nativeElement, 'top', `${point.y}px`);
    }
    adjustMaxWidthForViewportFitting(target) {
        const placement = this._currentPlacement;
        if (this.useWidthFitting) {
            this.ngZone.onStable.pipe(takeUntil(this._destroyed$), take(1)).subscribe(() => {
                const rect = this.element.nativeElement.getBoundingClientRect();
                if (rect.left < 0) {
                    if (placement === TooltipPlacement.Top || placement === TooltipPlacement.Bottom) {
                        this._maxWidthForFitting = rect.width + ((rect.left - this.adjustedWidthMargin) * 2);
                    }
                    else if (placement === TooltipPlacement.Left) {
                        this._maxWidthForFitting = rect.width + rect.left - this.adjustedWidthMargin;
                    }
                }
                this.renderer.setStyle(this.element.nativeElement, 'maxWidth', this.w);
            });
        }
        else {
            this._maxWidthForFitting = null;
        }
        setTimeout(() => {
            this._translatePoint = this.tooltipService.getFixedPosition(target, this.placement).translatePoint;
        });
    }
    _setFixedPosition(target) {
        // need to reset values for new tooltip
        this.renderer.setStyle(this.element.nativeElement, 'maxWidth', 'initial');
        this.renderer.setStyle(this.element.nativeElement, 'transform', this.translate);
        const { point } = this.tooltipService.getFixedPosition(target, this.placement);
        this.setPositionStyles(point);
    }
    _setAutoPosition(target) {
        fromPromise(this.tooltipService.getAutoPosition(target))
            .pipe(takeUntil(this._destroyed$), distinctUntilChanged())
            .subscribe(({ point, placement }) => {
            this.setPositionStyles(point);
            this._currentPlacement = placement;
            this.adjustMaxWidthForViewportFitting(target);
        });
    }
}
AdaptTooltipComponent.ɵfac = function AdaptTooltipComponent_Factory(t) { return new (t || AdaptTooltipComponent)(i0.ɵɵdirectiveInject(i1.TooltipService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.AdaptOverlayService), i0.ɵɵdirectiveInject(i3.AdaptRadarAngularService), i0.ɵɵdirectiveInject(i0.ElementRef)); };
AdaptTooltipComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: AdaptTooltipComponent, selectors: [["ng-component"]], hostVars: 6, hostBindings: function AdaptTooltipComponent_HostBindings(rf, ctx) { if (rf & 2) {
        i0.ɵɵclassMap(ctx.hostCls);
        i0.ɵɵstyleProp("max-width", ctx.w)("transform", ctx.translate);
    } }, inputs: { customCls: "customCls", content: "content", context: "context", useWidthFitting: "useWidthFitting", adjustedWidthMargin: "adjustedWidthMargin", id: "id", placement: "placement", width: "width" }, features: [i0.ɵɵProvidersFeature([TooltipService]), i0.ɵɵInheritDefinitionFeature], decls: 12, vars: 6, consts: [["role", "tooltip", 1, "adapt-tooltip-inner", 3, "id"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["text", ""], ["tpl", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function AdaptTooltipComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtext(0, "\n    ");
        i0.ɵɵelementStart(1, "div", 0);
        i0.ɵɵtext(2, "\n      ");
        i0.ɵɵtemplate(3, AdaptTooltipComponent_3_Template, 1, 0, undefined, 1);
        i0.ɵɵtext(4, "\n      ");
        i0.ɵɵtemplate(5, AdaptTooltipComponent_ng_template_5_Template, 1, 1, "ng-template", null, 2, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(7, "\n      ");
        i0.ɵɵtemplate(8, AdaptTooltipComponent_ng_template_8_Template, 3, 2, "ng-template", null, 3, i0.ɵɵtemplateRefExtractor);
        i0.ɵɵtext(10, "\n    ");
        i0.ɵɵelementEnd();
        i0.ɵɵtext(11, "\n  ");
    } if (rf & 2) {
        const _r1 = i0.ɵɵreference(6);
        const _r3 = i0.ɵɵreference(9);
        i0.ɵɵadvance(1);
        i0.ɵɵproperty("id", ctx.visible ? ctx.id : undefined)("@show", ctx.visible)("@overlayTooltipAnimation", undefined);
        i0.ɵɵadvance(2);
        i0.ɵɵproperty("ngIf", ctx.isTemplate())("ngIfThen", _r3)("ngIfElse", _r1);
    } }, directives: [i4.NgIf, i4.NgTemplateOutlet], encapsulation: 2, data: { animation: [
            trigger('show', [
                state('0', style({
                    display: 'none',
                    opacity: 0
                })),
                state('1', style({
                    opacity: 1
                })),
                transition('0 => 1', [
                    style({
                        display: 'block'
                    }),
                    animate(`${ANIMATION_DURATION.slow} ${ANIMATION_TIMING_FUNCTION.base.floatInOut}`)
                ]),
                transition('1 => 0', animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.floatInOut}`))
            ]),
            trigger('overlayTooltipAnimation', [
                transition(':enter', [
                    useAnimation(ANIMATION_NAME.opacity)
                ])
            ])
        ] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(AdaptTooltipComponent, [{
        type: Component,
        args: [{
                template: `
    <div class="adapt-tooltip-inner"
         role="tooltip"
         [id]="visible ? id : undefined"
         [@show]="visible"
         [@overlayTooltipAnimation]>
      <ng-template *ngIf="isTemplate(); then tpl; else text"></ng-template>
      <ng-template #text>{{ content }}</ng-template>
      <ng-template #tpl>
        <ng-container *ngTemplateOutlet="content; context: context"></ng-container>
      </ng-template>
    </div>
  `,
                providers: [TooltipService],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('show', [
                        state('0', style({
                            display: 'none',
                            opacity: 0
                        })),
                        state('1', style({
                            opacity: 1
                        })),
                        transition('0 => 1', [
                            style({
                                display: 'block'
                            }),
                            animate(`${ANIMATION_DURATION.slow} ${ANIMATION_TIMING_FUNCTION.base.floatInOut}`)
                        ]),
                        transition('1 => 0', animate(`${ANIMATION_DURATION.fast} ${ANIMATION_TIMING_FUNCTION.base.floatInOut}`))
                    ]),
                    trigger('overlayTooltipAnimation', [
                        transition(':enter', [
                            useAnimation(ANIMATION_NAME.opacity)
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: i1.TooltipService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i2.AdaptOverlayService }, { type: i3.AdaptRadarAngularService }, { type: i0.ElementRef }]; }, { customCls: [{
            type: Input
        }], content: [{
            type: Input
        }], context: [{
            type: Input
        }], useWidthFitting: [{
            type: Input
        }], adjustedWidthMargin: [{
            type: Input
        }], id: [{
            type: Input
        }], w: [{
            type: HostBinding,
            args: ['style.max-width']
        }], translate: [{
            type: HostBinding,
            args: ['style.transform']
        }], hostCls: [{
            type: HostBinding,
            args: ['class']
        }], placement: [{
            type: Input
        }], width: [{
            type: Input
        }] }); })();
//# sourceMappingURL=tooltip.component.js.map