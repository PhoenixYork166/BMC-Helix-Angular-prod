import { AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, Injector, NgZone, OnDestroy, OnInit, QueryList, Renderer2, TemplateRef } from '@angular/core';
import { ControlValueAccessor, Validators } from '@angular/forms';
import { AnimationEvent } from '@angular/animations';
import { Observable, OperatorFunction, ReplaySubject } from 'rxjs';
import { AdaptDeviceDetectionService } from '../common/device-detection.service';
import { AdaptTranslateService } from '../common/i18n/index';
import { FormComponent, ValidationError } from '../common/form.component';
import { Func, KeyValueObject, ValueOrFunc2 } from '../common/common.models';
import { AdaptTruncatePipe, TruncateConfig, TruncatedTextData } from '../common/truncated.pipe';
import { AdaptRxControlLabelTooltip } from '../rx/form-control/index';
import { AdaptRxTypeaheadComponent, RxTypeaheadResultTemplateContext, RxTypeaheadSelectItemEvent } from '../rx/rx-typeahead/index';
import { AddTagEvent, InitTagEditingEvent, RemoveTagEvent, TagStyleFormatterParam, TagTemplateData, TagType } from './metatag.types';
import { AdaptRadarAngularService } from '../common/radar/adapt-radar';
import * as i0 from "@angular/core";
export declare function getTagText(tag: TagType): string;
export declare class AdaptMetatagComponent extends FormComponent implements ControlValueAccessor, OnInit, AfterContentInit, OnDestroy, Validators {
    private _renderer;
    truncatePipe: AdaptTruncatePipe;
    private _ngZone;
    private _devDetection;
    private _changeDetectorRef;
    context: any;
    items: TagType[];
    isValid: boolean;
    inputValue: string;
    getTagText: Function;
    defaultTexts: {
        placeholder?: string;
        mainErrorText?: string;
    };
    /**
     * Label icon with a tooltip or popover
     */
    tooltipConfig: AdaptRxControlLabelTooltip;
    isMobile: boolean;
    typeaheadFn: OperatorFunction<string, any[]>;
    /**
     * Destroy subject
     */
    readonly destroy$: ReplaySubject<boolean>;
    /**
     * Sets the prefix label to the field
     * @docs-default
     */
    prefix: string;
    /**
     * Sets the suffix label to the field
     * @docs-default
     */
    suffix: string;
    /**
     * Sets max characters length to the tag
     * (while tag length is bigger than [maxTagLength], the tag is being truncated)
     * @docs-default
     */
    maxTagLength: number;
    /**
     * Sets middle truncation with hard prefix limit and hard suffix limit
     * @docs-default
     */
    truncateConfig: TruncateConfig;
    /**
     * Sets the ID of the component instance
     * @docs-default auto-generated
     */
    id: string;
    testID: string;
    /**
     * Sets the name of the component instance
     * @docs-default auto-generated
     */
    name: string;
    ariaLabel: string;
    /**
     * A function to transform the provided observable text into the array of results.
     * Note that the "this" argument is undefined so you need to explicitly bind it to a desired "this" target
     * @docs-default OperatorFunction<string, any[]>
     */
    set search(searchFn: OperatorFunction<string, any[]>);
    get search(): OperatorFunction<string, any[]>;
    /**
     * The maximum height of input component
     * @docs-default 100
     */
    maxHeight: number;
    /**
     * Manages the ability to create tags by Enter key pressing
     * @docs-default false
     */
    suppressManual: boolean;
    /**
     * Allows to set up the label for the field
     * @docs-default
     */
    label: string;
    /**
     * A placeholder string for the input filed
     * @docs-default Start typing
     */
    placeholder: string;
    /**
     * An error message for tag item validation
     * @docs-default Incorrect value
     */
    mainErrorText: string;
    /**
     *
     */
    warningStateText: string;
    /**
     * Allows to set up the width for the field
     * @docs-default 100%
     */
    width: string;
    /**
     * Callback for error checking on each tag item
     * @docs-default (tag) => false
     */
    errorCheck: (tag: TagType) => boolean;
    /**
     * Callback for warning checking on each tag item
     * @docs-default (tag) => false
     */
    warningCheck: (tag: TagType) => boolean;
    /**
     * Template for dropdown item
     * @docs-default
     */
    selectItemTemplate: TemplateRef<RxTypeaheadResultTemplateContext>;
    /**
     * A template to override a matching result default display
     * @docs-default
     */
    tagTemplate: TemplateRef<TagTemplateData>;
    /**
     * If true then in writeValue method will make model copy, otherwise will concatenate to existing items
     * @docs-default
     */
    replaceModelOnWrite: boolean;
    /**
     * When a user inputs this symbol, the component creates new tag
     * @docs-default ,
     */
    delimiterSymbol: string;
    /**
     * Custom class for the dropdown menu
     * @docs-default
     */
    popupClass: string;
    /**
     * Making input disabled and prevent creating new tags
     * @docs-default
     */
    disabledInput: boolean;
    /**
     * When true, opens popup when user focus on element
     * @docs-default
     */
    openDropdownOnFocus: boolean;
    selectItemFormatter: (value: TagType) => string;
    /**
     * This input controls using full container width for editing tags
     * @docs-default
     * @since v11.11.0
     */
    fullWidthEdit: boolean;
    /**
     * Formatter that changes tag's style. This function should return object with type <Partial<CSSStyleDeclaration>>
     * Takes TagFormatterParam as parameters
     * @docs-default
     * @since v12.23.0
     */
    tagStyleFormatter: ValueOrFunc2<Partial<CSSStyleDeclaration>, TagStyleFormatterParam>;
    /**
     * The event firing on field focus
     */
    readonly focus: EventEmitter<FocusEvent>;
    /**
     * The event firing on field blur
     */
    readonly blur: EventEmitter<FocusEvent>;
    /**
     * The event firing on tag remove
     */
    readonly removeTag: EventEmitter<RemoveTagEvent>;
    /**
     * The event firing on tag add
     * @since v12.14.0
     */
    readonly addTag: EventEmitter<AddTagEvent>;
    /**
     * The event firing on tag edit
     */
    readonly initTagEditing: EventEmitter<InitTagEditingEvent>;
    get hostClasses(): string;
    get focused(): boolean;
    adaptRxTypeaheadComponent: AdaptRxTypeaheadComponent;
    inputWrp: ElementRef<HTMLDivElement>;
    container: ElementRef<HTMLDivElement>;
    metatag: ElementRef<HTMLDivElement>;
    tagItemList: QueryList<ElementRef>;
    tagItemWrpList: QueryList<ElementRef>;
    get inputSizeAttr(): number;
    get isEmpty(): boolean;
    get isWarnings(): boolean;
    get hasAllTagsErrors(): boolean;
    get hasNotAllTagsErrors(): boolean;
    get isAllWarnings(): boolean;
    private get _isLabelError();
    private get _isCurrentlyActive();
    private get _currentCursorPosition();
    set value(v: TagType[]);
    get value(): TagType[];
    private _value;
    private _isAdded;
    private _docListenerFn;
    private _isEditingTag;
    private _activeTabIndex;
    private _search;
    private _closeBtnText;
    static NullSearch(): Observable<null>;
    constructor(_renderer: Renderer2, injector: Injector, truncatePipe: AdaptTruncatePipe, _ngZone: NgZone, _devDetection: AdaptDeviceDetectionService, _changeDetectorRef: ChangeDetectorRef, ts: AdaptTranslateService, _adaptRadarService: AdaptRadarAngularService, _elem: ElementRef<HTMLElement>);
    ngOnInit(): void;
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    writeValue(value: TagType[]): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    getContainerClass(): string[];
    getTruncatedTagModel(tag: TagType): TruncatedTextData;
    removeItem(event: MouseEvent | KeyboardEvent, index: number, focusOnInputField: boolean): void;
    emitModelChange(): void;
    onKeyDown(event: KeyboardEvent, value: string): void;
    onInput(event: Event): void;
    onTagAnimationDone(event: AnimationEvent): void;
    isCurrentTagActive(index: number): boolean;
    getTagTooltipFunc(tagTextContainer: HTMLElement, tag: TagType): Func<string>;
    getRemoveTagBtnText(tag: TagType): string;
    onSelect(event: RxTypeaheadSelectItemEvent): void;
    onFocus(event: FocusEvent): void;
    onBlur(event: FocusEvent): void;
    focusOnInputField(options?: FocusOptions): void;
    onFieldContainerClick(event: MouseEvent): void;
    itemDblClick(index: number): void;
    /**
     * Function to handle tag item click on mobile devices
     */
    itemClick(event: MouseEvent, index: number): void;
    validate(): {
        tagError: {
            name: string;
            text: string;
        };
    } | null;
    getInputStyle(): KeyValueObject;
    trackByForErrors(index: number, error: ValidationError): string | number;
    trackByForTags(index: number, item: string): string | number;
    getTagStyle(index: number, item: TagType): Partial<CSSStyleDeclaration>;
    private _recalculateIndex;
    private _onTagEdit;
    private _onTouchedCallback;
    private _removeDuplicates;
    private _addTag;
    private _cleanField;
    private _onDocumentClick;
    private _resetInputElem;
    private _defaultItemFormatter;
    private _getTagStyleConfig;
    private _getTextColor;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptMetatagComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AdaptMetatagComponent, "adapt-metatag, adapt-tag-field", never, { "prefix": "prefix"; "suffix": "suffix"; "maxTagLength": "maxTagLength"; "truncateConfig": "truncateConfig"; "id": "id"; "testID": "testID"; "name": "name"; "ariaLabel": "ariaLabel"; "search": "search"; "maxHeight": "maxHeight"; "suppressManual": "suppressManual"; "label": "label"; "placeholder": "placeholder"; "mainErrorText": "mainErrorText"; "warningStateText": "warningStateText"; "width": "width"; "errorCheck": "errorCheck"; "warningCheck": "warningCheck"; "selectItemTemplate": "selectItemTemplate"; "tagTemplate": "tagTemplate"; "replaceModelOnWrite": "replaceModelOnWrite"; "delimiterSymbol": "delimiterSymbol"; "popupClass": "popupClass"; "disabledInput": "disabledInput"; "openDropdownOnFocus": "openDropdownOnFocus"; "selectItemFormatter": "selectItemFormatter"; "fullWidthEdit": "fullWidthEdit"; "tagStyleFormatter": "tagStyleFormatter"; }, { "focus": "focus"; "blur": "blur"; "removeTag": "removeTag"; "addTag": "addTag"; "initTagEditing": "initTagEditing"; }, never, never>;
}
