import * as i0 from '@angular/core';
import { EventEmitter, PLATFORM_ID, Component, ChangeDetectionStrategy, Inject, Input, Output, ViewChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import * as kjua from 'kjua-svg';

class NgxKjuaComponent {
    constructor(platformId) {
        this.platformId = platformId;
        /**
         * render method
         */
        this.render = "svg";
        /**
         * render pixel-perfect lines
         */
        this.crisp = true;
        /**
         * minimum version= 1..40
         */
        this.minVersion = 1;
        /**
         * error correction level
         */
        this.ecLevel = "L";
        /**
         * size in pixel
         */
        this.size = 200;
        /**
         * pixel-ratio; undefined for devicePixelRatio
         */
        this.ratio = undefined;
        /**
         * code color
         */
        this.fill = "#333";
        /**
         * background color
         */
        this.back = "#fff";
        /**
         * content
         */
        this.text = "";
        /**
         * roundend corners in pc= 0..100
         */
        this.rounded = 0;
        /**
         * quiet zone in modules
         */
        this.quiet = 0;
        /**
         * modes
         */
        this.mode = "plain";
        /**
         * label/image size and pos in pc= 0..100
         */
        this.mSize = 30;
        this.mPosX = 50;
        this.mPosY = 50;
        this.image = undefined;
        this.imageAsCode = false;
        /**
         * label
         */
        this.label = "";
        this.fontname = "sans-serif";
        this.fontcolor = "#333";
        this.fontoutline = true;
        /**
         * If true, rendering is done inside "requestAnimationFrame"-call.
         * Use this if you want to generate more than one code (e.g. batch)
         */
        this.renderAsync = false;
        this.codeFinished = new EventEmitter();
        this.viewInitialized = false;
    }
    ngAfterViewInit() {
        this.viewInitialized = true;
        this.updateView();
    }
    ngOnChanges(changes) {
        if (this.viewInitialized) {
            this.updateView();
        }
    }
    get template() {
        const settings = {
            render: this.render,
            crisp: this.crisp,
            minVersion: this.minVersion,
            ecLevel: this.ecLevel,
            size: this.size,
            ratio: this.ratio,
            fill: this.fill,
            back: this.back,
            text: this.text,
            rounded: this.rounded,
            quiet: this.quiet,
            mode: this.mode,
            mSize: this.mSize,
            mPosX: this.mPosX,
            mPosY: this.mPosY,
            label: this.label,
            fontname: this.fontname,
            fontcolor: this.fontcolor,
            image: this.image,
            fontoutline: this.fontoutline,
            imageAsCode: this.imageAsCode,
            elementId: this.elementId
        };
        return kjua(settings);
    }
    renderCode() {
        this.div.nativeElement.innerHTML = "";
        const node = this.template;
        this.div.nativeElement.appendChild(node);
        this.codeFinished.next(node);
    }
    updateView() {
        this.div.nativeElement.style.width = +this.size;
        this.div.nativeElement.style.height = +this.size;
        if (typeof this.image === "string") {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                if (this.renderAsync) {
                    requestAnimationFrame(() => this.renderCode());
                }
                else {
                    this.renderCode();
                }
            };
            img.src = 'data:image/png;base64,' + this.image;
        }
        else {
            if (this.renderAsync) {
                requestAnimationFrame(() => this.renderCode());
            }
            else {
                this.renderCode();
            }
        }
    }
}
NgxKjuaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.6", ngImport: i0, type: NgxKjuaComponent, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });
NgxKjuaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.6", type: NgxKjuaComponent, selector: "ngx-kjua", inputs: { render: "render", crisp: "crisp", minVersion: "minVersion", ecLevel: "ecLevel", size: "size", ratio: "ratio", fill: "fill", back: "back", text: "text", rounded: "rounded", quiet: "quiet", mode: "mode", mSize: "mSize", mPosX: "mPosX", mPosY: "mPosY", image: "image", imageAsCode: "imageAsCode", label: "label", fontname: "fontname", fontcolor: "fontcolor", fontoutline: "fontoutline", renderAsync: "renderAsync", cssClass: "cssClass", elementId: "elementId" }, outputs: { codeFinished: "codeFinished" }, viewQueries: [{ propertyName: "div", first: true, predicate: ["elem"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div [class]="cssClass" #elem></div>`, isInline: true, styles: [":host{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.6", ngImport: i0, type: NgxKjuaComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "ngx-kjua",
                    template: `
    <div [class]="cssClass" #elem></div>`,
                    styles: [`
    :host {
      display: block;
    }
  `],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () {
        return [{ type: Object, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }];
    }, propDecorators: { render: [{
                type: Input
            }], crisp: [{
                type: Input
            }], minVersion: [{
                type: Input
            }], ecLevel: [{
                type: Input
            }], size: [{
                type: Input
            }], ratio: [{
                type: Input
            }], fill: [{
                type: Input
            }], back: [{
                type: Input
            }], text: [{
                type: Input
            }], rounded: [{
                type: Input
            }], quiet: [{
                type: Input
            }], mode: [{
                type: Input
            }], mSize: [{
                type: Input
            }], mPosX: [{
                type: Input
            }], mPosY: [{
                type: Input
            }], image: [{
                type: Input
            }], imageAsCode: [{
                type: Input
            }], label: [{
                type: Input
            }], fontname: [{
                type: Input
            }], fontcolor: [{
                type: Input
            }], fontoutline: [{
                type: Input
            }], renderAsync: [{
                type: Input
            }], cssClass: [{
                type: Input
            }], elementId: [{
                type: Input
            }], codeFinished: [{
                type: Output
            }], div: [{
                type: ViewChild,
                args: ["elem"]
            }] } });

class NgxKjuaModule {
}
NgxKjuaModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.6", ngImport: i0, type: NgxKjuaModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgxKjuaModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.2.6", ngImport: i0, type: NgxKjuaModule, declarations: [NgxKjuaComponent], imports: [CommonModule], exports: [NgxKjuaComponent] });
NgxKjuaModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.2.6", ngImport: i0, type: NgxKjuaModule, imports: [[
            CommonModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.6", ngImport: i0, type: NgxKjuaModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        NgxKjuaComponent
                    ],
                    exports: [
                        NgxKjuaComponent
                    ]
                }]
        }] });

class QrCodeHelper {
    /**
     *  Make the code for creating an SMS.
     *  Number can be provided as number or string (useful for international format e.g. +1 for USA)
     *
     * @paramnumber
     * @param text
     */
    static makeSMS(number, text) {
        if (text) {
            if (text.length > 160) {
                return `SMSTO:${number}:${text.substr(0, 160)}`;
            }
            else {
                return `SMSTO:${number}:${text}`;
            }
        }
        else {
            return `SMSTO:${number}`;
        }
    }
    /**
     * Make the code for making a phone call
     * Number can be provided as number or string (useful for international format e.g. +1 for USA)
     *
     * @param number
     */
    static makeCall(number) {
        return `tel:${number}`;
    }
    /**
     * Make the code for encoding a location
     *
     * @param lat
     * @param lon
     * @param meters
     */
    static makeGeo(lat, lon, meters = 400) {
        return `geo:${lat},${lon},${meters}`;
    }
    /**
     * Make the code for encoding an event in iCal format
     * You have to do the encoding for the begin and end by yourself (use moment.js!)
     *
     * @param description
     * @param begin
     * @param end
     */
    static makeEvent(description, begin, end) {
        return `BEGIN:VEVENT
SUMMARY:${description}
DTSTART:${begin}
DTEND:${end}
END:VEVENT`;
    }
    /**
     * Make the code for an Email
     *
     * @param recipient
     * @param subject
     * @param text
     */
    static makeEmail(recipient, subject, text) {
        let retVal = `MATMSG:TO:${recipient};`;
        if (subject) {
            retVal += `SUB:${subject}`;
        }
        retVal += `;`;
        if (text) {
            retVal += `BODY:${text}`;
        }
        retVal += `;;`;
        return retVal;
    }
    /**
     * Make the code that lets user login to a WiFi
     * If no pass is provided, the WiFi is considered as not encrypted (no WPA)
     *
     * @param ssid
     * @param pass
     * @param hidden
     */
    static makeWifi(ssid, pass, hidden = false) {
        let retVal = `WIFI:${!!pass ? "T:WPA" : "T:nopass"};S:${ssid};`;
        if (pass) {
            retVal += `P:${pass}`;
        }
        retVal += `;`;
        if (hidden) {
            retVal += `H:true`;
        }
        retVal += `;`;
        return retVal;
    }
    /**
     * Make the code that encodes contact information.
     * Numbers can be provided as number or string (useful for international format e.g. +1 for USA)
     * Encoding is done with MECARD-format and NOT VCard! VCard gives a longer string and therefore a
     * bigger code which has a negative impact on readability for scanners. You can, of course, create
     * a VCard string as well but the format is more complex.
     *
     * @param name
     * @param telNumbers
     * @param address, values separated with comma
     * @param email
     * @param url
     */
    static makeContactMeCard(name, telNumbers, address, email, url) {
        let retVal = `MECARD:N:${name};`;
        if (address) {
            retVal += `ADR:${address};`;
        }
        if (telNumbers && telNumbers.length > 0) {
            for (let i = 0; i < telNumbers.length; i++) {
                retVal += `TEL:${telNumbers[i]};`;
            }
        }
        if (email) {
            retVal += `EMAIL:${email};`;
        }
        if (url) {
            retVal += `URL:${url};`;
        }
        retVal += `;`;
        return retVal;
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { NgxKjuaComponent, NgxKjuaModule, QrCodeHelper };
//# sourceMappingURL=ngx-kjua.mjs.map
